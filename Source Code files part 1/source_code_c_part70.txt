] ) ) )
		{
			DWORD dwRequestedIndex = _ttoi ( sTemp ) ;

// sanity check: gotta have right number of digits, etc...

			int length = sTemp.GetLength () ;

			BOOL t_Status = ( \
								( ( dwRequestedIndex < 10 ) && ( length == 1 ) ) || \
								( ( dwRequestedIndex > 9  ) && ( dwRequestedIndex < 100  )  && ( length == 2 ) ) || \
								( ( dwRequestedIndex > 99 ) && ( dwRequestedIndex < 1000 )  && ( length == 3 ) ) \
							) ;

			if ( t_Status )
			{
				hRetCode = GetPhysDiskInfoNT ( pInstance , sDeviceID, dwRequestedIndex, dwProperties, FALSE ) ;
			}
		}
	}

#endif

    return hRetCode ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskDrive::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each physical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DiskDrive :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
    return Enumerate(pMethodContext, lFlags, BIT_ALL_PROPS);
}

HRESULT CWin32DiskDrive::Enumerate(
	MethodContext *pMethodContext,
	long lFlags,
    DWORD dwProperties)
{
    HRESULT	hres = WBEM_E_FAILED;

#ifdef NTONLY

	HDEVINFO					DeviceInfoSet	= INVALID_HANDLE_VALUE;
	SP_DEVINFO_DATA				DeviceInfoData;
	SP_INTERFACE_DEVICE_DATA	DeviceInterfaceData;

	::ZeroMemory ( &DeviceInfoData, sizeof ( SP_DEVINFO_DATA ) );
	DeviceInfoData.cbSize = sizeof ( SP_DEVINFO_DATA );

	::ZeroMemory ( &DeviceInterfaceData, sizeof ( SP_INTERFACE_DEVICE_DATA ) );
	DeviceInterfaceData.cbSize	= sizeof ( SP_INTERFACE_DEVICE_DATA );

	GUID		ClassGuid		= GUID_DEVINTERFACE_DISK;
	DWORD		MemberIndex		= 0;

	// get device list
	DeviceInfoSet = SetupDiGetClassDevs	(	&ClassGuid, 
											NULL, 
											NULL, 
											DIGCF_INTERFACEDEVICE
										);

	if ( DeviceInfoSet != INVALID_HANDLE_VALUE )
	{
		BOOL bContinue = TRUE;
		hres = WBEM_S_NO_ERROR;

		// enumerate list
		while (bContinue && SetupDiEnumDeviceInterfaces	(	DeviceInfoSet,
												NULL,
												&ClassGuid,
												MemberIndex,
												&DeviceInterfaceData
											)
			  )
		{
			PSP_INTERFACE_DEVICE_DETAIL_DATA	pDeviceInterfaceDetailData		= NULL;
			DWORD								DeviceInterfaceDetailDataSize	= 0L;
			DWORD								RequiredSize					= 0L;

			if ( ! SetupDiGetDeviceInterfaceDetail	(	DeviceInfoSet,
														&DeviceInterfaceData, 
														NULL,
														0, 
														&RequiredSize,
														&DeviceInfoData
													))
			{
				if ( ERROR_INSUFFICIENT_BUFFER == ::GetLastError () )
				{
					DeviceInterfaceDetailDataSize = RequiredSize;
					BYTE* data = NULL;

					try
					{
						if ( ( data = new BYTE [RequiredSize] ) == NULL )
						{
							throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR );
						}

						pDeviceInterfaceDetailData = reinterpret_cast < PSP_INTERFACE_DEVICE_DETAIL_DATA > ( data );
					}
					catch ( ... )
					{
						// clear resources
						SetupDiDestroyDeviceInfoList ( DeviceInfoSet );

						throw;
					}
				}
				else
				{
					bContinue = FALSE;
				}
			}

			if ( bContinue )
			{
				// set size
				pDeviceInterfaceDetailData->cbSize = sizeof ( SP_INTERFACE_DEVICE_DETAIL_DATA );

				if ( ! SetupDiGetDeviceInterfaceDetail	(	DeviceInfoSet,
															&DeviceInterfaceData, 
															pDeviceInterfaceDetailData,
															DeviceInterfaceDetailDataSize, 
															&RequiredSize,
															&DeviceInfoData
														))
				{
					bContinue = FALSE;
				}
				else
				{
					try
					{
						CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
						HRESULT	hresTemp = GetPhysDiskInfoNT ( pInstance, pDeviceInterfaceDetailData->DevicePath, MemberIndex, dwProperties, TRUE ) ;
						if ( SUCCEEDED ( hresTemp ) )
						{
							hres = pInstance->Commit (  ) ;

							if FAILED ( hres )
							{
								bContinue = FALSE;
							}
						}
					}
					catch ( ... )
					{
						// clear resource
						if (pDeviceInterfaceDetailData)
						{
							delete [] reinterpret_cast < BYTE* > (pDeviceInterfaceDetailData);
							pDeviceInterfaceDetailData = NULL;
						}

						DeviceInterfaceDetailDataSize = 0L;

						// clear resources
						SetupDiDestroyDeviceInfoList ( DeviceInfoSet );

						throw;
					}

					MemberIndex++;
				}

				DeviceInterfaceDetailDataSize = 0L;
			}

			if (pDeviceInterfaceDetailData)
			{
				delete [] reinterpret_cast < BYTE* > (pDeviceInterfaceDetailData);
				pDeviceInterfaceDetailData = NULL;
			}
		}

		// is it error ?
		if ( ERROR_NO_MORE_ITEMS != ::GetLastError () )
		{
			hres = WBEM_E_FAILED;
		}

		// clear resources
		SetupDiDestroyDeviceInfoList ( DeviceInfoSet );
	}

#endif

    return hres;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskDrive::GetPhysDiskInfoNT
 *
 *  DESCRIPTION : Retrieves property values for physical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32DiskDrive::GetPhysDiskInfoNT (

	CInstance *pInstance,
    LPCWSTR lpwszDiskSpec,
    DWORD dwIndex,
	DWORD dwProperties,
	BOOL bGetIndex
)
{
	HRESULT hres = WBEM_S_NO_ERROR ;

	// Get handle to physical drive
	//=============================

	SetCreationClassName(pInstance);

	pInstance->SetCHString ( IDS_SystemName , GetLocalComputerName() ) ;
    pInstance->SetWCHARSplat ( IDS_SystemCreationClassName , PROPSET_NAME_COMPSYS ) ;
    pInstance->SetWCHARSplat ( IDS_Status , IDS_OK ) ;

	SmartCloseHandle hDiskHandle = CreateFile (

		lpwszDiskSpec,
		GENERIC_READ ,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		0,
		0
	) ;

	DWORD dwErr = GetLastError () ;

	if (bGetIndex)
	{
		if ( hDiskHandle != INVALID_HANDLE_VALUE )
		{
			DWORD                   dwBytesReturned = 0;
			STORAGE_DEVICE_NUMBER   StorageDevNum;

			//send an IOCTL_STORAGE_GET_DEVICE_NUMBER to the drive using DeviceIoControl and the handle to the drive
			if ( DeviceIoControl (
									hDiskHandle,						// handle to device
									IOCTL_STORAGE_GET_DEVICE_NUMBER,	// operation
									NULL,								// input data buffer - we have none, so passing NULL
									0,									// size of input data buffer - we have none, so passing 0
									&StorageDevNum,						// output data buffer
									sizeof ( STORAGE_DEVICE_NUMBER ),	// size of output data buffer
									&dwBytesReturned,					// byte count
									NULL								// overlapped information
								 ))
			{

				pInstance->SetDWORD ( IDS_Index , StorageDevNum.DeviceNumber ) ;

				CHString	wszDiskSpec ( L"\\\\.\\PHYSICALDRIVE" );
				WCHAR		wszNumber [ 32 ] = { L'\0' };

				_itow ( StorageDevNum.DeviceNumber, wszNumber, 10 );
				wszDiskSpec += wszNumber;

				pInstance->SetCHString ( IDS_DeviceID , wszDiskSpec) ;
				pInstance->SetCHString ( IDS_Caption , wszDiskSpec ) ;
				pInstance->SetCHString ( IDS_Name , wszDiskSpec ) ;
				pInstance->SetCHString ( IDS_Description , wszDiskSpec ) ;
			}
		}
	}
	else
	{
		pInstance->SetDWORD ( IDS_Index , dwIndex ) ;
		pInstance->SetCHString ( IDS_DeviceID , lpwszDiskSpec) ;
		pInstance->SetCHString ( IDS_Caption , lpwszDiskSpec ) ;
		pInstance->SetCHString ( IDS_Name , lpwszDiskSpec ) ;
		pInstance->SetCHString ( IDS_Description , lpwszDiskSpec ) ;
	}

#if NTONLY >= 5

    if ( (hDiskHandle != INVALID_HANDLE_VALUE) &&
        (dwProperties &
            (BIT_Description |
             BIT_Caption |
             BIT_Model |
             BIT_Manufacturer |
             BIT_PNPDeviceID |
             BIT_MediaLoaded |
             BIT_InterfaceType |
             BIT_Status |
             BIT_ConfigManagerErrorCode |
             BIT_ConfigManagerUserConfig)) )
    {

        CHString sTemp;
        if (GetPNPDeviceIDFromHandle(hDiskHandle, sTemp))
        {
            CConfigManager configMgr;

            CConfigMgrDevicePtr pDevice;
	        if ( configMgr.LocateDevice ( sTemp, pDevice ) )
	        {
                if (dwProperties & BIT_InterfaceType)
                {
                    SetInterfaceType(pInstance, pDevice);
                }

                if (dwProperties &
                     (BIT_PNPDeviceID |
                     BIT_ConfigManagerErrorCode |
                     BIT_ConfigManagerUserConfig))
                {
                    SetConfigMgrProperties(pDevice, pInstance);
                }

                if ( (dwProperties & (BIT_Description | BIT_Caption)) && (pDevice->GetDeviceDesc(sTemp) ))
	            {
                    pInstance->SetCHString ( IDS_Description , sTemp ) ;
    	            pInstance->SetCHString ( IDS_Caption , sTemp ) ;
                }

                if ((dwProperties & (BIT_Caption | BIT_Model)) && (pDevice->GetFriendlyName(sTemp)) )
                {
    	            pInstance->SetCHString ( IDS_Caption , sTemp ) ;
                    pInstance->SetCHString ( IDS_Model , sTemp ) ;
                }

                if ((dwProperties & BIT_Manufacturer) && (pDevice->GetMfg(sTemp)))
                {
                    pInstance->SetCHString(IDS_Manufacturer, sTemp);
                }

                if ((dwProperties & BIT_Status) && (pDevice->GetStatus(sTemp)))
                {
		            pInstance->SetCHString ( IDS_Status , sTemp ) ;
	            }
            }
        }
    }

#endif

	if (( hDiskHandle != INVALID_HANDLE_VALUE ) || (dwErr == ERROR_ACCESS_DENIED))
	{
        if ((dwProperties & (BIT_Partitions|BIT_Signature|BIT_MediaLoaded)) && (hDiskHandle != INVALID_HANDLE_VALUE))
        {
			 // Get other resources we'll need
			 //===============================

			DWORD dwByteCount =	sizeof(DRIVE_LAYOUT_INFORMATION) -
									sizeof(PARTITION_INFORMATION) +
									128 * sizeof(PARTITION_INFORMATION ) ;

			DRIVE_LAYOUT_INFORMATION *DriveLayout = reinterpret_cast < DRIVE_LAYOUT_INFORMATION * > ( new char [ dwByteCount ] ) ;

   			if ( DriveLayout )
			{
				try
				{
					BOOL t_Status = DeviceIoControl (

						hDiskHandle ,
						IOCTL_DISK_GET_DRIVE_LAYOUT ,
						NULL ,
						0 ,
						DriveLayout ,
						dwByteCount ,
						&dwByteCount ,
						NULL
					) ;

					if ( t_Status )
					{
// MS documentation says we get an entry in PartitionEntry for each
// disk partition.  What we really get is an entry for each slot in
// the disk's partition table -- some used, some not.  Not knowing
// in advance how many slots there are in the table, (at the time of
// this writing, 8 is the most I've seen), I'm going to allow space
// for a 64-entry partition table (about 2k).  It'll be interesting
// to see how long it takes to find a disk exceeding this limit.
//==================================================================
// Well, we're there.  GPT disks can have 128 partitions.
//==================================================================
						if (dwProperties & BIT_Partitions)
						{
							DWORD dwPartitions = 0 ;
							for ( DWORD i = 0 ; i < DriveLayout->PartitionCount ; i ++ )
							{
								if ( DriveLayout->PartitionEntry[i].RecognizedPartition )
								{
									dwPartitions ++ ;
								}
							}

							pInstance->SetDWORD(IDS_Partitions, dwPartitions ) ;
						}

						if (dwProperties & BIT_Signature)
						{
							pInstance->SetDWORD(IDS_Signature, DriveLayout->Signature ) ;
						}

						if (dwProperties & BIT_MediaLoaded)
						{
							pInstance->Setbool(IDS_MediaLoaded, TRUE );
						}
					}
					else
					{
						if (dwProperties & BIT_MediaLoaded)
						{
							pInstance->Setbool(IDS_MediaLoaded, FALSE );
						}
					}
				}
				catch ( ... )
				{
					if ( DriveLayout != NULL )
					{
						delete [] reinterpret_cast<char *> (DriveLayout) ;
					}

					throw ;
				}

				delete [] reinterpret_cast<char *> (DriveLayout);
			}
			else
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}
        }

		if ( (dwProperties &
                (BIT_TotalHeads |
                 BIT_TracksPerCylinder |
                 BIT_SectorsPerTrack |
                 BIT_BytesPerSector |
                 BIT_TotalCylinders |
                 BIT_TotalTracks |
                 BIT_TotalSectors |
                 BIT_Size |
                 BIT_MediaType |
                 BIT_Capabilities))
                 && (hDiskHandle != INVALID_HANDLE_VALUE))
		{

			DWORD dwByteCount = 0 ;
			DISK_GEOMETRY DiskGeometry ;

			BOOL t_Status = DeviceIoControl (

				hDiskHandle ,
				IOCTL_DISK_GET_DRIVE_GEOMETRY ,
				NULL ,
				0 ,
				& DiskGeometry ,
				sizeof ( DiskGeometry ) ,
				&dwByteCount ,
				NULL
			) ;

			if ( t_Status )
			{

// Calculate size info
//====================

				pInstance->SetDWORD ( IDS_TotalHeads , DiskGeometry.TracksPerCylinder ) ;
				pInstance->SetDWORD ( IDS_TracksPerCylinder , DiskGeometry.TracksPerCylinder ) ;
				pInstance->SetDWORD ( IDS_SectorsPerTrack , DiskGeometry.SectorsPerTrack ) ;
				pInstance->SetDWORD ( IDS_BytesPerSector , DiskGeometry.BytesPerSector ) ;

				unsigned __int64 i64Temp = DiskGeometry.Cylinders.QuadPart;
				pInstance->SetWBEMINT64 ( IDS_TotalCylinders , i64Temp );

				i64Temp *= (unsigned __int64) DiskGeometry.TracksPerCylinder ;
				pInstance->SetWBEMINT64(IDS_TotalTracks, i64Temp );

				i64Temp *= (unsigned __int64) DiskGeometry.SectorsPerTrack ;
				pInstance->SetWBEMINT64(IDS_TotalSectors, i64Temp );

				i64Temp *= (unsigned __int64) DiskGeometry.BytesPerSector ;
				pInstance->SetWBEMINT64(IDS_Size, i64Temp);

				// Create a safearray for the Capabilities information

				SAFEARRAYBOUND rgsabound[1];

				rgsabound [ 0 ].cElements = 2 ;
				rgsabound [ 0 ].lLbound = 0 ;

				variant_t vValue;

				V_ARRAY(&vValue) = SafeArrayCreate ( VT_I2 , 1 , rgsabound ) ;

				if ( V_ARRAY(&vValue) )
				{
    				V_VT(&vValue) = VT_I2 | VT_ARRAY;

					long ix [ 1 ] ;

					DWORD dwVal = 3 ;
					ix [ 0 ] = 0 ;

					SafeArrayPutElement ( V_ARRAY(&vValue) , ix , & dwVal ) ;

					dwVal = 4 ;
					ix [ 0 ] = 1 ;

					SafeArrayPutElement ( V_ARRAY(&vValue) , ix , & dwVal ) ;

					// Assume fixed, non-removable until otherwise indicated
					//======================================================

					bool bRemovable = false ;

					switch ( DiskGeometry.MediaType )
					{
						case RemovableMedia :
						{
							rgsabound[0].cElements ++ ;

							HRESULT t_Result = SafeArrayRedim ( V_ARRAY(&vValue) , rgsabound ) ;
							if ( t_Result == E_OUTOFMEMORY )
							{
								throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
							}

							ix [ 0 ] ++ ;
							dwVal = 7;

							SafeArrayPutElement ( V_ARRAY(&vValue) , ix , & dwVal ) ;

							pInstance->SetWCHARSplat ( IDS_MediaType , L"Removable media other than floppy" );

							bRemovable = true;
						}
						break ;

						case FixedMedia :
						{
							pInstance->SetWCHARSplat(IDS_MediaType, L"Fixed hard disk media" );
						}
						break ;

						default :
						{
							pInstance->SetWCHARSplat(IDS_MediaType, L"Format is unknown" );
						}
						break ;
					}

					pInstance->SetVariant ( IDS_Capabilities , vValue ) ;
                }
				else
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}
            }
            else
            {
                LogMessage2(L"Failed to GetDriveGeometry: %d", GetLastError());
            }
        }

// Now some real fun -- determining the drive type
//================================================
        if (dwProperties &
              (BIT_Description |
#if NTONLY == 4
               BIT_InterfaceType |
#endif
               BIT_SCSIPort |
               BIT_SCSIBus |
               BIT_SCSITargetID |
               BIT_SCSILogicalUnit |
               BIT_Manufacturer)
               && (hDiskHandle != INVALID_HANDLE_VALUE))
        {
			DWORD dwByteCount = 0 ;
			SCSI_ADDRESS SCSIAddress ;

			BOOL t_Status = DeviceIoControl (

				hDiskHandle,
				IOCTL_SCSI_GET_ADDRESS,
				NULL,
				0,
				&SCSIAddress,
				sizeof(SCSI_ADDRESS),
				&dwByteCount,
				NULL
			) ;

			if ( t_Status )
			{
#if NTONLY == 4
				pInstance->SetWCHARSplat ( IDS_InterfaceType , L"SCSI" ) ;
#endif

				pInstance->SetDWORD ( IDS_SCSIPort,        DWORD ( SCSIAddress.PortNumber ) ) ;
				pInstance->SetDWORD ( IDS_SCSIBus,         DWORD ( SCSIAddress.PathId ) ) ;
				pInstance->SetDWORD ( IDS_SCSITargetID,    DWORD ( SCSIAddress.TargetId) ) ;
				pInstance->SetDWORD ( IDS_SCSILogicalUnit, DWORD ( SCSIAddress.Lun) ) ;
#if NTONLY == 4

                if (dwProperties & (BIT_Description | BIT_Manufacturer))
                {
                    CHString sSCSIKey, sTemp;
                    CRegistry cReg;

                    sSCSIKey.Format(L"Hardware\\DeviceMap\\Scsi\\Scsi Port %d\\Scsi Bus %d\\Target ID %d\\Logical Unit Id %d",
                        SCSIAddress.PortNumber,
                        SCSIAddress.PathId,
                        SCSIAddress.TargetId,
                        SCSIAddress.Lun);

                    if (cReg.Open(HKEY_LOCAL_MACHINE, sSCSIKey, KEY_QUERY_VALUE) == ERROR_SUCCESS)
                    {
                        if (cReg.GetCurrentKeyValue(L"Identifier", sTemp) == ERROR_SUCCESS)
                        {
                            if (dwProperties & BIT_Manufacturer)
                            {
                                CHString sMfg(sTemp.Left(8));
                                sMfg.TrimRight();

                                pInstance->SetCHString(IDS_Manufacturer, sMfg);
                            }
                            if (dwProperties & BIT_Description)
                            {
                                CHString sDesc(sTemp.Mid(8,16));
                                sDesc.TrimRight();

                                pInstance->SetCHString(IDS_Description, sDesc);
                            }
                        }
                    }
                }
#endif



            }
			else
			{
#if NTONLY == 4
				pInstance->SetWCHARSplat ( IDS_InterfaceType , L"IDE") ;
#endif
			}

#if NTONLY == 4
//              Under NT 3.51, 4.0, the IDE drives are controlled
//              by a subset of the SCSI miniport and are identified
//              by the above call as SCSI drives.  We need to go
//              into the registry & get the driver type.  If ATAPI,
//              the drive is really IDE.  This may not always work.
//=================================================================

            TCHAR szTemp[_MAX_PATH] ;
			_stprintf ( szTemp , L"HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port %d" , SCSIAddress.PortNumber ) ;

			CRegistry RegInfo ;
			if ( RegInfo.Open ( HKEY_LOCAL_MACHINE , szTemp , KEY_READ ) == ERROR_SUCCESS )
			{
				CHString sTemp ;
				if ( RegInfo.GetCurrentKeyValue (L"Driver", sTemp) == ERROR_SUCCESS )
				{
					if ( ! lstrcmpi ( sTemp.GetBuffer(1), L"ATAPI" ) )
					{
						 pInstance->SetWCHARSplat ( IDS_InterfaceType , L"IDE" ) ;
					}
				}

				RegInfo.Close() ;
			}
#endif

        }
	}
	else
	{
        if ( dwErr == ERROR_FILE_NOT_FOUND)
		{
			hres = WBEM_E_NOT_FOUND ;
		}
	}

  	return hres ;
}

#endif

#if NTONLY == 5

#define WMI_PNPDEVICEID_GUID           { 0xc7bf35d2, 0xaadb, 0x11d1, { 0xbf, 0x4a, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 } }
#define OffsetToPtr(Base, Offset) ((PBYTE)((PBYTE)Base + Offset))

BOOL CWin32DiskDrive::GetPNPDeviceIDFromHandle(HANDLE hHandle, CHString &sPNPDeviceID)
{
    BOOL bRet = FALSE;

    WMIHANDLE WmiHandle;
	ULONG status;
    GUID GeomGuid = WMI_DISK_GEOMETRY_GUID;

    CWmiApi* pWmi = (CWmiApi*) CResourceManager::sm_TheResourceManager.GetResource(g_guidWmiApi, NULL);
    if(pWmi != NULL)
    {
	    try
        {

            status = pWmi->WmiOpenBlock(&GeomGuid,
                                  GENERIC_ALL,
                                  &WmiHandle);

            if (status == ERROR_SUCCESS)
            {
                WCHAR wszInstancePath[_MAX_PATH];
                try
                {
	                ULONG NameLen = _MAX_PATH;
                    status = pWmi->WmiFileHandleToInstanceName(WmiHandle,
                                                         hHandle,
                                                         &NameLen,
                                                         wszInstancePath);
                }
                catch ( ... )
                {
            		pWmi->WmiCloseBlock( WmiHandle );
                    throw;
                }
            	pWmi->WmiCloseBlock( WmiHandle );

                if (status == ERROR_SUCCESS)
                {
                    GUID PNPGuid = WMI_PNPDEVICEID_GUID;
                    status = pWmi->WmiOpenBlock(&PNPGuid,
                                          GENERIC_ALL,
                                          &WmiHandle);

                    if (status == ERROR_SUCCESS)
                    {
                        try
                        {
                            WCHAR wszPNPId[_MAX_PATH + sizeof(WNODE_SINGLE_INSTANCE)];
                            ULONG NameLen = sizeof(wszPNPId);

                            status = pWmi->WmiQuerySingleInstance(WmiHandle,
                                                                  wszInstancePath,
                                                                  &NameLen,
                                                                  wszPNPId);

                            if (status == ERROR_SUCCESS)
                            {
                                WNODE_SINGLE_INSTANCE *pNode = (PWNODE_SINGLE_INSTANCE)wszPNPId;

                                // Number of bytes in string
                                WORD *pWord = (WORD *)OffsetToPtr(pNode, pNode->DataBlockOffset);
                                WORD wChars = *pWord / sizeof(WCHAR);

                                WCHAR *pBuff = sPNPDeviceID.GetBuffer(wChars + 1);
                                memcpy(pBuff, OffsetToPtr(pNode, pNode->DataBlockOffset) + 2, *pWord);
                                pBuff[wChars] = 0;

                                bRet = TRUE;
                            }
                        }
                        catch ( ... )
                        {
            			    pWmi->WmiCloseBlock( WmiHandle );
                            throw;
                        }
            			pWmi->WmiCloseBlock( WmiHandle );
                    }
                    else
                    {
                        LogMessage2(L"WmiOpenBlock PNPDeviceID failed %d\n", status);
                    }
                }
                else
                {
                    LogMessage2(L"WmiFileHandleToInstanceName failed %d\n", status);
                }
            }
            else
            {
                LogMessage2(L"WmiOpenBlock Geom failed %d\n", status);
            }
        }
        catch ( ... )
        {
            CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidWmiApi, pWmi);
            throw;
        }

        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidWmiApi, pWmi);
    }

    return bRet;
}

#endif

void CWin32DiskDrive::SetInterfaceType(CInstance *pInstance, CConfigMgrDevice *pDevice)
{
    CConfigMgrDevicePtr pParent, pCurDevice(pDevice);

    while (pCurDevice->GetParent(pParent))
    {
        if (pParent->IsClass (L"SCSIAdapter"))
        {
            pInstance->SetWCHARSplat(IDS_InterfaceType, L"SCSI");
            break;
        }
        else if (pParent->IsClass (L"hdc"))
        {
            pInstance->SetWCHARSplat(IDS_InterfaceType, L"IDE");
            break;
        }
        else if (pParent->IsClass (L"USB"))
        {
            pInstance->SetWCHARSplat(IDS_InterfaceType, L"USB");
            break;
        }
        else if (pParent->IsClass (L"1394"))
        {
            pInstance->SetWCHARSplat(IDS_InterfaceType, L"1394");
            break;
        }
        pCurDevice = pParent;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\diskpartition.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  Partition.CPP
//
//  Purpose: Disk partition property set provider
//
//***************************************************************************

#include "precomp.h"
#include <assertbreak.h>

#include <ntdddisk.h>
#include "diskpartition.h"
#include "diskdrive.h"
#include "resource.h"

#define CLUSTERSIZE 4096

// Property set declaration
//=========================
CWin32DiskPartition MyDiskPartitionSet ( PROPSET_NAME_DISKPARTITION , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskPartition::CWin32DiskPartition
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32DiskPartition :: CWin32DiskPartition (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskPartition::~CWin32DiskPartition
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32DiskPartition :: ~CWin32DiskPartition ()
{
}

BOOL CWin32DiskPartition :: SetPartitionType (

	CInstance *pInstance,
	GUID *pGuidPartitionType,
	BOOL &bIsSystem,
	BOOL &bIsPrimary
)
{
	bIsPrimary = TRUE;
	bIsSystem = FALSE;
	CHString sTemp2;

	if (IsEqualGUID(*pGuidPartitionType, PARTITION_ENTRY_UNUSED_GUID))
	{
		//
		// disk tools consider all but unused
		// partition as a primary partition
		//
		bIsPrimary = FALSE;

		return FALSE;
	}
	else if (IsEqualGUID(*pGuidPartitionType, PARTITION_SYSTEM_GUID))
	{
		//EFI system partition.
		bIsSystem = TRUE;

        LoadStringW(sTemp2, IDR_PartitionDescGPTSystem);
		pInstance->SetCharSplat ( IDS_Type, IDS_PartitionDescGPTSystem ) ;
	}
	else if (IsEqualGUID(*pGuidPartitionType, PARTITION_MSFT_RESERVED_GUID))
	{
		return FALSE;

//		LoadStringW(sTemp2, IDR_PartitionDescGPTMSFTReserved);
//		pInstance->SetCharSplat ( IDS_Type, IDS_PartitionDescGPTMSFTReserved ) ;
	}
	else if (IsEqualGUID(*pGuidPartitionType, PARTITION_BASIC_DATA_GUID))
	{
        LoadStringW(sTemp2, IDR_PartitionDescGPTBasicData);
		pInstance->SetCharSplat ( IDS_Type, IDS_PartitionDescGPTBasicData ) ;
	}
	else if (IsEqualGUID(*pGuidPartitionType, PARTITION_LDM_METADATA_GUID))
	{
        LoadStringW(sTemp2, IDR_PartitionDescGPTLDMMetaData);
		pInstance->SetCharSplat ( IDS_Type, IDS_PartitionDescGPTLDMMetaData ) ;
	}
	else if (IsEqualGUID(*pGuidPartitionType, PARTITION_LDM_DATA_GUID))
	{
        LoadStringW(sTemp2, IDR_PartitionDescGPTLDMData);
		pInstance->SetCharSplat ( IDS_Type, IDS_PartitionDescGPTLDMData ) ;
	}
	else // Unknown!!
	{
		//
		// we should not really be here
		// just in case we do not consider this as a primary partition
		//
		bIsPrimary = FALSE;

        LoadStringW(sTemp2, IDR_PartitionDescGPTUnknown);
		pInstance->SetCharSplat ( IDS_Type, IDS_PartitionDescGPTUnknown ) ;
	}

	pInstance->SetCHString ( IDS_Description , sTemp2 ) ;
	return TRUE;
}

BOOL CWin32DiskPartition :: SetPartitionType (

	CInstance *pInstance,
	DWORD dwPartitionType,
	DWORD dwPartitionIndex, 
	BOOL &bIsPrimary
)
{
	if ((dwPartitionType == PARTITION_ENTRY_UNUSED) || IsContainerPartition(dwPartitionType))
	{
		return FALSE;
	}

	//
	// this is constant from disk manager. it says
	// there are only MAX_PARTITION_ENTRIES real partitions
	// in the system allowed, others are logical, unused ...
	//

	#define MAX_PARTITION_ENTRIES 4

	//
	// if this is one of allowed partitions recognize
	// its status per partition type
	//

	if ( dwPartitionIndex < MAX_PARTITION_ENTRIES )
	{
		switch ( dwPartitionType )
		{

			case PARTITION_ENTRY_UNUSED:
			case PARTITION_EXTENDED:
			case PARTITION_XINT13_EXTENDED:
			{
				bIsPrimary = FALSE;
			}
			break;

			default:
			{
				bIsPrimary = TRUE;
			}
			break;
		}
	}

	//
	// this is logical for
	// extentded partition -> FALSE
	//

	else
	{
		bIsPrimary = FALSE;
	}

    CHString sTemp2;
	
	switch ( dwPartitionType )
	{

		case PARTITION_ENTRY_UNUSED:
		{
            LoadStringW(sTemp2, IDR_PartitionDescUnused);
			pInstance->SetCharSplat ( IDS_Type, IDS_PartitionDescUnused ) ;
		}
		break;

		case PARTITION_FAT_12:
		{
            LoadStringW(sTemp2, IDR_PartitionDesc12bitFAT);
			pInstance->SetCharSplat ( IDS_Type , IDS_PartitionDesc12bitFAT ) ;
		}
		break;

		case PARTITION_XENIX_1:
		{
            LoadStringW(sTemp2, IDR_PartitionDescXenixOne);
			pInstance->SetCharSplat ( IDS_Type , IDS_PartitionDescXenixOne ) ;
		}
		break;

		case PARTITION_XENIX_2:
		{
            LoadStringW(sTemp2, IDR_PartitionDescXenixTwo);
			pInstance->SetCharSplat ( IDS_Type , IDS_PartitionDescXenixTwo ) ;
		}
		break;

		case PARTITION_FAT_16:
		{
            LoadStringW(sTemp2, IDR_PartitionDesc16bitFAT);
			pInstance->SetCharSplat ( IDS_Type , IDS_PartitionDesc16bitFAT ) ;
		}
		break;

		case PARTITION_EXTENDED:
		{
            LoadStringW(sTemp2, IDR_PartitionDescExtPartition);
			pInstance->SetCharSplat ( IDS_Type, IDS_PartitionDescExtPartition ) ;
		}
		break;

		case PARTITION_HUGE:
		{
            LoadStringW(sTemp2, IDR_PartitionDescDOSV4Huge);
			pInstance->SetCharSplat ( IDS_Type , IDS_PartitionDescDOSV4Huge ) ;
		}
		break;

		case PARTITION_IFS:
		{
            LoadStringW(sTemp2, IDR_PartitionDescInstallable);
			pInstance->SetCharSplat ( IDS_Type, IDS_PartitionDescInstallable ) ;
		}
		break;

		case PARTITION_PREP:
		{
            LoadStringW(sTemp2, IDR_PartitionDescPowerPCRef);
			pInstance->SetCharSplat ( IDS_Type , IDS_PartitionDescPowerPCRef);
		}
		break;

		case PARTITION_UNIX:
		{
            LoadStringW(sTemp2, IDR_PartitionDescUnix);
			pInstance->SetCharSplat ( IDS_Type, IDS_PartitionDescUnix ) ;
		}
		break;

		case VALID_NTFT:
		{
            LoadStringW(sTemp2, IDR_PartitionDescNTFT);
			pInstance->SetCharSplat ( IDS_Type , IDS_PartitionDescNTFT ) ;
		}
		break;

		case PARTITION_XINT13:
		{
            LoadStringW(sTemp2, IDR_PartitionDescWin95Ext);
			pInstance->SetCharSplat ( IDS_Type , IDS_PartitionDescWin95Ext ) ;
		}
		break;

		case PARTITION_XINT13_EXTENDED:
		{
            LoadStringW(sTemp2, IDR_PartitionDescExt13);
			pInstance->SetCharSplat ( IDS_Type , IDS_PartitionDescExt13 ) ;
		}
		break;

		case PARTITION_LDM:
		{
            LoadStringW(sTemp2, IDR_PartitionDescLogicalDiskManager);
			pInstance->SetWCHARSplat ( IDS_Type , L"Logical Disk Manager" ) ;
		}
		break;

		default:
		{
            sTemp2 = IDS_PartitionDescUnknown;
			pInstance->SetCharSplat ( IDS_Type, IDS_PartitionDescUnknown ) ;
		}
		break;
	}

	pInstance->SetCHString ( IDS_Description , sTemp2 ) ;
	return TRUE;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskPartition::GetObject
 *                                         RefreshInstanceNT
 *                                         RefreshInstanceWin95
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                from pInstance
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DiskPartition :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
	CHString chsDeviceID ;
	pInstance->GetCHString ( IDS_DeviceID , chsDeviceID ) ;
	chsDeviceID.MakeUpper () ;

#ifdef NTONLY

	int iWhere = chsDeviceID.Find ( L"DISK #" ) ;
	if ( iWhere == -1 )
	{
		return WBEM_E_NOT_FOUND ;
	}

    // We want the number of characters, not the number of bytes.

	DWORD dwDiskIndex = _ttol ( chsDeviceID.Mid ( iWhere + sizeof("DISK #") - 1 ) ) ; // Don't use _T here.

	iWhere = chsDeviceID.Find ( L"PARTITION #" ) ;
	if ( iWhere == -1 )
	{
		return WBEM_E_NOT_FOUND;
	}

	DWORD dwPartitionIndex = _ttol ( chsDeviceID.Mid ( iWhere + sizeof ("PARTITION #") - 1 ) ) ; // Don't use _T here.

	HRESULT hres = RefreshInstanceNT (

		dwDiskIndex,
		dwPartitionIndex,
		pInstance
	) ;

#endif

    // If we seem to have succeeded, make one last check to be SURE we got what they asked for

    if ( SUCCEEDED ( hres ) )
    {
		CHString chsDeviceIDNew ;
        pInstance->GetCHString ( IDS_DeviceID , chsDeviceIDNew ) ;

        if ( chsDeviceIDNew.CompareNoCase ( chsDeviceID ) != 0 )
        {
            return WBEM_E_NOT_FOUND;
        }
    }

	return hres ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskPartition::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each logical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DiskPartition :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
#ifdef NTONLY

    HRESULT t_Result = AddDynamicInstancesNT (

		pMethodContext
	) ;

	return t_Result ;

#endif

}

#ifdef NTONLY

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskPartition::AddDynamicInstancesNT
 *
 *  DESCRIPTION : Creates instance of property set for each logical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DiskPartition :: AddDynamicInstancesNT (

	MethodContext *pMethodContext
)
{
    HRESULT	hres;
    DWORD	j;
    TCHAR   szTemp[_MAX_PATH];

    // Get list of disks
    //==================

    TRefPointerCollection<CInstance> Disks;

    hres = CWbemProviderGlue :: GetInstancesByQuery (

		L"SELECT Index FROM Win32_DiskDrive" ,
        & Disks,
		pMethodContext,
                GetNamespace()
	) ;

    if ( FAILED ( hres ) )
    {
        return hres ;
    }

    REFPTRCOLLECTION_POSITION pos ;

    if ( Disks.BeginEnum ( pos ) )
    {

	    CInstancePtr pDisk;
        for (pDisk.Attach(Disks.GetNext ( pos ));
             SUCCEEDED( hres ) && (pDisk != NULL);
             pDisk.Attach(Disks.GetNext ( pos )))
        {
			DWORD dwDiskIndex = 0 ;

			pDisk->GetDWORD ( IDS_Index , dwDiskIndex ) ;

            // Open the disk
            //==============

            _stprintf ( szTemp , IDS_PhysicalDrive , dwDiskIndex ) ;

			DWORD dwLayoutType = 0;
            CSmartBuffer pBuff (GetPartitionInfoNT(szTemp, dwLayoutType));

            // Should we return an error here?  Or not?  Hmmm.
            if ((LPBYTE)pBuff != NULL)
            {
			    // Create instance for each partition on drive
			    //============================================
				DWORD dwPCount = (dwLayoutType == 1)
									? ((DRIVE_LAYOUT_INFORMATION *)(LPBYTE)pBuff)->PartitionCount
									: ((DRIVE_LAYOUT_INFORMATION_EX *)(LPBYTE)pBuff)->PartitionCount;

				// fake index for "valid" partitions only
				DWORD dwFakePartitionNumber = 0L;

				for ( j = 0 ; (j < dwPCount ) && ( SUCCEEDED ( hres ) ) ; j++ )
				{
					CInstancePtr pInstance(CreateNewInstance(pMethodContext ), false) ;

					if (LoadPartitionValuesNT (

						pInstance,
						dwDiskIndex,
						j,
						dwFakePartitionNumber,
						(LPBYTE)pBuff,
						dwLayoutType
					))
					{
						hres = pInstance->Commit (  ) ;

						if SUCCEEDED ( hres )
						{
							dwFakePartitionNumber++;
						}
					}
				}
            }
        }

        Disks.EndEnum() ;

    } // If Disks.BeginEnum()

    return hres;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskPartition::RefreshInstanceNT
 *
 *  DESCRIPTION : Creates instance of property set for each logical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DiskPartition :: RefreshInstanceNT (

	DWORD dwDiskIndex,
	DWORD dwPartitionIndex,
	CInstance *pInstance
)
{
	HRESULT	hres = WBEM_E_NOT_FOUND ;

	// Open the target drive
	//======================

	TCHAR szTemp [ _MAX_PATH ] ;
	wsprintf ( szTemp , IDS_PhysicalDrive , dwDiskIndex ) ;

	DWORD dwLayoutType = 0;
    CSmartBuffer pBuff (GetPartitionInfoNT(szTemp, dwLayoutType));

    // Should we return an error here?  Or not?  Hmmm.
    if ((LPBYTE)pBuff != NULL)
    {
		DWORD dwRealPartitionIndex = static_cast < DWORD > ( - 1 );
		dwRealPartitionIndex = GetRealPartitionIndex ( dwPartitionIndex, (LPBYTE)pBuff, dwLayoutType );

		// Create instance for each partition on drive
		//============================================
	    if (dwRealPartitionIndex != static_cast < DWORD > ( - 1 ) )
	    {
		    if (LoadPartitionValuesNT (

			    pInstance ,
			    dwDiskIndex ,
				dwRealPartitionIndex ,
			    dwPartitionIndex ,
			    (LPBYTE)pBuff,
				dwLayoutType
		    ))
			{
				hres = WBEM_S_NO_ERROR ;
			}
	    }

    }

	return hres ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskPartition::LoadPartitionValuesNT
 *
 *  DESCRIPTION : Loads property values according to passed PARTITION_INFORMATION
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CWin32DiskPartition::LoadPartitionValuesNT (

	CInstance *pInstance,
	DWORD dwDiskIndex,
    DWORD dwPartitionNumber,
    DWORD dwFakePartitionNumber,
	LPBYTE pBuff,
	DWORD dwLayoutStyle
)
{
	BOOL retVal = FALSE;
	BOOL bIndicator = FALSE;
	BOOL bSetIndicator = FALSE;
	LONGLONG llStart = 0;
	LONGLONG llLength = 0;

	BOOL bPrimaryPartition = FALSE;

	if (dwLayoutStyle == 1)
	{
		UCHAR uPType = ((DRIVE_LAYOUT_INFORMATION *)(LPBYTE)pBuff)->PartitionEntry[dwPartitionNumber].PartitionType;
		retVal = SetPartitionType(pInstance, (DWORD)uPType, dwPartitionNumber, bPrimaryPartition);

		if (retVal)
		{
			bSetIndicator = TRUE;
			bIndicator = ((DRIVE_LAYOUT_INFORMATION *)(LPBYTE)pBuff)->PartitionEntry[dwPartitionNumber].BootIndicator;
			llStart = ((DRIVE_LAYOUT_INFORMATION *)(LPBYTE)pBuff)->PartitionEntry[dwPartitionNumber].StartingOffset.QuadPart;
			llLength = ((DRIVE_LAYOUT_INFORMATION *)(LPBYTE)pBuff)->PartitionEntry[dwPartitionNumber].PartitionLength.QuadPart;
		}
	}
	else //dwLayoutStyle == 2
	{
		switch (((DRIVE_LAYOUT_INFORMATION_EX *)(LPBYTE)pBuff)->PartitionEntry[dwPartitionNumber].PartitionStyle)
		{
			case PARTITION_STYLE_MBR :
			{
				UCHAR uPType = ((DRIVE_LAYOUT_INFORMATION_EX *)(LPBYTE)pBuff)->PartitionEntry[dwPartitionNumber].Mbr.PartitionType;
				retVal = SetPartitionType(pInstance, (DWORD)uPType, dwPartitionNumber, bPrimaryPartition);

				if (retVal)
				{
					bSetIndicator = TRUE;
					bIndicator = ((DRIVE_LAYOUT_INFORMATION_EX *)(LPBYTE)pBuff)->PartitionEntry[dwPartitionNumber].Mbr.BootIndicator;
				}
			}
			break;

			case PARTITION_STYLE_GPT :
			{
				GUID *pGuid = &(((DRIVE_LAYOUT_INFORMATION_EX *)(LPBYTE)pBuff)->PartitionEntry[dwPartitionNumber].Gpt.PartitionType);
				retVal = bSetIndicator = SetPartitionType(pInstance, pGuid, bIndicator, bPrimaryPartition);
			}
			break;

			case PARTITION_STYLE_RAW :
			default:
			{
				retVal = FALSE;
			}
			break;
		}

		if (retVal)
		{
			llStart = ((DRIVE_LAYOUT_INFORMATION_EX *)(LPBYTE)pBuff)->PartitionEntry[dwPartitionNumber].StartingOffset.QuadPart;
			llLength = ((DRIVE_LAYOUT_INFORMATION_EX *)(LPBYTE)pBuff)->PartitionEntry[dwPartitionNumber].PartitionLength.QuadPart;
		}
	}

	if (retVal)
	{
		CHString strDesc ;
		FormatMessage ( strDesc, IDR_DiskPartitionFormat , dwDiskIndex , dwFakePartitionNumber ) ;

		pInstance->SetCharSplat ( IDS_Caption , strDesc ) ;
		pInstance->SetCharSplat ( IDS_Name , strDesc ) ;

		TCHAR szTemp [ _MAX_PATH ] ;
		_stprintf (

			szTemp,
			L"Disk #%d, Partition #%d",
			dwDiskIndex,
			dwFakePartitionNumber
		) ;

		pInstance->SetCharSplat ( IDS_DeviceID , szTemp ) ;

		SetCreationClassName ( pInstance ) ;

		pInstance->SetWCHARSplat ( IDS_SystemCreationClassName , L"Win32_ComputerSystem" ) ;

		pInstance->SetCHString ( IDS_SystemName , GetLocalComputerName() ) ;

		pInstance->SetWBEMINT64 ( IDS_BlockSize , (ULONGLONG)BYTESPERSECTOR ) ;

		pInstance->SetDWORD ( IDS_DiskIndex , dwDiskIndex ) ;

		pInstance->SetDWORD ( IDS_Index , dwFakePartitionNumber ) ;

		pInstance->SetWBEMINT64 ( IDS_NumberOfBlocks , llLength /  (LONGLONG) BYTESPERSECTOR) ;

		pInstance->SetWBEMINT64 ( IDS_Size , llLength ) ;

		pInstance->SetWBEMINT64 ( IDS_StartingOffset , llStart ) ;

		if (bSetIndicator)
		{
			pInstance->Setbool ( IDS_PrimaryPartition , bPrimaryPartition ) ;

			if ( bIndicator )
			{
				// we can say this is bootable as it is active boot
				pInstance->Setbool ( IDS_Bootable, true ) ;
			}

			// indicator says if we booted up from this partition
			pInstance->Setbool ( IDS_BootPartition, bIndicator ) ;
		}
	}

	return retVal;
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskPartition::GetRealPartitionIndex
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
DWORD CWin32DiskPartition::GetRealPartitionIndex(DWORD dwFakePartitionIndex, LPBYTE pBuff, DWORD dwLayoutStyle)
{
	DWORD dwPartitionIndex = static_cast <DWORD> ( -1 );
	DWORD dwRealPartitionIndex = 0L;

	// loop counter
	DWORD dwPCount = (dwLayoutStyle == 1)
						? (reinterpret_cast <DRIVE_LAYOUT_INFORMATION *> (pBuff))->PartitionCount
						: (reinterpret_cast <DRIVE_LAYOUT_INFORMATION_EX *> (pBuff))->PartitionCount;

	BOOL bContinue = TRUE;

	if (dwLayoutStyle == 2)
	{
		for ( DWORD dwPartitionNumber = 0; dwPartitionNumber < dwPCount && bContinue; dwPartitionNumber++ )
		{
			switch ((reinterpret_cast <DRIVE_LAYOUT_INFORMATION_EX *> (pBuff))->PartitionEntry[dwPartitionNumber].PartitionStyle)
			{
				case PARTITION_STYLE_MBR :
				{
					UCHAR uPType = (reinterpret_cast <DRIVE_LAYOUT_INFORMATION_EX *> (pBuff))->PartitionEntry[dwPartitionNumber].Mbr.PartitionType;
					if ( static_cast <DWORD> (uPType) != PARTITION_ENTRY_UNUSED && !IsContainerPartition(static_cast <DWORD> (uPType)) )
					{
						if ( dwFakePartitionIndex == dwRealPartitionIndex )
						{
							bContinue = FALSE;
							dwPartitionIndex = dwPartitionNumber;
						}
						else
						{
							dwRealPartitionIndex ++;
						}
					}
				}
				break;

				case PARTITION_STYLE_GPT :
				{
					GUID *pGuid = &((reinterpret_cast <DRIVE_LAYOUT_INFORMATION_EX *> (pBuff))->PartitionEntry[dwPartitionNumber].Gpt.PartitionType);
					if ( !IsEqualGUID(*pGuid, PARTITION_ENTRY_UNUSED_GUID) && ! IsEqualGUID(*pGuid, PARTITION_MSFT_RESERVED_GUID) )
					{
						if ( dwFakePartitionIndex == dwRealPartitionIndex )
						{
							bContinue = FALSE;
							dwPartitionIndex = dwPartitionNumber;
						}
						else
						{
							dwRealPartitionIndex ++;
						}
					}
				}
				break;

				case PARTITION_STYLE_RAW :
				default:
				{
				}
				break;
			}
		}
	}
	else //dwLayoutStyle == 1
	{
		for ( DWORD dwPartitionNumber = 0; dwPartitionNumber < dwPCount && bContinue; dwPartitionNumber++ )
		{
			UCHAR uPType = (reinterpret_cast <DRIVE_LAYOUT_INFORMATION *> (pBuff))->PartitionEntry[dwPartitionNumber].PartitionType;
			if ( static_cast <DWORD> (uPType) != PARTITION_ENTRY_UNUSED && !IsContainerPartition(static_cast <DWORD> (uPType)) )
			{
				if ( dwFakePartitionIndex == dwRealPartitionIndex )
				{
					bContinue = FALSE;
					dwPartitionIndex = dwPartitionNumber;
				}
				else
				{
					dwRealPartitionIndex ++;
				}
			}
		}
	}

	return dwPartitionIndex;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskPartition::GetPartitionInfoNT
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
LPBYTE CWin32DiskPartition::GetPartitionInfoNT(LPCWSTR szTemp, DWORD &dwType)
{
    LPBYTE pDiskInfo = NULL;
	dwType = 0;

	SmartCloseHandle hDiskHandle = CreateFile (

		szTemp,
		FILE_ANY_ACCESS ,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		0,
		0
	) ;

	if ( hDiskHandle != INVALID_HANDLE_VALUE )
	{
		DWORD dwBytesAllocatedPartition = 0L;
		dwBytesAllocatedPartition = 32 * sizeof(PARTITION_INFORMATION_EX);

		DWORD dwBytesInfoAllocated = 0L;
		dwBytesInfoAllocated = sizeof(DRIVE_LAYOUT_INFORMATION_EX);

		DWORD dwBytesAllocated = 0L;
		dwBytesAllocated = dwBytesInfoAllocated + dwBytesAllocatedPartition;

		DWORD dwBytes = 0;

		BOOL bSucceeded = FALSE;
		BOOL bFailure = FALSE;

        // The reason we do this two different ways, is that using IOCTL_DISK_GET_DRIVE_LAYOUT
        // returns extended partitions as partitions.  In this class, we only want the 4 'hard'
        // partitions.  However, NEC_98 stores its info differently, so this approach doesn't work
        // there.  On the plus side, NEC_98 boxes don't have extended partitions, so we can safely
        // use IOCTL_DISK_GET_DRIVE_LAYOUT.
        if (IsNotNEC_98)
        {
			//let's try IOCTL_DISK_GET_DRIVE_LAYOUT_EX and work with extended partitions first...
			pDiskInfo = new BYTE [dwBytesAllocated];

			try
			{
				while ( pDiskInfo && !( bSucceeded || bFailure ) )
				{
					if (!DeviceIoControl(
						hDiskHandle,
						IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
						NULL,
						0,
						pDiskInfo,
						dwBytesAllocated,
						&dwBytes,
						NULL))
					{
						if ( ERROR_INSUFFICIENT_BUFFER == ::GetLastError () )
						{
							if ( pDiskInfo )
							{
								delete [] pDiskInfo;
								pDiskInfo = NULL;
							}

							dwBytesAllocated = dwBytesAllocated + dwBytesAllocatedPartition;
							pDiskInfo = new BYTE [dwBytesAllocated];
						}
						else
						{
							LogErrorMessage3(L"Failed to IOCTL_DISK_GET_DRIVE_LAYOUT_EX device %s (%d)", szTemp, GetLastError());

							if ( pDiskInfo )
							{
								delete [] pDiskInfo;
								pDiskInfo = NULL;
							}

							bFailure = FALSE;
						}
					}
					else
					{
						dwType = 2;

						bSucceeded = TRUE;
					}
				}
			}
			catch(...)
			{
				if ( pDiskInfo )
				{
					delete [] pDiskInfo;
					pDiskInfo = NULL;
				}

				throw;
			}

			if (pDiskInfo == NULL)
			{
				SmartCloseHandle hDiskReadHandle = CreateFile (

					szTemp,
					FILE_READ_ACCESS ,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					0,
					0
				) ;

				if ( hDiskReadHandle != INVALID_HANDLE_VALUE )
				{
					//Using IOCTL_DISK_GET_DRIVE_LAYOUT_EX failed, try the old fashioned way...

					// Get drive information
					//======================

					CSmartBuffer pClusterBuffer (CLUSTERSIZE);

					DWORD dwRead = 0 ;

					BOOL t_Status = ReadFile (

						hDiskReadHandle ,
						pClusterBuffer ,
						CLUSTERSIZE ,
						&dwRead ,
						NULL
					) ;

					// Get a more useful handle on the data
					MasterBootSector *stMasterBootSector = ( MasterBootSector * ) (LPBYTE)pClusterBuffer ;

					// See if the read worked, and the signature is there
					if ( t_Status && ( dwRead == CLUSTERSIZE ) && (stMasterBootSector->wSignature == 0xaa55) )
					{
						// This is the pointer we return
						pDiskInfo = new BYTE [sizeof(DRIVE_LAYOUT_INFORMATION) + (4 * sizeof(PARTITION_INFORMATION))];

						if (pDiskInfo)
						{
							try
							{
								// Copy the data to a common structure format
								DRIVE_LAYOUT_INFORMATION *pDInfo =  (DRIVE_LAYOUT_INFORMATION *)pDiskInfo;
								dwType = 1;
								pDInfo->PartitionCount = 4;
								pDInfo->Signature = stMasterBootSector->wSignature;

								for (DWORD x=0; x < 4; x++)
								{
									pDInfo->PartitionEntry[x].StartingOffset.QuadPart = stMasterBootSector->stPartition [ x ].dwSectorsPreceding;
									pDInfo->PartitionEntry[x].StartingOffset.QuadPart *= (LONGLONG)BYTESPERSECTOR;
									pDInfo->PartitionEntry[x].PartitionLength.QuadPart = stMasterBootSector->stPartition [ x ].dwLengthInSectors;
									pDInfo->PartitionEntry[x].PartitionLength.QuadPart *= (LONGLONG)BYTESPERSECTOR;
									pDInfo->PartitionEntry[x].HiddenSectors = 0;
									pDInfo->PartitionEntry[x].PartitionNumber = x;
									pDInfo->PartitionEntry[x].PartitionType = stMasterBootSector->stPartition [ x ].cOperatingSystem;
									pDInfo->PartitionEntry[x].BootIndicator = stMasterBootSector->stPartition [ x ].cBoot == 0x80;
									pDInfo->PartitionEntry[x].RecognizedPartition = TRUE; // Well....
									pDInfo->PartitionEntry[x].RewritePartition = FALSE;
								}
							}
							catch ( ... )
							{
								delete [] pDiskInfo;
								throw;
							}
						}
						else
						{
							throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
						}
					}
					else
					{
						LogErrorMessage3(L"Failed to read from device %s (%d)", szTemp, GetLastError());
					}
				}
			}
			else
			{
				LogErrorMessage3(L"Failed to open device %s (%d) for read", szTemp, GetLastError());
			}
        }
        else
        {
            pDiskInfo = new BYTE [dwBytesAllocated];
            if (pDiskInfo)
            {
                try
                {
                    // NOTE!  This ioctl is not appropriate for whistler and beyond.  However, nec98 isn't supported
                    // for whistler and beyond either.  The only reason this code is still here is that we MIGHT
                    // backprop this dll to w2k.
					while ( pDiskInfo && !( bSucceeded || bFailure ) )
					{
						if (!DeviceIoControl(
							hDiskHandle,
							IOCTL_DISK_GET_DRIVE_LAYOUT,
							NULL,
							0,
							pDiskInfo,
							dwBytesAllocated,
							&dwBytes,
							NULL))
						{
							if ( ERROR_INSUFFICIENT_BUFFER == ::GetLastError () )
							{
								if ( pDiskInfo )
								{
									delete [] pDiskInfo;
									pDiskInfo = NULL;
								}

								dwBytesAllocated = dwBytesAllocated + dwBytesAllocatedPartition;
								pDiskInfo = new BYTE [dwBytesAllocated];
							}
							else
							{
								LogErrorMessage3(L"Failed to IOCTL_DISK_GET_DRIVE_LAYOUT_EX device %s (%d)", szTemp, GetLastError());

								if ( pDiskInfo )
								{
									delete [] pDiskInfo;
									pDiskInfo = NULL;
								}

								bFailure = FALSE;
							}
						}
						else
						{
							dwType = 1;

							bSucceeded = TRUE;
						}
					}
                }
                catch ( ... )
                {
					if ( pDiskInfo )
					{
						delete [] pDiskInfo;
						pDiskInfo = NULL;
					}

                    throw;
                }
            }
            else
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}
        }
    }
    else
    {
        LogErrorMessage3(L"Failed to open device %s (%d)", szTemp, GetLastError());
    }

    return (LPBYTE)pDiskInfo;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\diskpartition.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  DiskPartition.h
//
//  Purpose: Disk partition instance provider
//
//***************************************************************************

// Property set identification
//============================

#define PROPSET_NAME_DISKPARTITION L"Win32_DiskPartition"
#define BYTESPERSECTOR 512

typedef BOOL (STDAPICALLTYPE *GETDISKFREESPACEEX)(LPCSTR lpDirectoryName,
                                                      PULARGE_INTEGER lpFreeBytesAvailableToCaller,
                                                      PULARGE_INTEGER lpTotalNumberOfBytes,
                                                      PULARGE_INTEGER lpTotalNumberOfFreeBytes);

typedef BOOL (WINAPI *KERNEL32_DISK_FREESPACEEX) (LPCTSTR lpDirectoryName,
                                                  PULARGE_INTEGER lpFreeBytesAvailableToCaller,
                                                  PULARGE_INTEGER lpTotalNumberOfBytes,
                                                  PULARGE_INTEGER lpTotalNumberOfFreeBytes) ;

#ifdef NTONLY

#pragma pack(push, 1)
typedef struct  
{
    BYTE cBoot;
    BYTE cStartHead;
    BYTE cStartSector;
    BYTE cStartTrack;
    BYTE cOperatingSystem;
    BYTE cEndHead;
    BYTE cEndSector;
    BYTE cEndTrack;
    DWORD dwSectorsPreceding;
    DWORD dwLengthInSectors;
} PartitionRecord, *pPartitionRecord;

typedef struct 
{
    BYTE cLoader[446];
    PartitionRecord stPartition[4];
    WORD wSignature;
} MasterBootSector, FAR *pMasterBootSector;

typedef struct
{
    // Article ID: Q140418 & Windows NT Server 4.0 resource kit - Chap 3 (partition boot sector)
    BYTE cJMP[3];
    BYTE cOEMID[8];
    WORD wBytesPerSector;
    BYTE cSectorsPerCluster;
    WORD wReservedSectors;
    BYTE cFats;
    WORD cRootEntries;
    WORD wSmallSectors;
    BYTE cMediaDescriptor;
    WORD wSectorsPerFat;
    WORD wSectorsPerTrack;
    WORD wHeads;
    DWORD dwHiddenSectors;
    DWORD dwLargeSectors;

    // ExtendedBiosParameterBlock (not always supported)
    BYTE cPhysicalDriveNumber;
    BYTE cCurrentHead;
    BYTE cSignature;
    DWORD dwID;
    BYTE cVolumeLabel[11];
    BYTE cSystemID[8];

    BYTE cBootStrap[448];
    BYTE cEndOfSector[2];

} PartitionBootSector, FAR *pPartitionBootSector;


#pragma pack(pop)
#endif

class CWin32DiskPartition ;

class CWin32DiskPartition:public Provider 
{
public:

        // Constructor/destructor
        //=======================

        CWin32DiskPartition(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CWin32DiskPartition() ;

        // Functions provide properties with current values
        //=================================================

        HRESULT GetObject(CInstance *pInstance, long lFlags = 0L) ;
        HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L) ;

private:

        // Utility
        //========

#ifdef NTONLY

        HRESULT RefreshInstanceNT (

			DWORD dwDiskIndex, 
			DWORD dwPartitionIndex, 
			CInstance *pInstance
		) ;

        HRESULT AddDynamicInstancesNT (

			MethodContext *pMethodContext
		) ;

        BOOL LoadPartitionValuesNT (

			CInstance *pInstance, 
			DWORD dwDiskIndex, 
            DWORD dwPartitionNumber, 
            DWORD dwFakePartitionNumber, 
			LPBYTE pBuff,
			DWORD dwLayoutStyle
		) ;

        LPBYTE	GetPartitionInfoNT(LPCWSTR szTemp, DWORD &dwType);
		DWORD	GetRealPartitionIndex(DWORD dwFakePartitionIndex, LPBYTE pBuff, DWORD dwLayoutStyle);

#endif
		BOOL GetDriveFreeSpace ( CInstance *pInstance , const char *pszName ) ;

        void CreateNameProperty ( DWORD dwDisk , DWORD dwPartition , char *pszName ) ;

        BOOL SetPartitionType ( CInstance *pInstance , DWORD dwPartitionType, DWORD dwPartitionIndex, BOOL &bIsPrimary ) ;
        BOOL SetPartitionType ( CInstance *pInstance , GUID *pGuidPartitionType , BOOL &bIsSystem, BOOL &bIsPrimary ) ;

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\displaycfg.cpp ===
///////////////////////////////////////////////////////////////////////

//

// displaycfg.cpp -- Implementation of MO Provider for Win32DisplayConfiguration

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//
//  10/05/96     jennymc     Initial Code
//  10/24/97     jennymc     Moved to new framework
//
///////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <cregcls.h>

#include <winuser.h>
#include "DisplayCfg.h"

// Property set declaration
//=========================

CWin32DisplayConfiguration MyCWin32DisplayConfigurationSet ( PROPSET_NAME_DISPLAY , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DisplayConfiguration::CWin32DisplayConfiguration
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32DisplayConfiguration :: CWin32DisplayConfiguration (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DisplayConfiguration::~CWin32DisplayConfiguration
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32DisplayConfiguration :: ~CWin32DisplayConfiguration ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DisplayConfiguration :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

	CHString littleOldKey ;
	if ( pInstance->GetCHString ( IDS_DeviceName, littleOldKey ) )
	{
		hr = GetDisplayInfo ( pInstance , TRUE ) ;
	}
	else
	{
		hr = WBEM_E_INVALID_PARAMETER ;
	}

	if ( SUCCEEDED ( hr ) )
	{
		CHString littleNewKey ;
		pInstance->GetCHString ( IDS_DeviceName, littleNewKey ) ;

		if ( littleNewKey.CompareNoCase ( littleOldKey ) != 0 )
		{
			hr = WBEM_E_NOT_FOUND ;
		}
	}

	return hr ;
}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DisplayConfiguration :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
	HRESULT hr = WBEM_E_FAILED;
    CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
    hr = GetDisplayInfo ( pInstance , TRUE ) ;
	if ( SUCCEEDED ( hr ) )
	{
		hr = pInstance->Commit ( ) ;
	}

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DisplayConfiguration :: GetDisplayInfo (

	CInstance *pInstance,
	BOOL fAssignKey
)
{
	CHString strName ;
	CHString strDesc ;

	CConfigManager      configMngr;
	CDeviceCollection   devCollection;

	if ( configMngr.GetDeviceListFilterByClass ( devCollection , L"Display" ) )
	{
		REFPTR_POSITION pos ;

		devCollection.BeginEnum ( pos ) ;

		if ( devCollection.GetSize () )
		{
			CConfigMgrDevicePtr pDevice(devCollection.GetNext ( pos ), false) ;
			if ( pDevice )
			{
				pDevice->GetDeviceDesc ( strDesc ) ;

				if ( strName.IsEmpty () )
				{
					strName = strDesc ;
				}

#ifdef NTONLY
				CHString strService ;
				CHString strFileName ;
				CHString strVersion ;

				// If under WinNT, get the version by getting the service
				// name and getting its version information.

				BOOL t_Status = pDevice->GetService ( strService ) &&
								GetServiceFileName ( strService , strFileName ) &&
								GetVersionFromFileName ( strFileName , strVersion ) ;

				if ( t_Status )
				{
					pInstance->SetCHString ( IDS_DriverVersion , strVersion ) ;
				}
#endif

			}
		}
	}

	if ( fAssignKey )
	{
		pInstance->SetCHString ( IDS_DeviceName , strName ) ;
	}

	pInstance->SetCHString ( IDS_Caption , strName ) ;

	pInstance->SetCHString ( L"SettingID" , strName ) ;

	pInstance->SetCHString ( IDS_Description , strDesc.IsEmpty () ? strName : strDesc ) ;

	//===============================================
	//  Get the info
	//===============================================

	DWORD dMode = ENUM_REGISTRY_SETTINGS ;

	HDC hdc = GetDC ( GetDesktopWindow () ) ;
	if (hdc)
	{
		try
		{

			DWORD dwTemp = (DWORD) GetDeviceCaps ( hdc , BITSPIXEL ) ;
			pInstance->SetDWORD ( IDS_BitsPerPel , dwTemp ) ;

			dwTemp = ( DWORD ) GetDeviceCaps ( hdc , HORZRES ) ;
			pInstance->SetDWORD( IDS_PelsWidth, dwTemp );

			dwTemp = ( DWORD ) GetDeviceCaps ( hdc , VERTRES ) ;
			pInstance->SetDWORD ( IDS_PelsHeight , dwTemp );

#ifdef NTONLY
			pInstance->SetDWORD ( IDS_DisplayFrequency, ( DWORD ) GetDeviceCaps ( hdc , VREFRESH ) ) ;
#endif
		}
		catch ( ... )
		{
			ReleaseDC ( GetDesktopWindow () , hdc ) ;
            throw;
		}

		ReleaseDC ( GetDesktopWindow () , hdc ) ;
	}

	DEVMODE DevMode ;

	memset ( & DevMode , 0 , sizeof ( DEVMODE ) ) ;

	DevMode.dmSize = sizeof ( DEVMODE ) ;
	DevMode.dmSpecVersion = DM_SPECVERSION ;

	BOOL t_Status = EnumDisplaySettings ( NULL, ENUM_CURRENT_SETTINGS , & DevMode ) ;
	if ( t_Status )
	{
		pInstance->SetDWORD ( IDS_SpecificationVersion, (DWORD) DevMode. dmSpecVersion ) ;

		if ( DevMode.dmFields & DM_LOGPIXELS )
		{
			pInstance->SetDWORD ( IDS_LogPixels , ( DWORD ) DevMode.dmLogPixels ) ;
		}

		if ( DevMode.dmFields & DM_DISPLAYFLAGS )
		{
			pInstance->SetDWORD ( IDS_DisplayFlags, DevMode.dmDisplayFlags ) ;
		}

	}


    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\displaycfg.h ===
///////////////////////////////////////////////////////////////////////

//                                                                   

// Display.h        	

//                                                                  

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//                                                                   
//  10/05/96     jennymc     Initial Code
//  10/24/96     jennymc     Moved to new framework
//                                                                   
///////////////////////////////////////////////////////////////////////

#define PROPSET_NAME_DISPLAY L"Win32_DisplayConfiguration"
#define WIN95_DSPCTLCFG_BOOT_DESC						_T("Boot.Description")
#define WIN95_DSPCTLCFG_DISPLAY_DRV						_T("Display.Drv")
#define	WIN95_DSPCTLCFG_SYSTEM_INI						_T("SYSTEM.INI")

#define	DSPCTLCFG_DEFAULT_NAME							_T("Current Display Controller Configuration")

///////////////////////////////////////////////////////////////////////////////////////
class CWin32DisplayConfiguration : Provider{

    public:

        // Constructor/destructor
        //=======================

        CWin32DisplayConfiguration(LPCWSTR name, LPCWSTR pszNamespace);
       ~CWin32DisplayConfiguration() ;

        // Funcitons provide properties with current values
        //=================================================
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);


        // Utility
        //========

    private:

        HRESULT GetDisplayInfo(CInstance *pInstance, BOOL fAssignKey);
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\displayctrlcfg.h ===
///////////////////////////////////////////////////////////////////////

//                                                                   //

// DisplayCtrlCfg.h -- Video display controller property set         //

//                      description for WBEM MO                      //

//                                                                   //

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//                                                                   //
// 09/08/95     a-skaja     Prototype                                //
// 09/27/96     jennymc     Updated to meet current standards        //
//                                                                   //
///////////////////////////////////////////////////////////////////////

#define	PROPSET_NAME_DSPCTLCFG	L"Win32_DisplayControllerConfiguration"

//==================================================================

///////////////////////////////////////////////////////////////////////////////////////
//                                                                                   //
//                           PROPERTY SET DEFINITION                                 //
//                                                                                   //
///////////////////////////////////////////////////////////////////////////////////////
#define WIN95_DSPCTLCFG_REGISTRY_KEY _T("System\\CurrentControlSet\\Services\\Class\\Display\\0000")
#define WIN95_DSPCTLCFG_MONITOR_TYPE_REGISTRY_KEY _T("System\\CurrentControlSet\\Services\\Class\\Monitor\\0000")
#define WIN95_DSPCTLCFG_MONITOR_MFG_REGISTRY_KEY _T("Enum\\Monitor\\Default_Monitor\\0001")
#define WINNT_DSPCTLCFG_REGISTRY_KEY             _T("HARDWARE\\DEVICEMAP\\DSPCTLCFG")
#define WIN95_DISPLAY_DRIVER_KEY			 _T("System\\CurrentControlSet\\Services\\Class\\Display")

#define	WINNT_DSPCTLCFG_ADAPTERSTRING_VALUE_NAME		_T("HardwareInformation.AdapterString")
#define	WINNT_DSPCTLCFG_DISPLAYADAPTERNAME_KEY			_T("HARDWARE\\DEVICEMAP\\VIDEO")
#define	WINNT_DSPCTLCFG_VIDEOADAPTERKEY_VALUE			_T("\\Device\\Video0")

#define WIN95_DSPCTLCFG_BOOT_DESC						_T("Boot.Description")
#define WIN95_DSPCTLCFG_DISPLAY_DRV						_T("Display.Drv")
#define	WIN95_DSPCTLCFG_SYSTEM_INI						_T("SYSTEM.INI")

#define	DSPCTLCFG_DEFAULT_NAME							_T("Current Display Controller Configuration")

#define ADAPTER_DESC _T("DriverDesc")
#define MONITOR_TYPE _T("DriverDesc")
#define MONITOR_MFG _T("DriverDesc")
#define MFG _T("Mfg")
#define ADAPTER_COMPATIBILITY                _T("Adapter Compatibility")
#define DSPCTLCFG_INFO_PATH                  _T("\\Device\\Video0")
#define SERVICES                             _T("\\SERVICES\\")
#define DEVICE                               _T("\\DEVICE")
#define SYSTEM                               _T("\\SYSTEM")
#define INTERLACED                           _T("DefaultSettings.Interlaced")
#define INSTALLED_DISPLAY_DRIVERS            _T("InstalledDisplayDrivers")
#define ADAPTER_RAM                          _T("HardwareInformation.MemorySize")
#define ADAPTER_DESCRIPTION                  _T("HardwareInformation.AdapterString")
#define ADAPTER_CHIPTYPE                     _T("HardwareInformation.ChipType")
#define ADAPTER_DAC_TYPE                     _T("HardwareInformation.DACType")
#define WINNT_HARDWARE_DESCRIPTION_REGISTRY_KEY _T("HARDWARE\\Description\\System")
#define DISPLAY_CONTROLLER                   _T("DisplayController")
#define INTERNAL                             _T("INTERNAL")
#define INTEGRATED_CIRCUITRY                 _T("Integrated circuitry/Internal")
#define ADD_ON_CARD                          _T("Add-on card on ")
#define MONITOR_PERIPHERAL                   _T("\\MonitorPeripheral\\0")
#define ZERO                                 _T("\\0")
#define IDENTIFIER                           _T("Identifier")
#define SLASH                                _T("\\")
#define INF_PATH		_T("InfPath")
#define INF_SECTION		_T("InfSection")
#define DRIVER_DATE		_T("DriverDate")
///////////////////////////////////////////////////////////////////////////////////////

class CWin32DisplayControllerConfig : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32DisplayControllerConfig( LPCWSTR strName, LPCWSTR pszNamespace ) ;
       ~CWin32DisplayControllerConfig() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility
        //========

        // Utility function(s)
        //====================

    private:

#ifdef NTONLY
	    BOOL GetNTInstance( CInstance* pInstance );
	    BOOL RefreshNTInstance( CInstance* pInstance );
		void GetNameNT( CHString& strName );
#endif
        BOOL GetCommonVideoInfo( CInstance* pInstance );

		void SetVideoMode( CInstance* pInstance );

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\dma.cpp ===
/////////////////////////////////////////////////////////////////

//

// DMA.CPP -- DMA managed object implementation

//

//  Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
// 10/18/95     a-skaja     Prototype for demo
// 09/10/96     jennymc     Updated to current standards
//
/////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <cregcls.h>

#include <conio.h>
#include <winnls.h>
#include <wincon.h>

#include "chwres.h"
#include "ntdevtosvcsearch.h"
#include "resource.h"
#include <set>

#include "DMA.h"

CWin32DMAChannel MyCWin32DMAChannelSet ( PROPSET_NAME_DMA , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DMAChannel::CWin32DMAChannel
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32DMAChannel :: CWin32DMAChannel (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
}
/*****************************************************************************
 *
 *  FUNCTION    : CWin32DMAChannel::~CWin32DMAChannel
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32DMAChannel :: ~CWin32DMAChannel ()
{
}
/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DMAChannel :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{

#ifdef NTONLY

 	HRESULT hr = GetNTDMA ( NULL , pInstance ) ;

#else

 	HRESULT hr = GetWin9XDMA ( NULL , pInstance ) ;

#endif

    return hr ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DMAChannel::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each logical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DMAChannel :: EnumerateInstances (

	MethodContext *pMethodContext ,
	long lFlags /*= 0L*/)
{

#ifdef NTONLY

	HRESULT hr = GetNTDMA ( pMethodContext , NULL ) ;

#else

	HRESULT hr = GetWin9XDMA ( pMethodContext , NULL ) ;
#endif

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DMAChannel::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each logical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY

HRESULT CWin32DMAChannel :: GetNTDMA (

	MethodContext *pMethodContext ,
    CInstance *pInstance
)
{
    HRESULT hr = WBEM_S_NO_ERROR ;

	CInstancePtr pInstanceAlias ( pInstance );
    //=======================================
    // If we are refreshing a specific
    // instance, get which channel we are
    // going for
    //=======================================

	DWORD ChannelNumberToRefresh ;

    if ( pInstanceAlias )
	{
        pInstanceAlias->GetDWORD ( IDS_DMAChannel, ChannelNumberToRefresh ) ;
	}

    //=======================================
    // Create hardware system resource list &
    // get the head of the list
    //=======================================

#if NTONLY == 4
    CHWResource HardwareResource ;
    HardwareResource.CreateSystemResourceLists () ;

    SYSTEM_RESOURCES SystemResource ;
    SystemResource = HardwareResource._SystemResourceList;


    // Just count how many DMAs we're going to find.  We need this so
    // we can build an array to keep the DMAs found so we don't commit
    // the same DMA more than once.  (This problem only seems to happen
    // on NT5.

    LPRESOURCE_DESCRIPTOR ResourceDescriptor ;

	int nFound = 0 ;
	int nDMA ;

    for (	nDMA = 0, ResourceDescriptor = SystemResource.DmaHead;
			ResourceDescriptor;
			ResourceDescriptor = ResourceDescriptor->NextSame, nDMA++
	)
    {
    }

    DWORD *pdwDMAFound = new DWORD [ nDMA ] ;

	if ( pdwDMAFound )
	{
		try
		{
			// Go through the list of DMAs.

			for (	ResourceDescriptor = SystemResource.DmaHead;
					ResourceDescriptor;
					ResourceDescriptor = ResourceDescriptor->NextSame
			)
			{
				//===============================================================
				//  If we are just trying to refresh a specific one and it is NOT
				//  the one we want, get the next one...
				//===============================================================
				if ( ! pMethodContext )
				{
					if ( ChannelNumberToRefresh != ResourceDescriptor->CmResourceDescriptor.u.Dma.Channel )
					{
						continue ;
					}
				}
				else
				{
					// Look to see if we already have this DMA value.

					for ( int i = 0; i < nFound; i++ )
					{
						// Skip this DMA if we already have it.
						if ( ResourceDescriptor->CmResourceDescriptor.u.Dma.Channel == pdwDMAFound [ i ] )
						{
							break ;
						}
					}

					// Skip this DMA if we already have it.
					// If we didn't find it, i == nFound.

					if ( i != nFound )
					{
						continue ;
					}

					pdwDMAFound[nFound++] = ResourceDescriptor->CmResourceDescriptor.u.Dma.Channel ;

					pInstanceAlias.Attach( CreateNewInstance ( pMethodContext ) );
				
					pInstanceAlias->SetDWORD ( IDS_DMAChannel , ResourceDescriptor->CmResourceDescriptor.u.Dma.Channel ) ;
				}

				//===============================================================
				// If we are here, we want it
				//===============================================================

				//---------------------------------------------------------------
				// Set defaults for unknown items

				pInstanceAlias->SetWBEMINT16 ( L"AddressSize" , 0 ) ;
				pInstanceAlias->SetDWORD ( L"MaxTransferSize" , 0 ) ;
				pInstanceAlias->SetWBEMINT16 ( L"ByteMode" , 2 ) ;
				pInstanceAlias->SetWBEMINT16 ( L"WordMode" , 2 ) ;
				pInstanceAlias->SetWBEMINT16 ( L"ChannelTiming" , 2 ) ;
				pInstanceAlias->SetWBEMINT16 ( L"TypeCTiming" , 2 ) ;

				SAFEARRAYBOUND rgsabound [ 1 ] ;

				rgsabound [ 0 ].cElements = 1 ;
				rgsabound [ 0 ].lLbound = 0 ;

				SAFEARRAY *sa = SafeArrayCreate ( VT_I2 , 1 , rgsabound ) ;
				if ( sa )
				{
					try
					{
						long ix [ 1 ] ;

						ix [ 0 ] = 0 ;
						WORD wWidth = 0;

						HRESULT t_Result = SafeArrayPutElement ( sa , ix , &wWidth ) ;
						if ( t_Result != E_OUTOFMEMORY )
						{
							VARIANT vValue;

							VariantInit(&vValue);

							V_VT(&vValue) = VT_I2 | VT_ARRAY ;
							V_ARRAY(&vValue) = sa ;
							sa = NULL ;

							try
							{
								pInstanceAlias->SetVariant(L"TransferWidths", vValue);
							}
							catch ( ... )
							{
								VariantClear ( & vValue ) ;

								throw ;
							}

							VariantClear ( & vValue ) ;
						}
						else
						{
							SafeArrayDestroy ( sa ) ;
							sa = NULL ;

							throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
						}
					}
					catch ( ... )
					{
						if ( sa )
						{
							SafeArrayDestroy ( sa ) ;
						}

						throw ;
					}
				}
				else
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}
				//---------------------------------------------------------------

				CHString sTemp ;
				Format ( sTemp , IDR_ChannelFormat , ResourceDescriptor->CmResourceDescriptor.u.Dma.Channel ) ;

				pInstanceAlias->SetCHString ( IDS_Name , sTemp ) ;

				CHString sDesc ;
				Format ( sDesc , IDR_ChannelFormat , ResourceDescriptor->CmResourceDescriptor.u.Dma.Channel ) ;

				pInstanceAlias->SetCHString ( IDS_Caption , sDesc ) ;

				pInstanceAlias->SetCHString ( IDS_Description , sDesc ) ;

				pInstanceAlias->SetDWORD (IDS_Port, ResourceDescriptor->CmResourceDescriptor.u.Dma.Port ) ;

				pInstanceAlias->SetCharSplat ( IDS_Status , IDS_OK ) ;

				SetCreationClassName ( pInstanceAlias ) ;

				pInstanceAlias->SetCHString ( IDS_CSName , GetLocalComputerName () ) ;

				pInstanceAlias->SetCHString ( IDS_CSCreationClassName , _T("Win32_ComputerSystem") ) ;

				pInstanceAlias->SetWBEMINT16 ( IDS_Availability , 4 ) ;

				//===============================================================
				// Set return code
				//===============================================================

				hr = WBEM_NO_ERROR ;

				if ( pMethodContext )
				{
					hr = pInstanceAlias->Commit ( ) ;
				}
			}
		}
		catch ( ... )
		{
			delete [] pdwDMAFound ;

			throw ;
		}

		delete [] pdwDMAFound ;
	}
	else
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}

#else   // Modernized approach: use Config Manager.

    CConfigManager cfgManager;
    CDeviceCollection deviceList;
    std::set<long> setDMA;
    bool fDone = false;
    bool fFound = false; 

    if(cfgManager.GetDeviceList(deviceList))
    {
        REFPTR_POSITION posDev;

        if(deviceList.BeginEnum(posDev))
        {
            // Walk the list
            CConfigMgrDevicePtr pDevice;
            for(pDevice.Attach(deviceList.GetNext(posDev));
                SUCCEEDED(hr) && (pDevice != NULL) && !fDone;
                pDevice.Attach(deviceList.GetNext(posDev)))
            {
				// Enumerate the device's DMA resource usage...
                CDMACollection DevDMACollection;
                REFPTR_POSITION posDMA;

                pDevice->GetDMAResources(DevDMACollection);

                if(DevDMACollection.BeginEnum(posDMA))
                {
                    CDMADescriptorPtr pDMA(NULL);
                    // Walk the dma's
                    for(pDMA.Attach(DevDMACollection.GetNext(posDMA));
                        pDMA != NULL && !fDone && SUCCEEDED(hr);
                        pDMA.Attach(DevDMACollection.GetNext(posDMA)))
                    {
                        ULONG ulChannel = pDMA->GetChannel();

				        // If we are just trying to refresh a 
                        // specific one and it is NOT
				        // the one we want, get the next one...
				        if(!pMethodContext) // we were called by GetObject
				        {
					        if(ChannelNumberToRefresh != ulChannel)
					        {
						        continue;
					        }
                            else
                            {
                                SetNonKeyProps(pInstanceAlias, pDMA);
                                fDone = fFound = true;
                            }
				        }
				        else  // We were called by enum
				        {
                            // If we don't have this DMA already,
                            if(!FoundAlready(ulChannel, setDMA))
				            {
					            // add it to the list,
                                setDMA.insert(ulChannel);
                                // create a new instance,
                                pInstanceAlias.Attach(CreateNewInstance(pMethodContext));
				                // set that instance's properties,
					            pInstanceAlias->SetDWORD(IDS_DMAChannel, ulChannel);  // key
                                SetNonKeyProps(pInstanceAlias, pDMA);
                                // and commit it.
                                hr = pInstanceAlias->Commit();
                            }
                        }
                    }
                    DevDMACollection.EndEnum();
				}
            }
            deviceList.EndEnum();
        }
    }
#endif

    if(!fFound)
    {
        hr = WBEM_E_NOT_FOUND;
    }

    return hr ;
}


bool CWin32DMAChannel::FoundAlready(
    ULONG ulKey,
    std::set<long>& S)
{
    return (S.find(ulKey) != S.end());
}


void CWin32DMAChannel::SetNonKeyProps(
    CInstance* pInstance, 
    CDMADescriptor* pDMA)
{
    pInstance->SetWBEMINT16(L"AddressSize", 0);
	pInstance->SetDWORD(L"MaxTransferSize", 0);
	pInstance->SetWBEMINT16(L"ByteMode", 2);
	pInstance->SetWBEMINT16(L"WordMode", 2);
	pInstance->SetWBEMINT16(L"ChannelTiming", 2);
	pInstance->SetWBEMINT16(L"TypeCTiming", 2);

    SAFEARRAYBOUND rgsabound[1];

	rgsabound[0].cElements = 1;
	rgsabound[0].lLbound = 0;

	SAFEARRAY *sa = ::SafeArrayCreate(VT_I2, 1, rgsabound);
	if(sa)
	{
		try
		{
			long ix[1];

			ix[0] = 0;
			WORD wWidth = 0;

			if(::SafeArrayPutElement(sa , ix, &wWidth) != E_OUTOFMEMORY)
			{
				VARIANT vValue;
				::VariantInit(&vValue);
				V_VT(&vValue) = VT_I2 | VT_ARRAY;
				V_ARRAY(&vValue) = sa;
				sa = NULL;

				try
				{
					pInstance->SetVariant(L"TransferWidths", vValue);
				}
				catch(...)
				{
					::VariantClear(&vValue);
					throw;
				}

				::VariantClear(&vValue);
			}
			else
			{
				::SafeArrayDestroy(sa);
				sa = NULL ;

				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}
		}
		catch(...)
		{
			if(sa)
			{
				::SafeArrayDestroy(sa);
			}
			throw;
		}
	}
	else
	{
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

    CHString chstrTemp;
    Format(chstrTemp, IDR_ChannelFormat, pDMA->GetChannel());
    pInstance->SetCHString(IDS_Name, chstrTemp);

    pInstance->SetCHString(IDS_Caption, chstrTemp);
    pInstance->SetCHString(IDS_Description, chstrTemp);

    // DMA ports are an invalid concept for W2K and later.
    // pInstanceAlias->SetDWORD(IDS_Port, ResourceDescriptor->CmResourceDescriptor.u.Dma.Port ) ;

    pInstance->SetCharSplat(IDS_Status, IDS_OK);
    SetCreationClassName(pInstance);
    pInstance->SetCHString(IDS_CSName, GetLocalComputerName());
    pInstance->SetCHString(IDS_CSCreationClassName, _T("Win32_ComputerSystem"));
    pInstance->SetWBEMINT16(IDS_Availability, 4);
}
#else

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DMAChannel::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each logical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DMAChannel::GetWin9XDMA (

	MethodContext *pMethodContext ,
    CInstance *pInstance
)
{
    HRESULT hr = WBEM_E_NOT_FOUND ;

	CInstancePtr pInstanceAlias ( pInstance );
    //=================================================================
    // If we are refreshing a specific instance, get which channel we
    // are going for
    //=================================================================

    DWORD ChannelNumberToRefresh ;

    if ( pInstanceAlias )
	{
        pInstanceAlias->GetDWORD ( IDS_DMAChannel , ChannelNumberToRefresh ) ;
    }

    //=================================================================
    // Get the latest DMA info from the Configuration Manager
    //=================================================================

    CConfigManager CMgr ( ResType_DMA ) ;

    if ( CMgr.RefreshList () )
	{
		unsigned int iUsed [8] = {0, 0, 0, 0, 0, 0, 0, 0};

        for ( int i = 0 ; i < CMgr.GetTotal () ; i++ )
		{
            //=========================================================
            //  Get the instance to process
            //=========================================================

            DMA_INFO *pDMA = CMgr.GetDMA ( i ) ;

            // If this channel has already been reported

            if ( BitSet ( iUsed , pDMA->Channel , sizeof ( iUsed ) ) )
			{
                continue;
            }

            //=========================================================
            //  If we are just trying to refresh a specific one and it
            //  is NOT the one we want, get the next one...
            //=========================================================

            if ( ! pMethodContext )
			{
	            if ( ChannelNumberToRefresh != pDMA->Channel )
				{
	                continue ;
                }
		    }
            else
			{
                pInstanceAlias.Attach ( CreateNewInstance ( pMethodContext ) );
                
/*
 *	Only set key when creating new instances.
 */
	    		pInstanceAlias->SetDWORD ( IDS_DMAChannel , pDMA->Channel ) ;
            }

			//---------------------------------------------------------------
			// Set defaults for unknown items

			pInstanceAlias->SetWBEMINT16 ( L"AddressSize" , 0 ) ;
			pInstanceAlias->SetDWORD ( L"MaxTransferSize" , 0 ) ;
			pInstanceAlias->SetWBEMINT16 ( L"ByteMode" , 2 ) ;
			pInstanceAlias->SetWBEMINT16 ( L"WordMode" , 2 ) ;
			pInstanceAlias->SetWBEMINT16 ( L"ChannelTiming" , 2 ) ;
			pInstanceAlias->SetWBEMINT16 ( L"TypeCTiming" , 2 ) ;
            pInstanceAlias->SetCharSplat ( IDS_Status , IDS_OK ) ;

			//===========================================================
			//  Get what we can
			//===========================================================

			SAFEARRAYBOUND rgsabound [ 1 ] ;

			rgsabound [ 0 ].cElements = 1 ;
			rgsabound [ 0 ].lLbound = 0 ;

			SAFEARRAY *sa = SafeArrayCreate ( VT_I2 , 1 , rgsabound ) ;
			if ( sa )
			{
				try
				{
					long ix [ 1 ] ;

					ix [ 0 ] = 0 ;

					HRESULT t_Result = SafeArrayPutElement ( sa , ix , & ( pDMA->ChannelWidth ) ) ;
					if ( t_Result != E_OUTOFMEMORY )
					{
						VARIANT vValue;

						VariantInit(&vValue);

						V_VT(&vValue) = VT_I2 | VT_ARRAY ;
						V_ARRAY(&vValue) = sa ;
						sa = NULL ;

						try
						{
							pInstanceAlias->SetVariant(L"TransferWidths", vValue);
						}
						catch ( ... )
						{
							VariantClear ( & vValue ) ;

							throw ;
						}

						VariantClear ( & vValue ) ;
					}
					else
					{
						SafeArrayDestroy ( sa ) ;
						sa = NULL ;

						throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
					}
				}
				catch ( ... )
				{
					if ( sa )
					{
						SafeArrayDestroy ( sa ) ;
					}

					throw ;
				}
			}
			else
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}

			pInstanceAlias->SetWBEMINT16 ( IDS_Availability, 4 ) ;

			CHString strTemp;
			Format ( strTemp, IDR_DMAFormat , pDMA->Channel ) ;

			pInstanceAlias->SetCharSplat ( IDS_Caption, strTemp ) ;
			pInstanceAlias->SetCharSplat ( IDS_Description, strTemp ) ;
			pInstanceAlias->SetCHString ( IDS_Name, strTemp ) ;

#if NTONLY >= 5
            if (pDMA->Port != 0xffffffff)
            {
    			pInstanceAlias->SetDWORD(IDS_Port , pDMA->Port);
            }
#endif

			SetCreationClassName ( pInstanceAlias ) ;

			pInstanceAlias->SetCHString ( IDS_CSName , GetLocalComputerName () ) ;

			pInstanceAlias->SetCHString ( IDS_CSCreationClassName , _T("Win32_ComputerSystem" ) ) ;

			//===========================================================
			// Set return code
			//===========================================================

			hr = WBEM_NO_ERROR;

			//===========================================================
			//  If we just want this one, then break out of here,
			//  otherwise get them all
			//===========================================================

			if ( ! pMethodContext )
			{
				break;
			}
			else
			{
					hr = pInstanceAlias->Commit () ;
			}
		}
    }

    if ( ( ! pMethodContext ) && ( FAILED ( hr ) ) )
	{
        hr = WBEM_E_NOT_FOUND ;
    }

    return hr ;
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DMAChannel::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each logical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

bool CWin32DMAChannel :: BitSet (

	unsigned int iUsed[],
	ULONG iPos,
	DWORD iSize
)
{
	bool bRet;

    // iIndex is which DWORD to modify
	DWORD iIndex = iPos / (sizeof(iUsed[0]) * 8);

    // Make sure we have that many dwords
	if (iIndex < iSize)
	{
	    // I don't know why I need these, but if I don't use them, the compiler keeps
	    // adding code to extend the sign.  Once the optimizer gets this, it shouldn't
	    // matter anyway.
		unsigned int a1, a2;

        // a1 will tell how many bits over within the current dword
        // we need to move
		a1 =   iPos - (iIndex * (sizeof(iUsed[0]) * 8));

        // a2 will have set the bit we are trying to set
		a2 = 1 << a1;

        // The return value will indicate whether that bit had already been set.
		bRet = iUsed[iIndex] & a2;

		iUsed[iIndex] |= a2;
	}
	else
	{
		bRet = false;
		LogErrorMessage(L"Overflow on irq table");
	}

	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\dma.h ===
///////////////////////////////////////////////////////////////////////

//                                                                   //

// DMA.h -- DMA property set description for WBEM MO                 //

//                                                                   //

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//                                                                   //
//                                                                   //
///////////////////////////////////////////////////////////////////////
#define PROPSET_NAME_DMA  L"Win32_DMAChannel"

class CWin32DMAChannel : public Provider{

    public:

        //=================================================
        // Constructor/destructor
        //=================================================

        CWin32DMAChannel(LPCWSTR name, LPCWSTR pszNamespace);
       ~CWin32DMAChannel() ;

        //=================================================
        // Functions provide properties with current values
        //=================================================
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
        



#ifdef NTONLY
#if NTONLY > 4
        void SetNonKeyProps(
            CInstance* pInstance, 
            CDMADescriptor* pDMA);

        bool FoundAlready(
            ULONG ulKey,
            std::set<long>& S);
#endif
        HRESULT GetNTDMA(MethodContext*  pMethodContext,
                         CInstance *pSpecificInstance );
#else
        HRESULT GetWin9XDMA(MethodContext*  pMethodContext,
                         CInstance *pSpecificInstance );
#endif

        //=================================================
        // Utility
        //=================================================
    private:
        bool BitSet(unsigned int iUsed[], ULONG iPos, DWORD iSize);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\dllmain.h ===
//***************************************************************************

//

//  MAINDLL.H

// 

//  Module: WBEM Framework Instance provider 

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

HRESULT RegisterServer(TCHAR *a_pName, REFGUID a_rguid ) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\displayctrlcfg.cpp ===
//

// DSPCTLCFG.CPP -- video managed object implementation

//

//  Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
// 09/23/95     a-skaja     Prototype for demo
// 09/27/96     jennymc     Updated to current standards
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <cregcls.h>

#include "displayctrlcfg.h"

//////////////////////////////////////////////////////////////////////

// Property set declaration
//=========================

CWin32DisplayControllerConfig win32DspCtlCfg ( PROPSET_NAME_DSPCTLCFG , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DisplayControllerConfig::CWin32DisplayControllerConfig
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32DisplayControllerConfig :: CWin32DisplayControllerConfig (

	LPCWSTR strName,
    LPCWSTR pszNamespace

) : Provider ( strName, pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DisplayControllerConfig::~CWin32DisplayControllerConfig
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32DisplayControllerConfig::~CWin32DisplayControllerConfig()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DisplayControllerConfig :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
	// Find the instance depending on platform id.

#ifdef NTONLY
	BOOL fReturn = RefreshNTInstance ( pInstance ) ;
#endif

	return ( fReturn ? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND );
}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DisplayControllerConfig :: EnumerateInstances (

	MethodContext *pMethodContext ,
	long lFlags /*= 0L*/
)
{
	HRESULT hr = WBEM_E_OUT_OF_MEMORY;
	CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
	if ( NULL != pInstance )
	{
		// Get the proper OS dependent instance

#ifdef NTONLY

		BOOL fReturn = GetNTInstance ( pInstance ) ;

#endif


		// Commit the instance if'n we got it.

		if ( fReturn )
		{
			hr = pInstance->Commit ( ) ;
		}

		hr = WBEM_S_NO_ERROR ;
	}

	return hr ;
}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY

BOOL CWin32DisplayControllerConfig :: RefreshNTInstance (

	CInstance *pInstance
)
{
	BOOL fReturn = FALSE ;

	// Check that we will be getting the requested instance

	CHString strName ;
	GetNameNT ( strName ) ;

	CHString strInstanceName ;
	pInstance->GetCHString ( IDS_Name , strInstanceName ) ;

	if ( 0 == strInstanceName.CompareNoCase ( strName ) )
	{
		fReturn = GetNTInstance ( pInstance ) ;
	}

    return fReturn;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY

BOOL CWin32DisplayControllerConfig :: GetNTInstance ( CInstance *pInstance )
{
	// Get the adapter name from the registry

	CHString strName ;
	GetNameNT ( strName ) ;

	pInstance->SetCHString ( IDS_Name , strName ) ;
	pInstance->SetCHString ( IDS_Caption , strName ) ;
	pInstance->SetCHString ( _T("SettingID") , strName ) ;
	pInstance->SetCHString ( IDS_Description , strName ) ;

	BOOL fReturn = FALSE ;

	// Get commonly available information, then go ahead and obtain
	// NT applicable information

	if ( GetCommonVideoInfo ( pInstance ) )
	{

		// For now, the only NT Specific value we are getting is the Refresh Rate
		// Don't fail if GetDC fails here since we got mosty of the values anyway

		HDC hdc = GetDC ( NULL );
		if ( NULL != hdc )
		{
			try
			{
				pInstance->SetDWORD ( IDS_RefreshRate , (DWORD) GetDeviceCaps ( hdc , VREFRESH ) ) ;
			}
			catch ( ... )
			{
				ReleaseDC ( NULL, hdc ) ;

				throw ;
			}

			ReleaseDC ( NULL, hdc ) ;

		}

		// We need the refresh rate to set the video mode correctly.

		SetVideoMode ( pInstance ) ;

		fReturn = TRUE ;

	}

	return fReturn ;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CWin32DisplayControllerConfig :: GetCommonVideoInfo ( CInstance *pInstance )
{
    HDC hdc = GetDC ( NULL ) ;
    if( hdc )
	{
		try
		{
			//  Get the common info
			//=============================

			DWORD dwTemp = (DWORD) GetDeviceCaps ( hdc , BITSPIXEL ) ;
			pInstance->SetDWORD ( IDS_BitsPerPixel , dwTemp ) ;

			dwTemp = (DWORD) GetDeviceCaps ( hdc , PLANES ) ;
			pInstance->SetDWORD ( IDS_ColorPlanes , dwTemp ) ;

			dwTemp = (DWORD) GetDeviceCaps ( hdc , NUMCOLORS ) ;
			pInstance->SetDWORD ( IDS_DeviceEntriesInAColorTable , dwTemp ) ;

			dwTemp = (DWORD) GetDeviceCaps ( hdc , NUMPENS ) ;
			pInstance->SetDWORD ( IDS_DeviceSpecificPens , dwTemp ) ;

			dwTemp = (DWORD) GetDeviceCaps ( hdc , HORZRES ) ;
			pInstance->SetDWORD ( IDS_HorizontalResolution , dwTemp ) ;

			dwTemp = (DWORD) GetDeviceCaps ( hdc , VERTRES ) ;
			pInstance->SetDWORD ( IDS_VerticalResolution , dwTemp ) ;

			if ( GetDeviceCaps ( hdc , RASTERCAPS ) & RC_PALETTE )
			{
				dwTemp = (DWORD) GetDeviceCaps ( hdc , SIZEPALETTE ) ;
				pInstance->SetDWORD ( IDS_SystemPaletteEntries , dwTemp ) ;

				dwTemp = (DWORD) GetDeviceCaps ( hdc , NUMRESERVED ) ;
				pInstance->SetDWORD ( IDS_ReservedSystemPaletteEntries , dwTemp ) ;
			}
		}
		catch ( ... )
		{
			ReleaseDC ( NULL , hdc ) ;

			throw ;
		}

		ReleaseDC ( NULL , hdc ) ;
	}
	else
	{
        return FALSE ;
	}

    return TRUE ;
}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void CWin32DisplayControllerConfig :: SetVideoMode ( CInstance *pInstance )
{
	DWORD dwBitsPerPixel = 0 ;
	DWORD dwHorizontalResolution = 0 ;
	DWORD dwVerticalResolution = 0 ;
	DWORD dwRefreshRate =0 ;

	pInstance->GetDWORD ( IDS_BitsPerPixel , dwBitsPerPixel ) ;
	pInstance->GetDWORD ( IDS_HorizontalResolution , dwHorizontalResolution ) ;
	pInstance->GetDWORD ( IDS_VerticalResolution , dwVerticalResolution ) ;
	pInstance->GetDWORD ( IDS_RefreshRate , dwRefreshRate ) ;

	// DevMode MUST be Zeroed out or NT 3.51

	DEVMODE	devmode ;

    memset ( &devmode , NULL , sizeof ( DEVMODE ) ) ;
    devmode.dmSize = sizeof ( DEVMODE ) ;

	// Enumerate the display modes until we find one that matches our settings

	DWORD dwModeNum = 0 ;
	BOOL fFoundMode	= FALSE ;

	// Not localized, deprecated anyway.
    while ( 0 != EnumDisplaySettings( NULL, dwModeNum, &devmode ) )
	{
		// Look for a hit.

		BOOL t_Status = devmode.dmBitsPerPel == dwBitsPerPixel &&
						devmode.dmPelsWidth == dwHorizontalResolution &&
						devmode.dmPelsHeight == dwVerticalResolution &&
						devmode.dmDisplayFrequency == dwRefreshRate ;

		if ( t_Status )
		{
			CHString strTemp ;

			CHString strVideoMode ;

			// Start with the resolution

			strVideoMode.Format (

				L"%u by %u pixels",
				devmode.dmPelsWidth,
				devmode.dmPelsHeight
			);

			if ( 32 == devmode.dmBitsPerPel )
			{
				strVideoMode += _T(", True Color") ;
			}
			else
			{
				// It's a power of two, so...

				DWORD dwNumColors = 1 << devmode.dmBitsPerPel ;

				strTemp.Format (

					L", %u Colors" ,
					dwNumColors
				) ;

				strVideoMode += strTemp ;
			}

			// Add in the vertical refresh rate, 0 and/or 1 are indicative of a default rate
			// specific to the device (set by jumpers or a propietary app).

			if ( 0 != devmode.dmDisplayFrequency &&	1 != devmode.dmDisplayFrequency )
			{
				strTemp.Format (

					L", %u Hertz",
					devmode.dmDisplayFrequency
				) ;

				strVideoMode += strTemp ;

				// If we're less than 50, it's interlaced.  This was straight out
				// of the NT Display Settings code, so I'm taking it on "faith".
				if ( 50 > devmode.dmDisplayFrequency )
				{
					strVideoMode += L", Interlaced";
				}
			}
#ifdef NTONLY
            else
			{
				// On Windows NT, if the refresh rate is zero or 1, a default rate is specified.  This
				// rate is either set on the hardware using jumpers or using a separate manufacturer
				// supplied configuration app.

				strVideoMode += _T(", Default Refresh Rate");
			}
#endif

			// Store the video mode and get out
			pInstance->SetCHString ( IDS_VideoMode, strVideoMode ) ;
			fFoundMode = TRUE ;

			break ;

		}	// IF mode matches

		dwModeNum ++ ;

		// To be safe clear out and reset DevMode due to the
		// sensitivity of NT 3.51

		memset ( & devmode , NULL , sizeof ( DEVMODE ) ) ;
		devmode.dmSize = sizeof ( DEVMODE ) ;

	}

	// If we didn't find a matching mode, then assume the adapter is configured incorrectly

	if ( !fFoundMode )
	{
		pInstance->SetCHString ( IDS_VideoMode, IDS_AdapterConfiguredIncorrect );
	}

}

/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY

void CWin32DisplayControllerConfig :: GetNameNT (

	CHString &strName
)
{
	// Store a default name in case something goes wrong
	strName = DSPCTLCFG_DEFAULT_NAME;

	// First get the key name that we will need to go to in order to get
	// the Adapter name.

	CRegistry reg ;

	CHString strAdapterNameKey ;

	DWORD dwRet = reg.Open (

		HKEY_LOCAL_MACHINE,
		WINNT_DSPCTLCFG_DISPLAYADAPTERNAME_KEY,
		KEY_READ
	) ;

	if ( ERROR_SUCCESS == dwRet )
	{
		reg.GetCurrentKeyValue ( WINNT_DSPCTLCFG_VIDEOADAPTERKEY_VALUE , strAdapterNameKey ) ;

		reg.Close () ;
	}

	// The string will not be empty if we got a value.


	if ( ! strAdapterNameKey.IsEmpty () )
	{
		// Look for the System name, which is the beginning of the subkey under HKEY_LOCAL_MACHINE
		// where we will be looking.

		INT	nIndex = strAdapterNameKey.Find ( _T("System") ) ;
		if ( -1 != nIndex )
		{
			// We found our index, so extract our key name, then open the key.  If that succeeds, then
			// there should be a binary value called "HardwareInformation.AdapterString" we can retrieve.
			// This binary value is actually a WSTR value which we can then copy into the Name field.

			strAdapterNameKey = strAdapterNameKey.Right ( strAdapterNameKey.GetLength() - nIndex ) ;

			dwRet = reg.Open (

				HKEY_LOCAL_MACHINE ,
				strAdapterNameKey ,
				KEY_READ
			) ;

			if ( ERROR_SUCCESS == dwRet )
			{
				BYTE *pbValue = NULL ;
				DWORD dwValueSize = 0 ;

				// Find out how big the string is, then allocate a buffer for it.

				dwRet = reg.GetCurrentBinaryKeyValue (

					WINNT_DSPCTLCFG_ADAPTERSTRING_VALUE_NAME,
					pbValue,
					&dwValueSize
				) ;

				if ( ERROR_SUCCESS == dwRet )
				{
					pbValue = new BYTE [ dwValueSize ] ;
					if ( NULL != pbValue )
					{
						try
						{
							dwRet = reg.GetCurrentBinaryKeyValue (

								WINNT_DSPCTLCFG_ADAPTERSTRING_VALUE_NAME,
								pbValue,
								&dwValueSize
							) ;

							if ( ERROR_SUCCESS == dwRet )
							{
								// Reset the name since we found a value

								strName = (LPWSTR) pbValue ;

                                // Get rid of CR+LF (thanks to the Stealth II G460).
                                // Otherwise, CIMOM will throw away the key.
                                strName = strName.SpanExcluding(L"\t\r\n");
							}

						}
						catch ( ... )
						{
							delete [] pbValue ;

							throw ;
						}

						delete [] pbValue ;
					}
					else
					{
						throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
					}
				}

				reg.Close ();

			}
		}
	}

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\driverfordevice.h ===
/******************************************************************



   DriverForDevice.H -- WMI provider class definition



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

*******************************************************************/

#ifndef _CDRIVERFORDEVICE_H_
#define _CDRIVERFORDEVICE_H_

#define PROVIDER_NAME_DRIVERFORDEVICE L"Win32_DriverForDevice"
#define PROVIDER_NAME_PRINTER		  L"Win32_Printer"
#define PROVIDER_NAME_PRINTERDRIVER   L"Win32_PrinterDriver"

#define ANTECEDENT					  L"Antecedent"
#define DEPENDENT					  L"Dependent"
#define DRIVERNAME					  L"Name"
#define DEVICEID				      L"DeviceID"


class CDriverForDevice : public Provider 
{
public:
    CDriverForDevice ( LPCWSTR lpwszClassName,  LPCWSTR lpwszNameSpace ) ;
    virtual ~CDriverForDevice () ;

public:

    HRESULT EnumerateInstances ( MethodContext *pMethodContext, long lFlags = 0L ) ;
    HRESULT GetObject ( CInstance *pInstance, long lFlags, CFrameworkQuery &Query ) ;
	HRESULT ExecQuery ( MethodContext *pMethodContext, CFrameworkQuery &Query, long lFlags );

private:

 	HRESULT EnumerateAllDriversForDevice ( MethodContext *pMethodContext );
	void MakeObjectPath ( LPWSTR &a_ObjPathString, LPWSTR a_ClassName, DRIVER_INFO_2 *pDriverBuff );
	HRESULT SetError();
	HRESULT ConvertDriverKeyToValues ( IN CHString  Key, IN OUT CHString &DriverName, IN OUT DWORD &dwVersion, IN OUT CHString &Environment, IN WCHAR cDelimiter = L',' );
	HRESULT GetDriversFromQuery ( CHStringArray &t_DriverObjPath, CHStringArray &t_DriverNameArray, CHStringArray &t_EnvironmentArray, DWORD **pdwVersion );
	HRESULT GetPrintersFromQuery ( CHStringArray &t_PrintersObjPath, CHStringArray &t_Printers );
	HRESULT CommitInstance ( CHString &a_Driver, CHString &a_Printer, MethodContext *pMethodContext );

#if NTONLY >= 5
	HRESULT AssociateDriverToDevice (CHString &a_PrinterName, MethodContext *pMethodContext);
#endif

private:

} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\driverfordevice.cpp ===
/******************************************************************

   CriverForDevice.CPP -- WMI provider class implementation



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
  
   Description:  Association Class between Printer and Printer Driver
   
******************************************************************/
#include "precomp.h"
#include <lockwrap.h>
#include <DllWrapperBase.h>
#include <WinSpool.h>
#include <ObjPath.h>
#include "prnutil.h"

#include "driverForDevice.h"

#define DELIMITER           L","

CDriverForDevice MyCDriverForDevice ( 

    PROVIDER_NAME_DRIVERFORDEVICE , 
    IDS_CimWin32Namespace
) ;

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsJnPtReplica::CDfsJnPtReplica
 *
 *  DESCRIPTION :   Constructor
 *
 *****************************************************************************/

CDriverForDevice :: CDriverForDevice (

    LPCWSTR lpwszName, 
    LPCWSTR lpwszNameSpace

) : Provider ( lpwszName , lpwszNameSpace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDriverForDevice::~CDriverForDevice
 *
 *  DESCRIPTION :   Destructor
 *
 *****************************************************************************/

CDriverForDevice :: ~CDriverForDevice ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CDriverForDevice::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*****************************************************************************/

HRESULT CDriverForDevice :: EnumerateInstances (

    MethodContext *pMethodContext, 
    long lFlags
)
{
    HRESULT hRes = WBEM_S_NO_ERROR ;

#if NTONLY >= 5
    hRes = EnumerateAllDriversForDevice ( pMethodContext );

    return ((hRes == WBEM_E_NOT_FOUND) ? WBEM_S_NO_ERROR : hRes);
#else
    return WBEM_E_NOT_SUPPORTED;
#endif

}


/*****************************************************************************
*
*  FUNCTION    :    CDriverForDevice::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*****************************************************************************/

HRESULT CDriverForDevice :: GetObject (

    CInstance *pInstance, 
    long lFlags ,
    CFrameworkQuery &Query
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
#if NTONLY >= 5
    CHString t_Key1;
    CHString t_Key2;

    if ( pInstance->GetCHString (  ANTECEDENT, t_Key1 ) )
    {
        if ( pInstance->GetCHString ( DEPENDENT, t_Key2 ) )
        {
            // here unparse Key2 and key1 the LinkName should be the same as that of t_key1 value entrypath
            CObjectPathParser t_ObjPathParser;
            ParsedObjectPath *t_Key1ObjPath;
            ParsedObjectPath *t_Key2ObjPath;

            // Parse the keys so that the values can be compared
            if ( t_ObjPathParser.Parse ( t_Key1, &t_Key1ObjPath ) == t_ObjPathParser.NoError  )
            {
                if ( t_Key1ObjPath != NULL )
                {
                    try
                    {
                        if ( t_ObjPathParser.Parse ( t_Key2, &t_Key2ObjPath ) == t_ObjPathParser.NoError ) 
                        {
                            if ( t_Key2ObjPath != NULL ) 
                            {
                                // Use of delay loaded functions requires exception handler.
                                SetStructuredExceptionHandler seh;
                                try
                                {
                                    CHString t_DriverName;
                                    CHString t_Environment;
                                    DWORD dwVersion;
                                    CHString t_DriverKey;
                            
                                    if ( (t_Key2ObjPath->m_dwNumKeys == 1) &&
                                         ((t_Key2ObjPath->m_paKeys[0]->m_pName == NULL) ||
                                          (_wcsicmp ( t_Key2ObjPath->m_paKeys[0]->m_pName, DRIVERNAME ) == 0)) && 
                                         (V_VT(&t_Key2ObjPath->m_paKeys[0]->m_vValue) == VT_BSTR) )
                                    {
                                        t_DriverKey = t_Key2ObjPath->m_paKeys[0]->m_vValue.bstrVal;                             
                                        hRes = ConvertDriverKeyToValues ( t_DriverKey, t_DriverName, dwVersion, t_Environment );
                                    }
                                    else
                                    {
                                        hRes = WBEM_E_INVALID_PARAMETER;
                                    }
                        
                                    if ( SUCCEEDED ( hRes ) )
                                    {
                                        CHString t_PrinterName;

                                        if ( (t_Key1ObjPath->m_dwNumKeys == 1) &&
                                             ((t_Key1ObjPath->m_paKeys[0]->m_pName == NULL) ||
                                              (_wcsicmp ( t_Key1ObjPath->m_paKeys[0]->m_pName, DEVICEID ) == 0)) &&
                                             ( V_VT(&t_Key1ObjPath->m_paKeys[0]->m_vValue) == VT_BSTR ) )
                                        {
                                            t_PrinterName = t_Key1ObjPath->m_paKeys[0]->m_vValue.bstrVal;                       
                                            // now check if for a given Printer Driver Exists
                                            BOOL bSuccess = FALSE;
                                            SmartClosePrinter hPrinter; 
                                            DWORD dwError;
                                            DWORD dwBytesNeeded;

                                            bSuccess = ::OpenPrinter ( TOBSTRT ( t_PrinterName.GetBuffer ( 0 ) ), (LPHANDLE) & hPrinter, NULL ) ;

                                            if ( bSuccess ) 
                                            {
                                                    // Using this handle get the driver 
                                                BYTE *pDriverInfo = NULL;
                                                bSuccess = ::GetPrinterDriver( 
                                                                hPrinter, 
                                                                TOBSTRT ( t_Environment.GetBuffer ( 0 ) ), 
                                                                2, 
                                                                pDriverInfo, 
                                                                0, 
                                                                &dwBytesNeeded
                                                            );
                                                if ( !bSuccess )
                                                {
                                                    dwError = GetLastError();
                                                    if ( dwError != ERROR_INSUFFICIENT_BUFFER )
                                                    {
                                                        hRes = SetError ();
                                                    }
                                                    else
                                                    {
                                                        // Here allocate memory and get the Driver again.
                                                        pDriverInfo = new BYTE [ dwBytesNeeded ];

                                                        if ( pDriverInfo )
                                                        {
                                                            try
                                                            {
                                                                bSuccess = ::GetPrinterDriver( 
                                                                                hPrinter, 
                                                                                TOBSTRT ( t_Environment.GetBuffer ( 0 ) ), 
                                                                                2, 
                                                                                pDriverInfo, 
                                                                                dwBytesNeeded, 
                                                                                &dwBytesNeeded  
                                                                            );

                                                                if ( bSuccess )
                                                                {
                                                                    DRIVER_INFO_2 *pDriverBuf =  ( DRIVER_INFO_2 *)pDriverInfo;

                                                                    if ((pDriverBuf->pName == NULL) ||
                                                                        (pDriverBuf->pEnvironment == NULL) ||
                                                                        ( pDriverBuf->cVersion != dwVersion ) ||
                                                                        (t_DriverName.CompareNoCase(pDriverBuf->pName) != 0) ||
                                                                        (t_Environment.CompareNoCase(pDriverBuf->pEnvironment) != 0))
                                                                    {
                                                                        hRes = WBEM_E_NOT_FOUND;
                                                                    }
                                                                }
                                                            }
                                                            catch(Structured_Exception se)
                                                            {
                                                                DelayLoadDllExceptionFilter(se.GetExtendedInfo());
                                                                delete [] pDriverInfo;
                                                                pDriverInfo = NULL;
                                                                hRes = WBEM_E_FAILED;
                                                            }
                                                            catch ( ... )
                                                            {
                                                                delete [] pDriverInfo;
                                                                pDriverInfo = NULL;
                                                                throw;
                                                            }
                                                            delete [] pDriverInfo;
                                                            pDriverInfo = NULL;
                                                        }
                                                        else
                                                        {
                                                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                                                        }
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                hRes = SetError ( );
                                            }
                                        }
                                        else
                                        {
                                            hRes = WBEM_E_INVALID_PARAMETER;
                                        }
                                    }
                                }
                                catch(Structured_Exception se)
                                {
                                    DelayLoadDllExceptionFilter(se.GetExtendedInfo());
                                    t_ObjPathParser.Free ( t_Key2ObjPath );
                                    hRes = WBEM_E_FAILED;
                                }
                                catch ( ... )
                                {
                                    t_ObjPathParser.Free ( t_Key2ObjPath );
                                    throw;
                                }
                                t_ObjPathParser.Free ( t_Key2ObjPath );
                            }
                        }
                        else
                        {
                            hRes = WBEM_E_INVALID_PARAMETER;
                        }
                    }
                    catch ( ... )
                    {
                        t_ObjPathParser.Free ( t_Key1ObjPath );
                        throw;
                    }
                    t_ObjPathParser.Free ( t_Key1ObjPath );
                }

            }           
        }
        else
        {
            hRes = WBEM_E_PROVIDER_FAILURE;
        }
    }
    else
    {
        hRes = WBEM_E_PROVIDER_FAILURE;
    }

    return hRes ;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    :    CDriverForDevice::ExecQuery
*
*  DESCRIPTION :    Optimization of the query based on only key value.
*
*****************************************************************************/
HRESULT CDriverForDevice :: ExecQuery ( 

    MethodContext *pMethodContext, 
    CFrameworkQuery &Query, 
    long lFlags
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
#if NTONLY >= 5
    CHStringArray t_PrinterObjPath;
    CHStringArray t_DriverObjPath;

    CHStringArray t_EnvironmentArray;
    CHStringArray t_DriverNameArray; 
    CHStringArray t_Printers;
    DWORD *pdwVersion = NULL;


    // Both the properties being key cannot be null.
    hRes = Query.GetValuesForProp( ANTECEDENT, t_PrinterObjPath );
    if ( SUCCEEDED ( hRes ) )
    {
        hRes = Query.GetValuesForProp( DEPENDENT, t_DriverObjPath );
    }

    if ( SUCCEEDED ( hRes ) )
    {
        if ( t_PrinterObjPath.GetSize () > 0 ) 
        {
            //  Get all the printers, in the t_PrinterObjPath arra
            hRes = GetPrintersFromQuery ( t_PrinterObjPath, t_Printers );
        }
    }

    if ( SUCCEEDED ( hRes ) )
    {
        if ( t_DriverObjPath.GetSize () > 0 )
        {
            hRes = GetDriversFromQuery ( t_DriverObjPath, t_DriverNameArray, t_EnvironmentArray, &pdwVersion );
        }
    }

    if ( SUCCEEDED ( hRes ) )
    {
        if ( ( t_PrinterObjPath.GetSize () > 0 ) && ( t_DriverObjPath.GetSize () > 0 ) )
        {
            if ( pdwVersion != NULL )
            {
                // Use of delay loaded functions requires exception handler.
                SetStructuredExceptionHandler seh;
                try
                {
                    // For each Printer We need to get driver and if the driver exists in the above specified query
                    // we need to commit that instance.
                    for ( DWORD dwPrinter = 0; dwPrinter < t_Printers.GetSize (); dwPrinter++ )
                    {
                        SmartClosePrinter  hPrinter;

                        BOOL bSuccess = ::OpenPrinter (

                                            TOBSTRT ( t_Printers.GetAt ( dwPrinter ).GetBuffer ( 0 ) ),
                                            & hPrinter,
                                            NULL
                                        ) ;
                        if ( bSuccess )
                        {
                            DRIVER_INFO_2 *pDriverInfo = NULL;
                            DWORD bytesNeeded;
                            bSuccess = ::GetPrinterDriver(
                                                hPrinter,     // printer object
                                                NULL,       // environment name
                                                2,         // information level
                                                ( LPBYTE )pDriverInfo,  // driver data buffer
                                                0,         // size of buffer
                                                &bytesNeeded    // bytes received or required
                                            );
                            if ( !bSuccess )
                            {
                                DWORD dwError = GetLastError();
    
                                if( dwError == ERROR_INSUFFICIENT_BUFFER )
                                {
                                    pDriverInfo = ( DRIVER_INFO_2 * ) new BYTE [ bytesNeeded ];

                                    if ( pDriverInfo != NULL )
                                    {
                                        try
                                        {
                                            bSuccess = ::GetPrinterDriver(
                                                                hPrinter,     
                                                                NULL,       
                                                                2,         
                                                                ( LPBYTE )pDriverInfo,  
                                                                bytesNeeded,         
                                                                &bytesNeeded
                                                        );
                                            if ( bSuccess )
                                            {
                                                // Search and commit
                                                for ( DWORD dwDrivers = 0; dwDrivers < t_DriverNameArray.GetSize(); dwDrivers++ )
                                                {
                                                    if ( ( t_DriverNameArray.GetAt ( dwDrivers ).CompareNoCase ( TOBSTRT ( pDriverInfo->pName ) ) == 0 ) &&
                                                         ( t_EnvironmentArray.GetAt ( dwDrivers ).CompareNoCase ( TOBSTRT ( pDriverInfo->pEnvironment) ) == 0 ) &&
                                                         ( pdwVersion [ dwDrivers ] == pDriverInfo->cVersion ) )
                                                    {
                                                        // Commit the Instance
                                                        CHString t_DriverKey;
                                                        t_DriverKey.Format ( L"%s%s%d%s%s", 
                                                                             t_DriverNameArray.GetAt ( dwDrivers ),
                                                                             DELIMITER,
                                                                             pdwVersion [ dwDrivers ],
                                                                             DELIMITER,
                                                                             t_EnvironmentArray.GetAt ( dwDrivers )
                                                                     );
                                                        hRes = CommitInstance ( t_DriverKey, t_Printers.GetAt ( dwPrinter ), pMethodContext );
                                                    }
                                                }
                                            }
                                        }
                                        catch(Structured_Exception se)
                                        {
                                            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
                                            delete [] pDriverInfo;
                                            pDriverInfo = NULL;
                                            hRes = WBEM_E_FAILED;
                                        }
                                        catch ( ... )
                                        {
                                            delete [] pDriverInfo;
                                            pDriverInfo = NULL;
                                            throw;
                                        }

                                        delete [] pDriverInfo;
                                        pDriverInfo = NULL;
                                    }
                                    else
                                    {
                                        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                                    }
                                }
                            }
                        }
                    }
                }
                catch(Structured_Exception se)
                {
                    DelayLoadDllExceptionFilter(se.GetExtendedInfo());
                    delete [] pdwVersion;
                    pdwVersion = NULL;
                    hRes = WBEM_E_FAILED;
                }
                catch ( ... )
                {
                    delete [] pdwVersion;
                    pdwVersion = NULL;
                    throw;
                }
                delete [] pdwVersion;
                pdwVersion = NULL;
            }
        }
        else
        if ( t_PrinterObjPath.GetSize () > 0 )
        {
            // Use of delay loaded functions requires exception handler.
            for ( DWORD dwPrinter = 0; dwPrinter < t_Printers.GetSize (); dwPrinter++ )
            {
                AssociateDriverToDevice (t_Printers[dwPrinter], pMethodContext);
            }
        }
        else
        {
            hRes = WBEM_E_PROVIDER_NOT_CAPABLE;
        }
    }

    return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

#if NTONLY >= 5
HRESULT CDriverForDevice::AssociateDriverToDevice (CHString &a_PrinterName, MethodContext *pMethodContext)
{
    if (a_PrinterName.GetLength() == 0)
    {
        return WBEM_E_FAILED;
    }

    HRESULT hRes = WBEM_S_NO_ERROR;
    SetStructuredExceptionHandler seh;
    SmartClosePrinter hPrinter;

    try
    {
        BOOL bSuccess = ::OpenPrinter (

                            TOBSTRT ( a_PrinterName.GetBuffer ( 0 ) ),
                            & hPrinter,
                            NULL
                        ) ;
        if ( bSuccess )
        {
            DRIVER_INFO_2 *pDriverInfo = NULL;
            DWORD bytesNeeded;
            bSuccess = ::GetPrinterDriver(
                                hPrinter,     // printer object
                                NULL,       // environment name
                                2,         // information level
                                ( LPBYTE )pDriverInfo,  // driver data buffer
                                0,         // size of buffer
                                &bytesNeeded    // bytes received or required
                            );
            if ( !bSuccess )
            {
                DWORD dwError = GetLastError();

                if( dwError == ERROR_INSUFFICIENT_BUFFER )
                {
                    pDriverInfo = ( DRIVER_INFO_2 * ) new BYTE [ bytesNeeded ];

                    if ( pDriverInfo != NULL )
                    {
                        try
                        {
                            bSuccess = ::GetPrinterDriver(
                                                hPrinter,     
                                                NULL,       
                                                2,         
                                                ( LPBYTE )pDriverInfo,  
                                                bytesNeeded,         
                                                &bytesNeeded
                                        );
                            if ( bSuccess )
                            {
                                // Commit the Instance
                                CHString t_DriverKey;
                                t_DriverKey.Format ( L"%s%s%d%s%s", 
                                                     pDriverInfo->pName,
                                                     DELIMITER,
                                                     pDriverInfo->cVersion,
                                                     DELIMITER,
                                                     pDriverInfo->pEnvironment
                                             );
                                CommitInstance ( t_DriverKey, a_PrinterName, pMethodContext );
                            }
                        }
                        catch(Structured_Exception se)
                        {
                            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
                            delete [] pDriverInfo;
                            pDriverInfo = NULL;
                            hRes = WBEM_E_FAILED;
                        }
                        catch ( ... )
                        {
                            delete [] pDriverInfo;
                            pDriverInfo = NULL;
                            throw;
                        }

                        delete [] pDriverInfo;
                        pDriverInfo = NULL;
                    }
                }
            }
        }
    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        hRes = WBEM_E_FAILED;
    }

    return hRes;
}
#endif


/*****************************************************************************
*
*  FUNCTION    :    CDriverForDevice::EnumerateAllDriversForDevice
*
*  DESCRIPTION :    Enumerates all the drivers for Device
*
*****************************************************************************/
HRESULT CDriverForDevice::EnumerateAllDriversForDevice ( 
                                                        
    MethodContext *pMethodContext 
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    DWORD   PrinterFlags = PRINTER_ENUM_LOCAL; 
    BOOL    bSuccess = FALSE;
    DWORD   dwNeeded = 0;
    DWORD   dwReturnedPrinters = 0;
    BOOL    bIsLocalCall;
    PRINTER_INFO_4 *pPrinterBuff = NULL;

    hRes = WinErrorToWBEMhResult(IsLocalCall(&bIsLocalCall));

    if (SUCCEEDED(hRes))
    {
        if (bIsLocalCall)
        {
            PrinterFlags |= PRINTER_ENUM_CONNECTIONS;
        }
    
        bSuccess = ::EnumPrinters(
                        PrinterFlags,
                        NULL,
                        4,
                        ( LPBYTE) pPrinterBuff,  
                        (DWORD ) 0L,
                        &dwNeeded,
                        &dwReturnedPrinters
                    );
    
        if ( ! bSuccess )
        {
            DWORD dwError = GetLastError();
    
            if ( dwError == ERROR_INSUFFICIENT_BUFFER )
            {
                BYTE *pPrinterInfo = new BYTE [ dwNeeded ];
    
                if ( pPrinterInfo != NULL )
                {
                    // Use of delay loaded functions requires exception handler.
                    SetStructuredExceptionHandler seh;
                    try
                    {
                        DWORD dwReturnedDrivers = 0;
    
                        bSuccess = ::EnumPrinters(
                                        PrinterFlags,
                                        NULL,
                                        4,
                                        ( LPBYTE) pPrinterInfo,  
                                        (DWORD ) dwNeeded,
                                        &dwNeeded,
                                        &dwReturnedPrinters
                                    );
    
                        if ( bSuccess )
                        {
                            pPrinterBuff = ( PRINTER_INFO_4 *) pPrinterInfo;
    
                            for ( DWORD dwPrinters = 0; dwPrinters < dwReturnedPrinters; dwPrinters++, pPrinterBuff++ )
                            {
                                HRESULT hr = AssociateDriverToDevice (CHString(pPrinterBuff->pPrinterName), pMethodContext);
    
                                if (FAILED(hr) && SUCCEEDED(hRes))
                                {
                                    hRes = hr;
                                }
                            }
                        }
                        else
                        {
                            hRes = SetError();
                        }
                    }
                    catch(Structured_Exception se)
                    {
                        DelayLoadDllExceptionFilter(se.GetExtendedInfo());
                        delete [] pPrinterInfo;
                        pPrinterInfo = NULL;
                        hRes = WBEM_E_FAILED;
                    }
                    catch ( ... )
                    {
                        delete [] pPrinterInfo;
                        pPrinterInfo = NULL;
                        throw;
                    }
                    delete [] pPrinterInfo;
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }
            else
            {
                hRes = SetError();
            }
        }
        else // SUCCESS and no printers expected
        {
            if ( dwReturnedPrinters )
            {
                hRes = SetError();
            }
        }
    }

    return hRes;
}


/*****************************************************************************
*
*  FUNCTION    :    CDriverForDevice::SetError
*
*  DESCRIPTION :    Sets and logs the appropriate error. Logs only if logging 
*                   is enabled
*
*****************************************************************************/

HRESULT CDriverForDevice::SetError ()
{
    HRESULT hRes = WBEM_S_NO_ERROR;
#if NTONLY >= 5
    DWORD dwError = GetLastError();
    if (dwError == ERROR_ACCESS_DENIED)
    {
        hRes = WBEM_E_ACCESS_DENIED;
    }
    else
    if ( ( ERROR_INVALID_PRINTER_NAME == dwError ) || ( ERROR_INVALID_ENVIRONMENT == dwError ) )
    {
        hRes = WBEM_E_NOT_FOUND;
    }
    else
    {
        hRes = WBEM_E_FAILED;

        if (IsErrorLoggingEnabled())
        {
            LogErrorMessage4(L"%s:Error %lxH (%ld)\n",PROVIDER_NAME_DRIVERFORDEVICE, dwError, dwError);
        }       
    }


    return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}


/*****************************************************************************
*
*  FUNCTION    :    CDriverForDevice::ConvertDriverKeyToValues
*
*  DESCRIPTION :    Converting composite driver keys into a individual values
*
*****************************************************************************/
HRESULT CDriverForDevice::
ConvertDriverKeyToValues(
    IN     CHString  Key,
    IN OUT CHString &DriverName,
    IN OUT DWORD    &dwVersion,
    IN OUT CHString &Environment,
    IN     WCHAR     cDelimiter
    )
{
    HRESULT hRes = WBEM_E_INVALID_PARAMETER;
#if NTONLY >= 5
    if (!Key.IsEmpty()) 
    {
        CHString t_Middle;

        int iFirst = Key.Find(cDelimiter);
        int iLast  = Key.ReverseFind(cDelimiter);
    
        if (iFirst>=1 && iLast>=1 && iLast!=iFirst) 
        {
            int iLength = Key.GetLength();

            DriverName  = Key.Left(iFirst);
            Environment = Key.Right(iLength - iLast - 1);
            t_Middle    = Key.Mid(iFirst + 1, iLast - iFirst - 1);

            if (1==swscanf(t_Middle, L"%u", &dwVersion)) 
            {
                hRes = WBEM_S_NO_ERROR;
            }            
        }
    }

    return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    :    CDriverForDevice::GetDriversFromQuery
*
*  DESCRIPTION :    Gets all the Drivers from the array ObjectPath Array of Drivers
*
*****************************************************************************/
HRESULT CDriverForDevice::GetDriversFromQuery ( 
                                                  
    CHStringArray &t_DriverObjPath, 
    CHStringArray &t_DriverNameArray, 
    CHStringArray &t_EnvironmentArray, 
    DWORD **pdwVersion )
{
    HRESULT hRes = WBEM_S_NO_ERROR;
#if NTONLY >= 5
    CObjectPathParser t_PathParser;
    ParsedObjectPath *t_ObjPath;

    *pdwVersion =  new DWORD [ t_DriverObjPath.GetSize() ];

    if ( *pdwVersion != NULL )
    {
        try
        {
            int iTotDrivers = 0;
            for ( int i = 0; i < t_DriverObjPath.GetSize(); i++ )
            {
            // Parse the DriverObject path
                CHString t_Driver = t_DriverObjPath.GetAt ( i );

                if ( ( t_PathParser.Parse( t_Driver, &t_ObjPath ) ==  t_PathParser.NoError ) &&
                    ( V_VT(&t_ObjPath->m_paKeys[0]->m_vValue) == VT_BSTR ) )
                {
                    if ( t_ObjPath != NULL )
                    {
                        try
                        {
                            if ( TRUE /* if DriverClass and if Key name is DRIVERNAME */)
                            {
                                CHString t_Environment;
                                CHString t_DriverName; 
                                DWORD dwVersion;
                                // check for the key name 
                                hRes = ConvertDriverKeyToValues( t_ObjPath->m_paKeys[0]->m_vValue.bstrVal, t_DriverName, dwVersion, t_Environment );
                                if ( SUCCEEDED ( hRes ) )
                                {
                                    t_EnvironmentArray.Add ( t_Environment.GetBuffer ( 0 ) );
                                    t_DriverNameArray.Add ( t_DriverName.GetBuffer ( 0 ) );
                                    *pdwVersion [ iTotDrivers ] = dwVersion;
                                    iTotDrivers++;
                                }
                            }
                        }
                        catch ( ... )
                        {
                            t_PathParser.Free (t_ObjPath);
                            t_ObjPath = NULL;
                            throw;
                        }
                        t_PathParser.Free (t_ObjPath);
                        t_ObjPath = NULL;
                    }
                }           
            }
        }
        catch ( ... )
        {
            delete [] *pdwVersion;
            *pdwVersion = NULL;
            throw;
        }
    }
    else
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    :    CDriverForDevice::GetPrintersFromQuery
*
*  DESCRIPTION :    Gets all the Printers from the array ObjectPath Array of Printers
*
*****************************************************************************/
HRESULT CDriverForDevice::GetPrintersFromQuery ( 
                                                  
    CHStringArray &t_PrinterObjPath, 
    CHStringArray &t_Printers
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
#if NTONLY >=5 
    CObjectPathParser t_PathParser;
    ParsedObjectPath *t_ObjPath;

    int iTotPrinters = 0;

    for ( int i = 0; i < t_PrinterObjPath.GetSize(); i++ )
    {
        // Parse the DriverObject path
        CHString t_Printer = t_PrinterObjPath.GetAt ( i );

        if ( ( t_PathParser.Parse( t_Printer, &t_ObjPath ) ==  t_PathParser.NoError ) &&
            ( V_VT(&t_ObjPath->m_paKeys[0]->m_vValue) == VT_BSTR ) )
        {
            if ( t_ObjPath != NULL )
            {
                try
                {
                    if ( TRUE // First Verify that the class is Printer Class and the Key Value is DeviceId
                    /*only then  add the values*/ )
                    {
                        t_Printers.Add (  t_ObjPath->m_paKeys[0]->m_vValue.bstrVal );
                    }
                }
                catch ( ... )
                {
                    t_PathParser.Free (t_ObjPath);
                    throw;
                }
                t_PathParser.Free (t_ObjPath);
                t_ObjPath = NULL;
            }
        }
    }

    return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    :    CDriverForDevice::CommitInstance
*
*  DESCRIPTION :    Forming an Object Path and then Creating and Commiting an instance
*
*****************************************************************************/
HRESULT CDriverForDevice::CommitInstance ( 
                                          
    CHString &a_Driver, 
    CHString &a_Printer, 
    MethodContext *pMethodContext 
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
#if NTONLY >= 5
    ParsedObjectPath t_PrinterObjPath;
    LPWSTR lpPrinterPath = NULL;
    variant_t t_PathPrinter = a_Printer.GetBuffer ( 0 );

    t_PrinterObjPath.SetClassName ( PROVIDER_NAME_PRINTER );
    t_PrinterObjPath.AddKeyRef ( DEVICEID, &t_PathPrinter );

    CObjectPathParser t_PathParser;

    if ( t_PathParser.Unparse( &t_PrinterObjPath, &lpPrinterPath  ) != t_PathParser.NoError )
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    if ( lpPrinterPath != NULL )
    {
        try
        {
            ParsedObjectPath t_DriverObjPath;
            variant_t t_PathDriver = a_Driver.GetBuffer ( 0 );
            LPWSTR lpDriverPath = NULL;

            t_DriverObjPath.SetClassName ( PROVIDER_NAME_PRINTERDRIVER );
            t_DriverObjPath.AddKeyRef ( DRIVERNAME, &t_PathDriver );

            if ( t_PathParser.Unparse( &t_DriverObjPath, &lpDriverPath  ) != t_PathParser.NoError )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

            if ( lpDriverPath != NULL )
            {
                try 
                {
                    // Now Create Instance and commit;
                    CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ) , false ) ;
                    pInstance->SetCHString ( ANTECEDENT, lpPrinterPath );
                    pInstance->SetCHString ( DEPENDENT, lpDriverPath );
                    hRes = pInstance->Commit();
                }
                catch ( ... )
                {
                    delete [] lpDriverPath;
                    lpDriverPath = NULL;
                    throw;
                }
                delete [] lpDriverPath;
                lpDriverPath = NULL;
            }
        }
        catch ( ... )
        {
            delete [] lpPrinterPath;
            lpPrinterPath = NULL;
            throw;
        }
        delete [] lpPrinterPath;
        lpPrinterPath = NULL;
    }

    return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\elementsetting.cpp ===
//=================================================================

//

// ElementSetting.cpp

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <assertbreak.h>

#include "ElementSetting.h"

//========================

CWin32AssocElementToSettings::CWin32AssocElementToSettings(
const CHString&	strName,
const CHString& strElementClassName,
const CHString&	strElementBindingPropertyName,
const CHString& strSettingClassName,
const CHString& strSettingBindingPropertyName,
LPCWSTR			pszNamespace )
:	Provider( strName, pszNamespace ),
	m_strElementClassName( strElementClassName ),
	m_strElementBindingPropertyName( strElementBindingPropertyName ),
	m_strSettingClassName( strSettingClassName  ),
	m_strSettingBindingPropertyName( strSettingBindingPropertyName )
{

	// Binding Property Name and Setting Property Name MUST either
	// both be empty or both have values

	ASSERT_BREAK(	( strElementBindingPropertyName.IsEmpty() && strSettingBindingPropertyName.IsEmpty() )
				||	( !strElementBindingPropertyName.IsEmpty() && !strSettingBindingPropertyName.IsEmpty() ) );
}

CWin32AssocElementToSettings::~CWin32AssocElementToSettings()
{
}

HRESULT CWin32AssocElementToSettings::EnumerateInstances( MethodContext*  pMethodContext, long lFlags /*= 0L*/ )
{
	HRESULT		hr	=	WBEM_S_NO_ERROR;

    // Perform queries
    //================

	TRefPointerCollection<CInstance>	elementList;
	TRefPointerCollection<CInstance>	settingsList;

	REFPTRCOLLECTION_POSITION	pos;

   CHString sQuery1, sQuery2;

   if (m_strElementBindingPropertyName.IsEmpty()) {
      sQuery1.Format(L"SELECT __RELPATH FROM %s", m_strElementClassName);
   } else {
      sQuery1.Format(L"SELECT __RELPATH, %s FROM %s", m_strElementBindingPropertyName, m_strElementClassName);
   }

   if (m_strSettingBindingPropertyName.IsEmpty()) {
      sQuery2.Format(L"SELECT __RELPATH FROM %s", m_strSettingClassName);
   } else {
      sQuery2.Format(L"SELECT __RELPATH, %s FROM %s", m_strSettingBindingPropertyName, m_strSettingClassName);
   }

	// grab all of both items that could be endpoints
//	if (SUCCEEDED(CWbemProviderGlue::GetAllInstances( m_strElementClassName, &elementList, IDS_CimWin32Namespace, pMethodContext ))
//		&&
//		SUCCEEDED(CWbemProviderGlue::GetAllInstances( m_strSettingClassName, &settingsList, IDS_CimWin32Namespace, pMethodContext )) )
   if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(sQuery1, &elementList, pMethodContext, IDS_CimWin32Namespace))
      &&
      SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(sQuery2, &settingsList, pMethodContext, IDS_CimWin32Namespace)))

	{
		if ( elementList.BeginEnum( pos ) )
		{

			// For each element, check the settings list for associations
        	CInstancePtr pElement;

			for (pElement.Attach(elementList.GetNext( pos )) ;
                 SUCCEEDED(hr) && ( pElement != NULL );
                 pElement.Attach(elementList.GetNext( pos )) )
			{

				hr = EnumSettingsForElement( pElement, settingsList, pMethodContext );

			}	// IF GetNext Computer System

			elementList.EndEnum();

		}	// IF BeginEnum

	}	// IF GetInstancesByQuery

	return hr;

}

HRESULT CWin32AssocElementToSettings::EnumSettingsForElement(
CInstance*							pElement,
TRefPointerCollection<CInstance>&	settingsList,
MethodContext*						pMethodContext )
{

	HRESULT		hr	=	WBEM_S_NO_ERROR;

	REFPTRCOLLECTION_POSITION	pos;

	CHString	strElementPath,
				strSettingPath;

	// Pull out the object path of the element as the various
	// settings object paths will be associated to this value

	if ( GetLocalInstancePath( pElement, strElementPath ) )
	{

		if ( settingsList.BeginEnum( pos ) )
		{

        	CInstancePtr pInstance;
        	CInstancePtr pSetting;

			for (pSetting.Attach(settingsList.GetNext( pos ) );
                 SUCCEEDED(hr) && ( pSetting != NULL );
                 pSetting.Attach(settingsList.GetNext( pos ) ))
			{
				// Check if we have an association

				if ( AreAssociated( pElement, pSetting ) )
				{
					// Get the path to the setting object and create us an association.

					if ( GetLocalInstancePath( pSetting, strSettingPath ) )
					{

						pInstance.Attach(CreateNewInstance( pMethodContext ));
						if ( NULL != pInstance )
						{
							pInstance->SetCHString( IDS_Element, strElementPath );
							pInstance->SetCHString( IDS_Setting, strSettingPath );

							// Invalidates pointer
							hr = pInstance->Commit(  );
						}
						else
						{
							hr = WBEM_E_OUT_OF_MEMORY;
						}

					}	// IF GetPath to Setting Object

				}	// IF AreAssociated

			}	// WHILE GetNext

			settingsList.EndEnum();

		}	// IF BeginEnum

	}	// IF GetLocalInstancePath

	return hr;

}

HRESULT CWin32AssocElementToSettings::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
	HRESULT		hr;

	CInstancePtr pElement;
	CInstancePtr pSetting;

	CHString	strElementPath,
				strSettingPath;

	pInstance->GetCHString( IDS_Element, strElementPath );
	pInstance->GetCHString( IDS_Setting, strSettingPath );

	// If we can get both objects, test for an association

	if (	SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath( strElementPath, &pElement, pInstance->GetMethodContext() ))
		&&	SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath( strSettingPath, &pSetting, pInstance->GetMethodContext() )) )
	{
        if (AreAssociated( pElement, pSetting ))
        {
            hr = WBEM_S_NO_ERROR;
        }
        else
        {
            hr = WBEM_E_NOT_FOUND;
        }
	}

	return ( hr );
}

BOOL CWin32AssocElementToSettings::AreAssociated( CInstance* pElement, CInstance* pSetting )
{
	BOOL	fReturn = FALSE;

	// If we've got Binding property names, the properties MUST be checked, otherwise,
	// the objects are assumed to be associated

	if ( !m_strElementBindingPropertyName.IsEmpty() && !m_strSettingBindingPropertyName.IsEmpty() )
	{
		variant_t vElementValue, vSettingValue;

		// Get the property values and if they are equal, we have an association

		if (	pElement->GetVariant( m_strElementBindingPropertyName, vElementValue )
			&&	pSetting->GetVariant( m_strSettingBindingPropertyName, vSettingValue ) )
		{

			fReturn = CompareVariantsNoCase(&vElementValue, &vSettingValue);

		}

	}
	else
	{
		fReturn = TRUE;
	}

	return fReturn;
}

// Static Classes
CWin32AssocUserToDesktop::CWin32AssocUserToDesktop(void) : CWin32AssocElementToSettings(L"Win32_UserDesktop",
																						L"Win32_UserAccount",
																						L"Domain, Name",
																						L"Win32_Desktop",
																						L"Name",
																						IDS_CimWin32Namespace)
{
}

// only difference betweeen this and the base class
// is that it will use .DEFAULT
HRESULT CWin32AssocUserToDesktop::EnumSettingsForElement(
CInstance*							pElement,
TRefPointerCollection<CInstance>&	settingsList,
MethodContext*						pMethodContext )
{

	HRESULT		hr	=	WBEM_S_NO_ERROR;

    REFPTRCOLLECTION_POSITION	pos;

	CInstancePtr pSetting;
	CInstancePtr pInstance;

	CHString	strElementPath,
				strSettingPath,
				strDefaultPath;


	{
		// find de faulty setting
		CHString desktopName;
		if (settingsList.BeginEnum( pos ))
		{
	        CInstancePtr pSetting;
	        CInstancePtr pInstance;

			for (pSetting.Attach(settingsList.GetNext( pos ));
                 strDefaultPath.IsEmpty() && ( pSetting != NULL );
                 pSetting.Attach(settingsList.GetNext( pos )))
			{
				pSetting->GetCHString(IDS_Name,  desktopName);
				// check to see if the last few letters are ".Default"
				// there MAY be a way to fool this check, but it'd be rather obscure;
				//if (desktopName.Find(".DEFAULT") == (desktopName.GetLength() - 8))
				if (!desktopName.CompareNoCase(L".DEFAULT"))
                {
					GetLocalInstancePath( pSetting, strDefaultPath );
                }
			}
			settingsList.EndEnum();
		}
	}

	// Pull out the object path of the element as the various
	// settings object paths will be associated to this value
	bool bGotOne = false; // did we find one that was NOT .default?

	if ( GetLocalInstancePath( pElement, strElementPath ) )
	{
		if ( settingsList.BeginEnum( pos ) )
		{
			for( pSetting.Attach(settingsList.GetNext( pos )) ;
                (!bGotOne )	&& 	SUCCEEDED(hr) && ( pSetting != NULL ) ;
                pSetting.Attach(settingsList.GetNext( pos )) )

			{
				// Check if we have an association

				if ( bGotOne = AreAssociated( pElement, pSetting ) )
				{
					// Get the path to the setting object and create us an association.
					if ( GetLocalInstancePath( pSetting, strSettingPath ) )
					{
						pInstance.Attach(CreateNewInstance( pMethodContext ));

						if ( NULL != pInstance )
						{
							pInstance->SetCHString( IDS_Element, strElementPath );
							pInstance->SetCHString( IDS_Setting, strSettingPath );

							// Invalidates pointer
							hr = pInstance->Commit(  );
						}
						else
						{
							hr = WBEM_E_OUT_OF_MEMORY;
						}
					}	// IF GetPath to Setting Object
				}	// IF AreAssociated
			}	// WHILE GetNext
			settingsList.EndEnum();
		}	// IF BeginEnum
	}	// IF GetLocalInstancePath

	// if we didn't got one, he gets the default...
	if (!bGotOne && !strDefaultPath.IsEmpty())
	{
		pInstance.Attach(CreateNewInstance( pMethodContext ));

		if ( NULL != pInstance )
		{
			pInstance->SetCHString( IDS_Element, strElementPath );
			pInstance->SetCHString( IDS_Setting, strDefaultPath );

			// Invalidates pointer
			hr = pInstance->Commit(  );
		}
		else
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}

	return hr;
}


// element is account
// setting is desktop
BOOL CWin32AssocUserToDesktop::AreAssociated( CInstance* pElement, CInstance* pSetting )
{
	CHString userName, desktopName, userQualifiedName;

	pElement->GetCHString(IDS_Name,   userName);
	pSetting->GetCHString(IDS_Name,   desktopName);

#ifdef NTONLY
	{
		CHString userDomain;
		pElement->GetCHString(IDS_Domain, userDomain);
		userQualifiedName = userDomain + L'\\' + userName;
	}
#endif

	return (desktopName.CompareNoCase(userQualifiedName) == 0);
}

// only difference betweeen this and the base class
// is that it will use .DEFAULT
HRESULT CWin32AssocUserToDesktop::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
	CInstancePtr pElement;
	CInstancePtr pSetting;
    HRESULT hr;

	CHString	strElementPath,
				strSettingPath;

	pInstance->GetCHString( IDS_Element, strElementPath );
	pInstance->GetCHString( IDS_Setting, strSettingPath );

	// If we can get both objects, test for an association

	if (	SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath( strElementPath, &pElement, pInstance->GetMethodContext() ))
		&&	SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath( strSettingPath, &pSetting, pInstance->GetMethodContext() )) )
	{
		if (!AreAssociated( pElement, pSetting ))
		{
            hr = WBEM_E_NOT_FOUND;

			CHString desktopName;
			pSetting->GetCHString(IDS_Name,   desktopName);
            desktopName.MakeUpper();

			// okay, we're trying to match with default
			// only a match if the user DOESN'T have his own...
			if (desktopName.Find(L".DEFAULT") == (desktopName.GetLength() - 8))
			{
				// note local "desktopName" superceding the outer scope
                CHString userName, desktopName, userQualifiedName;

				pElement->GetCHString(IDS_Name,   userName);
				pSetting->GetCHString(IDS_Name,   desktopName);

#ifdef NTONLY
				{
					CHString userDomain;
					pElement->GetCHString(IDS_Domain, userDomain);
					userQualifiedName = userDomain + L'\\' + userName;
				}
#endif

				CHString newPath;
				CInstancePtr pNewSetting;
				newPath.Format(L"Win32_Desktop.Name=\"%s\"", (LPCWSTR) userQualifiedName);

				if (FAILED(CWbemProviderGlue::GetInstanceByPath( newPath, &pNewSetting, pInstance->GetMethodContext() )))
                {
					hr = WBEM_S_NO_ERROR;
                }
			}
        }
        else
        {
            hr = WBEM_S_NO_ERROR;
        }
	}

	return ( hr );
}


CWin32AssocUserToDesktop MyUserToDesktop;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\file.cpp ===
//=================================================================
//
// File.CPP -- File property set provider
//
//  Copyright (c) 1996-2002 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/14/98    a-kevhu         Created
//
//=================================================================

//NOTE: The implementations of EnumerateInstances, GetObject & the pure virtual declaration of IsOneOfMe  method
//		is now present in the derived CImplement_LogicalFile class. Cim_LogicalFile is now instantiable & has only
//		generic method implementations.


//ADDITION ST
// Now in fwcommon.h
//#ifndef _WIN32_WINNT
//#define _WIN32_WINNT 0x0400 //will this affect something else....to be checked out
//#endif
//ADDITION END

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"
#include <comdef.h>
#include "tokenprivilege.h"
#include <winioctl.h>
#include "file.h"
#include "accessentrylist.h"
#include "dacl.h"
#include "sacl.h"
#include "Win32Securitydescriptor.h"
#include "DllWrapperBase.h"
#include "AdvApi32Api.h"
#include "tokenprivilege.h"
#include <strsafe.h>

#include "NtDllApi.h"

#pragma warning(disable : 4995) // we introduced as including strsafe.h gives error for all unsafe string functions

#define PROPSET_NAME_WIN32_SECURITY				_T("Win32_SecurityDescriptor")


#define METHOD_NAME_COPYFILE						L"Copy"
#define METHOD_NAME_COPYFILE_EX						L"CopyEx"
#define METHOD_NAME_DELETEFILE						L"Delete"
#define METHOD_NAME_DELETEFILE_EX					L"DeleteEx"
#define METHOD_NAME_COMPRESS						L"Compress"
#define METHOD_NAME_COMPRESS_EX						L"CompressEx"
#define METHOD_NAME_UNCOMPRESS						L"Uncompress"
#define METHOD_NAME_UNCOMPRESS_EX					L"UncompressEx"
#define METHOD_NAME_TAKEOWNERSHIP					L"TakeOwnerShip"
#define METHOD_NAME_TAKEOWNERSHIP_EX				L"TakeOwnerShipEx"
#define METHOD_NAME_CHANGESECURITYPERMISSIONS		L"ChangeSecurityPermissions"
#define METHOD_NAME_CHANGESECURITYPERMISSIONS_EX	L"ChangeSecurityPermissionsEx"
#define METHOD_NAME_RENAMEFILE						L"Rename"
#define METHOD_NAME_EFFECTIVE_PERMISSION            L"GetEffectivePermission"

#define METHOD_ARG_NAME_RETURNVALUE					L"ReturnValue"
#define METHOD_ARG_NAME_NEWFILENAME					L"FileName"
#define METHOD_ARG_NAME_SECURITY_DESC				L"SecurityDescriptor"
#define METHOD_ARG_NAME_OPTION						L"Option"
#define METHOD_ARG_NAME_START_FILENAME				L"StartFileName"
#define METHOD_ARG_NAME_STOP_FILENAME				L"StopFileName"
#define METHOD_ARG_NAME_RECURSIVE					L"Recursive"
#define METHOD_ARG_NAME_PERMISSION                  L"Permissions"

#define OPTION_VALUE_CHANGE_OWNER				(0X00000001L)
#define OPTION_VALUE_CHANGE_GROUP				(0X00000002L)
#define OPTION_VALUE_CHANGE_DACL				(0X00000004L)
#define OPTION_VALUE_CHANGE_SACL				(0X00000008L)


#define File_STATUS_SUCCESS							0


// Control
#define File_STATUS_ACCESS_DENIED					2
#define File_STATUS_UNKNOWN_FAILURE					8

//start
#define File_STATUS_INVALID_NAME					9
#define File_STATUS_ALREADY_EXISTS					10
#define File_STATUS_FILESYSTEM_NOT_NTFS				11
#define File_STATUS_PLATFORM_NOT_WINNT				12
#define File_STATUS_NOT_SAME_DRIVE					13
#define File_STATUS_DIR_NOT_EMPTY					14
#define File_STATUS_SHARE_VIOLATION					15
#define File_STATUS_INVALID_STARTFILE				16
#define File_STATUS_PRIVILEGE_NOT_HELD				17

#define File_STATUS_INVALID_PARAMETER				21




// Property set declaration
//=========================
CCIMLogicalFile MyFileSet(PROPSET_NAME_FILE, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CCIMLogicalFile::CCIMLogicalFile
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CCIMLogicalFile::CCIMLogicalFile(LPCWSTR setName,
                                 LPCWSTR pszNamespace)
    : Provider(setName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CCIMLogicalFile::~CCIMLogicalFile
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CCIMLogicalFile::~CCIMLogicalFile()
{
}


HRESULT CCIMLogicalFile::ExecMethod (

	const CInstance& rInstance,
	const BSTR bstrMethodName ,
	CInstance *pInParams ,
	CInstance *pOutParams ,
	long lFlags
)
{
	if(!pOutParams )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}

	if ( _wcsicmp ( bstrMethodName ,METHOD_NAME_CHANGESECURITYPERMISSIONS) == 0	)
	{
		return ExecChangePermissions(rInstance,pInParams,pOutParams, lFlags, false ) ;
	}
	else if ( _wcsicmp ( bstrMethodName ,METHOD_NAME_COPYFILE) == 0 )
	{
		return ExecCopy(rInstance,pInParams,pOutParams, lFlags, false ) ;
	}
	else if ( _wcsicmp ( bstrMethodName ,METHOD_NAME_RENAMEFILE) == 0 )
	{
		return ExecRename(rInstance,pInParams,pOutParams, lFlags ) ;
	}
	else if ( _wcsicmp ( bstrMethodName ,METHOD_NAME_DELETEFILE) == 0 )
	{
		return ExecDelete(rInstance,pInParams,pOutParams, lFlags, false ) ;
	}
	else if (_wcsicmp ( bstrMethodName ,METHOD_NAME_COMPRESS) == 0 )
	{
		return ExecCompress(rInstance, pInParams, pOutParams, lFlags, false ) ;
	}
	else if (_wcsicmp ( bstrMethodName ,METHOD_NAME_UNCOMPRESS) == 0 )
	{
		return ExecUncompress(rInstance, pInParams, pOutParams, lFlags, false ) ;
	}
	else if ( _wcsicmp ( bstrMethodName , METHOD_NAME_TAKEOWNERSHIP ) == 0 )
	{
		return ExecTakeOwnership(rInstance,pInParams,pOutParams, lFlags, false ) ;
	}
	if ( _wcsicmp ( bstrMethodName ,METHOD_NAME_CHANGESECURITYPERMISSIONS_EX ) == 0	)
	{
		return ExecChangePermissions(rInstance,pInParams,pOutParams, lFlags, true ) ;
	}
	else if ( _wcsicmp ( bstrMethodName ,METHOD_NAME_COPYFILE_EX ) == 0 )
	{
		return ExecCopy(rInstance,pInParams,pOutParams, lFlags, true ) ;
	}
	else if ( _wcsicmp ( bstrMethodName ,METHOD_NAME_DELETEFILE_EX ) == 0 )
	{
		return ExecDelete(rInstance,pInParams,pOutParams, lFlags, true ) ;
	}
	else if (_wcsicmp ( bstrMethodName ,METHOD_NAME_COMPRESS_EX ) == 0 )
	{
		return ExecCompress(rInstance, pInParams, pOutParams, lFlags, true ) ;
	}
	else if (_wcsicmp ( bstrMethodName ,METHOD_NAME_UNCOMPRESS_EX ) == 0 )
	{
		return ExecUncompress(rInstance, pInParams, pOutParams, lFlags, true ) ;
	}
	else if ( _wcsicmp ( bstrMethodName , METHOD_NAME_TAKEOWNERSHIP_EX ) == 0 )
	{
		return ExecTakeOwnership(rInstance,pInParams,pOutParams, lFlags, true ) ;
	}
    else if(_wcsicmp(bstrMethodName, METHOD_NAME_EFFECTIVE_PERMISSION) == 0)
	{
		return ExecEffectivePerm(rInstance, pInParams, pOutParams, lFlags);
	}

	return WBEM_E_INVALID_METHOD ;
}


HRESULT CCIMLogicalFile::ExecChangePermissions(
	const CInstance& rInstance,
	CInstance *pInParams,
	CInstance *pOutParams,
	long lFlags,
	bool bExtendedMethod
)
{
	HRESULT hr = S_OK ;
	DWORD dwStatus = STATUS_SUCCESS ;
	CInputParams InputParams ;
	if ( pInParams )
	{
		hr = CheckChangePermissionsOnFileOrDir(
				rInstance,
				pInParams ,
				pOutParams ,
				dwStatus,
				bExtendedMethod,
				InputParams
			) ;

			if ( SUCCEEDED ( hr ) )
			{
				pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , dwStatus ) ;
				if ( bExtendedMethod && dwStatus != STATUS_SUCCESS && !InputParams.bstrtErrorFileName == false )
				{
					pOutParams->SetCHString ( METHOD_ARG_NAME_STOP_FILENAME, (PWCHAR)InputParams.bstrtErrorFileName ) ;
				}
				if ( dwStatus == File_STATUS_PRIVILEGE_NOT_HELD )
				{
					hr = WBEM_E_PRIVILEGE_NOT_HELD ;
				}
			}
	}
	else
	{
		hr = WBEM_E_INVALID_PARAMETER ;
	}
	return hr ;
}


typedef void (*GETDESCRIPTOR)(
	CInstance* pInstance, PSECURITY_DESCRIPTOR *ppDescriptor);


HRESULT CCIMLogicalFile::CheckChangePermissionsOnFileOrDir(
	const CInstance& rInstance ,
	CInstance *pInParams ,
	CInstance *pOutParams ,
	DWORD &dwStatus,
	bool bExtendedMethod,
	CInputParams& InputParams

)
{
	HRESULT hr = S_OK ;

#ifdef NTONLY
	CHString chsStartFile ;
	bool bExists ;
	VARTYPE eType ;
	DWORD dwOption ;

	if ( bExtendedMethod )
	{
		if ( pInParams->GetStatus( METHOD_ARG_NAME_START_FILENAME, bExists , eType ) )
		{
			if ( bExists && ( eType == VT_BSTR || eType == VT_NULL ) )
			{
				if ( eType == VT_BSTR )
				{
					if ( pInParams->GetCHString( METHOD_ARG_NAME_START_FILENAME, chsStartFile ) )
					{
					}
					else
					{
						dwStatus = File_STATUS_INVALID_PARAMETER ;
						return hr ;
					}
				}
			}
			else
			{
				dwStatus = File_STATUS_INVALID_PARAMETER ;
				return hr ;
			}
		}
		else
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
			return hr ;
		}

		//check if recursive operation is desired
		if ( pInParams->GetStatus( METHOD_ARG_NAME_RECURSIVE, bExists , eType ) )
		{
			if ( bExists && ( eType == VT_BOOL || eType == VT_NULL ) )
			{
				if ( eType == VT_BOOL )
				{
					if ( pInParams->Getbool( METHOD_ARG_NAME_RECURSIVE, InputParams.bRecursive ) )
					{
					}
					else
					{
						dwStatus = File_STATUS_INVALID_PARAMETER ;
						return hr ;
					}
				}
			}
			else
			{
				dwStatus = File_STATUS_INVALID_PARAMETER ;
				return hr ;
			}
		}
		else
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
			return hr ;
		}
	}

	//set the start file if given as input after checking that it's a fully qualified path
	if ( !chsStartFile.IsEmpty() )
	{
		InputParams.bstrtStartFileName = (LPCTSTR)chsStartFile ;
		WCHAR* pwcTmp	= InputParams.bstrtStartFileName ;
		WCHAR* pwcColon = L":" ;

		if( *(pwcTmp + 1) != *pwcColon )
		{
			dwStatus = File_STATUS_INVALID_NAME ;
			return hr ;
		}
	}

	if ( pInParams->GetStatus( METHOD_ARG_NAME_OPTION, bExists , eType ) )
	{
		if ( bExists && ( eType == VT_I4 ) )
		{
			if ( pInParams->GetDWORD( METHOD_ARG_NAME_OPTION, dwOption) )
			{
			}
			else
			{
				dwStatus = File_STATUS_INVALID_PARAMETER ;
				return hr ;
			}
		}
		else
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
			return hr ;
		}
	}
	else
	{
		dwStatus = File_STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	MethodContext* pMethodContext = pInParams->GetMethodContext();
	CInstancePtr pSecurityDesc ;
	if ( pInParams->GetStatus ( METHOD_ARG_NAME_SECURITY_DESC , bExists , eType ) )
	{
		if ( bExists &&  eType == VT_UNKNOWN )
		{
			if ( pInParams->GetEmbeddedObject(METHOD_ARG_NAME_SECURITY_DESC, &pSecurityDesc, pMethodContext) )
			{
			}
			else
			{
				dwStatus = File_STATUS_INVALID_PARAMETER ;
			}
		}
		else if(bExists)
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
		}
		else
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
			hr = WBEM_E_PROVIDER_FAILURE ;
		}
	}
	else
	{
		dwStatus = File_STATUS_INVALID_PARAMETER ;
		hr = WBEM_E_PROVIDER_FAILURE ;
	}

	if( dwStatus != STATUS_SUCCESS )
	{
		return hr ;
	}


	CHString chsClassProperty ( L"__CLASS" ) ;
	if ( pSecurityDesc->GetStatus ( chsClassProperty, bExists , eType ) )
	{
		if ( bExists && ( eType == VT_BSTR ) )
		{
			CHString chsClass ;
			if ( pSecurityDesc->GetCHString ( chsClassProperty , chsClass ) )
			{
				if ( chsClass.CompareNoCase ( PROPSET_NAME_WIN32_SECURITY ) != 0 )
				{
					dwStatus = File_STATUS_INVALID_PARAMETER ;
				}
			}
			else
			{
				dwStatus = File_STATUS_INVALID_PARAMETER ;
				hr = WBEM_E_PROVIDER_FAILURE ;
			}

		}
		else
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
			hr = WBEM_E_PROVIDER_FAILURE ;
		}
	}
	else
	{
		dwStatus = File_STATUS_INVALID_PARAMETER ;
		hr = WBEM_E_PROVIDER_FAILURE ;
	}


	if( dwStatus != STATUS_SUCCESS )
	{
		return hr ;
	}


	PSECURITY_DESCRIPTOR pSD = NULL ;
	WCHAR *pwcName = NULL ;

	try
	{
		GetDescriptorFromMySecurityDescriptor(pSecurityDesc, &pSD);

		rInstance.GetWCHAR(IDS_Name,&pwcName) ;
		if(pSD)
		{
			InputParams.SetValues ( pwcName, dwOption, pSD, false, InputParams.bRecursive, ENUM_METHOD_CHANGE_PERM, rInstance.GetMethodContext()) ;
			dwStatus = DoOperationOnFileOrDir(pwcName, InputParams ) ;
			free( InputParams.pSD );
			pSD = NULL ;
		}
		else
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
		}
	}
	catch ( ... )
	{
		if ( pSD )
		{
			free( pSD );
			pSD = NULL ;
		}

        free(pwcName);
        pwcName = NULL ;

		throw ;
	}

    if (pwcName)
    {
        free(pwcName);
        pwcName = NULL;
    }

	return hr ;
#endif
}



DWORD CCIMLogicalFile::ChangePermissions(_bstr_t bstrtFileName, DWORD dwOption, PSECURITY_DESCRIPTOR pSD, CInputParams& InputParams )
{
	//If the object's system ACL is being set,
	//the SE_SECURITY_NAME privilege must be enabled for the calling process.
	DWORD dwReturn = ERROR_SUCCESS;
	bool t_bErrorsDueToMissingPrivileges = false ;
#ifdef NTONLY
    // flags to tell us when the client has not enabled the needed flags
    bool noRestorePriv = false;
    bool noSecurityPriv = false;

	{
		// Fill out security information with only the appropriate DACL/SACL values.
		if ( dwOption & OPTION_VALUE_CHANGE_DACL )
		{
			if ( !::SetFileSecurityW( bstrtFileName,
						 DACL_SECURITY_INFORMATION,
						 pSD ) )
			{
				dwReturn = GetLastError() ;
			}

		}

		// If we need to write owner information, try to write just that piece first.  If
		// we fail because of insufficient access and we are setting the DACL, set that
		// then retry the Write_Owner.
		if ( ( dwOption & OPTION_VALUE_CHANGE_OWNER ) && dwReturn == ERROR_SUCCESS )
		{

			if ( !::SetFileSecurityW( bstrtFileName,
									 OWNER_SECURITY_INFORMATION,
									 pSD ) )
			{
				dwReturn = GetLastError() ;
			}

			// If we failed with this error, try adjusting the SE_RESTORE_NAME privilege
			// so it is enabled.  If that succeeds, retry the operation.
			if ( ERROR_INVALID_OWNER == dwReturn )
			{
				// We might need this guy to handle some special access stuff
				CTokenPrivilege	restorePrivilege( SE_RESTORE_NAME );

				// If we enable the privilege, retry setting the owner info
				if ( ERROR_SUCCESS == restorePrivilege.Enable() )
				{
					bool t_bRestore = true ;
					try
					{
						dwReturn = ERROR_SUCCESS ;
						if ( !::SetFileSecurityW( bstrtFileName,
												 OWNER_SECURITY_INFORMATION,
												 pSD ) )
						{
							dwReturn = GetLastError() ;
						}

						// Clear the privilege
						t_bRestore = false ;
					}
					catch ( ... )
					{
						if ( t_bRestore )
						{
							restorePrivilege.Enable( FALSE );
						}
						throw ;
					}
					restorePrivilege.Enable( FALSE );
				}
                else
                    noRestorePriv = true;
			}

			if ( noRestorePriv && dwReturn != ERROR_SUCCESS )
			{
				t_bErrorsDueToMissingPrivileges = true ;
			}
		}

		if ( ( dwOption & OPTION_VALUE_CHANGE_SACL ) && dwReturn == ERROR_SUCCESS )
		{
			CTokenPrivilege	securityPrivilege( SE_SECURITY_NAME );
			BOOL fDisablePrivilege = FALSE;
			fDisablePrivilege = ( securityPrivilege.Enable() == ERROR_SUCCESS );
            noSecurityPriv = !fDisablePrivilege;
			try
			{
				if  ( !::SetFileSecurityW( bstrtFileName,
										   SACL_SECURITY_INFORMATION,
										   pSD ) )
				{
					dwReturn = ::GetLastError();
				}
			}
			catch ( ... )
			{
				if ( fDisablePrivilege )
				{
					fDisablePrivilege = false ;
					securityPrivilege.Enable(FALSE);
				}
				throw ;
			}

			// Cleanup the Name Privilege as necessary.
			if ( fDisablePrivilege )
			{
				fDisablePrivilege = false ;
				securityPrivilege.Enable(FALSE);
			}

			if ( noSecurityPriv && dwReturn != ERROR_SUCCESS )
			{
				t_bErrorsDueToMissingPrivileges = true ;
			}
		}

		if ( ( dwOption & OPTION_VALUE_CHANGE_GROUP ) && dwReturn == ERROR_SUCCESS )
		{
			if  ( !::SetFileSecurityW( bstrtFileName,
									   GROUP_SECURITY_INFORMATION,
									   pSD ) )
			{
				dwReturn = ::GetLastError();
			}
		}

		dwReturn = MapWinErrorToStatusCode ( dwReturn ) ;

		if ( t_bErrorsDueToMissingPrivileges )
		{
			dwReturn = File_STATUS_PRIVILEGE_NOT_HELD ;
		}

        // client is missing essential privilege
        // prepare error info...
        if (noSecurityPriv || noRestorePriv)
        {
	        SAFEARRAY *psaPrivilegesReqd = NULL , *psaPrivilegesNotHeld = NULL ;
	        SAFEARRAYBOUND rgsabound[1];
	        rgsabound[0].cElements = 1;
	        rgsabound[0].lLbound = 0;
	        psaPrivilegesReqd = SafeArrayCreate(VT_BSTR, 1, rgsabound);
			if ( !psaPrivilegesReqd )
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}
			try
			{
				// how many elements? as many as there are true flags!
				rgsabound[0].cElements = noSecurityPriv + noRestorePriv;
				psaPrivilegesNotHeld = SafeArrayCreate(VT_BSTR, 1, rgsabound);
				if ( !psaPrivilegesNotHeld )
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}

				if (psaPrivilegesReqd && psaPrivilegesNotHeld)
				{
					bstr_t sercurityName(_T("SE_SECURITY_NAME"));
					bstr_t restoreName(_T("SE_RESTORE_NAME"));
					long index = 0;
					// both are REQUIRED
					SafeArrayPutElement(psaPrivilegesReqd, &index, (void *)(BSTR)sercurityName);
					index = 1;
					SafeArrayPutElement(psaPrivilegesReqd, &index, (void *)(BSTR)restoreName);

					// now list those that aren't here
					index = 0;
					if (noSecurityPriv)
					{
						SafeArrayPutElement(psaPrivilegesNotHeld, &index, (void *)(BSTR)sercurityName);
						index++;
					}

					if (noRestorePriv)
						SafeArrayPutElement(psaPrivilegesNotHeld, &index, (void *)(BSTR)restoreName);

					CWbemProviderGlue::SetStatusObject(InputParams.pContext, IDS_CimWin32Namespace,
						_T("Required privilege not enabled"), WBEM_E_FAILED, psaPrivilegesNotHeld,
						psaPrivilegesReqd);
				}
			}
			catch ( ... )
			{
				if (psaPrivilegesNotHeld)
				{
					SafeArrayDestroy(psaPrivilegesNotHeld);
					psaPrivilegesNotHeld = NULL ;
				}
				if (psaPrivilegesReqd)
				{
					SafeArrayDestroy(psaPrivilegesReqd);
					psaPrivilegesReqd = NULL ;
				}
				throw ;
			}

			if (psaPrivilegesNotHeld)
			{
				SafeArrayDestroy(psaPrivilegesNotHeld);
				psaPrivilegesNotHeld = NULL ;
			}
			if (psaPrivilegesReqd)
			{
				SafeArrayDestroy(psaPrivilegesReqd);
				psaPrivilegesReqd = NULL ;
			}
        }
	}
#endif
	//set the file-name at which error occured
	if ( dwReturn != STATUS_SUCCESS )
	{
		InputParams.bstrtErrorFileName = bstrtFileName ;
	}

	return dwReturn ;
}


HRESULT CCIMLogicalFile::ExecCopy(

	const CInstance& rInstance,
	CInstance *pInParams,
	CInstance *pOutParams,
	long lFlags ,
	bool bExtendedMethod
)
{
	HRESULT hr = S_OK ;
	DWORD dwStatus = STATUS_SUCCESS ;
	CInputParams InputParams ;
	if ( pInParams )
	{
		hr = CheckCopyFileOrDir(
				rInstance,
				pInParams ,
				pOutParams ,
				dwStatus,
				bExtendedMethod,
				InputParams
			) ;
			if ( SUCCEEDED ( hr ) )
			{
				pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , dwStatus ) ;
				if ( bExtendedMethod && dwStatus != STATUS_SUCCESS && !InputParams.bstrtErrorFileName == false )
				{
					pOutParams->SetCHString ( METHOD_ARG_NAME_STOP_FILENAME, (PWCHAR)InputParams.bstrtErrorFileName ) ;
				}
			}
	}
	else
	{
		hr = WBEM_E_INVALID_PARAMETER ;
	}
	return hr ;
}


HRESULT CCIMLogicalFile::ExecRename(

	const CInstance& rInstance,
	CInstance *pInParams,
	CInstance *pOutParams,
	long lFlags
)
{

	HRESULT hr = S_OK ;
	DWORD dwStatus = STATUS_SUCCESS ;

	if ( pInParams )
	{

		hr = CheckRenameFileOrDir(
				rInstance,
				pInParams ,
				pOutParams ,
				dwStatus
			) ;

			if ( SUCCEEDED ( hr ) )
			{
				pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , dwStatus ) ;
			}
	}
	else
	{
		hr = WBEM_E_INVALID_PARAMETER ;
	}
	return hr ;
}

HRESULT CCIMLogicalFile::ExecDelete(

	const CInstance& rInstance,
	CInstance *pInParams,
	CInstance *pOutParams,
	long lFlags,
	bool bExtendedMethod
)
{

	HRESULT hr = S_OK ;
	DWORD dwStatus = STATUS_SUCCESS ;
	CInputParams InputParams ;

	if ( bExtendedMethod && !pInParams )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}

	CHString chsStartFile ;
	bool bExists ;
	VARTYPE eType ;
	if ( bExtendedMethod )
	{
		if ( pInParams->GetStatus( METHOD_ARG_NAME_START_FILENAME, bExists , eType ) )
		{
			if ( bExists && ( eType == VT_BSTR || eType == VT_NULL ) )
			{
				if ( eType == VT_BSTR )
				{
					if ( pInParams->GetCHString( METHOD_ARG_NAME_START_FILENAME, chsStartFile ) )
					{
					}
					else
					{
						pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_PARAMETER );
						return hr ;
					}
				}
			}
			else
			{
				pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_PARAMETER );
				return hr ;
			}
		}
		else
		{
			pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_PARAMETER );
			return hr ;
		}
	}

	//set the start file if given as input after checking that it's a fully qualified path
	if ( !chsStartFile.IsEmpty() )
	{
		InputParams.bstrtStartFileName = (LPCWSTR)chsStartFile ;
		WCHAR* pwcTmp	= InputParams.bstrtStartFileName ;
		WCHAR* pwcColon = L":" ;

		if( *(pwcTmp + 1) != *pwcColon )
		{
			pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_NAME ) ;
			return hr ;
		}
	}


	WCHAR *pszName = NULL ;
	rInstance.GetWCHAR(IDS_Name,&pszName) ;

    try
    {
	    InputParams.SetValues ( pszName, 0, NULL, true, true, ENUM_METHOD_DELETE ) ;
	    dwStatus = DoOperationOnFileOrDir( pszName, InputParams ) ;
    }
    catch ( ... )
    {
        if (pszName)
        {
            free (pszName);
            pszName = NULL;
        }
        throw;
    }

    if (pszName)
    {
        free (pszName);
        pszName = NULL;
    }

	pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , dwStatus ) ;
	if ( bExtendedMethod && dwStatus != STATUS_SUCCESS && !InputParams.bstrtErrorFileName == false )
	{
		pOutParams->SetCHString ( METHOD_ARG_NAME_STOP_FILENAME, (PWCHAR)InputParams.bstrtErrorFileName ) ;
	}
	return hr ;
}

HRESULT CCIMLogicalFile::ExecCompress (

	const CInstance& rInstance,
	CInstance *pInParams,
	CInstance *pOutParams,
	long lFlags,
	bool bExtendedMethod
)
{
	HRESULT hr = S_OK ;
	DWORD dwStatus = STATUS_SUCCESS ;
	CInputParams InputParams ;

	if ( bExtendedMethod && !pInParams )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}

	CHString chsStartFile ;
	bool bExists ;
	VARTYPE eType ;
	if ( bExtendedMethod )
	{
		if ( pInParams->GetStatus( METHOD_ARG_NAME_START_FILENAME, bExists , eType ) )
		{
			if ( bExists && ( eType == VT_BSTR || eType == VT_NULL ) )
			{
				if ( eType == VT_BSTR )
				{
					if ( pInParams->GetCHString( METHOD_ARG_NAME_START_FILENAME, chsStartFile ) )
					{
					}
					else
					{
						pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_PARAMETER );
						return hr ;
					}
				}
			}
			else
			{
				pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_PARAMETER );
				return hr ;
			}
		}
		else
		{
			pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_PARAMETER );
			return hr ;
		}

		//check if recursive operation is desired
		if ( pInParams->GetStatus( METHOD_ARG_NAME_RECURSIVE, bExists , eType ) )
		{
			if ( bExists && ( eType == VT_BOOL || eType == VT_NULL ) )
			{
				if ( eType == VT_BOOL )
				{
					if ( pInParams->Getbool( METHOD_ARG_NAME_RECURSIVE, InputParams.bRecursive ) )
					{
					}
					else
					{
						dwStatus = File_STATUS_INVALID_PARAMETER ;
						return hr ;
					}
				}
			}
			else
			{
				dwStatus = File_STATUS_INVALID_PARAMETER ;
				return hr ;
			}
		}
		else
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
			return hr ;
		}
	}

	//set the start file if given as input after checking that it's a fully qualified path
	if ( !chsStartFile.IsEmpty() )
	{
		InputParams.bstrtStartFileName = (LPCWSTR)chsStartFile ;
		WCHAR* pwcTmp	= InputParams.bstrtStartFileName ;
		WCHAR* pwcColon = L":" ;

		if( *(pwcTmp + 1) != *pwcColon )
		{
			pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_NAME );
			return hr ;
		}
	}

	WCHAR *pszName = NULL ;
	rInstance.GetWCHAR(IDS_Name,&pszName) ;

    try
    {
	    InputParams.SetValues ( pszName, 0, NULL, false, InputParams.bRecursive, ENUM_METHOD_COMPRESS ) ;
	    dwStatus = DoOperationOnFileOrDir ( pszName, InputParams ) ;
    }
    catch ( ... )
    {
        if (pszName)
        {
            free(pszName);
            pszName = NULL;
        }
        throw;
    }

    if (pszName)
    {
        free(pszName);
        pszName = NULL;
    }

	pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , dwStatus ) ;
	if ( bExtendedMethod && dwStatus != STATUS_SUCCESS && !InputParams.bstrtErrorFileName == false )
	{
		pOutParams->SetCHString ( METHOD_ARG_NAME_STOP_FILENAME, (PWCHAR)InputParams.bstrtErrorFileName ) ;
	}
	return hr ;
}

HRESULT CCIMLogicalFile::ExecUncompress (

	const CInstance& rInstance,
	CInstance *pInParams,
	CInstance *pOutParams,
	long lFlags,
	bool bExtendedMethod
)
{
	HRESULT hr = S_OK ;

#ifdef NTONLY
	DWORD dwStatus = STATUS_SUCCESS ;
	CInputParams InputParams ;
	if ( bExtendedMethod && !pInParams )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}

	CHString chsStartFile ;
	bool bExists ;
	VARTYPE eType ;
	if ( bExtendedMethod )
	{
		if ( pInParams->GetStatus( METHOD_ARG_NAME_START_FILENAME, bExists , eType ) )
		{
			if ( bExists && ( eType == VT_BSTR || eType == VT_NULL ) )
			{
				if ( eType == VT_BSTR )
				{
					if ( pInParams->GetCHString( METHOD_ARG_NAME_START_FILENAME, chsStartFile ) )
					{
					}
					else
					{
						pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_PARAMETER );
						return hr ;
					}
				}
			}
			else
			{
				pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_PARAMETER );
				return hr ;
			}
		}
		else
		{
			pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_PARAMETER );
			return hr ;
		}

		//check if recursive operation is desired
		if ( pInParams->GetStatus( METHOD_ARG_NAME_RECURSIVE, bExists , eType ) )
		{
			if ( bExists && ( eType == VT_BOOL || eType == VT_NULL ) )
			{
				if ( eType == VT_BOOL )
				{
					if ( pInParams->Getbool( METHOD_ARG_NAME_RECURSIVE, InputParams.bRecursive ) )
					{
					}
					else
					{
						dwStatus = File_STATUS_INVALID_PARAMETER ;
						return hr ;
					}
				}
			}
			else
			{
				dwStatus = File_STATUS_INVALID_PARAMETER ;
				return hr ;
			}
		}
		else
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
			return hr ;
		}
	}

	//set the start file if given as input after checking that it's a fully qualified path
	if ( !chsStartFile.IsEmpty() )
	{
		InputParams.bstrtStartFileName = (LPCTSTR)chsStartFile ;
		WCHAR* pwcTmp	= InputParams.bstrtStartFileName ;
		WCHAR* pwcColon = L":" ;

		if( *(pwcTmp + 1) != *pwcColon )
		{
			pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_NAME );
			return hr ;
		}
	}

	WCHAR *pszName = NULL ;
	rInstance.GetWCHAR(IDS_Name,&pszName) ;

    try
    {
        InputParams.SetValues ( pszName, 0, NULL, false, InputParams.bRecursive, ENUM_METHOD_UNCOMPRESS ) ;
	    dwStatus = DoOperationOnFileOrDir ( pszName, InputParams ) ;
    }
    catch ( ... )
    {
        if (pszName)
        {
            free (pszName);
            pszName = NULL;
        }
        throw;
    }

    if (pszName)
    {
        free (pszName);
        pszName = NULL;
    }

	pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , dwStatus ) ;
	if ( bExtendedMethod && dwStatus != STATUS_SUCCESS && !InputParams.bstrtErrorFileName == false )
	{
		pOutParams->SetCHString ( METHOD_ARG_NAME_STOP_FILENAME, (PWCHAR)InputParams.bstrtErrorFileName ) ;
	}
	return hr ;
#endif
}

HRESULT CCIMLogicalFile::ExecTakeOwnership(

	const CInstance& rInstance,
	CInstance *pInParams,
	CInstance *pOutParams,
	long lFlags,
	bool bExtendedMethod
)
{
	HRESULT hr = S_OK ;

#ifdef NTONLY
	DWORD dwStatus = STATUS_SUCCESS ;
	CInputParams InputParams ;

	if ( bExtendedMethod && !pInParams )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}

	CHString chsStartFile ;
	bool bExists ;
	VARTYPE eType ;
	if ( bExtendedMethod )
	{
		if ( pInParams->GetStatus( METHOD_ARG_NAME_START_FILENAME, bExists , eType ) )
		{
			if ( bExists && ( eType == VT_BSTR || eType == VT_NULL ) )
			{
				if ( eType == VT_BSTR )
				{
					if ( pInParams->GetCHString( METHOD_ARG_NAME_START_FILENAME, chsStartFile ) )
					{
					}
					else
					{
						pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_PARAMETER );
						return hr ;
					}
				}
			}
			else
			{
				pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_PARAMETER );
				return hr ;
			}
		}
		else
		{
			pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_PARAMETER );
			return hr ;
		}

		//check if recursive operation is desired
		if ( pInParams->GetStatus( METHOD_ARG_NAME_RECURSIVE, bExists , eType ) )
		{
			if ( bExists && ( eType == VT_BOOL || eType == VT_NULL ) )
			{
				if ( eType == VT_BOOL )
				{
					if ( pInParams->Getbool( METHOD_ARG_NAME_RECURSIVE, InputParams.bRecursive ) )
					{
					}
					else
					{
						dwStatus = File_STATUS_INVALID_PARAMETER ;
						return hr ;
					}
				}
			}
			else
			{
				dwStatus = File_STATUS_INVALID_PARAMETER ;
				return hr ;
			}
		}
		else
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
			return hr ;
		}
	}

	//set the start file if given as input after checking that it's a fully qualified path
	if ( !chsStartFile.IsEmpty() )
	{
		InputParams.bstrtStartFileName = (LPCTSTR)chsStartFile ;
		WCHAR* pwcTmp	= InputParams.bstrtStartFileName ;
		WCHAR* pwcColon = L":" ;

		if( *(pwcTmp + 1) != *pwcColon )
		{
			pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_NAME );
			return hr ;
		}
	}

	WCHAR *pszName = NULL ;
	rInstance.GetWCHAR(IDS_Name,&pszName) ;

    try
    {
	    InputParams.SetValues ( pszName, 0, NULL, false, InputParams.bRecursive, ENUM_METHOD_TAKEOWNERSHIP ) ;
	    dwStatus = DoOperationOnFileOrDir ( pszName, InputParams ) ;
    }
    catch ( ... )
    {
        if (pszName)
        {
            free (pszName);
            pszName = NULL;
        }
        throw ;
    }

    if (pszName)
    {
        free (pszName);
        pszName = NULL;
    }

	pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , dwStatus ) ;
	if ( bExtendedMethod && dwStatus != STATUS_SUCCESS && !InputParams.bstrtErrorFileName == false )
	{
		pOutParams->SetCHString ( METHOD_ARG_NAME_STOP_FILENAME, (PWCHAR)InputParams.bstrtErrorFileName ) ;
	}
	return hr ;
#endif
}


HRESULT CCIMLogicalFile::ExecEffectivePerm(const CInstance& rInstance,
	                                       CInstance *pInParams,
	                                       CInstance *pOutParams,
	                                       long lFlags)
{
	HRESULT hr = S_OK ;

#ifdef NTONLY
	bool fHasPerm = false;
	if(pInParams != NULL)
	{
		hr = CheckEffectivePermFileOrDir(rInstance, pInParams, pOutParams, fHasPerm);
		if(SUCCEEDED(hr))
		{
			pOutParams->Setbool(METHOD_ARG_NAME_RETURNVALUE, fHasPerm);
		}
	}
	else
	{
		hr = WBEM_E_INVALID_PARAMETER;
	}
#endif
	return hr ;
}


DWORD CCIMLogicalFile::DoOperationOnFileOrDir(WCHAR *pwcName, CInputParams& InParams )
{
	_bstr_t bstrtDrive;
    _bstr_t bstrtPathName;
    WCHAR wstrTemp[_MAX_PATH];
    WCHAR* pwc = NULL;
    DWORD dwStatus = File_STATUS_INVALID_NAME ;

    ZeroMemory(wstrTemp,sizeof(wstrTemp));

	if ((pwcName != NULL) &&
        (wcschr(pwcName, L':') != NULL) &&
        (wcspbrk(pwcName,L"?*") == NULL)) //don't want files with wildchars
	{
        if(FAILED(StringCchCopy(wstrTemp,_MAX_PATH, pwcName))){
            return dwStatus;
        }

		//parse the filename for drive & path
		pwc = wcschr(wstrTemp, L':');
        if(pwc == NULL)
        {
			return dwStatus ;
		}

		*pwc = NULL;

		//Get the drive
        bstrtDrive = wstrTemp;
        bstrtDrive += L":";

        ZeroMemory(wstrTemp,sizeof(wstrTemp));
        wcscpy(wstrTemp,pwcName);
        pwc = NULL;
        pwc = wcschr(wstrTemp, L':') + 1;
        if(pwc == NULL)
        {
			return dwStatus ;
		}


		//Get the path
		bstrtPathName = pwc;


		//chek that the the file system is NTFS

		_bstr_t bstrtBuff ;
		bstrtBuff = bstrtDrive ;
		bstrtBuff += L"\\"  ;

		TCHAR szFSName[_MAX_PATH];

		if( !GetVolumeInformation(bstrtBuff, NULL, 0, NULL, NULL, NULL, szFSName, sizeof(szFSName) / sizeof(TCHAR) ) )
		{
			return GetStatusCode() ;
		}

		//NTFS not reqd. for delete or copy...
		if( !lstrcmp(szFSName, _T("NTFS"))  || InParams.eOperation == ENUM_METHOD_DELETE || InParams.eOperation == ENUM_METHOD_COPY )
		{

			DWORD dwAttrib ;

#ifdef NTONLY
			{

				dwAttrib = GetFileAttributesW(pwcName) ;
			}
#endif
			if( dwAttrib == 0xFFFFFFFF )
			{
				return GetStatusCode() ;
			}

			//check if a dir.
			if (dwAttrib & FILE_ATTRIBUTE_DIRECTORY)
			{
				if ( InParams.bDoDepthFirst )
				{
					// do a depth-first
#ifdef NTONLY
						dwStatus = EnumAllPathsNT(bstrtDrive, bstrtPathName, InParams ) ;
#endif
					if(!dwStatus)
					{
						dwStatus = DoTheRequiredOperation ( pwcName, dwAttrib, InParams )  ;

						//check if the StartFile was encountered
						if ( !dwStatus && !InParams.bOccursAfterStartFile )
						{
							dwStatus = File_STATUS_INVALID_STARTFILE ;
						}
					}
				}
				else  //not a depth first
				{
					//for COPY: parent dir/file already copied so only enumerate sub-paths
					if ( InParams.eOperation != ENUM_METHOD_COPY )
					{
						dwStatus = DoTheRequiredOperation ( pwcName, dwAttrib, InParams ) ;
					}
					else
					{
						dwStatus = STATUS_SUCCESS ;
					}

					if(!dwStatus)
					{
#ifdef NTONLY
							dwStatus = EnumAllPathsNT (bstrtDrive, bstrtPathName, InParams ) ;
#endif
						//check if the StartFile was encountered
						if ( !dwStatus && !InParams.bOccursAfterStartFile )
						{
							dwStatus = File_STATUS_INVALID_STARTFILE ;
						}
					}
				}
			}
			//compress the file
			else
			{
				if( InParams.eOperation != ENUM_METHOD_COPY )
				{
					dwStatus = DoTheRequiredOperation ( pwcName, dwAttrib, InParams ) ;

					//check if the StartFile was encountered
					if ( !dwStatus && !InParams.bOccursAfterStartFile )
					{
						dwStatus = File_STATUS_INVALID_STARTFILE ;
					}
				}
				else
				{
					dwStatus = STATUS_SUCCESS ;
				}
			}
		}
		else
		{
			dwStatus = File_STATUS_FILESYSTEM_NOT_NTFS  ; // this to be checked
		}
	}

    return dwStatus ;
}



#ifdef NTONLY
DWORD CCIMLogicalFile::EnumAllPathsNT(const WCHAR *pszDrive, const WCHAR *pszPath, CInputParams& InParams )
{
   WCHAR szBuff[_MAX_PATH];
   WCHAR szCompletePath[_MAX_PATH];

   WIN32_FIND_DATAW stFindData;
   SmartFindClose hFind;
   bool bRoot ;

   DWORD dwStatusCode = STATUS_SUCCESS ;

   // Start building the path for FindFirstFile
   HRESULT copyResult = StringCchCopyW(szBuff,_MAX_PATH, pszDrive);
   if (FAILED(copyResult)) return File_STATUS_INVALID_PARAMETER;

   // Are we looking at the root?
   if (wcscmp(pszPath, L"\\") == 0)
   {
		bRoot = true;
   }
   else
   {
		bRoot = false;
		copyResult = StringCchCatW(szBuff, _MAX_PATH, pszPath);
	    if (FAILED(copyResult)) return File_STATUS_INVALID_PARAMETER;		
   }

   // Complete the path
   copyResult = StringCchCatW(szBuff, _MAX_PATH, L"\\*.*");
   if (FAILED(copyResult)) return File_STATUS_INVALID_PARAMETER;		
   

   // Do the find
   hFind = FindFirstFileW(szBuff, &stFindData);
   if (hFind == INVALID_HANDLE_VALUE)
   {
		return false;
   }


   // Walk the directory tree
   do
   {
		// Build path containing the directory we just found
		wcscpy(szCompletePath, pszDrive);
		wcscat(szCompletePath,pszPath) ;
		wcscpy(szBuff, pszPath);
		if (!bRoot)
		{
			wcscat(szBuff, L"\\");
			wcscat(szCompletePath, L"\\") ;
		}

		wcscat(szBuff, stFindData.cFileName);
		wcscat(szCompletePath, stFindData.cFileName);

		if(stFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
		{
			//do the operation on the directory only if the recursive option was set
			if ( InParams.bRecursive )
			{
				// check if it's a dir
				if( wcscmp(stFindData.cFileName, L".")	&& wcscmp(stFindData.cFileName, L"..") )
				{
					if ( InParams.bDoDepthFirst )	// do a depth-first
					{
						dwStatusCode = EnumAllPathsNT(pszDrive, szBuff, InParams );

						if(!dwStatusCode)
						{
							dwStatusCode = DoTheRequiredOperation ( szCompletePath, stFindData.dwFileAttributes, InParams ) ;
						}
					}
					else	//it's not a depth first
					{

						dwStatusCode = DoTheRequiredOperation ( szCompletePath, stFindData.dwFileAttributes, InParams ) ;

						if(!dwStatusCode)
						{
							dwStatusCode = EnumAllPathsNT(pszDrive, szBuff, InParams );
						}
					}
				}
			}
		}
		else //it's a file
		{
			dwStatusCode = DoTheRequiredOperation ( szCompletePath, stFindData.dwFileAttributes, InParams ) ;
		}
   }while ( !dwStatusCode && FindNextFileW(hFind, &stFindData) );

   return dwStatusCode;
}
#endif

DWORD CCIMLogicalFile::Delete(_bstr_t bstrtFileName, DWORD dwAttributes, CInputParams& InputParams )
{
	DWORD dwStatus = STATUS_SUCCESS ;
	bool bRet ;

	//remove read-only attrib since we have to delete anyway ?? fix for Bug#31676
	DWORD dwTempAttribs = ~FILE_ATTRIBUTE_READONLY ;

	if(dwAttributes & FILE_ATTRIBUTE_READONLY)
	{
#ifdef NTONLY
		{
			bRet = SetFileAttributesW(bstrtFileName, dwAttributes & dwTempAttribs ) ;
		}
#endif

		if(!bRet)
		{
			//set the file-name at which error occured
			InputParams.bstrtErrorFileName = bstrtFileName ;
			return GetStatusCode() ;
		}
	}


	if( dwAttributes & FILE_ATTRIBUTE_DIRECTORY )
	{

#ifdef NTONLY
		{
			bRet = RemoveDirectoryW( bstrtFileName ) ;
		}
#endif
	}
	else
	{
#ifdef NTONLY
		{
			bRet = DeleteFileW( bstrtFileName ) ;
		}
#endif

	}
	if(!bRet)
	{
		//set the file-name at which error occured
		InputParams.bstrtErrorFileName = bstrtFileName ;
		dwStatus = GetStatusCode() ;
	}

	return dwStatus ;
}

DWORD CCIMLogicalFile::Compress (_bstr_t bstrtFileName, DWORD dwAttributes, CInputParams& InputParams )
{
	SmartCloseHandle hFile ;
	BOOL bRet ;
	if( dwAttributes & FILE_ATTRIBUTE_COMPRESSED )
	{
		return STATUS_SUCCESS ;
	}

	//  Try to remove the READONLY attribute if set, as we've to open the file for writing
	if ( dwAttributes & FILE_ATTRIBUTE_READONLY )
	{
#ifdef NTONLY
		{
			bRet = SetFileAttributesW ( bstrtFileName, dwAttributes & ~FILE_ATTRIBUTE_READONLY ) ;
		}
#endif

		if ( !bRet )
		{
			//set the file-name at which error occured
			InputParams.bstrtErrorFileName = bstrtFileName ;
			return GetStatusCode() ;
		}
	}

#ifdef NTONLY
	{

			hFile = CreateFileW(	bstrtFileName,											// pointer to name of the file
									FILE_READ_DATA | FILE_WRITE_DATA ,						// access (read-write) mode
									FILE_SHARE_READ | FILE_SHARE_WRITE ,					// share mode is exclusive
									NULL,													// pointer to security attributes
									OPEN_EXISTING,											// how to create
									FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_SEQUENTIAL_SCAN,	// file attributes
									NULL													// handle to file with attributes to  copy
								);
	}
#endif
	//Turn the READONLY attribute back ON.
	if ( dwAttributes & FILE_ATTRIBUTE_READONLY )
	{
#ifdef NTONLY
		{
			bRet = SetFileAttributesW ( bstrtFileName, dwAttributes | FILE_ATTRIBUTE_READONLY ) ;
		}
#endif
		if ( !bRet )
		{
			//set the file-name at which error occured
			InputParams.bstrtErrorFileName = bstrtFileName ;
			return GetStatusCode() ;
		}
	}

	if ( hFile == INVALID_HANDLE_VALUE )
	{
		//set the file-name at which error occured
		InputParams.bstrtErrorFileName = bstrtFileName ;
		return GetStatusCode() ;
	}

	//default Compression format is COMPRESSION_FORMAT_LZNT1
	//use COMPRESSION_FORMAT_NONE to decompress

	USHORT eCompressionState =  COMPRESSION_FORMAT_DEFAULT ;
	DWORD BytesReturned = 0;

	bRet =	DeviceIoControl(	hFile,							// handle to device of interest
								FSCTL_SET_COMPRESSION,			// control code of operation to perform
								(LPVOID ) &eCompressionState,   // pointer to buffer to supply input data
								sizeof(eCompressionState),		// size of input buffer
								NULL,							// pointer to buffer to receive output data
								0,								// size of output buffer
								&BytesReturned,					// pointer to variable to receive output
								NULL							// pointer to overlapped structure for asynchronous operation
							);


	if(!bRet)
	{
		//set the file-name at which error occured
		InputParams.bstrtErrorFileName = bstrtFileName ;
		return GetStatusCode() ;
	}

	return STATUS_SUCCESS ;
}

DWORD CCIMLogicalFile::Uncompress (_bstr_t bstrtFileName, DWORD dwAttributes, CInputParams& InputParams )
{
	SmartCloseHandle hFile ;
	BOOL bRet ;
	//check if the file is already uncompressed
	if ( !( dwAttributes & FILE_ATTRIBUTE_COMPRESSED ) )
	{
		return STATUS_SUCCESS ;
	}

	//  Try to remove the READONLY attribute if set, as we've to open the file for writing
	if ( dwAttributes & FILE_ATTRIBUTE_READONLY )
	{
#ifdef NTONLY
		{
			bRet = SetFileAttributesW ( bstrtFileName, dwAttributes & ~FILE_ATTRIBUTE_READONLY ) ;
		}
#endif

		if ( !bRet )
		{
			//set the file-name at which error occured
			InputParams.bstrtErrorFileName = bstrtFileName ;
			return GetStatusCode() ;
		}
	}

#ifdef NTONLY
	{

			hFile = CreateFileW(	bstrtFileName,											// pointer to name of the file
									FILE_READ_DATA | FILE_WRITE_DATA ,						// access (read-write) mode
									FILE_SHARE_READ | FILE_SHARE_WRITE ,					// share mode is exclusive
									NULL,													// pointer to security attributes
									OPEN_EXISTING,											// how to create
									FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_SEQUENTIAL_SCAN,	// file attributes
									NULL													// handle to file with attributes to  copy
								);
	}
#endif
	//Turn the READONLY attribute back ON.
	if ( dwAttributes & FILE_ATTRIBUTE_READONLY )
	{
#ifdef NTONLY
		{
			bRet = SetFileAttributesW ( bstrtFileName, dwAttributes | FILE_ATTRIBUTE_READONLY ) ;
		}
#endif
		if ( !bRet )
		{
			//set the file-name at which error occured
			InputParams.bstrtErrorFileName = bstrtFileName ;
			return GetStatusCode() ;
		}
	}

	if ( hFile == INVALID_HANDLE_VALUE )
	{
		//set the file-name at which error occured
		InputParams.bstrtErrorFileName = bstrtFileName ;
		return GetStatusCode() ;
	}

	USHORT eCompressionState = COMPRESSION_FORMAT_NONE ;
	DWORD BytesReturned = 0;

	bRet =	DeviceIoControl(	hFile,							// handle to device of interest
								FSCTL_SET_COMPRESSION,			// control code of operation to perform
								(LPVOID ) &eCompressionState,   // pointer to buffer to supply input data
								sizeof(eCompressionState),		// size of input buffer
								NULL,							// pointer to buffer to receive output data
								0,								// size of output buffer
								&BytesReturned,					// pointer to variable to receive output
								NULL							// pointer to overlapped structure for asynchronous operation
							);


	if(!bRet)
	{
		//set the file-name at which error occured
		InputParams.bstrtErrorFileName = bstrtFileName ;
		return GetStatusCode() ;
	}

	return STATUS_SUCCESS ;
}

HRESULT CCIMLogicalFile::DeleteInstance(const CInstance& newInstance, long lFlags /*= 0L*/)
{
	HRESULT hr = WBEM_S_NO_ERROR ;
	DWORD dwStatus ;
	WCHAR *pwcFileName = NULL;
	if ( newInstance.GetWCHAR( IDS_Name, &pwcFileName) &&  pwcFileName != NULL )
	{
        try
        {
		    CInputParams InParams;
			InParams.SetValues( pwcFileName, 0, NULL, true, true, ENUM_METHOD_DELETE ) ;
		    dwStatus = DoOperationOnFileOrDir ( pwcFileName, InParams ) ;
        }
        catch ( ... )
        {
            if (pwcFileName)
            {
                free(pwcFileName);
                pwcFileName = NULL;
            }
            throw;
        }

        if (pwcFileName)
        {
            free(pwcFileName);
            pwcFileName = NULL;
        }

		if(dwStatus != STATUS_SUCCESS)
		{
			hr = MapStatusCodestoWbemCodes( dwStatus ) ;
		}
	}
	else
	{
		hr = WBEM_E_INVALID_PARAMETER ;
	}

	return hr ;
}


typedef DWORD  (WINAPI *SETNAMEDSECURITYINFO)(
	LPWSTR,
	SE_OBJECT_TYPE,
	SECURITY_INFORMATION,
	PSID,
	PSID,
	PACL,
	PACL);


DWORD CCIMLogicalFile::TakeOwnership( _bstr_t bstrtFileName, CInputParams& InputParams )
{
#ifdef NTONLY
    HANDLE hToken ;
	TOKEN_USER * pTokenUser = NULL ;
	DWORD dwReturnLength ;
	HRESULT hr = E_FAIL ;
	CAdvApi32Api* pAdvApi32 = NULL ;
	try
	{

		BOOL bStatus = OpenThreadToken (	GetCurrentThread(),
											TOKEN_QUERY ,
											TRUE,  //?
											&hToken
										) ;

		if ( ! bStatus )
		{

			bStatus = OpenProcessToken (	GetCurrentProcess(),
											TOKEN_QUERY | TOKEN_DUPLICATE ,
											&hToken
										) ;
		}

		if(!bStatus)
		{
			//set the file-name at which error occured
			InputParams.bstrtErrorFileName = bstrtFileName ;
			return GetStatusCode() ;
		}

		TOKEN_INFORMATION_CLASS eTokenInformationClass = TokenUser ;

		BOOL bTokenStatus = GetTokenInformation (	hToken,
													eTokenInformationClass ,
													NULL ,
													0 ,
													&dwReturnLength
												) ;

		if ( ! bTokenStatus && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
		{
			pTokenUser = ( TOKEN_USER * ) new UCHAR [ dwReturnLength ] ;

			bTokenStatus = GetTokenInformation (	hToken,//hToken1,
													eTokenInformationClass ,
													(LPVOID) pTokenUser ,
													dwReturnLength ,
													& dwReturnLength
												) ;

			DWORD dwRes ;
			if ( bTokenStatus )
			{

				//HINSTANCE hinstAdvapi = LoadLibrary(_T("advapi32.dll"));
				//
				//if (!hinstAdvapi)
				//	return File_STATUS_UNKNOWN_FAILURE;

				pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL);
				if(pAdvApi32 != NULL)
				{

					//SETNAMEDSECURITYINFO fpSetNamedSecurityInfoW =
					//    (SETNAMEDSECURITYINFO) GetProcAddress(hinstAdvapi,
					//    "SetNamedSecurityInfoW");
					//
					//if (!fpSetNamedSecurityInfoW)
					//    return File_STATUS_UNKNOWN_FAILURE;

					pAdvApi32->SetNamedSecurityInfoW(
												bstrtFileName,               // name of the object
												SE_FILE_OBJECT,              // type of object
												OWNER_SECURITY_INFORMATION,  // change only the object's pwner
												pTokenUser->User.Sid ,       // desired SID
												NULL, NULL, NULL,
												&dwRes);
				}
				else
				{
					return File_STATUS_UNKNOWN_FAILURE;
				}

				//FreeLibrary(hinstAdvapi);

				if(pTokenUser)
				{
					delete[] (UCHAR*)pTokenUser ;
					pTokenUser = NULL ;
				}

				dwRes = MapWinErrorToStatusCode(dwRes) ;
				if ( dwRes != STATUS_SUCCESS )
				{
					//set the file-name at which error occured
					InputParams.bstrtErrorFileName = bstrtFileName ;
				}

				return dwRes ;
			}

		}
	}
	catch ( ... )
	{
		if(pTokenUser)
		{
			delete[] (UCHAR*)pTokenUser ;
			pTokenUser = NULL ;
		}

		if ( pAdvApi32 )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, pAdvApi32);
			pAdvApi32 = NULL ;
		}

		throw ;
	}

	if(pTokenUser)
	{
		delete[] (UCHAR*)pTokenUser ;
		pTokenUser = NULL ;
	}

	CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, pAdvApi32);
	pAdvApi32 = NULL;

	DWORD dwRet = GetStatusCode();
	if ( dwRet != STATUS_SUCCESS )
	{
		//set the file-name at which error occured
		InputParams.bstrtErrorFileName = bstrtFileName ;
	}
	return dwRet ;


#endif
}


HRESULT CCIMLogicalFile::CheckCopyFileOrDir(

	const CInstance& rInstance ,
	CInstance *pInParams ,
	CInstance *pOutParams ,
	DWORD &dwStatus ,
	bool bExtendedMethod,
	CInputParams& InputParams
)
{
	HRESULT hr = S_OK ;

	bool bExists ;
	VARTYPE eType ;

	WCHAR * pszNewFileName  = NULL;

	CHString chsStartFile ;
	if ( bExtendedMethod )
	{
		if ( pInParams->GetStatus( METHOD_ARG_NAME_START_FILENAME, bExists , eType ) )
		{
			if ( bExists && ( eType == VT_BSTR || eType == VT_NULL ) )
			{
				if ( eType == VT_BSTR )
				{
					if ( pInParams->GetCHString( METHOD_ARG_NAME_START_FILENAME, chsStartFile ) )
					{
					}
					else
					{
						dwStatus = File_STATUS_INVALID_PARAMETER ;
						return hr ;
					}
				}
			}
			else
			{
				dwStatus = File_STATUS_INVALID_PARAMETER ;
				return hr ;
			}
		}
		else
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
			return hr ;
		}

		//check if recursive operation is desired
		if ( pInParams->GetStatus( METHOD_ARG_NAME_RECURSIVE, bExists , eType ) )
		{
			if ( bExists && ( eType == VT_BOOL || eType == VT_NULL ) )
			{
				if ( eType == VT_BOOL )
				{
					if ( pInParams->Getbool( METHOD_ARG_NAME_RECURSIVE, InputParams.bRecursive ) )
					{
					}
					else
					{
						dwStatus = File_STATUS_INVALID_PARAMETER ;
						return hr ;
					}
				}
			}
			else
			{
				dwStatus = File_STATUS_INVALID_PARAMETER ;
				return hr ;
			}
		}
		else
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
			return hr ;
		}
	}

	//set the start file if given as input after checking that it's a fully qualified path
	if ( !chsStartFile.IsEmpty() )
	{
		InputParams.bstrtStartFileName = (LPCWSTR)chsStartFile ;
		WCHAR* pwcTmp	= InputParams.bstrtStartFileName ;
		WCHAR* pwcColon = L":" ;

		if( *(pwcTmp + 1) != *pwcColon )
		{
			dwStatus = File_STATUS_INVALID_NAME ;
			return hr ;
		}
	}

	if ( pInParams->GetStatus( METHOD_ARG_NAME_NEWFILENAME , bExists , eType ) )
	{
		if ( bExists && ( eType == VT_BSTR ) )
		{
			if ( pInParams->GetWCHAR( METHOD_ARG_NAME_NEWFILENAME, &pszNewFileName) && pszNewFileName != NULL )
			{
			}
			else
			{
				// Zero Length string
				dwStatus = File_STATUS_INVALID_PARAMETER ;
				return hr ;
			}
		}
		else if(bExists)
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
			return hr ;
		}
		else
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
			return hr ;
		}
	}
	else
	{
		dwStatus = File_STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

    try
    {
        if ( dwStatus == STATUS_SUCCESS )
	    {
		    dwStatus = CopyFileOrDir(rInstance, pszNewFileName, InputParams ) ;
	    }
    }
    catch ( ... )
    {
        if (pszNewFileName)
        {
            free(pszNewFileName);
            pszNewFileName = NULL;
        }
        throw;
    }

    if (pszNewFileName)
    {
        free(pszNewFileName);
        pszNewFileName = NULL;
    }

	return hr ;
}


DWORD CCIMLogicalFile::CopyFileOrDir(const CInstance &rInstance, _bstr_t bstrtNewFileName, CInputParams& InputParams )
{
	DWORD dwStatus = STATUS_SUCCESS ;

	WCHAR *pszTemp = NULL ;
	bool bRet = false;

// a very crude way to check for a fully qualified path(?)
	WCHAR* pwcTmp	= bstrtNewFileName ;

	if (!pwcTmp)
	{
		return File_STATUS_INVALID_NAME ;
	}

	WCHAR* pwcColon = L":" ;

	if( *(pwcTmp + 1) != *pwcColon )
	{
		return File_STATUS_INVALID_NAME ;
	}

    _bstr_t bstrtOriginalName;

	rInstance.GetWCHAR(IDS_Name,&pszTemp) ;

    try
    {
	    bstrtOriginalName = pszTemp;
    }
    catch ( ... )
    {
        free(pszTemp);
        throw;
    }

    free(pszTemp);
    pszTemp = NULL;

	if(  wcsstr( pwcTmp, bstrtOriginalName ) )
	{
		PWCHAR pwcTest = pwcTmp + bstrtOriginalName.length () ;
		if ( *pwcTest == '\0' || *pwcTest == '\\' )
		{
			return File_STATUS_INVALID_NAME ;
		}
	}

	DWORD dwAttrib ;

#ifdef NTONLY
	{
		dwAttrib = GetFileAttributesW(bstrtOriginalName)  ;
	}
#endif

	if( dwAttrib == 0xFFFFFFFF )
	{
		return GetStatusCode() ;
	}

	//copy the parent dir/file only if it satisfies start file-name condition
	bool bDoIt = false ;
	if ( !InputParams.bstrtStartFileName )
	{
		bDoIt = true ;
	}
	else
	{
		if ( bstrtOriginalName == InputParams.bstrtStartFileName )
		{
			bDoIt = true ;
		}
	}

	if ( bDoIt )
	{

		BOOL bCancel = FALSE ;

		//check if it's a file to be copied
		if( !( dwAttrib & FILE_ATTRIBUTE_DIRECTORY ) )
		{

#ifdef NTONLY
			{

				bRet = ::CopyFileW(	bstrtOriginalName,		// pointer to name of an existing file
									bstrtNewFileName,         // pointer to filename to copy to
									TRUE);

			}
#endif

			if( !bRet )
			{
				dwStatus = GetStatusCode() ;
				InputParams.bstrtErrorFileName = bstrtOriginalName ;
			}

			return dwStatus ;
		}


	// If we r here , we've to copy dir .CHek about SD's
#ifdef NTONLY
		{

			bRet = CreateDirectoryExW(	bstrtOriginalName,		// pointer to path string of template directory
										bstrtNewFileName,			// pointer to path string of directory to create
										NULL					// pointer to security descriptor
										) ;
		}
#endif
		if(!bRet)
		{
			InputParams.bstrtErrorFileName = bstrtOriginalName ;
			return GetStatusCode() ;
		}
	}

	//now copy from original dir to new dir...
	InputParams.SetValues ( bstrtOriginalName, 0, NULL, false, InputParams.bRecursive, ENUM_METHOD_COPY ) ;
	if ( bDoIt )
	{
		InputParams.bOccursAfterStartFile = true ;
	}
	InputParams.bstrtMirror = bstrtNewFileName ;
	dwStatus = DoOperationOnFileOrDir(bstrtOriginalName, InputParams) ;

	return dwStatus ;
}




DWORD CCIMLogicalFile::CopyFile(_bstr_t bstrtOriginalFile, DWORD dwFileAttributes, bstr_t bstrtMirror, bstr_t bstrtParentDir, CInputParams& InputParams )
{
	_bstr_t wstrTemp ;
    WCHAR* pwc = NULL;
	bool bRet ;

	WCHAR pszOriginalName[_MAX_PATH] ;
    HRESULT copyResult = StringCchCopyW(pszOriginalName, _MAX_PATH, bstrtOriginalFile) ;
    if (FAILED(copyResult)) return File_STATUS_INVALID_PARAMETER;		
    

	wstrTemp = bstrtMirror ;

	//remove parent dir name
	pwc = wcsstr(pszOriginalName, bstrtParentDir ) ;
	if(pwc == NULL)
	{
		//set the file-name at which error occured
		InputParams.bstrtErrorFileName = bstrtOriginalFile ;
		return File_STATUS_INVALID_NAME ;
	}

	pwc = pwc + wcslen( bstrtParentDir ) ;
	if(pwc == NULL)
	{
		//set the file-name at which error occured
		InputParams.bstrtErrorFileName = bstrtOriginalFile ;
		return File_STATUS_INVALID_NAME ;
	}

	wstrTemp += pwc ;

	//create new dir if it's a dir
	if(dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
	{

		//chek out SD
#ifdef NTONLY
		{
			bRet =  CreateDirectoryExW(	bstrtOriginalFile,		// pointer to path string of template directory
										wstrTemp,			// pointer to path string of directory to create
										NULL					// pointer to security descriptor
										) ;
		}
#endif

	}
	else //copy the file
	{

		BOOL bCancel = FALSE ;

#ifdef NTONLY
		{
			bRet = ::CopyFileW(	bstrtOriginalFile,		// pointer to name of an existing file
								wstrTemp,         // pointer to filename to copy to
								TRUE);
		}
#endif


	}

	if(!bRet)
	{
		//set the file-name at which error occured
		InputParams.bstrtErrorFileName = bstrtOriginalFile ;
		return GetStatusCode() ;
	}
	else
	{
		return STATUS_SUCCESS ;
	}
}


HRESULT CCIMLogicalFile::CheckRenameFileOrDir(

	const CInstance& rInstance ,
	CInstance *pInParams ,
	CInstance *pOutParams ,
	DWORD &dwStatus
)
{
	HRESULT hr = S_OK ;

	bool bExists ;
	VARTYPE eType ;

	WCHAR * pszNewFileName  = NULL;

	if ( pInParams->GetStatus( METHOD_ARG_NAME_NEWFILENAME , bExists , eType ) )
	{
		if ( bExists && ( eType == VT_BSTR ) )
		{
			if ( pInParams->GetWCHAR( METHOD_ARG_NAME_NEWFILENAME, &pszNewFileName) && pszNewFileName != NULL )
			{
			}
			else
			{
				// Zero Length string
				dwStatus = File_STATUS_INVALID_PARAMETER ;
				return hr ;
			}
		}
		else if(bExists)
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
			return hr ;
		}
		else
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
			return hr ;
		}
	}
	else
	{
		dwStatus = File_STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

    try
    {
	    if ( dwStatus == STATUS_SUCCESS )
	    {
		    dwStatus = RenameFileOrDir(rInstance, pszNewFileName) ;
	    }
    }
    catch ( ... )
    {
        if (pszNewFileName)
        {
            free(pszNewFileName);
            pszNewFileName = NULL;
        }
        throw;
    }

    if (pszNewFileName)
    {
        free(pszNewFileName);
        pszNewFileName = NULL;
    }

	return hr ;
}


DWORD CCIMLogicalFile::RenameFileOrDir(const CInstance &rInstance, WCHAR* pszNewFileName )
{

	WCHAR pszOriginalName[_MAX_PATH] ;
	WCHAR *pszTemp = NULL ;
	ZeroMemory((PVOID) pszOriginalName, sizeof(pszOriginalName) ) ;
	DWORD dwStatus = STATUS_SUCCESS ;
	WCHAR *pwDrive1 = NULL , *pwDrive2 = NULL ;

	// a very crude way to check for a fully qualified path(?)
	WCHAR* pwcColon = L":" ;

	if( *(pszNewFileName + 1) != *pwcColon )
	{
		return File_STATUS_INVALID_NAME ;
	}



	rInstance.GetWCHAR(IDS_Name,&pszTemp) ;

	if(pszTemp)
	{
		HRESULT copyStatus = StringCchCopyW(pszOriginalName,_MAX_PATH, pszTemp);
		free(pszTemp) ;
		if (FAILED(copyStatus)) return File_STATUS_INVALID_NAME;
	}

#ifdef NTONLY
	{
    	bool bRet ;
		bRet = MoveFileExW(	pszOriginalName,	// pointer to the name of the existing file
							pszNewFileName,		// pointer to the new name for the file
							0	)	;			// flag that specifies how to move file

		if(!bRet)
		{
			dwStatus = GetStatusCode() ;
		}
	}
#endif
	return dwStatus ;


}

HRESULT CCIMLogicalFile::CheckEffectivePermFileOrDir(const CInstance& rInstance,
	                                                 CInstance *pInParams,
	                                                 CInstance *pOutParams,
	                                                 bool& fHasPerm)
{
	HRESULT hr = S_OK;

#ifdef NTONLY
	bool bExists ;
	VARTYPE eType ;
	DWORD dwPermToCheck = 0L;

	if(pInParams->GetStatus(METHOD_ARG_NAME_PERMISSION, bExists, eType))
	{
		if(bExists && (eType == VT_I4))
		{
			if(!pInParams->GetDWORD(METHOD_ARG_NAME_PERMISSION, dwPermToCheck))
			{
				// Invalid arguement
				fHasPerm = false;
			}
		}
		else
		{
			fHasPerm = false;
			hr = WBEM_E_INVALID_PARAMETER;
		}
	}
	else
	{
		fHasPerm = false;;
		hr = WBEM_E_PROVIDER_FAILURE;
	}

	if(SUCCEEDED(hr))
	{
		DWORD dwRes = EffectivePermFileOrDir(rInstance, dwPermToCheck);
        if(dwRes == ERROR_SUCCESS)
        {
            fHasPerm = true;
        }
        else if(dwRes == ERROR_PRIVILEGE_NOT_HELD)  // This is the only error case we want to explicitly return
        {                                           // other than S_OK for, as one might invalidly assume that the right didn't exist just because the privilege wasn't enabled.
            SetSinglePrivilegeStatusObject(rInstance.GetMethodContext(), SE_SECURITY_NAME);
            fHasPerm = false;
            hr = WBEM_E_PRIVILEGE_NOT_HELD;
        }
	}
#endif
	return hr ;
}


DWORD CCIMLogicalFile::EffectivePermFileOrDir(const CInstance &rInstance, const DWORD dwPermToCheck)
{
    DWORD dwRet = -1L;

#ifdef NTONLY
    // All we need to do is call NtOpenFile with the specified permissions.  Must be careful
    // to not open the file/dir for exclusive access.  If we can open it with the requested
    // access, return true.

    // First, get the file/dir name...
    WCHAR wstrFileName[_MAX_PATH + 8];
    ZeroMemory(wstrFileName, sizeof(wstrFileName));
    WCHAR* wstrTemp = NULL;

    rInstance.GetWCHAR(IDS_Name,&wstrTemp);

	if(wstrTemp != NULL)
	{
		wcscpy(wstrFileName, L"\\??\\");
        wcsncat(wstrFileName, wstrTemp, _MAX_PATH - 1);
		free(wstrTemp);
	}

    CNtDllApi *pNtDllApi = NULL;
    pNtDllApi = (CNtDllApi*) CResourceManager::sm_TheResourceManager.GetResource(g_guidNtDllApi, NULL);
    if(pNtDllApi != NULL)
    {
        HANDLE hFileHandle = 0L;
        UNICODE_STRING ustrNtFileName = { 0 };
        OBJECT_ATTRIBUTES oaAttributes;
        IO_STATUS_BLOCK IoStatusBlock;

        if(NT_SUCCESS(pNtDllApi->RtlInitUnicodeString(&ustrNtFileName, wstrFileName)) && ustrNtFileName.Buffer)
        {
            InitializeObjectAttributes(&oaAttributes,
					                   &ustrNtFileName,
					                   OBJ_CASE_INSENSITIVE,
					                   NULL,
					                   NULL);

            // We must have the security privilege enabled in order to access the object's SACL, which in
            // some cases is exactly what we are testing for (e.g., the ACCESS_SYSTEM_SECURITY right).
            CTokenPrivilege	securityPrivilege( SE_SECURITY_NAME );
            bool fDisablePrivilege = false;

            if(dwPermToCheck & ACCESS_SYSTEM_SECURITY)
            {
                fDisablePrivilege = ( securityPrivilege.Enable() == ERROR_SUCCESS );
            }

            NTSTATUS ntstat = -1L;
            ntstat = pNtDllApi->NtOpenFile(&hFileHandle,
                                           dwPermToCheck,
                                           &oaAttributes,
                                           &IoStatusBlock,
                                           FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                           0);
            if(NT_SUCCESS(ntstat))
            {
                dwRet = ERROR_SUCCESS;
                pNtDllApi->NtClose(hFileHandle);
                hFileHandle = 0L;
            }
            else if( STATUS_PRIVILEGE_NOT_HELD == ntstat )
            {
                dwRet = ERROR_PRIVILEGE_NOT_HELD;
            }

            if(fDisablePrivilege)
            {
                securityPrivilege.Enable(FALSE);
            }
        }

        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidNtDllApi, pNtDllApi);
        pNtDllApi = NULL;
    }

#endif

    return dwRet;
}





DWORD CCIMLogicalFile::GetStatusCode()
{
	DWORD t_Error = GetLastError() ;
#ifdef DBG
	TCHAR buf[255];
	wsprintf(buf, _T("%d"), t_Error) ;
	OutputDebugString(buf) ;
#endif	
	return MapWinErrorToStatusCode(t_Error) ;

}


DWORD CCIMLogicalFile::MapWinErrorToStatusCode(DWORD dwWinError)
{

	DWORD t_Result ;

	switch ( dwWinError )
	{
		case ERROR_SUCCESS:
			{
				t_Result = STATUS_SUCCESS ;
			}
			break;


		case ERROR_ACCESS_DENIED:
			{
				t_Result = File_STATUS_ACCESS_DENIED ;
			}
			break ;

		case ERROR_DIR_NOT_EMPTY:
			{
				t_Result = File_STATUS_DIR_NOT_EMPTY ;
			}
			break ;


		case ERROR_NOT_SAME_DEVICE:
			{
				t_Result = File_STATUS_NOT_SAME_DRIVE ;
			}
			break ;


		case ERROR_ALREADY_EXISTS:
		case ERROR_FILE_EXISTS:
			{
				t_Result = File_STATUS_ALREADY_EXISTS ;
			}
			break ;

		case ERROR_PATH_NOT_FOUND:
		case ERROR_FILE_NOT_FOUND:
			{
				t_Result = File_STATUS_INVALID_NAME ;
			}
			break ;

		case ERROR_SHARING_VIOLATION:
			{
				t_Result = File_STATUS_SHARE_VIOLATION ;
			}
		break ;

		default:
			{
				t_Result = File_STATUS_UNKNOWN_FAILURE ;
			}
			break ;
	}

	return t_Result ;
}

HRESULT CCIMLogicalFile::MapStatusCodestoWbemCodes(DWORD dwStatus)
{
	HRESULT hr = E_FAIL ;

	switch(dwStatus)
	{
		case File_STATUS_ACCESS_DENIED:
			{
				hr = WBEM_E_ACCESS_DENIED ;
			}
			break ;

		case File_STATUS_INVALID_NAME:
			{
				hr = WBEM_E_NOT_FOUND ;
			}
			break ;

		default:
			{
				hr = WBEM_E_FAILED ;
			}
			break ;
	}

	return hr ;
}


DWORD CCIMLogicalFile::DoTheRequiredOperation ( bstr_t bstrtFileName, DWORD dwAttrib, CInputParams& InputParams )
{
	DWORD dwStatus = STATUS_SUCCESS ;
	//check if the this file occurs after the file from which operation has to be started
	if ( !InputParams.bOccursAfterStartFile )
	{
		if ( bstrtFileName == InputParams.bstrtStartFileName )
		{
			InputParams.bOccursAfterStartFile = true ;
		}
	}

	//now do the operation, only if the file occurs after the start file
	if ( InputParams.bOccursAfterStartFile )
	{
		switch ( InputParams.eOperation )
		{
		case ENUM_METHOD_DELETE:
			{
				dwStatus = Delete ( bstrtFileName, dwAttrib, InputParams ) ;
				break ;
			}

		case ENUM_METHOD_COMPRESS:
			{
				dwStatus = Compress ( bstrtFileName, dwAttrib, InputParams ) ;
				break ;
			}
		case ENUM_METHOD_UNCOMPRESS:
			{
				dwStatus = Uncompress ( bstrtFileName, dwAttrib, InputParams ) ;
				break;
			}

		case ENUM_METHOD_TAKEOWNERSHIP:
			{
				dwStatus = TakeOwnership ( bstrtFileName, InputParams ) ;
				break ;
			}

		case ENUM_METHOD_COPY:
			{
				dwStatus = CopyFile( bstrtFileName, dwAttrib, InputParams.bstrtMirror, InputParams.bstrtFileName, InputParams ) ;
				break ;
			}

		case ENUM_METHOD_CHANGE_PERM:
			{
				dwStatus = ChangePermissions( bstrtFileName, InputParams.dwOption, InputParams.pSD, InputParams ) ;
				break ;
			}
		}
	}

	return dwStatus ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\filefile.h ===
//=================================================================

//

// FileFile.h

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/09/98    a-kevhu         Created
//
// Comment: Parent class for disk/dir, dir/dir, and dir/file association classes.
//
//=================================================================

// Property set identification
//============================

#ifndef _FILEFILE_H_
#define _FILEFILE_H_

class CFileFile;

class CFileFile : public Provider 
{
    public:
        // Constructor/destructor
        //=======================
        CFileFile(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CFileFile() ;

    protected:
        HRESULT QueryForSubItemsAndCommit(CHString& chstrGroupComponentPATH,
                                          CHString& chstrQuery,
                                          MethodContext* pMethodContext);

        HRESULT GetSingleSubItemAndCommit(CHString& chstrGroupComponentPATH,
                                          CHString& chstrSubItemPATH,
                                          MethodContext* pMethodContext);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\environment.h ===
//=================================================================

//

// Environment.h -- Environment property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//				 10/24/97    a-hhance       ported to new paradigm
//				  1/11/98    a-hhance       ported to V2
//				  1/20/98	 a-brads        Added DeleteInstance
//											Added PutInstance
//
//=================================================================

// Property set identification
//============================

#define  PROPSET_NAME_ENVIRONMENT L"Win32_Environment" 
//#define  PROPSET_UUID_ENVIRONMENT "{7D0E0480-FEEE-11d0-9E3B-0000E80D7352}"

class Environment : public Provider 
{
	public: 

        // Constructor/destructor
        //=======================
        Environment(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~Environment() ;

        // Functions provide properties with current values
        //=================================================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT PutInstance(const CInstance& pInstance, long lFlags = 0L);
		virtual HRESULT DeleteInstance(const CInstance& pInstance, long lFlags = 0L);

	protected:
        // Utility function(s)
        //====================
        HRESULT CreateEnvInstances(MethodContext*  pMethodContext,
								 LPCWSTR pszUserName, 
                                 HKEY hRootKey, 
                                 LPCWSTR pszEnvKeyName,
								 bool bItSystemVar) ;

#ifdef NTONLY
        HRESULT RefreshInstanceNT(CInstance* pInstance) ;
        HRESULT AddDynamicInstancesNT(MethodContext*  pMethodContext) ;
#endif
		void GenerateCaption(LPCWSTR pUserName, LPCWSTR pVariableName, CHString& caption);
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\file.h ===
//=================================================================

//

// File.h -- File property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/02/98    a-kevhu         Created
//
//=================================================================

#ifndef _FILE_H
#define _FILE_H 

//NOTE: The implementations of EnumerateInstances, GetObject & the pure virtual declaration of IsOneOfMe  method 
//		is now present in the derived CImplement_LogicalFile class. Cim_LogicalFile is now instantiable & has only 
//		generic method implementations.
#define  PROPSET_NAME_FILE L"CIM_LogicalFile"

class CInputParams ; 

class CCIMLogicalFile : public Provider 
{
    public:

        // Constructor/destructor
        //=======================

        CCIMLogicalFile(LPCWSTR name, LPCWSTR pszNamespace);
       ~CCIMLogicalFile() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return WBEM_E_NOT_AVAILABLE ; }
        virtual HRESULT EnumerateInstances(MethodContext* pMethodContext, 
                                           long lFlags = 0L) 
		{ return WBEM_E_NOT_AVAILABLE ; }
        
		virtual HRESULT ExecQuery(MethodContext* pMethodContext, 
                                  CFrameworkQuery& pQuery, 
                                  long lFlags = 0L)
		{ return WBEM_E_NOT_AVAILABLE ; }
		
		virtual HRESULT ExecMethod (const CInstance& rInstance, const BSTR bstrMethodName ,CInstance *pInParams ,CInstance *pOutParams ,long lFlags ) ;
    
	protected:
		
		virtual HRESULT DeleteInstance(const CInstance& newInstance, long lFlags = 0L);

	private:

		HRESULT ExecDelete(const CInstance& rInstance, CInstance *pInParams, CInstance *pOutParams, long lFlags, bool bExtendedMethod ) ;		
		HRESULT ExecCompress (const CInstance& rInstance, CInstance *pInParams, CInstance *pOutParams, long lFlags, bool bExtendedMethod ) ;
		HRESULT ExecUncompress (const CInstance& rInstance, CInstance *pInParams, CInstance *pOutParams, long lFlags, bool bExtendedMethod ) ;
		HRESULT ExecTakeOwnership(const CInstance &rInstance, CInstance *pInParams, CInstance *pOutParams, long lFlags, bool bExtendedMethod );
		HRESULT ExecChangePermissions(const CInstance& rInstance, CInstance *pInParams, CInstance *pOutParams, long lFlags, bool bExtendedMethod ) ;
		HRESULT ExecCopy(const CInstance &rInstance, CInstance *pInParams, CInstance *pOutParams, long lFlags, bool bExtendedMethod ) ;
		HRESULT ExecRename(const CInstance &rInstance, CInstance *pInParams, CInstance *pOutParams, long lFlags) ;
        HRESULT ExecEffectivePerm(const CInstance &rInstance, CInstance *pInParams, CInstance *pOutParams, long lFlags);
		
		// support functions for checking permission
        HRESULT CheckEffectivePermFileOrDir(const CInstance& rInstance, CInstance *pInParams, CInstance* pOutParams, bool& fHasPerm);
		DWORD EffectivePermFileOrDir(const CInstance& rInstance, const DWORD dwPermToCheck);
        
        //fns to change permissions on file/dir
		HRESULT CheckChangePermissionsOnFileOrDir(const CInstance& rInstance ,CInstance *pInParams ,CInstance *pOutParams ,DWORD &dwStatus, bool bExtendedMethod, CInputParams& InputParams ) ;
 
		//fns. for copying file/dir
		HRESULT CheckCopyFileOrDir( const CInstance& rInstance ,CInstance *pInParams ,CInstance *pOutParams ,DWORD &dwStatus,	bool bExtendedMethod, CInputParams& InputParams ) ;
		DWORD CopyFileOrDir(const CInstance &rInstance, _bstr_t bstrtNewFileName, CInputParams& InputParams );
		

		//fns for renaming file/dir
		HRESULT CheckRenameFileOrDir( const CInstance& rInstance ,CInstance *pInParams ,CInstance *pOutParams ,DWORD &dwStatus );
		DWORD RenameFileOrDir(const CInstance &rInstance, WCHAR* pszNewFileName);
		
		DWORD DoTheRequiredOperation ( bstr_t bstrtFileName, DWORD dwAttrib, CInputParams& InputParams );		

		//wrappers over win32 API
		DWORD Delete(_bstr_t bstrtFileName, DWORD dwAttributes, CInputParams& InputParams );
		DWORD Compress (_bstr_t bstrtFileName, DWORD dwAttributes, CInputParams& InputParams );
		DWORD Uncompress (_bstr_t bstrtFileName, DWORD dwAttributes, CInputParams& InputParams );
		DWORD TakeOwnership( _bstr_t bstrtFileName, CInputParams& InputParams ) ;
		DWORD ChangePermissions(_bstr_t bstrtFileName, DWORD dwOption, PSECURITY_DESCRIPTOR pSD, CInputParams& InputParams );
		DWORD CopyFile(_bstr_t bstrtOriginalFile, DWORD dwFileAttributes, bstr_t bstrtMirror, bstr_t bstrtParentDir, CInputParams& InputParams );

		//helper fns.
		DWORD DoOperationOnFileOrDir(WCHAR *pwcName, CInputParams& InParams );
#ifdef NTONLY
		DWORD EnumAllPathsNT(const WCHAR *pszDrive, const WCHAR *pszPath, CInputParams& InParams );
#endif
		//fn to map win32 error to status code
		DWORD GetStatusCode();    
		DWORD MapWinErrorToStatusCode(DWORD dwWinError);
		HRESULT MapStatusCodestoWbemCodes(DWORD dwStatus);
		friend class CInputParams ;

	private:
		enum OperationName  
		{
			ENUM_METHOD_DELETE = 0		,
			ENUM_METHOD_COMPRESS		,
			ENUM_METHOD_TAKEOWNERSHIP	,
			ENUM_METHOD_COPY			,
			ENUM_METHOD_CHANGE_PERM		,
			ENUM_METHOD_UNCOMPRESS
		} ;

};


class CInputParams
{
public:
	
    CInputParams::CInputParams ():
		dwOption ( 0 ),
		pSD ( NULL ),
		bDoDepthFirst ( false ),
		bOccursAfterStartFile ( false ),
		pContext( NULL ),  
		bRecursive ( false )
		{
		}
	
	void SetValues 
	( 
		bstr_t bstrtFile,	
		DWORD dwInOption,
		PSECURITY_DESCRIPTOR pSecDesc,
		bool bDepthFirst,
		bool bRecursiveArg,
		CCIMLogicalFile::OperationName eOperationName,
        MethodContext* pMethodContext = NULL
	)
	{
		bstrtFileName = bstrtFile ;
		dwOption = dwInOption ;
		pSD = pSecDesc ;
		bDoDepthFirst = bDepthFirst ;
		bRecursive = bRecursiveArg ;
		eOperation = eOperationName ;
        pContext = pMethodContext ;

		//check if we're given a start file to start the operation from
		if ( !bstrtStartFileName )
		{
			bOccursAfterStartFile = true ;
		}
		else
		{
			bOccursAfterStartFile = false ;
		}
	}
	
	~CInputParams () {};

	//member variables
public:
	bstr_t bstrtFileName ;		//File or Dir. Name on which operation is to be performed
	bstr_t bstrtStartFileName ;	//file to start the operation from
	bstr_t bstrtErrorFileName ;  //file at which error occured while carrying out the operation
	bstr_t bstrtMirror ;		//The Mirror Dir. used for Copy Operation 
	DWORD dwOption ;			//Option for applying Security descriptor
	PSECURITY_DESCRIPTOR pSD ;	
	bool bDoDepthFirst ;		//flag for doing a depthfirst traversal of Dir. hierarchy
	bool bOccursAfterStartFile ;//Flag which checks if the current file occurs after the StartFile
	CCIMLogicalFile::OperationName eOperation ;	//Opertion type
    MethodContext* pContext;   // context for this operation, may be NULL.  
	bool bRecursive ;

}  ;


#endif // _FILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\elementsetting.h ===
//=================================================================

//

// ElementSetting.h

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef __ASSOC_ELEMENTSETTING__
#define __ASSOC_ELEMENTSETTING__

class CWin32AssocElementToSettings : protected Provider
{
    public:

        CWin32AssocElementToSettings(	const CHString&	strName,
										const CHString& strElementClassName,
										const CHString&	strElementBindingPropertyName,
										const CHString& strSettingClassName,
										const CHString& strSettingBindingPropertyName,
										LPCWSTR			pszNamespace = NULL );

       ~CWin32AssocElementToSettings() ;

		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
	   
	protected:

		CHString	m_strElementClassName;
		CHString	m_strElementBindingPropertyName;
        CHString	m_strSettingClassName;
		CHString	m_strSettingBindingPropertyName;

		virtual HRESULT EnumSettingsForElement( CInstance* pElement, TRefPointerCollection<CInstance>& settingsList, MethodContext* pMethodContext );
		virtual BOOL AreAssociated( CInstance* pElement, CInstance* pSetting );

} ;

class CWin32AssocSystemToSettings : public CWin32AssocElementToSettings
{
    public:

        CWin32AssocSystemToSettings(	const CHString&	strName,
										const CHString&	strSettingClassName,
										LPCWSTR			pszNamespace = NULL );

       ~CWin32AssocSystemToSettings() ;
    
} ;

class CWin32AssocDeviceToSettings : public CWin32AssocElementToSettings
{
    public:

        CWin32AssocDeviceToSettings(	const CHString&	strName,
										const CHString& strDeviceClassName,
										const CHString&	strDeviceBindingPropertyName,
										const CHString& strSettingClassName,
										const CHString& strSettingBindingPropertyName,
										LPCWSTR		pszNamespace = NULL );

       ~CWin32AssocDeviceToSettings() ;

};

class CWin32AssocUserToDesktop : public CWin32AssocElementToSettings
{
	public:	
		CWin32AssocUserToDesktop(void);

	protected:
		virtual HRESULT EnumSettingsForElement(CInstance* pElement,
												TRefPointerCollection<CInstance>&	settingsList,
												MethodContext*	pMethodContext );


		virtual BOOL	AreAssociated( CInstance* pElement, CInstance* pSetting );
		virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\filefile.cpp ===
//=================================================================

//

// FileFile.cpp

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/26/98    a-kevhu         Created
//
// Comment: Parent class for disk/dir, dir/dir, and dir/file association classes.
//
//=================================================================

#include "precomp.h"

#include "FileFile.h"


/*****************************************************************************
 *
 *  FUNCTION    : CFileFile::CFileFile
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CFileFile::CFileFile(LPCWSTR setName, LPCWSTR pszNamespace)
:Provider(setName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CFileFile::~CFileFile
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CFileFile::~CFileFile()
{
}


/*****************************************************************************
 *
 *  FUNCTION    : CFileFile::QueryForSubItemsAndCommit
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Runs a query to obtain a list of dependent items, creates
 *                the associations with the antecedent, and commits the
 *                association instances.
 *
 *****************************************************************************/

HRESULT CFileFile::QueryForSubItemsAndCommit(CHString& chstrGroupComponentPATH,
                                                 CHString& chstrQuery,
                                                 MethodContext* pMethodContext)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    TRefPointerCollection<CInstance> LList;
    if(SUCCEEDED(CWbemProviderGlue::GetInstancesByQuery(chstrQuery,
                                                        &LList,
                                                        pMethodContext,
                                                        IDS_CimWin32Namespace)))
    {
        REFPTRCOLLECTION_POSITION pos;
        CInstancePtr pinstListElement;
        if(LList.BeginEnum(pos))
        {
            CHString chstrPartComponentPATH;
            for (pinstListElement.Attach(LList.GetNext(pos)) ;
                (SUCCEEDED(hr)) && (pinstListElement != NULL) ;
                pinstListElement.Attach(LList.GetNext(pos)) )
            {
                if(pinstListElement != NULL)
                {
                    CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                    if(pInstance != NULL)
                    {
                        pinstListElement->GetCHString(IDS___Path, chstrPartComponentPATH); // goes back as 'Dependent'
                        pInstance->SetCHString(IDS_PartComponent, chstrPartComponentPATH);
                        pInstance->SetCHString(IDS_GroupComponent, chstrGroupComponentPATH);
                        hr = pInstance->Commit();
                    }
                    else
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }
                } // if pinstListElement not NULL
            } // while list elements to enumerate
            LList.EndEnum();
        } // beginenum of list worked
    } // the query
    return(hr);
}

/*****************************************************************************
 *
 *  FUNCTION    : CFileFile::GetSingleSubItemAndCommit
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Obtains the dependent item, creates
 *                the association with the antecedent, and commits the
 *                association instance.
 *
 *****************************************************************************/
HRESULT CFileFile::GetSingleSubItemAndCommit(CHString& chstrGroupComponentPATH,
                                          CHString& chstrSubItemPATH,
                                          MethodContext* pMethodContext)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CInstancePtr pinstRootDir;
    if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrSubItemPATH, &pinstRootDir, pMethodContext)))
    {
        CHString chstrPartComponentPATH;
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        if(pInstance != NULL)
        {
            pInstance->SetCHString(IDS_PartComponent, chstrSubItemPATH);
            pInstance->SetCHString(IDS_GroupComponent, chstrGroupComponentPATH);
            hr = pInstance->Commit();
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\environment.cpp ===
//=================================================================

//

// Environment.CPP --Environment property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//				 10/24/97    a-hhance       ported to new paradigm
//				  1/11/98    a-hhance       ported to V2
//				1/20/98		a-brads			worked on GetObject
//
//=================================================================

#include "precomp.h"
#include "UserHive.h"

#include "Environment.h"
#include "desktop.h"
#include "sid.h"
#include "implogonuser.h"
#include <tchar.h>

// Property set declaration
//=========================

Environment MyEnvironmentSet(PROPSET_NAME_ENVIRONMENT, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : Environment::Environment
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

Environment::Environment(LPCWSTR name, LPCWSTR pszNamespace)
: Provider(name, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Environment::~Environment
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

Environment::~Environment()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Environment::GetObject(CInstance* pInstance)
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Environment::GetObject(CInstance* pInstance, long lFlags /*= 0L*/)
{
	HRESULT	hr;

#ifdef NTONLY
						hr = RefreshInstanceNT(pInstance);
#endif
	return hr;
}

#ifdef NTONLY
HRESULT Environment::RefreshInstanceNT(CInstance* pInstance)
{
	BOOL			bRetCode = FALSE;
	DWORD			dwRet;
	HRESULT		hRetCode;
	CRegistry	RegInfo;
	CUserHive	UserHive;
	TCHAR			szKeyName[_MAX_PATH];
	BOOL			bHiveLoaded = FALSE;
	CHString		sTemp;
	CHString		userName;

	pInstance->GetCHString(IDS_UserName, userName);
	try
	{
		// Load the user hive & retrieve the value
		if(!_tcsicmp(userName.GetBuffer(0), IDS_SystemUser))
		{
			dwRet = RegInfo.Open(HKEY_LOCAL_MACHINE,
						IDS_RegEnvironmentNT,
						KEY_READ) ;

			pInstance->Setbool(IDS_SystemVariable, true);
		}
		else
		{
			dwRet = UserHive.Load(userName.GetBuffer(0),
						szKeyName, _MAX_PATH) ;

			if (dwRet == ERROR_SUCCESS)
			{
        		bHiveLoaded = TRUE ;
				TCHAR			szKeyName2[_MAX_PATH];
				_tcscpy(szKeyName2, szKeyName);

				_tcscat(szKeyName2, IDS_RegEnvironmentKey) ;
				hRetCode = RegInfo.Open(HKEY_USERS, szKeyName2, KEY_READ) ;
				pInstance->Setbool(IDS_SystemVariable, false);
			}
		}

		// looks healthy to me...
		pInstance->SetCharSplat(IDS_Status, IDS_CfgMgrDeviceStatus_OK);

		if (dwRet == ERROR_SUCCESS)
		{

			CHString name;
			pInstance->GetCHString(IDS_Name, name);
			dwRet = RegInfo.GetCurrentKeyValue(name.GetBuffer(0), sTemp) ;
			pInstance->SetCHString(IDS_VariableValue, sTemp);

			CHString foo;
			GenerateCaption(userName, name, foo);
			pInstance->SetCHString(IDS_Description, foo);
			pInstance->SetCHString(IDS_Caption, foo);

			RegInfo.Close() ;
		}

	}
	catch ( ... )
	{
		if ( bHiveLoaded )
		{
			bHiveLoaded = false ;
			UserHive.Unload(szKeyName);
		}

		throw ;
	}

	if (bHiveLoaded)
	{
		bHiveLoaded = false ;
		UserHive.Unload(szKeyName);
	}
	return WinErrorToWBEMhResult(dwRet);
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : Environment::EnumerateInstances
 *
 *  DESCRIPTION : Creates property set instances
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT Environment::EnumerateInstances(MethodContext*  pMethodContext, long lFlags /*= 0L*/)
{
#ifdef NTONLY
		return AddDynamicInstancesNT(pMethodContext);
#endif
}

/*
 ** Environment::AddDynamicInstancesNT
 *
 *  FILENAME: D:\PandoraNG\Win32Provider\providers\Environment\environment.cpp
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */
#ifdef NTONLY
HRESULT Environment::AddDynamicInstancesNT(MethodContext*  pMethodContext)
{
	HRESULT	hResult = WBEM_S_NO_ERROR;
    CUserHive UserHive ;
    TCHAR szUserName[_MAX_PATH], szKeyName[_MAX_PATH] , szKeyName2[_MAX_PATH] ;
    CHString userName;

    // Instance system environment vars first
    //=======================================

//    hr = CreateEnvInstances(pMethodContext, "<SYSTEM>", HKEY_LOCAL_MACHINE,
//                                          "System\\CurrentControlSet\\Control\\Session Manager\\Environment", true) ;

    hResult = CreateEnvInstances(pMethodContext, IDS_SystemUser, HKEY_LOCAL_MACHINE,
                                          IDS_RegEnvironmentNT, true) ;

    // Create instances for each user
    //===============================

    // logic: if they don't have a desktop, they're not likely to have any environment vars . . .
	// find Win32_Desktops...
	TRefPointerCollection<CInstance> users;

	if ((SUCCEEDED(hResult)) &&
//		(SUCCEEDED(hResult = CWbemProviderGlue::GetAllInstances(
//			PROPSET_NAME_DESKTOP, &users, IDS_CimWin32Namespace,
//			pMethodContext))))
		(SUCCEEDED(hResult = CWbemProviderGlue::GetInstancesByQuery(L"SELECT Name FROM Win32_Desktop",
                                                                    &users, pMethodContext, GetNamespace()))))
	{

		REFPTRCOLLECTION_POSITION pos;
		CInstancePtr pUser;

		if (users.BeginEnum(pos))
		{
			// GetNext() will AddRef() the pointer, so make sure we Release()
			// it when we are done with it.

			for (	pUser.Attach ( users.GetNext( pos ) ) ;
					(SUCCEEDED(hResult)) && (pUser != NULL) ;
					pUser.Attach ( users.GetNext( pos ) )
                )
			{
				// Look up the user's account info
				//================================

				pUser->GetCHString(IDS_Name, userName) ;

				_tcscpy(szUserName, userName) ;

                // Most names are of the form domain\user.  However, there are also two entries for 'default' and 'all users'.
                // This code will skip those users.
				if (_tcschr(szUserName, _T('\\')) != NULL)
                {
                    if (UserHive.Load(szUserName, szKeyName, _MAX_PATH) == ERROR_SUCCESS)
                    {
						bool bHiveLoaded = true ;
						try
						{
							// Instance user's variables
							//==========================

			//				strcat(szKeyName, "\\Environment") ;
							_tcscpy(szKeyName2, szKeyName);
							_tcscat(szKeyName, IDS_RegEnvironmentKey) ;
							hResult = CreateEnvInstances(pMethodContext, szUserName, HKEY_USERS, szKeyName, false) ;

						}
						catch ( ... )
						{
							if ( bHiveLoaded )
							{
								bHiveLoaded = false ;
								UserHive.Unload(szKeyName2) ;
							}

							throw ;
						}

						if ( bHiveLoaded )
						{
							bHiveLoaded = false ;
							UserHive.Unload(szKeyName2) ;
						}
                    }

				}

                // While this seems like a good idea, it doesn't appear that the os really USES this key.  I tried adding
                // variables and changing variables, then created a new user and logged in.  I didn't get the new or changed vars.
//                else
//                {
//                    if (_tcsicmp(szUserName, _T(".Default")) == 0)
//                    {
//				        hResult = CreateEnvInstances(pMethodContext, szUserName, HKEY_USERS, _T(".DEFAULT\\Environment"), false) ;
//                    }
//                }

			}

			users.EndEnum();
		}
	}

    return hResult;
}
#endif

/*
 ** Environment::CreateEnvInstances
 *
 *  FILENAME: D:\PandoraNG\Win32Provider\providers\Environment\environment.cpp
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */
HRESULT Environment::CreateEnvInstances(MethodContext*  pMethodContext,
										LPCWSTR pszUserName,
                                        HKEY hRootKey,
                                        LPCWSTR pszEnvKeyName,
										bool bItSystemVar)
{
	HKEY	hKey;
	LONG	lRetCode;
	DWORD dwValueIndex,
			dwEnvVarNameSize,
			dwEnvVarValueSize,
			dwType;
	TCHAR	szEnvVarName[1024],
			szEnvVarValue[1024];
	CInstancePtr pInstance;

    HRESULT hr = WBEM_S_NO_ERROR;

	if ((lRetCode = RegOpenKeyEx(hRootKey, TOBSTRT(pszEnvKeyName), 0, KEY_READ, &hKey)) !=
		ERROR_SUCCESS)
		return WinErrorToWBEMhResult(lRetCode);

	for (dwValueIndex = 0; (lRetCode == ERROR_SUCCESS) && (SUCCEEDED(hr)); dwValueIndex++)
	{
		dwEnvVarNameSize  = sizeof(szEnvVarName) / sizeof (TCHAR);
		dwEnvVarValueSize = sizeof(szEnvVarValue) ;
		lRetCode = RegEnumValue(hKey, dwValueIndex, szEnvVarName,
						&dwEnvVarNameSize, NULL, &dwType,
						(BYTE *) szEnvVarValue, &dwEnvVarValueSize);

		if (lRetCode == ERROR_SUCCESS)
        {
		    if (dwType == REG_SZ || dwType == REG_EXPAND_SZ)
		    {
			    pInstance.Attach(CreateNewInstance(pMethodContext));
                if (pInstance != NULL)
                {
			        pInstance->SetCharSplat(IDS_UserName, pszUserName);
			        pInstance->SetCharSplat(IDS_Name, szEnvVarName);
			        pInstance->SetCharSplat(IDS_VariableValue, szEnvVarValue);

			        CHString foo;
			        GenerateCaption(TOBSTRT(pszUserName), TOBSTRT(szEnvVarName), foo);
			        pInstance->SetCHString(IDS_Description, foo);
			        pInstance->SetCHString(IDS_Caption, foo);

			        pInstance->Setbool(IDS_SystemVariable, bItSystemVar);

			        // looks healthy to me...
			        pInstance->SetCharSplat(IDS_Status, IDS_CfgMgrDeviceStatus_OK);

			        hr = pInstance->Commit() ;
                }
                else
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
		    }
        }
	}

	RegCloseKey(hKey);

	return hr;
}

// takes in joeuser and envvar, returns joeuser\envar
void Environment::GenerateCaption(LPCWSTR pUserName, LPCWSTR pVariableName, CHString& caption)
{
	caption = CHString(pUserName) + "\\" +  CHString(pVariableName);
}


/*****************************************************************************
 *
 *  FUNCTION    : Environment::PutInstance
 *
 *  DESCRIPTION : Creates an environment variable on the system
 *
 *  INPUTS      : The instance to put
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : an HRESULT --
 *					WBEM_E_INVALID_PARAMETER - if one of the parameters is wrong or NULL
 *					WBEM_E_FAILED -- if the system wouldn't accept the put
 *					WBEM_E_PROVIDER_NOT_CAPABLE -- if in Win '95
 *					WBEM_S_NO_ERROR - if successful
 *
 *  COMMENTS    : Logic here is way too deep & convoluted TODO! fix.
 *
 *****************************************************************************/
HRESULT Environment::PutInstance(const CInstance &pInstance, long lFlags /*= 0L*/)
{
#ifdef NTONLY
    HRESULT hr = WBEM_E_FAILED;
    CHString EnvironmentVariable;
    CHString VariableValue;
    CHString UserName, sTmpUser;
    TCHAR* szCurrentUserName = NULL;

    HRESULT hRetCode ;
    CRegistry RegInfo ;
    CUserHive UserHive ;
    TCHAR szKeyName[_MAX_PATH] ;
    BOOL bHiveLoaded = FALSE ;
    int iFind;

    pInstance.GetCHString(IDS_Name, EnvironmentVariable);
    pInstance.GetCHString(IDS_VariableValue, VariableValue);
    pInstance.GetCHString(IDS_UserName, UserName);

    // the Username exists on this machine.  We can put the instance variables
    // Load the user hive & retrieve the value
    //========================================
    {
        // we need all the keys
        // but only need a value for CreateOnly
        // jumping out in the middle, since there's too much of a rewrite elsewise...
        if ((EnvironmentVariable.GetLength() == 0) ||
            (UserName.GetLength() == 0)             ||
            ((VariableValue.GetLength() == 0) && (lFlags & WBEM_FLAG_CREATE_ONLY)))
            return WBEM_E_INVALID_PARAMETER;

        //      if(!_strcmpi(UserName.GetBuffer(0), "<SYSTEM>"))
        if(!_tcsicmp(UserName.GetBuffer(0), IDS_SystemUser))
        {
            //            hRetCode = RegInfo.Open(HKEY_LOCAL_MACHINE,
            //             "System\\CurrentControlSet\\Control\\Session Manager\\Environment",
            //               KEY_ALL_ACCESS) ;

            hRetCode = RegInfo.Open(HKEY_LOCAL_MACHINE,
                IDS_RegEnvironmentNT,
                KEY_ALL_ACCESS) ;

            if (ERROR_SUCCESS == hRetCode)
            {
                // Check the flags.  First do we even care?
                if (lFlags & (WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY))
                {
                    // Ok, we care.  Is this var already there?
                    CHString sTemp;
                    hRetCode = RegInfo.GetCurrentKeyValue(EnvironmentVariable, sTemp);

                    // If create only and already there, that's an error, else no error
                    if (lFlags & WBEM_FLAG_CREATE_ONLY)
                    {
                        if (hRetCode == ERROR_SUCCESS)
                        {
                            hr = WBEM_E_ALREADY_EXISTS;
                            hRetCode = ~ERROR_SUCCESS;
                        }
                        else
                        {
                            hRetCode = ERROR_SUCCESS;
                            // If update only (the only other option) and not there, that's an error, else no error
                        }
                    }
                    else if (hRetCode != ERROR_SUCCESS)
                    {
                        hr = WBEM_E_NOT_FOUND;
                        hRetCode = ~ERROR_SUCCESS;
                    }
                    else
                    {
                        hRetCode = ERROR_SUCCESS;
                    }
                }

                // If we're still in business, change the environment variable in the registry
                if (hRetCode == ERROR_SUCCESS) {
                    hRetCode = RegInfo.SetCurrentKeyValue(EnvironmentVariable, VariableValue);

                    if (ERROR_SUCCESS == hRetCode)
                    {
                        // From here, we can say that we've won.
                        hr = WBEM_S_NO_ERROR;
                        if (VariableValue.IsEmpty())
                        {
                            // Remove from registry
                            RegInfo.DeleteCurrentKeyValue(EnvironmentVariable);
                        }

                    }	// end if
                    else
                    {
                        // instance could not be put for some reason
                        hr = WBEM_E_FAILED;
                    }
                }
            }	// end if open registry key
            else if (hRetCode == ERROR_ACCESS_DENIED)
                hr = WBEM_E_ACCESS_DENIED;
            else
            {
                // instance could not be put for some reason....unknown
                hr = WBEM_E_FAILED;
            }	// end else
        }	// end if system variable
        else	// NOT A SYSTEM VARIABLE
        {
            hRetCode = UserHive.Load(UserName.GetBuffer(0),
                szKeyName,_MAX_PATH) ;
            

            if(hRetCode == ERROR_SUCCESS)
            {
                TCHAR szKeyName2[_MAX_PATH];
                _tcscpy(szKeyName2, szKeyName);
				try
				{
					bHiveLoaded = TRUE ;
					//               strcat(szKeyName, "\\Environment") ;
					_tcscat(szKeyName, IDS_RegEnvironmentKey) ;
					hRetCode = RegInfo.Open(HKEY_USERS, szKeyName, KEY_ALL_ACCESS) ;
					if (ERROR_SUCCESS == hRetCode)
					{
						// Check the flags.  First do we even care?
						if (lFlags & (WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY))
						{

							// Ok, we care.  Is this var already there?
							CHString sTemp;
							hRetCode = RegInfo.GetCurrentKeyValue(EnvironmentVariable, sTemp);

							// If create only and already there, that's an error, else no error
							if (lFlags & WBEM_FLAG_CREATE_ONLY)
							{
								if (hRetCode == ERROR_SUCCESS)
								{
									hr = WBEM_E_ALREADY_EXISTS;
									hRetCode = ~ERROR_SUCCESS;
								}
								else
								{
									hRetCode = ERROR_SUCCESS;
									// If update only (the only other option) and not there, that's an error, else no error
								}
							} else if (hRetCode != ERROR_SUCCESS)
							{
								hr = WBEM_E_NOT_FOUND;
								hRetCode = ~ERROR_SUCCESS;
							}
							else
							{
								hRetCode = ERROR_SUCCESS;
							}
						}

						// If we're still in business, change the environment variable in the registry
						if (hRetCode == ERROR_SUCCESS)
						{
							hRetCode = RegInfo.SetCurrentKeyValue(EnvironmentVariable, VariableValue);

							if (ERROR_SUCCESS == hRetCode)
							{
								// From here, we can say that we've won.
								hr = WBEM_S_NO_ERROR;
								if (pInstance.IsNull(IDS_VariableValue) || VariableValue.IsEmpty())
								{
									// Remove from registry
									RegInfo.DeleteCurrentKeyValue(EnvironmentVariable);
								}

								// now check to see if you are the current logged on user
								// if you are, change the variable in memory.
								CImpersonateLoggedOnUser	impersonateLoggedOnUser;

								if ( !impersonateLoggedOnUser.Begin() )
								{
									LogErrorMessage(IDS_LogImpersonationFailed);
								}	// end if logged on successfully
								else
								{
									try
									{
										//
										// possible failure
										//

										hr = WBEM_E_FAILED;

										DWORD dwLength = 0;
										if ( ! GetUserName ( szCurrentUserName, &dwLength ) )
										{
											if ( ERROR_INSUFFICIENT_BUFFER == ::GetLastError () )
											{
												if ( NULL != ( szCurrentUserName = new TCHAR [ dwLength ] ) )
												{
													if ( GetUserName ( szCurrentUserName, &dwLength ) )
													{
														//
														// we can say that possible everything was right
														//

														hr = WBEM_S_NO_ERROR;

														iFind = UserName.Find('\\');
														if (iFind > 0) {
															sTmpUser = UserName.Mid(iFind + _tclen(_T("\\")) );
														} else {
															sTmpUser = UserName;
														}
														if (sTmpUser.CompareNoCase(szCurrentUserName) == 0)
														{
															if (!SetEnvironmentVariable(EnvironmentVariable, VariableValue))
															{
																hr = WBEM_E_FAILED;
															}	// end else
														}	// end if
													}

													delete [] szCurrentUserName ;
													szCurrentUserName = NULL;
												}
											}
										}

									}
									catch ( ... )
									{
										if ( szCurrentUserName )
										{
											delete [] szCurrentUserName ;
											szCurrentUserName = NULL;
										}

										if ( !impersonateLoggedOnUser.End() )
										{
											LogErrorMessage(IDS_LogImpersonationRevertFailed) ;
										}

										throw ;
									}
								}

								if ( !impersonateLoggedOnUser.End() )
								{
									LogErrorMessage(IDS_LogImpersonationRevertFailed) ;
								}	// end if
							}
							else if (hRetCode == ERROR_ACCESS_DENIED)
								hr = WBEM_E_ACCESS_DENIED;
							else
								// instance could not be put
								hr = WBEM_E_FAILED;
						}
					}	// end if
					else if (hRetCode == ERROR_ACCESS_DENIED)
					{
						hr = WBEM_E_ACCESS_DENIED;
					}
					else
					{
						// instance could not be put because the key could not be opened
						hr = WBEM_E_FAILED;
					}
				}

				catch ( ... )
				{
					if (bHiveLoaded)
					{
						bHiveLoaded = false ;
						UserHive.Unload(szKeyName2) ;
					}

					throw ;
				}

				if (bHiveLoaded)
				{
					bHiveLoaded = false ;
					UserHive.Unload(szKeyName2) ;
				}

         }	// end if loaded hive
      }	// end else system variable

      //Send public message announcing change to Environment
      //Time out value of 1000 ms taken from the Environment Variables dialog of the System Control Panel Applet
      if ( SUCCEEDED ( hr ) )
      {
          DWORD_PTR dwResult ;
          ::SendMessageTimeout(	HWND_BROADCAST,
              WM_SETTINGCHANGE,
              0,
              (LPARAM) TEXT("Environment"),
              SMTO_NORMAL | SMTO_ABORTIFHUNG,
              1000,
              &dwResult );
      }
   }	// end if NT

   return(hr);
#endif

}	// end Environment::PutInstance(const CInstance &pInstance)

////////////////////////////////////////////////////////////////////////
//
//	Function:	DeleteInstance
//
//	CIMOM wants us to delete this instance.
//
//	Inputs:
//
//	Outputs:
//
//	Return:
//
//	Comments:
//
////////////////////////////////////////////////////////////////////////
HRESULT Environment::DeleteInstance(const CInstance& pInstance, long lFlags /*= 0L*/)
{
	HRESULT		hr = WBEM_E_NOT_FOUND;

#ifdef NTONLY
	// since the variable value is NULL, the value will be removed.
	hr = PutInstance(pInstance, WBEM_FLAG_UPDATE_ONLY);
#endif
	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\floppy.cpp ===
//***************************************************************************
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//  Floppy.cpp
//
//  Purpose: Floppy drive property set provider
//
//***************************************************************************

#include "precomp.h"

#include <winioctl.h>
#include <ntddscsi.h>

#include "Floppy.h"

#include <comdef.h>

#include "Kernel32Api.h"

// Property set declaration
//=========================

#define CONFIG_MANAGER_CLASS_FLOPPYDISK L"FloppyDisk"
#define CONFIG_MANAGER_CLASS_GUID_FLOPPYDISK L"{4d36e980-e325-11ce-bfc1-08002be10318}"

CWin32_FloppyDisk s_FloppyDisk ( PROPSET_NAME_FLOPPYDISK , IDS_CimWin32Namespace );

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_FloppyDisk::CWin32_FloppyDisk
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32_FloppyDisk :: CWin32_FloppyDisk (

	LPCWSTR a_Name,
	LPCWSTR a_Namespace

) : Provider ( a_Name, a_Namespace )
{
//	InitializeCriticalSection ( & m_CriticalSection ) ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_FloppyDisk::~CWin32_FloppyDisk
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32_FloppyDisk :: ~CWin32_FloppyDisk()
{
//	DeleteCriticalSection ( & m_CriticalSection ) ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_FloppyDisk::GetObject
//
//  Inputs:     CInstance*      pInstance - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_FloppyDisk :: GetObject ( CInstance *a_Instance, long a_Flags, CFrameworkQuery &a_Query )
{
    HRESULT t_Result = WBEM_E_NOT_FOUND ;

    CConfigManager t_ConfigManager ;

/*
 * Let's see if config manager recognizes this device at all
 */

    CHString t_Key ;
    a_Instance->GetCHString ( IDS_DeviceID , t_Key ) ;

    CConfigMgrDevicePtr t_Device;
    if ( t_ConfigManager.LocateDevice ( t_Key , t_Device ) )
    {
/*
 * Ok, it knows about it.  Is it a Floppy device?
 */
        if (t_Device->IsClass(CONFIG_MANAGER_CLASS_FLOPPYDISK))
		{
			TCHAR *t_DosDeviceNameList = NULL ;

			if ( QueryDosDeviceNames ( t_DosDeviceNameList ) )
			{
				try
				{
					CHString t_DeviceId ;
					if ( t_Device->GetPhysicalDeviceObjectName ( t_DeviceId ) )
					{
						DWORD t_SpecifiedProperties = GetBitMask( a_Query );

						t_Result = LoadPropertyValues ( a_Instance, t_Device , t_DeviceId , t_DosDeviceNameList, t_SpecifiedProperties ) ;
					}
				}
				catch ( ... )
				{
					delete [] t_DosDeviceNameList ;

					throw ;
				}

				delete [] t_DosDeviceNameList ;
			}
			else
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}
		}
    }

    return t_Result ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_FloppyDisk::EnumerateInstances
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_FloppyDisk :: EnumerateInstances ( MethodContext *a_MethodContext , long a_Flags )
{
	HRESULT t_Result = Enumerate ( a_MethodContext , a_Flags ) ;
	return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_FloppyDisk::ExecQuery
 *
 *  DESCRIPTION : Query optimizer
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32_FloppyDisk :: ExecQuery ( MethodContext *a_MethodContext, CFrameworkQuery &a_Query, long a_Flags )
{
    HRESULT t_Result = WBEM_E_FAILED ;

    DWORD t_SpecifiedProperties = GetBitMask( a_Query );

//	if ( t_SpecifiedProperties )
	{
		t_Result = Enumerate ( a_MethodContext , a_Flags , t_SpecifiedProperties ) ;
	}

    return t_Result ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_FloppyDisk::Enumerate
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_FloppyDisk :: Enumerate ( MethodContext *a_MethodContext , long a_Flags , DWORD a_SpecifiedProperties )
{
    HRESULT t_Result = WBEM_S_NO_ERROR ;

	TCHAR *t_DosDeviceNameList = NULL ;
	if ( QueryDosDeviceNames ( t_DosDeviceNameList ) )
	{
		try
		{
			CConfigManager t_ConfigManager ;
			CDeviceCollection t_DeviceList ;

		/*
		*	While it might be more performant to use FilterByGuid, it appears that at least some
		*	95 boxes will report InfraRed info if we do it this way.
		*/

			if ( t_ConfigManager.GetDeviceListFilterByClass ( t_DeviceList, CONFIG_MANAGER_CLASS_FLOPPYDISK ) )
			{
				REFPTR_POSITION t_Position ;

				if ( t_DeviceList.BeginEnum ( t_Position ) )
				{
					CConfigMgrDevicePtr t_Device;

					t_Result = WBEM_S_NO_ERROR ;

					// Walk the list
					for (t_Device.Attach(t_DeviceList.GetNext ( t_Position ));
						 SUCCEEDED( t_Result ) && ( t_Device != NULL );
						 t_Device.Attach(t_DeviceList.GetNext ( t_Position )))
					{
						CInstancePtr t_Instance (CreateNewInstance ( a_MethodContext ), false) ;
						CHString t_DeviceId ;
						if ( t_Device->GetPhysicalDeviceObjectName ( t_DeviceId ) )
						{
							t_Result = LoadPropertyValues ( t_Instance , t_Device , t_DeviceId , t_DosDeviceNameList , a_SpecifiedProperties ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Instance->Commit (  ) ;
							}
						}
						else
						{
							//t_Result = WBEM_E_PROVIDER_FAILURE ;  // Don't return failures from query or enum as impacts association classes
						}
					}

					// Always call EndEnum().  For all Beginnings, there must be an End

					t_DeviceList.EndEnum();
				}
			}
		}
		catch ( ... )
		{
			delete [] t_DosDeviceNameList ;

			throw ;
		}

		delete [] t_DosDeviceNameList ;
	}
	else
	{
		//t_Result = WBEM_E_PROVIDER_FAILURE ;  // Don't return failures from query or enum as impacts association classes
	}

    return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_FloppyDisk::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance* pInstance - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32_FloppyDisk :: LoadPropertyValues (

	CInstance *a_Instance,
	CConfigMgrDevice *a_Device ,
	const CHString &a_DeviceName ,
	const TCHAR *a_DosDeviceNameList ,
	DWORD a_SpecifiedProperties
)
{
	HRESULT t_Result = LoadConfigManagerPropertyValues ( a_Instance , a_Device , a_DeviceName , a_SpecifiedProperties ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_SpecifiedProperties & SPECIAL_MEDIA )
		{
			CHString t_DosDeviceName ;
			t_Result = GetDeviceInformation ( a_Instance , a_Device , a_DeviceName , t_DosDeviceName , a_DosDeviceNameList , a_SpecifiedProperties ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
#if 0
				t_Result = LoadMediaPropertyValues ( a_Instance , a_Device , a_DeviceName , t_DosDeviceName , a_SpecifiedProperties ) ;
#endif
			}
			else
			{
				t_Result = ( t_Result == WBEM_E_NOT_FOUND ) ? S_OK : t_Result ;
			}
		}
	}

	return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_FloppyDisk::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance* pInstance - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32_FloppyDisk :: LoadConfigManagerPropertyValues (

	CInstance *a_Instance ,
	CConfigMgrDevice *a_Device ,
	const CHString &a_DeviceName ,
	DWORD a_SpecifiedProperties
)
{
    HRESULT t_Result = WBEM_S_NO_ERROR;

	a_Instance->SetWBEMINT16(IDS_Availability, 3 ) ;

/*
 *	 Set PNPDeviceID, ConfigManagerErrorCode, ConfigManagerUserConfig
 */

	if ( a_SpecifiedProperties & SPECIAL_CONFIGPROPERTIES )
	{
		SetConfigMgrProperties ( a_Device, a_Instance ) ;

/*
 * Set the status based on the config manager error code
 */

		if ( a_SpecifiedProperties & SPECIAL_PROPS_STATUS )
		{
            CHString t_sStatus;
			if ( a_Device->GetStatus ( t_sStatus ) )
			{
				a_Instance->SetCHString ( IDS_Status , t_sStatus ) ;
			}
		}
	}
/*
 *	Use the PNPDeviceID for the DeviceID (key)
 */

	if ( a_SpecifiedProperties & SPECIAL_PROPS_DEVICEID ) // Always populate the key
	{
		CHString t_Key ;

		if ( a_Device->GetDeviceID ( t_Key ) )
		{
			a_Instance->SetCHString ( IDS_DeviceID , t_Key ) ;
		}
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CREATIONNAME )
	{
        a_Instance->SetWCHARSplat ( IDS_SystemCreationClassName , L"Win32_ComputerSystem" ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_SYSTEMNAME )
	{
	    a_Instance->SetCHString ( IDS_SystemName , GetLocalComputerName () ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CREATIONCLASSNAME )
	{
		SetCreationClassName ( a_Instance ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_DESC_CAP_NAME )
	{
		CHString t_Description ;
		if ( a_Device->GetDeviceDesc ( t_Description ) )
		{
			if ( a_SpecifiedProperties & SPECIAL_PROPS_DESCRIPTION )
			{
				a_Instance->SetCHString ( IDS_Description , t_Description ) ;
			}
		}

/*
 *	Use the friendly name for caption and name
 */

		if ( a_SpecifiedProperties & SPECIAL_CAP_NAME )
		{
			CHString t_FriendlyName ;
			if ( a_Device->GetFriendlyName ( t_FriendlyName ) )
			{
				if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPTION )
				{
					a_Instance->SetCHString ( IDS_Caption , t_FriendlyName ) ;
				}

				if ( a_SpecifiedProperties & SPECIAL_PROPS_NAME )
				{
					a_Instance->SetCHString ( IDS_Name , t_FriendlyName ) ;
				}
			}
			else
			{
		/*
		 *	If we can't get the name, settle for the description
		 */

				if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPTION )
				{
					a_Instance->SetCHString ( IDS_Caption , t_Description );
				}

				if ( a_SpecifiedProperties & SPECIAL_PROPS_NAME )
				{
					a_Instance->SetCHString ( IDS_Name , t_Description );
				}
			}
		}
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_MANUFACTURER )
	{
		CHString t_Manufacturer ;

		if ( a_Device->GetMfg ( t_Manufacturer ) )
		{
			a_Instance->SetCHString ( IDS_Manufacturer, t_Manufacturer ) ;
		}
	}

/*
 *	Fixed value from enumerated list
 */

//	if ( a_SpecifiedProperties & SPECIAL_PROPS_PROTOCOLSSUPPORTED )
//	{
//	    a_Instance->SetWBEMINT16 ( IDS_ProtocolSupported , 16 ) ;
//	}

    return t_Result ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_FloppyDisk :: GetDeviceInformation
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_FloppyDisk :: GetDeviceInformation (

	CInstance *a_Instance ,
	CConfigMgrDevice *a_Device ,
	CHString a_DeviceName ,
	CHString &a_DosDeviceName ,
	const TCHAR *a_DosDeviceNameList ,
	DWORD a_SpecifiedProperties
)
{
	HRESULT t_Result = S_OK ;

	ULONG t_DeviceIndexLength = a_DeviceName.GetLength() + 1 - sizeof ( _TEXT("\\Device\\FloppyPdo" ) ) / sizeof ( TCHAR ) ;

	CHString t_FloppyIndex = a_DeviceName.Right ( t_DeviceIndexLength ) ;

	TCHAR t_DeviceLabel [ sizeof ( TCHAR ) * 17 + sizeof ( _TEXT("\\Device\\Floppy") ) * sizeof ( TCHAR ) ] ;
	_stprintf ( t_DeviceLabel , _TEXT("\\Device\\Floppy%s") , t_FloppyIndex ) ;

	TCHAR t_Query [ MAX_PATH * 2 ] ;

	DWORD t_QueryStatus = QueryDosDevice ( _TEXT("a:") , t_Query , sizeof ( t_Query ) / sizeof ( TCHAR ) ) ;

	if ( ! FindDosDeviceName ( a_DosDeviceNameList , t_DeviceLabel, a_DosDeviceName , TRUE ) )
	{
		t_Result = WBEM_E_NOT_FOUND ;
	}

	return t_Result ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_FloppyDisk :: LoadMediaPropertyValues
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_FloppyDisk::LoadMediaPropertyValues (

	CInstance *a_Instance ,
	CConfigMgrDevice *a_Device ,
	const CHString &a_DeviceName ,
	const CHString &a_DosDeviceName ,
	DWORD a_SpecifiedProperties
)
{

	HRESULT t_Result = S_OK ;

/*
 *
 */
    // Set common drive properties
    //=============================

	CHString t_DeviceLabel = CHString ( a_DosDeviceName ) ;

	if ( a_SpecifiedProperties & SPECIAL_PROPS_DRIVE )
	{
	    a_Instance->SetCharSplat ( IDS_Drive, t_DeviceLabel ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_ID )
	{
		a_Instance->SetCharSplat ( IDS_Id, t_DeviceLabel ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPABILITY )
	{
		// Create a safearray for the Capabilities information

		SAFEARRAYBOUND t_ArrayBounds ;

		t_ArrayBounds.cElements = 2;
		t_ArrayBounds.lLbound = 0;

        variant_t t_CapabilityValue ;
		if ( V_ARRAY ( & t_CapabilityValue ) = SafeArrayCreate ( VT_I2 , 1 , & t_ArrayBounds ) )
		{
			V_VT ( & t_CapabilityValue ) = VT_I2 | VT_ARRAY ;
			long t_Capability = 3 ;
			long t_Index = 0;

			HRESULT t_Result = SafeArrayPutElement ( V_ARRAY ( & t_CapabilityValue ) , & t_Index , & t_Capability ) ;
			if ( t_Result == E_OUTOFMEMORY )
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}

			t_Index = 1;
			t_Capability = 7 ;
			t_Result = SafeArrayPutElement ( V_ARRAY ( & t_CapabilityValue ), & t_Index , & t_Capability ) ;
			if ( t_Result == E_OUTOFMEMORY )
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}

			a_Instance->SetVariant ( IDS_Capabilities , t_CapabilityValue ) ;

		}
		else
		{
			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}
	}

/*
 * Media type
 */

	if ( a_SpecifiedProperties & SPECIAL_PROPS_MEDIATYPE )
	{
	    a_Instance->SetCharSplat ( IDS_MediaType , IDS_MDT_CD ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_VOLUMEINFORMATION )
	{

/*
 * Set the DriveIntegrity and TransferRate properties:
 */

		CHString t_VolumeDevice = CHString ( L"\\\\.\\" ) + a_DosDeviceName + CHString ( L"\\" ) ;

/*
 *	Volume information
 */

		TCHAR t_FileSystemName [ _MAX_PATH ] = _T("Unknown file system");

		TCHAR t_VolumeName [ _MAX_PATH ] ;
		DWORD t_VolumeSerialNumber ;
		DWORD t_MaxComponentLength ;
		DWORD t_FileSystemFlags ;

		ULARGE_INTEGER t_TotalBytes ;
		ULARGE_INTEGER t_AvailableBytes ;
		BOOL t_SizeFound = FALSE ;

		BOOL t_Status =	GetVolumeInformation (

			TOBSTRT((LPCWSTR)t_VolumeDevice) ,
			t_VolumeName ,
			sizeof ( t_VolumeName ) / sizeof ( TCHAR ) ,
			& t_VolumeSerialNumber ,
			& t_MaxComponentLength ,
			& t_FileSystemFlags ,
			t_FileSystemName ,
			sizeof ( t_FileSystemName ) / sizeof ( TCHAR )
		) ;

		if ( t_Status )
		{
/*
 * There's a disk in -- set disk-related props
 */
			if ( a_SpecifiedProperties & SPECIAL_PROPS_MEDIALOADED )
			{
				a_Instance->Setbool ( IDS_MediaLoaded , true ) ;
			}

			if ( a_SpecifiedProperties & SPECIAL_PROPS_STATUS )
			{
				a_Instance->SetCharSplat ( IDS_Status , IDS_OK ) ;
			}

			if ( a_SpecifiedProperties & SPECIAL_PROPS_VOLUMENAME )
			{
				a_Instance->SetCharSplat ( IDS_VolumeName , t_VolumeName ) ;
			}

			if ( a_SpecifiedProperties & SPECIAL_PROPS_MAXCOMPONENTLENGTH )
			{
				a_Instance->SetDWORD ( IDS_MaximumComponentLength , t_MaxComponentLength ) ;
			}

			if ( a_SpecifiedProperties & SPECIAL_PROPS_FILESYSTEMFLAGS )
			{
				a_Instance->SetDWORD ( IDS_FileSystemFlags , t_FileSystemFlags ) ;
			}

			if ( a_SpecifiedProperties & SPECIAL_PROPS_SERIALNUMBER )
			{
				TCHAR t_SerialNumber [ 9 ] ;

				_stprintf ( t_SerialNumber , _T("%x"), t_VolumeSerialNumber ) ;
				_tcsupr ( t_SerialNumber ) ;

				a_Instance->SetCharSplat ( IDS_VolumeSerialNumber , t_SerialNumber ) ;
			}

/*
 *	See if GetDiskFreeSpaceEx() is supported
 */

			if ( a_SpecifiedProperties & SPECIAL_VOLUMESPACE )
			{
				TCHAR t_TotalBytesString [ _MAX_PATH ];

                CKernel32Api *pKernel32 = (CKernel32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidKernel32Api, NULL);
                if ( pKernel32 != NULL)
				{
					try
					{
						// See if the function is available...
						BOOL fRetval = FALSE;
						if ( pKernel32->GetDiskFreeSpaceEx ( TOBSTRT((LPCWSTR)t_VolumeDevice) , & t_AvailableBytes , & t_TotalBytes , NULL , &fRetval) )
						{   // the function exists.
							if(fRetval)
							{   // and the return value was true.
								_stprintf ( t_TotalBytesString , _T("%I64d"), t_TotalBytes.QuadPart ) ;
								a_Instance->SetCHString ( IDS_Size , t_TotalBytesString ) ;
								t_SizeFound = TRUE ;
							}
						}
					}
					catch ( ... )
					{
						CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidKernel32Api, pKernel32);

						throw ;
					}

					CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidKernel32Api, pKernel32);
					pKernel32 = NULL;
				}

		/*
		 *	If we couldn't get extended info -- use old API
		 *  (known to be inaccurate on Win95 for >2G drives)
		 */
				if ( ! t_SizeFound )
				{
					DWORD t_SectorsPerCluster ;
					DWORD t_BytesPerSector ;
					DWORD t_FreeClusters ;
					DWORD t_TotalClusters ;

					t_Status = GetDiskFreeSpace (

						TOBSTRT((LPCWSTR)a_DosDeviceName) ,
						& t_SectorsPerCluster,
						& t_BytesPerSector,
						& t_FreeClusters,
						& t_TotalClusters
					) ;

					if ( t_Status )
					{
						t_TotalBytes.QuadPart = (DWORDLONG) t_BytesPerSector * (DWORDLONG) t_SectorsPerCluster * (DWORDLONG) t_TotalClusters ;
						_stprintf( t_TotalBytesString , _T("%I64d"), t_TotalBytes.QuadPart ) ;

					}
				}
			}
		}
		else
		{
			DWORD t_LastError = GetLastError () ;

			if ( a_SpecifiedProperties & SPECIAL_PROPS_STATUS )
			{
				a_Instance->SetCharSplat ( IDS_Status , IDS_STATUS_Unknown ) ;
			}

			if ( a_SpecifiedProperties & SPECIAL_PROPS_MEDIALOADED )
			{
				a_Instance->Setbool ( IDS_MediaLoaded , false ) ;
			}
		}
	}

	return t_Result ;
}

DWORD CWin32_FloppyDisk :: GetBitMask ( CFrameworkQuery &a_Query )
{
    DWORD t_SpecifiedProperties = SPECIAL_PROPS_NONE_REQUIRED ;

    if ( a_Query.IsPropertyRequired ( IDS_Status ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_DeviceID ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DEVICEID ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SystemCreationClassName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CREATIONNAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SystemName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SYSTEMNAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Description ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DESCRIPTION ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Caption ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CAPTION ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Name ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_NAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Manufacturer ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_MANUFACTURER ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_ProtocolSupported ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_PROTOCOLSSUPPORTED ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SCSITargetId ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SCSITARGETID ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Drive ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DRIVE ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Id ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_ID ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Capabilities ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CAPABILITY ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_MediaType ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_MEDIATYPE ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Status ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_MediaLoaded ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_MEDIALOADED ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_VolumeName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_VOLUMENAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_MaximumComponentLength ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_MAXCOMPONENTLENGTH ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_FileSystemFlags ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_FILESYSTEMFLAGS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_VolumeSerialNumber ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SERIALNUMBER ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Size ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SIZE ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_CreationClassName ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CREATIONCLASSNAME ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_PNPDeviceID ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_PNPDEVICEID ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ConfigManagerErrorCode ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CONFIGMERRORCODE ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ConfigManagerUserConfig ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CONFIGMUSERCONFIG ;
    }

    return t_SpecifiedProperties;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\floppy.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  Floppy.h
//
//  Purpose: Floppy drive property set provider
//
//***************************************************************************

// Property set identification
//============================

typedef BOOL (WINAPI *KERNEL32_DISK_FREESPACEEX) (

		LPCTSTR lpDirectoryName,
        PULARGE_INTEGER lpFreeBytesAvailableToCaller,
        PULARGE_INTEGER lpTotalNumberOfBytes,
        PULARGE_INTEGER lpTotalNumberOfFreeBytes
) ;

// Property set identification
//============================

#define PROPSET_NAME_FLOPPYDISK				L"Win32_FloppyDrive"

#define METHOD_NAME_PROFILEDRIVE		L"ProfileDrive"
#define METHOD_NAME_TESTDRIVEINTEGRITY	L"TestDriveIntegrity"

#define SPECIAL_PROPS_ALL_REQUIRED          0xFFFFFFFF
#define SPECIAL_PROPS_NONE_REQUIRED         0x00000000
#define SPECIAL_PROPS_TEST_INTEGRITY        0x00000001
#define SPECIAL_PROPS_TEST_TRANSFERRATE     0x00000002
#define SPECIAL_PROPS_STATUS				0x00000004
#define SPECIAL_PROPS_DEVICEID				0x00000008
#define SPECIAL_PROPS_CREATIONNAME			0x00000010
#define SPECIAL_PROPS_SYSTEMNAME			0x00000020
#define SPECIAL_PROPS_DESCRIPTION			0x00000040
#define SPECIAL_PROPS_CAPTION				0x00000080
#define SPECIAL_PROPS_NAME					0x00000100
#define SPECIAL_PROPS_MANUFACTURER			0x00000200
#define SPECIAL_PROPS_PROTOCOLSSUPPORTED	0x00000400
#define SPECIAL_PROPS_SCSITARGETID			0x00000800
#define SPECIAL_PROPS_DRIVE					0x00001000
#define SPECIAL_PROPS_ID					0x00002000
#define SPECIAL_PROPS_CAPABILITY			0x00004000
#define SPECIAL_PROPS_MEDIATYPE				0x00008000
#define SPECIAL_PROPS_VOLUMENAME			0x00010000
#define SPECIAL_PROPS_MAXCOMPONENTLENGTH	0x00020000
#define SPECIAL_PROPS_FILESYSTEMFLAGS		0x00040000
#define SPECIAL_PROPS_SERIALNUMBER			0x00080000
#define SPECIAL_PROPS_SIZE					0x00100000
#define SPECIAL_PROPS_MEDIALOADED			0x00200000
#define SPECIAL_PROPS_PNPDEVICEID			0x00400000
#define SPECIAL_PROPS_CONFIGMERRORCODE		0x00800000
#define SPECIAL_PROPS_CONFIGMUSERCONFIG		0x01000000
#define SPECIAL_PROPS_CREATIONCLASSNAME		0x02000000


#define SPECIAL_ALL					( SPECIAL_CONFIGMANAGER | \
									SPECIAL_MEDIA )

#define SPECIAL_CONFIGMANAGER		( SPECIAL_PROPS_STATUS | \
									SPECIAL_PROPS_DEVICEID | \
									SPECIAL_PROPS_CREATIONNAME | \
									SPECIAL_PROPS_SYSTEMNAME | \
									SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME | \
									SPECIAL_PROPS_MANUFACTURER | \
									SPECIAL_PROPS_PROTOCOLSSUPPORTED | \
									SPECIAL_PROPS_PNPDEVICEID | \
									SPECIAL_PROPS_CONFIGMERRORCODE | \
									SPECIAL_PROPS_CONFIGMUSERCONFIG | \
									SPECIAL_PROPS_CREATIONCLASSNAME )

#define SPECIAL_CONFIGPROPERTIES 	( SPECIAL_PROPS_PNPDEVICEID | \
									SPECIAL_PROPS_CONFIGMERRORCODE | \
									SPECIAL_PROPS_CONFIGMUSERCONFIG | \
									SPECIAL_PROPS_STATUS )

#define SPECIAL_DESC_CAP_NAME		( SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define SPECIAL_DESC_CAP_NAME		( SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define SPECIAL_CAP_NAME			( SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define SPECIAL_MEDIA				( SPECIAL_PROPS_SCSITARGETID | \
									SPECIAL_PROPS_DRIVE | \
									SPECIAL_PROPS_ID | \
									SPECIAL_PROPS_CAPABILITY | \
									SPECIAL_PROPS_MEDIATYPE | \
									SPECIAL_PROPS_VOLUMENAME | \
									SPECIAL_PROPS_MAXCOMPONENTLENGTH | \
									SPECIAL_PROPS_FILESYSTEMFLAGS | \
									SPECIAL_PROPS_SERIALNUMBER | \
									SPECIAL_PROPS_SIZE | \
									SPECIAL_PROPS_MEDIALOADED )

#define SPECIAL_ALL					( SPECIAL_CONFIGMANAGER | \
									SPECIAL_MEDIA )

#define SPECIAL_VOLUMEINFORMATION	( SPECIAL_PROPS_MEDIATYPE | \
									SPECIAL_PROPS_VOLUMENAME | \
									SPECIAL_PROPS_MAXCOMPONENTLENGTH | \
									SPECIAL_PROPS_FILESYSTEMFLAGS | \
									SPECIAL_PROPS_SERIALNUMBER | \
									SPECIAL_PROPS_SIZE | \
									SPECIAL_PROPS_MEDIALOADED )
	

#define SPECIAL_VOLUMESPACE			( SPECIAL_PROPS_SIZE )
	
class CWin32_FloppyDisk : public Provider
{
protected:

//		CRITICAL_SECTION m_CriticalSection ;

protected:

        DWORD GetBitMask ( 

            CFrameworkQuery &a_Query 
        );

        // Utility function(s)
        //====================

		HRESULT Enumerate ( 

			MethodContext *a_MethodContext , 
			long a_Flags , 
			DWORD a_SpecifiedPropertied = SPECIAL_PROPS_ALL_REQUIRED
		) ;

		HRESULT LoadPropertyValues ( 

			CInstance *a_Instance, 
			CConfigMgrDevice *a_Device , 
			const CHString &a_DeviceName , 
			const TCHAR *a_DosDeviceNameList ,
			DWORD a_SpecifiedPropertied = SPECIAL_PROPS_ALL_REQUIRED 
		) ;

		HRESULT LoadConfigManagerPropertyValues ( 

			CInstance *a_Instance , 
			CConfigMgrDevice *a_Device , 
			const CHString &a_DeviceName , 
			DWORD a_SpecifiedPropertied
		) ;

		HRESULT GetDeviceInformation ( 

			CInstance *a_Instance ,
			CConfigMgrDevice *a_Device , 
			CHString a_DeviceName , 
			CHString &a_DosDeviceName ,
			const TCHAR *a_DosDeviceNameList ,
			DWORD a_SpecifiedPropertied
		) ;

		HRESULT LoadMediaPropertyValues (	

			CInstance *a_Instance , 
			CConfigMgrDevice *a_Device , 
			const CHString &a_DeviceName , 
			const CHString &a_DosDeviceName , 
			DWORD a_SpecifiedPropertied 
		) ;

public:

        // Constructor/destructor
        //=======================

        CWin32_FloppyDisk ( LPCWSTR a_Name, LPCWSTR a_Namespace ) ;
       ~CWin32_FloppyDisk () ;

        // Functions provide properties with current values
        //=================================================

        HRESULT GetObject ( 

			CInstance *a_Instance, 
			long a_Flags,
			CFrameworkQuery &a_Query
		) ;

        HRESULT EnumerateInstances ( 

			MethodContext *a_MethodContext, 
			long a_Flags = 0L 
		) ;

        HRESULT ExecQuery ( 

			MethodContext *a_MethodContext, 
			CFrameworkQuery &a_Query, 
			long a_Flags = 0L
		) ;

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\groupuser.h ===
//=================================================================

//

// groupuser.h -- UserGroup to User Group Members association provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    1/26/98      davwoh         Created
//
// Comments: Shows the members in each user group
//
//=================================================================

// Property set identification
//============================

#define  PROPSET_NAME_GROUPUSER L"Win32_GroupUser"

class CWin32GroupUser ;

class CWin32GroupUser:public Provider {

   public:

      // Constructor/destructor
      //=======================

      CWin32GroupUser(LPCWSTR name, LPCWSTR pszNamespace) ;
      ~CWin32GroupUser() ;

      // Functions provide properties with current values
      //=================================================

      virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
      virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);
      virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags = 0L );
      static HRESULT WINAPI StaticEnumerationCallback(Provider* pThat, CInstance* pInstance, MethodContext* pContext, void* pGroupData);

   private:

      // Utility function(s)
      //====================

      void CWin32GroupUser::GetDependentsFromGroup(CNetAPI32& netapi, 
                                               const CHString sDomain,
                                               const CHString sGroupName, 
                                               const BYTE btSidType, 
                                               CHStringArray &asArray);

      HRESULT EnumerationCallback(CInstance* pGroup, MethodContext* pContext, void* pUserData);

      HRESULT ProcessArray(
        MethodContext* pMethodContext,
        CHString& chstrGroup__RELPATH, 
        CHStringArray& rgchstrArray);


      CHString m_sGroupBase;
      CHString m_sUserBase;
      CHString m_sSystemBase;
//      CHString m_sSystemBase;

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\floppycontroller.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  FloppyController.cpp
//
//  Purpose: Floppy Controller property set provider
//
//***************************************************************************

#include "precomp.h"

#include "FloppyController.h"

// Property set declaration
//=========================

#define CONFIG_MANAGER_CLASS_FLOPPYCONTROLLER L"fdc"
//#define CONFIG_MANAGER_CLASS_GUID_FLOPPYCONTROLLER L"{4d36e969-e325-11ce-bfc1-08002be10318}"

CWin32_FloppyController s_FloppyController ( PROPSET_NAME_FLOPPYCONTROLLER , IDS_CimWin32Namespace );

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_FloppyController::CWin32_FloppyController
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32_FloppyController :: CWin32_FloppyController (

	LPCWSTR a_Name ,
	LPCWSTR a_Namespace

) : Provider( a_Name, a_Namespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_FloppyController::~CWin32_FloppyController
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32_FloppyController :: ~CWin32_FloppyController ()
{
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_FloppyController::GetObject
//
//  Inputs:     CInstance*      a_Instance - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_FloppyController :: GetObject ( CInstance *a_Instance , long a_Flags , CFrameworkQuery &a_Query )
{
    HRESULT t_Result = WBEM_E_NOT_FOUND ;


    // Let's see if config manager recognizes this device at all

    CHString t_DeviceID;
    a_Instance->GetCHString ( IDS_DeviceID , t_DeviceID ) ;

    CConfigManager t_ConfigurationManager ;
    CConfigMgrDevicePtr t_Device;

    if ( t_ConfigurationManager.LocateDevice ( t_DeviceID , t_Device ) )
    {
        // Ok, it knows about it.  Is it a Floppy controller?
		CHString t_Class;
		if ( t_Device->IsClass ( CONFIG_MANAGER_CLASS_FLOPPYCONTROLLER ) )
		{
			CHString t_Key ;
			a_Instance->GetCHString ( IDS_DeviceID , t_Key ) ;

            DWORD t_SpecifiedProperties = GetBitMask( a_Query );
			t_Result = LoadPropertyValues ( a_Instance , t_Device , t_Key , t_SpecifiedProperties ) ;
		}
    }

    return t_Result ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_FloppyController::EnumerateInstances
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_FloppyController :: EnumerateInstances ( MethodContext *a_MethodContext , long a_Flags )
{
	HRESULT t_Result ;
	t_Result = Enumerate ( a_MethodContext , a_Flags ) ;
	return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::ExecQuery
 *
 *  DESCRIPTION : Query optimizer
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32_FloppyController :: ExecQuery ( MethodContext *a_MethodContext, CFrameworkQuery &a_Query, long a_Flags )
{
    HRESULT t_Result = WBEM_E_FAILED ;

    DWORD t_SpecifiedProperties = GetBitMask( a_Query );
//	if ( t_SpecifiedProperties )
	{
		t_Result = Enumerate ( a_MethodContext , a_Flags , t_SpecifiedProperties ) ;
	}

    return t_Result ;
}

HRESULT CWin32_FloppyController :: Enumerate ( MethodContext *a_MethodContext , long a_Flags , DWORD a_SpecifiedProperties )
{
    HRESULT t_Result = WBEM_E_FAILED ;

    CConfigManager t_ConfigurationManager ;
    CDeviceCollection t_DeviceList ;

    // While it might be more performant to use FilterByGuid, it appears that at least some
    // 95 boxes will report InfraRed info if we do it this way.

    if ( t_ConfigurationManager.GetDeviceListFilterByClass ( t_DeviceList , CONFIG_MANAGER_CLASS_FLOPPYCONTROLLER ) )
    {
        REFPTR_POSITION t_Position ;

        if ( t_DeviceList.BeginEnum( t_Position ) )
        {
            CConfigMgrDevicePtr t_Device;

            t_Result = WBEM_S_NO_ERROR ;

            // Walk the list
            for (t_Device.Attach(t_DeviceList.GetNext ( t_Position ));
                SUCCEEDED( t_Result ) && (t_Device != NULL);
                t_Device.Attach(t_DeviceList.GetNext ( t_Position )))
            {
				// Now to find out if this is the floppy controller

				CHString t_Key ;
				if ( t_Device->GetDeviceID ( t_Key ) )
				{
					CInstancePtr t_Instance (CreateNewInstance ( a_MethodContext ), false);
					if ( ( t_Result = LoadPropertyValues ( t_Instance , t_Device , t_Key , a_SpecifiedProperties ) ) == WBEM_S_NO_ERROR )
					{
						t_Result = t_Instance->Commit (  ) ;
					}
				}
            }

            // Always call EndEnum().  For all Beginnings, there must be an End
            t_DeviceList.EndEnum () ;
        }
    }

    return t_Result;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_FloppyController::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance* a_Instance - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32_FloppyController :: LoadPropertyValues (

	CInstance *a_Instance ,
	CConfigMgrDevice *a_Device ,
	const CHString &a_DeviceName ,
	DWORD a_SpecifiedProperties
)
{
    HRESULT t_Result = WBEM_S_NO_ERROR;

/*
 *	 Set PNPDeviceID, ConfigManagerErrorCode, ConfigManagerUserConfig
 */

	if ( a_SpecifiedProperties & SPECIAL_CONFIGPROPERTIES )
	{
		SetConfigMgrProperties ( a_Device, a_Instance ) ;

/*
 * Set the status based on the config manager error code
 */

		if ( a_SpecifiedProperties & SPECIAL_PROPS_STATUS )
		{
            CHString t_sStatus;
			if ( a_Device->GetStatus ( t_sStatus ) )
			{
				a_Instance->SetCHString ( IDS_Status , t_sStatus ) ;
			}
		}
	}
/*
 *	Use the PNPDeviceID for the DeviceID (key)
 */

	if ( a_SpecifiedProperties & SPECIAL_PROPS_DEVICEID )
	{
		CHString t_Key ;

		if ( a_Device->GetDeviceID ( t_Key ) )
		{
			a_Instance->SetCHString ( IDS_DeviceID , t_Key ) ;
		}
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CREATIONNAME )
	{
		a_Instance->SetWCHARSplat ( IDS_SystemCreationClassName , L"Win32_ComputerSystem" ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_SYSTEMNAME )
	{
	    a_Instance->SetCHString ( IDS_SystemName , GetLocalComputerName () ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CREATIONCLASSNAME )
	{
		SetCreationClassName ( a_Instance ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_DESC_CAP_NAME )
	{
		CHString t_Description ;
		if ( a_Device->GetDeviceDesc ( t_Description ) )
		{
			if ( a_SpecifiedProperties & SPECIAL_PROPS_DESCRIPTION )
			{
				a_Instance->SetCHString ( IDS_Description , t_Description ) ;
			}
		}

/*
 *	Use the friendly name for caption and name
 */

		if ( a_SpecifiedProperties & SPECIAL_CAP_NAME )
		{
			CHString t_FriendlyName ;
			if ( a_Device->GetFriendlyName ( t_FriendlyName ) )
			{
				if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPTION )
				{
					a_Instance->SetCHString ( IDS_Caption , t_FriendlyName ) ;
				}

				if ( a_SpecifiedProperties & SPECIAL_PROPS_NAME )
				{
					a_Instance->SetCHString ( IDS_Name , t_FriendlyName ) ;
				}
			}
			else
			{
		/*
		 *	If we can't get the name, settle for the description
		 */

				if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPTION )
				{
					a_Instance->SetCHString ( IDS_Caption , t_Description );
				}

				if ( a_SpecifiedProperties & SPECIAL_PROPS_NAME )
				{
					a_Instance->SetCHString ( IDS_Name , t_Description );
				}
			}
		}
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_MANUFACTURER )
	{
		CHString t_Manufacturer ;

		if ( a_Device->GetMfg ( t_Manufacturer ) )
		{
			a_Instance->SetCHString ( IDS_Manufacturer, t_Manufacturer ) ;
		}
	}

/*
 *	Fixed value from enumerated list
 */

	if ( a_SpecifiedProperties & SPECIAL_PROPS_PROTOCOLSSUPPORTED )
	{
	    a_Instance->SetWBEMINT16 ( IDS_ProtocolSupported , 2 ) ;
	}

    return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_FloppyController::IsInfraRedController
 *
 *  DESCRIPTION : Checks to make sure pDevice is a controller, and not some
 *                other type of InfraRed device.
 *
 *  INPUTS      : CConfigMgrDevice* pDevice - The device to check.  It is
 *                assumed that the caller has ensured that the device is a
 *                valid InfraRed class device.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CWin32_FloppyController :: IsFloppyController ( CConfigMgrDevice *a_Device )
{
    BOOL t_Status = FALSE ;

    if ( a_Device )
    {
        // Now to find out if this is the floppy controller
		t_Status = a_Device->IsClass ( CONFIG_MANAGER_CLASS_FLOPPYCONTROLLER ) ;
    }

    return t_Status ;
}


DWORD CWin32_FloppyController :: GetBitMask ( CFrameworkQuery &a_Query )
{
    DWORD t_SpecifiedProperties = SPECIAL_PROPS_NONE_REQUIRED ;

    if ( a_Query.IsPropertyRequired ( IDS_Status ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_DeviceID ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DEVICEID ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SystemCreationClassName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CREATIONNAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SystemName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SYSTEMNAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Description ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DESCRIPTION ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Caption ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CAPTION ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Name ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_NAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Manufacturer ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_MANUFACTURER ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_ProtocolSupported ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_PROTOCOLSSUPPORTED ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Status ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_CreationClassName ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CREATIONCLASSNAME ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_PNPDeviceID ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_PNPDEVICEID ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ConfigManagerErrorCode ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CONFIGMERRORCODE ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ConfigManagerUserConfig ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CONFIGMUSERCONFIG ;
    }

    return t_SpecifiedProperties;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\floppycontroller.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  FloppyController.cpp
//
//  Purpose: Floppy Controller property set provider
//
//***************************************************************************

// Property set identification
//============================

#define	PROPSET_NAME_FLOPPYCONTROLLER	L"Win32_FloppyController"

#define SPECIAL_PROPS_ALL_REQUIRED          0xFFFFFFFF
#define SPECIAL_PROPS_NONE_REQUIRED         0x00000000
#define SPECIAL_PROPS_STATUS				0x00000004
#define SPECIAL_PROPS_DEVICEID				0x00000008
#define SPECIAL_PROPS_CREATIONNAME			0x00000010
#define SPECIAL_PROPS_SYSTEMNAME			0x00000020
#define SPECIAL_PROPS_DESCRIPTION			0x00000040
#define SPECIAL_PROPS_CAPTION				0x00000080
#define SPECIAL_PROPS_NAME					0x00000100
#define SPECIAL_PROPS_MANUFACTURER			0x00000200
#define SPECIAL_PROPS_PROTOCOLSSUPPORTED	0x00000400
#define SPECIAL_PROPS_PNPDEVICEID			0x00400000
#define SPECIAL_PROPS_CONFIGMERRORCODE		0x00800000
#define SPECIAL_PROPS_CONFIGMUSERCONFIG		0x01000000
#define SPECIAL_PROPS_CREATIONCLASSNAME		0x02000000


#define SPECIAL_ALL					( SPECIAL_CONFIGMANAGER )

#define SPECIAL_CONFIGMANAGER		( SPECIAL_PROPS_STATUS | \
									SPECIAL_PROPS_DEVICEID | \
									SPECIAL_PROPS_CREATIONNAME | \
									SPECIAL_PROPS_SYSTEMNAME | \
									SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME | \
									SPECIAL_PROPS_MANUFACTURER | \
									SPECIAL_PROPS_PROTOCOLSSUPPORTED | \
									SPECIAL_PROPS_PNPDEVICEID | \
									SPECIAL_PROPS_CONFIGMERRORCODE | \
									SPECIAL_PROPS_CONFIGMUSERCONFIG | \
									SPECIAL_PROPS_CREATIONCLASSNAME )

#define SPECIAL_CONFIGPROPERTIES 	( SPECIAL_PROPS_PNPDEVICEID | \
									SPECIAL_PROPS_CONFIGMERRORCODE | \
									SPECIAL_PROPS_CONFIGMUSERCONFIG | \
									SPECIAL_PROPS_STATUS )

#define SPECIAL_DESC_CAP_NAME		( SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define SPECIAL_DESC_CAP_NAME		( SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define SPECIAL_CAP_NAME			( SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

class CWin32_FloppyController : public Provider
{
    public:

        // Constructor/destructor
        //=======================

        CWin32_FloppyController ( LPCWSTR a_Name , LPCWSTR a_Namespace ) ;

       ~CWin32_FloppyController() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject ( CInstance *a_Instance , long lFlags , CFrameworkQuery &a_Query) ;
		HRESULT ExecQuery ( MethodContext *a_MethodContext, CFrameworkQuery &a_Query, long a_Flags ) ;
        virtual HRESULT EnumerateInstances ( MethodContext *a_MethodContext , long a_Flags = 0L ) ;

    private:

        // Utility function(s)
        //====================

		HRESULT Enumerate ( 

			MethodContext *a_MethodContext , 
			long a_Flags , 
			DWORD a_SpecifiedPropertied = SPECIAL_PROPS_ALL_REQUIRED
		) ;

        HRESULT LoadPropertyValues ( 

			CInstance *a_Instance , 
			CConfigMgrDevice *a_Device , 
			const CHString &a_DeviceName , 
			DWORD a_SpecifiedPropertied = SPECIAL_PROPS_ALL_REQUIRED 
		) ;

        BOOL IsFloppyController ( CConfigMgrDevice *a_Device ) ;
        DWORD GetBitMask ( CFrameworkQuery &a_Query );

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\group.h ===
//=================================================================

//

// Group.h -- Group property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               11/13/97    davwoh         Re-Worked to return all
//                                          domain Groups
//
//=================================================================

// Method name for changing the key in this WMI class
#define METHOD_NAME_Rename	L"Rename"

// Method return property
#define METHOD_ARG_NAME_METHODRESULT L"ReturnValue"


// Property set identification
//============================
#define	PROPSET_NAME_GROUP L"Win32_Group"

class CWin32GroupAccount : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32GroupAccount(LPCWSTR strName, LPCWSTR pszNamespace ) ;
        ~CWin32GroupAccount() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );
        virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ );

#ifdef NTONLY	
		virtual	HRESULT ExecMethod(	const CInstance &a_Inst,
									const BSTR a_MethodName, 
									CInstance *a_InParams,
									CInstance *a_OutParams,
									long a_Flags = 0L ) ;

		// method errors -- maps to mof
		enum E_MethodResult	{
			e_Success,
			e_InstanceNotFound,
			e_NoInstance,
			e_InvalidParameter,
			e_GroupNotFound,
			e_InvalidComputer,
			e_NotPrimary,
			e_SpeGroupOp,
			e_ApiError,
			e_InternalError
		};		
#endif		
    private:

        // Utility function(s)
        //====================

#ifdef NTONLY
        HRESULT AddDynamicInstancesNT( MethodContext* pMethodContext ) ;
        HRESULT RefreshInstanceNT( CInstance* pInstance ) ;
        void LoadGroupValuesNT(LPCWSTR pwszFullName, LPCWSTR pwszDescription, DWORD dwFlags, CInstance* pInstance );
		HRESULT GetDomainGroupsNT( CNetAPI32& netapi, LPCWSTR wstrDomain, MethodContext* pMethodContext );
        HRESULT GetLocalGroupsNT(CNetAPI32& netapi, MethodContext* pMethodContext , LPCWSTR a_Domain = NULL );
		HRESULT GetSingleGroupNT( CInstance* pInstance );
#endif
#ifdef NTONLY
        BOOL GetSIDInformationW(const LPCWSTR wstrDomainName, 
                                const LPCWSTR wstrAccountName, 
                                const LPCWSTR wstrComputerName, 
                                CInstance* pInstance,
								bool a_Local=false
		);

		HRESULT hRenameGroup( 

			CInstance *a_pInst,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long a_Flags ) ;
#endif
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\groupuser.cpp ===
//=================================================================

//

// groupuser.h -- UserGroup to User Group Members association provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    1/26/98      davwoh         Created
//
// Comments: Shows the members in each usergroup
//
//=================================================================
// In trying to do the UserGroups->Group Members association, I have made the following assumptions
//
// a) Global groups cannot have groups as members.
// b) Global groups cannot have any well-known accounts as members.
// c) Local groups can have Global groups as members.
// d) Local groups cannot have any well-known accounts as members.
//
// This is based on my experimentation with RegEdt32 and UsrMgr.  When these are discovered not to be
// true, we will probably need to make some changes here.

#include "precomp.h"
#include <frqueryex.h>
#include <assertbreak.h>

#include <comdef.h>
#include "wbemnetapi32.h"
#include "sid.h"

#include "user.h"
#include "group.h"
#include "systemaccount.h"

#include "GroupUser.h"

// Property set declaration
//=========================

CWin32GroupUser MyLoadDepends(PROPSET_NAME_GROUPUSER, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32GroupUser::CWin32GroupUser
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32GroupUser::CWin32GroupUser(LPCWSTR setName, LPCWSTR pszNamespace)
:Provider(setName, pszNamespace)
{
   CHString sTemp;

   // Just saves us from having to constantly re-calculate these when sending
   // instances back.
   sTemp = PROPSET_NAME_USER;
   sTemp += L".Domain=\"";
   m_sUserBase = MakeLocalPath(sTemp);

   sTemp = PROPSET_NAME_GROUP;
   sTemp += L".Domain=\"";
   m_sGroupBase = MakeLocalPath(sTemp);

   sTemp = PROPSET_NAME_SYSTEMACCOUNT;
   sTemp += L".Domain=\"";
   m_sSystemBase = MakeLocalPath(sTemp);

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32GroupUser::~CWin32GroupUser
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32GroupUser::~CWin32GroupUser()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32GroupUser::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32GroupUser::GetObject(CInstance *pInstance, long lFlags /*= 0L*/)
{

   // No groups on 95
#ifdef NTONLY
   CHString sMemberPath, sGroupPath;
   HRESULT hRet = WBEM_E_NOT_FOUND;
	CInstancePtr pGroup;
	CInstancePtr pMember;

   // Initialize the net stuff
   CNetAPI32 netapi ;
   if( netapi.Init() != ERROR_SUCCESS ) {
      return WBEM_E_FAILED;
   }

   // Get the two paths
   pInstance->GetCHString(IDS_GroupComponent, sGroupPath);
   pInstance->GetCHString(IDS_PartComponent, sMemberPath);

   // As we will be comparing these object paths
   // with those returned from GetDependentsFromGroup,
   // which always contains __PATH style object paths,
   // and since the user might have specified a __RELPATH,
   // we need to convert to __PATH here for consistency.
   CHString chstrGroup__PATH;
   CHString chstrMember__PATH;
   int n = -1;

   // Handle various GroupComponent path specifications...
   if(sGroupPath.Find(L"\\\\") == -1)
   {
       chstrGroup__PATH = MakeLocalPath(sGroupPath);
   }
   else if(sGroupPath.Find(L"\\\\.") != -1)
   {
       n = sGroupPath.Find(L":");
       if(n == -1)
       {
           hRet = WBEM_E_INVALID_OBJECT_PATH;
       }
       else
       {
           chstrGroup__PATH = MakeLocalPath(sGroupPath.Mid(n+1));
       }    
   }
   else
   {
       chstrGroup__PATH = sGroupPath;
   }


   // Handle various PartComponent path specifications...
   if(hRet != WBEM_E_INVALID_OBJECT_PATH)
   {
       if(sMemberPath.Find(L"\\\\") == -1)
       {
           chstrMember__PATH = MakeLocalPath(sMemberPath);
       }
       else if(sMemberPath.Find(L"\\\\.") != -1)
       {
           n = sMemberPath.Find(L":");
           if(n == -1)
           {
               hRet = WBEM_E_INVALID_OBJECT_PATH;
           }
           else
           {
               chstrMember__PATH = MakeLocalPath(sMemberPath.Mid(n+1));
           }    
       }
       else
       {
           chstrMember__PATH = sMemberPath;
       }
   }

   // If both ends are there
   if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath( (LPCTSTR)chstrMember__PATH, &pMember, pInstance->GetMethodContext() ) ) ) 
   {
      if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath( (LPCTSTR)chstrGroup__PATH, &pGroup, pInstance->GetMethodContext() ) ) ) 
      {
         // Now we need to check to see if this member (user or group) is in the usergroup
         CHString sGroupName, sDomainName;
         CHStringArray asMembersGot;
         DWORD dwSize;
         BYTE btType;

         // Retrieve the values we are looking for
         pGroup->GetCHString(IDS_Domain, sDomainName);
         pGroup->GetCHString(IDS_Name, sGroupName);
         pGroup->GetByte(IDS_SIDType, btType);

         // Get the dependent list for this service
         GetDependentsFromGroup(netapi, sDomainName, sGroupName, btType, asMembersGot);

         // Walk the list to see if we're there
         dwSize = asMembersGot.GetSize();
 
         for (int x=0; x < dwSize; x++) 
         {
            if (asMembersGot.GetAt(x).CompareNoCase(chstrMember__PATH) == 0) 
            {
               hRet = WBEM_S_NO_ERROR;
               break;
            }
         }
      }
   }

   return hRet;
#endif

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32GroupUser::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32GroupUser::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
#ifdef NTONLY
   HRESULT hr;

   CNetAPI32 netapi ;
   if( netapi.Init() != ERROR_SUCCESS ) {
      return WBEM_E_FAILED;
   }

//	hr = CWbemProviderGlue::GetAllInstancesAsynch(PROPSET_NAME_GROUP, this, StaticEnumerationCallback, IDS_CimWin32Namespace, pMethodContext, &netapi);
   	hr = CWbemProviderGlue::GetInstancesByQueryAsynch(_T("Select Domain, Name, SidType from Win32_Group"),
                                                      this, StaticEnumerationCallback, IDS_CimWin32Namespace,
                                                      pMethodContext, &netapi);

   return hr;
#endif
}


/*****************************************************************************
 *
 *  FUNCTION    : CWin32GroupUser::ExecQuery
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32GroupUser::ExecQuery(
    MethodContext *pMethodContext, 
    CFrameworkQuery& pQuery, 
    long lFlags /*= 0L*/ )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    std::vector<_bstr_t> vecGroupComponents;
    std::vector<_bstr_t> vecPartComponents;
    DWORD dwNumGroupComponents;
    DWORD dwNumPartComponents;
    CHString chstrGroup__RELPATH;
    CHString chstrGroupDomain;
    CHString chstrGroupName;
    CHStringArray rgchstrGroupMembers;

    // Initialize the net stuff
    CNetAPI32 netapi;
    if( netapi.Init() != ERROR_SUCCESS ) 
    {
       return WBEM_E_FAILED;
    }

    // Did they specify groups?
    pQuery.GetValuesForProp(IDS_GroupComponent, vecGroupComponents);
    dwNumGroupComponents = vecGroupComponents.size();

    // Did they specify users?
    pQuery.GetValuesForProp(IDS_PartComponent, vecPartComponents);
    dwNumPartComponents = vecPartComponents.size();

    // Prepare information to be used below...
    ParsedObjectPath    *pParsedPath = NULL;
    CObjectPathParser	objpathParser;

    // Find out what type of query it was.
    // Was it a 3TokenOR?
    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx *>(&pQuery);
    if (pQuery2 != NULL)
    {
        variant_t vGroupComp;
        variant_t vPartComp;
        CHString chstrSubDirPath;
        CHString chstrCurrentDir;

        if ( (pQuery2->Is3TokenOR(IDS_GroupComponent, IDS_PartComponent, vGroupComp, vPartComp)) &&
             ((V_BSTR(&vGroupComp) != NULL) && (V_BSTR(&vPartComp) != NULL)) &&
             (wcscmp(V_BSTR(&vGroupComp), V_BSTR(&vPartComp)) == 0) )
        {
			//group can be a member of a group so we have to enumerate :-(...
			hr = EnumerateInstances(pMethodContext, lFlags);
        }
        else if(dwNumGroupComponents > 0 && dwNumPartComponents == 0)  // one or more groups specified; no users specified
        {
            for(LONG m = 0L; m < dwNumGroupComponents && SUCCEEDED(hr); m++)
            {
                // Parse the path to get the domain/user
                int nStatus = objpathParser.Parse(vecGroupComponents[m],  &pParsedPath);

                // Did we parse it and does it look reasonable?
                if (nStatus == 0)
                {
                    try
                    {
                        if ( (pParsedPath->m_dwNumKeys == 2) &&
                             (pParsedPath->m_paKeys[0]->m_vValue.vt == VT_BSTR) && 
                             (pParsedPath->m_paKeys[1]->m_vValue.vt == VT_BSTR))
                        {
                            // This contains the complete object path
                            chstrGroup__RELPATH = (wchar_t*) vecGroupComponents[m];

                            // This contains just the 'Domain' part of the object path
                            chstrGroupDomain = pParsedPath->m_paKeys[0]->m_vValue.bstrVal;

                            // This contains just the 'Name' part of the object path
                            chstrGroupName = pParsedPath->m_paKeys[1]->m_vValue.bstrVal;

                            // Obtain members of this group...
                            CHString chstrComputerName(GetLocalComputerName());
							CHString chstrNT_AUTHORITY;
							CHString chstrBuiltIn;

							if(GetLocalizedNTAuthorityString(chstrNT_AUTHORITY) && GetLocalizedBuiltInString(chstrBuiltIn))
							{
								if ( chstrGroupDomain.CompareNoCase(chstrBuiltIn) != 0 &&
									 chstrGroupDomain.CompareNoCase(chstrNT_AUTHORITY) != 0
								   )
								{
									if(chstrGroupDomain.CompareNoCase(chstrComputerName) == 0)
									{
										GetDependentsFromGroup(netapi, chstrGroupDomain, chstrGroupName, SidTypeWellKnownGroup, rgchstrGroupMembers);
									}
									else
									{
										GetDependentsFromGroup(netapi, chstrGroupDomain, chstrGroupName, SidTypeGroup, rgchstrGroupMembers);
									}

									hr = ProcessArray(pMethodContext, chstrGroup__RELPATH, rgchstrGroupMembers);
								}
							}
                        }
                    }
                    catch (...)
                    {
                        objpathParser.Free( pParsedPath );
                        throw;
                    }

                    // Clean up the Parsed Path
                    objpathParser.Free( pParsedPath );
                }
            }
        }
        else if(dwNumGroupComponents == 1 && dwNumPartComponents == 1)  // one group specified; one user specified
        {
            // Parse the path to get the domain/user
            int nStatus = objpathParser.Parse(vecGroupComponents[0],  &pParsedPath);

            // Did we parse it and does it look reasonable?
            if (nStatus == 0)
            {
                try
                {
                    if ( (pParsedPath->m_dwNumKeys == 2) &&
                         (pParsedPath->m_paKeys[0]->m_vValue.vt == VT_BSTR) && 
                         (pParsedPath->m_paKeys[1]->m_vValue.vt == VT_BSTR))
                    {
                        // This contains the complete object path
                        chstrGroup__RELPATH = (wchar_t*) vecGroupComponents[0];

                        // This contains just the 'Domain' part of the object path
                        chstrGroupDomain = pParsedPath->m_paKeys[0]->m_vValue.bstrVal;

                        // This contains just the 'Name' part of the object path
                        chstrGroupName = pParsedPath->m_paKeys[1]->m_vValue.bstrVal;

                        // Obtain members of this group...
                        CHString chstrComputerName(GetLocalComputerName());
						CHString chstrNT_AUTHORITY;
						CHString chstrBuiltIn;

						if(GetLocalizedNTAuthorityString(chstrNT_AUTHORITY) && GetLocalizedBuiltInString(chstrBuiltIn))
						{
							if ( chstrGroupDomain.CompareNoCase(chstrBuiltIn) != 0 &&
								 chstrGroupDomain.CompareNoCase(chstrNT_AUTHORITY) != 0
							   )
							{
								if(chstrGroupDomain.CompareNoCase(chstrComputerName) == 0)
								{
									GetDependentsFromGroup(netapi, chstrGroupDomain, chstrGroupName, SidTypeWellKnownGroup, rgchstrGroupMembers);
								}
								else
								{
									GetDependentsFromGroup(netapi, chstrGroupDomain, chstrGroupName, SidTypeGroup, rgchstrGroupMembers);
								}
                    
								DWORD dwSize = rgchstrGroupMembers.GetSize();
								CInstancePtr pInstance;

								//get full path for partcomponent
								CHString chstrMember__PATH;
								CHString chstrPart((LPCWSTR)(vecPartComponents[0]));
								
								if(chstrPart.Find(L"\\\\") == -1)
								{
									chstrMember__PATH = MakeLocalPath(chstrPart);
								}
								else if(chstrPart.Find(L"\\\\.") != -1)
								{
									int n = chstrPart.Find(L":");

									if(n != -1)
									{
										chstrMember__PATH = MakeLocalPath(chstrPart.Mid(n+1));
									}    
								}
								else
								{
								   chstrMember__PATH = ((LPCWSTR)(vecPartComponents[0]));
								}

								// Process the instance
								for (int x=0; x < dwSize && SUCCEEDED(hr) ; x++)
								{
									if(rgchstrGroupMembers.GetAt(x).CompareNoCase(chstrMember__PATH) == 0)
									{
										pInstance.Attach(CreateNewInstance(pMethodContext));
										if(pInstance)
										{
											// Do the puts, and that's it
											pInstance->SetCHString(IDS_GroupComponent, chstrGroup__RELPATH);
											pInstance->SetCHString(IDS_PartComponent, chstrMember__PATH);
											hr = pInstance->Commit();
											break;
										}
										else
										{
											hr = WBEM_E_OUT_OF_MEMORY;
										}
									}
								}
							}
						}
                    }
                }
                catch (...)
                {
                    objpathParser.Free( pParsedPath );
                    throw;
                }

                // Clean up the Parsed Path
                objpathParser.Free( pParsedPath );
            }    
        }
        else
        {
            hr = EnumerateInstances(pMethodContext, lFlags);
        }
    }

    // Because this is an association class, we should only return WBEM_E_NOT_FOUND or WBEM_S_NO_ERROR.  Other error codes
    // will cause associations that hit this class to terminate prematurely.
    if(SUCCEEDED(hr))
    {
        hr = WBEM_S_NO_ERROR;
    }
    else
    {
        hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}
#endif


/*****************************************************************************
 *
 *  FUNCTION    : CWin32GroupUser::GetDependentsFromGroup
 *
 *  DESCRIPTION : Given a group name, returns the Users/Groups in that group name
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : Returns empty array if no group, empty group, or bad
 *                group name.
 *
 *****************************************************************************/
#ifdef NTONLY
void CWin32GroupUser::GetDependentsFromGroup(CNetAPI32& netapi,
                                               const CHString sDomainName,
                                               const CHString sGroupName,
                                               const BYTE btSidType,
                                               CHStringArray &asArray)
{
    CHString sTemp;
    NET_API_STATUS	stat;
    bool bAddIt;
    DWORD dwNumReturnedEntries = 0, dwIndex = 0, dwTotalEntries = 0;
	DWORD_PTR dwptrResume = NULL;

    // Domain Groups
    if (btSidType == SidTypeGroup)
    {
        GROUP_USERS_INFO_0 *pGroupMemberData = NULL;
        CHString		chstrDCName;

        if (netapi.GetDCName( sDomainName, chstrDCName ) == ERROR_SUCCESS)
        {
            do
            {

                // Accept up to 256k worth of data.
                stat = netapi.NetGroupGetUsers( chstrDCName,
                    sGroupName,
                    0,
                    (LPBYTE *)&pGroupMemberData,
                    262144,
                    &dwNumReturnedEntries,
                    &dwTotalEntries,
                    &dwptrResume);

                // If we got some data
                if ( ERROR_SUCCESS == stat || ERROR_MORE_DATA == stat )
                {
                    try
                    {

                        // Walk through all the returned entries
                        for ( DWORD	dwCtr = 0; dwCtr < dwNumReturnedEntries; dwCtr++ )
                        {

                            // Get the sid type for this object
                            CSid	sid( sDomainName, CHString(pGroupMemberData[dwCtr].grui0_name), NULL );
                            DWORD dwType = sid.GetAccountType();

                            // From our assertions above, Domain groups can only have users
                            if (dwType == SidTypeUser)
                            {
                                sTemp = m_sUserBase;
                                sTemp += sDomainName;
                                sTemp += _T("\",Name=\"");
                                sTemp += pGroupMemberData[dwCtr].grui0_name;
                                sTemp += _T('"');
                                asArray.Add(sTemp);
                            }
                        }
                    }
                    catch ( ... )
                    {
                        netapi.NetApiBufferFree( pGroupMemberData );
                        throw ;
                    }

                    netapi.NetApiBufferFree( pGroupMemberData );

                }	// IF stat OK

            } while ( ERROR_MORE_DATA == stat );
            
        }
    }
    // Local Groups
    else if (btSidType == SidTypeAlias || btSidType == SidTypeWellKnownGroup)
    {
        LOCALGROUP_MEMBERS_INFO_1 *pGroupMemberData = NULL;

        do {

            // Accept up to 256k worth of data.
            stat = netapi.NetLocalGroupGetMembers( NULL,
                sGroupName,
                1,
                (LPBYTE *)&pGroupMemberData,
                262144,
                &dwNumReturnedEntries,
                &dwTotalEntries,
                &dwptrResume);

            // If we got some data
            if ( ERROR_SUCCESS == stat || ERROR_MORE_DATA == stat )
            {
                try
                {

                    // Walk through all the returned entries
                    for ( DWORD	dwCtr = 0; dwCtr < dwNumReturnedEntries; dwCtr++ )
                    {

                        // If this is a recognized type...
                        bAddIt = true;

                        switch (pGroupMemberData[dwCtr].lgrmi1_sidusage) {

                        case SidTypeUser:
                            sTemp = m_sUserBase;
                            break;

                        case SidTypeGroup:
                            sTemp = m_sGroupBase;
                            break;

                        case SidTypeWellKnownGroup:
                            sTemp = m_sSystemBase;
                            break;

                        default:
                            // Group member is of unrecognized type, don't add it
                            ASSERT_BREAK(0);
                            bAddIt = false;
                            break;
                        }

                        CSid cLCID(pGroupMemberData[dwCtr].lgrmi1_sid);

                        // Then add it to the list
                        if (bAddIt)
                        {
                            CHString chstrDomNameTemp = cLCID.GetDomainName();
                            CHString chstrComputerName(GetLocalComputerName());
							CHString chstrBuiltIn;

                            if(GetLocalizedBuiltInString(chstrBuiltIn))
                            {
								if (chstrDomNameTemp.CompareNoCase(chstrBuiltIn) == 0)
								{
									chstrDomNameTemp = chstrComputerName;
								}
								else
								{
									CHString chstrNT_AUTHORITY;
									if(GetLocalizedNTAuthorityString(chstrNT_AUTHORITY))
									{
										if(chstrDomNameTemp.CompareNoCase(chstrNT_AUTHORITY) == 0 ||
										  (chstrDomNameTemp.IsEmpty() && pGroupMemberData[dwCtr].lgrmi1_sidusage == SidTypeWellKnownGroup))
										{
											chstrDomNameTemp = chstrComputerName;
										}   
									}
									else
									{
										bAddIt = false;
									}
								}
                            }
                            else
                            {
								bAddIt = false;
                            }

                            if(bAddIt)
                            {
                                sTemp += chstrDomNameTemp;
                                //sTemp += cLCID.GetDomainName();
                                sTemp += _T("\",Name=\"");
                                sTemp += pGroupMemberData[dwCtr].lgrmi1_name;
                                sTemp += _T('"');
                                asArray.Add(sTemp);
                            }
                        }
                    }
                }
                catch ( ... )
                {
                    netapi.NetApiBufferFree( pGroupMemberData );
                    throw ;
                }

                netapi.NetApiBufferFree( pGroupMemberData );

            }	// IF stat OK

        } while ( ERROR_MORE_DATA == stat );
    }
	else
    {
        // Unrecognized Group type
        ASSERT_BREAK(0);
    }

}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32GroupUser::StaticEnumerationCallback
 *
 *  DESCRIPTION : Called from GetAllInstancesAsynch as a wrapper to EnumerationCallback
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef NTONLY
HRESULT WINAPI CWin32GroupUser::StaticEnumerationCallback(Provider* pThat, CInstance* pInstance, MethodContext* pContext, void* pUserData)
{
	CWin32GroupUser* pThis;
   HRESULT hr;

	pThis = dynamic_cast<CWin32GroupUser *>(pThat);
	ASSERT_BREAK(pThis != NULL);

	if (pThis)
		hr = pThis->EnumerationCallback(pInstance, pContext, pUserData);
   else
      hr = WBEM_E_FAILED;

   return hr;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32GroupUser::EnumerationCallback
 *
 *  DESCRIPTION : Called from GetAllInstancesAsynch via StaticEnumerationCallback
 *
 *  INPUTS      : (see CWbemProviderGlue::GetAllInstancesAsynch)
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef NTONLY
HRESULT CWin32GroupUser::EnumerationCallback(CInstance* pGroup, MethodContext* pMethodContext, void* pUserData)
{
	CNetAPI32* pNetApi;
	pNetApi = (CNetAPI32 *) pUserData;
   CHStringArray asMembersGot;
   BYTE btSidType;
   DWORD dwSize, x;
   CHString sGroup, sDomain, sGroupPath;
   HRESULT hr = WBEM_S_NO_ERROR;

   // Get the info about this group
   pGroup->GetCHString(IDS_Domain, sDomain) ;
   pGroup->GetCHString(IDS_Name, sGroup) ;
   pGroup->GetByte(IDS_SIDType, btSidType);
   pGroup->GetCHString(L"__RELPATH", sGroupPath) ;

   // See if there are users in this group
   GetDependentsFromGroup(*pNetApi, sDomain, sGroup, btSidType, asMembersGot);

   dwSize = asMembersGot.GetSize();

   // Ok, turn the relpath into a complete path
   GetLocalInstancePath(pGroup, sGroupPath);
   CInstancePtr pInstance;

   // Start pumping out the instances
   for (x=0; x < dwSize && SUCCEEDED(hr) ; x++)
   {
      pInstance.Attach(CreateNewInstance(pMethodContext));
      if (pInstance)
      {
          // Do the puts, and that's it
          pInstance->SetCHString(IDS_GroupComponent, sGroupPath);
          pInstance->SetCHString(IDS_PartComponent, asMembersGot.GetAt(x));
          hr = pInstance->Commit();
      }
      else
      {
          hr = WBEM_E_OUT_OF_MEMORY;
      }
   }

   return hr;
}
#endif



/*****************************************************************************
 *
 *  FUNCTION    : CWin32GroupUser::ProcessArray
 *
 *  DESCRIPTION : Called from query routine to return instances
 *
 *  INPUTS      : 
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef NTONLY
HRESULT CWin32GroupUser::ProcessArray(
    MethodContext* pMethodContext,
    CHString& chstrGroup__RELPATH, 
    CHStringArray& rgchstrArray)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwSize, x;
    CHString sGroup, sDomain, sGroupPath;

    dwSize = rgchstrArray.GetSize();

    CInstancePtr pInstance;

    // Start pumping out the instances
    for (x=0; x < dwSize && SUCCEEDED(hr) ; x++)
    {
        pInstance.Attach(CreateNewInstance(pMethodContext));
        if(pInstance)
        {
            // Do the puts, and that's it
            pInstance->SetCHString(IDS_GroupComponent, chstrGroup__RELPATH);
            pInstance->SetCHString(IDS_PartComponent, rgchstrArray.GetAt(x));
            hr = pInstance->Commit();
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\group.cpp ===
//=================================================================

//

// Group.CPP -- Group property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               11/13/97    davwoh         Re-Worked to return all
//                                          domain Groups
//
//
//=================================================================

#include "precomp.h"

#include "wbemnetapi32.h"
#include <lmwksta.h>
#include <comdef.h>

#include "sid.h"
#include "Group.h"
#include <vector>
#include <frqueryex.h>

#include <computerAPI.h>

//////////////////////////////////////////////////////////////////////

// Property set declaration
//=========================

CWin32GroupAccount   Win32GroupAccount( PROPSET_NAME_GROUP, IDS_CimWin32Namespace );

/*****************************************************************************
 *
 *  FUNCTION    : CWin32GroupAccount::CWin32GroupAccount
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *                LPCTSTR pszNamespace - Namespace for class
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32GroupAccount::CWin32GroupAccount(LPCWSTR strName, LPCWSTR pszNamespace /*=NULL*/ )
:  Provider( strName, pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32GroupAccount::~CWin32GroupAccount
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32GroupAccount::~CWin32GroupAccount()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32GroupAccount::ExecQuery
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32GroupAccount::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ )
{
   HRESULT  hr = WBEM_S_NO_ERROR;

#ifdef NTONLY
   {
	   //CHStringArray acsDomains;
	   std::vector<_bstr_t> vectorDomains;
       std::vector<_bstr_t> vectorNames;
       std::vector<_variant_t> vectorLocalAccount;
	   DWORD dwDomains, x, dwNames;
       CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx *>(&pQuery);
        bool fLocalAccountPropertySpecified = false;
        bool fLocalAccount = false;

	   pQuery.GetValuesForProp(L"Domain", vectorDomains);
       pQuery.GetValuesForProp(L"Name", vectorNames);
	   dwDomains = vectorDomains.size();
       dwNames = vectorNames.size();
       pQuery2->GetValuesForProp(IDS_LocalAccount, vectorLocalAccount);
       // See if only local accounts requested
       if(vectorLocalAccount.size() > 0)
       {
           fLocalAccountPropertySpecified = true;
           // use variant_t's bool extractor...
           fLocalAccount = vectorLocalAccount[0];
       }

       if(dwDomains == 0 && dwNames >= 1)
       {
           // We were given one or more names, but no domain, so we need
           // to look for those groups on all domains...

           // For the local case, there won't be many groups,
           // so enumerate them...
           CNetAPI32 NetAPI;
           if(NetAPI.Init() == ERROR_SUCCESS)
           {
               GetLocalGroupsNT(NetAPI, pMethodContext);

               if(!(fLocalAccountPropertySpecified && fLocalAccount))
               {
                   // Now try to find the specified group on all
                   // trusted domains...
                   // Get all the domains related to this one (plus this one)
                   std::vector<_bstr_t> vectorTrustList;
                   NetAPI.GetTrustedDomainsNT(vectorTrustList);
                   WCHAR wstrLocalComputerName[MAX_COMPUTERNAME_LENGTH+1] = { L'\0' };
                   DWORD dwNameSize = MAX_COMPUTERNAME_LENGTH+1;
         
                   if(ProviderGetComputerName(
                      wstrLocalComputerName,
                      &dwNameSize))
                   {
                       for(long z = 0L;
                           z < vectorNames.size();
                           z++)
                       {
                           // For each domain, try to find  the Groups
		                   bool fDone = false;
                           for(LONG m = 0L; 
                               m < vectorTrustList.size() && SUCCEEDED(hr) && !fDone; 
                               m++)
                           {
                               CInstancePtr pInstance = NULL;
                               pInstance.Attach(CreateNewInstance(pMethodContext));
	    			             if(pInstance != NULL)
                               {
                                   pInstance->SetWCHARSplat(IDS_Domain, vectorTrustList[m]);
                                   pInstance->SetWCHARSplat(IDS_Name, vectorNames[z]);
                             
                                   if((_wcsicmp((WCHAR*)vectorTrustList[m],
                                       wstrLocalComputerName) != 0) || 
                                        (NetAPI.IsDomainController(NULL)) ) 
                                   {
  				                       if(WBEM_S_NO_ERROR == GetSingleGroupNT(pInstance))
                                       {
                                           hr = pInstance->Commit();
                                       }                                         
                                   }
                               }
                           }
                       }
                   }
                }
           }
       }
       else if ((dwDomains == 0 && dwNames == 0))
	   {
           if(fLocalAccountPropertySpecified)
           {
               if(!fLocalAccount)
               {
                   hr = EnumerateInstances(pMethodContext);
               }
               else
               {
					CNetAPI32 NetAPI ;
		          // Get NETAPI32.DLL entry points
		          //==============================
					if(NetAPI.Init() == ERROR_SUCCESS)
					{
						hr = GetLocalGroupsNT(NetAPI, pMethodContext);
                  }
               }
           }
           else
           {
                hr = EnumerateInstances(pMethodContext);
           }
	   }
	   else  // Domain(s) specified...
	   {
		  CNetAPI32 NetAPI ;
		  // Get NETAPI32.DLL entry points
		  //==============================
		  if( NetAPI.Init() == ERROR_SUCCESS )
		  {
			 WCHAR wstrLocalComputerName[MAX_COMPUTERNAME_LENGTH+1];
			 DWORD dwNameSize = MAX_COMPUTERNAME_LENGTH+1;
			 ZeroMemory(wstrLocalComputerName,sizeof(wstrLocalComputerName));

			if(!ProviderGetComputerName( wstrLocalComputerName, &dwNameSize ) )
			{
				if ( ERROR_ACCESS_DENIED == ::GetLastError () )
				{
					return WBEM_E_ACCESS_DENIED;
				}
				else
				{
					return WBEM_E_FAILED;
				}
			}

             // If we given both name and domain, just find the one instance
             // specified
             if(dwDomains == 1 && dwNames ==1)
             {
                // Use our GetSingleGroupNT function to get info on
                // the one instance requested.
                CInstancePtr pInstance = NULL;
                pInstance.Attach(CreateNewInstance(pMethodContext));
				if(pInstance != NULL)
                {
                    pInstance->SetWCHARSplat(IDS_Domain, vectorDomains[0]);
                    pInstance->SetWCHARSplat(IDS_Name, vectorNames[0]);
                    hr = GetSingleGroupNT(pInstance);
                    if(WBEM_S_NO_ERROR == hr)
                    {
                        hr = pInstance->Commit();   
                    }
                }
             }
             else   
             {
				CHString chstrBuiltIn;
    
				if(GetLocalizedBuiltInString(chstrBuiltIn))
				{
					 // We were given more than one name and one domain,
					 // so we have to enumerate groups by domain (since
					 // we can't match up requested domain-name pairs).
					 // For all the paths, get the info
					 if(fLocalAccountPropertySpecified)
					 {
							if(fLocalAccount)
							{
								hr = GetLocalGroupsNT( NetAPI, pMethodContext ); 
							}
							else
							{
								for(x=0; 
									x < dwDomains && SUCCEEDED(hr); 
									x++)
								{
									if((_wcsicmp((WCHAR*)vectorDomains[x], wstrLocalComputerName) != 0) && 
									   (_wcsicmp((WCHAR*)vectorDomains[x], chstrBuiltIn) != 0))
									{
										hr = GetLocalGroupsNT( NetAPI, pMethodContext,vectorDomains[x] ); 
										if ( SUCCEEDED ( hr ) )
										{
											hr = GetDomainGroupsNT( NetAPI, vectorDomains[x], pMethodContext );
										}
									}
								}
							}
					 }
					 else
					 {
						 for(x=0; 
							 x < dwDomains && SUCCEEDED(hr); 
							 x++)
						 {
#if 1
							 if ((_wcsicmp((WCHAR*)vectorDomains[x],wstrLocalComputerName) == 0) || (_wcsicmp((WCHAR*)vectorDomains[x],chstrBuiltIn) == 0))
							 {
								 hr = GetLocalGroupsNT( NetAPI, pMethodContext );
							 }
							 else
							 {
								hr = GetLocalGroupsNT( NetAPI, pMethodContext,vectorDomains[x] );
								if ( SUCCEEDED ( hr ) ) 
								{
									hr = GetDomainGroupsNT( NetAPI, vectorDomains[x], pMethodContext );
								}
							 }
#else
							 if ((_wcsicmp((WCHAR*)vectorDomains[x],wstrLocalComputerName) == 0) || (_wcsicmp((WCHAR*)vectorDomains[x],chstrBuiltIn) == 0))
							 {
								 hr = GetLocalGroupsNT( NetAPI, pMethodContext );
							 }
							 else
							 {
								 hr = GetDomainGroupsNT( NetAPI, vectorDomains[x], pMethodContext );
							 }
#endif
						 }
					 }
				}
             }
		  }
	   }
   }
#endif
   return WBEM_S_NO_ERROR;
}

////////////////////////////////////////////////////////////////////////
//
// Function:   CWin32GroupAccount::GetObject
//
// Inputs:     CInstance*     pInstance - Instance into which we
//                               retrieve data.
//
// Outputs: None.
//
// Returns: HRESULT        Success/Failure code.
//
// Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32GroupAccount::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
   HRESULT hRes = WBEM_E_NOT_FOUND;

   // Find the instance depending on platform id.

#ifdef NTONLY
      hRes = RefreshInstanceNT( pInstance );
#endif
   return hRes;
}

////////////////////////////////////////////////////////////////////////
//
// Function:   CWin32GroupAccount::EnumerateInstances
//
// Inputs:     MethodContext* pMethodContext - Context to enum
//                      instance data in.
//
// Outputs: None.
//
// Returns: HRESULT        Success/Failure code.
//
// Comments:      None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32GroupAccount::EnumerateInstances( MethodContext* pMethodContext, long lFlags /*= 0L*/ )
{
   BOOL     fReturn     =  FALSE;
   HRESULT     hr       =  WBEM_S_NO_ERROR;

   // Get the proper OS dependent instance

#ifdef NTONLY
      hr = AddDynamicInstancesNT( pMethodContext );
#endif
   return WBEM_S_NO_ERROR;

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32GroupAccount::ExecMethod
 *
 *  DESCRIPTION : Executes a method
 *
 *  INPUTS      : Instance to execute against, method name, input parms instance
 *                Output parms instance.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef NTONLY

HRESULT CWin32GroupAccount::ExecMethod(

const CInstance &a_rInst,
const BSTR a_MethodName,
CInstance *a_pInParams,
CInstance *a_pOutParams,
long a_Flags )
{
	if ( !a_pOutParams )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	// Method recognized?
	if( !_wcsicmp ( a_MethodName, METHOD_NAME_Rename ) )
	{
		return hRenameGroup( (CInstance*)&a_rInst, a_pInParams, a_pOutParams, a_Flags ) ;
	}

	return WBEM_E_INVALID_METHOD ;
}

#endif

/*******************************************************************
    NAME:       hRenameGroup

    SYNOPSIS:   Sets a new group name for this instance.
				A method is required here since we are changing the key
				on the instance.

    ENTRY:      const CInstance &a_rInst,
				CInstance *a_pInParams,
				CInstance *a_pOutParams,
				long a_Flags	:

	NOTES:		This is a non static, instance dependent method call

    HISTORY:
********************************************************************/
#ifdef NTONLY

HRESULT CWin32GroupAccount::hRenameGroup(

CInstance *a_pInst,
CInstance *a_pInParams,
CInstance *a_pOutParams,
long a_Flags )
{
	E_MethodResult	t_eResult = e_InstanceNotFound ;
	CHString	t_chsGroupName ;
	CHString	t_chsDomainName ;
	CHString	t_chsNewGroupName ;

	if( !a_pOutParams )
	{
		return WBEM_E_FAILED ;
	}

	if( !a_pInParams )
	{
		a_pOutParams->SetDWORD( METHOD_ARG_NAME_METHODRESULT, e_InternalError ) ;
		return S_OK ;
	}

	// nonstatic method requires an instance
	if( !a_pInst )
	{
		a_pOutParams->SetDWORD( METHOD_ARG_NAME_METHODRESULT, e_NoInstance ) ;
		return S_OK ;
	}

	// keys
	if( !a_pInst->IsNull( IDS_Name ) && !a_pInst->IsNull( IDS_Domain ) )
	{
		// Name
		if( a_pInst->GetCHString( IDS_Name , t_chsGroupName ) )
		{
			// Domain
			if( a_pInst->GetCHString( IDS_Domain, t_chsDomainName ) )
			{
				// New Group name
				if( !a_pInParams->IsNull( IDS_Name ) &&
					a_pInParams->GetCHString( IDS_Name, t_chsNewGroupName ) )
				{
					t_eResult = e_Success ;
				}
				else
				{
					t_eResult = e_InvalidParameter ;
				}
			}
		}
	}

	// proceed with the update...
	if( e_Success == t_eResult )
	{
		if( t_chsNewGroupName != t_chsGroupName )
		{
			CNetAPI32	t_NetAPI;

			if ( ERROR_SUCCESS == t_NetAPI.Init () )
			{
				DWORD t_ParmError = 0 ;
				NET_API_STATUS t_Status = 0 ;
				GROUP_INFO_0 t_GroupInfo_0 ;
				t_GroupInfo_0.grpi0_name  = (LPWSTR)(LPCWSTR)t_chsNewGroupName ;

				WCHAR t_wstrLocalComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ] ;
				DWORD t_dwNameSize = MAX_COMPUTERNAME_LENGTH + 1 ;
				ZeroMemory( t_wstrLocalComputerName, sizeof( t_wstrLocalComputerName ) ) ;

				if(ProviderGetComputerName( t_wstrLocalComputerName, &t_dwNameSize ) )
				{
					if( t_chsDomainName.CompareNoCase( t_wstrLocalComputerName ) )
					{
						// Changes for local group
						t_Status = t_NetAPI.NetGroupSetInfo(
															(LPCWSTR)t_chsDomainName,
															(LPCWSTR)t_chsGroupName,
															0,
															(LPBYTE) &t_GroupInfo_0,
															&t_ParmError
															) ;


						if ( NERR_GroupNotFound == t_Status )
						{
							t_Status = t_NetAPI.NetLocalGroupSetInfo(
																t_chsDomainName,
																(LPCWSTR)t_chsGroupName,
																0,
																(LPBYTE) &t_GroupInfo_0,
																&t_ParmError
																) ;
						}
					}
					else
					{
						t_Status = t_NetAPI.NetLocalGroupSetInfo(
															NULL,
															(LPCWSTR)t_chsGroupName,
															0,
															(LPBYTE) &t_GroupInfo_0,
															&t_ParmError
															) ;
					}

					switch( t_Status )
					{
						case NERR_Success:			t_eResult = e_Success ;			break ;
						case NERR_GroupNotFound:	t_eResult = e_GroupNotFound ;	break ;
						case NERR_InvalidComputer:	t_eResult = e_InvalidComputer ;	break ;
						case NERR_NotPrimary:		t_eResult = e_NotPrimary ;		break ;
						case NERR_SpeGroupOp:		t_eResult = e_SpeGroupOp ;		break ;
						default:					t_eResult = e_ApiError;			break ;
					}
				}
				else
				{
					t_eResult =  e_InternalError;
				}
			}
		}
	}

	a_pOutParams->SetDWORD( METHOD_ARG_NAME_METHODRESULT, t_eResult ) ;
	return S_OK ;
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32GroupAccount::AddDynamicInstancesNT
 *
 *  DESCRIPTION : Creates instance for all known local Groups (NT)
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : nada, nichts, niente
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32GroupAccount::AddDynamicInstancesNT( MethodContext* pMethodContext )
{
   HRESULT  hr = WBEM_S_NO_ERROR;
   CNetAPI32 NetAPI ;

   // Get NETAPI32.DLL entry points
   //==============================

   if( NetAPI.Init() == ERROR_SUCCESS )
   {
      // Get the local groups first
      hr = GetLocalGroupsNT( NetAPI, pMethodContext );
      if (SUCCEEDED(hr))
      {
         // Get all the domains related to this one (plus this one)
         //CHStringArray achsTrustList;
         std::vector<_bstr_t> vectorTrustList;
         NetAPI.GetTrustedDomainsNT(vectorTrustList);
         WCHAR wstrLocalComputerName[MAX_COMPUTERNAME_LENGTH+1];
         DWORD dwNameSize = MAX_COMPUTERNAME_LENGTH+1;
         ZeroMemory(wstrLocalComputerName,sizeof(wstrLocalComputerName));

		if(!ProviderGetComputerName( wstrLocalComputerName, &dwNameSize ) )
		{
			if ( ERROR_ACCESS_DENIED == ::GetLastError () )
			{
				return WBEM_E_ACCESS_DENIED;
			}
			else
			{
				return WBEM_E_FAILED;
			}
		}

         // For each domain, get the Groups
         //for (int x=0; (x < achsTrustList.GetSize()) && (SUCCEEDED(hr)) ; x++)
         //while(stackTrustList.size() > 0 && (SUCCEEDED(hr)))
		 for(LONG m = 0L; m < vectorTrustList.size(); m++)
         {
             if ( (_wcsicmp((WCHAR*)vectorTrustList[m],wstrLocalComputerName) != 0) ||
                  (NetAPI.IsDomainController(NULL)) )
             {
				hr = GetLocalGroupsNT( NetAPI, pMethodContext , vectorTrustList[m] );
				if ( SUCCEEDED ( hr ) )
				{
					//hr = GetDomainGroupsNT( NetAPI, (WCHAR*)stackTrustList.top(), pMethodContext );
					hr = GetDomainGroupsNT( NetAPI, (WCHAR*)vectorTrustList[m], pMethodContext );
				}

                if (hr == WBEM_E_CALL_CANCELLED)
                {
                    break;
                }
             }
         }
      }
   }
   return hr;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : RefreshInstanceNT
 *
 *  DESCRIPTION : Loads property values according to key value set by framework
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32GroupAccount::RefreshInstanceNT( CInstance* pInstance )
{
	HRESULT hRetCode = GetSingleGroupNT(pInstance );
	if ( SUCCEEDED (hRetCode) )
	{
		if ( WBEM_S_NO_ERROR != hRetCode )
		{
			return WBEM_E_NOT_FOUND ;
		}
	}

	return hRetCode ;
}
#endif

/////////////////////////////////////////////////////////////////////////////
//
// Function:   CWin32GroupAccount::GetDomainGroupsNT
//
// Obtains Group Names for all Groups in the specified domain.  If no
// domain is specified, then we assume the local machine.
//
// Inputs:     CNetAPI32      netapi - network api functions.
//          LPCTSTR        pszDomain - Domain to retrieve Groups from.
//          MethodContext* pMethodContext - Method Context
//
// Outputs: None.
//
// Returns: TRUE/FALSE     Success/Failure
//
// Comments:
//
/////////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
HRESULT CWin32GroupAccount::GetDomainGroupsNT( CNetAPI32& netapi, LPCWSTR wstrDomain, MethodContext* pMethodContext )
{
   BOOL fGotDC   = TRUE;
   CHString chstrDCName;
   NET_DISPLAY_GROUP *pDomainGroupData = NULL;
   //CHString strComputerName;
   DWORD i;
   HRESULT hr = WBEM_S_NO_ERROR;
   bool fLookupSidLocally = true;

   // When the computer name is the same as the domain name, that's the local accounts
   //strComputerName = GetLocalComputerName();
   WCHAR wstrLocalComputerName[MAX_COMPUTERNAME_LENGTH+1];
   DWORD dwNameSize = MAX_COMPUTERNAME_LENGTH+1;
   ZeroMemory(wstrLocalComputerName,sizeof(wstrLocalComputerName));

	if(!ProviderGetComputerName( wstrLocalComputerName, &dwNameSize ) )
	{
		if ( ERROR_ACCESS_DENIED == ::GetLastError () )
		{
			return WBEM_E_ACCESS_DENIED;
		}
		else
		{
			return WBEM_E_FAILED;
		}
	}

   if (wcscmp(wstrLocalComputerName, wstrDomain) != 0)
   {
      fGotDC = (netapi.GetDCName( wstrDomain, chstrDCName ) == ERROR_SUCCESS);
      fLookupSidLocally = false;
   }


   try
   {
	   if ( fGotDC )
	   {

		  DWORD       dwNumReturnedEntries = 0,
			 dwIndex = 0;
		  NET_API_STATUS stat;
		  CInstancePtr pInstance ;

		  // Global groups
		  //==============
		  dwIndex = 0;

		  do {

			 // Get a bunch of groups at once
			 stat = netapi.NetQueryDisplayInformation(_bstr_t((LPCWSTR)chstrDCName),
				3,
				dwIndex,
				16384,
				256000,
				&dwNumReturnedEntries,
				(PVOID*) &pDomainGroupData) ;

			 if (stat != NERR_Success && stat != ERROR_MORE_DATA)
				{
					if (stat == ERROR_ACCESS_DENIED)
						return WBEM_E_ACCESS_DENIED;
					else if (stat == ERROR_NO_SUCH_ALIAS)
						return WBEM_E_NOT_FOUND;
					else
						return WBEM_E_FAILED;
			 }

			 // Make instances for all the returned groups
			 for(i = 0 ; (i < dwNumReturnedEntries) && (SUCCEEDED(hr)) ; i++)
			 {
				pInstance.Attach ( CreateNewInstance(pMethodContext) ) ;
				if ( pInstance != NULL )
				{
					bool t_Resolved = GetSIDInformationW (
						
						wstrDomain,
                        pDomainGroupData[i].grpi3_name,
                        fLookupSidLocally ? wstrLocalComputerName : chstrDCName,
                        pInstance,
						false
					);
                    
					if ( t_Resolved )
					{
						pInstance->SetWCHARSplat(IDS_Description, pDomainGroupData[i].grpi3_comment);
						pInstance->SetCharSplat(IDS_Status, IDS_STATUS_OK);
						pInstance->Setbool(L"LocalAccount", false);

						hr = pInstance->Commit () ;
					}
				}
			 }

			 // The index for continuing the search is stored in the last entry
			 if ( dwNumReturnedEntries != 0 ) {
				dwIndex = pDomainGroupData[dwNumReturnedEntries-1].grpi3_next_index;
			 }
		  } while ((stat == ERROR_MORE_DATA) && (hr != WBEM_E_CALL_CANCELLED)) ;

	   }  // IF fGotDC
   }
   catch ( ... )
   {
		if ( pDomainGroupData )
		{
			netapi.NetApiBufferFree ( pDomainGroupData ) ;
			pDomainGroupData = NULL ;
		}

		throw ;
   }

	if ( pDomainGroupData )
	{
		netapi.NetApiBufferFree ( pDomainGroupData ) ;
		pDomainGroupData = NULL ;
	}

  return hr;
}
#endif

/////////////////////////////////////////////////////////////////////////////
//
// Function:   CWin32GroupAccount::GetSingleGroupNT
//
// Obtains the Group name from the specified domain (which can be the
// local workstation)
//
// Inputs:     CNetAPI32      netapi - network api functions.
//          CInstance*     pInstance - Instance to get.
//
// Outputs: None.
//
// Returns: TRUE/FALSE     Success/Failure
//
// Comments:   No special access is necessary here.  We just need to make sure
//          we are able to get the appropriate domain controller.
//
/////////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
HRESULT CWin32GroupAccount::GetSingleGroupNT(CInstance* pInstance )
{
	HRESULT     hReturn = WBEM_E_NOT_FOUND;
	CHString    chstrDCName;
	//CHString strDomainName,
    //  strGroupName,
    //  strComputerName;
    WCHAR* wstrDomainName = NULL;
    WCHAR* wstrGroupName = NULL;
    //WCHAR wstrComputerName[_MAX_PATH];

	CNetAPI32 netapi;

    //ZeroMemory(wstrComputerName,sizeof(wstrComputerName));

    WCHAR wstrLocalComputerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD dwNameSize = MAX_COMPUTERNAME_LENGTH+1;
    ZeroMemory(wstrLocalComputerName,sizeof(wstrLocalComputerName));

	if(!ProviderGetComputerName( wstrLocalComputerName, &dwNameSize ) )
	{
		if ( ERROR_ACCESS_DENIED == ::GetLastError () )
		{
			return WBEM_E_ACCESS_DENIED;
		}
		else
		{
			return WBEM_E_FAILED;
		}
	}

    _bstr_t bstrtDomainName ;
	pInstance->GetWCHAR( IDS_Domain, &wstrDomainName );

    try
    {
	    bstrtDomainName = wstrDomainName;
    }
    catch ( ... )
    {
        free (wstrDomainName);
        throw ;
    }
    free (wstrDomainName);
    wstrDomainName = NULL;

    _bstr_t bstrtGroupName;
	pInstance->GetWCHAR( IDS_Name, &wstrGroupName );

    try
    {
	    bstrtGroupName = wstrGroupName;
    }
    catch ( ... )
    {
        free(wstrGroupName);
        throw ;
    }
    free(wstrGroupName);
    wstrGroupName = NULL;

	if ((!bstrtDomainName || !bstrtGroupName))
    {
		//hReturn = WBEM_E_INVALID_OBJECT_PATH; // domain name can be empty, as in the case of the Everyone group, and other well known RIDs, which systemaccount will pick up, so report back not found from this routine, not invalid object path.
        hReturn = WBEM_E_NOT_FOUND;
    }
    if (wcslen(bstrtDomainName)==0 || wcslen(bstrtGroupName)==0)
    {
		//hReturn = WBEM_E_INVALID_OBJECT_PATH; // domain name can be empty, as in the case of the Everyone group, and other well known RIDs, which systemaccount will pick up, so report back not found from this routine, not invalid object path.
        hReturn = WBEM_E_NOT_FOUND;
    }
	else if (netapi.Init() != ERROR_SUCCESS)
    {
		hReturn = WBEM_E_FAILED;
    }
	else // everything is in order, let's go!
	{
        // See if we want local or domain accounts
        if(_wcsicmp(bstrtDomainName,wstrLocalComputerName)!=0)
        {
		    // We have either a remote group , or an NT well-known-group (local).
            // Get the domain controller name; if that fails, we will see if it is a well-known-group...
            CHString chstrNTAUTHORITY;
			CHString chstrBuiltIn;
    
            if(!GetLocalizedNTAuthorityString(chstrNTAUTHORITY) || !GetLocalizedBuiltInString(chstrBuiltIn))
            {
                hReturn = WBEM_E_FAILED;
            }
            else
            {
		        if((_wcsicmp(bstrtDomainName, chstrBuiltIn) != 0)  &&
                    (_wcsicmp(bstrtDomainName, (LPCWSTR)chstrNTAUTHORITY) != 0)
                    && (netapi.GetDCName( bstrtDomainName, chstrDCName ) == ERROR_SUCCESS))
		        {
                    pInstance->Setbool(L"LocalAccount", false);

			        GROUP_INFO_1*  pGroupInfo = NULL ;
				    try
				    {
						// Add LocalGroup check
					    if ( ERROR_SUCCESS == netapi.NetGroupGetInfo( chstrDCName, bstrtGroupName, 1, (LPBYTE*) &pGroupInfo ) )
					    {
						    // Not much to get, but we got it
                            bool t_Resolved = GetSIDInformationW(
								
								bstrtDomainName, 
								bstrtGroupName, 
								chstrDCName, 
								pInstance,
								false 
							);

							if ( t_Resolved )
							{
								pInstance->SetWCHARSplat(IDS_Description, pGroupInfo->grpi1_comment);
								pInstance->SetCharSplat(IDS_Status, IDS_STATUS_OK);
								hReturn = WBEM_S_NO_ERROR;

							}
							else
							{
							    hReturn = WBEM_S_FALSE;
							}
					    }
						else
						{
							LOCALGROUP_INFO_1 *pLocalGroupInfo = NULL ;
							if ( ERROR_SUCCESS == netapi.NetLocalGroupGetInfo(chstrDCName,bstrtGroupName,1, (LPBYTE*)& pLocalGroupInfo) )
							{
								try
								{
									bool t_Resolved = GetSIDInformationW (
										
										bstrtDomainName, 
										bstrtGroupName, 
										chstrDCName, 
										pInstance,
										false 
									);

									if ( t_Resolved )
									{
										pInstance->SetWCHARSplat(IDS_Description, pLocalGroupInfo->lgrpi1_comment);
										pInstance->SetCharSplat(IDS_Status, IDS_STATUS_OK);
										hReturn = WBEM_S_NO_ERROR;
									}
									else
									{
										hReturn = WBEM_S_FALSE;
									}
								}
								catch ( ... )
								{
									if ( pLocalGroupInfo )
									{
										netapi.NetApiBufferFree( pLocalGroupInfo);
										pLocalGroupInfo = NULL ;
									}

									throw ;
								}

								netapi.NetApiBufferFree( pLocalGroupInfo);
								pLocalGroupInfo = NULL ;
							}
						}
				    }
				    catch ( ... )
				    {
					    if ( pGroupInfo )
					    {
						    netapi.NetApiBufferFree( pGroupInfo);
						    pGroupInfo = NULL ;
					    }

					    throw ;
				    }

				    // Free the buffer
				    netapi.NetApiBufferFree( pGroupInfo);
				    pGroupInfo = NULL ;

                }
                else
                {
                    // We may have a well known group (e.g., "NT AUTHORITY").  Check if we do...
                    // Commented out because Win32_Account and its children don't
                    // refer to well known groups with the domain being anything other
                    // than the machine name (when Win32_Account is enumerated, these
                    // accounts show up under Win32_SystemAccount - this class doesn't
                    // return them - and Win32_SystemAccount specifies the domain as
                    // the local machine name).
                    /*
                    CSid sid((LPCWSTR)bstrtDomainName, (LPCWSTR)bstrtGroupName, NULL);
                    if (sid.IsValid() && sid.IsOK())
                    {
                        SID_NAME_USE snu = sid.GetAccountType();
                        if(snu == SidTypeAlias)
                        {
                            // In order to properly set the description, we need to get local group
                            // info on this group.
                            LOCALGROUP_INFO_1	*pLocalGroupInfo = NULL ;
			                NET_API_STATUS		stat;

			                if (ERROR_SUCCESS == (stat = netapi.NetLocalGroupGetInfo(NULL,
				                bstrtGroupName, 1, (LPBYTE*) &pLocalGroupInfo)))
			                {
                                pInstance->SetWCHARSplat(IDS_Description, pLocalGroupInfo->lgrpi1_comment);
					            pInstance->SetCharSplat(IDS_Status, IDS_STATUS_OK);
                                pInstance->SetWCHARSplat(IDS_SID, sid.GetSidStringW());
                                pInstance->SetByte(IDS_SIDType, sid.GetAccountType());
                                pInstance->Setbool(L"LocalAccount", true);
                                // Because we didn't call GetSidInformation (didn't need to), we do still
                                // need to set the caption in this case...
                                _bstr_t bstrtCaption(bstrtDomainName);
                                bstrtCaption += L"\\";
                                bstrtCaption += bstrtGroupName;
                                pInstance->SetWCHARSplat(IDS_Caption, (WCHAR*) bstrtCaption);
                                hReturn = WBEM_S_NO_ERROR;
                            }
                        }
                        else if(snu == SidTypeWellKnownGroup)
                        {
                            pInstance->SetWCHARSplat(IDS_Description, L"Well known group");
					        pInstance->SetCharSplat(IDS_Status, IDS_STATUS_OK);
                            pInstance->SetWCHARSplat(IDS_SID, sid.GetSidStringW());
                            pInstance->SetByte(IDS_SIDType, sid.GetAccountType());
                            pInstance->Setbool(L"LocalAccount", true);
                            // Because we didn't call GetSidInformation (didn't need to), we do still
                            // need to set the caption in this case...
                            _bstr_t bstrtCaption(bstrtDomainName);
                            bstrtCaption += L"\\";
                            bstrtCaption += bstrtGroupName;
                            pInstance->SetWCHARSplat(IDS_Caption, (WCHAR*) bstrtCaption);
                            hReturn = WBEM_S_NO_ERROR;
                        }
                    }*/
                }
            }
        }
		else
		{
            pInstance->Setbool(L"LocalAccount", true);

            LOCALGROUP_INFO_1	*pLocalGroupInfo = NULL ;
			NET_API_STATUS		stat;

			if (ERROR_SUCCESS == (stat = netapi.NetLocalGroupGetInfo(NULL,
				bstrtGroupName, 1, (LPBYTE*) &pLocalGroupInfo)))
			{
				try
				{
				    GetSIDInformationW (
						
						wstrLocalComputerName, 
						bstrtGroupName, 
						wstrLocalComputerName, 
						pInstance,
						true
					);

					pInstance->SetWCHARSplat(IDS_Description, pLocalGroupInfo->lgrpi1_comment);
					pInstance->SetCharSplat(IDS_Status, IDS_STATUS_OK);
                    hReturn = WBEM_S_NO_ERROR;
				}
				catch ( ... )
				{
					if ( pLocalGroupInfo )
					{
						netapi.NetApiBufferFree ( pLocalGroupInfo );
						pLocalGroupInfo = NULL ;
					}
					throw ;
				}

				netapi.NetApiBufferFree( pLocalGroupInfo);
				pLocalGroupInfo = NULL ;
			}
			else
			{
                if (stat == ERROR_NO_SUCH_ALIAS || stat == NERR_GroupNotFound)
					hReturn = WBEM_E_NOT_FOUND;
				else
					hReturn = WinErrorToWBEMhResult(stat);
			}
		}
	}
	return hReturn;
}
#endif



/////////////////////////////////////////////////////////////////////////////
//
// Function:   CWin32GroupAccount::GetSIDInformation
//
// Obtains the SID Information for the group.
//
// Inputs:     CHString&      strDomainName - Domain Name.
//          CHString&      strAccountName - Account Name
//          CHString&      strComputerName - Computer Name
//          CInstance*     pInstance - Instance to put values in.
//
// Outputs: None.
//
// Returns: TRUE/FALSE     Success/Failure
//
// Comments:   Call for valid groups to get SID data.
//
/////////////////////////////////////////////////////////////////////////////
#ifdef NTONLY
BOOL CWin32GroupAccount::GetSIDInformationW(const LPCWSTR wstrDomainName,
                                            const LPCWSTR wstrAccountName,
                                            const LPCWSTR wstrComputerName,
                                            CInstance* pInstance,
											bool a_Local
											)
{
    BOOL  fReturn = FALSE;
    bool fDomainIsBuiltin = false;

    // Ignore Domain if it's the local machine.
    // Make sure we got the SID and it's all okey dokey
    if(wstrDomainName != NULL)
    {
       CSid  sid( wstrDomainName, wstrAccountName, wstrComputerName);

       // If that didn't work, see if this is a built-in account
       if (sid.GetError() == ERROR_NONE_MAPPED)
       {
			CHString chstrBuiltIn;

			if (GetLocalizedBuiltInString(chstrBuiltIn))
			{
				sid = CSid(chstrBuiltIn, wstrAccountName, wstrComputerName);
				if (sid.IsValid() && sid.IsOK())
				{
					fDomainIsBuiltin = true;
				}
			}

       }

       // barring that, try it without specifying the domain (let the os find it)...
       if (sid.GetError() == ERROR_NONE_MAPPED)
       {
            sid = CSid(NULL, wstrAccountName, wstrComputerName);
       }

       if (sid.IsValid() && sid.IsOK())
       {
            fReturn = TRUE;

            pInstance->SetWCHARSplat(IDS_SID, sid.GetSidStringW());
            pInstance->SetByte(IDS_SIDType, sid.GetAccountType());
            // Setting the domain and name here assures that their values are
            // in synch with the returned sid info. Same for caption.
            if(!fDomainIsBuiltin)
            {
                pInstance->SetCHString(IDS_Domain, wstrDomainName);
                _bstr_t bstrtCaption(wstrDomainName);
                bstrtCaption += L"\\";
                bstrtCaption += wstrAccountName;
                pInstance->SetWCHARSplat(IDS_Caption, (WCHAR*) bstrtCaption);
            }
            else
            {
				if ( a_Local )
				{
					pInstance->SetCHString(IDS_Domain, wstrComputerName);
					_bstr_t bstrtCaption(wstrComputerName);
					bstrtCaption += L"\\";
					bstrtCaption += wstrAccountName;
					pInstance->SetWCHARSplat(IDS_Caption, (WCHAR*) bstrtCaption);
				}
				else
				{
					fReturn = false ;
				}
            }
            pInstance->SetCHString(IDS_Name, wstrAccountName);
       }
    }
    return fReturn;
}
#endif


/////////////////////////////////////////////////////////////////////////////
//
// Function:   CWin32GroupAccount::GetLocalGroupsNT
//
// Obtains Group Names for local groups (including 'special' groups).
//
// Inputs:     CNetAPI32      netapi - network api functions.
//          MethodContext* pMethodContext - Method Context
//
// Outputs: None.
//
// Returns: TRUE/FALSE     Success/Failure
//
// Comments:
//
/////////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
HRESULT CWin32GroupAccount::GetLocalGroupsNT(
	
	CNetAPI32& netapi, 
	MethodContext* pMethodContext ,
	LPCWSTR a_Domain
)
{
    HRESULT hr=WBEM_S_NO_ERROR;
    NET_API_STATUS stat;
    DWORD i;
    LOCALGROUP_INFO_1 *pLocalGroupData = NULL;
    DWORD dwNumReturnedEntries = 0,
          dwMaxEntries;

	DWORD_PTR dwptrResume = NULL;

    CInstancePtr pInstance;
//    WKSTA_INFO_100 *pstInfo;

    // Get Domain name
//    netapi.NetWkstaGetInfo(NULL, 100, (LPBYTE *)&pstInfo);

	CHString chstrDCName ;

	LPCWSTR t_Server = NULL ;
	if ( a_Domain )
	{
		bool fGotDC = (netapi.GetDCName( a_Domain, chstrDCName ) == ERROR_SUCCESS);
		if ( fGotDC )
		{
			t_Server = chstrDCName ;
		}
	}

    // Local groups
    //=============
	try
	{
		do
		{
			// Local groups are returned from a different call than Global groups
			stat = netapi.NetLocalGroupEnum(t_Server,
											1,
											(LPBYTE *) &pLocalGroupData,
											262144,
											&dwNumReturnedEntries,
											&dwMaxEntries,
											&dwptrResume) ;

			if (stat != NERR_Success && stat != ERROR_MORE_DATA)
			{
					if (stat == ERROR_ACCESS_DENIED)
						hr = WBEM_E_ACCESS_DENIED;
					else
						hr = WBEM_E_FAILED;
			}

			// Make instances for all the returned groups
			WCHAR wstrLocalComputerName[MAX_COMPUTERNAME_LENGTH+1];
			DWORD dwNameSize = MAX_COMPUTERNAME_LENGTH+1;
			ZeroMemory(wstrLocalComputerName,sizeof(wstrLocalComputerName));

			if(!ProviderGetComputerName( wstrLocalComputerName, &dwNameSize ) )
			{
				if ( ERROR_ACCESS_DENIED == ::GetLastError () )
				{
					return WBEM_E_ACCESS_DENIED;
				}
				else
				{
					return WBEM_E_FAILED;
				}
			}

			_bstr_t bstrtCaption;
			for(i = 0 ; ((i < dwNumReturnedEntries) && (SUCCEEDED(hr))) ; i++)
			{
				pInstance.Attach ( CreateNewInstance(pMethodContext) ) ;
				if (pInstance != NULL )
				{
					bool t_Resolved = GetSIDInformationW(
						
						a_Domain?a_Domain:wstrLocalComputerName,
						pLocalGroupData[i].lgrpi1_name,
						a_Domain?t_Server:wstrLocalComputerName,
						pInstance,
						a_Domain?false:true
					);

					if ( t_Resolved )
					{
						pInstance->SetWCHARSplat(IDS_Description, pLocalGroupData[i].lgrpi1_comment);
						pInstance->SetCharSplat(IDS_Status, IDS_STATUS_OK);
						pInstance->Setbool(L"LocalAccount", a_Domain?false:true);
						hr = pInstance->Commit () ;
					}
				}
			}

			if ( pLocalGroupData )
			{
				netapi.NetApiBufferFree ( pLocalGroupData ) ;
				pLocalGroupData = NULL ;
			}

		} while ((stat == ERROR_MORE_DATA) && (hr != WBEM_E_CALL_CANCELLED));

	//    netapi.NetApiBufferFree(pstInfo);
	}
	catch ( ... )
	{
		if ( pLocalGroupData )
		{
			netapi.NetApiBufferFree ( pLocalGroupData ) ;
			pLocalGroupData = NULL ;
		}
		throw ;
	}

	return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\ide.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  IDE.cpp
//
//  Purpose: IDE Controller property set provider
//
//***************************************************************************

#include "precomp.h"
#include "LPVParams.h"
#include <FRQueryEx.h>

#include "IDE.h"

// Property set declaration
//=========================

CWin32IDE MyIDEController( PROPSET_NAME_IDE, IDS_CimWin32Namespace );

/*****************************************************************************
 *
 *  FUNCTION    : CWin32IDE::CWin32IDE
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32IDE :: CWin32IDE (

	LPCWSTR strName,
	LPCWSTR pszNamespace

) : Provider( strName, pszNamespace )
{
    m_ptrProperties.SetSize(13);
    m_ptrProperties[0] = ((LPVOID) IDS_ConfigManagerErrorCode);
    m_ptrProperties[1] = ((LPVOID) IDS_ConfigManagerUserConfig);
    m_ptrProperties[2] = ((LPVOID) IDS_Status);
    m_ptrProperties[3] = ((LPVOID) IDS_PNPDeviceID);
    m_ptrProperties[4] = ((LPVOID) IDS_DeviceID);
    m_ptrProperties[5] = ((LPVOID) IDS_SystemCreationClassName);
    m_ptrProperties[6] = ((LPVOID) IDS_SystemName);
    m_ptrProperties[7] = ((LPVOID) IDS_Description);
    m_ptrProperties[8] = ((LPVOID) IDS_Caption);
    m_ptrProperties[9] = ((LPVOID) IDS_Name);
    m_ptrProperties[10] = ((LPVOID) IDS_Manufacturer);
    m_ptrProperties[11] = ((LPVOID) IDS_ProtocolSupported);
    m_ptrProperties[12] = ((LPVOID) IDS_CreationClassName);
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32IDE::~CWin32IDE
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32IDE::~CWin32IDE()
{
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32IDE::GetObject
//
//  Inputs:     CInstance*      pInstance - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32IDE::GetObject
(
    CInstance* pInstance,
    long lFlags,
    CFrameworkQuery& pQuery
)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    // Let's see if config manager recognizes this device at all
    CHString sDeviceID;
    pInstance->GetCHString(IDS_DeviceID, sDeviceID);

    CConfigManager cfgmgr;

    CConfigMgrDevicePtr pDevice;
    if(cfgmgr.LocateDevice(sDeviceID, pDevice))
    {
		// OK, it knows about it.  Is it a IDEController?
		if ( IsOneOfMe ( pDevice ) )
		{
            CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);
            DWORD dwProperties;
            pQuery2->GetPropertyBitMask(m_ptrProperties, &dwProperties);

			hr = LoadPropertyValues (

					&CLPVParams (

						pInstance,
						pDevice,
						dwProperties
					)
			) ;
		}
    }
	else
	{
		if ( ERROR_ACCESS_DENIED == ::GetLastError() )
		{
			hr = WBEM_E_ACCESS_DENIED;
		}
	}

    return hr ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32IDE::ExecQuery
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//              CFrameworkQuery& the query object
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32IDE::ExecQuery
(
    MethodContext* pMethodContext,
    CFrameworkQuery& pQuery,
    long lFlags
)
{
    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);
    DWORD dwProperties;
    pQuery2->GetPropertyBitMask(m_ptrProperties, &dwProperties);

    return Enumerate(pMethodContext, lFlags, dwProperties);
}


////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32IDE::EnumerateInstances
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32IDE::EnumerateInstances
(
    MethodContext* pMethodContext,
    long lFlags /*= 0L*/
)
{
    return Enumerate(pMethodContext, lFlags);
}



////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32IDE::Enumerate
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32IDE::Enumerate
(
    MethodContext* pMethodContext,
    long lFlags,
    DWORD dwReqProps
)
{
    HRESULT hr = WBEM_E_FAILED;

    CConfigManager cfgManager;
    CDeviceCollection deviceList;

    // While it might be more performant to use FilterByGuid, it appears that
    // at least some
    // 95 boxes will report IDE info if we do it this way.
    if ( cfgManager.GetDeviceListFilterByClass( deviceList, L"hdc" ) )
    {
        REFPTR_POSITION pos;

        if ( deviceList.BeginEnum( pos ) )
        {
            hr = WBEM_S_NO_ERROR;

            // Walk the list
            CConfigMgrDevicePtr pDevice;
            for (pDevice.Attach(deviceList.GetNext(pos));
                 SUCCEEDED(hr) && (pDevice != NULL);
                 pDevice.Attach(deviceList.GetNext(pos)))
            {
				// Now to find out if this is the IDE controller
				if (IsOneOfMe(pDevice))
				{
					CInstancePtr pInstance (CreateNewInstance ( pMethodContext ), false) ;
					if((hr = LoadPropertyValues(&CLPVParams(pInstance, pDevice, dwReqProps))) == WBEM_S_NO_ERROR)
					{
						// Derived classes (like CW32IDECntrlDev) may
						// commit as result of call to LoadPropertyValues,
						// so check if we should -> only do so if we are
						// of this class's type.

						if ( ShouldBaseCommit ( NULL ) )
						{
							hr = pInstance->Commit(  );
						}
					}
				}
            }

            // Always call EndEnum().  For all Beginnings, there must be an End
            deviceList.EndEnum();
        }
    }
	else
	{
		if ( ERROR_ACCESS_DENIED == ::GetLastError() )
		{
			hr = WBEM_E_ACCESS_DENIED;
		}
	}

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32IDE::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance* pInstance - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32IDE::LoadPropertyValues
(
    void* a_pv
)
{
    HRESULT t_hr = WBEM_S_NO_ERROR;
    CHString t_chstrDeviceID, t_chstrDesc, t_chstrTemp;

    /*************************************
    * Unpack and confirm our parameters...
    *************************************/
    CLPVParams* t_pData = (CLPVParams*)a_pv;
    CInstance* t_pInstance = (CInstance*)(t_pData->m_pInstance); // This instance released by caller
    CConfigMgrDevice* t_pDevice = (CConfigMgrDevice*)(t_pData->m_pDevice);
    DWORD t_dwReqProps = (DWORD)(t_pData->m_dwReqProps);

    if(t_pInstance == NULL || t_pDevice == NULL)
    {
        return WBEM_E_PROVIDER_FAILURE;
    }


    /***********************
    * Set the key properties
    ***********************/

    t_pDevice->GetDeviceID(t_chstrDeviceID);
    if(t_chstrDeviceID.GetLength() == 0)
    {
        // We need the device id for the key property of this class.  If we can
        // not obtain it, we can't set the key, which is an unacceptable error.
        return WBEM_E_PROVIDER_FAILURE;
    }
    else
    {
        t_pInstance->SetCHString(IDS_DeviceID, t_chstrDeviceID);
    }


    /*****************************
    * Set IDEController properties
    *****************************/

    if(t_dwReqProps & IDE_PROP_Manufacturer)
    {
        if(t_pDevice->GetMfg(t_chstrTemp))
        {
            t_pInstance->SetCHString(IDS_Manufacturer, t_chstrTemp);
        }
    }


    /*****************************
    * Set CIMController properties
    *****************************/

    // Fixed value from enumerated list
    if(t_dwReqProps & IDE_PROP_ProtocolSupported)
    {
        t_pInstance->SetWBEMINT16(IDS_ProtocolSupported, 37);
    }


    /*********************************
    * Set CIM_LogicalDevice properties
    *********************************/

    if(t_dwReqProps & IDE_PROP_PNPDeviceID)
    {
        t_pInstance->SetCHString(IDS_PNPDeviceID, t_chstrDeviceID);
    }
    if(t_dwReqProps & IDE_PROP_SystemCreationClassName)
    {
        t_pInstance->SetCHString(IDS_SystemCreationClassName,
                                 IDS_Win32ComputerSystem);
    }
    if(t_dwReqProps & IDE_PROP_CreationClassName)
    {
        SetCreationClassName(t_pInstance);
    }
    if(t_dwReqProps & IDE_PROP_SystemCreationClassName)
    {
        t_pInstance->SetCHString(IDS_SystemCreationClassName,
                                 IDS_Win32ComputerSystem);
    }
    if(t_dwReqProps & IDE_PROP_SystemName)
    {
        t_pInstance->SetCHString(IDS_SystemName, GetLocalComputerName());
    }

    if( t_dwReqProps & (IDE_PROP_Description | IDE_PROP_Caption | IDE_PROP_Name) )
    {
        if(t_pDevice->GetDeviceDesc(t_chstrDesc))
        {
            t_pInstance->SetCHString(IDS_Description, t_chstrDesc);
        }
    }

    if(t_dwReqProps & IDE_PROP_ConfigManagerErrorCode ||
       t_dwReqProps & IDE_PROP_Status)
    {
        DWORD t_dwStatus = 0L;
        DWORD t_dwProblem = 0L;
        if(t_pDevice->GetStatus(&t_dwStatus, &t_dwProblem))
        {
            if(t_dwReqProps & IDE_PROP_ConfigManagerErrorCode)
            {
                t_pInstance->SetDWORD(IDS_ConfigManagerErrorCode, t_dwProblem);
            }
            if(t_dwReqProps & IDE_PROP_Status)
            {
                CHString t_chsTmp;

				ConfigStatusToCimStatus ( t_dwStatus , t_chsTmp ) ;
                t_pInstance->SetCHString(IDS_Status, t_chsTmp);
            }
        }
    }

    if(t_dwReqProps & IDE_PROP_ConfigManagerUserConfig)
    {
        t_pInstance->SetDWORD(IDS_ConfigManagerUserConfig,
                              t_pDevice->IsUsingForcedConfig());
    }

    // Use the friendly name for caption and name
    if(t_dwReqProps & IDE_PROP_Caption || t_dwReqProps & IDE_PROP_Name)
    {
        if(t_pDevice->GetFriendlyName(t_chstrTemp))
        {
            t_pInstance->SetCHString(IDS_Caption, t_chstrTemp);
            t_pInstance->SetCHString(IDS_Name, t_chstrTemp);
        }
        else
        {
            // If we can't get the name, settle for the description
            if(t_chstrDesc.GetLength() > 0)
            {
                t_pInstance->SetCHString(IDS_Caption, t_chstrDesc);
                t_pInstance->SetCHString(IDS_Name, t_chstrDesc);
            }
        }
    }
    return t_hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32IDE::IsOneOfMe
 *
 *  DESCRIPTION : Checks to make sure pDevice is a controller, and not some
 *                other type of IDE device.
 *
 *  INPUTS      : CConfigMgrDevice* pDevice - The device to check.  It is
 *                assumed that the caller has ensured that the device is a
 *                valid IDE class device.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
bool CWin32IDE::IsOneOfMe
(
    void* pv
)
{
    bool fRet = false;

    if(pv != NULL)
    {
        CConfigMgrDevice* pDevice = (CConfigMgrDevice*) pv;
        // Ok, it knows about it.  Is it a IDE device?

        fRet = pDevice->IsClass(L"hdc");
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\ide.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  IDE.h
//
//  Purpose: IDE Controller property set provider
//
//***************************************************************************

// Property set identification
//============================
#ifndef _IDE_H
#define _IDE_H



#define IDE_ALL_PROPS                    0xFFFFFFFF
#define IDE_KEY_ONLY                     0x00000010
#define IDE_PROP_ConfigManagerErrorCode  0x00000001
#define IDE_PROP_ConfigManagerUserConfig 0x00000002
#define IDE_PROP_Status                  0x00000004
#define IDE_PROP_PNPDeviceID             0x00000008
#define IDE_PROP_DeviceID                0x00000010
#define IDE_PROP_SystemCreationClassName 0x00000020
#define IDE_PROP_SystemName              0x00000040
#define IDE_PROP_Description             0x00000080
#define IDE_PROP_Caption                 0x00000100
#define IDE_PROP_Name                    0x00000200
#define IDE_PROP_Manufacturer            0x00000400
#define IDE_PROP_ProtocolSupported       0x00000800
#define IDE_PROP_CreationClassName       0x00001000





#define	PROPSET_NAME_IDE	L"Win32_IDEController"

class CWin32IDE : virtual public Provider
{
    private:
        CHPtrArray m_ptrProperties;

    protected:

        virtual bool IsOneOfMe
        (
            void* a_pv
        );

        virtual HRESULT LoadPropertyValues
        (
            void* a_pv
        );

        virtual bool ShouldBaseCommit
        (
            void* a_pvData
        );

        HRESULT Enumerate
        (
            MethodContext* a_pMethodContext, 
            long a_lFlags, 
            DWORD a_dwReqProps = IDE_ALL_PROPS
        );

    public:

        // Constructor/destructor
        //=======================

        CWin32IDE
        (
            LPCWSTR a_strName, 
            LPCWSTR a_pszNamespace
        );

        ~CWin32IDE();

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject
        (
            CInstance* a_pInstance, 
            long a_lFlags,
            CFrameworkQuery& pQuery
        );

        virtual HRESULT ExecQuery
        (
            MethodContext* a_pMethodContext, 
            CFrameworkQuery& a_pQuery, 
            long a_Flags = 0L 
        );

        virtual HRESULT EnumerateInstances
        (
            MethodContext* a_pMethodContext, 
            long a_lFlags = 0L
        );        
} ;

// This is the base; it should always commit in the base.
inline bool CWin32IDE::ShouldBaseCommit
(
    void* pvData
)
{ 
    return true; 
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\infrared.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  InfraRed.h
//
//  Purpose: InfraRed Controller property set provider
//
//***************************************************************************

// Property set identification
//============================

#define	PROPSET_NAME_INFRARED	L"Win32_InfraredDevice"

#define SPECIAL_PROPS_ALL_REQUIRED          0xFFFFFFFF
#define SPECIAL_PROPS_NONE_REQUIRED         0x00000000
#define SPECIAL_PROPS_STATUS				0x00000004
#define SPECIAL_PROPS_DEVICEID				0x00000008
#define SPECIAL_PROPS_CREATIONNAME			0x00000010
#define SPECIAL_PROPS_SYSTEMNAME			0x00000020
#define SPECIAL_PROPS_DESCRIPTION			0x00000040
#define SPECIAL_PROPS_CAPTION				0x00000080
#define SPECIAL_PROPS_NAME					0x00000100
#define SPECIAL_PROPS_MANUFACTURER			0x00000200
#define SPECIAL_PROPS_PROTOCOLSSUPPORTED	0x00000400
#define SPECIAL_PROPS_PNPDEVICEID			0x00400000
#define SPECIAL_PROPS_CONFIGMERRORCODE		0x00800000
#define SPECIAL_PROPS_CONFIGMUSERCONFIG		0x01000000
#define SPECIAL_PROPS_CREATIONCLASSNAME		0x02000000
#define SPECIAL_PROPS_STATUSINFO			0x04000000
#define SPECIAL_PROPS_AVAILABILITY			0x08000000


#define SPECIAL_ALL					( SPECIAL_CONFIGMANAGER )

#define SPECIAL_CONFIGMANAGER		( SPECIAL_PROPS_STATUS | \
									SPECIAL_PROPS_DEVICEID | \
									SPECIAL_PROPS_CREATIONNAME | \
									SPECIAL_PROPS_SYSTEMNAME | \
									SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME | \
									SPECIAL_PROPS_MANUFACTURER | \
									SPECIAL_PROPS_PROTOCOLSSUPPORTED | \
									SPECIAL_PROPS_PNPDEVICEID | \
									SPECIAL_PROPS_CONFIGMERRORCODE | \
									SPECIAL_PROPS_CONFIGMUSERCONFIG | \
									SPECIAL_PROPS_CREATIONCLASSNAME | \
									SPECIAL_PROPS_STATUS | \
									SPECIAL_PROPS_STATUSINFO | \
									SPECIAL_PROPS_AVAILABILITY )

#define SPECIAL_CONFIGPROPERTIES 	( SPECIAL_PROPS_PNPDEVICEID | \
									SPECIAL_PROPS_CONFIGMERRORCODE | \
									SPECIAL_PROPS_CONFIGMUSERCONFIG | \
									SPECIAL_PROPS_STATUS | \
									SPECIAL_PROPS_STATUSINFO | \
									SPECIAL_PROPS_AVAILABILITY )

#define SPECIAL_DESC_CAP_NAME		( SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define SPECIAL_DESC_CAP_NAME		( SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define SPECIAL_CAP_NAME			( SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3
#define SEV_MASK 0xC0000000

class CWin32_InfraRed : public Provider
{
    public:

        // Constructor/destructor
        //=======================

        CWin32_InfraRed ( LPCWSTR a_Name , LPCWSTR a_Namespace ) ;

       ~CWin32_InfraRed() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject ( CInstance *a_Instance , long lFlags , CFrameworkQuery &a_Query ) ;
		HRESULT ExecQuery ( MethodContext *a_MethodContext, CFrameworkQuery &a_Query, long a_Flags ) ;
        virtual HRESULT EnumerateInstances ( MethodContext *a_MethodContext , long a_Flags = 0L ) ;

    private:

        // Utility function(s)
        //====================

		HRESULT Enumerate ( 

			MethodContext *a_MethodContext , 
			long a_Flags , 
			DWORD a_SpecifiedPropertied = SPECIAL_PROPS_ALL_REQUIRED
		) ;

        HRESULT LoadPropertyValues ( 

			CInstance *a_Instance , 
			CConfigMgrDevice *a_Device , 
			const CHString &a_DeviceName , 
			DWORD a_SpecifiedPropertied = SPECIAL_PROPS_ALL_REQUIRED 
		) ;

        DWORD GetBitMask ( CFrameworkQuery &a_Query );

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\infrared.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  InfraRed.cpp
//
//  Purpose: InfraRed Controller property set provider
//
//***************************************************************************

#include "precomp.h"

#include "InfraRed.h"

// Property set declaration
//=========================

#define CONFIG_MANAGER_CLASS_INFRARED L"InfraRed"

CWin32_InfraRed s_InfraRed ( PROPSET_NAME_INFRARED, IDS_CimWin32Namespace );

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_InfraRed::CWin32_InfraRed
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32_InfraRed :: CWin32_InfraRed (

	LPCWSTR a_Name ,
	LPCWSTR a_Namespace

) : Provider( a_Name, a_Namespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_InfraRed::~CWin32_InfraRed
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32_InfraRed :: ~CWin32_InfraRed ()
{
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_InfraRed::GetObject
//
//  Inputs:     CInstance*      a_Instance - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_InfraRed :: GetObject ( CInstance *a_Instance , long a_Flags , CFrameworkQuery &a_Query )
{
    HRESULT t_Result = WBEM_E_NOT_FOUND ;


    // Let's see if config manager recognizes this device at all

    CHString t_DeviceID;
    a_Instance->GetCHString ( IDS_DeviceID , t_DeviceID ) ;

    CConfigManager t_ConfigurationManager ;
    CConfigMgrDevicePtr t_Device;

    if ( t_ConfigurationManager.LocateDevice ( t_DeviceID , t_Device ) )
    {
		// Ok, it knows about it.  Is it a InfraRed device?

		if ( t_Device->IsClass ( CONFIG_MANAGER_CLASS_INFRARED ) )
		{
			// Last chance, are you sure it's a controller?

			CHString t_Key ;
			a_Instance->GetCHString ( IDS_DeviceID , t_Key ) ;

            DWORD t_SpecifiedProperties = GetBitMask ( a_Query );

			t_Result = LoadPropertyValues ( a_Instance , t_Device , t_Key , t_SpecifiedProperties) ;
		}
    }
	else
	{
		if ( ERROR_ACCESS_DENIED == ::GetLastError() )
		{
			t_Result = WBEM_E_ACCESS_DENIED;
		}
	}

    return t_Result ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_InfraRed::EnumerateInstances
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_InfraRed :: EnumerateInstances ( MethodContext *a_MethodContext , long a_Flags )
{
	HRESULT t_Result = Enumerate ( a_MethodContext , a_Flags ) ;
	return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::ExecQuery
 *
 *  DESCRIPTION : Query optimizer
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32_InfraRed :: ExecQuery ( MethodContext *a_MethodContext, CFrameworkQuery &a_Query, long a_Flags )
{
    HRESULT t_Result = WBEM_E_FAILED ;

    DWORD t_SpecifiedProperties = GetBitMask ( a_Query );
	//if ( t_SpecifiedProperties )  //removed since would result in no query being executed if we didn't ask for any special props.
	{
		t_Result = Enumerate ( a_MethodContext , a_Flags , t_SpecifiedProperties ) ;
	}

    return t_Result ;
}

HRESULT CWin32_InfraRed :: Enumerate ( MethodContext *a_MethodContext , long a_Flags , DWORD a_SpecifiedProperties )
{
    HRESULT t_Result = WBEM_E_FAILED ;

    CConfigManager t_ConfigurationManager ;
    CDeviceCollection t_DeviceList ;

    // While it might be more performant to use FilterByGuid, it appears that at least some
    // 95 boxes will report InfraRed info if we do it this way.

    if ( t_ConfigurationManager.GetDeviceListFilterByClass ( t_DeviceList , CONFIG_MANAGER_CLASS_INFRARED ) )
    {
        REFPTR_POSITION t_Position ;

        if ( t_DeviceList.BeginEnum( t_Position ) )
        {
            CConfigMgrDevicePtr t_Device;

            t_Result = WBEM_S_NO_ERROR ;

            // Walk the list
            for (t_Device.Attach(t_DeviceList.GetNext ( t_Position ) );
                 SUCCEEDED ( t_Result ) && ( t_Device != NULL );
                 t_Device.Attach(t_DeviceList.GetNext ( t_Position ) ))
            {
				// Now to find out if this is the infrared controller

				CHString t_Key ;
				if ( t_Device->GetDeviceID ( t_Key ) )
				{
					CInstancePtr t_Instance (CreateNewInstance ( a_MethodContext ), false) ;
					if ( ( t_Result = LoadPropertyValues ( t_Instance , t_Device , t_Key , a_SpecifiedProperties) ) == WBEM_S_NO_ERROR )
					{
						t_Result = t_Instance->Commit (  ) ;
					}
				}
            }

            // Always call EndEnum().  For all Beginnings, there must be an End

            t_DeviceList.EndEnum () ;
        }
    }
	else
	{
		if ( ERROR_ACCESS_DENIED == ::GetLastError() )
		{
			t_Result = WBEM_E_ACCESS_DENIED;
		}
	}

    return t_Result;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_InfraRed::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance* a_Instance - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32_InfraRed :: LoadPropertyValues (

	CInstance *a_Instance ,
	CConfigMgrDevice *a_Device ,
	const CHString &a_DeviceName ,
	DWORD a_SpecifiedProperties
)
{
    HRESULT t_Result = WBEM_S_NO_ERROR;

/*
 *	 Set PNPDeviceID, ConfigManagerErrorCode, ConfigManagerUserConfig
 */

	if ( a_SpecifiedProperties & SPECIAL_CONFIGPROPERTIES )
	{
		SetConfigMgrProperties ( a_Device, a_Instance ) ;

/*
 * Set the status based on the config manager error code
 */

		if ( a_SpecifiedProperties & ( SPECIAL_PROPS_AVAILABILITY | SPECIAL_PROPS_STATUS | SPECIAL_PROPS_STATUSINFO ) )
		{
            CHString t_sStatus;
			if ( a_Device->GetStatus ( t_sStatus ) )
			{
				if (t_sStatus == IDS_STATUS_Degraded)
                {
					a_Instance->SetWBEMINT16 ( IDS_StatusInfo , 3 ) ;
					a_Instance->SetWBEMINT16 ( IDS_Availability , 10 ) ;
                }
                else if (t_sStatus == IDS_STATUS_OK)
                {

				    a_Instance->SetWBEMINT16 ( IDS_StatusInfo , 3 ) ;
				    a_Instance->SetWBEMINT16 ( IDS_Availability,  3 ) ;
                }
                else if (t_sStatus == IDS_STATUS_Error)
                {
				    a_Instance->SetWBEMINT16 ( IDS_StatusInfo , 4 ) ;
				    a_Instance->SetWBEMINT16 ( IDS_Availability , 4 ) ;
                }
                else
                {
					a_Instance->SetWBEMINT16 ( IDS_StatusInfo , 2 ) ;
					a_Instance->SetWBEMINT16 ( IDS_Availability , 2 ) ;
                }

                a_Instance->SetCHString(IDS_Status, t_sStatus);
			}
		}
	}
/*
 *	Use the PNPDeviceID for the DeviceID (key)
 */

	if ( a_SpecifiedProperties & SPECIAL_PROPS_DEVICEID )
	{
		CHString t_Key ;

		if ( a_Device->GetDeviceID ( t_Key ) )
		{
			a_Instance->SetCHString ( IDS_DeviceID , t_Key ) ;
		}
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CREATIONNAME )
	{
		a_Instance->SetWCHARSplat ( IDS_SystemCreationClassName , L"Win32_ComputerSystem" ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_SYSTEMNAME )
	{
	    a_Instance->SetCHString ( IDS_SystemName , GetLocalComputerName () ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CREATIONCLASSNAME )
	{
		SetCreationClassName ( a_Instance ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_DESC_CAP_NAME )
	{
		CHString t_Description ;
		if ( a_Device->GetDeviceDesc ( t_Description ) )
		{
			if ( a_SpecifiedProperties & SPECIAL_PROPS_DESCRIPTION )
			{
				a_Instance->SetCHString ( IDS_Description , t_Description ) ;
			}
		}

/*
 *	Use the friendly name for caption and name
 */

		if ( a_SpecifiedProperties & SPECIAL_CAP_NAME )
		{
			CHString t_FriendlyName ;
			if ( a_Device->GetFriendlyName ( t_FriendlyName ) )
			{
				if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPTION )
				{
					a_Instance->SetCHString ( IDS_Caption , t_FriendlyName ) ;
				}

				if ( a_SpecifiedProperties & SPECIAL_PROPS_NAME )
				{
					a_Instance->SetCHString ( IDS_Name , t_FriendlyName ) ;
				}
			}
			else
			{
		/*
		 *	If we can't get the name, settle for the description
		 */

				if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPTION )
				{
					a_Instance->SetCHString ( IDS_Caption , t_Description );
				}

				if ( a_SpecifiedProperties & SPECIAL_PROPS_NAME )
				{
					a_Instance->SetCHString ( IDS_Name , t_Description );
				}
			}
		}
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_MANUFACTURER )
	{
		CHString t_Manufacturer ;

		if ( a_Device->GetMfg ( t_Manufacturer ) )
		{
			a_Instance->SetCHString ( IDS_Manufacturer, t_Manufacturer ) ;
		}
	}

/*
 *	Fixed value from enumerated list
 */

	if ( a_SpecifiedProperties & SPECIAL_PROPS_PROTOCOLSSUPPORTED )
	{
	    a_Instance->SetWBEMINT16 ( IDS_ProtocolSupported, 45 ) ;
	}

    return t_Result ;
}

DWORD CWin32_InfraRed :: GetBitMask ( CFrameworkQuery &a_Query )
{
    DWORD t_SpecifiedProperties = SPECIAL_PROPS_NONE_REQUIRED ;

    if ( a_Query.IsPropertyRequired ( IDS_Status ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_StatusInfo ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUSINFO ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_DeviceID ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DEVICEID ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SystemCreationClassName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CREATIONNAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SystemName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SYSTEMNAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Description ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DESCRIPTION ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Caption ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CAPTION ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Name ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_NAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Manufacturer ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_MANUFACTURER ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_ProtocolSupported ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_PROTOCOLSSUPPORTED ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Status ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_CreationClassName ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CREATIONCLASSNAME ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_PNPDeviceID ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_PNPDEVICEID ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ConfigManagerErrorCode ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CONFIGMERRORCODE ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ConfigManagerUserConfig ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CONFIGMUSERCONFIG ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_Availability ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_AVAILABILITY ;
    }

    return t_SpecifiedProperties;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\implement_logicalfile.cpp ===
//=================================================================
//
// Implement_LogicalFile.CPP -- File property set provider
//
//  Copyright (c) 1996-2002 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/14/98    a-kevhu         Created
//
//=================================================================

//NOTE: The CImplement_LogicalFile class is not exposed to the outside world through the mof. It now has implementations
//		of EnumerateInstances & GetObject which were earlier present in CCimLogicalFile. CImplement_LogicalFile can't be
//		instantiated since it has pure virtual declaration of the IsOneOfMe  method which the derived classes  should
//		implement.

#include "precomp.h"
#include <cregcls.h>
#include "file.h"
#include "Implement_LogicalFile.h"
#include "sid.h"
#include "ImpLogonUser.h"
#include <typeinfo.h>
#include <frqueryex.h>
#include <assertbreak.h>
#include <winioctl.h>
#include "CIMDataFile.h"
#include "Directory.h"

#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "aclapi.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"					// CSACL class
#include "securitydescriptor.h"
#include "securefile.h"

#include "accessentrylist.h"
#include <accctrl.h>
#include "AccessRights.h"
#include "ObjAccessRights.h"

#include "AdvApi32Api.h"

/*****************************************************************************
 *
 *  FUNCTION    : CImplement_LogicalFile::CImplement_LogicalFile
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CImplement_LogicalFile::CImplement_LogicalFile(LPCWSTR setName,
                                 LPCWSTR pszNamespace)
    : CCIMLogicalFile(setName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CImplement_LogicalFile::~CImplement_LogicalFile
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CImplement_LogicalFile::~CImplement_LogicalFile()
{
}



CDriveInfo::CDriveInfo()
{
    memset(m_wstrDrive,'\0',sizeof(m_wstrDrive));
    memset(m_wstrFS,'\0',sizeof(m_wstrFS));
}

CDriveInfo::CDriveInfo(WCHAR* wstrDrive, WCHAR* wstrFS)
{
    memset(m_wstrDrive,'\0',sizeof(m_wstrDrive));
    memset(m_wstrFS,'\0',sizeof(m_wstrFS));
    if(wstrDrive != NULL)
    {
        wcsncpy(m_wstrDrive,wstrDrive,(sizeof(m_wstrDrive) - sizeof(WCHAR))/sizeof(WCHAR));

    }
    if(wstrFS != NULL)
    {
        wcsncpy(m_wstrFS,wstrFS,(sizeof(m_wstrFS) - sizeof(WCHAR))/sizeof(WCHAR));
    }
}

CDriveInfo::~CDriveInfo()
{
    long l = 9;   // what?
}


/*****************************************************************************
 *
 *  FUNCTION    : CImplement_LogicalFile::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CImplement_LogicalFile::GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery)
{
    CHString chstrName;
    HRESULT hr = WBEM_E_NOT_FOUND;
    CHString chstrDrive;
    CHString chstrPathName;

    // DEVNOTE: REMOVE FOR QUASAR!!!  Necessary for double hop access.
#ifdef NTONLY
    bool fImp = false;
    CImpersonateLoggedOnUser icu;
    if(icu.Begin())
    {
        fImp = true;
    }
#endif


    // FindFirstFile looks at not only the DACL to
    // decide if a person has access, but at whether
    // that person has the SeTakeOwnershipPrivilege, 
    // because with that privilege, a person can 
    // take ownership and change the security to
    // grant themselves access.  In other words, they
    // have access even though they may not be in
    // the DACL yet, as they are able to change the
    // DACL by making themselves the owner.  Hence
    // the following call...
    EnablePrivilegeOnCurrentThread(SE_BACKUP_NAME);


    pInstance->GetCHString(IDS_Name, chstrName);

    //if(pwcName != NULL)
    if(chstrName.GetLength() > 0)
    {
        if ((chstrName.Find(L':') != -1) &&
            (wcspbrk((LPCWSTR)chstrName,L"?*") == NULL)) //don't want files with wildchars
	    {
            chstrDrive = chstrName.SpanExcluding(L":");
            chstrDrive += L":";
            chstrPathName = chstrName.Mid(chstrDrive.GetLength());

            // Determine whether certain other expensive properties are required:
            DWORD dwReqProps = PROP_NO_SPECIAL;
            DetermineReqProps(pQuery, &dwReqProps);

#ifdef NTONLY
		    {
			    if(chstrPathName.GetLength() == 1) // that is, the pathname is just "\", looking at root, so, actually, no path, or filename
                {
                    hr = FindSpecificPathNT(pInstance, chstrDrive, L"", dwReqProps);
                }
                else
                {
                    hr = FindSpecificPathNT(pInstance, chstrDrive, chstrPathName, dwReqProps);
                }
		    }
#endif
        }
	}

#ifdef NTONLY
    if(fImp)
    {
        icu.End();
        fImp = false;
    }
#endif

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CImplement_LogicalFile::ExecQuery
 *
 *  DESCRIPTION : Analyses query and returns appropriate instances
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CImplement_LogicalFile::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ )
{
    std::vector<_bstr_t> vectorNames;  // these are fully qualified path\name.extensions
    std::vector<_bstr_t> vectorDrives;
    std::vector<_bstr_t> vectorPaths;
    std::vector<_bstr_t> vectorFilenames;
    std::vector<_bstr_t> vectorExtensions;
    std::vector<_bstr_t> vector8dot3;
    LONG x;
    LONG y;
    DWORD dwNames;
    DWORD dwDrives;
    DWORD dwPaths;
    DWORD dwFilenames;
    DWORD dwExtensions;
    DWORD dw8dot3;
    HRESULT hr = WBEM_S_NO_ERROR;
    BOOL fOpName = FALSE;
    BOOL fOpDrive = FALSE;
    BOOL fOpPath = FALSE;
    BOOL fOpFilename = FALSE;
    BOOL fOpExtension = FALSE;
    BOOL fOp8dot3 = FALSE;
    BOOL fOpSpecificDrivePath = FALSE;
    LONG lDriveIndex;
    bool bRoot = false;
    bool fNeedFS = false;
    std::vector<CDriveInfo*> vecpDI;
    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx *>(&pQuery);  // for use far below to check IfNTokenAnd
    CHStringArray achstrPropNames;
    CHPtrArray aptrPropValues;


    // DEVNOTE: REMOVE FOR QUASAR!!!  Necessary for double hop access.
#ifdef NTONLY
    bool fImp = false;
    CImpersonateLoggedOnUser icu;
    if(icu.Begin())
    {
        fImp = true;
    }
#endif


    // FindFirstFile looks at not only the DACL to
    // decide if a person has access, but at whether
    // that person has the SeTakeOwnershipPrivilege, 
    // because with that privilege, a person can 
    // take ownership and change the security to
    // grant themselves access.  In other words, they
    // have access even though they may not be in
    // the DACL yet, as they are able to change the
    // DACL by making themselves the owner.  Hence
    // the following call...
    EnablePrivilegeOnCurrentThread(SE_BACKUP_NAME);


    // Determine whether certain other expensive properties are required:
    DWORD dwReqProps = PROP_NO_SPECIAL;
    DetermineReqProps(pQuery, &dwReqProps);

    if(dwReqProps & PROP_FILE_SYSTEM ||
       dwReqProps & PROP_INSTALL_DATE)
    {
        fNeedFS = true;
    }

    hr = pQuery.GetValuesForProp(IDS_Name, vectorNames);
    // In the case of the name property only (the key), we will not accept anything other than WBEM_S_NO_ERROR.
    if(SUCCEEDED(hr))
    {
        hr = pQuery.GetValuesForProp(IDS_Drive, vectorDrives);
    }
    if(SUCCEEDED(hr))
    {
        hr = pQuery.GetValuesForProp(IDS_Path, vectorPaths);
    }
    if(SUCCEEDED(hr))
    {
        hr = pQuery.GetValuesForProp(IDS_Filename, vectorFilenames);
    }
    if(SUCCEEDED(hr))
    {
        hr = pQuery.GetValuesForProp(IDS_Extension, vectorExtensions);
    }
    if(SUCCEEDED(hr))
    {
        hr = pQuery.GetValuesForProp(IDS_EightDotThreeFileName, vector8dot3);
    }

    if(SUCCEEDED(hr))
    {
        dwNames = vectorNames.size();
        dwDrives = vectorDrives.size();
        dwPaths = vectorPaths.size();
        dwFilenames = vectorFilenames.size();
        dwExtensions = vectorExtensions.size();
        dw8dot3 = vector8dot3.size();

        // Create minterms:
        //if(dwNames > 0 && dwDrives == 0 && dwPaths == 0 && dwFilenames == 0 && dwExtensions == 0 && dw8dot3 == 0) fOpName = TRUE;
        //if(dwDrives > 0 && dwNames == 0 && dwPaths == 0 && dwFilenames == 0 && dwExtensions == 0 && dw8dot3 == 0) fOpDrive = TRUE;
        //if(dwPaths > 0 && dwNames == 0 && dwDrives == 0 && dwFilenames == 0 && dwExtensions == 0 && dw8dot3 == 0) fOpPath = TRUE;
        //if(dwFilenames > 0 && dwNames == 0 && dwDrives == 0 && dwPaths == 0 && dwExtensions == 0 && dw8dot3 == 0) fOpFilename = TRUE;
        //if(dwExtensions > 0 && dwNames == 0 && dwDrives == 0 && dwPaths == 0 && dwFilenames == 0 && dw8dot3 == 0) fOpExtension = TRUE;
        //if(dw8dot3 > 0 && dwNames == 0 && dwDrives == 0 && dwPaths == 0 && dwFilenames == 0 && dwExtensions == 0) fOp8dot3 = TRUE;

        if(dwNames > 0) fOpName = TRUE;
        if(dwDrives > 0) fOpDrive = TRUE;
        if(dwPaths > 0) fOpPath = TRUE;
        if(dwFilenames > 0) fOpFilename = TRUE;
        if(dwExtensions > 0) fOpExtension = TRUE;
        if(dw8dot3 > 0) fOp8dot3 = TRUE;

        // One special type: where we specify a unique path AND a drive:
        if(dwDrives == 1 && dwPaths == 1 && dwNames == 0 && dwFilenames == 0 && dwExtensions == 0 && dw8dot3 == 0) fOpSpecificDrivePath = TRUE;

        // Before proceeding: if drives were specified, we need to confirm that they
        // were specified using the correct syntax - namely, 'c:', not anything else,
        // such as 'c:\' (bug WMI RAID #676).
        if(dwDrives > 0)
        {
            _bstr_t bstrtCopy;
            for(long z = 0;
                z < dwDrives && SUCCEEDED(hr);
                z++)
            {
                bstrtCopy = vectorDrives[z];
                WCHAR wstrBuf[_MAX_DRIVE + 1] = { L'\0' };
                wcsncpy(wstrBuf, (LPWSTR)bstrtCopy, _MAX_DRIVE);
                if(wcslen(wstrBuf) != 2 ||
                    wstrBuf[1] != L':')
                {
                    hr = WBEM_E_INVALID_PARAMETER;
                }    
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        // We will optimize on the five optimization variables set above.  If none
        // were set, enumerate all instances and let CIMOM sort it out.

        // Our top candidate is the most restrictive case, where we are optimizing on a specific file(s)...
        if(fOpName)
        {
            // In this case we were given one or more fully qualified pathnames.
            // So we just need to look for those files.

            WCHAR* pwch;
            WCHAR* pwstrFS;
            // For all the specific files, get the info
            //for(x=0; (x < dwNames) && (SUCCEEDED(hr)); x++)
            for(x=0; x < dwNames; x++)
            {
                pwstrFS = NULL;
                // if the name contained a wildcard character, return WBEM_E_INVALID_QUERY:
                if(wcspbrk((wchar_t*)vectorNames[x],L"?*") != NULL)
                {
                    FreeVector(vecpDI);
                    return WBEM_E_INVALID_QUERY;
                }

                pwch = NULL;
                _bstr_t bstrtTemp = vectorNames[x];
                pwch = wcsstr((wchar_t*)bstrtTemp,L":");
                if(pwch != NULL)
                {
                    WCHAR wstrDrive[_MAX_PATH] = L"";
                    WCHAR wstrDir[_MAX_PATH] = L"";
                    WCHAR wstrFile[_MAX_PATH] = L"";
                    WCHAR wstrExt[_MAX_PATH] = L"";

                    _wsplitpath(bstrtTemp,wstrDrive,wstrDir,wstrFile,wstrExt);

                    // Get listing of drives and related info (only if the file system is needed - which it is, by the way, if AccessMask
                    // is needed, because accessmask setting logic depends on whether ntfs or fat. ibid the various dates. DetermineReqProps
                    // will account for this by modifying the dwReqProps value to include PROP_FILE_SYSTEM if necessary.):
                    if(fNeedFS)
                    {
                        GetDrivesAndFS(vecpDI, true, wstrDrive);

                        if(!GetIndexOfDrive(wstrDrive, vecpDI, &lDriveIndex))
                        {
                            FreeVector(vecpDI);
                            return WBEM_E_NOT_FOUND;
                        }
                        else
                        {
                            pwstrFS = (WCHAR*)vecpDI[lDriveIndex]->m_wstrFS;
                        }
                    }

                    // Find out if we are looking for the root directory
                    if(wcscmp(wstrDir,L"\\")==0 && wcslen(wstrFile)==0 && wcslen(wstrExt)==0)
                    {
                        bRoot = true;
                        // If we are looking for the root, our call to EnumDirs presumes that we specify
                        // that we are looking for the root directory with "" as the path, not "\\".
                        // Therefore...
                        wcscpy(wstrDir, L"");
                    }
                    else
                    {
                        bRoot = false;
                    }

                    // We should have been given the exact name of a file, with an extension.
                    // Therefore, the wstrDir now contains the path, filename, and extension.
                    // Thus, we can pass it into EnumDirsNT as the path, and an empty string
                    // as the completetionstring parameter, and still have a whole pathname
                    // for FindFirst (in EnumDirs) to work with.

                    //CInstance *pInstance = CreateNewInstance(pMethodContext);
#ifdef NTONLY
			        {
                        hr = EnumDirsNT(CNTEnumParm(pMethodContext,
                                        wstrDrive,
                                        wstrDir,
                                        wstrFile,
                                        wstrExt,
                                        false,                 // no recursion desired
                                        pwstrFS,
                                        dwReqProps,
                                        bRoot,
                                        NULL));
			        }
#endif
                }

            }
        }
        // Second choice is where we optimize on an EightDotThree filename(s) (which is just as restrictive as Name)...
        else if(fOp8dot3)
        {
            // In this case we were given one or more fully qualified pathnames.
            // So we just need to look for those files.

            WCHAR* pwch;
            WCHAR* pwstrFS;
            for(x=0; x < dw8dot3; x++)
            {
                pwstrFS = NULL;
                // if the name contained a wildcard character, return WBEM_E_INVALID_QUERY:
                if(wcspbrk((wchar_t*)vector8dot3[x],L"?*") != NULL)
                {
                    FreeVector(vecpDI);
                    return WBEM_E_INVALID_QUERY;
                }

                pwch = NULL;
			    _bstr_t bstrtTemp = vector8dot3[x];
                pwch = wcsstr((wchar_t*)bstrtTemp,L":");
                if(pwch != NULL)
                {
				    WCHAR wstrDrive[_MAX_PATH] = L"";
                    WCHAR wstrDir[_MAX_PATH] = L"";
                    WCHAR wstrFile[_MAX_PATH] = L"";
                    WCHAR wstrExt[_MAX_PATH] = L"";


                    _wsplitpath(bstrtTemp,wstrDrive,wstrDir,wstrFile,wstrExt);

                    // Get listing of drives and related info (only if the file system is needed - which it is, by the way, if AccessMask
                    // is needed, because accessmask setting logic depends on whether ntfs or fat. ibid the various dates. DetermineReqProps
                    // will account for this by modifying the dwReqProps value to include PROP_FILE_SYSTEM if necessary.):
                    if(fNeedFS)
                    {
                        GetDrivesAndFS(vecpDI, true, wstrDrive);

                        if(!GetIndexOfDrive(wstrDrive, vecpDI, &lDriveIndex))
                        {
                            FreeVector(vecpDI);
                            return WBEM_E_NOT_FOUND;
                        }
                        else
                        {
                            pwstrFS = (WCHAR*)vecpDI[lDriveIndex]->m_wstrFS;
                        }
                    }

                    // Find out if we are looking for the root directory
                    if(wcscmp(wstrDir,L"\\")==0 && wcslen(wstrFile)==0 && wcslen(wstrExt)==0)
                    {
                        bRoot = true;
                        // If we are looking for the root, our call to EnumDirs presumes that we specify
                        // that we are looking for the root directory with "" as the path, not "\\".
                        // Therefore...
                        wcscpy(wstrDir, L"");
                    }
                    else
                    {
                        bRoot = false;
                    }

                    // We should have been given the exact name of a file, with an extension.
                    // Therefore, the wstrDir now contains the path, filename, and extension.
                    // Thus, we can pass it into EnumDirsNT as the path, and an empty string
                    // as the completetionstring parameter, and still have a whole pathname
                    // for FindFirst (in EnumDirs) to work with.

                    //CInstance *pInstance = CreateNewInstance(pMethodContext);
#ifdef NTONLY
			        {
                        hr = EnumDirsNT(CNTEnumParm(pMethodContext,
                                        wstrDrive,
                                        wstrDir,
                                        wstrFile,
                                        wstrExt,
                                        false,       // no recursion desired
                                        pwstrFS,
                                        dwReqProps,
                                        bRoot,
                                        NULL));
			        }
#endif
                }
            }
        }
        // Third choice is an NTokenAnd, since it might be more restrictive than any of the other styles that follow...
        else if(pQuery2->IsNTokenAnd(achstrPropNames, aptrPropValues))
        {
            // We got ourselves a good ol' fashioned NTokenAnd query.
            // Need to look at what we were given.  Will only accept as prop names any of the following:
            //   "Drive", "Path", "Filename", or "Extension".
            // So first, go through achstrPropNames and make sure each is one of the above...
            bool fSpecifiedDrive = false;
            bool fRecurse = true;
            long lDriveIndex = -1L;
            CHString chstrDrive = _T("");
            CHString chstrPath = _T("");
            CHString chstrFilename = _T("*");
            CHString chstrExtension = _T("*");

            for(short s = 0; s < achstrPropNames.GetSize(); s++)
            {
                // A note on the lines like if(dwDrives > 0) below:
                // An NTokenAnd query can only have AND expressions,
                // no ORs.  Therefore, the greatest the value any of 
                // the variables like dwDrives can be is 1.
                if(achstrPropNames[s].CompareNoCase(IDS_Drive) == 0)
                {
                    // We may have had a query like "select * from cim_logicalfile where extension = "txt" and drive = NULL",
                    // in which case dwDrives will be zero, and aptrPropValues will contain a variant of type VT_NULL.  VT_NULLs
                    // don't go into _bstr_t all that well, so protect ourselves.  Still do an ntokenand, as it is too late
                    // to attempt another optimization.
                    if(dwDrives > 0L)
                    {
                        chstrDrive = (wchar_t*)_bstr_t(*((variant_t*)aptrPropValues[s]));
                        fSpecifiedDrive = true;

                        if(fNeedFS)
                        {
                            GetDrivesAndFS(vecpDI, fNeedFS, chstrDrive);
                            if(!GetIndexOfDrive(TOBSTRT(chstrDrive), vecpDI, &lDriveIndex))
                            {
                                FreeVector(vecpDI);
                                return WBEM_E_NOT_FOUND;
                            }
                        }
                    }
                }
                else if(achstrPropNames[s].CompareNoCase(IDS_Path) == 0)
                {
                    if(dwPaths > 0L) // see the comment above
                    {
                        chstrPath = (wchar_t*)_bstr_t(*((variant_t*)aptrPropValues[s]));
                        fRecurse = false;
                    }
                }
                else if(achstrPropNames[s].CompareNoCase(IDS_Filename) == 0)
                {
                    if(dwFilenames > 0L)
                    {
                        chstrFilename = (wchar_t*)_bstr_t(*((variant_t*)aptrPropValues[s]));
                    }
                }
                else if(achstrPropNames[s].CompareNoCase(IDS_Extension) == 0)
                {
                    if(dwExtensions > 0L)
                    {
                        chstrExtension = (wchar_t*)_bstr_t(*((variant_t*)aptrPropValues[s]));
                    }
                }
            }

            // If no drive was specified, we need to get the set of drives.
            if(!fSpecifiedDrive)
            {
                GetDrivesAndFS(vecpDI, fNeedFS);  // can't find files on all drives without knowing what drives there are now can we?
            }


            unsigned int sNumDrives;
            (chstrDrive.GetLength() == 0) ? sNumDrives = vecpDI.size() : sNumDrives = 1;

            for(x = 0; x < sNumDrives; x++)
            {
#ifdef NTONLY
                hr = EnumDirsNT(CNTEnumParm(pMethodContext,
                                fSpecifiedDrive ? chstrDrive : (WCHAR*)vecpDI[x]->m_wstrDrive,
                                chstrPath,                         // start either at the root (path = "") or at wherever they specified
                                chstrFilename,                     // filename
                                chstrExtension,                    // extension
                                fRecurse,                          // recursion desired
                                fNeedFS ? (fSpecifiedDrive ? (WCHAR*)vecpDI[lDriveIndex]->m_wstrFS : (WCHAR*)vecpDI[x]->m_wstrFS) : NULL,
                                dwReqProps,
                                (chstrPath.GetLength() == 0) ? true : false,
                                NULL));                            // no more data
#endif
            }  // for all drives required

            // Free up results of IsNTokenAnd call...
            for (s = 0; s < aptrPropValues.GetSize(); s++)
            {
                delete aptrPropValues[s];
            }
            aptrPropValues.RemoveAll();
        }

        // Fourth choice is where we optimize on a drive and a path(s)...
        else if(fOpSpecificDrivePath)
        {
            // This time we were given one or more specific paths to enumerate all
            // the files in (including subdirectories).  The paths look like:
            // "\\windows\\" or "\\system32\\", including the leading AND trailing
            // backslashes.  We need to look for these paths on all drives.

            WCHAR* pwstrFS;

            if(fNeedFS)
            {
                GetDrivesAndFS(vecpDI, true, vectorDrives[0]);
            }            

            //for(x = 0; x < vecpDI.size(); x++)     // for specified drive only
            {
                //for(y = 0; y < dwPaths; y++)         // for specified path only
                {
                    pwstrFS = NULL;
                    // If the path contained a wildcard character (you never know!),
                    if(wcspbrk((wchar_t*)vectorPaths[0],L"?*") != NULL)
                    {
                        FreeVector(vecpDI);
                        return WBEM_E_INVALID_QUERY;
                    }

                    if(!GetIndexOfDrive(vectorDrives[0], vecpDI, &lDriveIndex))
                    {
                        FreeVector(vecpDI);
                        return WBEM_E_NOT_FOUND;
                    }
                    else
                    {
                        if(fNeedFS)
                        {
                            pwstrFS = (WCHAR*)vecpDI[lDriveIndex]->m_wstrFS;
                        }
                    }

                    // See if we are looking at the root:
                    if(wcscmp((wchar_t*)vectorPaths[0],L"") == 0)
                    {
                        bRoot = true;
                    }


#ifdef NTONLY
			        {
                        hr = EnumDirsNT(CNTEnumParm(pMethodContext,
                                        (wchar_t*)vectorDrives[0],
                                        (wchar_t*)vectorPaths[0],   // use the given path
                                        L"*",                       // filename
                                        L"*",                       // extension
                                        false,                      // no recursion desired
                                        pwstrFS,
                                        dwReqProps,
                                        bRoot,
                                        NULL));
			        }
#endif
                }
            }
        }
        // Fifth choice is where we optimize on a specific path(s)...
        else if(fOpPath)
        {
            // This time we were given one or more specific paths to enumerate all
            // the files in (including subdirectories).  The paths look like:
            // "\\windows\\" or "\\system32\\", including the leading AND trailing
            // backslashes.  We need to look for these paths on all drives.

            GetDrivesAndFS(vecpDI, fNeedFS);  // can't find files on all drives without knowing what drives there are now can we?

            for(x = 0; x < vecpDI.size(); x++)     // for all drives
            {
                for(y = 0; y < dwPaths; y++)         // for all supplied paths
                {
                    // If the path contained a wildcard character (you never know!),
                    // return WBEM_E_INVALID_QUERY:
                    if(wcspbrk((wchar_t*)vectorPaths[y],L"?*") != NULL)
                    {
                        FreeVector(vecpDI);
                        return WBEM_E_INVALID_QUERY;
                    }

                    // See if we are looking at the root:
                    if(wcscmp((wchar_t*)vectorPaths[y],L"") == 0)
                    {
                        bRoot = true;
                    }


#ifdef NTONLY
			        {
                        hr = EnumDirsNT(CNTEnumParm(pMethodContext,
                                        (WCHAR*)vecpDI[x]->m_wstrDrive,
                                        (WCHAR*)vectorPaths[y],     // use the given path
                                        L"*",                       // filename
                                        L"*",                       // extension
                                        false,                      // no recursion desired
                                        fNeedFS ? (WCHAR*)vecpDI[x]->m_wstrFS : NULL,
                                        dwReqProps,
                                        bRoot,
                                        NULL));

			        }
#endif
                }
            }
        }
        // Fifth choice is where we optimize on a specific filename(s)...
        else if(fOpFilename)
        {
            // In this case we were given one or more file names.  The file name
            // is just the name - no extension, no path, no drive.  For example,
            // "autoexec", or "win".  So this time I want to examine all drives,
            // all paths (recursively), for all files of that name, with any
            // extension.
            
            GetDrivesAndFS(vecpDI, fNeedFS);  // can't find files on all drives without knowing what drives there are now can we?

            for(x = 0; x < vecpDI.size(); x++)     // for all drives
            {
                for(y = 0; y < dwFilenames; y++)     // for all supplied filenames
                {
                    // If the filename contained a wildcard character (you never know!),
                    if(wcspbrk((wchar_t*)vectorFilenames[y],L"?*") != NULL)
                    {
                        FreeVector(vecpDI);
                        return WBEM_E_INVALID_QUERY;
                    }

                    // If we specified "" as the filename, the root qualifies. Otherwise it doesn't.
                    if(wcslen((wchar_t*)vectorFilenames[y]) == 0)
                    {
                        bRoot = true;
                    }
                    else
                    {
                        bRoot = false;
                    }

#ifdef NTONLY
			        {
                        hr = EnumDirsNT(CNTEnumParm(pMethodContext,
                                        (WCHAR*)vecpDI[x]->m_wstrDrive,
                                        L"",                          // start at the root
                                        (wchar_t*)vectorFilenames[y], // filename
                                        L"*",                          // extension
                                        true,                         // recursion desired
                                        fNeedFS ? (WCHAR*)vecpDI[x]->m_wstrFS: NULL,
                                        dwReqProps,
                                        bRoot,
                                        NULL));

			        }
#endif
                }
            }
        }
        // Sixth choice is where we optimize on a specific drive(s)...
        else if(fOpDrive)   // We are optimizing on a specific drive:
        {
            // In this case we were given one or more drive letters, so need to
            // enumerate all files in all paths on those drive(s).
            WCHAR* pwstrFS;

            for(x=0; x < dwDrives; x++)
            {
                pwstrFS = NULL;

                // If the drive contained a wildcard character (you never know!),
                // return WBEM_E_INVALID_QUERY:
                if(wcspbrk((wchar_t*)vectorDrives[x],L"?*") != NULL)
                {
                    FreeVector(vecpDI);
                    return WBEM_E_INVALID_QUERY;
                }

                GetDrivesAndFS(vecpDI, fNeedFS);

                if(!GetIndexOfDrive(vectorDrives[x], vecpDI, &lDriveIndex))
                {
                    FreeVector(vecpDI);
                    return WBEM_E_NOT_FOUND;
                }
                else
                {
                    if(fNeedFS)
                    {
                        pwstrFS = (WCHAR*)vecpDI[lDriveIndex]->m_wstrFS;
                    }
                }

#ifdef NTONLY
			    {
                    hr = EnumDirsNT(CNTEnumParm(pMethodContext,
                                    vectorDrives[x],
                                    L"",          // start at the root
                                    L"*",         // filename
                                    L"*",         // extension
                                    true,         // recursion desired
                                    pwstrFS,
                                    dwReqProps,
                                    true,
                                    NULL));        // true because we are starting at the root
			    }
#endif
            }
        }
        // And the last choice is where we optimize on a specific extension(s)...
        else if(fOpExtension)
        {
            // In this case we were given one or more files with a given extension
            // to search for, on any drive, in any directory.  So again, examine
            // all drives, all directories (recursively) for all files with the
            // given extension.
            GetDrivesAndFS(vecpDI, fNeedFS);  // can't find files on all drives without knowing what drives there are now can we?

            for(x = 0; x < vecpDI.size(); x++)     // for all drives
            {
                for(y = 0; y < dwExtensions; y++)     // for all supplied extensions
                {
                    // If the extension contained a wildcard character (you never know!),
                    // return WBEM_E_FAILED:
                    if(wcspbrk((wchar_t*)vectorExtensions[y],L"?*") != NULL)
                    {
                        FreeVector(vecpDI);
                        return WBEM_E_INVALID_QUERY;
                    }

                    // If we specified "" as the extension, the root qualifies. Otherwise it doesn't.
                    if(wcslen((wchar_t*)vectorExtensions[y]) == 0)
                    {
                        bRoot = true;
                    }
                    else
                    {
                        bRoot = false;
                    }

#ifdef NTONLY
			        {
                        hr = EnumDirsNT(CNTEnumParm(pMethodContext,
                                        (WCHAR*)vecpDI[x]->m_wstrDrive,
                                        L"",                           // start at the root
                                        L"*",                          // filename
                                        (wchar_t*)vectorExtensions[y], // extension
                                        true,                          // recursion desired
                                        fNeedFS ? (WCHAR*)vecpDI[x]->m_wstrFS : NULL,
                                        dwReqProps,
                                        bRoot,
                                        NULL));                        // false because, if there is an extension, it can't be the root
			        }
#endif
                }
            }
        }
        // Last choice: enumeration.
        else  // let CIMOM handle filtering; we'll hand back everything!
        {
            EnumerateInstances(pMethodContext);
        }
    } // succeeded on GetValuesForProp calls

    FreeVector(vecpDI);


#ifdef NTONLY
    if(fImp)
    {
        icu.End();
        fImp = false;
    }
#endif


    return WBEM_S_NO_ERROR;
}

/*****************************************************************************
 *
 *  FUNCTION    : CImplement_LogicalFile::GetDrivesAndFS
 *
 *  DESCRIPTION : Creates a list of valid drives and their respective file
 *                system.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : The caller must free the members of the array (pointers to
 *                CDriveInfo class).
 *
 *****************************************************************************/
void CImplement_LogicalFile::GetDrivesAndFS(
    std::vector<CDriveInfo*>& vecpDI, 
    bool fGetFS /*=false*/, 
    LPCTSTR tstrDriveSet /*= NULL*/)
{
    TCHAR tstrDrive[4];
    int x;
    DWORD dwDrives;
    bool bContinue = true;

    // Walk all the logical drives
    dwDrives = GetLogicalDrives();

    TCHAR tstrFSName[_MAX_PATH];

    for(x=0; (x < 32) && (bContinue); x++)
    {
        // If the bit is set, the drive letter is active
        if (dwDrives & (1<<x))
        {
            tstrDrive[0] = x + _T('A');
            tstrDrive[1] = _T(':');
            tstrDrive[2] = _T('\\');
            tstrDrive[3] = _T('\0');

            if(!tstrDriveSet)
            {
                // Only local drives
                if(IsValidDrive(tstrDrive))
                {
                    BOOL bRet = TRUE;
                    if(fGetFS)
                    {
                        try
                        {
                            bRet = GetVolumeInformation(tstrDrive, NULL, 0, NULL, NULL, NULL, tstrFSName, sizeof(tstrFSName)/sizeof(TCHAR));
                        }
                        catch ( ... )
                        {
                            bRet = FALSE;
                        }
                    }

                    if(bRet)
                    {
                        tstrDrive[2] = '\0';
                        CDriveInfo* pdi = (CDriveInfo*) new CDriveInfo((WCHAR*)_bstr_t((TCHAR*)tstrDrive),
                                                                       (fGetFS && bRet) ? (WCHAR*)_bstr_t((TCHAR*)tstrFSName) : NULL);
                        vecpDI.push_back(pdi);
                        // Notice that pdi is not destroyed - it gets
                        // destroyed by the caller!.
                    }
                }
            }
            else // We were given a set of drives to be concerned with (in the form a:c:f:z:)
            {
                CHString chstrDriveSet(tstrDriveSet);
                CHString chstrDrive(tstrDrive);
                chstrDriveSet.MakeUpper();
                chstrDrive = chstrDrive.Left(2);
                if(chstrDriveSet.Find(chstrDrive) != -1L)
                {
                    // Only local drives
                    if(IsValidDrive(tstrDrive))
                    {
                        BOOL bRet = TRUE;
                        if(fGetFS)
                        {
                            try
                            {
                                bRet = GetVolumeInformation(tstrDrive, NULL, 0, NULL, NULL, NULL, tstrFSName, sizeof(tstrFSName)/sizeof(TCHAR));
                            }
                            catch ( ... )
                            {
                                bRet = FALSE;
                            }
                        }

                        if(bRet)
                        {
                            tstrDrive[2] = '\0';
                            CDriveInfo* pdi = (CDriveInfo*) new CDriveInfo((WCHAR*)_bstr_t((TCHAR*)tstrDrive),
                                                                           (fGetFS && bRet) ? (WCHAR*)_bstr_t((TCHAR*)tstrFSName) : NULL);
                            vecpDI.push_back(pdi);
                            // Notice that pdi is not destroyed - it gets
                            // destroyed by the caller!.
                        }
                    }
                }
            }
        }
    }
}


/*****************************************************************************
 *
 *  FUNCTION    : CImplement_LogicalFile::FreeVector
 *
 *  DESCRIPTION : Frees vector members and clears the vector.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : none
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
void CImplement_LogicalFile::FreeVector(std::vector<CDriveInfo*>& vecpDI)
{
    for(long l = 0L; l < vecpDI.size(); l++)
    {
          delete vecpDI[l];
    }
    vecpDI.clear();
}

/*****************************************************************************
 *
 *  FUNCTION    : CImplement_LogicalFile::GetIndexOfDrive
 *
 *  DESCRIPTION : Obtains the array index of the passed in drive
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
BOOL CImplement_LogicalFile::GetIndexOfDrive(const WCHAR* wstrDrive,
                                      std::vector<CDriveInfo*>& vecpDI,
                                      LONG* lDriveIndex)
{
    // Go through the vector of drive letters, looking for the one passed in.
    // If I find it, return the associated drive's array index.
    for(LONG j = 0; j < vecpDI.size(); j++)
    {
        if(_wcsicmp(wstrDrive, _bstr_t((vecpDI[j]->m_wstrDrive))) == 0)
        {
            *lDriveIndex = j;
            return TRUE;
        }
    }
    return FALSE;
}

/*****************************************************************************
 *
 *  FUNCTION    : CImplement_LogicalFile::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CImplement_LogicalFile::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
    // DEVNOTE: REMOVE FOR QUASAR!!!  Necessary for double hop access.
#ifdef NTONLY
    bool fImp = false;
    CImpersonateLoggedOnUser icu;
    if(icu.Begin())
    {
        fImp = true;
    }
#endif


    // FindFirstFile looks at not only the DACL to
    // decide if a person has access, but at whether
    // that person has the SeTakeOwnershipPrivilege, 
    // because with that privilege, a person can 
    // take ownership and change the security to
    // grant themselves access.  In other words, they
    // have access even though they may not be in
    // the DACL yet, as they are able to change the
    // DACL by making themselves the owner.  Hence
    // the following call...
    EnablePrivilegeOnCurrentThread(SE_BACKUP_NAME);

	EnumDrives(pMethodContext, NULL);


#ifdef NTONLY
    if(fImp)
    {
        icu.End();
        fImp = false;
    }
#endif


	return WBEM_S_NO_ERROR ;
}

void CImplement_LogicalFile::EnumDrives(MethodContext *pMethodContext, LPCTSTR pszPath)
{
    TCHAR tstrDrive[4];
    int x;
    DWORD dwDrives;
    TCHAR tstrFSName[_MAX_PATH];
    HRESULT hr = WBEM_S_NO_ERROR;
    bool bRoot = false;


    // Walk all the logical drives
    dwDrives = GetLogicalDrives();
    for (x=0; (x < 32) && SUCCEEDED(hr); x++)
    {
        // If the bit is set, the drive letter is active
        if (dwDrives & (1<<x))
        {
            tstrDrive[0] = x + _T('A');
            tstrDrive[1] = _T(':');
            tstrDrive[2] = _T('\\');
            tstrDrive[3] = _T('\0');

            // Only local drives
            if (IsValidDrive(tstrDrive))
            {
                BOOL bRet;
                try
                {
                    bRet = GetVolumeInformation(tstrDrive, NULL, 0, NULL, NULL, NULL, tstrFSName, sizeof(tstrFSName)/sizeof(TCHAR));
                }
                catch ( ... )
                {
                    bRet = FALSE;
                }

                if (bRet)
                {
                   tstrDrive[2] = '\0';
                    // If we were asked for a specific path, then we don't want to recurse, else
                    // start from the root.
                    if (pszPath == NULL)
                    {
#ifdef NTONLY
				        {
						    bstr_t bstrDrive(tstrDrive);
                            bstr_t bstrName(tstrFSName);
                            {
                                CNTEnumParm p(pMethodContext, bstrDrive, L"", L"*", L"*", true, bstrName, PROP_ALL_SPECIAL, true, NULL);
					            hr = EnumDirsNT(p);
                            }
				        }
#endif
                    }
                    else
                    {
#ifdef NTONLY
				        {
						    bstr_t bstrName ( tstrFSName ) ;
						    bstr_t bstrDrive ( tstrDrive ) ;
					   	    bstr_t bstrPath ( pszPath ) ;
                            {
                                CNTEnumParm p(pMethodContext, bstrDrive, bstrPath, L"*", L"*", false, bstrName, PROP_ALL_SPECIAL, true, NULL);
					   	        hr = EnumDirsNT(p);
                            }
				        }
#endif
                    }

                }
            }
        }
        // Under certain conditions, we want to continue enumerating other drives even if we
        // received certain errors.
        if(hr == WBEM_E_ACCESS_DENIED || hr == WBEM_E_NOT_FOUND)
		{
			hr = WBEM_S_NO_ERROR;
		}
    }
}

/*****************************************************************************
 *
 *  FUNCTION    : CImplement_LogicalFile::EnumDirs
 *
 *  DESCRIPTION : Walks the dirs on a specific drive
 *
 *  INPUTS      : pszDrive is of the format "c:", path is of the format "\" or "\dos"
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : WBEM_E_FAILED (some generic problem - quit); WBEM_E_ACCESS_DENIED
 *                (access denied to file - continue along with next);
 *                WBEM_S_NO_ERROR (no problemo); WBEM_E_NOT_FOUND (couldn't find
 *                the file); WBEM_E_INVALID_PARAMETER (one or more parts of the
 *                file name was not valid).
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CImplement_LogicalFile::EnumDirsNT(CNTEnumParm& p)
{
    WCHAR szBuff[_MAX_PATH];
    WIN32_FIND_DATAW stFindData;
    SmartFindClose hFind;

	CInstancePtr pInstance;
	WCHAR* pwc = NULL;
	bool bWildFile = false;
	bool bWildExt = false;
	_bstr_t bstrtFullPathName;
	HRESULT hr = WBEM_S_NO_ERROR;
	bool fDone = false;

	// Before proceeding further:  if we are not looking at the root "directory",
	// then the path arguement must have BOTH leading AND trailing backslashes.
	// If not, it was misspecified, so get the @#%$^% out of Dodge:
	if(!IsValidPath(p.m_pszPath, p.m_bRoot))
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	// Determine if filename and or extension are a wildchar:
	if(wcscmp(p.m_pszFile,L"*") == 0) bWildFile = true;
	if(wcscmp(p.m_pszExt,L"*") == 0) bWildExt = true;

	ZeroMemory(&stFindData,sizeof(stFindData));
	ZeroMemory(szBuff,sizeof(szBuff));

	// One simple case is where neither bWildFile nor bWildExt
	// are true.  In that case we are looking for a specific
	// file only. If this is the case, we are done onece the
	// following block executes (whether the file is found or
	// not), so indicate as such at the end.
	if(!(bWildFile || bWildExt || p.m_bRoot) && !p.m_bRecurse)
	{
		// Assemble pathname - we have all the pieces.
		wcscpy(szBuff,p.m_pszDrive);
		wcscat(szBuff,p.m_pszPath);
		wcscat(szBuff,p.m_pszFile);
        if(p.m_pszExt && wcslen(p.m_pszExt) > 0)
        {
		    if(p.m_pszExt[0] != L'.')
            {
                wcscat(szBuff, L".");
                wcscat(szBuff, p.m_pszExt);
            }
            else
            {
                wcscat(szBuff, p.m_pszExt);
            }
        }

		// Do the find
		hFind = FindFirstFileW(szBuff, &stFindData);

		// If the find failed and we are not recursing (we were interested only in
		// looking at one particular path), indicate that we should not continue.
		//DWORD dw = GetLastError();
		if(hFind == INVALID_HANDLE_VALUE/* || dw != ERROR_SUCCESS*/)
		{
			hr = WinErrorToWBEMhResult(GetLastError());
		}

		if(SUCCEEDED(hr))
		{
			// We found it, so fill in the values and commit it.
			pInstance.Attach ( CreateNewInstance ( p.m_pMethodContext ) ) ;

			// FindClose(hFind); // DONE AT BOTTOM
			bstrtFullPathName = p.m_pszDrive;
			if(wcslen(p.m_pszPath) == 0) // were dealing with the root dir; need "\\" before file name
			{
				bstrtFullPathName += L"\\";
			}
			else
			{
				bstrtFullPathName += p.m_pszPath;
			}
			bstrtFullPathName += stFindData.cFileName;
			if(IsOneOfMe(&stFindData,bstrtFullPathName))
			{
				// The following is done for compatability with cases in which we did an 8dot3 optimization.
				// Only szBuff contains the proper, 8dot3 filename (stfindData contains both - how would we
				// know which to use?).  Thus load it here, then extact it there, and use it if present.
                // Note that some derived classes (such as Win32LogicalFileSecuritySetting) may not have a
                // Name property to set - hence the following check.
                bool fHasNameProp = false;
                VARTYPE vt = VT_BSTR;
                if(pInstance->GetStatus(IDS_Name, fHasNameProp, vt) && fHasNameProp)
                {
					pInstance->SetWCHARSplat(IDS_Name,szBuff);
                }
				//LoadPropertyValuesNT(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
				if(wcslen(p.m_pszPath) == 0)
				{
					LoadPropertyValuesNT(pInstance, p.m_pszDrive, L"\\", p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
				}
				else
				{
					LoadPropertyValuesNT(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
				}

				if ( SUCCEEDED(hr))
				{
					hr = pInstance->Commit () ;
				}
			}
			else
			{
				hr = WBEM_E_NOT_FOUND;
			}
		}
		fDone = TRUE;
	}

	// Another simple case is where we are looking for the root directory itself.
	if(p.m_bRoot && !fDone)
	{
		pInstance.Attach ( CreateNewInstance ( p.m_pMethodContext ) ) ;

		// If the szFSName parameter is NULL, we never got the file system name, perhaps
		// because that property was not required.  However, normally when we do get the
		// FSName, we call GetDrivesAndFS, and it is only through that call that we
		// confirm that the specified drive even exists!  Here, however, we can get away
        // with confirming that the specific drive of interest is valid via a call to IsValidDrive.
		if(p.m_szFSName == NULL || wcslen(p.m_szFSName)==0)
		{
            CHString chstrTmp;
            chstrTmp.Format(L"%s\\",p.m_pszDrive);
            if(!IsValidDrive(chstrTmp))
			{
				hr = WBEM_E_NOT_FOUND;
			}
			//FreeVector(vecpDI);
		}
		if(SUCCEEDED(hr))
		{
			bstrtFullPathName = p.m_pszDrive;
			bstrtFullPathName += p.m_pszPath;
			if(IsOneOfMe((LPWIN32_FIND_DATAW)NULL,bstrtFullPathName))
			{
				LoadPropertyValuesNT(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, NULL, p.m_dwReqProps, p.m_pvMoreData);
				hr = pInstance->Commit () ;
			}
		}
		// In this case, if we aren't recursing, we are done. Otherwise, continue.
		// NO! That would cause only the root to be returned; what if the query had
		// been "select * from cim_logicalfile where path = "\\" ?  Then we want
		// all files and directories off of the root directory, in addition to the root.
		// YES! (after revising root's path to be empty by definition, and after
		// revising the test that sets bRoot to compare to an empty string rather than
		// to "\\") Do want to stop if root, as now no ambiguity between the root dir
		// and files hanging off the root. Previously there was, since both had a path
		// of "\\".  Now the root's path is "", while the path of files off of the root
		// is "\\".  So, un-commenting out the following lines:
		if(!p.m_bRecurse)
		{
			fDone = true;
		}
	}

	// If we are recursing and all is well, we're not done yet!
	if(!fDone && SUCCEEDED(hr))
	{
		// The more involved case if that for which either bWildFile or bWildExt
		// is true.  We need to find matching files or extensions or both potentially
		// in all directories.

		// Start by assembling a path, but use wildcards for the filename and extension.
		wcscpy(szBuff,p.m_pszDrive);
		if(wcslen(p.m_pszPath) == 0)
		{
			wcscat(szBuff,L"\\");  // path was the root - need leading "\\"
		}
		else
		{
			wcscat(szBuff,p.m_pszPath);
		}
		wcscat(szBuff,L"*.*");

		// Do the find
		hFind = FindFirstFileW(szBuff, &stFindData);

		// If the find failed, quit.
		if(hFind == INVALID_HANDLE_VALUE)
		{
			// The intended logic here is as follows:  if we have an invalid handle, we
			// need to return at this point no matter what.  However, if we just got an
			// access denied error, we want to return a value that will allow us to keep
			// iterating (presumably at the next higher node in the directory structure),
			// as opposed to returning a false, which would get propegated out of all
			// recursed calls and prematurely abort the iteration unnescessarily.
			hr = WinErrorToWBEMhResult(GetLastError());
		}
		else
		{
			// Walk the directory tree
			do
			{
				if( (wcscmp(stFindData.cFileName, L".") != 0) &&
					(wcscmp(stFindData.cFileName, L"..") != 0))
				{
					// It was a file.
					// If both bWildFile and bWildExt are true, it is a file we are
					// interested in, so copy values and commit it.
					if(bWildFile && bWildExt)
					{
						// Create the new instance and copy the values in:
						pInstance.Attach ( CreateNewInstance ( p.m_pMethodContext ) ) ;

						bstrtFullPathName = p.m_pszDrive;
						if(wcslen(p.m_pszPath) == 0)   // were working with root dir; need \\ before filename
						{
							bstrtFullPathName += L"\\";
						}
						else
						{
							bstrtFullPathName += p.m_pszPath;
						}
						bstrtFullPathName += stFindData.cFileName;
						if(IsOneOfMe(&stFindData,bstrtFullPathName))
						{
							if(wcslen(p.m_pszPath) == 0)
							{
								LoadPropertyValuesNT(pInstance, p.m_pszDrive, L"\\", p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
							}
							else
							{
								LoadPropertyValuesNT(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
							}

							hr = pInstance->Commit () ;
						}

						if(SUCCEEDED(hr))
						{
							// Look for entries that are marked as Directory, and aren't . or ..
							if( (stFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
								(wcscmp(stFindData.cFileName, L".") != 0) &&
								(wcscmp(stFindData.cFileName, L"..") != 0) && p.m_bRecurse)
							{
								// Build path containing the directory we just found
								if(wcslen(p.m_pszPath) == 0)   // were working with root dir; need \\ before filename
								{
									wcscpy(szBuff,L"\\");
								}
								else
								{
									wcscpy(szBuff, p.m_pszPath);
								}
								wcscat(szBuff, stFindData.cFileName);
								wcscat(szBuff, L"\\");

								CNTEnumParm newp(p);
								newp.m_pszPath = szBuff;
								newp.m_bRoot = false;

								hr = EnumDirsNT(newp);
							}
						}
					}
					else
					{
						// The first alternative possibility is that we were looking
						// for all cases of a particular file with any extension:
						if(!bWildFile && bWildExt)
						{
							// in which case we need to compare the filename of
							// the file that was found with that which was asked for:
							wcscpy(szBuff,stFindData.cFileName);
							pwc = NULL;
							pwc = wcsrchr(szBuff, L'.');
							if(pwc != NULL)
							{
								*pwc = '\0';
							}
							if(_wcsicmp(szBuff,p.m_pszFile)==0)
							{
								// The file is one of interest, so load values
								// and commit it.
								pInstance.Attach ( CreateNewInstance ( p.m_pMethodContext ) ) ;

								bstrtFullPathName = p.m_pszDrive;
								bstrtFullPathName += p.m_pszPath;
								bstrtFullPathName += stFindData.cFileName;
								if(IsOneOfMe(&stFindData,bstrtFullPathName))
								{
									//LoadPropertyValuesNT(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
									if(wcslen(p.m_pszPath) == 0)
									{
										LoadPropertyValuesNT(pInstance, p.m_pszDrive, L"\\", p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
									}
									else
									{
										LoadPropertyValuesNT(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
									}

									hr = pInstance->Commit () ;
								}
							}
							if(SUCCEEDED(hr))
							{
								// Look for entries that are marked as Directory, and aren't . or ..
								if( (stFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
									(wcscmp(stFindData.cFileName, L".") != 0) &&
									(wcscmp(stFindData.cFileName, L"..") != 0) & p.m_bRecurse)
								{
									// Build path containing the directory we just found
									if(wcslen(p.m_pszPath) == 0)   // were working with root dir; need \\ before filename
									{
										wcscpy(szBuff,L"\\");
									}
									else
									{
										wcscpy(szBuff, p.m_pszPath);
									}
									wcscat(szBuff, stFindData.cFileName);
									wcscat(szBuff, L"\\");

									CNTEnumParm newp(p);
									newp.m_pszPath = szBuff;
									newp.m_bRoot = false;

									hr = EnumDirsNT(newp);
								}
							}
						}

						// The second alternative is that we were looking for all
						// cases of any given file, with a particular extension:
						if(bWildFile && !bWildExt)
						{
							// in which case we need to compare the extension of
							// the file that was found with that which was asked for:
							wcscpy(szBuff,stFindData.cFileName);
							pwc = NULL;
							pwc = wcsrchr(szBuff, L'.');
							if(pwc != NULL)
							{
								if(_wcsicmp(pwc+1,p.m_pszExt)==0)
								{
									// The file is one of interest, so load values
									// and commit it.
									pInstance.Attach ( CreateNewInstance ( p.m_pMethodContext ) ) ;

									bstrtFullPathName = p.m_pszDrive;
									bstrtFullPathName += p.m_pszPath;
									bstrtFullPathName += stFindData.cFileName;
									if(IsOneOfMe(&stFindData,bstrtFullPathName))
									{
										//LoadPropertyValuesNT(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
										if(wcslen(p.m_pszPath) == 0)
										{
											LoadPropertyValuesNT(pInstance, p.m_pszDrive, L"\\", p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
										}
										else
										{
											LoadPropertyValuesNT(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
										}

										hr = pInstance->Commit () ;
									}
								}
							}
							else if(pwc == NULL && wcslen(p.m_pszExt) == 0) // there was no extension, but our query asked for files with none
							{
								// The file is one of interest, so load values
								// and commit it.
								pInstance.Attach ( CreateNewInstance ( p.m_pMethodContext ) ) ;

								bstrtFullPathName = p.m_pszDrive;
								bstrtFullPathName += p.m_pszPath;
								bstrtFullPathName += stFindData.cFileName;
								if(IsOneOfMe(&stFindData,bstrtFullPathName))
								{
									//LoadPropertyValuesNT(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
									if(wcslen(p.m_pszPath) == 0)
									{
										LoadPropertyValuesNT(pInstance, p.m_pszDrive, L"\\", p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
									}
									else
									{
										LoadPropertyValuesNT(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
									}

									hr = pInstance->Commit () ;
								}
							}
							if(SUCCEEDED(hr))
							{
								// Look for entries that are marked as Directory, and aren't . or ..
								if( (stFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
									(wcscmp(stFindData.cFileName, L".") != 0) &&
									(wcscmp(stFindData.cFileName, L"..") != 0) && p.m_bRecurse)
								{
									// Build path containing the directory we just found
									if(wcslen(p.m_pszPath) == 0)   // were working with root dir; need \\ before filename
									{
										wcscpy(szBuff,L"\\");
									}
									else
									{
										wcscpy(szBuff, p.m_pszPath);
									}
									wcscat(szBuff, stFindData.cFileName);
									wcscat(szBuff, L"\\");

									CNTEnumParm newp(p);
									newp.m_pszPath = szBuff;
									newp.m_bRoot = false;

									hr = EnumDirsNT(newp);
								}
							}
						}
						// A third alternative is that bWildExtension and bWildFilename are both false, but
						// we didn't specify a specific file either.  This might happen if a user did an NTokenAnd
						// query, and specified drive, filename, and extension, for instance, but no path. So...
						if(!bWildFile && !bWildExt && p.m_bRecurse)
						{
							// in which case we need to compare the filename of
							// the file that was found with that which was asked for,
							// and do the same with the asked for and found extension:
							wcscpy(szBuff,stFindData.cFileName);
							pwc = NULL;
							pwc = wcsrchr(szBuff, L'.');
							if(pwc != NULL)
							{
								*pwc = '\0';
							}
							if(_wcsicmp(szBuff,p.m_pszFile)==0)
							{
								wcscpy(szBuff,stFindData.cFileName);
								pwc = NULL;
								pwc = wcsrchr(szBuff, L'.');
								if(pwc != NULL)
								{
									if(_wcsicmp(pwc+1,p.m_pszExt)==0)
									{
										// The file is one of interest, so load values
										// and commit it.
										pInstance.Attach ( CreateNewInstance ( p.m_pMethodContext ) ) ;

										bstrtFullPathName = p.m_pszDrive;
										bstrtFullPathName += p.m_pszPath;
										bstrtFullPathName += stFindData.cFileName;
										if(IsOneOfMe(&stFindData,bstrtFullPathName))
										{
											//LoadPropertyValuesNT(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
											if(wcslen(p.m_pszPath) == 0)
											{
												LoadPropertyValuesNT(pInstance, p.m_pszDrive, L"\\", p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
											}
											else
											{
												LoadPropertyValuesNT(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
											}

											hr = pInstance->Commit () ;
										}
									}
								}
							}
							if(SUCCEEDED(hr))
							{
								// Look for entries that are marked as Directory, and aren't . or ..
								if( (stFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
									(wcscmp(stFindData.cFileName, L".") != 0) &&
									(wcscmp(stFindData.cFileName, L"..") != 0) & p.m_bRecurse)
								{
									// Build path containing the directory we just found
									if(wcslen(p.m_pszPath) == 0)   // were working with root dir; need \\ before filename
									{
										wcscpy(szBuff,L"\\");
									}
									else
									{
										wcscpy(szBuff, p.m_pszPath);
									}
									wcscat(szBuff, stFindData.cFileName);
									wcscat(szBuff, L"\\");

									CNTEnumParm newp(p);
									newp.m_pszPath = szBuff;
									newp.m_bRoot = false;

									hr = EnumDirsNT(newp);
								}
							}
						}
					}
				}
				// Just before repeating, need to munge hr - if it was
				// WBEM_E_ACCESS_DENIED, we want to keep going anyway.
				if(hr == WBEM_E_ACCESS_DENIED)
				{
					hr = WBEM_S_NO_ERROR;
				}
			} while ((FindNextFileW(hFind, &stFindData)) && (SUCCEEDED(hr)));
		} // hFind was valid
	}  // recursing and succeeded hr

	return hr;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CImplement_LogicalFile::IsValidPath
 *
 *  DESCRIPTION : Checks to see whether the path contained both leading and
 *                trailing backslashes.
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

bool CImplement_LogicalFile::IsValidPath(const WCHAR* wstrPath, bool fRoot)
{
    return HasCorrectBackslashes(wstrPath,fRoot);
}

bool CImplement_LogicalFile::IsValidPath(const CHAR* strPath, bool fRoot)
{
    bool fRet = false;
    UINT uiACP = GetACP();
	WCHAR* pwstr = NULL ;
	try
	{
		// Make the string a wide string...
		DWORD dw = MultiByteToWideChar(uiACP, MB_PRECOMPOSED|MB_USEGLYPHCHARS, strPath, -1, NULL, 0);
		if(dw != 0)
		{
			pwstr = (WCHAR*) new WCHAR[dw];
			if(pwstr != NULL)
			{
				if(MultiByteToWideChar(uiACP, MB_PRECOMPOSED|MB_USEGLYPHCHARS, strPath, -1, pwstr, dw) != 0)
				{
					fRet = HasCorrectBackslashes(pwstr,fRoot);
				}				
			}
		}
	}
	catch ( ... )
	{
		if(pwstr != NULL)
		{
			delete pwstr;
			pwstr = NULL;
		}
		throw ;
	}


	if(pwstr != NULL)
	{
		delete pwstr;
		pwstr = NULL;
	}

	return fRet;

}

bool CImplement_LogicalFile::HasCorrectBackslashes(const WCHAR* wstrPath, bool fRoot)
{
    bool fRet = false;

    if(fRoot)
    {
        // Test for root directory; wstrPath should be empty.
        if(wcslen(wstrPath) == 0)
        {
            fRet = true;
        }
    }
    else
    {
        if(wcslen(wstrPath)==0)
        {
            // This is the case where we don't want to return an instance for the root
            // directory, so fRoot is false, but we do want to start the enumeration from
            // the root directory.
            fRet = true;
        }
        else if(wcslen(wstrPath)==1)
        {
            // If the path arguement is just \\ and nothing else
            // (as it would be in the case of c:\\autoexec.bat),
            // and this is not a test for the root directory, all is well.
            if(*wstrPath == L'\\')
            {
                fRet = true;
            }
        }
        else if(wcslen(wstrPath) >= 3)
        {
            if(*wstrPath == L'\\') // is the first char after the drive letter and the colon a backslash?
            {
                // Is the next letter NOT a backslash? (can't have two in a row)
                if(*(wstrPath+1) != L'\\')
                {
                    const WCHAR* pwc1 = wstrPath+1;
                    LONG m = wcslen(pwc1);
                    if(*(pwc1+m-1) == L'\\') // is the final char a backslash?
                    {
                        // Is the character just before the final one not a backslash? (can't have two in a row)
                        if(*(pwc1+m-2) != L'\\')
                        {
                            fRet = true;
                        }
                    }
                    pwc1 = NULL;
                }
            }
        }
    }
    return fRet;
}



/*****************************************************************************
 *
 *  FUNCTION    : CImplement_LogicalFile::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

bool CImplement_LogicalFile::IsValidDrive(const TCHAR* tstrDrive)
{
    DWORD dwDriveType;
    bool bRet = false;

    dwDriveType = GetDriveType(tstrDrive);

    if(((dwDriveType == DRIVE_REMOTE) ||       // NOTE: WITH BUG 43566, IT WAS DECIDED TO INCLUDE NETWORKED DRIVES WITH THIS CLASS AND ALL CLASSES DEPENDENT ON IT.
        (dwDriveType == DRIVE_FIXED) ||
        (dwDriveType == DRIVE_REMOVABLE) ||
        (dwDriveType == DRIVE_CDROM) ||
        (dwDriveType == DRIVE_RAMDISK)) &&
        (CHString(tstrDrive).GetLength() == 3))
    {
        if ((dwDriveType == DRIVE_REMOVABLE) || (dwDriveType == DRIVE_CDROM))
        {
            // Need to check if the drive is really there too...
            if(DrivePresent(tstrDrive))
            {
                bRet = true;
            }
        }
        else
        {
            bRet = true;
        }
    }
   return bRet;
}

#ifdef NTONLY
HRESULT CImplement_LogicalFile::LoadPropertyValuesNT(CInstance* pInstance,
                                                  const WCHAR* pszDrive,
                                                  const WCHAR* pszPath,
                                                  const WCHAR* szFSName,
                                                  LPWIN32_FIND_DATAW pstFindData,
                                                  const DWORD dwReqProps,
                                                  const void* pvMoreData)
{
    // Need buffers to store parms so they can be lowercased...
    WCHAR wstrDrive[_MAX_DRIVE+1];
    WCHAR wstrPath[_MAX_PATH+1];
    // Copy data in...
    wcsncpy(wstrDrive,pszDrive,(sizeof(wstrDrive)/sizeof(WCHAR))-1);
    wcsncpy(wstrPath,pszPath,(sizeof(wstrPath)/sizeof(WCHAR))-1);
    // Lower case it...
    _wcslwr(wstrDrive);
    _wcslwr(wstrPath);


    WCHAR* pChar = NULL;
    WCHAR szBuff[_MAX_PATH * 2] = L"";
    WCHAR szBuff2[_MAX_PATH * 2];
    WCHAR wstrFilename[_MAX_PATH * 2];
    CHString chsSize;
    bool bRoot = false;

    if(pstFindData == NULL)
    {
        bRoot = true;
    }


    // The following (setting the Name property) needs to
    // always be done first.  The Name needs to be set since GetExtendedProps
    // functions often expect to be able to extract it.

    // szBuff is going to contain the string that becomes the name.  For consistency,
    // if the path to the file contains ~ characters (due to an 8dot3 query having been
    // used), the filename portion should be 8dot3 too, not long. If it was already
    // set in the instance, use that; otherwise, create it.
    if(!bRoot)
    {
        if (pInstance->IsNull(IDS_Name))
        {
            wsprintfW(szBuff,L"%s%s%s",pszDrive,pszPath,pstFindData->cFileName);
        }
        else
        {
            CHString chstr;
            pInstance->GetCHString(IDS_Name,chstr);
            if(chstr.GetLength() == 0)
            {
                wsprintfW(szBuff,L"%s%s%s",pszDrive,pszPath,pstFindData->cFileName);
            }
            else
            {
                wcsncpy(szBuff,chstr,_MAX_PATH-1);
            }
        }
    }
    else
    {
        wsprintfW(szBuff,L"%s\\",pszDrive);
    }
    _wcslwr(szBuff);
    pInstance->SetWCHARSplat(IDS_Name, szBuff);

	BOOL bCreateFileFailed = FALSE ;
	SmartCloseHandle hCheckFile = CreateFile	(
													szBuff,
													0,
													FILE_SHARE_DELETE | FILE_SHARE_WRITE | FILE_SHARE_READ ,
													NULL,
													OPEN_EXISTING,

													( ( pstFindData ) ? ( pstFindData->dwFileAttributes ) : 0 ) | FILE_FLAG_BACKUP_SEMANTICS,

													NULL
												);

	if (hCheckFile == INVALID_HANDLE_VALUE)
	{
		if (  ERROR_FILE_NOT_FOUND == ::GetLastError () )
		{
			return WBEM_E_NOT_FOUND ;
		}

		bCreateFileFailed = TRUE ;
	}
	else
	{
		DWORD t_FileType = GetFileType ( hCheckFile ) ;
		if ( t_FileType != FILE_TYPE_DISK )
		{
			return WBEM_E_NOT_FOUND ;
		}
	}

    if(GetAllProps())  // that is, we want base class props plus derived class props
    {
        // Set attributes that are the same whether this was a root or not:
        if(szFSName != NULL && wcslen(szFSName) > 0)
        {
            pInstance->SetWCHARSplat(IDS_FSName, szFSName);
        }
        pInstance->Setbool(IDS_Readable, true);
        pInstance->SetWCHARSplat(IDS_Drive, wstrDrive);
        pInstance->SetCharSplat(IDS_CSCreationClassName, _T("Win32_ComputerSystem"));
        pInstance->SetCHString(IDS_CSName, GetLocalComputerName());
        pInstance->SetCharSplat(IDS_CreationClassName, PROPSET_NAME_FILE);
        pInstance->SetCharSplat(IDS_Status, _T("OK"));
        pInstance->SetCharSplat(IDS_FSCreationClassName, _T("Win32_FileSystem"));


        // Set attributes that depend on whether this was the root or not:
        if(!bRoot)
        {
            if (pstFindData->cAlternateFileName[0] == '\0')
            {
                wsprintfW(szBuff2,L"%s%s%s",wstrDrive,wstrPath,_wcslwr(pstFindData->cFileName));
            }
            else
            {
                wsprintfW(szBuff2,L"%s%s%s",wstrDrive,wstrPath,_wcslwr(pstFindData->cAlternateFileName));
            }
            pInstance->SetWCHARSplat(IDS_EightDotThreeFileName, szBuff2);

			if ( ! ( pstFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) )
			{
	            pChar = wcsrchr(pstFindData->cFileName, '.');
			}

            pInstance->Setbool(IDS_Archive, pstFindData->dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE);
            // In either case, we have FOUND an extension, so we need to return something other than null.
            if (pChar != NULL)
            {
                pInstance->SetWCHARSplat(IDS_Extension, pChar+1);
                // If this is a directory, set FileType to "File Folder".  Otherwise, get the Description
                // of Type for that extension from the registry.
                if(dwReqProps & PROP_FILE_TYPE)
                {
                    if(pstFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    {
                        pInstance->SetCharSplat(IDS_FileType, IDS_FileFolder);
                    }
                    else
                    {
                        CRegistry reg;
                        CHString chstrRegKey;
                        _bstr_t bstrtExtension(pChar+1);
                        CHString chstrExtension = (TCHAR*)bstrtExtension;
                        CHString chstrRegNewSubkey;
                        CHString chstrFileType;
                        chstrFileType.Format(_T("%s %s"), chstrExtension, IDS_File); // this will be our default value
                        chstrRegKey.Format(_T("%s.%s"), IDS_FileTypeKeyNT4, chstrExtension);
                        if(reg.Open(HKEY_LOCAL_MACHINE,chstrRegKey,KEY_READ) == ERROR_SUCCESS)
                        {
                            if(reg.GetCurrentKeyValue(NULL,chstrRegNewSubkey) == ERROR_SUCCESS)
                            {
                                CRegistry reg2;
                                chstrRegKey.Format(_T("%s%s"), IDS_FileTypeKeyNT4, chstrRegNewSubkey);
                                if(reg2.Open(HKEY_LOCAL_MACHINE,chstrRegKey,KEY_READ) == ERROR_SUCCESS)
                                {
                                    CHString chstrTempFileType;
                                    if(reg2.GetCurrentKeyValue(NULL,chstrTempFileType) == ERROR_SUCCESS)
                                    {
                                        chstrFileType = chstrTempFileType;
                                    }
                                }
                            }
                        }
                        pInstance->SetCharSplat(IDS_FileType, chstrFileType);
                    }
                }
            }
            else // the file had no extension
            {
                pInstance->SetWCHARSplat(IDS_Extension, L"");
                if(dwReqProps & PROP_FILE_TYPE)
                {
                    if(pstFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    {
                        pInstance->SetCharSplat(IDS_FileType, IDS_FileFolder);
                    }
			        else
			        {
				        pInstance->SetCharSplat(IDS_FileType, IDS_File);
			        }
                }
            }

			wcscpy(wstrFilename,pstFindData->cFileName);
			if ( ! ( pstFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) )
			{
				pChar = NULL;
				pChar = wcsrchr(wstrFilename, '.');
				if(pChar != NULL)
				{
					*pChar = '\0';
				}
			}

            pInstance->SetWCHARSplat(IDS_Filename, wstrFilename);

            pInstance->SetWCHARSplat(IDS_Caption, szBuff);
            pInstance->SetWCHARSplat(IDS_Path, wstrPath);
            pInstance->SetWCHARSplat(IDS_Description, szBuff);

            pInstance->Setbool(IDS_Writeable, !(pstFindData->dwFileAttributes & FILE_ATTRIBUTE_READONLY));
            if(pstFindData->dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED)
            {
                pInstance->SetWCHARSplat(IDS_CompressionMethod, IDS_Compressed);
                // The following property is redundant with the above, but Win32_Directory shipped
                // with it, so we need to continue to support it
                pInstance->Setbool(IDS_Compressed, pstFindData->dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED);
                // DEV NOTE: In the future, use the DeviceIOControl operation FSCTL_GET_COMPRESSION to
                // obtain the type of compression used.  For now (7/31/98) only one type of compression,
                // LZNT1 is supported, so no compression method string is available through this operation.
                // But it will be, once other compression methods are available.
            }
		    else
		    {
			    pInstance->Setbool(IDS_Compressed, false) ;
		    }

		    if(pstFindData->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED)
            {
                pInstance->SetWCHARSplat(IDS_EncryptionMethod, IDS_Encrypted);
                // The following property is redundant with the above, but Win32_Directory shipped
                // with it, so we need to continue to support it
                pInstance->Setbool(IDS_Encrypted, pstFindData->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED);
            }
		    else
		    {
			    pInstance->Setbool(IDS_Encrypted, false) ;
		    }

		    pInstance->Setbool(IDS_Hidden, pstFindData->dwFileAttributes & FILE_ATTRIBUTE_HIDDEN);
            pInstance->Setbool(IDS_System, pstFindData->dwFileAttributes & FILE_ATTRIBUTE_SYSTEM);


            // Times differ between FAT and NTFS drives...
            if(szFSName != NULL && _tcslen(szFSName) > 0)
            {
                if(_wcsicmp(szFSName,L"NTFS") != 0)
                {
                    // on non-NTFS partitions, the times are possibly off by an hour...
                    if((dwReqProps & PROP_CREATION_DATE) || (dwReqProps & PROP_INSTALL_DATE))
                    {
                        if ((pstFindData->ftCreationTime.dwLowDateTime != 0) && (pstFindData->ftCreationTime.dwHighDateTime != 0))
                        {
                            WBEMTime wbt(pstFindData->ftCreationTime);
                            BSTR bstrRealTime = wbt.GetDMTFNonNtfs();
                            if((bstrRealTime != NULL) && (SysStringLen(bstrRealTime) > 0))
                            {
                                pInstance->SetWCHARSplat(IDS_CreationDate, bstrRealTime);
                                pInstance->SetWCHARSplat(IDS_InstallDate, bstrRealTime);
                                SysFreeString(bstrRealTime);
                            }
                        }
                    }
                    if(dwReqProps & PROP_LAST_ACCESSED)
                    {
                        if ((pstFindData->ftLastAccessTime.dwLowDateTime != 0) && (pstFindData->ftLastAccessTime.dwHighDateTime != 0))
                        {
                            WBEMTime wbt(pstFindData->ftLastAccessTime);
                            BSTR bstrRealTime = wbt.GetDMTFNonNtfs();
                            if((bstrRealTime != NULL) && (SysStringLen(bstrRealTime) > 0))
                            {
                                pInstance->SetWCHARSplat(IDS_LastAccessed, bstrRealTime);
                                SysFreeString(bstrRealTime);
                            }
                        }
                    }
                    if(dwReqProps & PROP_LAST_MODIFIED)
                    {
                        if ((pstFindData->ftLastWriteTime.dwLowDateTime != 0) && (pstFindData->ftLastWriteTime.dwHighDateTime != 0))
                        {
                            WBEMTime wbt(pstFindData->ftLastWriteTime);
                            BSTR bstrRealTime = wbt.GetDMTFNonNtfs();
                            if((bstrRealTime != NULL) && (SysStringLen(bstrRealTime) > 0))
                            {
                                pInstance->SetWCHARSplat(IDS_LastModified, bstrRealTime);
                                SysFreeString(bstrRealTime);
                            }
                        }
                    }
                }
                else  // on nt we can report the time as provided
                {
                    if((dwReqProps & PROP_CREATION_DATE) || (dwReqProps & PROP_INSTALL_DATE))
                    {
                        if((pstFindData->ftCreationTime.dwLowDateTime != 0) && (pstFindData->ftCreationTime.dwHighDateTime != 0))
                        {
                            pInstance->SetDateTime(IDS_CreationDate, pstFindData->ftCreationTime);
                            pInstance->SetDateTime(IDS_InstallDate, pstFindData->ftCreationTime);
                        }
                    }
                    if(dwReqProps & PROP_LAST_ACCESSED)
                    {
                        if((pstFindData->ftLastAccessTime.dwLowDateTime != 0) && (pstFindData->ftLastAccessTime.dwHighDateTime != 0))
                        {
                            pInstance->SetDateTime(IDS_LastAccessed, pstFindData->ftLastAccessTime);
                        }
                    }
                    if(dwReqProps & PROP_LAST_MODIFIED)
                    {
                        if((pstFindData->ftLastWriteTime.dwLowDateTime != 0) && (pstFindData->ftLastWriteTime.dwHighDateTime != 0))
                        {
                            pInstance->SetDateTime(IDS_LastModified, pstFindData->ftLastWriteTime);
                        }
                    }
                }
            }
        }
        else   // the root case
        {
            wsprintfW(szBuff,L"%s\\",pszDrive);
            pInstance->SetWCHARSplat(IDS_EightDotThreeFileName, L""); // root directory has no 8dot3 filename
            pInstance->SetWCHARSplat(IDS_Caption, szBuff);
            pInstance->SetWCHARSplat(IDS_Path, L"");  // root directory has empty path
            pInstance->SetWCHARSplat(IDS_Filename, L"");  // root directory has empty filename
            pInstance->SetWCHARSplat(IDS_Extension, L"");  // root directory has empty extension
            pInstance->SetWCHARSplat(IDS_Description, szBuff);
            pInstance->SetWCHARSplat(IDS_FileType, IDS_LocalDisk);
        }

        // Whether we are looking at the root or not, we may want the AccessMask property...
        if(dwReqProps & PROP_ACCESS_MASK)
        {
            if(szFSName != NULL && wcslen(szFSName) > 0)
            {
                if(_wcsicmp(szFSName,L"FAT") == 0 || _wcsicmp(szFSName,L"FAT32") == 0)
                {   // on fat volumes, indicate that no security has been set (e.g., full access for all)
                    pInstance->SetDWORD(IDS_AccessMask, -1L);
                }
                else
                {
					if ( FALSE == bCreateFileFailed )
					{
						SmartCloseHandle hFile = CreateFile(szBuff,
															MAXIMUM_ALLOWED,
															FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE ,
															NULL,
															OPEN_EXISTING,
															FILE_FLAG_BACKUP_SEMANTICS,
															NULL
															);

						if (hFile != INVALID_HANDLE_VALUE)
						{
							FILE_ACCESS_INFORMATION fai;
							IO_STATUS_BLOCK iosb;
							memset(&fai, 0, sizeof(FILE_ACCESS_INFORMATION));
							memset(&iosb, 0, sizeof(IO_STATUS_BLOCK));

							if ( NT_SUCCESS( NtQueryInformationFile( hFile,
												&iosb,
												&fai,
												sizeof( FILE_ACCESS_INFORMATION ),
												FileAccessInformation
											) )
							)
							{
								pInstance->SetDWORD(IDS_AccessMask, fai.AccessFlags);
							}
						}
						else
						{
							DWORD dwErr = GetLastError();

							if (dwErr == ERROR_ACCESS_DENIED)
							{
								pInstance->SetDWORD( IDS_AccessMask, 0L );
							}
						}
					}
                }
            }
        }
    }

	if ( FALSE == bCreateFileFailed )
	{
		// Need the extended (e.g., class specific) properties
		GetExtendedProperties(pInstance, dwReqProps);
	}
	else
	{
		//
		// if size is requested and we have FindFirstData
		// we could use it to fill FileSize property even
		// without calling into GetExtendProperties
		//

		if ( dwReqProps & PROP_FILESIZE)
        {
			if ( NULL != pstFindData )
			{
				__int64 LoDW = (__int64)(pstFindData->nFileSizeLow);
				__int64 HiDW = (__int64)(pstFindData->nFileSizeHigh);
				__int64 FileSize = (HiDW << 32) + LoDW;

				WCHAR strSize [ 40 ] ;
				_i64tow ( FileSize, strSize, 10 ) ;
				pInstance->SetWBEMINT64 ( IDS_Filesize, strSize ) ;
			}
		}
	}

	return WBEM_S_NO_ERROR ;
}
#endif


#ifdef NTONLY
HRESULT CImplement_LogicalFile::FindSpecificPathNT(CInstance *pInstance,
                        const WCHAR* sDrive, const WCHAR* sDir, DWORD dwReqProps)
{
	WIN32_FIND_DATAW
				stFindData,
				*pfdToLoadProp;
	HANDLE	hFind;
	WCHAR		szFSName[_MAX_PATH] = L"";
	BOOL		bIsRoot = !wcscmp(sDir, L"");  // sDir contains the path and name of file, so if that combination is just empty, we are indeed looking at the root.
	_bstr_t	bstrFullPath,
				bstrRoot;

	bstrFullPath = sDrive;
	bstrFullPath += sDir;

	bstrRoot = sDrive;
	bstrRoot += L"\\";

    bool fContinue = true;
    HRESULT hr = WBEM_E_NOT_FOUND;

	// if the directory contained a wildcard character, return WBEM_E_NOT_FOUND.
	if (wcspbrk(sDir,L"?*") != NULL)
    {
    	fContinue = false;
    }

	// FindFirstW doesn't work with root dirs (since they're not real dirs.)
    DWORD dwErr = E_FAIL;

    if(fContinue)
    {
	    if (bIsRoot)
        {
		    pfdToLoadProp = NULL;
        }
	    else
	    {
		    pfdToLoadProp = &stFindData;
		    ZeroMemory(&stFindData, sizeof(stFindData));

		    hFind = FindFirstFileW((LPCWSTR) bstrFullPath, &stFindData);
            dwErr = ::GetLastError();
		    if (hFind == INVALID_HANDLE_VALUE)
            {
		        fContinue = false;
            }
		    FindClose(hFind);
	    }
    }

	// If GetVolumeInformationW fails, only get out if we're trying
	// to get the root.
    BOOL fGotVolInfo = FALSE;

    if(fContinue)
    {
        try
        {
            if(dwReqProps & PROP_FILE_SYSTEM)
            {
                fGotVolInfo = GetVolumeInformationW(bstrRoot, NULL, 0, NULL, NULL, NULL,
		        szFSName, sizeof(szFSName)/sizeof(WCHAR));
                dwErr = ::GetLastError();
                if(!fGotVolInfo && bIsRoot)
                {
                    fContinue = false;
                }
            }
        }
        catch(...)
        {
            if(!fGotVolInfo && bIsRoot)
            {
                fContinue = false;
            }
        }
    }

	if(fContinue)
    {
        if(!IsOneOfMe(pfdToLoadProp, bstrFullPath))
        {
		    fContinue = false;;
        }
    }

    if(fContinue)
    {
	    if (bIsRoot)
        {
            hr = LoadPropertyValuesNT(pInstance, sDrive, sDir, szFSName, NULL, dwReqProps, NULL);
        }
        else
        {
            // sDir contains \\path\\morepath\\filename.exe at this point, instead
            // of just \\path\\morepath\\, so need to hack of the last part.
		    WCHAR* wstrJustPath = NULL ;
		    try
		    {
			    wstrJustPath = (WCHAR*) new WCHAR[wcslen(sDir) + 1];
			    WCHAR* pwc = NULL;
			    ZeroMemory(wstrJustPath,(wcslen(sDir) + 1)*sizeof(WCHAR));
			    wcscpy(wstrJustPath,sDir);
			    pwc = wcsrchr(wstrJustPath, L'\\');
			    if(pwc != NULL)
			    {
				    *(pwc+1) = L'\0';
			    }
			    hr=LoadPropertyValuesNT(pInstance, sDrive, wstrJustPath, szFSName, pfdToLoadProp, dwReqProps, NULL);
		    }
		    catch ( ... )
		    {
                if ( wstrJustPath )
			    {
				    delete wstrJustPath ;
				    wstrJustPath = NULL ;
			    }
			    throw ;
		    }

			delete wstrJustPath;
			wstrJustPath = NULL ;
        }
    }

	return hr;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CImplement_LogicalFile::DetermineReqProps
 *
 *  DESCRIPTION : Determines which of a certain set of properties are required
 *
 *  INPUTS      : Reference to query object, DWORD bit field
 *
 *  OUTPUTS     : None.
 *
 *  RETURNS     : Number of properties newly determined to be required
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
LONG CImplement_LogicalFile::DetermineReqProps(CFrameworkQuery& pQuery,
                                               DWORD* pdwReqProps)
{
    DWORD dwRet = PROP_NO_SPECIAL;
    LONG lNumNewPropsSet = 0L;
    dwRet |= *pdwReqProps;

    if(pQuery.KeysOnly())
    {
        dwRet |= PROP_KEY_ONLY;
        lNumNewPropsSet++;
    }
    else
    {
        if(pQuery.IsPropertyRequired(IDS_CompressionMethod))
        {
            dwRet |= PROP_COMPRESSION_METHOD;
            lNumNewPropsSet++;
        }
        if(pQuery.IsPropertyRequired(IDS_EncryptionMethod))
        {
            dwRet |= PROP_ENCRYPTION_METHOD;
            lNumNewPropsSet++;
        }
        if(pQuery.IsPropertyRequired(IDS_FileType))
        {
            dwRet |= PROP_FILE_TYPE;
            lNumNewPropsSet++;
        }
        if(pQuery.IsPropertyRequired(IDS_Manufacturer))
        {
            dwRet |= PROP_MANUFACTURER;
            lNumNewPropsSet++;
        }
        if(pQuery.IsPropertyRequired(IDS_Version))
        {
            dwRet |= PROP_VERSION;
            lNumNewPropsSet++;
        }
        if(pQuery.IsPropertyRequired(IDS_Target))
        {
            dwRet |= PROP_TARGET;
            lNumNewPropsSet++;
        }
        if(pQuery.IsPropertyRequired(IDS_Filesize))
        {
            dwRet |= PROP_FILESIZE;
            lNumNewPropsSet++;
        }
        if(pQuery.IsPropertyRequired(IDS_FSName))
        {
            dwRet |= PROP_FILE_SYSTEM;
            lNumNewPropsSet++;
        }
        if(pQuery.IsPropertyRequired(IDS_AccessMask))
        {
            dwRet |= PROP_ACCESS_MASK;
            lNumNewPropsSet++;
        }
        if(pQuery.IsPropertyRequired(IDS_CreationDate))
        {
            dwRet |= PROP_CREATION_DATE;
            lNumNewPropsSet++;
        }
        if(pQuery.IsPropertyRequired(IDS_LastAccessed))
        {
            dwRet |= PROP_LAST_ACCESSED;
            lNumNewPropsSet++;
        }
        if(pQuery.IsPropertyRequired(IDS_LastModified))
        {
            dwRet |= PROP_LAST_MODIFIED;
            lNumNewPropsSet++;
        }
        if(pQuery.IsPropertyRequired(IDS_InstallDate))
        {
            dwRet |= PROP_INSTALL_DATE;
            lNumNewPropsSet++;
        }
        // Additionally, if certain items were asked for
        // for which we must get other info, change the flags
        // to suit.
        if((dwRet & PROP_ACCESS_MASK) ||
           (dwRet & PROP_CREATION_DATE) ||
           (dwRet & PROP_LAST_ACCESSED) ||
           (dwRet & PROP_LAST_MODIFIED) ||
           (dwRet & PROP_INSTALL_DATE))
        {
            dwRet |= PROP_FILE_SYSTEM;
        }

    }
    *pdwReqProps = dwRet;
    return lNumNewPropsSet;
}


/*****************************************************************************
 *
 *  FUNCTION    : CImplement_LogicalFile::GetAllProps
 *
 *  DESCRIPTION : Determines if base class properties are required, or if only
 *                derived class properties will suffice.
 *
 *  INPUTS      : The name of the class that the request is satisfying
 *
 *  OUTPUTS     : None.
 *
 *  RETURNS     : true if base class properties are required
 *
 *  COMMENTS    : It should be noted that this function accomplishes something
 *                different from what DetermineReqProps supports.  This function gives us
 *                the ability to get all the properties for a given instance of,
 *                say, Win32_Shortcutfile only once when we specify * in the query,
 *                rather than twice (once in the Win32_Shortcutfile instance,
 *                and once in the Cim_DataFile instance).  It also allows us to
 *                intelligently modify queries in some cases (for instance, we
 *                can specify an extension of "lnk" (if we are looking for
 *                Win32_Shortcutfile instances) in ExecQuery.
 *
 *****************************************************************************/
bool CImplement_LogicalFile::GetAllProps()
{
    bool fRet = false;
    CHString chstr(GetProviderName());
    if(chstr.CompareNoCase(PROPSET_NAME_CIMDATAFILE)==0 ||
        chstr.CompareNoCase(PROPSET_NAME_DIRECTORY)==0)
    {
        fRet = true;
    }
    return fRet;
}

/*****************************************************************************
 *
 *  FUNCTION    : CImplement_LogicalFile::IsClassShortcutFile
 *
 *  DESCRIPTION : Determines if the class passed in was a Win32_ShortcutFile.
 *
 *  INPUTS      : The name of the class that the request is satisfying
 *
 *  OUTPUTS     : None.
 *
 *  RETURNS     : true if class is Win32_ShortcutFile.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
bool CImplement_LogicalFile::IsClassShortcutFile()
{
    bool fRet = false;
    CHString chstr(typeid(*this).name());
    if(chstr.CompareNoCase(L"class CShortcutFile")==0)
    {
        fRet = true;
    }
    return fRet;
}



/*****************************************************************************
 *
 *  FUNCTION    : CImplement_LogicalFile::GetPathPieces
 *
 *  DESCRIPTION : Helper that does splitpath work on chstrings.
 *
 *  INPUTS      : Full path name
 *
 *  OUTPUTS     : path components
 *
 *  RETURNS     : none
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
void CImplement_LogicalFile::GetPathPieces(const CHString& chstrFullPathName,
                                           CHString& chstrDrive,
                                           CHString& chstrPath,
                                           CHString& chstrName,
                                           CHString& chstrExt)
{
    WCHAR* wstrDrive = NULL;
    WCHAR* wstrPath = NULL;
    WCHAR* wstrFile = NULL;
    WCHAR* wstrExt = NULL;

    try
    {
        wstrDrive = new WCHAR[_MAX_PATH];
        wstrPath = new WCHAR[_MAX_PATH];
        wstrFile = new WCHAR[_MAX_PATH];
        wstrExt = new WCHAR[_MAX_PATH];

		ZeroMemory(wstrDrive, _MAX_PATH*sizeof(WCHAR));
		ZeroMemory(wstrPath, _MAX_PATH*sizeof(WCHAR));
		ZeroMemory(wstrFile, _MAX_PATH*sizeof(WCHAR));
		ZeroMemory(wstrExt, _MAX_PATH*sizeof(WCHAR));

		if(wstrDrive != NULL && wstrPath != NULL && wstrFile != NULL && wstrExt != NULL)
		{

#ifdef NTONLY
		_wsplitpath((LPCTSTR)chstrFullPathName,wstrDrive,wstrPath,wstrFile,wstrExt);
#endif
			chstrDrive = wstrDrive;
			chstrPath = wstrPath;
			chstrName = wstrFile;
			chstrExt = wstrExt;
		}
    }
    catch(...)
    {
        if(wstrDrive != NULL)
        {
            delete wstrDrive;
            wstrDrive = NULL;
        }
        if(wstrPath != NULL)
        {
            delete wstrPath;
            wstrPath = NULL;
        }
        if(wstrFile != NULL)
        {
            delete wstrFile;
            wstrFile = NULL;
        }
        if(wstrExt != NULL)
        {
            delete wstrExt;
            wstrExt = NULL;
        }
        throw;
    }

    if(wstrDrive != NULL)
    {
        delete wstrDrive;
        wstrDrive = NULL;
    }
    if(wstrPath != NULL)
    {
        delete wstrPath;
        wstrPath = NULL;
    }
    if(wstrFile != NULL)
    {
        delete wstrFile;
        wstrFile = NULL;
    }
    if(wstrExt != NULL)
    {
        delete wstrExt;
        wstrExt = NULL;
    }
}

void CImplement_LogicalFile::GetExtendedProperties(CInstance* pInstance, long lFlags /*= 0L*/)
{
}


bool CImplement_LogicalFile::DrivePresent(LPCTSTR tstrDrive)
{
    bool fRet = false;
    // Convert the drive letter to a number (the indeces are 1 based)
	int nDrive = ( toupper(*tstrDrive) - 'A' ) + 1;

#ifdef NTONLY
	// The following code was lifted from Knowledge Base Article
	// Q163920.  The code uses DeviceIoControl to discover the
	// type of drive we are dealing with.

	TCHAR szDriveName[8];
	wsprintf(szDriveName, TEXT("\\\\.\\%c:"), TEXT('@') + nDrive);

    DWORD dwAccessMode = FILE_READ_ACCESS;

	SmartCloseHandle hVMWIN32 = CreateFile (szDriveName,
		                                    dwAccessMode,
		                                    FILE_SHARE_WRITE | FILE_SHARE_READ,
		                                    0,
		                                    OPEN_EXISTING,
		                                    0,
		                                    0);

	if ( hVMWIN32 != INVALID_HANDLE_VALUE )
	{
        // Verify media present...
		DWORD t_BytesReturned ;
		if(DeviceIoControl(hVMWIN32,
//#if NTONLY >= 5
//			               IOCTL_STORAGE_CHECK_VERIFY ,
//#else
                           IOCTL_DISK_CHECK_VERIFY,
//#endif
			               NULL,
			               0,
			               NULL,
			               0,
			               &t_BytesReturned,
			               0))
        {
            fRet = true;
        }
    }
#endif

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\implement_logicalfile.h ===
//=================================================================
//
// Implement_LogicalFile.h -- 
//
//  Copyright (c) 1998-2002 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/02/98    a-kevhu         Created
//
//=================================================================

//NOTE: The CImplement_LogicalFile class is not exposed to the outside world thru the mof. It now has implementations 
//		of EnumerateInstances & GetObject which were earlier present in CCimLogicalFile. CImplement_LogicalFile can't be 
//		instantiated since it has pure virtual declaration of the IsOneOfMe  method which the derived classes  should 
//		implement.

#ifndef _IMPLEMENT_LOGICALFILE_H
#define _IMPLEMENT_LOGICALFILE_H


//***************************************************************************************************
// Flags defined for use in determining whether certain expensive properties are required in queries.
// DEVNOTE: If you add to this list, be sure to enhance the function DetermineReqProps().

//   First, those common to all cim_logicalfile derived classes
#define PROP_NO_SPECIAL                          0x00000000
#define PROP_KEY_ONLY                            0x10000000
#define PROP_ALL_SPECIAL                         0x0FFFFFFF
#define PROP_COMPRESSION_METHOD                  0x00000001
#define PROP_ENCRYPTION_METHOD                   0x00000002
#define PROP_FILE_TYPE                           0x00000004
#define PROP_MANUFACTURER                        0x00000008
#define PROP_VERSION                             0x00000010
#define PROP_FILESIZE                            0x00000020
#define PROP_FILE_SYSTEM                         0x00000040
#define PROP_ACCESS_MASK                         0x00000080
#define PROP_CREATION_DATE                       0x00000100
#define PROP_LAST_ACCESSED                       0x00000200
#define PROP_LAST_MODIFIED                       0x00000400
#define PROP_INSTALL_DATE                        0x00000800
//   Then, those for specific classes derived from cim_logicalfile
//       Shortcut files
#define PROP_TARGET                              0x00010000

//***************************************************************************************************


#include "file.h"

class CDriveInfo
{
    public:
        CDriveInfo();
        CDriveInfo(WCHAR* wstrDrive, WCHAR* wstrFS);  
        ~CDriveInfo();

        WCHAR m_wstrDrive[8];
        WCHAR m_wstrFS[56];
};

class CEnumParm
{
    public:
        CEnumParm();
        CEnumParm(MethodContext* pMethodContext,
                  bool bRecurse,
                  DWORD dwReqProps,
                  bool bRoot,
                  void* pvMoreData);
        
        ~CEnumParm();

        MethodContext* m_pMethodContext;
        bool m_bRecurse;
        DWORD m_dwReqProps;
        bool m_bRoot;
        void* m_pvMoreData;
};

inline CEnumParm::CEnumParm()
:   m_bRecurse(false),
    m_dwReqProps(0L),
    m_bRoot(false),
    m_pMethodContext(NULL),
    m_pvMoreData(NULL)
{
}

inline CEnumParm::CEnumParm(MethodContext* pMethodContext,
                            bool bRecurse,
                            DWORD dwReqProps,
                            bool bRoot,
                            void* pvMoreData) 
:  m_pMethodContext(pMethodContext), 
   m_bRecurse(bRecurse),
   m_dwReqProps(dwReqProps),
   m_bRoot(bRoot),
   m_pvMoreData(pvMoreData)
{
}

inline CEnumParm::~CEnumParm()
{
}


#ifdef NTONLY
class CNTEnumParm : public CEnumParm
{
    public:
        CNTEnumParm();
        CNTEnumParm(MethodContext* pMethodContext,
                    const WCHAR* pszDrive,
                    const WCHAR* pszPath,
                    const WCHAR* pszFile,
                    const WCHAR* pszExt,
                    bool bRecurse,
                    const WCHAR* szFSName,
                    DWORD dwReqProps,
                    bool bRoot,
                    void* pvMoreData);

        CNTEnumParm(CNTEnumParm& oldp);
        
        ~CNTEnumParm();

        const WCHAR* m_pszDrive;
        const WCHAR* m_pszPath;
        const WCHAR* m_pszFile;
        const WCHAR* m_pszExt;
        const WCHAR* m_szFSName;
};

inline CNTEnumParm::CNTEnumParm()
{
}

inline CNTEnumParm::~CNTEnumParm()
{
}

inline CNTEnumParm::CNTEnumParm(MethodContext* pMethodContext,
                    const WCHAR* pszDrive,
                    const WCHAR* pszPath,
                    const WCHAR* pszFile,
                    const WCHAR* pszExt,
                    bool bRecurse,
                    const WCHAR* szFSName,
                    DWORD dwReqProps,
                    bool bRoot,
                    void* pvMoreData) 
:   CEnumParm(pMethodContext, bRecurse, dwReqProps, bRoot, pvMoreData),
    m_pszDrive(pszDrive),
    m_pszPath(pszPath),
    m_pszFile(pszFile),
    m_pszExt(pszExt),
    m_szFSName(szFSName)
{
}

inline CNTEnumParm::CNTEnumParm(CNTEnumParm& oldp)
{
    m_pMethodContext = oldp.m_pMethodContext;
    m_bRecurse = oldp.m_bRecurse;
    m_dwReqProps = oldp.m_dwReqProps;
    m_bRoot = oldp.m_bRoot;
    m_pszDrive = oldp.m_pszDrive;
    m_pszPath = oldp.m_pszPath;
    m_pszFile = oldp.m_pszFile;
    m_pszExt = oldp.m_pszExt;
    m_szFSName = oldp.m_szFSName;
    m_pvMoreData = oldp.m_pvMoreData;               
}

#endif

//#define  PROPSET_NAME_FILE "CIM_LogicalFile"



class CImplement_LogicalFile: public CCIMLogicalFile
{    

    public:

        // Constructor/destructor
        //=======================

        CImplement_LogicalFile(LPCWSTR name, LPCWSTR pszNamespace);
       ~CImplement_LogicalFile() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery& pQuery);
        virtual HRESULT EnumerateInstances(MethodContext* pMethodContext, 
                                           long lFlags = 0L);
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, 
                                  CFrameworkQuery& pQuery, 
                                  long lFlags = 0L);



    protected:
		
        // Some derived association classes use these functions...
        void GetPathPieces(const CHString& chstrFullPath, 
                           CHString& chstrDrive, 
                           CHString& chstrPath,
                           CHString& chstrName, 
                           CHString& chstrExt);

        LONG DetermineReqProps(CFrameworkQuery& pQuery,
                               DWORD* pdwReqProps);

        void GetDrivesAndFS(
            std::vector<CDriveInfo*>& vecpDI, 
            bool fGetFS = false, 
            LPCTSTR tstrDriveSet = NULL);

        BOOL GetIndexOfDrive(const WCHAR* wstrDrive, 
                             std::vector<CDriveInfo*>& vecpDI, 
                             LONG* lDriveIndex);

        void FreeVector(std::vector<CDriveInfo*>& vecpDI);
        
        // Note: IsOneOfMe function used by derived classes to filter out what 
        // they allow to be reported as "one of them".  In this class, for instance,
        // it will always return true.  In classes derived from this one, such as
        // Win32_Directory, they will return true only if the file is a directory.
         
#ifdef NTONLY
        virtual BOOL IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
                               const WCHAR* wstrFullPathName = 0) = 0;

        HRESULT EnumDirsNT(CNTEnumParm& p);

        virtual HRESULT LoadPropertyValuesNT(CInstance* pInstance,
                                          const WCHAR* pszDrive, 
                                          const WCHAR* pszPath, 
                                          const WCHAR* pszFSName, 
                                          LPWIN32_FIND_DATAW pstFindData,
                                          const DWORD dwReqProps,
                                          const void* pvMoreData);

#endif
        virtual void GetExtendedProperties(CInstance *pInstance, long lFlags = 0L);
        bool IsValidDrive(LPCTSTR szDrive);
        

		bool GetAllProps();

    private:


        bool IsClassShortcutFile();
		void EnumDrives(MethodContext* pMethodContext, LPCTSTR pszPath);
        bool IsValidPath(const WCHAR* wstrPath, bool fRoot);
        bool IsValidPath(const CHAR* strPath, bool fRoot);
        bool HasCorrectBackslashes(const WCHAR* wstrPath, bool fRoot);
        bool DrivePresent(LPCTSTR tstrDrive);
        
#ifdef NTONLY
		HRESULT FindSpecificPathNT(CInstance* pInstance, 
                                   const WCHAR* sDrive, 
                                   const WCHAR* sDir,
                                   DWORD dwProperties);
#endif
};


#endif  // _IMPLEMENT_LOGICALFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\irq.h ===
///////////////////////////////////////////////////////////////////////

//                                                                   //

// IRQ.h -- IRQ property set description for WBEM MO                 //

//                                                                   //

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved //
//                                                                   //
// 10/18/95     a-skaja     Prototype                                //
// 09/13/96     jennymc     Updated to meet current standards        //
// 09/12/97		a-sanjes	Added LocateNTOwnerDevice and added		 //
//                                                                   //
///////////////////////////////////////////////////////////////////////

#define PROPSET_NAME_IRQ L"Win32_IRQResource"


class CWin32IRQResource : public Provider{

    public:

        //=================================================
        // Constructor/destructor
        //=================================================

        CWin32IRQResource(LPCWSTR name, LPCWSTR pszNamespace);
       ~CWin32IRQResource() ;

        //=================================================
        // Functions provide properties with current values
        //=================================================
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);

#if NTONLY == 4
        HRESULT GetNTIRQ(MethodContext*  pMethodContext,
                         CInstance *pSpecificInstance );
#endif
#if NTONLY > 4
        HRESULT GetW2KIRQ(
            MethodContext* pMethodContext,
            CInstance* pSpecificInstance);

        void SetNonKeyProps(
            CInstance* pInstance, 
            CDMADescriptor* pDMA);
        
        bool FoundAlready(
            ULONG ulKey,
            std::set<long>& S);

#endif

        //=================================================
        // Utility
        //=================================================
    private:
        bool BitSet(unsigned int iUsed[], ULONG iPos, DWORD iSize);
        void SetCommonProperties(
            CInstance *pInstance,
            DWORD dwIRQ,
            BOOL bHardware);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\keyboard.cpp ===
//=================================================================

//

// Keyboard.CPP --Keyboard property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//				 10/23/97	 a-hhance       ported to new world order
//
//=================================================================

#include "precomp.h"

#include "Keyboard.h"
#include <vector>
#include "resource.h"

// Property set declaration
//=========================
Keyboard MyKeyboardSet ( PROPSET_NAME_KEYBOARD , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : Keyboard::Keyboard
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

Keyboard :: Keyboard (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Keyboard::~Keyboard
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

Keyboard :: ~Keyboard ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Keyboard::GetObject
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    : Makes the assumption that there exists only one keyboard --
 *                this will be enhanced later
 *
 *****************************************************************************/

HRESULT Keyboard :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    // Make a list of the keyboards that exist

    std::vector<CHString> vecchstrKeyboardList ;
    GenerateKeyboardList ( vecchstrKeyboardList ) ;

    CHString chstrTemp;
    pInstance->GetCHString ( IDS_DeviceID , chstrTemp ) ;

    LONG lKeyboardIndex = -1 ;

    // Need to confirm that the keyboard really exists

    if ( ( lKeyboardIndex = ReallyExists ( chstrTemp , vecchstrKeyboardList ) ) != -1 )
    {
        // If so, first, load the PNPDeviceID out of the list

        pInstance->SetCHString ( IDS_PNPDeviceID , vecchstrKeyboardList [ lKeyboardIndex ] ) ;

        // then load the rest of the property values.

        hr = LoadPropertyValues ( pInstance ) ;
    }

    if ( FAILED ( hr ) )
    {
        hr = WBEM_E_NOT_FOUND ;
    }

	return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : Keyboard::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each installed client
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    : Makes the assumption that there exists only one keyboard --
 *                this will be enhanced later
 *
 *****************************************************************************/

HRESULT Keyboard :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Make a list of keyboard PNPDeviceID's from config manager:

    std::vector<CHString> vecchstrKeyboardList;
    GenerateKeyboardList(vecchstrKeyboardList);

    for ( LONG m = 0L ; m < vecchstrKeyboardList.size () && SUCCEEDED ( hr ) ; m++ )
    {
        CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;

		// Set keyboard data
		pInstance->SetCHString ( IDS_PNPDeviceID , vecchstrKeyboardList [ m ] ) ;
		pInstance->SetCharSplat ( IDS_DeviceID , vecchstrKeyboardList [ m ] ) ;

		// Commit the instance

		hr = LoadPropertyValues(pInstance);

		if ( SUCCEEDED ( hr ) )
		{
			hr = pInstance->Commit ( ) ;
        }
    }
    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : Keyboard::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to property set
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Keyboard::LoadPropertyValues(CInstance* pInstance)
{

	// If we were able to get a Keyboard Type, assume the keyboard is
	// installed, otherwise not.

    // All we get here is type

    int nKeyboardType = GetKeyboardType ( 0 ) ;

	if ( 0 != nKeyboardType )
	{
        CHString sTemp2;

        switch ( nKeyboardType )
        {
			case 1:
			{
                LoadStringW(sTemp2, IDR_PCXT);
			}
			break ;

			case 2:
			{
                LoadStringW(sTemp2, IDR_ICO);
			}
			break ;

			case 3:
			{
                LoadStringW(sTemp2, IDR_PCAT);
			}
			break ;

			case 4:
			{
                LoadStringW(sTemp2, IDR_ENHANCED101102);
			}
			break ;

			case 5:
			{
                LoadStringW(sTemp2, IDR_NOKIA1050);
			}
			break ;

			case 6:
			{
                LoadStringW(sTemp2, IDR_NOKIA9140);
			}
			break ;

			case 7:
			{
                LoadStringW(sTemp2, IDR_Japanese);
			}
			break ;

			default:
			{
                LoadStringW(sTemp2, IDR_UnknownKeyboard);
			}
			break ;
		}

		pInstance->SetCHString(IDS_Name, sTemp2);
		pInstance->SetCHString(IDS_Caption, sTemp2);

		pInstance->SetDWORD ( IDS_NumberOfFunctionKeys , (DWORD) GetKeyboardType ( 2 ) ) ;

	    TCHAR szTemp [ _MAX_PATH ] ;
		if ( GetKeyboardLayoutName ( szTemp ) )
        {
			pInstance->SetCharSplat(IDS_Layout, szTemp);
		}

		pInstance->Setbool ( IDS_PowerManagementSupported , FALSE ) ;

        // Need the PNPDeviceID in order to get the device description:

        CHString chstrPNPDID;
        if ( pInstance->GetCHString ( IDS_PNPDeviceID , chstrPNPDID ) )
        {
            GetDevicePNPInformation ( pInstance , chstrPNPDID ) ;
        }

	    pInstance->SetCharSplat ( IDS_SystemCreationClassName , L"Win32_ComputerSystem" ) ;
  	    pInstance->SetCHString ( IDS_SystemName , GetLocalComputerName () ) ;

	    // Saves the creation class name

	    SetCreationClassName ( pInstance ) ;
	}

	// Returns whether or not we got an initial keyboard type
    return ( nKeyboardType ?  WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND);
}


/*****************************************************************************
 *
 *  FUNCTION    : Keyboard::GetDeviceDescription
 *
 *  DESCRIPTION : helper to obtain a device's description given its PNPDeviceID.
 *
 *  INPUTS      : chstrPNPDevID - pnp device id of device of interest
 *
 *  OUTPUTS     : chstrDeviceDescription - Device description (which is what we
 *                   use as the DeviceID in the mof for this class).
 *
 *  RETURNS     : LONG: reference in array of the keyboard (zero based).
 *                   -1L will be returned if the element isn't in the array.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL Keyboard::GetDevicePNPInformation (

	CInstance *a_Instance,
	CHString& chstrPNPDevID
)
{
    BOOL fRet = FALSE;

    CConfigManager cfgmgr;
    CConfigMgrDevicePtr pKeyboard;

    if ( cfgmgr.LocateDevice ( chstrPNPDevID, pKeyboard ) )
    {
		CHString chstrDeviceDescription ;
		if ( pKeyboard->GetDeviceDesc ( chstrDeviceDescription ) )
		{
			a_Instance->SetCHString ( IDS_Description , chstrDeviceDescription ) ;

			fRet = TRUE;
		}

		SetConfigMgrProperties ( pKeyboard , a_Instance ) ;

		DWORD t_ConfigStatus = 0 ;
		DWORD t_ConfigError = 0 ;

		if ( pKeyboard->GetStatus ( &t_ConfigStatus , & t_ConfigError ) )
		{
			CHString t_chsTmp ;
			ConfigStatusToCimStatus ( t_ConfigStatus , t_chsTmp ) ;

			a_Instance->SetCHString ( IDS_Status, t_chsTmp ) ;
		}
    }

	if ( ! fRet )
	{
	    CHString chstrDeviceDescription ;

		a_Instance->GetCHString ( IDS_Caption , chstrDeviceDescription ) ;
		a_Instance->SetCHString ( IDS_Description , chstrDeviceDescription ) ;
	}

    return fRet;
}



/*****************************************************************************
 *
 *  FUNCTION    : Keyboard::GenerateKeyboardList
 *
 *  DESCRIPTION : helper to construct a list of keyboards by their PNPDeviceIDs
 *
 *  INPUTS      : stl vector of CHStrings
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : none
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
VOID Keyboard::GenerateKeyboardList(std::vector<CHString>& vecchstrKeyboardList)
{

    BOOL fGotDevList = FALSE ;

    CConfigManager cfgmgr;
    CDeviceCollection deviceList ;

#ifdef NTONLY

    BOOL bIsNT5 = IsWinNT5 () ;
    if(bIsNT5)
    {
        //fGotDevList = cfgmgr.GetDeviceListFilterByClassGUID(deviceList, "{4D36E96B-E325-11CE-BFC1-08002BE10318}");

        // HID USB devices are returned this way, but without any bus information, which causes an enumeration
        // of what devices are on a USB bus to fail.  So we do it the following way:
        // 1) Get all the devices where the class is {4D36E96B-E325-11CE-BFC1-08002BE10318}.  Also get all devices where service is "HidUsb".
        // 2) Go through list of devices returned from "kbdclass", and see if the DeviceId for the device
        //    includes the string HID at the beginning.
        // 3) If one is found (format of string is HID\xxxxxxx\yyyyy), compare xxxxxx to the DeviceID of the
        //    devices returned from enumeration of devices where service is "HidUsb" from step 1 (format of these
        //    entries is similarly USB\zzzzzzz\qqqqq)
        //    a. If xxxxxx == zzzzzzz, then add device zzzzzzz to the vector.
        // 4) If we can't find a matching HID entry, use what we got

        CDeviceCollection HIDDeviceList;

        cfgmgr.GetDeviceListFilterByClassGUID(deviceList, _T("{4D36E96B-E325-11CE-BFC1-08002BE10318}"));
        cfgmgr.GetDeviceListFilterByService(HIDDeviceList, _T("HidUsb"));

        REFPTR_POSITION pos = 0;
        if ( deviceList.BeginEnum ( pos ) )
        {
            CConfigMgrDevicePtr pKeyboard;

            for (pKeyboard.Attach(deviceList.GetNext ( pos ));
                 pKeyboard != NULL;
                 pKeyboard.Attach(deviceList.GetNext ( pos )))
            {
				CHString chstrPNPDevID ;
				if ( pKeyboard->GetDeviceID ( chstrPNPDevID ) != NULL )
				{
					CHString chstrPrefix = chstrPNPDevID.Left(3);
					BOOL fGotMatchingHID = FALSE;
					if(chstrPrefix == _T("HID"))
					{
						REFPTR_POSITION posHID = 0;
						if(chstrPNPDevID.GetLength() > 4)
						{
							CHString chstrMiddlePart = chstrPNPDevID.Mid(4);
							LONG m = chstrMiddlePart.ReverseFind(_T('\\'));
							if(m != -1)
							{
								chstrMiddlePart = chstrMiddlePart.Left(m);

								if(HIDDeviceList.BeginEnum(posHID))
								{
									CConfigMgrDevicePtr pHID;

                                    for (pHID.Attach(HIDDeviceList.GetNext ( posHID ) );
                                         (pHID != NULL) && ( ! fGotMatchingHID );
                                         pHID.Attach(HIDDeviceList.GetNext ( posHID ) ))
									{
										CHString chstrPNPHIDDevID ;
										if ( pHID->GetDeviceID ( chstrPNPHIDDevID ) != NULL )
										{
											if ( chstrPNPHIDDevID.GetLength () > 4 )
											{
												CHString chstrHIDMiddlePart = chstrPNPHIDDevID.Mid ( 4 ) ;

												m = chstrHIDMiddlePart.ReverseFind ( _T('\\') ) ;
												if ( m != -1 )
												{
													chstrHIDMiddlePart = chstrHIDMiddlePart.Left ( m ) ;

													if ( chstrHIDMiddlePart.CompareNoCase ( chstrMiddlePart ) == 0 )
													{
														fGotMatchingHID = TRUE ;
														vecchstrKeyboardList.push_back ( chstrPNPHIDDevID ) ;
													}
												}
											}
										}
									}

									HIDDeviceList.EndEnum();
								}
							}
						}
					}

					if ( ! fGotMatchingHID ) // Use what we got if couldn't find matching HID entry.
					{
						vecchstrKeyboardList.push_back ( chstrPNPDevID );
					}
				}

            }

            deviceList.EndEnum () ;
        }
    }
    else   // this works fine on Win 9x and NT4!
#endif
    {
        fGotDevList = cfgmgr.GetDeviceListFilterByClass ( deviceList, L"Keyboard" ) ;
    }



#ifdef NTONLY

    if ( fGotDevList && ! IsWinNT5 () )

#endif

    {
        REFPTR_POSITION pos ;
        if ( deviceList.BeginEnum ( pos ) )
        {
            CConfigMgrDevicePtr pKeyboard;
            for (pKeyboard.Attach(deviceList.GetNext ( pos ) );
                 pKeyboard != NULL;
                 pKeyboard.Attach(deviceList.GetNext ( pos ) ))
            {
				CHString chstrPNPDevID ;
				if ( pKeyboard->GetDeviceID ( chstrPNPDevID ) )
				{
					vecchstrKeyboardList.push_back ( chstrPNPDevID ) ;
				}
            }

            deviceList.EndEnum () ;
		}
    }

#ifdef NTONLY

    // On nt4, the keyboard doesn't always get marked with class = Keyboard.  So, if the
    // code above didn't find anything, check for some common keyboard service names.

    if ( ( vecchstrKeyboardList.size () == 0 ) && ( IsWinNT4 () ) )
    {
        fGotDevList = cfgmgr.GetDeviceListFilterByService ( deviceList , _T("kbdclass") ) ;
        if ( fGotDevList )
        {
            REFPTR_POSITION pos ;
            if ( deviceList.BeginEnum ( pos ) )
            {
                CConfigMgrDevicePtr pKeyboard;
                for (pKeyboard.Attach(deviceList.GetNext ( pos ) );
                     pKeyboard != NULL;
                     pKeyboard.Attach(deviceList.GetNext ( pos ) ))
                {
					CHString chstrPNPDevID ;
					if ( pKeyboard->GetDeviceID ( chstrPNPDevID ) )
					{
						vecchstrKeyboardList.push_back(chstrPNPDevID);
					}
                }

                deviceList.EndEnum();
            }
        }
    }

    // On nt4, the keyboard doesn't always get marked with class = Keyboard.  So, if the
    // code above didn't find anything, check for some common keyboard service names.

    if ( ( vecchstrKeyboardList.size () == 0 ) && ( IsWinNT4 () ) )
    {
        fGotDevList = cfgmgr.GetDeviceListFilterByService ( deviceList , _T("i8042prt") ) ;
        if ( fGotDevList )
        {
            REFPTR_POSITION pos ;
            if ( deviceList.BeginEnum ( pos ) )
            {
                CConfigMgrDevicePtr pKeyboard;
                for (pKeyboard.Attach(deviceList.GetNext ( pos ));
                     pKeyboard != NULL;
                     pKeyboard.Attach(deviceList.GetNext ( pos )))
                {
					CHString chstrPNPDevID;
					if ( pKeyboard->GetDeviceID ( chstrPNPDevID ) )
					{
						vecchstrKeyboardList.push_back ( chstrPNPDevID ) ;
					}
                }

                deviceList.EndEnum();
            }
        }
    }
#endif
}


/*****************************************************************************
 *
 *  FUNCTION    : Keyboard::ReallyExists
 *
 *  DESCRIPTION : helper to determine if a keyboard exists based on its mof
 *                   key.  Remember, DeviceID is the same as the PNPId.
 *
 *  INPUTS      : chsKeyboardDeviceDesc - DeviceID
 *                vecchstrKeyboardList - stl array of CHStrings containing
 *                   PNPDeviceIDs
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : LONG: reference in array of the keyboard (zero based).
 *                   -1L will be returned if the element isn't in the array.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

LONG Keyboard :: ReallyExists (

	CHString &chsKeyboardDeviceDesc ,
    std::vector<CHString>& vecchstrKeyboardList
)
{
    LONG lRet = -1;

    for ( LONG m = 0L ; ( ( m < vecchstrKeyboardList.size () ) && ( lRet == -1L ) ) ; m++ )
    {
        if ( vecchstrKeyboardList [ m ].CompareNoCase ( chsKeyboardDeviceDesc ) == 0 )
        {
            lRet = m ;
        }
    }

	return lRet ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\irq.cpp ===
////////////////////////////////////////////////////////////////////

//

// IRQ.CPP -- IRQ managed object implementation

//

//  Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
// 09/10/96     jennymc     Updated to current standards
// 09/12/97		a-sanjes	Added LocateNTOwnerDevice and added
//							change to get IRQ number from IRQ Level,
//	1/16/98		a-brads		Updated to V2 MOF
//
/////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <cregcls.h>

#include <ole2.h>
#include <conio.h>
#include <iostream.h>

#include "ntdevtosvcsearch.h"
#include "chwres.h"

#include "IRQ.h"
#include "resource.h"

// Property set declaration
//=========================
CWin32IRQResource MyCWin32IRQResourceSet(PROPSET_NAME_IRQ, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32IRQResource::CWin32IRQResource
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32IRQResource::CWin32IRQResource(

	LPCWSTR name,
	LPCWSTR pszNamespace

) :  Provider(name , pszNamespace)
{
}
/*****************************************************************************
 *
 *  FUNCTION    : CWin32IRQResource::~CWin32IRQResource
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32IRQResource::~CWin32IRQResource()
{
}
/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32IRQResource::GetObject(CInstance* pInstance, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_E_FAILED;

#if NTONLY == 4

	hr = GetNTIRQ(NULL , pInstance);

#endif

#if NTONLY > 4

    hr = GetW2KIRQ(NULL , pInstance);

#endif

    if (FAILED(hr))
	{
        hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32IRQResource::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each logical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32IRQResource::EnumerateInstances(

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_E_FAILED;

#if NTONLY == 4

	hr = GetNTIRQ(pMethodContext , NULL);

#endif

#if NTONLY > 4

	hr = GetW2KIRQ(pMethodContext , NULL);

#endif


    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : CWin32IRQResource::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each logical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void CWin32IRQResource::SetCommonProperties(
    CInstance *pInstance,
    DWORD dwIRQ,
    BOOL bHardware)
{
	WCHAR    szName[_MAX_PATH];
    CHString strDesc;

	swprintf(
        szName,
		L"IRQ%u",
		dwIRQ);

	pInstance->SetCharSplat(IDS_Name, szName);

	Format(strDesc,
		IDR_IRQFormat,
		dwIRQ);

    pInstance->SetDWORD(L"IRQNumber", dwIRQ);

	pInstance->SetCharSplat(IDS_Caption, strDesc);
	pInstance->SetCharSplat(IDS_Description, strDesc);
    pInstance->SetCharSplat(IDS_CSName, GetLocalComputerName());
	pInstance->SetCharSplat(IDS_CSCreationClassName, L"Win32_ComputerSystem");
    pInstance->SetCharSplat(IDS_Status, L"OK");
    pInstance->SetDWORD(L"TriggerLevel", 2); // 2 == Unknown
    pInstance->SetDWORD(L"TriggerType", 2); // 2 == Unknown

	SetCreationClassName(pInstance);

	// Indicate whether it's a software(Internal) or hardware IRQ.
    // This property is stupid, as all the interrupts we can detect
    // are associated with hardware.  Some interrupt channels
    // serve dual software and hardware roles (via the OS hooking
    // into them on bootup).  Since this property can only be either
    // true or false (and our data is either true or true + software, 
    // we'll go with true).
	pInstance->SetDWORD(L"Hardware", TRUE);

    // Set Availability to Unknown since there's no good way to get this.
    pInstance->SetDWORD(L"Availability", 2);
}


/*****************************************************************************
 *
 *  FUNCTION    : CWin32IRQResource::GetxxxIRQ
 *
 *  DESCRIPTION : Creates instance of property set for each logical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#if NTONLY > 4
HRESULT CWin32IRQResource::GetW2KIRQ(
    MethodContext* pMethodContext,
    CInstance* pSpecificInstance)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CInstancePtr pInstanceAlias(pSpecificInstance);
    
    //=======================================
    // If we are refreshing a specific
    // instance, get which channel we are
    // going for
    //=======================================
	DWORD dwIndexToRefresh;
    if(pInstanceAlias)
	{
        pInstanceAlias->GetDWORD(L"IRQNumber", dwIndexToRefresh);
	}

    CConfigManager cfgManager;
    CDeviceCollection deviceList;
    std::set<long> setIRQ;
    bool fDone = false; 
    bool fFound = false;

    if(cfgManager.GetDeviceList(deviceList))
    {
        REFPTR_POSITION posDev;

        if(deviceList.BeginEnum(posDev))
        {
            // Walk the list
            CConfigMgrDevicePtr pDevice;
            for(pDevice.Attach(deviceList.GetNext(posDev));
                SUCCEEDED(hr) && (pDevice != NULL) && !fDone;
                pDevice.Attach(deviceList.GetNext(posDev)))
            {
				// Enumerate the device's IRQ resource usage...
                CIRQCollection DevIRQCollection;
                REFPTR_POSITION posIRQ;

                pDevice->GetIRQResources(DevIRQCollection);

                if(DevIRQCollection.BeginEnum(posIRQ))
                {
                    CIRQDescriptorPtr pIRQ(NULL);
                    // Walk the dma's
                    for(pIRQ.Attach(DevIRQCollection.GetNext(posIRQ));
                        pIRQ != NULL && !fDone && SUCCEEDED(hr);
                        pIRQ.Attach(DevIRQCollection.GetNext(posIRQ)))
                    {
                        ULONG ulIRQNum = pIRQ->GetInterrupt();

				        // If we are just trying to refresh a 
                        // specific one and it is NOT
				        // the one we want, get the next one...
				        if(!pMethodContext) // we were called by GetObject
				        {
					        if(dwIndexToRefresh != ulIRQNum)
					        {
						        continue;
					        }
                            else
                            {
                                SetCommonProperties(pInstanceAlias, ulIRQNum, TRUE);
                                fDone = fFound = true;
                            }
				        }
				        else  // We were called by enum
				        {
                            // If we don't have this IRQ already,
                            if(!FoundAlready(ulIRQNum, setIRQ))
				            {
					            // add it to the list,
                                setIRQ.insert(ulIRQNum);
                                // create a new instance,
                                pInstanceAlias.Attach(CreateNewInstance(pMethodContext));
                                SetCommonProperties(pInstanceAlias, ulIRQNum, TRUE);
                                // and commit it.
                                hr = pInstanceAlias->Commit();
                            }
                        }
                    }
                    DevIRQCollection.EndEnum();
				}
            }
            deviceList.EndEnum();
        }
    }

    if(!fFound)
    {
        hr = WBEM_E_NOT_FOUND;
    }

    return hr ;
}


bool CWin32IRQResource::FoundAlready(
    ULONG ulKey,
    std::set<long>& S)
{
    return (S.find(ulKey) != S.end());
}

#endif


#if NTONLY == 4

HRESULT CWin32IRQResource::GetNTIRQ(

	MethodContext *pMethodContext ,
    CInstance *pInstance
)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	//=======================================
	// If we are refreshing a specific
	// instance, get which channel we are
	// going for
	//=======================================

	DWORD IndexToRefresh = 0;
	BOOL t_Found;

	if (!pMethodContext)
	{
		pInstance->GetDWORD(L"IRQNumber" , IndexToRefresh);
        t_Found  = FALSE;
	}
    else
    {
        t_Found = TRUE;
    }


	//=======================================
	// Create hardware system resource list &
	// get the head of the list
	//=======================================

	CHWResource HardwareResource;
	HardwareResource.CreateSystemResourceLists();

	SYSTEM_RESOURCES SystemResource;
	SystemResource = HardwareResource._SystemResourceList;
	unsigned int iUsed [8] = {0, 0, 0, 0, 0, 0, 0, 0};

	LPRESOURCE_DESCRIPTOR ResourceDescriptor;

	for (	ResourceDescriptor = SystemResource.InterruptHead;
			ResourceDescriptor != NULL && SUCCEEDED(hr);
			ResourceDescriptor = ResourceDescriptor->NextSame
	)
	{

		BOOL t_Status = BitSet(iUsed , ResourceDescriptor->CmResourceDescriptor.u.Interrupt.Level , sizeof(iUsed));
		if (!t_Status)
		{
			CInstancePtr pInstCreated;

            //===============================================================
			//  If we are just trying to refresh a specific one and it is NOT
			//  the one we want, get the next one...
			//===============================================================

			if (!pMethodContext)
			{
				if (IndexToRefresh != ResourceDescriptor->CmResourceDescriptor.u.Interrupt.Level)
				{
					continue;
				}
			}
			else
			{
                pInstance = CreateNewInstance(pMethodContext);
                pInstCreated.Attach(pInstance);
			}

			//=========================================================
			//  Now, we got here, so we want to get all of the info
			//=========================================================
            SetCommonProperties(
                pInstance,
                ResourceDescriptor->CmResourceDescriptor.u.Interrupt.Level,
                ResourceDescriptor->InterfaceType != Internal);

			pInstance->SetDWORD(L"Vector" , ResourceDescriptor->CmResourceDescriptor.u.Interrupt.Vector);

			//=========================================================
			// Interrupt Level and Actual IRQ Number appear to be the
			// same thing.
			//=========================================================

			//===============================================================
			//  If we just want this one, then break out of here, otherwise
			//  get them all
			//===============================================================

			if (!pMethodContext)
			{
                t_Found = TRUE;
                break;
			}
			else
			{
				hr = pInstance->Commit();
            }
		}
	}

    if (!t_Found)
    {
        hr = WBEM_E_NOT_FOUND;
    }

	return hr;
}

#endif



/*****************************************************************************
 *
 *  FUNCTION    : CWin32IRQResource::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each logical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    : Bit number in iPos are zero based
 *
 *****************************************************************************/

bool CWin32IRQResource::BitSet(
	unsigned int iUsed[],
	ULONG iPos,
	DWORD iSize
)
{
	bool bRet;

    // iIndex is which DWORD to modify
	DWORD iIndex = iPos / (sizeof(iUsed[0]) * 8);

    // Make sure we have that many dwords
	if (iIndex < iSize)
	{
	    // I don't know why I need these, but if I don't use them, the compiler keeps
	    // adding code to extend the sign.  Once the optimizer gets this, it shouldn't
	    // matter anyway.
		unsigned int a1, a2;

        // a1 will tell how many bits over within the current dword
        // we need to move
		a1 =   iPos - (iIndex * (sizeof(iUsed[0]) * 8));

        // a2 will have set the bit we are trying to set
		a2 = 1 << a1;

        // The return value will indicate whether that bit had already been set.
		bRet = iUsed[iIndex] & a2;

		iUsed[iIndex] |= a2;
	}
	else
	{
		bRet = false;
		LogErrorMessage(L"Overflow on irq table");
	}

	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\keyboard.h ===
//=================================================================

//

// Keyboard.h -- Keyboard property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//				 10/23/97	 a-hhance       ported to new world order
//
//=================================================================

// Property set identification
//============================

#define  PROPSET_NAME_KEYBOARD  L"Win32_Keyboard"
//#define  PROPSET_UUID_KEYBOARD  L"{e0bb7140-3d11-11d0-939d-0000e80d7352}"

class Keyboard:public Provider {

    public:

        // Constructor/destructor
        //=======================

        Keyboard(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~Keyboard() ;

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
       
	private:

        // Utility function(s)
        //====================
        HRESULT LoadPropertyValues(CInstance* pInstance) ;
        
        BOOL GetDevicePNPInformation (CInstance *a_Instance , CHString& chstrPNPDevID ) ;

        VOID GenerateKeyboardList(std::vector<CHString>& vecchstrKeyboardList);
        LONG ReallyExists(CHString& chsBus, std::vector<CHString>& vecchstrKeyboardList);


} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\kuserdata.cpp ===
//=================================================================

//

// KUserdata.cpp --

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    02/16/98	a-peterc        Created

// Encapsulates kernel user data into an extraction class. This is
// done primarily to avoid nt header files from colliding with wmi
// provider headers.
// No member data.
//
//=================================================================

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"
#include "KUserdata.h"

void ConvertTime( volatile KSYSTEM_TIME* ksTime, LARGE_INTEGER* pTime );

//
BOOLEAN KUserdata::IsNec98()
{ return USER_SHARED_DATA->AlternativeArchitecture == NEC98x86; }

//
ULONG KUserdata::TickCountLow()
{ return USER_SHARED_DATA->TickCount.LowPart; }

//
ULONG KUserdata::TickCountMultiplier()
{ return USER_SHARED_DATA->TickCountMultiplier; }

//
LARGE_INTEGER KUserdata::InterruptTime()
{
	LARGE_INTEGER llTime;

	ConvertTime( &USER_SHARED_DATA->InterruptTime, &llTime );
	return llTime;
}

//
LARGE_INTEGER KUserdata::SystemTime()
{
	LARGE_INTEGER llTime;

	ConvertTime( &USER_SHARED_DATA->SystemTime, &llTime );
	return llTime;
}

//
LARGE_INTEGER KUserdata::TimeZoneBias()
{
	LARGE_INTEGER llTime;

	ConvertTime( &USER_SHARED_DATA->TimeZoneBias, &llTime );
	return llTime;
}

//
USHORT KUserdata::ImageNumberLow()
{ return USER_SHARED_DATA->ImageNumberLow; }

//
USHORT KUserdata::ImageNumberHigh()
{ return USER_SHARED_DATA->ImageNumberHigh; }

//
WCHAR* KUserdata::NtSystemRoot()
{ return (WCHAR*)&USER_SHARED_DATA->NtSystemRoot; }

//
ULONG KUserdata::MaxStackTraceDepth()
{ return USER_SHARED_DATA->MaxStackTraceDepth; }

//
ULONG KUserdata::CryptoExponent()
{ return USER_SHARED_DATA->CryptoExponent; }

//
ULONG KUserdata::TimeZoneId()
{ return USER_SHARED_DATA->TimeZoneId; }

//
ULONG KUserdata::NtProductType()
{ return USER_SHARED_DATA->NtProductType; }

//
BOOLEAN KUserdata::ProductTypeIsValid()
{ return USER_SHARED_DATA->ProductTypeIsValid; }

//
ULONG KUserdata::NtMajorVersion()
{ return USER_SHARED_DATA->NtMajorVersion; }

//
ULONG KUserdata::NtMinorVersion()
{ return USER_SHARED_DATA->NtMinorVersion; }

//
BOOLEAN KUserdata::ProcessorFeatures(DWORD dwIndex, BOOLEAN& bFeature )
{
	if(dwIndex < PROCESSOR_FEATURE_MAX )
	{
		bFeature = USER_SHARED_DATA->ProcessorFeatures[dwIndex];
		return TRUE;
	}
	return FALSE;
 }

//
ULONG KUserdata::TimeSlip()
{ return USER_SHARED_DATA->TimeSlip; }

//
LARGE_INTEGER KUserdata::SystemExpirationDate()
{ return USER_SHARED_DATA->SystemExpirationDate; }

//
ULONG KUserdata::SuiteMask()
{ return USER_SHARED_DATA->SuiteMask; }

//
void ConvertTime( volatile KSYSTEM_TIME* ksTime, LARGE_INTEGER* pTime )
{
    do {
		pTime->HighPart = ksTime->High1Time;
        pTime->LowPart	= ksTime->LowPart;
    } while (pTime->HighPart != ksTime->High2Time);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\loaddepends.cpp ===
//=================================================================

//

// LoadMember.CPP -- LoadOrderGroup to Service association provider

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    12/26/97    davwoh         Created
//
// Comments: Shows the load order groups that each service depends
//           on to start.
//
//=================================================================

#include "precomp.h"

#include "Loaddepends.h"
#include "loadorder.h"

// Property set declaration
//=========================

CWin32LoadGroupDependency MyLoadDepends(PROPSET_NAME_LOADORDERGROUPSERVICEDEPENDENCIES, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LoadGroupDependency::CWin32LoadGroupDependency
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32LoadGroupDependency::CWin32LoadGroupDependency(LPCWSTR setName, LPCWSTR pszNamespace)
:Provider(setName, pszNamespace)
{
   CHString sTemp(PROPSET_NAME_LOADORDERGROUP);

   sTemp += L".Name=\"";

   // Just saves us from having to constantly re-calculate this when sending
   // instances back.
   m_sGroupBase = MakeLocalPath(sTemp);
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LoadGroupDependency::~CWin32LoadGroupDependency
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32LoadGroupDependency::~CWin32LoadGroupDependency()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LoadGroupDependency::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32LoadGroupDependency::GetObject(CInstance *pInstance, long lFlags /*= 0L*/)
{
   CHString sServicePath, sGroupPath;
   HRESULT hRet = WBEM_E_NOT_FOUND;
    CInstancePtr pPart;

   // Get the two paths
   pInstance->GetCHString(L"Dependent", sServicePath);
   pInstance->GetCHString(L"Antecedent", sGroupPath);

   // It is perfectly possible that a service is dependent on a group that doesn't exist
   if(SUCCEEDED(hRet = CWbemProviderGlue::GetInstanceByPath(sServicePath, &pPart, pInstance->GetMethodContext() ) ) )
   {
//      if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath( (LPCTSTR)sGroupPath, &pGroup ) ) ) {

         // Now we need to check to see if this service really is a Dependent
         CHString sServiceName;
         CHStringArray asGroupGot;
         DWORD dwSize;

         pPart->GetCHString(IDS_Name, sServiceName);

         // Get the dependent list for this service
         hRet = GetDependentsFromService(sServiceName, asGroupGot);

         if (SUCCEEDED(hRet)) 
         {
             // Haven't proveny anything yet.
             hRet = WBEM_E_NOT_FOUND;

             // Walk the list to see if we're there
             dwSize = asGroupGot.GetSize();
             for (int x=0; x < dwSize; x++) 
             {
                if (asGroupGot.GetAt(x).CompareNoCase(sGroupPath) == 0) 
                {
                   hRet = WBEM_S_NO_ERROR;
                   break;
                }
             }
         }
      }
//   }

   // There are no properties to set, if the endpoints exist, we be done

   return hRet;

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LoadGroupDependency::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32LoadGroupDependency::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
    CHString sService, sServicePath;
    CHStringArray asGroupGot;
    DWORD dwSize, x;
    HRESULT hr = WBEM_S_NO_ERROR;

   // Get list of services
   //==================
   TRefPointerCollection<CInstance> Services;

//   if SUCCEEDED(hr = CWbemProviderGlue::GetAllInstances(_T("Win32_Service"), &Services, IDS_CimWin32Namespace, pMethodContext))   {
   if SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(L"select __relpath, Name from Win32_Service", &Services, pMethodContext, GetNamespace()))
   {
      REFPTRCOLLECTION_POSITION pos;
      CInstancePtr pService;

      if (Services.BeginEnum(pos))
      {

         for (pService.Attach(Services.GetNext( pos )) ;
             (SUCCEEDED(hr)) && (pService != NULL) ;
              pService.Attach(Services.GetNext( pos )) )
             {

            pService->GetCHString(IDS_Name, sService) ;
            pService->GetCHString(L"__RELPATH", sServicePath) ;

            // See if there is a group for this service.  sGroupGot comes
            // back as a full path or as blank
            asGroupGot.RemoveAll();

            // If one service can't get its data, we still want to return the rest
            if (SUCCEEDED(GetDependentsFromService(sService, asGroupGot)))
            {

                dwSize = asGroupGot.GetSize();

                // Ok, turn the relpath into a complete path
                GetLocalInstancePath(pService, sServicePath);

                for (x=0; x < dwSize && SUCCEEDED(hr) ; x++) {
                   CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                   if (pInstance)
                   {
                       // Do the puts, and that's it
                       pInstance->SetCHString(L"Dependent", sServicePath);
                       pInstance->SetCHString(L"Antecedent", asGroupGot.GetAt(x));
                       hr = pInstance->Commit();
                   }
                   else
                       hr = WBEM_E_OUT_OF_MEMORY;
                }
            }

         }

         Services.EndEnum();
      }
   }

   // GetAllInstances doesn't clear the old values, so I do it.
   Services.Empty();

//   if (SUCCEEDED(hr) &&
//      (SUCCEEDED(hr = CWbemProviderGlue::GetAllInstances(_T("Win32_SystemDriver"), &Services, IDS_CimWin32Namespace, pMethodContext))))   {

   if (SUCCEEDED(hr) &&
      (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(L"Select __relpath, Name from Win32_SystemDriver", &Services, pMethodContext, GetNamespace()))))
   {
      REFPTRCOLLECTION_POSITION pos;
      CInstancePtr pService;

      if (Services.BeginEnum(pos))
      {
         for (pService.Attach (Services.GetNext( pos ));
              (SUCCEEDED(hr)) && (pService != NULL);
              pService.Attach (Services.GetNext( pos )))
         {

            pService->GetCHString(L"Name", sService) ;
            pService->GetCHString(L"__RELPATH", sServicePath) ;

            // See if there is a group for this service.  sGroupGot comes
            // back as a full path or as blank
            asGroupGot.RemoveAll();
            GetDependentsFromService(sService, asGroupGot);

            dwSize = asGroupGot.GetSize();

            // Ok, turn the relpath into a complete path
            GetLocalInstancePath(pService, sServicePath);

            for (x=0; x < dwSize && SUCCEEDED(hr) ; x++)
            {
               CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

               if (pInstance)
               {
                   // Do the puts, and that's it
                   pInstance->SetCHString(L"Dependent", sServicePath);
                   pInstance->SetCHString(L"Antecedent", asGroupGot.GetAt(x));
                   hr = pInstance->Commit();
               }
               else
               {
                   hr = WBEM_E_OUT_OF_MEMORY;
               }
            }
         }

         Services.EndEnum();
      }
   }

   return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LoadGroupDependency::GetDependentsFromService
 *
 *  DESCRIPTION : Given a service name, returns the DependOnGroup's
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : Returns empty array if no group, empty group, or bad
 *                service name.
 *
 *****************************************************************************/
HRESULT CWin32LoadGroupDependency::GetDependentsFromService(const CHString &sServiceName, CHStringArray &asArray)
{
    CRegistry RegInfo;
    CHString sGroupNames, sTemp;
    CHString sKeyName(L"SYSTEM\\CurrentControlSet\\Services\\");
    WCHAR *pszString, *pChar;
    HRESULT hr, res;

    sKeyName += sServiceName;

    // Open the key, get the name
    if ((res = RegInfo.Open(HKEY_LOCAL_MACHINE, sKeyName, KEY_READ)) == ERROR_SUCCESS) {
        if ((res = RegInfo.GetCurrentKeyValue(L"DependOnGroup", sGroupNames)) == ERROR_SUCCESS) {
            if (sGroupNames == _T("")) {
                sGroupNames.Empty();
            }
        }
    }

    // Determine what we're going to tell people
    if (res == ERROR_ACCESS_DENIED) {
        hr = WBEM_E_ACCESS_DENIED;
    } else if ((res != ERROR_SUCCESS) && (res != REGDB_E_INVALIDVALUE)) {
        hr = WBEM_E_FAILED;
    } else {
        hr = WBEM_S_NO_ERROR;
    }

    // If we found something, turn it into a full path.  m_sGroupbase
    // was set in constructor.
    if (!sGroupNames.IsEmpty()) {

        pszString = new WCHAR[(sGroupNames.GetLength() + 1)];
        if (pszString == NULL)
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
        else
        {
            try
            {
                wcscpy(pszString, sGroupNames);
                pszString[lstrlenW(pszString) - 1] = 0;

                // Walk the returned string.  Note that this returns them
                // in reverse order from the registry entry.
                while (pChar = wcsrchr(pszString, '\n'))
                {
                    sTemp = m_sGroupBase + (pChar + 1); // L10N OK
                    sTemp += '"';
                    asArray.Add(sTemp);
                    *pChar = '\0';
                }

                // Get the last one
                sTemp = m_sGroupBase + pszString;
                sTemp += '"';
                asArray.Add(sTemp);
            }
            catch ( ... )
            {
                delete pszString;
                pszString = NULL;
                throw ;
            }

            delete pszString;
            pszString = NULL;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\loaddepends.h ===
//=================================================================

//

// loaddepends.h -- LoadOrderGroup to Service association provider

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    12/26/97    davwoh         Created
//
// Comments: Shows the load order groups that each service depends
//           on to start.
//
//=================================================================

// Property set identification
//============================

#define  PROPSET_NAME_LOADORDERGROUPSERVICEDEPENDENCIES L"Win32_LoadOrderGroupServiceDependencies"

class CWin32LoadGroupDependency ;

class CWin32LoadGroupDependency:public Provider {

   public:

      // Constructor/destructor
      //=======================

      CWin32LoadGroupDependency(LPCWSTR name, LPCWSTR pszNamespace) ;
      ~CWin32LoadGroupDependency() ;

      // Functions provide properties with current values
      //=================================================

      virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
      virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);

   private:

      // Utility function(s)
      //====================

      HRESULT GetDependentsFromService(const CHString &sServiceName, CHStringArray &asArray);

      CHString m_sGroupBase;

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\kuserdata.h ===
//=================================================================

//

// KUserdata.h 

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    02/16/98	a-peterc        Created

//=================================================================
class KUserdata
{
    public:
	        
    BOOLEAN			IsNec98();
	ULONG			TickCountLow();
	ULONG			TickCountMultiplier();
	LARGE_INTEGER	InterruptTime();
	LARGE_INTEGER	SystemTime();
	LARGE_INTEGER	TimeZoneBias();
	USHORT			ImageNumberLow();
	USHORT			ImageNumberHigh();
	WCHAR*			NtSystemRoot();
	ULONG			MaxStackTraceDepth();
	ULONG			CryptoExponent();
	ULONG			TimeZoneId();
	ULONG			NtProductType();
	BOOLEAN			ProductTypeIsValid();
	ULONG			NtMajorVersion();
	ULONG			NtMinorVersion();
	BOOLEAN			ProcessorFeatures(DWORD dwIndex, BOOLEAN& bFeature );
	ULONG			TimeSlip();
	LARGE_INTEGER	SystemExpirationDate();
	ULONG			SuiteMask();

	protected:
	private:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\loadmember.h ===
//=================================================================

//

// loadmember.h -- LoadOrderGroup to Service association provider

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/06/97    davwoh         Created
//
// Comment: Shows the members of each load order group
//
//=================================================================

// Property set identification
//============================

#define  PROPSET_NAME_LOADORDERGROUPSERVICEMEMBERS L"Win32_LoadOrderGroupServiceMembers"

class CWin32LoadGroupMember ;

class CWin32LoadGroupMember:public Provider {

    public:

        // Constructor/destructor
        //=======================

        CWin32LoadGroupMember(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CWin32LoadGroupMember() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);

    private:

        // Utility function(s)
        //====================

        CHString GetGroupFromService(const CHString &sServiceName);

        CHString m_sGroupBase;

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\loadorder.cpp ===
//=================================================================

//

// LoadOrder.CPP --Service Load Order Group property set provider

//                Windows NT only

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/25/97    davwoh         Moved to curly
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>

#include "LoadOrder.h"

// Property set declaration
//=========================
CWin32LoadOrderGroup MyLoadOrderGroupSet ( PROPSET_NAME_LOADORDERGROUP , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LoadOrderGroup::CWin32LoadOrderGroup
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32LoadOrderGroup :: CWin32LoadOrderGroup (

	LPCWSTR Name,
	LPCWSTR pszNamespace

) : Provider ( Name , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LoadOrderGroup::~CWin32LoadOrderGroup
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32LoadOrderGroup :: ~CWin32LoadOrderGroup ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LoadOrderGroup::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32LoadOrderGroup :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
    CHString sSeeking;
    pInstance->GetCHString ( L"Name" , sSeeking ) ;

    return WalkGroups ( NULL , pInstance , sSeeking ) ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LoadOrderGroup::AddDynamicInstances
 *
 *  DESCRIPTION : Creates instance of property set for each installed client
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32LoadOrderGroup :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
	return WalkGroups ( pMethodContext , NULL , NULL ) ;
}

HRESULT CWin32LoadOrderGroup :: WalkGroups (

	MethodContext *pMethodContext,
    CInstance *a_pInstance,
	LPCWSTR pszSeekName
)
{
	bool bDone = false ;

	CInstancePtr	t_pInstance = a_pInstance ;
	CHStringArray	saGroups;
					saGroups.SetSize ( 10 ) ;

	HRESULT			hRes = WBEM_S_NO_ERROR ;

	CRegistry RegInfo ;

	DWORD lResult = RegInfo.Open (

		HKEY_LOCAL_MACHINE,
		L"System\\CurrentControlSet\\Control\\ServiceGroupOrder",
		KEY_READ
	) ;

	if ( lResult == ERROR_SUCCESS )
	{
		CHString sTemp ;
		lResult = RegInfo.GetCurrentKeyValue ( L"List" , sTemp ) ;
		if ( lResult  == ERROR_SUCCESS )
		{

			WCHAR *pszServiceName = wcstok(sTemp.GetBuffer(sTemp.GetLength() + 1), L"\n") ;
			DWORD dwIndex = 1 ;

			while ( ( pszServiceName != NULL ) && ( ! bDone ) && ( SUCCEEDED ( hRes ) ) )
			{
				if ( pszServiceName [ 0 ] != '\0' )
				{
					if ( pMethodContext )
					{
						t_pInstance.Attach( CreateNewInstance ( pMethodContext ) ) ;
					}

					if ( ( pMethodContext ) || ( bDone = ( _wcsicmp ( pszServiceName , pszSeekName ) == 0 ) ) )
					{
						t_pInstance->SetCharSplat ( L"Name" , pszServiceName ) ;
						t_pInstance->SetDWORD ( L"GroupOrder" , dwIndex ) ;
						t_pInstance->SetCharSplat ( L"Caption" , pszServiceName ) ;
						t_pInstance->SetCharSplat ( L"Description" , pszServiceName ) ;
						t_pInstance->SetCharSplat ( L"Status" , L"OK" ) ;
						t_pInstance->Setbool ( L"DriverEnabled" , true ) ;
					}

					if ( pMethodContext )
					{
						hRes = t_pInstance->Commit() ;
					}

					saGroups.SetAtGrow ( dwIndex , _wcsupr ( pszServiceName ) ) ;
					dwIndex ++ ;
				}

				pszServiceName = wcstok(NULL, L"\n") ;
			}

			if( !bDone )
			{
				lResult = RegInfo.OpenAndEnumerateSubKeys (

					HKEY_LOCAL_MACHINE,
					L"System\\CurrentControlSet\\Services",
					KEY_READ
				) ;

				if ( lResult == ERROR_SUCCESS )
				{
					hRes = WBEM_S_NO_ERROR;

					bool bAnother ;

					for (	bAnother = (RegInfo.GetCurrentSubKeyCount() > 0);
							bAnother && !bDone && SUCCEEDED(hRes);
							bAnother = (RegInfo.NextSubKey() == ERROR_SUCCESS )
					)
					{
						CHString sKey ;
						RegInfo.GetCurrentSubKeyPath ( sKey ) ;

						CRegistry COne ;

						if ( COne.Open ( HKEY_LOCAL_MACHINE , sKey, KEY_READ ) == ERROR_SUCCESS )
						{
							if ( COne.GetCurrentKeyValue (L"Group", sTemp) == ERROR_SUCCESS )
							{
								if ( !FindGroup ( saGroups , sTemp , dwIndex ) )
								{
									if ( !sTemp.IsEmpty () )
									{
										if ( pMethodContext )
										{
											t_pInstance.Attach( CreateNewInstance ( pMethodContext ) ) ;
										}

										if ( ( pMethodContext ) || ( bDone = ( sTemp.CompareNoCase ( pszSeekName ) == 0 ) ) )
										{
											t_pInstance->SetCharSplat ( L"Name" , sTemp ) ;
											t_pInstance->SetDWORD ( L"GroupOrder" , dwIndex ) ;
											t_pInstance->SetCharSplat ( L"Caption" , sTemp ) ;
											t_pInstance->SetCharSplat ( L"Description" , sTemp ) ;
											t_pInstance->SetCharSplat ( L"Status" , L"OK" ) ;
											t_pInstance->Setbool ( L"DriverEnabled" , false ) ;
										}

										if ( pMethodContext )
										{
											hRes = t_pInstance->Commit() ;
										}

										sTemp.MakeUpper();
										saGroups.SetAtGrow(dwIndex, sTemp);
										dwIndex ++;

									}
								}
							}
						}
					}
				}
			}
		}

    // 95 doesn' have this key, but 98 should
    }

    else
	{
		hRes = WinErrorToWBEMhResult ( lResult ) ;
	}

	if ( ( pszSeekName != NULL ) && ( hRes == WBEM_S_NO_ERROR ) && ! bDone )
	{
		hRes = WBEM_E_NOT_FOUND ;
	}

   return hRes;

}

bool CWin32LoadOrderGroup :: FindGroup (

	const CHStringArray &saGroup,
	LPCWSTR pszTemp,
	DWORD dwSize
)
{
	CHString sTemp ( pszTemp ) ;
	sTemp.MakeUpper () ;

	LPCWSTR pszTemp2 = (LPCWSTR) sTemp ;

	for ( DWORD x = 1 ; x < dwSize ; x ++ )
	{
		if ( saGroup [ x ] == pszTemp2 )
		{
			return true ;
		}
	}

	return false ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\loadmember.cpp ===
//=================================================================

//

// LoadMember.CPP -- LoadOrderGroup to Service association provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/06/97    davwoh         Created
//
// Comment: Shows the members of each load order group
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>

#include "LoadMember.h"
#include "loadorder.h"

// Property set declaration
//=========================

CWin32LoadGroupMember MyLoadMember(PROPSET_NAME_LOADORDERGROUPSERVICEMEMBERS, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LoadGroupMember::CWin32LoadGroupMember
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32LoadGroupMember::CWin32LoadGroupMember(LPCWSTR setName, LPCWSTR pszNamespace)
:Provider(setName, pszNamespace)
{
   CHString sTemp(PROPSET_NAME_LOADORDERGROUP);

   sTemp += L".Name=\"";

   // Just saves us from having to constantly re-calculate this when sending
   // instances back.
   m_sGroupBase = MakeLocalPath(sTemp);
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LoadGroupMember::~CWin32LoadGroupMember
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32LoadGroupMember::~CWin32LoadGroupMember()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LoadGroupMember::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32LoadGroupMember::GetObject(CInstance *pInstance, long lFlags /*= 0L*/)
{
   CHString sService, sGroupDesired, sGroupGot;
   HRESULT hRet = WBEM_E_NOT_FOUND;
	CInstancePtr pGroup;
	CInstancePtr pPart;

   // Get the two paths
   pInstance->GetCHString(IDS_PartComponent, sService);
   pInstance->GetCHString(IDS_GroupComponent, sGroupDesired);

   // If both ends are there
   if(SUCCEEDED(hRet = CWbemProviderGlue::GetInstanceByPath(sService, &pPart, pInstance->GetMethodContext() ) ) )
   {
      if(SUCCEEDED(hRet = CWbemProviderGlue::GetInstanceByPath(sGroupDesired, &pGroup, pInstance->GetMethodContext() ) ) )
      {

         // Now we need to check to see if this service really is in this group
         CHString sServiceName, sGroupGot;

         pPart->GetCHString(IDS_Name, sServiceName);

         // Get the group and check it
         sGroupGot = GetGroupFromService(sServiceName);
         if (sGroupGot.CompareNoCase(sGroupDesired) == 0) 
         {
            hRet = WBEM_S_NO_ERROR;
         }
         else
         {
            hRet = WBEM_E_NOT_FOUND;
         }
      }
   }

   return hRet;

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LoadGroupMember::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32LoadGroupMember::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	CHString sService, sServicePath, sGroupGot;
	HRESULT hr = WBEM_S_NO_ERROR;

   // Get list of Services
   //=====================
   TRefPointerCollection<CInstance> Services;

//   if (SUCCEEDED(hr = CWbemProviderGlue::GetAllDerivedInstances(
//		_T("Win32_BaseService"), &Services, pMethodContext, IDS_CimWin32Namespace)))

   if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(
		L"Select __relpath, Name from Win32_BaseService", &Services, pMethodContext, GetNamespace())))
	{
      REFPTRCOLLECTION_POSITION pos;
      CInstancePtr pService;

      if (Services.BeginEnum(pos))
      {
         for (pService.Attach(Services.GetNext( pos )) ;
             (SUCCEEDED(hr)) && (pService != NULL) ;
             pService.Attach(Services.GetNext( pos )))
         {

            pService->GetCHString(IDS_Name, sService) ;
            pService->GetCHString(IDS___Relpath, sServicePath) ;

            // See if there is a group for this service.  sGroupGot comes
            // back as a full path or as blank
            sGroupGot = GetGroupFromService(sService);
            if (!sGroupGot.IsEmpty()) {
               CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
               if (pInstance)
               {
                   // Ok, turn the relpath into a complete path
                   GetLocalInstancePath(pService, sServicePath);

                   // Do the puts, and that's it
                   pInstance->SetCHString(IDS_PartComponent, sServicePath);
                   pInstance->SetCHString(IDS_GroupComponent, sGroupGot);
                   hr = pInstance->Commit();
               }
               else
               {
                   hr = WBEM_E_OUT_OF_MEMORY;
               }
            }
         }

         Services.EndEnum();
      }
   }

   return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LoadGroupMember::GetGroupFromService
 *
 *  DESCRIPTION : Given a service name, returns the Group name
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : Returns CHString.Empty() if no group, empty group, or bad
 *                service name.
 *
 *****************************************************************************/
CHString CWin32LoadGroupMember::GetGroupFromService(const CHString &sServiceName)
{
   CRegistry RegInfo;
   CHString sGroupName;
   CHString sKeyName(L"SYSTEM\\CurrentControlSet\\Services\\");

   sKeyName += sServiceName;

   // Open the key, get the name
   if (RegInfo.Open(HKEY_LOCAL_MACHINE, sKeyName, KEY_READ) == ERROR_SUCCESS) {
      if (RegInfo.GetCurrentKeyValue(L"Group", sGroupName) == ERROR_SUCCESS) {
         if (sGroupName == _T("")) {
            sGroupName.Empty();
         }
      }
   }

   // If we found something, turn it into a full path.  m_sGroupbase
   // was set in constructor.
   if (!sGroupName.IsEmpty()) {
      sGroupName = m_sGroupBase + sGroupName;
      sGroupName += _T('"');
   }

   return sGroupName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\loadorder.h ===
//=================================================================

//

// LoadOrder.h -- Service Load Order Group property set provider

//               Windows NT only

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/25/97    davwoh         Moved to curly
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_LOADORDERGROUP L"Win32_LoadOrderGroup"

class CWin32LoadOrderGroup ;

class CWin32LoadOrderGroup:public Provider {

    public:

        // Constructor/destructor
        //=======================

        CWin32LoadOrderGroup(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CWin32LoadOrderGroup() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);

    private:
        // Utility
        //========

        bool FindGroup(const CHStringArray &saGroup, LPCWSTR pszTemp, DWORD dwSize);
        HRESULT WalkGroups(MethodContext *pMethodContext, CInstance *pInstance, LPCWSTR pszSeekName);

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\logdiskpartition.h ===
//=================================================================

//

// LogDiskPartition.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef __ASSOC_LOGDISKPARTITION__
#define __ASSOC_LOGDISKPARTITION__

// Property set identification
//============================

#define	PROPSET_NAME_LOGDISKtoPARTITION	L"Win32_LogicalDiskToPartition"
#define BYTESPERSECTOR 512

class CWin32LogDiskToPartition : public Provider
{
public:

	// Constructor/destructor
	//=======================
	CWin32LogDiskToPartition(LPCWSTR strName, LPCWSTR pszNamespace = NULL ) ;
	~CWin32LogDiskToPartition() ;

	// Functions provide properties with current values
	//=================================================

	virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
	virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

	// Utility
	//========

	// Utility function(s)
	//====================

private:
	// Utility function(s)
	//====================
#ifdef NTONLY
	HRESULT AddDynamicInstancesNT( MethodContext* pMethodContext );
#endif

#if NTONLY == 4
	// Windows NT Helpers
	HRESULT RefreshInstanceNT( CInstance* pInstance );
    LPBYTE GetDiskKey(void);
	HRESULT EnumPartitionsForDiskNT( CInstance* pLogicalDisk, TRefPointerCollection<CInstance>& partitionList, MethodContext* pMethodContext, LPBYTE pBuff );
    BOOL IsRelatedNT(

        DISK_EXTENT *diskExtent,
        DWORD dwDrive,
        DWORD dwPartition,
        ULONGLONG &u64StartingAddress,
        ULONGLONG &u64EndingAddress
    );
    DWORD GetExtentsForDrive(
        LPCWSTR lpwszLogicalDisk,
        LPBYTE pBuff,
        DISK_EXTENT *diskExtent
    );
#endif

#if NTONLY >= 5
	HRESULT EnumPartitionsForDiskNT5(CInstance* pLogicalDisk, TRefPointerCollection<CInstance>& partitionList, MethodContext* pMethodContext );
	HRESULT RefreshInstanceNT5( CInstance* pInstance );
#endif

} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\logdiskpartition.cpp ===
//=================================================================

//

// LogDiskPartition.cpp

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <assertbreak.h>

typedef  long NTSTATUS;
#include <devioctl.h>
#include <ntddft.h>
#include <ntddvol.h>
#include <ntdddisk.h>
#include <ntdskreg.h>

#include "logdiskpartition.h"

#define CLUSTERSIZE 4096
#define MAXEXTENTS 31
#define MAXEXTENTSIZE (sizeof(VOLUME_DISK_EXTENTS) + (MAXEXTENTS * sizeof(DISK_EXTENT)))

// Property set declaration
//=========================

CWin32LogDiskToPartition win32LogDiskToPartition( PROPSET_NAME_LOGDISKtoPARTITION, IDS_CimWin32Namespace );


//////////////////////////////////////////////////////////////////////////////
//
//  logdiskpartition.cpp - Class implementation of CWin32LogDiskToPartition.
//
//  This class is intended to locate Win32 Logical Disks and create
//  associations between these logical disks and physical partitions on the
//  local hard disk(s).
//
//////////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogDiskToPartition::CWin32LogDiskToPartition
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *                LPCTSTR pszNamespace - Namespace for class
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32LogDiskToPartition::CWin32LogDiskToPartition( LPCWSTR strName, LPCWSTR pszNamespace /*=NULL*/ )
:   Provider( strName, pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogDiskToPartition::~CWin32LogDiskToPartition
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32LogDiskToPartition::~CWin32LogDiskToPartition()
{
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32LogDiskToPartition::GetObject
//
//  Inputs:     CInstance*      pInstance - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32LogDiskToPartition::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
    // Find the instance depending on platform id.
#if NTONLY >= 5
    return RefreshInstanceNT5(pInstance);
#endif

#if NTONLY == 4
    return RefreshInstanceNT(pInstance);
#endif


}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32LogDiskToPartition::EnumerateInstances
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32LogDiskToPartition::EnumerateInstances( MethodContext* pMethodContext, long lFlags /*= 0L*/ )
{
    HRESULT     hr          =   WBEM_S_NO_ERROR;

    // Get the proper OS dependent instance

#ifdef NTONLY
    hr = AddDynamicInstancesNT( pMethodContext );
#endif

    return hr;

}

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    :   CWin32LogDiskToPartition::AddDynamicInstancesNT
//
//  DESCRIPTION :   Queries the computer for run-time associations, each of
//                  which will have an instance created and saved.
//
//  INPUTS      :   none
//
//  OUTPUTS     :   none
//
//  RETURNS     :   DWORD       dwNumInstances - Number of instances located.
//
//  COMMENTS    :   Uses QueryDosDevice to find logical disks that are using
//                  "\device\harddisk" devices and associates them to their
//                  correct paritions.  At this time, this probably will
//                  not handle a "striped disk" (a disk spanning multiple
//                  partitions).
//
//////////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
HRESULT CWin32LogDiskToPartition::AddDynamicInstancesNT( MethodContext* pMethodContext )
{
    HRESULT hr;

    // Collections
    TRefPointerCollection<CInstance>    logicalDiskList;
    TRefPointerCollection<CInstance>    partitionList;

    // Perform queries
    //================

    if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(_T("SELECT DeviceID FROM Win32_LogicalDisk Where DriveType = 3 or DriveType = 2"),
                                            &logicalDiskList,
                                            pMethodContext,
                                            IDS_CimWin32Namespace)) &&
        SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(_T("Select DeviceID, StartingOffset, Size, DiskIndex, Index from Win32_DiskPartition"),
                                            &partitionList,
                                            pMethodContext,
                                            IDS_CimWin32Namespace)))
    {
        REFPTRCOLLECTION_POSITION   pos;

        if ( logicalDiskList.BeginEnum( pos ) )
        {

            CInstancePtr pLogicalDisk;
#if NTONLY == 4
            LPBYTE t_pBuff = GetDiskKey();
            if (t_pBuff)
            {
                try
                {
#endif

                    for ( pLogicalDisk.Attach(logicalDiskList.GetNext( pos ));
                         (WBEM_S_NO_ERROR == hr) && (pLogicalDisk != NULL);
                         pLogicalDisk.Attach(logicalDiskList.GetNext( pos )) )
                    {
#if NTONLY >= 5
                        hr = EnumPartitionsForDiskNT5( pLogicalDisk, partitionList, pMethodContext );
#else
                        hr = EnumPartitionsForDiskNT( pLogicalDisk, partitionList, pMethodContext, t_pBuff );
#endif

                    }   // for GetNext

                    logicalDiskList.EndEnum();
#if NTONLY == 4
                }
                catch ( ... )
                {
                    delete [] t_pBuff;
                    throw;
                }
                delete [] t_pBuff;
            }

#endif

        }   // IF BeginEnum
    }

    return hr;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    :   CWin32LogDiskToPartition::EnumPartitionsForDiskNT
//
//  DESCRIPTION :   Enumerates partitions from the supplied list, attemptng
//                  to find a partition matching the supplied logical disk.
//
//  INPUTS      :   CInstance*      pLogicalDisk - Logical Disk Drive
//                  TRefPointerCollection<CInstance>&   partitionList - Partition instances.
//                  MethodContext*  pMethodContext - Method Context.
//
//  OUTPUTS     :   none
//
//  RETURNS     :   DWORD       dwNumInstances - Number of instances located.
//
//  COMMENTS    :   At this time, this probably will not handle a "striped disk"
//                  (a disk spanning multiple partitions).
//
//////////////////////////////////////////////////////////////////////////////

#if NTONLY == 4
HRESULT CWin32LogDiskToPartition::EnumPartitionsForDiskNT(
                                 CInstance* pLogicalDisk,
                                 TRefPointerCollection<CInstance>& partitionList,
                                 MethodContext* pMethodContext,
                                 LPBYTE t_pBuff)
{
    HRESULT     hr = WBEM_S_NO_ERROR;
    DISK_EXTENT diskExtent[MAXEXTENTS];

    CInstancePtr pPartition;
    CHString    strLogicalDiskPath,
                strPartitionPath;
    CHString t_sDeviceID;

    pLogicalDisk->GetCHString(IDS_DeviceID, t_sDeviceID);
    DWORD dwExtents = GetExtentsForDrive(t_sDeviceID, t_pBuff, diskExtent);

    // Walk all the extents for this logical drive letter
    for (DWORD x=0; x < dwExtents; x++)
    {
        REFPTRCOLLECTION_POSITION   pos;

        // Compare the current extent against each of the partitions
        if ( partitionList.BeginEnum( pos ) )
        {
            for ( pPartition.Attach(partitionList.GetNext( pos )) ;
                  SUCCEEDED( hr ) && (pPartition != NULL) ;
                  pPartition.Attach(partitionList.GetNext( pos )) )
            {
                // If there is an association, create an instance from the method context
                //

                DWORD dwDisk = 0xffffffff;
                DWORD dwPartition = 0xffffffff;
                ULONGLONG i64Start, i64End;

                pPartition->GetDWORD(IDS_DiskIndex, dwDisk);
                pPartition->GetDWORD(IDS_Index, dwPartition);
                pPartition->GetWBEMINT64(IDS_StartingOffset, i64Start);
                pPartition->GetWBEMINT64(IDS_Size, i64End);

                i64End += i64Start;
                i64End -= 1;

                // i64Start and i64End are updated by this call
                if (IsRelatedNT(&diskExtent[x], dwDisk, dwPartition, i64Start, i64End ))
                {
                    CInstancePtr pInstance(CreateNewInstance( pMethodContext ), false);

                    // We got this far, there will be values for the Relative Path
                    // so don't worry about return failures here.

                    GetLocalInstancePath( pLogicalDisk, strLogicalDiskPath );
                    GetLocalInstancePath( pPartition, strPartitionPath );

                    pInstance->SetCHString( IDS_Dependent, strLogicalDiskPath );
                    pInstance->SetCHString( IDS_Antecedent, strPartitionPath );

                    pInstance->SetWBEMINT64( IDS_StartingAddress, i64Start );
                    pInstance->SetWBEMINT64( IDS_EndingAddress, i64End );

                    // This will invalidate the pointer
                    hr = pInstance->Commit(  );
                }
            }   // for GetNext

            partitionList.EndEnum();
        } // IF BeginEnum
    }

    return hr;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    :   CWin32LogDiskToPartition::RefreshInstance
//
//  DESCRIPTION :   Called when we need to refresh values for the supplied
//                  paths.  Simply checks that the association is valid.
//
//  INPUTS      :   CInstance*      pInstance - Instance to refresh.
//
//  OUTPUTS     :   none.

//
//  RETURNS     :   BOOL        TRUE/FALSE - Success/Failure
//
//  COMMENTS    :   Uses QueryDosDevice to determine if the association is
//                  still valid.  Will not work for "striped drives".
//
//////////////////////////////////////////////////////////////////////////////

#if NTONLY == 4
HRESULT CWin32LogDiskToPartition::RefreshInstanceNT( CInstance* pInstance )
{
    HRESULT hres = WBEM_E_FAILED;

    CHString    strLogicalDiskPath,
                strPartitionPath;

    // Logical Disk and Partition Instances
    CInstancePtr pLogicalDisk;
    CInstancePtr pPartition;

    // We need these values to get the instances
    pInstance->GetCHString( IDS_Dependent, strLogicalDiskPath );
    pInstance->GetCHString( IDS_Antecedent, strPartitionPath );

    if (SUCCEEDED(hres = CWbemProviderGlue::GetInstanceByPath(strLogicalDiskPath,
        &pLogicalDisk)) &&
        SUCCEEDED(hres = CWbemProviderGlue::GetInstanceByPath(strPartitionPath,
        &pPartition)))
    {
        hres = WBEM_E_NOT_FOUND;

        CHString t_sDeviceID;
        DWORD dwDisk = 0xffffffff;
        DWORD dwPartition = 0xffffffff;
        ULONGLONG i64Start, i64End;

        pLogicalDisk->GetCHString(IDS_DeviceID, t_sDeviceID);
        LPBYTE t_pBuff = GetDiskKey();
        DISK_EXTENT diskExtent[MAXEXTENTS];
        DWORD dwExtents;

        try
        {
            dwExtents = GetExtentsForDrive(t_sDeviceID, t_pBuff, diskExtent);
        }
        catch ( ... )
        {
            delete [] t_pBuff;
            throw;
        }
        delete [] t_pBuff;

        pPartition->GetDWORD(IDS_DiskIndex, dwDisk);
        pPartition->GetDWORD(IDS_Index, dwPartition);
        pPartition->GetWBEMINT64(IDS_StartingOffset, i64Start);
        pPartition->GetWBEMINT64(IDS_Size, i64End);

        i64End += i64Start;
        i64End -= 1;

        // Walk all the extents looking for a match
        for (DWORD x=0; x < dwExtents; x++)
        {
            if (IsRelatedNT(&diskExtent[x], dwDisk, dwPartition, i64Start, i64End ))
            {
                pInstance->SetCHString( IDS_Dependent, strLogicalDiskPath );
                pInstance->SetCHString( IDS_Antecedent, strPartitionPath );

                pInstance->SetWBEMINT64( IDS_StartingAddress, i64Start );
                pInstance->SetWBEMINT64( IDS_EndingAddress, i64End );

                hres = WBEM_S_NO_ERROR;
                break;
            }
        }
    }   // IF Get both objects

    return hres;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    :   CWin32LogDiskToPartition::EnumPartitionsForDiskNT5
//
//  DESCRIPTION :   Enumerates partitions from the supplied list, attemptng
//                  to find a partition matching the supplied logical disk.
//
//  INPUTS      :   CInstance*      pLogicalDisk - Logical Disk Drive
//                  TRefPointerCollection<CInstance>&   partitionList - Partition instances.
//                  MethodContext*  pMethodContext - Method Context.
//
//  OUTPUTS     :   none
//
//  RETURNS     :
//
//  COMMENTS    :   At this time, this probably will not handle a "striped disk"
//                  (a disk spanning multiple partitions).
//
//////////////////////////////////////////////////////////////////////////////

#if NTONLY >= 5
HRESULT CWin32LogDiskToPartition::EnumPartitionsForDiskNT5(

    CInstance* pLogicalDisk,
    TRefPointerCollection<CInstance>& partitionList,
    MethodContext* pMethodContext
)
{

    DWORD dwSize;
    HRESULT hr = WBEM_S_NO_ERROR;
    CHString sDeviceID;

    VOLUME_DISK_EXTENTS *pExt = (VOLUME_DISK_EXTENTS *)new BYTE[MAXEXTENTSIZE];
    if (pExt == NULL)
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    try
    {
        memset(pExt, '\0', MAXEXTENTSIZE);

        // Format the name to \\.\c: format
        pLogicalDisk->GetCHString(IDS_DeviceID, sDeviceID);
        sDeviceID = _T("\\\\.\\") + sDeviceID;

        SmartCloseHandle fHan;
        // Open the drive
        fHan = CreateFile(sDeviceID,
                        FILE_ANY_ACCESS ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

        // If the open worked
        if (fHan != INVALID_HANDLE_VALUE)
        {
            // Try to get the partition info
            if (DeviceIoControl(fHan,
                            IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                            NULL,
                            0,
                            pExt,
                            MAXEXTENTSIZE,
                            &dwSize,
                            NULL))
            {
                // Now we walk the partitions from partitionList looking for the entries
                // we just got back from DeviceIoControl

                for (DWORD x=0; x < pExt->NumberOfDiskExtents; x++)
                {
                    REFPTRCOLLECTION_POSITION   pos;

                    if ( partitionList.BeginEnum( pos ) )
                    {
                        bool bFound = false;
                        CInstancePtr pPartition;
                        ULONGLONG i64StartingOffset, i64PartitionSize;
                        DWORD dwDisk;
                        CHString strLogicalDiskPath, strPartitionPath;
                        ULONGLONG i64Start, i64End;

                        for (pPartition.Attach(partitionList.GetNext( pos )) ;
                            (!bFound) && (pPartition != NULL ) ;
                             pPartition.Attach(partitionList.GetNext( pos )))
                        {
                            pPartition->GetWBEMINT64(IDS_StartingOffset, i64StartingOffset);
                            pPartition->GetWBEMINT64(IDS_Size, i64PartitionSize);
                            pPartition->GetDWORD(IDS_DiskIndex, dwDisk);

                            // If the disk numbers are the same, and the starting offset is within
                            // the disk partition, it's related
                            bFound = ((dwDisk == pExt->Extents[x].DiskNumber) &&
                                (pExt->Extents[x].StartingOffset.QuadPart >= i64StartingOffset) &&
                                (pExt->Extents[x].StartingOffset.QuadPart < i64StartingOffset + i64PartitionSize));

                            // Grab the path
                            if (bFound)
                            {
                                GetLocalInstancePath( pLogicalDisk, strLogicalDiskPath );
                                GetLocalInstancePath( pPartition, strPartitionPath );

                                i64Start = pExt->Extents[x].StartingOffset.QuadPart;
                                i64End = i64Start + pExt->Extents[x].ExtentLength.QuadPart;
                                i64End -= 1;

                            }
                        }

                        partitionList.EndEnum();

                        // If we found it, create an instance.
                        if (bFound)
                        {
                            CInstancePtr pInstance(CreateNewInstance( pMethodContext ), false);

                            pInstance->SetCHString( IDS_Dependent, strLogicalDiskPath );
                            pInstance->SetCHString( IDS_Antecedent, strPartitionPath );

                            pInstance->SetWBEMINT64( IDS_StartingAddress, i64Start );
                            pInstance->SetWBEMINT64( IDS_EndingAddress, i64End );

                            hr = pInstance->Commit(  );
                        }
                    }
                }
            }

        }
    }
    catch ( ... )
    {

        delete pExt;
        throw ;
    }

    delete pExt;

    return hr;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    :   CWin32LogDiskToPartition::RefreshInstanceNT5
//
//  DESCRIPTION :
//
//  INPUTS      :   CInstance*      pInstance - Instance to refresh.
//
//  OUTPUTS     :   none.
//
//  RETURNS     :   BOOL        TRUE/FALSE - Success/Failure
//
//  COMMENTS    :   Will not work for "striped drives".
//
//////////////////////////////////////////////////////////////////////////////

#if NTONLY >= 5
HRESULT CWin32LogDiskToPartition::RefreshInstanceNT5( CInstance* pInstance )
{
    HRESULT hres = WBEM_E_FAILED;
    CHString    strLogicalDiskPath,
                strPartitionPath;

    // Logical Disk and Partition Instances
    CInstancePtr pLogicalDisk;
    CInstancePtr pPartition;

    // We need these values to get the instances
    pInstance->GetCHString( IDS_Dependent, strLogicalDiskPath );
    pInstance->GetCHString( IDS_Antecedent, strPartitionPath );

    if (SUCCEEDED(hres = CWbemProviderGlue::GetInstanceByPath(strLogicalDiskPath,
        &pLogicalDisk, pInstance->GetMethodContext())) &&
        SUCCEEDED(hres = CWbemProviderGlue::GetInstanceByPath(strPartitionPath,
            &pPartition, pInstance->GetMethodContext())))
    {
        DWORD dwLastError = 0;

        hres = WBEM_E_FAILED;

        // Format the name to \\.\c: format
        CHString sDeviceID;
        pLogicalDisk->GetCHString(IDS_DeviceID, sDeviceID);
        sDeviceID = _T("\\\\.\\") + sDeviceID;

        // Open the drive
        SmartCloseHandle fHan =
            CreateFile(sDeviceID,
                FILE_ANY_ACCESS ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL);

        // If the open worked
        if (fHan != INVALID_HANDLE_VALUE)
        {
            VOLUME_DISK_EXTENTS *pExt = (VOLUME_DISK_EXTENTS *)new BYTE[MAXEXTENTSIZE];
            if (pExt == NULL)
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

            try
            {
                memset(pExt, '\0', MAXEXTENTSIZE);

                // Try to get the partition info
                DWORD dwSize;
                if (DeviceIoControl(fHan,
                    IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                    NULL,
                    0,
                    pExt,
                    MAXEXTENTSIZE,
                    &dwSize,
                    NULL))
                {
                    ULONGLONG i64StartingOffset, i64Size;
                    DWORD dwDisk;

                    pPartition->GetWBEMINT64(IDS_StartingOffset, i64StartingOffset);
                    pPartition->GetWBEMINT64(IDS_Size, i64Size);
                    pPartition->GetDWORD(IDS_DiskIndex, dwDisk);

                    // If the disk numbers are the same, and the starting offset is within
                    // the disk partition, it's related
                    BOOL bFound = FALSE;
                    for (DWORD x=0; x < pExt->NumberOfDiskExtents && !bFound; x++)
                    {
                        bFound = ((dwDisk == pExt->Extents[x].DiskNumber) &&
                            (pExt->Extents[x].StartingOffset.QuadPart >= i64StartingOffset) &&
                            (pExt->Extents[x].StartingOffset.QuadPart < i64StartingOffset + i64Size));
                    }

                    if (bFound)
                    {
                        pInstance->SetWBEMINT64(IDS_StartingAddress, pExt->Extents[x-1].StartingOffset.QuadPart);
                        pInstance->SetWBEMINT64(IDS_EndingAddress, pExt->Extents[x-1].StartingOffset.QuadPart + pExt->Extents[x-1].ExtentLength.QuadPart - (ULONGLONG)1);

                        hres = WBEM_S_NO_ERROR;
                    }
                    else
                    {
                        hres = WBEM_E_NOT_FOUND;
                    }
                }
                else
                {
                    dwLastError = GetLastError();
                }
            }
            catch ( ... )
            {
                delete [] pExt;
                throw;
            }

            delete [] pExt;
        }
        else
        {
            dwLastError = GetLastError();
        }

        // Either CreateFile or DeviceIOControl failed, so find out what
        // happened.
        if (hres == WBEM_E_FAILED)
            hres = WinErrorToWBEMhResult(dwLastError);
    }   // IF Get both objects

    return hres;
}
#endif

/* Info on how to read the 'disk' key in the nt4 registry from Cristian Teodorescu:
This is the basic information you need in order to "read" the FT volumes in NT 4.0

1. The FT volumes configuration information is stored in the registry under
"HKEY_LOCAL_MACHINE\ SYSTEM \ DISK : Information (binary value).

2. This binary value starts with a header of type DISK_CONFIG_HEADER (see "ntddft.h")

3. The interesting data for you is a structure of type DISK_REGISTRY starting at the
offset DISK_CONFIG_HEADER::DiskInformationOffset from the base of the binary value. The
length of the DISK_REGISTRY data is DISK_CONFIG_HEADER::DiskInformationSize.
Structure DISK_REGISTRY is defined in "ntdskreg.h"

4. You can get directly the DISK_REGISTRY structure by calling DiskRegistryGet (defined
in "ntdskreg.h").  So, at this moment you can forget about points 1-3 above.

5. DISK_REGISTRY contains the number of disks plus an array of DISK_DESCRIPTION. Every
DISK_DESCRIPTION contains the signature, the number of partitions and an array of DISK_PARTITION.
Every DISK_PARTITION corresponds to a partition on the physical disk.
Note: You should use the signatures to map the DISK_DESCRIPTION structures found in
the registry with the actual physical disks you'll find in the system. Then you have
to check for every disk  whether the DISK_PARTITION structures match or not with
the actual partitions you'll find on the physical disk

6. This is a short explanation of DISK_PARTITION (defined in "ntdskreg.h"):

FT_TYPE FtType;
The type of the FT set whose member is this partition. NotAnFtMember is used to
mark the "normal" partitions. For such "normal" (non FT) partitions many of the
following fields are not used

FT_PARTITION_STATE FtState;
The state of the partition (if it is a member of an FT set). It also gives you
the health of the whole FT set

LARGE_INTEGER StartingOffset;
The partition starting offset

LARGE_INTEGER      Length;
The partition length

LARGE_INTEGER      FtLength;
Not used

UCHAR DriveLetter;
The drive letter of the FT set. Use it only when FtMember == 0 and
AssignDriveLetter == TRUE

BOOLEAN  AssignDriveLetter;
This boolean indicates whether or not the field DriveLetter is valid and you
can use it as the drive letter of the FT set

USHORT LogicalNumber
I don't know what is this

USHORT FtGroup
This is a number identifying the FT set whose member is this partition.  An FT
set is identified uniquely using its FT_TYPE and this number.  Note that you
may found FT sets with the same number, but they must have different FT types
(E.g. Mirror #2 and Stripe #2, but never 2 mirrors with #2)

USHORT FtMember
Zero-based number identifying what member of the FT set is this partition.  E.g.
if the FT set is a stripe with 3 members then its members have FTMember equal
with 0, 1, 2

BOOLEAN            Modified;
Doesn't matter

7. Basically what you want to do is:
    For every disk description:
         For every partition description
        If FtType ==  NotAnFtMember
            continue;
        //This is member <FtMember> of the FT set identified by <FtType> + <FtGroup>.
        If you haven't create yet an object for this FT set then create it.
        Add this member to the FT set


8. I strongly recommend to take a look at the old WINDISK code: \\hx86fix\nt40src\private\utils\windisk .
Read the function InitializeFt from \src\ft.cxx to see how windisk "reads" the FT volumes.
Don't forget to match what you read from registry with what you actually find on the disks.

9. If you want to create / modify FT volumes then things get a little bit complicated.

*/

#if NTONLY == 4
LPBYTE CWin32LogDiskToPartition::GetDiskKey(void)
{
    CRegistry RegInfo;
    LPBYTE pBuff = NULL;

    DWORD dwRet = RegInfo.Open (

        HKEY_LOCAL_MACHINE,
        L"SYSTEM\\DISK",
        KEY_QUERY_VALUE
    ) ;

    if (dwRet == ERROR_SUCCESS)
    {
        DWORD dwSize = 0;
        if (RegInfo.GetCurrentBinaryKeyValue(L"Information", NULL, &dwSize) == ERROR_SUCCESS)
        {
            pBuff = new BYTE[dwSize];
            if (pBuff)
            {
                try
                {
                    if (RegInfo.GetCurrentBinaryKeyValue(L"Information", pBuff, &dwSize) != ERROR_SUCCESS)
                    {
						// The delete from here has been moved after Catch
                    }
                }
                catch ( ... )
                {
                    delete [] pBuff;
                    throw;
                }
				delete [] pBuff;
                pBuff = NULL;
            }
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
        }
    }

    ASSERT_BREAK(pBuff != NULL);

    return pBuff;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\logicaldisk.h ===
//=================================================================

//

// LogicalDisk.h -- Logical disk property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/28/96    a-jmoon        Created
//
//=================================================================

typedef BOOL (WINAPI *KERNEL32_DISK_FREESPACEEX) (LPCTSTR lpDirectoryName,
                                                  PULARGE_INTEGER lpFreeBytesAvailableToCaller,
                                                  PULARGE_INTEGER lpTotalNumberOfBytes,
                                                  PULARGE_INTEGER lpTotalNumberOfFreeBytes) ;

// Property set identification
//============================

#define  PROPSET_NAME_LOGDISK  L"Win32_LogicalDisk"

class LogicalDisk : public Provider
{
public:

    // Constructor/destructor
    //=======================

    LogicalDisk(LPCWSTR name, LPCWSTR pszNamespace);
   ~LogicalDisk() ;

    // Functions provide properties with current values
    //=================================================

	virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &pQuery);
	virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
	virtual HRESULT PutInstance(const CInstance &pInstance, long lFlags = 0L);
	virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ );

#ifdef NTONLY
	HRESULT ExecMethod ( const CInstance& Instance, const BSTR bstrMethodName, CInstance *pInParams, CInstance *pOutParams, long lFlags ) ;
#endif


    // Utility
    //========

    void    GetLogicalDiskInfo				(CInstance* pInstance, DWORD dwProperties ) ;
    void    GetFixedDriveInfo				(CInstance* pInstance, LPCTSTR pszName, DWORD dwProperties ) ;
    void    GetRemoveableDriveInfo			(CInstance* pInstance, LPCTSTR pszName, DWORD dwProperties ) ;
    void    GetRemoveableDriveInfoNT		(CInstance* pInstance, LPCTSTR pszName, BOOL &a_MediaPresent, DWORD dwProperties ) ;
    void    GetRemoveableDriveInfo95		(CInstance* pInstance, LPCTSTR pszName, BOOL &a_MediaPresent ) ;
    void    GetCDROMDriveInfoNT				(CInstance* pInstance, LPCTSTR pszName, BOOL &a_MediaPresent, DWORD dwProperties ) ;
    void    GetCDROMDriveInfo95				(CInstance* pInstance, LPCTSTR pszName, BOOL &a_MediaPresent ) ;

    void    GetRemoteDriveInfo				(CInstance* pInstance, LPCTSTR pszName, DWORD dwProperties ) ;
    void    GetCDROMDriveInfo				(CInstance* pInstance, LPCTSTR pszName, DWORD dwProperties ) ;
    void    GetRAMDriveInfo					(CInstance* pInstance, LPCTSTR pszName, DWORD dwProperties ) ;

	// Drive space and volume information helpers

	DWORD   GetDriveVolumeInformation		(CInstance* pInstance, LPCTSTR pszName );
	BOOL	GetDriveFreeSpace				(CInstance* pInstance, LPCTSTR pszName );

private:

#ifdef NTONLY
	BOOLEAN IsVolumeDirty( IN  CHString    &NtDriveName, OUT BOOLEAN     *Result );

	HRESULT ExecChkDsk ( const CInstance& a_Instance, CInstance *a_InParams, CInstance *a_OutParams, long lFlags );
	HRESULT ExecChkDskMode ( const CInstance& a_Instance, CInstance *a_InParams,  CInstance *a_OutParams, LPWSTR DriveName, long lFlags );
	HRESULT ExecExcludeFromChkDsk( CInstance *a_InParams, CInstance *a_OutParams, long lFlags );
	HRESULT ExecScheduleChkdsk( CInstance *a_InParams,  CInstance *a_OutParams, long lFlags );
	HRESULT CheckChkDsk ( CInstance *a_InParams , CInstance *a_OutParams , LPWSTR DriveName, DWORD &a_Status );
	HRESULT GetChkNtfsCommand ( CInstance *a_InParams, CInstance *a_OutParams, WCHAR w_Mode,  CHString &a_ChkNtfsCommand, DWORD &dwRetVal);
	HRESULT CheckParameters ( CInstance *a_InParams );

	HRESULT ExecuteCommand ( LPCWSTR wszCommand );
#endif

    CHPtrArray m_ptrProperties;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\logicalfileaccess.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

#define  LOGICAL_FILE_ACCESS_NAME "Win32_LogicalFileAccess" 

// provider provided for test provisions
class CWin32LogicalFileAccess: public Provider
{
	private:
    public:	
		CWin32LogicalFileAccess(const CHString& setName, const WCHAR* pszNamespace );
		~CWin32LogicalFileAccess();

		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags /*= 0L*/);
		virtual HRESULT GetObject( CInstance* pInstance, long lFlags /*= 0L*/ );
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, 
                                  CFrameworkQuery& pQuery, 
                                  long lFlags = 0L);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\logicaldisk.cpp ===
//=================================================================
//
// LogicalDisk.CPP -- Logical Disk property set provider
//
//  Copyright (c) 1996-2002 Microsoft Corporation, All Rights Reserved
//
//
// Strings for ValueMaps for DriveType come from:
// \\trango\slmadd\src\shell\shell32\shel32.rc.  Search for
// IDS_DRIVES_REMOVABLE to find the clump.
//=================================================================
// following includes required for Getting if Volume is dirty 
// a property for chkdsk.

#include "precomp.h"
#include <assertbreak.h>
#include <winioctl.h>
#include "sid.h"
#include "implogonuser.h"
#include <frqueryex.h>
#include "resource.h"
#include "LogicalDisk.h"
#include "Kernel32Api.h"
#include <lmuse.h>
#include "DllWrapperBase.h"
#include "MprApi.h"
#include <initguid.h>
#include <DskQuota.h>
#include "..\dskquotaprovider\inc\DskQuotaCommon.h"

#include "AdvApi32Api.h"
#include "UserEnvApi.h"
#include "userhive.h"


#ifdef NTONLY
// for chkdisk dll exposed methods
#include <fmifs.h>
#include "mychkdsk.h"
#endif

#define LD_ALL_PROPS                        0xffffffff
#define LD_Name_BIT                         0x00000001
#define LD_Caption_BIT                      0x00000002
#define LD_DeviceID_BIT                     0x00000004
#define LD_Description_BIT                  0x00000008
#define LD_DriveType_BIT                    0x00000010
#define LD_SystemCreationClassName_BIT      0x00000020
#define LD_SystemName_BIT                   0x00000040
#define LD_MediaType_BIT                    0x00000080
#define LD_ProviderName_BIT                 0x00000100
#define LD_VolumeName_BIT                   0x00000200
#define LD_FileSystem_BIT                   0x00000400
#define LD_VolumeSerialNumber_BIT           0x00000800
#define LD_Compressed_BIT                   0x00001000
#define LD_SupportsFileBasedCompression_BIT 0x00002000
#define LD_MaximumComponentLength_BIT       0x00004000
#define LD_Size_BIT                         0x00008000
#define LD_FreeSpace_BIT                    0x00010000
// for dskQuotas
#define LD_SupportsDiskQuotas				0x00020000
#define LD_QuotasDisabled					0x00040000
#define LD_QuotasIncomplete					0x00080000
#define LD_QuotasRebuilding					0x00100000
//ForChkDsk
#define LD_VolumeDirty					0x00200000



#define LD_GET_VOL_INFO      (LD_VolumeName_BIT | \
                             LD_FileSystem_BIT | \
                             LD_VolumeSerialNumber_BIT | \
                             LD_Compressed_BIT | \
                             LD_SupportsFileBasedCompression_BIT | \
                             LD_MaximumComponentLength_BIT | \
                             LD_SupportsDiskQuotas | \
                             LD_QuotasDisabled | \
                             LD_QuotasIncomplete | \
                             LD_QuotasRebuilding | \
                             LD_VolumeDirty)


#define LD_SPIN_DISK        (LD_GET_VOL_INFO | \
                             LD_Size_BIT | \
                             LD_FreeSpace_BIT)

#ifdef NTONLY
std::map < DWORD, DWORD > mReturnVal;
#endif

// Property set declaration
//=========================
LogicalDisk MyLogicalDiskSet ( PROPSET_NAME_LOGDISK , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::LogicalDisk
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

LogicalDisk :: LogicalDisk (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
    m_ptrProperties.SetSize(22);

    m_ptrProperties[0] = ((LPVOID) IDS_Name);
    m_ptrProperties[1] = ((LPVOID) IDS_Caption);
    m_ptrProperties[2] = ((LPVOID) IDS_DeviceID);
    m_ptrProperties[3] = ((LPVOID) IDS_Description);
    m_ptrProperties[4] = ((LPVOID) IDS_DriveType);
    m_ptrProperties[5] = ((LPVOID) IDS_SystemCreationClassName);
    m_ptrProperties[6] = ((LPVOID) IDS_SystemName);
    m_ptrProperties[7] = ((LPVOID) IDS_MediaType);
    m_ptrProperties[8] = ((LPVOID) IDS_ProviderName);
    m_ptrProperties[9] = ((LPVOID) IDS_VolumeName);
    m_ptrProperties[10] = ((LPVOID) IDS_FileSystem);
    m_ptrProperties[11] = ((LPVOID) IDS_VolumeSerialNumber);
    m_ptrProperties[12] = ((LPVOID) IDS_Compressed);
    m_ptrProperties[13] = ((LPVOID) IDS_SupportsFileBasedCompression);
    m_ptrProperties[14] = ((LPVOID) IDS_MaximumComponentLength);
    m_ptrProperties[15] = ((LPVOID) IDS_Size);
    m_ptrProperties[16] = ((LPVOID) IDS_FreeSpace);
	m_ptrProperties[17] = ((LPVOID) IDS_SupportsDiskQuotas);
	m_ptrProperties[18] = ((LPVOID) IDS_QuotasDisabled);
	m_ptrProperties[19] = ((LPVOID) IDS_QuotasIncomplete);
	m_ptrProperties[20] = ((LPVOID) IDS_QuotasRebuilding);
	m_ptrProperties[21] = ((LPVOID) IDS_VolumeDirty);
}

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::~LogicalDisk
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

LogicalDisk :: ~LogicalDisk ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::~LogicalDisk
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

HRESULT LogicalDisk :: ExecQuery (

	MethodContext *pMethodContext,
	CFrameworkQuery &pQuery,
	long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Use the extended query type

    std::vector<int> vectorValues;
    DWORD dwTypeSize = 0;

    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx *>(&pQuery);

    // Find out what properties they asked for
    DWORD dwProperties = 0;
    pQuery2->GetPropertyBitMask(m_ptrProperties, &dwProperties);

    // See if DriveType is part of the where clause
    pQuery2->GetValuesForProp(IDS_DriveType, vectorValues);
    dwTypeSize = vectorValues.size();

    // See if DeviceID is part of the where clause
    CHStringArray sDriveLetters;
    pQuery.GetValuesForProp ( IDS_DeviceID , sDriveLetters ) ;
    DWORD dwLetterSize = sDriveLetters.GetSize () ;

    // Format drives so they match what comes back from GetLogicalDriveStrings

    for ( DWORD x = 0 ; x < dwLetterSize ; x ++ )
    {
        sDriveLetters [ x ] += _T('\\') ;
    }

	CImpersonateLoggedOnUser icu;
	icu.Begin () ;

	// Get the LogicalDrive letters from the os

	TCHAR szDriveStrings [ 320 ] ;
    if ( GetLogicalDriveStrings ( ( sizeof(szDriveStrings)/sizeof(TCHAR)) - 1, szDriveStrings ) )
    {
        // Walk the drive letters
        for( TCHAR *pszCurrentDrive = szDriveStrings ; *pszCurrentDrive && SUCCEEDED ( hr ) ; pszCurrentDrive += (lstrlen(pszCurrentDrive) + 1))
        {
            bool bContinue = true;

            // If they specified a DriveType in the where clause
            if (dwTypeSize > 0)
            {

                // If we don't find a match, don't send back an instance
                bContinue = false;

                // Get the DriveType of the current loop
                DWORD dwDriveType = GetDriveType(pszCurrentDrive);

                // See if it matches any of the values required
                for ( DWORD x = 0; x < dwTypeSize ; x ++ )
                {
                    if ( vectorValues [ x ] == dwDriveType )
                    {
                        bContinue = true ;
                        break;
                    }
                }
            }

            // If DriveType failed, no point in continuing.
            // Otherwise, if they specified a DeviceID

            if ( ( bContinue ) && ( dwLetterSize > 0 ) )
            {
                // Even if DriveType matched, if they specified a DeviceID,
                // there's no point continuing if we don't find a match.

                bContinue = false;

                for ( DWORD x = 0 ; x < dwLetterSize ; x ++ )
                {
                    if ( sDriveLetters [ x ].CompareNoCase ( TOBSTRT ( pszCurrentDrive ) ) == 0 )
                    {
                        bContinue = true ;
                        break;
                    }
                }
            }

            // If the where clauses haven't filtered out this drive letter

            if ( bContinue )
            {
		        CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false);
				CHString currentDrive ( pszCurrentDrive ) ;
				currentDrive.MakeUpper();

				pInstance->SetCHString(IDS_Name, currentDrive.SpanExcluding(L"\\"));
				pInstance->SetCHString(IDS_Caption, currentDrive.SpanExcluding(L"\\"));
				pInstance->SetCHString(IDS_DeviceID, currentDrive.SpanExcluding(L"\\"));

				GetLogicalDiskInfo ( pInstance, dwProperties ) ;

				hr = pInstance->Commit (  ) ;
            }
        }
    }

	return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT LogicalDisk :: GetObject (

	CInstance *pInstance,
	long lFlags,
    CFrameworkQuery &pQuery
)
{
    HRESULT hRetCode = WBEM_E_NOT_FOUND;

	CImpersonateLoggedOnUser icu;
	icu.Begin () ;

	TCHAR szDriveStrings[320] ;
    if ( GetLogicalDriveStrings((sizeof(szDriveStrings) - 1) / sizeof(TCHAR), szDriveStrings ) )
	{
		CHString strName ;
		pInstance->GetCHString(IDS_DeviceID, strName);

        for (	TCHAR *pszCurrentDrive = szDriveStrings ;
				*pszCurrentDrive ;
				pszCurrentDrive += (lstrlen(pszCurrentDrive) + 1)
		)
		{
			CHString strDrive = pszCurrentDrive ;

			if ( 0 == strName.CompareNoCase( strDrive.SpanExcluding(L"\\") ) )
			{
				pInstance->SetCHString ( IDS_Name , strName ) ;
				pInstance->SetCHString ( IDS_Caption, strName ) ;

				// We will want expensive properties in this case

                CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx *>(&pQuery);

                // Find out what properties they asked for
                DWORD dwProperties = 0;
                pQuery2->GetPropertyBitMask(m_ptrProperties, &dwProperties);
				GetLogicalDiskInfo ( pInstance , dwProperties ) ;

				hRetCode = WBEM_S_NO_ERROR;

				break ;
			}
        }
    }

    return hRetCode ;
}

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each logical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT LogicalDisk :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
    TCHAR szDriveStrings[320] ;

	CImpersonateLoggedOnUser icu;
	icu.Begin () ;

	HRESULT hr = WBEM_S_NO_ERROR;
    if ( GetLogicalDriveStrings ( ( sizeof ( szDriveStrings ) / sizeof ( TCHAR ) ) - 1 , szDriveStrings ) )
	{
        for(	TCHAR *pszCurrentDrive = szDriveStrings ;
				*pszCurrentDrive && SUCCEEDED ( hr ) ;
				pszCurrentDrive += (lstrlen(pszCurrentDrive) + 1)
		)
		{
	        CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
			CHString currentDrive ( pszCurrentDrive ) ;
			currentDrive.MakeUpper ();

			pInstance->SetCHString ( IDS_Name , currentDrive.SpanExcluding(L"\\"));
			pInstance->SetCHString ( IDS_Caption , currentDrive.SpanExcluding(L"\\"));
			pInstance->SetCHString ( IDS_DeviceID , currentDrive.SpanExcluding(L"\\"));

			GetLogicalDiskInfo ( pInstance , LD_ALL_PROPS ) ;

			hr = pInstance->Commit (  ) ;
        }
    }

    return hr;
}

#ifdef NTONLY

/*****************************************************************************
*
*  FUNCTION    :    LogicalDisk::ExecMethod
*
*  DESCRIPTION :    Providing methods of chkdsk
*
*****************************************************************************/
HRESULT LogicalDisk::ExecMethod ( 

	const CInstance& Instance,
    const BSTR bstrMethodName,
    CInstance *pInParams,
    CInstance *pOutParams,
    long lFlags
) 
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	if ( ! pOutParams )
	{
		hRes = WBEM_E_INVALID_PARAMETER ;
	}

	if ( SUCCEEDED ( hRes ) )
	{
		CImpersonateLoggedOnUser icu;

		// Do we recognize the method?
		if ( _wcsicmp ( bstrMethodName , METHOD_NAME_CHKDSK ) == 0 )
		{
			icu.Begin () ;

			// This method is instance specific
			hRes = ExecChkDsk ( Instance , pInParams , pOutParams , lFlags ) ;	
		}
		else
		if ( _wcsicmp ( bstrMethodName , METHOD_NAME_SCHEDULEAUTOCHK ) == 0 )
		{
			icu.Begin () ;

			// Following methods are static, i.e. not dependent on the instance
			hRes = ExecScheduleChkdsk ( pInParams , pOutParams,  lFlags ) ;
		}
		else
		if ( _wcsicmp ( bstrMethodName , METHOD_NAME_EXCLUDEFROMAUTOCHK ) == 0 )
		{
			icu.Begin () ;

			// Following methods are static, i.e. not dependent on the instance
			hRes = ExecExcludeFromChkDsk ( pInParams , pOutParams, lFlags ) ;
		}
	}
		
	return hRes;
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::GetLogicalDiskInfo
 *
 *  DESCRIPTION : Loads LOGDISK_INFO struct w/property values according to
 *                disk type
 *
 *  INPUTS      : BOOL	fGetExpensiveProperties - Exp. Properties flag.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void LogicalDisk :: GetLogicalDiskInfo (

	CInstance *pInstance,
	DWORD dwProperties
)
{
	CHString name;
	pInstance->GetCHString ( IDS_Name , name ) ;
	ASSERT_BREAK(!name.IsEmpty());

    TCHAR szTemp[10] ;
    lstrcpy(szTemp, TOBSTRT(name)) ;
	lstrcat(szTemp, _T("\\")) ;

	// We got a drive letter.  If the disk is fixed, removable, or
	// a CD-ROM, assume it must be installed.  For network drives
	// or RAM Disk, "installed" doesn't seem to be applicable.

	DWORD dwDriveType = GetDriveType ( szTemp ) ;
    switch(dwDriveType)
	{
        case DRIVE_FIXED:
		{
            GetFixedDriveInfo ( pInstance, szTemp, dwProperties ) ;
		}
		break ;

		case DRIVE_REMOVABLE :
		{
            GetRemoveableDriveInfo ( pInstance,  szTemp, dwProperties ) ;
		}
		break ;

        case DRIVE_REMOTE :
		{
            GetRemoteDriveInfo ( pInstance,  szTemp, dwProperties ) ;
		}
        break ;

        case DRIVE_CDROM :
		{
			GetCDROMDriveInfo ( pInstance,  szTemp, dwProperties ) ;
		}
        break ;

        case DRIVE_RAMDISK :
		{
            GetRAMDriveInfo ( pInstance,  szTemp, dwProperties ) ;
		}
        break ;

        default :
		{
            pInstance->SetWCHARSplat(IDS_Description, L"Unknown drive type");
		}
        break ;
	}

	pInstance->SetDWORD ( IDS_DriveType , dwDriveType ) ;

	SetCreationClassName ( pInstance ) ;

	pInstance->SetWCHARSplat ( IDS_SystemCreationClassName , L"Win32_ComputerSystem" ) ;

	pInstance->SetCHString ( IDS_SystemName, GetLocalComputerName () ) ;

}

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::GetFixedDriveInfo
 *
 *  DESCRIPTION : Retrieves property values for fixed-media logical disk
 *
 *  INPUTS      : char*		pszName - Name of Drive to get info for.
 *					BOOL	fGetExpensiveProperties - Exp. Properties flag.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void LogicalDisk :: GetFixedDriveInfo (

	CInstance *pInstance,
	LPCTSTR pszName,
	DWORD dwProperties
)
{
	// Identify the drive type

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_LocalFixedDisk);

	pInstance->SetCHString ( IDS_Description , sTemp2 ) ;

    pInstance->SetDWORD ( IDS_MediaType , FixedMedia ) ;

    DWORD dwResult = 0 ;

	// Get Expensive properties now if appropriate.
	if ( dwProperties & LD_GET_VOL_INFO)
	{
		// Obtain volume information

		dwResult = GetDriveVolumeInformation ( pInstance , pszName ) ;
    }

    if (dwResult == 0)
    {
        if ( dwProperties &
            (LD_Size_BIT |
             LD_FreeSpace_BIT) )
		{
		    GetDriveFreeSpace ( pInstance , pszName ) ;
	    }
    }
}

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::GetRemoveableDriveInfo
 *
 *  DESCRIPTION : Retrieves property values for removeable drive
 *
 *  INPUTS      : char*		pszName - Name of Drive to get info for.
 *					BOOL	fGetExpensiveProperties - Exp. Properties flag.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Separates call based on 95 or NT
 *
 *****************************************************************************/

void LogicalDisk :: GetRemoveableDriveInfo (

	CInstance *pInstance,
	LPCTSTR pszName,
	DWORD dwProperties
)
{

	// In case anything goes wrong, at least say we're working with
	// a removeable disk.

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_RemovableDisk);

	pInstance->SetCHString ( IDS_Description , sTemp2 ) ;

	// Obtaining removeable drive information requires the use of
	// the DeviceIoControl function.  To further complicate things,
	// the method of retrieval is different for NT and 95, so
	// let's just farm out the function calls now.

	BOOL t_MediaPresent = FALSE ;
#ifdef NTONLY
	GetRemoveableDriveInfoNT ( pInstance, pszName , t_MediaPresent, dwProperties );
#endif
    DWORD dwResult = 0 ;

	// Get Expensive properties now if appropriate.
	if ( t_MediaPresent &&
	     ( dwProperties & LD_GET_VOL_INFO ) )
	{
		dwResult = GetDriveVolumeInformation ( pInstance, pszName );
    }

    if (t_MediaPresent && dwResult == 0)
    {
        if ( dwProperties &
            (LD_Size_BIT |
             LD_FreeSpace_BIT) )
		{
		    GetDriveFreeSpace ( pInstance , pszName ) ;
	    }
    }

}

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::GetRemoveableDriveInfoNT
 *
 *  DESCRIPTION : Retrieves property values for removeable drive
 *
 *  INPUTS      : char*		pszName - Name of Drive to get info for.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Performs operation using DeviceIoControl in NT
 *
 *****************************************************************************/

#ifdef NTONLY
void LogicalDisk :: GetRemoveableDriveInfoNT (

	CInstance *pInstance,
	LPCTSTR pszName ,
	BOOL &a_MediaPresent,
    DWORD dwProperties
)
{
    // we have this set globally at system startup time.
    // SOMETHING is stepping on it on NT 3.51 *only*  This suggests
    // that a DLL we load is turning it off.
    if ( IsWinNT351 () )
    {
        UINT oldErrorMode = SetErrorMode ( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX ) ;
        SetErrorMode ( oldErrorMode | SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX ) ;
    }

	// Convert the drive letter to a number (the indeces are 1 based)

	int nDrive = ( toupper(*pszName) - 'A' ) + 1;

	// The following code was lifted from Knowledge Base Article
	// Q163920.  The code uses DeviceIoControl to discover the
	// type of drive we are dealing with.

	TCHAR szDriveName[8];
	wsprintf(szDriveName, TEXT("\\\\.\\%c:"), TEXT('@') + nDrive);

	SmartCloseHandle hVMWIN32 = CreateFile (

		szDriveName,
		FILE_ANY_ACCESS,
		FILE_SHARE_WRITE | FILE_SHARE_READ,
		0,
		OPEN_EXISTING,
		0,
		0
	);

	if ( hVMWIN32 != INVALID_HANDLE_VALUE )
	{

/*
 * Verify media present
 */
        if (dwProperties & LD_SPIN_DISK)
        {
		    DWORD t_BytesReturned ;
		    a_MediaPresent = DeviceIoControl (

			    hVMWIN32,
			    IOCTL_STORAGE_CHECK_VERIFY2 ,
			    NULL,
			    0,
			    NULL,
			    0,
			    &t_BytesReturned,
			    0
		    ) ;

            if (!a_MediaPresent)
            {
		        DWORD t_GetLastError = GetLastError () ;
		        if ( t_GetLastError != ERROR_NOT_READY )
		        {
			        LogErrorMessage2(L"Device IO control returned unexpected error for Check verify: (%d)", t_GetLastError);
		        }
            }
        }
        else
        {
            a_MediaPresent = FALSE;
        }

/*
 * Get media types
 */

		DISK_GEOMETRY Geom[20];
		DWORD cb ;

		BOOL t_Status = DeviceIoControl (

			hVMWIN32,
			IOCTL_DISK_GET_MEDIA_TYPES,
			0,
			0,
			Geom,
			sizeof(Geom),
			&cb,
			0
		) ;

		if ( t_Status && cb > 0 )
		{
			int nGeometries = cb / sizeof(DISK_GEOMETRY) ;
			BOOL bFound = FALSE ;

			// Go through all geometries.  If we find any 3.5 ones,
			// put it in Geom[0].  This seems to happen on PC-98s.

			for ( int i = 0; i < nGeometries && ! bFound; i++ )
			{
				switch ( Geom [ i ].MediaType )
				{
					// Found something 'higher' than a 5.25 drive, so
					// move it into Geom[0] and get out.

					case RemovableMedia:
					case F3_1Pt44_512: // 3.5 1.44MB floppy
					case F3_2Pt88_512: // 3.5 2.88MB floppy
					case F3_20Pt8_512: // 3.5 20.8MB floppy
					case F3_720_512:   // 3.5 720K   floppy
					case F3_120M_512:  // 3.5 120MB  floppy
					{
						Geom[0].MediaType = Geom[i].MediaType ;

						bFound = TRUE;
					}
					break;

					default:
					{
					}
					break;
				}
			}

			pInstance->SetDWORD ( IDS_MediaType , Geom[0].MediaType ) ;

            CHString sTemp2;

			switch ( Geom [ 0 ].MediaType )
			{
				case F5_1Pt2_512: // 5.25 1.2MB floppy
				case F5_360_512:  // 5.25 360K  floppy
				case F5_320_512:  // 5.25 320K  floppy
				case F5_320_1024: // 5.25 320K  floppy
				case F5_180_512:  // 5.25 180K  floppy
				case F5_160_512:  // 5.25 160K  floppy
				{
                    LoadStringW(sTemp2, IDR_525Floppy);

				}
				break;

				case F3_1Pt44_512: // 3.5 1.44MB floppy
				case F3_2Pt88_512: // 3.5 2.88MB floppy
				case F3_20Pt8_512: // 3.5 20.8MB floppy
				case F3_720_512:   // 3.5 720K   floppy
				case F3_120M_512:  // 3.5 120MB  floppy
				{
                    LoadStringW(sTemp2, IDR_350Floppy);
				}
				break;

				default: // unknown already defaulted to "Removeable Disk"
				{
				}
				break;
			}

		    pInstance->SetCHString(IDS_Description, sTemp2);
		}
	}
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::GetRemoteDriveInfo
 *
 *  DESCRIPTION : Retrieves property values for remote logical drives
 *
 *  INPUTS      : char*		pszName - Name of Drive to get info for.
 *					BOOL	fGetExpensiveProperties - Exp. Properties flag.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void LogicalDisk::GetRemoteDriveInfo (

	CInstance *pInstance,
	LPCTSTR pszName,
	DWORD dwProperties
)
{
	CMprApi *t_MprApi = ( CMprApi * )CResourceManager::sm_TheResourceManager.GetResource ( g_guidMprApi, NULL ) ;
	if ( t_MprApi )
	{
		pInstance->SetDWORD ( IDS_MediaType , Unknown ) ;

        CHString sTemp2;

        LoadStringW(sTemp2, IDR_NetworkConnection);
		pInstance->SetCHString ( IDS_Description , sTemp2 ) ;

		// Get Expensive properties now if appropriate.
	    if ( dwProperties &
                (LD_SPIN_DISK |
                LD_ProviderName_BIT) )
	    {
			if ( dwProperties & LD_ProviderName_BIT )
			{
				// Enumerate network resources to identify this drive's share
				//===========================================================

				// The enumeration will return drives identified by Drive Letter
				// and a colon (e.g. M:)

				TCHAR szTempDrive[_MAX_PATH] ;
				_stprintf(szTempDrive, _T("%c%c"), pszName[0], pszName[1]) ;

				TCHAR szProvName[_MAX_PATH];
				DWORD dwProvName = sizeof ( szProvName ) ;

				DWORD dwRetCode = t_MprApi->WNetGetConnection ( szTempDrive , szProvName , & dwProvName ) ;
				if (dwRetCode == NO_ERROR)
				{
					pInstance->SetCharSplat ( IDS_ProviderName , szProvName ) ;
				}
				else
				{
					dwRetCode = GetLastError();

					if ( ( dwRetCode == ERROR_MORE_DATA ) && (dwProvName > _MAX_PATH ) )
					{
						TCHAR *szNewProvName = new TCHAR[dwProvName];
						if (szNewProvName != NULL)
						{
							try
							{
								dwRetCode = t_MprApi->WNetGetConnection ( szTempDrive , szNewProvName , &dwProvName);
								if (dwRetCode == NO_ERROR)
								{
									pInstance->SetCharSplat(IDS_ProviderName, szNewProvName);
								}
							}
							catch ( ... )
							{
								delete [] szNewProvName ;

								throw ;
							}

							delete [] szNewProvName ;
						}
						else
						{
							throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
						}

					}
				}
			}

			DWORD dwResult = 0 ;

			// Get Expensive properties now if appropriate.

            if ( dwProperties & LD_GET_VOL_INFO )
			{
				// Obtain volume information
				dwResult = GetDriveVolumeInformation ( pInstance, pszName );
			}

			if ( dwResult == 0 )
			{
				if ( dwProperties &
					(LD_Size_BIT |
						LD_FreeSpace_BIT) )
				{
					GetDriveFreeSpace ( pInstance , pszName );
				}
			}
		}

		CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidMprApi , t_MprApi ) ;
	}
}

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::GetCDROMDriveInfo
 *
 *  DESCRIPTION : Retrieves property values for CD-ROM logical drive
 *
 *  INPUTS      : char*		pszName - Name of Drive to get info for.
 *					BOOL	fGetExpensiveProperties - Exp. Properties flag.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void LogicalDisk :: GetCDROMDriveInfo (

	CInstance *pInstance,
	LPCTSTR pszName,
	DWORD dwProperties
)
{
    CHString sTemp2;

    LoadStringW(sTemp2, IDR_CDRomDisk);

    pInstance->SetCHString ( IDS_Description , sTemp2 ) ;
    pInstance->SetDWORD ( IDS_MediaType , RemovableMedia ) ;

	// Get Expensive properties now if appropriate.

	BOOL t_MediaPresent = FALSE ;
#ifdef NTONLY
	GetCDROMDriveInfoNT ( pInstance, pszName , t_MediaPresent, dwProperties );
#endif
    DWORD dwResult = 0 ;

	if ( t_MediaPresent &&
        ( dwProperties &  LD_GET_VOL_INFO ) )
    {
		// Obtain volume information
		dwResult = GetDriveVolumeInformation ( pInstance , pszName ) ;
    }

    if ( t_MediaPresent && dwResult == 0 )
    {
        if ( dwProperties &
            (LD_Size_BIT |
             LD_FreeSpace_BIT) )
		{
		    GetDriveFreeSpace(pInstance, pszName );
	    }
    }
}

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::GetCDROMDriveInfoNT
 *
 *  DESCRIPTION : Retrieves property values for CDROM drive
 *
 *  INPUTS      : char*		pszName - Name of Drive to get info for.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Performs operation using DeviceIoControl in NT
 *
 *****************************************************************************/

#ifdef NTONLY
void LogicalDisk :: GetCDROMDriveInfoNT (

	CInstance *pInstance,
	LPCTSTR pszName ,
	BOOL &a_MediaPresent,
    DWORD dwProperties
)
{
    // we have this set globally at system startup time.
    // SOMETHING is stepping on it on NT 3.51 *only*  This suggests
    // that a DLL we load is turning it off.
    if ( IsWinNT351 () )
    {
        UINT oldErrorMode = SetErrorMode ( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX ) ;
        SetErrorMode ( oldErrorMode | SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX ) ;
    }

	// Convert the drive letter to a number (the indeces are 1 based)

	int nDrive = ( toupper(*pszName) - 'A' ) + 1;

	// The following code was lifted from Knowledge Base Article
	// Q163920.  The code uses DeviceIoControl to discover the
	// type of drive we are dealing with.

	TCHAR szDriveName[8];
	wsprintf(szDriveName, TEXT("\\\\.\\%c:"), TEXT('@') + nDrive);

	SmartCloseHandle hVMWIN32 = CreateFile (

		szDriveName,
		FILE_ANY_ACCESS,
		FILE_SHARE_WRITE | FILE_SHARE_READ,
		0,
		OPEN_EXISTING,
		0,
		0
	);

	if ( hVMWIN32 != INVALID_HANDLE_VALUE )
	{

/*
 * Verify media present
 */
        if (dwProperties & LD_SPIN_DISK)
        {
    		DWORD t_BytesReturned ;
		    a_MediaPresent = DeviceIoControl (

			    hVMWIN32,
			    IOCTL_STORAGE_CHECK_VERIFY2 ,
			    NULL,
			    0,
			    NULL,
			    0,
			    &t_BytesReturned,
			    0
		    ) ;

            if (!a_MediaPresent)
            {
		        DWORD t_GetLastError = GetLastError () ;
		        if ( t_GetLastError != ERROR_NOT_READY )
		        {
			        LogErrorMessage2(L"Device IO control returned unexpected error for Check verify: (%d)", t_GetLastError);
		        }
            }
        }
        else
        {
            a_MediaPresent = FALSE;
        }
	}
	else
	{
		a_MediaPresent = GetLastError() == ERROR_ACCESS_DENIED;
	}
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::GetCDROMDriveInfo95
 *
 *  DESCRIPTION : Retrieves property values for CDROM drive
 *
 *  INPUTS      : char*		pszName - Name of Drive to get info for.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Performs operation using DeviceIoControl in NT
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::GetRAMDriveInfo
 *
 *  DESCRIPTION : Retrieves property values for RAM drives
 *
 *  INPUTS      : char*		pszName - Name of Drive to get info for.
 *					BOOL	fGetExpensiveProperties - Exp. Properties flag.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void LogicalDisk :: GetRAMDriveInfo (

	CInstance *pInstance,
	LPCTSTR pszName,
	DWORD dwProperties
)
{
    CHString sTemp2;

    LoadStringW(sTemp2, IDR_RAMDisk);

    pInstance->SetCHString ( IDS_Description , sTemp2 ) ;
    pInstance->SetDWORD ( IDS_MediaType , Unknown ) ;

    DWORD dwResult = 0 ;

	// Get Expensive properties now if appropriate.
	if ( dwProperties & LD_GET_VOL_INFO )
	{
		// Obtain volume information
		dwResult = GetDriveVolumeInformation ( pInstance , pszName ) ;
    }

    if ( dwResult == 0 )
    {
        if ( dwProperties &
            (LD_Size_BIT |
             LD_FreeSpace_BIT) )
		{
		    GetDriveFreeSpace ( pInstance , pszName ) ;
	    }
    }
}

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::GetDriveVolumeInformation
 *
 *  DESCRIPTION : Retrieves property values for fixed-media logical disk
 *
 *  INPUTS      : const char*	pszName - Name of volume to retrieve
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : BOOL			TRUE/FALSE - Able/Unable to perform
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

DWORD LogicalDisk :: GetDriveVolumeInformation (

	CInstance *pInstance,
	LPCTSTR pszName
)
{
#ifdef NTONLY

    // we have this set globally at system startup time.
    // SOMETHING is stepping on it on NT 3.51 *only*  This suggests
    // that a DLL we load is turning it off.

    if ( IsWinNT351 () )
    {
        UINT oldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);
        SetErrorMode(oldErrorMode | SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);
    }

#endif

	DWORD dwReturn = 0 ;

	TCHAR szVolumeName[_MAX_PATH] ;
	TCHAR szFileSystem[_MAX_PATH] ;

    DWORD dwSerialNumber ;
	DWORD dwMaxComponentLength ;
	DWORD dwFSFlags ;

	BOOL fReturn = GetVolumeInformation (

		pszName,
		szVolumeName,
		sizeof(szVolumeName)/sizeof(TCHAR),
		&dwSerialNumber,
		&dwMaxComponentLength,
		&dwFSFlags,
		szFileSystem,
		sizeof(szFileSystem)/sizeof(TCHAR)
	) ;

    if ( fReturn )
	{
	// Win32 API will return volume information for all drive types.

        pInstance->SetCharSplat ( IDS_VolumeName , szVolumeName ) ;
        pInstance->SetCharSplat ( IDS_FileSystem , szFileSystem ) ;

        // Per raid 50801
        if (dwSerialNumber != 0)
        {
	        TCHAR szTemp[_MAX_PATH] ;
            _stprintf(szTemp, _T("%.8X"), dwSerialNumber) ;

            pInstance->SetCharSplat ( IDS_VolumeSerialNumber , szTemp ) ;
        }

		pInstance->Setbool ( IDS_Compressed , dwFSFlags & FS_VOL_IS_COMPRESSED ) ;
        pInstance->Setbool ( IDS_SupportsFileBasedCompression , dwFSFlags & FS_FILE_COMPRESSION ) ;
		pInstance->SetDWORD ( IDS_MaximumComponentLength , dwMaxComponentLength ) ;


#if NTONLY == 5

		pInstance->Setbool ( IDS_SupportsDiskQuotas,  dwFSFlags & FILE_VOLUME_QUOTAS ) ;

		IDiskQuotaControlPtr pIQuotaControl;

		// Here Get the State of the volume, we need to get the Interface pointer.
		if (  SUCCEEDED ( CoCreateInstance(
												CLSID_DiskQuotaControl,
												NULL,
												CLSCTX_INPROC_SERVER,
												IID_IDiskQuotaControl,
												(void **)&pIQuotaControl ) ) )
		{
			CHString t_VolumeName;
			HRESULT hRes = WBEM_S_NO_ERROR;
			pInstance->GetCHString ( IDS_DeviceID, t_VolumeName );

			WCHAR w_VolumePathName [ MAX_PATH + 1 ];

			BOOL bRetVal = GetVolumePathName(
									t_VolumeName.GetBuffer ( 0 ),           // file path
									w_VolumePathName,     // volume mount point
									MAX_PATH		  // Size of the Buffer
							 );
			if ( bRetVal )
			{
				if ( SUCCEEDED ( pIQuotaControl->Initialize (  w_VolumePathName, TRUE ) ) )
				{
					DWORD dwQuotaState;
					hRes = pIQuotaControl->GetQuotaState( &dwQuotaState );

					if ( SUCCEEDED ( hRes ) )
					{
						pInstance->Setbool ( IDS_QuotasIncomplete,  DISKQUOTA_FILE_INCOMPLETE ( dwQuotaState) ) ;
					
						pInstance->Setbool ( IDS_QuotasRebuilding,  DISKQUOTA_FILE_REBUILDING ( dwQuotaState) ) ;
				
						pInstance->Setbool ( IDS_QuotasDisabled,  DISKQUOTA_IS_DISABLED (dwQuotaState) );
					}
					else
					{
						dwReturn = GetLastError () ;
					}
				}
			}
		}
		else
		{
			dwReturn = GetLastError () ;
		}

#endif // NTONLY == 5

#ifdef NTONLY 

// for chkdsk VolumeDirty Property
	BOOLEAN bVolumeDirty = FALSE;
	BOOL bSuccess = FALSE;

	CHString t_DosDrive ( pszName );
	UNICODE_STRING string = { 0 };

    try
    {
	    if(RtlDosPathNameToNtPathName_U ( t_DosDrive .GetBuffer( 0 ), &string, NULL, NULL ) &&
            string.Buffer)
        {	    
            string.Buffer[string.Length/sizeof(WCHAR) - 1] = 0;
	        CHString nt_drive_name ( string.Buffer);

	        bSuccess = IsVolumeDirty ( nt_drive_name, &bVolumeDirty );

	        if ( bSuccess )
	        {
 		        pInstance->Setbool ( IDS_VolumeDirty,  bVolumeDirty);
	        }

            RtlFreeUnicodeString(&string);
            string.Buffer = NULL;
        }
        else
        {
            dwReturn = -1L;
        }
    }
    catch(...)
    {
        if(string.Buffer)
        {
            RtlFreeUnicodeString(&string);
            string.Buffer = NULL;
        }
        throw;
    }

#endif

    }
    else
    {
        dwReturn = GetLastError () ;
    }

    return dwReturn ;
}

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::GetDriveFreeSpace
 *
 *  DESCRIPTION : Retrieves Space Information for the specified Drive.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : BOOL		TRUE/FALSE - Able/Unable to perform
 *
 *  COMMENTS    : Uses GetDiskFreeSpaceEx if available.
 *
 *****************************************************************************/

BOOL LogicalDisk :: GetDriveFreeSpace (

	CInstance *pInstance,
	LPCTSTR pszName
)
{
	BOOL fReturn = FALSE ;

    // See if GetDiskFreeSpaceEx() is supported
    //=========================================

    CKernel32Api *pKernel32 = (CKernel32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidKernel32Api, NULL);
    if ( pKernel32 != NULL )
    {
		try
		{
			BOOL fRetval = FALSE;

			ULARGE_INTEGER uliTotalBytes ;
			ULARGE_INTEGER uliUserFreeBytes ;
			ULARGE_INTEGER uliTotalFreeBytes ;

			if ( pKernel32->GetDiskFreeSpaceEx ( pszName, &uliUserFreeBytes, &uliTotalBytes, & uliTotalFreeBytes, & fRetval ) )
			{
				if ( fRetval )
				{
					fReturn = TRUE ;

					pInstance->SetWBEMINT64(IDS_Size, uliTotalBytes.QuadPart);
					pInstance->SetWBEMINT64(IDS_FreeSpace, uliTotalFreeBytes.QuadPart);
				}
				else
				{
					// If we couldn't get extended info -- use old API
					// (known to be inaccurate on Win95 for >2G drives)
					//=================================================

					DWORD x = GetLastError();

					DWORD dwBytesPerSector ;
					DWORD dwSectorsPerCluster ;
					DWORD dwFreeClusters ;
					DWORD dwTotalClusters ;

					BOOL t_Status = GetDiskFreeSpace (

						pszName,
						&dwSectorsPerCluster,
						&dwBytesPerSector,
						&dwFreeClusters,
						&dwTotalClusters
					) ;

					if ( t_Status )
					{
						fReturn = TRUE ;

						__int64	i64Temp = (__int64) dwTotalClusters *
										(__int64) dwSectorsPerCluster *
										(__int64) dwBytesPerSector ;

						pInstance->SetWBEMINT64(IDS_Size, i64Temp);

						i64Temp = (__int64) dwFreeClusters *
								  (__int64) dwSectorsPerCluster *
								  (__int64) dwBytesPerSector ;

						pInstance->SetWBEMINT64( IDS_FreeSpace , i64Temp ) ;
					}
					else
					{
						DWORD x = GetLastError () ;

						fReturn = FALSE ;
					}
				}
			}
		}
		catch ( ... )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidKernel32Api, pKernel32);

			throw ;
		}

        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidKernel32Api, pKernel32);
    }

    return fReturn;
}

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::PutInstance
 *
 *  DESCRIPTION : Write changed instance
 *
 *  INPUTS      : pInstance to store data from
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT LogicalDisk :: PutInstance (

	const CInstance &pInstance,
	long lFlags /*= 0L*/
)
{
    // Tell the user we can't create a new logicaldisk (much as we might like to)

    if ( lFlags & WBEM_FLAG_CREATE_ONLY )
    {
	    return WBEM_E_UNSUPPORTED_PARAMETER ;
    }


    HRESULT hRet = WBEM_E_FAILED ;

    // See if we got a name we can recognize

    if ( ! pInstance.IsNull ( IDS_DeviceID ) )
    {
		CHString sName ;
	    pInstance.GetCHString ( IDS_DeviceID , sName ) ;
	    DWORD dwFind = sName.Find (':');

	    // Check for bad drive names

	    if ( ( dwFind == -1 ) || (dwFind != sName.GetLength () - 1 ) )
	    {
		    hRet = WBEM_E_INVALID_PARAMETER ;
	    }
	    else
	    {
		    sName = sName.Left(dwFind + 1);
		    sName += '\\';

		    DWORD dwDriveType = GetDriveType ( TOBSTRT(sName) ) ;
		    if ( ( dwDriveType == DRIVE_UNKNOWN ) || ( dwDriveType == DRIVE_NO_ROOT_DIR ) )
		    {
			    if ( lFlags & WBEM_FLAG_UPDATE_ONLY )
			    {
			        hRet = WBEM_E_NOT_FOUND ;
			    }
			    else
			    {
			        hRet = WBEM_E_UNSUPPORTED_PARAMETER;
			    }
		    }
		    else
		    {

			    hRet = WBEM_S_NO_ERROR;

			    if ( ! pInstance.IsNull ( IDS_VolumeName ) )
			    {
					CHString sVolume ;
			        pInstance.GetCHString ( IDS_VolumeName , sVolume ) ;

                    {
			            if ( SetVolumeLabel ( TOBSTRT(sName), TOBSTRT(sVolume) ) )
			            {
				            hRet = WBEM_NO_ERROR ;
			            }
			            else
			            {
                            DWORD dwLastError = GetLastError();

				            if ( dwLastError == ERROR_ACCESS_DENIED )
                            {
                                hRet = WBEM_E_ACCESS_DENIED;
                            }
                            else
                            {
                                hRet = dwLastError | 0x80000000;
                            }
                        }
                    }
                }
            }
        }
    }
    else
    {
	    hRet = WBEM_E_ILLEGAL_NULL ;
    }

    return hRet;
}

#ifdef NTONLY

/*****************************************************************************
*
*  FUNCTION    :    LogicalDisk::IsVolumeDirty
*
*  DESCRIPTION :    This routine opens the given nt drive and sends down
*					FSCTL_IS_VOLUME_DIRTY to determine the state of that volume's
*					dirty bit. 
*
*****************************************************************************/
BOOLEAN LogicalDisk::IsVolumeDirty(
    IN  CHString    &NtDriveName,
    OUT BOOLEAN     *Result
)
{
    UNICODE_STRING      u;
    OBJECT_ATTRIBUTES   obj;
    NTSTATUS            t_status;
    IO_STATUS_BLOCK     iosb;
    HANDLE              h = NULL;
    ULONG               r = 0;
	BOOLEAN				bRetVal = FALSE;

    u.Length = (USHORT) NtDriveName.GetLength() * sizeof(WCHAR);
    u.MaximumLength = u.Length;
    u.Buffer = NtDriveName.GetBuffer( 0 );

    InitializeObjectAttributes(&obj, &u, OBJ_CASE_INSENSITIVE, 0, 0);

    t_status = NtOpenFile(&h,
                        FILE_WRITE_ATTRIBUTES | SYNCHRONIZE ,
                        &obj,
                        &iosb,
                        FILE_SHARE_READ|FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT);

    if ( NT_SUCCESS(t_status)) 
	{
		try
		{
			t_status = NtFsControlFile(h, NULL, NULL, NULL,
									 &iosb,
									 FSCTL_IS_VOLUME_DIRTY,
									 NULL, 0,
									 &r, sizeof(r));

			if ( NT_SUCCESS(t_status)) 
			{

#if(_WIN32_WINNT >= 0x0500)
				*Result = (BOOLEAN)(r & VOLUME_IS_DIRTY);
#else
				*Result = (BOOLEAN)r;
#endif
				bRetVal = TRUE;
			}
		}
		catch(...)
		{
			NtClose(h);
			h = NULL;
			throw;
		}

		NtClose(h);
		h = NULL;
	}
	
	return bRetVal;
}


/*****************************************************************************
*
*  FUNCTION    :    LogicalDisk::ExecChkDsk
*
*  DESCRIPTION :    This methods checks the disk, and if disk is locked 
*					Schedules it for autocheck on reboot, if requested by 
*					the user, by default it will not be scheduled for autocheck
*					unless specified by the user.
*
*****************************************************************************/
HRESULT LogicalDisk :: ExecChkDsk (

	const CInstance& a_Instance, 
	CInstance *a_InParams, 
	CInstance *a_OutParams,
	long lFlags 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR ;

	DWORD dwThreadId = GetCurrentThreadId();

	hRes = a_InParams && a_OutParams ? hRes : WBEM_E_INVALID_PARAMETER;
	UINT unRetVal = 0;

	mReturnVal [ dwThreadId ] = unRetVal;

	if ( SUCCEEDED ( hRes ) )
	{
		// Get the drivename from the instance which is the key of the Logical DIsk
		CHString t_DriveName;

		hRes = a_Instance.GetCHString ( IDS_DeviceID, t_DriveName ) ? hRes : WBEM_E_PROVIDER_FAILURE;

		if ( SUCCEEDED ( hRes ) )
		{
			// checking for the validity of the drive on whick checkdsk can be performed
			DWORD dwDriveType = GetDriveType ( t_DriveName );

			if ( unRetVal == 0 )
			{
				hRes = CheckParameters ( a_InParams );

				if ( SUCCEEDED ( hRes ) )
				{
					// now check for the file system type, since chkdsk is applicable only for 
					// NTFS/FAT volumes by loading the fmifs.dll which exposes a chkdsk method
					HINSTANCE hDLL = NULL;  
					QUERYFILESYSTEMNAME QueryFileSystemName = NULL;
					FMIFS_CALLBACK CallBackRoutine = NULL;

					hDLL = LoadLibrary( L"fmifs.dll" );

					if (hDLL != NULL)
					{
						try
						{
						   QueryFileSystemName =  (QUERYFILESYSTEMNAME)GetProcAddress(hDLL, "QueryFileSystemName");

						   if ( QueryFileSystemName )
						   {
								CHString t_FileSystemName; 
								unsigned char MajorVersion;
								unsigned char MinorVersion;
								LONG ExitStatus;
			
								if ( QueryFileSystemName ( 
											t_DriveName.GetBuffer ( 0 ), 
											t_FileSystemName.GetBuffer ( _MAX_PATH + 1 ), 
											&MajorVersion, 
											&MinorVersion, 
											&ExitStatus ) )
								{
									// we need to check for the Filesystem
									if ( ( t_FileSystemName.CompareNoCase ( L"FAT" ) == 0 ) || ( t_FileSystemName.CompareNoCase ( L"FAT32" ) == 0 ) || ( t_FileSystemName.CompareNoCase ( L"NTFS" )  == 0) )
									{
										bool bFixErrors = false;
										bool bVigorousIndexCheck = false;
										bool bSkipFolderCycle = false;
										bool bForceDismount = false;
										bool bRecoverBadSectors = false;
										bool bCheckAtBootUp = false;

										// Get all the parameters from the instance here;
										a_InParams->Getbool ( METHOD_ARG_NAME_FIXERRORS, bFixErrors );
										a_InParams->Getbool ( METHOD_ARG_NAME_VIGOROUSINDEXCHECK, bVigorousIndexCheck );
										a_InParams->Getbool ( METHOD_ARG_NAME_SKIPFOLDERCYCLE, bSkipFolderCycle );
										a_InParams->Getbool ( METHOD_ARG_NAME_FORCEDISMOUNT, bForceDismount );
										a_InParams->Getbool ( METHOD_ARG_NAME_RECOVERBADSECTORS, bRecoverBadSectors );
										a_InParams->Getbool ( METHOD_ARG_NAME_CHKDSKATBOOTUP, bCheckAtBootUp );

										// Set the parameters for making a call to chkdsk here
										PFMIFS_CHKDSKEX_ROUTINE ChkDskExRoutine = NULL;

										ChkDskExRoutine = ( PFMIFS_CHKDSKEX_ROUTINE ) GetProcAddress( hDLL,  "ChkdskEx" );

										if ( ChkDskExRoutine != NULL )
										{
											if ( bCheckAtBootUp )
											{
												CallBackRoutine = ScheduleAutoChkIfLocked;
											}
											else
											{
												CallBackRoutine = DontScheduleAutoChkIfLocked;
											}
											FMIFS_CHKDSKEX_PARAM Param;

											Param.Major = 1;
											Param.Minor = 0;
											Param.Flags = 0;  // For the Verbose Flag
											Param.Flags |= bRecoverBadSectors ? FMIFS_CHKDSK_RECOVER : 0;
											Param.Flags |= bForceDismount ? FMIFS_CHKDSK_FORCE : 0;
											Param.Flags |= bVigorousIndexCheck ? FMIFS_CHKDSK_SKIP_INDEX_SCAN : 0;
											Param.Flags |= bSkipFolderCycle ? FMIFS_CHKDSK_SKIP_CYCLE_SCAN : 0;

                                            if (bRecoverBadSectors || bForceDismount)
                                            {
                                                bFixErrors = true;
                                            }
						
											ChkDskExRoutine ( 
												t_DriveName.GetBuffer ( 0 ),
												t_FileSystemName.GetBuffer ( 0 ),
												bFixErrors,
												&Param,
												CallBackRoutine
											);
										}
										else
										{
											hRes = WBEM_E_FAILED;
										}
									}
									else
									{
										mReturnVal [ dwThreadId ] = CHKDSK_UNSUPPORTED_FS;
									}
								}
								else
								{
									t_FileSystemName.ReleaseBuffer () ;
									if ( ! t_FileSystemName.IsEmpty () )
									{
										mReturnVal [ dwThreadId ] = CHKDSK_UNSUPPORTED_FS;
									}
									else
									{
										mReturnVal [ dwThreadId ] = CHKDSK_UNKNOWN_FS;
									}
								}
						   }
					   	}
						catch ( ... )
						{
							FreeLibrary(hDLL);  
							throw;
						}
						FreeLibrary(hDLL);  
					 }
					 else
					 {
						hRes = WBEM_E_FAILED;
					 }
				}
			}		
		}
	}
	// need to set the return value;
	if ( SUCCEEDED ( hRes ) )
	{
		a_OutParams->SetWORD ( METHOD_ARG_NAME_RETURNVALUE, mReturnVal [ dwThreadId ] ) ;
		//Initialize/Delete the valuemap entry for this thread 
		mReturnVal [ dwThreadId ] = 0;
	}
	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    LogicalDisk::ExecExcludeFromChkDsk
*
*  DESCRIPTION :    This method makes a chknts exe call to exclude the 
*					for autocheck on reboot
*
*****************************************************************************/
HRESULT LogicalDisk::ExecExcludeFromChkDsk(

	CInstance *a_InParams, 
	CInstance *a_OutParams,
	long lFlags 			
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
    CHString t_ChkNtFsCommand;
	DWORD dwRetVal = 0;

	// C for Schedule for autocheck on reboot
	hRes = GetChkNtfsCommand ( a_InParams, a_OutParams, L'X', t_ChkNtFsCommand, dwRetVal );

	// Making a call to execute an Chkntfs exe
	if ( SUCCEEDED ( hRes ) && ( dwRetVal == CHKDSKERR_NOERROR ) ) 
	{
		hRes = ExecuteCommand ( t_ChkNtFsCommand );
		if ( ( (HRESULT_FACILITY(hRes) == FACILITY_WIN32) ? HRESULT_CODE(hRes) : (hRes) ) == ERROR_ACCESS_DENIED )
		{
			hRes = WBEM_E_ACCESS_DENIED ;
		}
	}

	a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , dwRetVal );
	
	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    LogicalDisk::ExecScheduleChkdsk
*
*  DESCRIPTION :    This method makes a chknts exe call to Schedule drives 
*					for autocheck on reboot
*
*****************************************************************************/
HRESULT LogicalDisk::ExecScheduleChkdsk(
		
	CInstance *a_InParams, 
	CInstance *a_OutParams, 
	long lFlags 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
    CHString t_ChkNtFsCommand;
	DWORD dwRetVal = NOERROR;

	// C for Exclude for autocheck on reboot
	hRes = GetChkNtfsCommand ( a_InParams, a_OutParams, L'C', t_ChkNtFsCommand, dwRetVal );

	// Making a call to execute an Chkntfs exe
	if ( SUCCEEDED ( hRes ) && ( dwRetVal == CHKDSKERR_NOERROR ) )
	{
		hRes = ExecuteCommand ( t_ChkNtFsCommand );
		if ( ( (HRESULT_FACILITY(hRes) == FACILITY_WIN32) ? HRESULT_CODE(hRes) : (hRes) ) == ERROR_ACCESS_DENIED )
		{
			hRes = WBEM_E_ACCESS_DENIED ;
		}
    }

    a_OutParams->SetWORD ( METHOD_ARG_NAME_RETURNVALUE , dwRetVal );

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    LogicalDisk::GetChkNtfsCommand
*
*  DESCRIPTION :    This method gets an array of input drives checks if chkntfs
*					can be applied to them and puts it in the form of the ChkNtfs 
*					System command, based on the chk mode, either schedule or 
*					Exclude.
*
*****************************************************************************/

HRESULT LogicalDisk :: GetChkNtfsCommand ( 

	CInstance *a_InParams, 
	CInstance *a_OutParams, 
	WCHAR w_Mode, 
	CHString &a_ChkNtfsCommand,
	DWORD & dwRetVal
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	SAFEARRAY *t_paDrives;
	dwRetVal = CHKDSKERR_DRIVE_REMOVABLE;

	a_ChkNtfsCommand.Format ( L"%s%s%c", CHKNTFS, L" /", w_Mode );

	if ( a_InParams->GetStringArray ( METHOD_ARG_NAME_LOGICALDISKARRAY, t_paDrives ) == FALSE )
	{
		hRes = WBEM_E_INVALID_PARAMETER;
	}

	if ( SUCCEEDED ( hRes ) )
	{
		try
		{
			UINT unDim = SafeArrayGetDim( t_paDrives );

			if ( unDim != 1 )
			{
				hRes = WBEM_E_INVALID_PARAMETER;
			}

			if ( SUCCEEDED ( hRes ) )
			{
				LONG lLbound;
				LONG lUbound;

				hRes = SafeArrayGetLBound( t_paDrives, unDim, &lLbound );

				if ( SUCCEEDED ( hRes ) )
				{
					hRes = SafeArrayGetUBound( t_paDrives, unDim, &lUbound );

					if ( SUCCEEDED ( hRes ) )
					{
						BSTR bstrElement;

						for ( LONG lLbound = 0; lLbound <= lUbound; lLbound++ )
						{
							// getting the drives and putting them in command form
							hRes = SafeArrayGetElement ( t_paDrives, &lLbound , &bstrElement );

							if ( SUCCEEDED ( hRes ) )
							{
								DWORD dwElementLen = SysStringLen ( bstrElement );
								if ( dwElementLen == 2 )
								{
									DWORD dwDriveType;
									CHString t_Drive ( bstrElement );
									dwDriveType = GetDriveType ( TOBSTRT ( t_Drive ) );

                                    switch (dwDriveType)
                                    {
                                        case DRIVE_REMOTE:
                                        {
                                            dwRetVal =  CHKDSKERR_REMOTE_DRIVE;
                                            break;
                                        }

                                        case DRIVE_REMOVABLE:
                                        {
    										dwRetVal = CHKDSKERR_DRIVE_REMOVABLE;
                                            break;
                                        }

                                        case DRIVE_UNKNOWN:
									    {
										    dwRetVal = CHKDSKERR_DRIVE_UNKNOWN;
                                            break;
									    }

                                        case DRIVE_NO_ROOT_DIR:
									    {
										    dwRetVal = CHKDSKERR_DRIVE_NO_ROOT_DIR ;
                                            break;
									    }

                                        case DRIVE_FIXED:
                                        {
                                            dwRetVal = CHKDSKERR_NOERROR;
                                            break;
                                        }

                                        default:
                                        {
                                            dwRetVal = CHKDSKERR_DRIVE_UNKNOWN;
                                            break;
                                        }
                                    }

                                    a_ChkNtfsCommand += L' ';
                                    a_ChkNtfsCommand += t_Drive;
								}
								else
								{
									hRes = WBEM_E_INVALID_PARAMETER;
									break;
								}	
							}
							else
							{
								hRes = WBEM_E_INVALID_PARAMETER;
								break;
							}
						}
					}
					else
					{
						hRes = WBEM_E_INVALID_PARAMETER;
					}
				}
				else
				{
					hRes = WBEM_E_INVALID_PARAMETER;
				}
			}
		}
		catch ( ... )
		{
			hRes = SafeArrayDestroy ( t_paDrives );
			throw;
		}
		if ( FAILED ( SafeArrayDestroy ( t_paDrives ) ) )
		{
			hRes = WBEM_E_FAILED;
		}	
	}
	return ( hRes );
}

/*****************************************************************************
*
*  FUNCTION    :    LogicalDisk::CheckParameters
*
*  DESCRIPTION :    This routine checks for the validity of the parameters
*					which are passed as parameters to ChkDsk Method
*
*****************************************************************************/
HRESULT LogicalDisk::CheckParameters ( 

	CInstance *a_InParams
)
{
	HRESULT hRes = WBEM_S_NO_ERROR ;

	if ( a_InParams == NULL )
	{
		hRes = WBEM_E_INVALID_PARAMETER;
	}

	if ( SUCCEEDED ( hRes ) )
	{
		VARTYPE t_Type ;
		bool t_Exists;
		
		if ( a_InParams->GetStatus ( METHOD_ARG_NAME_FIXERRORS , t_Exists , t_Type ) )
		{
			hRes = t_Exists && ( t_Type == VT_BOOL ) ? hRes : WBEM_E_INVALID_PARAMETER;
		}
		else
		{
			hRes  = WBEM_E_INVALID_PARAMETER ;
		}

		if ( SUCCEEDED ( hRes ) )
		{
			if ( a_InParams->GetStatus ( METHOD_ARG_NAME_VIGOROUSINDEXCHECK , t_Exists , t_Type ) )
			{
				hRes = t_Exists && ( t_Type == VT_BOOL ) ? hRes : WBEM_E_INVALID_PARAMETER;
			}
			else
			{
				hRes  = WBEM_E_INVALID_PARAMETER ;
			}
		}

		if ( SUCCEEDED ( hRes ) )
		{
			if ( a_InParams->GetStatus ( METHOD_ARG_NAME_SKIPFOLDERCYCLE , t_Exists , t_Type ) )
			{
				hRes = t_Exists && ( t_Type == VT_BOOL ) ? hRes : WBEM_E_INVALID_PARAMETER;
			}
			else
			{
				hRes  = WBEM_E_INVALID_PARAMETER ;
			}
		}

		if ( SUCCEEDED ( hRes ) )
		{
			if ( a_InParams->GetStatus ( METHOD_ARG_NAME_FORCEDISMOUNT , t_Exists , t_Type ) )
			{
				hRes = 	t_Exists && ( t_Type == VT_BOOL ) ? hRes : hRes  = WBEM_E_INVALID_PARAMETER ;
			}
			else
			{
				hRes  = WBEM_E_INVALID_PARAMETER ;
			}
		}

		if ( SUCCEEDED ( hRes ) )
		{
			if ( a_InParams->GetStatus ( METHOD_ARG_NAME_RECOVERBADSECTORS , t_Exists , t_Type ) )
			{
				hRes = t_Exists && ( t_Type == VT_BOOL ) ? hRes : WBEM_E_INVALID_PARAMETER;
			}
			else
			{
				hRes = WBEM_E_INVALID_PARAMETER ;
			}
		}

		if ( SUCCEEDED ( hRes ) )
		{
			if ( a_InParams->GetStatus ( METHOD_ARG_NAME_CHKDSKATBOOTUP , t_Exists , t_Type ) )
			{
				hRes = t_Exists && ( t_Type == VT_BOOL ) ? hRes : WBEM_E_INVALID_PARAMETER;
			}
			else
			{
				hRes = WBEM_E_INVALID_PARAMETER ;
			}
		}
	}

	return hRes;
}


/*****************************************************************************
*
*  FUNCTION    :    DontScheduleAutoChkIfLocked
*
*  DESCRIPTION :    A callback routine, which is passed as a parameter to chkdsk method
*					a method exposed via FMIFS.h chkdsk interface.
*
*****************************************************************************/
BOOLEAN	DontScheduleAutoChkIfLocked( 
	
	FMIFS_PACKET_TYPE PacketType, 
	ULONG	PacketLength,
	PVOID	PacketData
)
{
	DWORD dwThreadId = GetCurrentThreadId();

	if ( PacketType == FmIfsCheckOnReboot  )
	{
		FMIFS_CHECKONREBOOT_INFORMATION *RebootResult;
		mReturnVal [ dwThreadId ] = CHKDSK_VOLUME_LOCKED;
		RebootResult = (  FMIFS_CHECKONREBOOT_INFORMATION * ) PacketData;
		RebootResult->QueryResult = 0;
	}
	else
	{
		ProcessInformation ( PacketType, PacketLength, PacketData );
	}

	return TRUE;
}

/*****************************************************************************
*
*  FUNCTION    :    ScheduleAutoChkIfLocked
*
*  DESCRIPTION :    A callback routine, which is passed as a parameter to chkdsk method
*					a method exposed via FMIFS.h chkdsk interface.
*
*****************************************************************************/
BOOLEAN	ScheduleAutoChkIfLocked( 
	
	FMIFS_PACKET_TYPE PacketType, 
	ULONG	PacketLength,
	PVOID	PacketData
)
{
	DWORD dwThreadId = GetCurrentThreadId();

	if ( PacketType == FmIfsCheckOnReboot  )
	{
		FMIFS_CHECKONREBOOT_INFORMATION *RebootResult;
		mReturnVal [ dwThreadId ] = CHKDSK_VOLUME_LOCKED;
		RebootResult = (  FMIFS_CHECKONREBOOT_INFORMATION * ) PacketData;
		RebootResult->QueryResult = 1;
	}
	else
	{
		ProcessInformation ( PacketType, PacketLength, PacketData );
	}

	return TRUE;
}

/*****************************************************************************
*
*  FUNCTION    :    ProcessInofrmation
*
*  DESCRIPTION :    Checks the the dsk and keeps track of the appropriate error 
*					messages.
*
*****************************************************************************/
BOOLEAN ProcessInformation ( 

	FMIFS_PACKET_TYPE PacketType, 
	ULONG	PacketLength,
	PVOID	PacketData
)
{
	int static unRetVal;

	DWORD dwThreadId = GetCurrentThreadId();


	switch ( PacketType )
	{	
	case FmIfsTextMessage :
			FMIFS_TEXT_MESSAGE *MessageText;

			MessageText =  ( FMIFS_TEXT_MESSAGE *) PacketData;

			// There is no way to access this message ids via a interface exposed hence cannot detect these errors.
			/*	if ( lstrcmp ( MessageText, MSGCHK_ERRORS_NOT_FIXED ) == 0 )
			{
				unRetVal = 2;
			}

			if ( lstrcmp ( MessageText, MSG_CHK_ERRORS_FIXED ) == 0 )
			{	
				unRetVal = 3;
			}
			*/
			break;

	case FmIfsFinished: 
			FMIFS_FINISHED_INFORMATION *Finish;
			Finish = ( FMIFS_FINISHED_INFORMATION *) PacketData;
			if ( Finish->Success )
			{
				mReturnVal [ dwThreadId ] = CHKDSKERR_NOERROR;
			}
			else
			{
                if (mReturnVal [ dwThreadId ] != CHKDSK_VOLUME_LOCKED)
                {
				    mReturnVal [ dwThreadId ] = CHKDSK_FAILED;
                }
			}
			break;

	// although follwoing are the additional message types, callback routine never gets these messages
	// hence the detailed code for each of these return type is not written.
/*
	case FmIfsIncompatibleFileSystem:
			break;

	case FmIfsAccessDenied:
			break;

	case FmIfsBadLabel:
			break;

	case FmIfsHiddenStatus:
			break;

	case FmIfsClusterSizeTooSmall:
			break;

	case FmIfsClusterSizeTooBig:
			break;

	case FmIfsVolumeTooSmall:
			break;

	case FmIfsVolumeTooBig:
			break;

	case FmIfsNoMediaInDevice:
			break;

	case FmIfsClustersCountBeyond32bits:
			break;

	case FmIfsIoError:
			FMIFS_IO_ERROR_INFORMATION *IoErrorInfo;
			IoErrorInfo = ( FMIFS_IO_ERROR_INFORMATION * ) PacketData;
			break;

	case FmIfsMediaWriteProtected:
			break;

	case FmIfsIncompatibleMedia:
			break;

	case FmIfsInsertDisk:
			FMIFS_INSERT_DISK_INFORMATION *InsertDiskInfo;
			InsertDiskInfo = ( FMIFS_INSERT_DISK_INFORMATION *) PacketData;
			unRetVal = 1;
			break;
*/

	}

	return TRUE;
}

HRESULT LogicalDisk::ExecuteCommand ( LPCWSTR wszCommand )
{
	HRESULT hRes = WBEM_E_FAILED;

	DWORD t_Status = ERROR_SUCCESS ;

	SmartCloseHandle t_TokenPrimaryHandle ;
	SmartCloseHandle t_TokenImpersonationHandle;

	BOOL t_TokenStatus = OpenThreadToken (

		GetCurrentThread () ,
		TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY  ,
		TRUE ,
		& t_TokenImpersonationHandle
	) ;

	if ( t_TokenStatus )
	{
		CAdvApi32Api *t_pAdvApi32 = NULL;
        if ( ( t_pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL) ) != NULL )
		{
			t_pAdvApi32->DuplicateTokenEx (	t_TokenImpersonationHandle ,
											TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY ,
											NULL,
											SecurityImpersonation,
											TokenPrimary ,
											&t_TokenPrimaryHandle,
											&t_TokenStatus
										  );

			CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_pAdvApi32);
			t_pAdvApi32 = NULL;
        }
		else
		{
			t_TokenStatus = 0;
		}
	}

	if ( t_TokenStatus )
	{
		CUserHive t_Hive ;
		CHString chsSID ;
		CHString t_Account ;

		DWORD dwCheckKeyPresentStatus = ERROR_SUCCESS ;
		TCHAR t_KeyName [ 1024 ]  = { L'\0' } ;

		TOKEN_INFORMATION_CLASS t_TokenInformationClass = TokenUser ;
		TOKEN_USER *t_TokenUser = NULL ;

		DWORD t_ReturnLength = 0L;

		t_TokenStatus = GetTokenInformation (

			t_TokenImpersonationHandle ,
			t_TokenInformationClass ,
			NULL ,
			0 ,
			& t_ReturnLength
		) ;

		if ( ! t_TokenStatus && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
		{
			if ( ( t_TokenUser = ( TOKEN_USER * ) new UCHAR [ t_ReturnLength ] ) != NULL )
			{
				try
				{
					t_TokenStatus = GetTokenInformation (

						t_TokenImpersonationHandle ,
						t_TokenInformationClass ,
						( void * ) t_TokenUser ,
						t_ReturnLength ,
						& t_ReturnLength
					) ;

					if ( t_TokenStatus )
					{
						CSid t_Sid ( t_TokenUser->User.Sid ) ;
						if ( t_Sid.IsOK () )
						{
							chsSID = t_Sid.GetSidString () ;
							t_Account = t_Sid.GetAccountName () ;
						}
						else
						{
							t_Status = GetLastError () ;
						}
					}
					else
					{
						t_Status = GetLastError () ;
					}
				}
				catch ( ... )
				{
					if ( t_TokenUser )
					{
						delete [] ( UCHAR * ) t_TokenUser ;
						t_TokenUser = NULL ;
					}

					throw ;
				}

				if ( t_TokenUser )
				{
					delete [] ( UCHAR * ) t_TokenUser ;
					t_TokenUser = NULL ;
				}
			}
			else
			{
				t_Status = ERROR_NOT_ENOUGH_MEMORY;
			}
		}
		else
		{
			t_Status = ::GetLastError ();
		}

		if ( t_Status == ERROR_SUCCESS )
		{
			CRegistry Reg ;
			//check if SID already present under HKEY_USER ...
			dwCheckKeyPresentStatus = Reg.Open(HKEY_USERS, chsSID, KEY_READ) ;
			Reg.Close() ;

			if(dwCheckKeyPresentStatus != ERROR_SUCCESS)
			{
				t_Status = t_Hive.Load ( t_Account , t_KeyName, 1024 ) ;
			}

			if ( t_Status == ERROR_FILE_NOT_FOUND )
			{
				t_Status = ERROR_SUCCESS ;
				dwCheckKeyPresentStatus = ERROR_SUCCESS ;
			}
		}

		if ( t_Status == ERROR_SUCCESS )
		{
			try
			{
				DWORD t_CreationFlags = 0 ;
				STARTUPINFO t_StartupInformation ;

				ZeroMemory ( &t_StartupInformation , sizeof ( t_StartupInformation ) ) ;
				t_StartupInformation.cb = sizeof ( STARTUPINFO ) ;
				t_StartupInformation.dwFlags = STARTF_USESHOWWINDOW;
				t_StartupInformation.wShowWindow  = SW_HIDE;

				t_CreationFlags = NORMAL_PRIORITY_CLASS | CREATE_UNICODE_ENVIRONMENT ;

				PROCESS_INFORMATION t_ProcessInformation;

				CUserEnvApi *pUserEnv = NULL ;
				LPVOID t_Environment = NULL ;

				if ( ( pUserEnv = ( CUserEnvApi * ) CResourceManager::sm_TheResourceManager.GetResource ( g_guidUserEnvApi, NULL ) ) != NULL )
				{
					try
					{
						pUserEnv->CreateEnvironmentBlock (

							& t_Environment ,
							t_TokenPrimaryHandle ,
							FALSE
						);

						t_Status = CreateProcessAsUser (

							t_TokenPrimaryHandle ,
							NULL ,
							( LPTSTR ) wszCommand,
							NULL ,
							NULL ,
							FALSE ,
							t_CreationFlags ,
							( TCHAR * ) t_Environment ,
							NULL ,
							& t_StartupInformation ,
							& t_ProcessInformation
						) ;

						if ( t_Environment )
						{
							pUserEnv->DestroyEnvironmentBlock ( t_Environment ) ;
							t_Environment = NULL;
						}
					}
					catch ( ... )
					{
						CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidUserEnvApi, pUserEnv ) ;
						pUserEnv = NULL ;

						throw;
					}

					CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidUserEnvApi, pUserEnv ) ;
					pUserEnv = NULL ;

					if ( t_Status )
					{
						t_Status = ERROR_SUCCESS;

						if ( ::WaitForSingleObject ( t_ProcessInformation.hProcess, INFINITE ) == WAIT_OBJECT_0 )
						{
							DWORD t_ExitCode = 0L;
							if ( GetExitCodeProcess ( t_ProcessInformation.hProcess, &t_ExitCode ) )
							{
								if ( t_ExitCode == 2 )
								{
									//	from chkntfs file
									//
									//	EXIT:
									//	0   -- OK, dirty bit not set on drive or bit not checked
									//	1   -- OK, and dirty bit set on at least one drive
									//	2   -- Error

									hRes = WBEM_E_FAILED;
								}
								else
								{
									hRes = WBEM_S_NO_ERROR;
								}
							}

							::CloseHandle ( t_ProcessInformation.hProcess ) ;
						}
					}
					else
					{
						t_Status = ::GetLastError ();
					}
				}
			}
			catch ( ... )
			{
				if(dwCheckKeyPresentStatus != ERROR_SUCCESS)
				{
					t_Hive.Unload ( t_KeyName ) ;
				}

				throw;
			}

			if(dwCheckKeyPresentStatus != ERROR_SUCCESS)
			{
				t_Hive.Unload ( t_KeyName ) ;
			}
		}
	}

	if ( t_Status == ERROR_ACCESS_DENIED )
	{
		hRes = HRESULT_FROM_WIN32 ( t_Status );
	}

	return hRes;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\logicalfileaccess.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

#include "precomp.h"
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "securefile.h"
#include "logicalfileaccess.h"


typedef std::vector<_bstr_t> BSTRTVEC;


CWin32LogicalFileAccess LogicalFileAccess( LOGICAL_FILE_ACCESS_NAME, IDS_CimWin32Namespace );

/*
    [Dynamic, Association: ToInstance]
class Win32_LogicalFileAccess : Win32_SecuritySettingAccess
{
    Win32_LogicalFileSecuritySetting ref SecuritySetting;

    Win32_SID ref Trustee;
};
*/

CWin32LogicalFileAccess::CWin32LogicalFileAccess( const CHString& setName, LPCTSTR pszNameSpace /*=NULL*/)
:	Provider( setName, pszNameSpace )
{
}

CWin32LogicalFileAccess::~CWin32LogicalFileAccess()
{
}

HRESULT CWin32LogicalFileAccess::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
	HRESULT hr = WBEM_E_NOT_FOUND;

#ifdef NTONLY

	if(pInstance != NULL)
	{
		CInstancePtr pLogicalFileInstance;

		// get instance by path on Win32_LogicalFileSecuritySetting part
		CHString chsLogicalFileSecurityPath;
		pInstance->GetCHString(_T("SecuritySetting"), chsLogicalFileSecurityPath);
		MethodContext* pMethodContext = pInstance->GetMethodContext();

		if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chsLogicalFileSecurityPath, &pLogicalFileInstance, pMethodContext)) &&
           pLogicalFileInstance != NULL)
		{
			CHString chsFilePath;

			pLogicalFileInstance->GetCHString(IDS_Path, chsFilePath);

			CSecureFile secFile(chsFilePath, FALSE);  // Don't need SACL
			CDACL dacl;
			secFile.GetDACL(dacl);

			// walk DACL looking for the sid path passed in....
            // First need merged acl to work with...
            CAccessEntryList t_cael;
            if(dacl.GetMergedACL(t_cael))
            {
			    ACLPOSITION aclPos;
			    if(t_cael.BeginEnum(aclPos))
                {
			        CAccessEntry ACE;
			        CSid sidTrustee;
                    bool fFoundIt = false;
			        while(t_cael.GetNext(aclPos, ACE ) && !fFoundIt)
			        {
				        ACE.GetSID(sidTrustee);
				        CHString chsTrustee = sidTrustee.GetSidString();

				        CInstancePtr pSIDInstance;
				        CHString chstrSIDPath;
				        pInstance->GetCHString(_T("Trustee"), chstrSIDPath);
		                //CHString chstrFullSIDPath;
                        //chstrFullSIDPath.Format(_T("\\\\%s\\%s:Win32_SID.SID=\"%s\""),
                        //             GetLocalComputerName(),
                        //             IDS_CimWin32Namespace,
                        //             (LPCTSTR)chstrSIDPath);
			  	        if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrSIDPath, &pSIDInstance, pInstance->GetMethodContext())))
				        {
					        if(pSIDInstance != NULL)
					        {
						        CHString chsInstanceSID;
						        pSIDInstance->GetCHString(_T("SID"), chsInstanceSID);
						        if(chsTrustee.CompareNoCase(chsInstanceSID) == 0)
						        {
							        hr = WBEM_S_NO_ERROR;
                                    fFoundIt = true;
						        }
					        }
				        }
			        }
			        t_cael.EndEnum(aclPos);
                }
            }
		}
	}

#endif

	return(hr);
}


HRESULT CWin32LogicalFileAccess::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_S_NO_ERROR;

#ifdef NTONLY

    // We optimize for one scenario only:  the query specified one or more SecuritySettings, requesting associations with the Trustees of
    // each; if the query specified one or more Trustees, we would have to enumerate all instances of cim_logicalfile and
    // determine the Trustees of each, so we don't support that "optimization".
    BSTRTVEC vectorSecuritySettings;
    BSTRTVEC vectorTrustees;
    pQuery.GetValuesForProp(IDS_SecuritySetting, vectorSecuritySettings);
    pQuery.GetValuesForProp(IDS_Trustee, vectorTrustees);
    DWORD dwSettings = vectorSecuritySettings.size();
    DWORD dwTrustees = vectorTrustees.size();
    if(dwSettings >= 1 && dwTrustees == 0)
    {
        CInstancePtr pSecSetting;
        for(LONG m = 0; m < dwSettings && SUCCEEDED(hr); m++)
        {
            CHString chstrLFSSPath;  // LogicalFileSecuritySetting path
            pSecSetting = NULL;
            chstrLFSSPath.Format(_T("\\\\%s\\%s:%s"),
                                 (LPCTSTR)GetLocalComputerName(),
                                 IDS_CimWin32Namespace,
                                 (LPCTSTR)CHString((WCHAR*)vectorSecuritySettings[m]));

            if(SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath(chstrLFSSPath, &pSecSetting, pMethodContext)))
            {
                if(pSecSetting != NULL)
                {
                    CHString chstrSSPath; // SecuritySetting path
                    pSecSetting->GetCHString(IDS_Path, chstrSSPath);
                    if(!chstrSSPath.IsEmpty())
                    {
                        CSecureFile secFile(chstrSSPath, FALSE);  // don't need SACL
                        // Get the DACL and for each entry create an instance of this association...
			            CDACL dacl;
                        CSid sidTrustee;
                        ACLPOSITION aclPos;
                        CAccessEntry ACE;
			            secFile.GetDACL(dacl);
                        // First need merged list
                        CAccessEntryList t_cael;
                        if(dacl.GetMergedACL(t_cael))
                        {
                            if(t_cael.BeginEnum(aclPos))
                            {
                                while(t_cael.GetNext(aclPos, ACE) && SUCCEEDED(hr))
			                    {
                                    ACE.GetSID(sidTrustee);
                                    if(sidTrustee.IsValid())
                                    {
                                        CInstancePtr pNewAssocInst;
                                        pNewAssocInst.Attach(CreateNewInstance(pMethodContext));
                                        if(pNewAssocInst != NULL)
                                        {
                                            // Set the SecuritySetting property of the association instance.
                                            pNewAssocInst->SetCHString(IDS_SecuritySetting, chstrLFSSPath);
                                            // Set the Trustee property of the association instance.
                                            CHString chstrFullWin32SIDPath;
                                            chstrFullWin32SIDPath.Format(_T("\\\\%s\\%s:Win32_SID.SID=\"%s\""),
                                                                         (LPCTSTR)GetLocalComputerName(),
                                                                         IDS_CimWin32Namespace,
                                                                         (LPCTSTR)sidTrustee.GetSidString());
                                            pNewAssocInst->SetCHString(IDS_Trustee, chstrFullWin32SIDPath);
                                            hr = pNewAssocInst->Commit();
                                        }
                                    }
                                }
                                t_cael.EndEnum(aclPos);
                            }
                        }
                    }
                }
            }
        }
    }
    else
    {
        // hr = EnumerateInstances(pMethodContext, lFlags);
        // commented out since some other classes may support exec queries of this type, and returning provider not
        // capable from this class results in some instances (from other classes) being returned, followed by an abort
        // of the enumeration due to this class's returning provider not capable.
    }

#endif

    return hr;
}


HRESULT CWin32LogicalFileAccess::EnumerateInstances( MethodContext*  pMethodContext, long lFlags /*= 0L*/ )
{
/*	HRESULT hr = WBEM_S_NO_ERROR;

    if(m_dwPlatformID != VER_PLATFORM_WIN32_NT)
    {
		return(hr);
	}

    TRefPointerCollection<CInstance> LCIMLogicalFiles;

    CHString chstrAllFilesQuery;
    chstrAllFilesQuery = _T("SELECT __PATH FROM CIM_LogicalFile");
    if(SUCCEEDED(CWbemProviderGlue::GetInstancesByQuery(chstrAllFilesQuery,
                                                        &LCIMLogicalFiles,
                                                        pMethodContext,
                                                        IDS_CimWin32Namespace)))

    {
        REFPTRCOLLECTION_POSITION pos;
        if(LCIMLogicalFiles.BeginEnum(pos))
        {
            CInstance* pinstCIMLogicalFile = NULL;
            CInstance* pSecSetting = NULL;
            //CInstance* pW32SID = NULL;
            while((SUCCEEDED(hr)) && (pinstCIMLogicalFile = LCIMLogicalFiles.GetNext(pos)))
            {
                if(pinstCIMLogicalFile != NULL)
                {
                    // For each logicalfile instance, need to create an association instance.
                    // For each association instance, need to fill in two properties: Trustee and SecuritySetting.

                    // Get and set the SecuritySetting property:
                    // First get the name property of the CIM_LogicalFile instance:
                    CHString chstrCLFName;
                    pinstCIMLogicalFile->GetCHString(IDS_Name, chstrCLFName);
                    CHString chstrDblEscCLFName;
                    EscapeBackslashes(chstrCLFName, chstrDblEscCLFName);
                    CHString chstrLFSSPath;  // LogicalFileSecuritySetting path
                    pSecSetting = NULL;
                    chstrLFSSPath.Format(_T("\\\\%s\\%s:Win32_LogicalFileSecuritySetting.Path=\"%s\""),
                                         (LPCTSTR)GetLocalComputerName(),
                                         IDS_CimWin32Namespace,
                                         (LPCTSTR)chstrDblEscCLFName);

                    if(SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath(chstrLFSSPath, &pSecSetting)))
                    {
                        if(pSecSetting != NULL)
                        {
                            CHString chstrSSPath; // SecuritySetting path
                            pSecSetting->GetCHString(IDS_Path, chstrSSPath);
                            if(!chstrSSPath.IsEmpty())
                            {
                                CSecureFile secFile(chstrSSPath, FALSE);  // don't need SACL
                                // Get the DACL and for each entry create an instance of this association...
			                    CDACL dacl;
                                CSid sidTrustee;
                                ACLPOSITION aclPos;
                                CAccessEntry ACE;
			                    secFile.GetDACL(dacl);
                                if(dacl.BeginEnum(aclPos))
                                {
                                    while(dacl.GetNext(aclPos, ACE))
			                        {
                                        ACE.GetSID(sidTrustee);
                                        if(sidTrustee.IsValid())
                                        {
                                            CInstance* pNewAssocInst = CreateNewInstance(pMethodContext);
                                            if(pNewAssocInst != NULL)
                                            {
                                                // Set the SecuritySetting property of the association instance.
                                                pNewAssocInst->SetCHString(IDS_SecuritySetting, chstrLFSSPath);
                                                // Set the Trustee property of the association instance.
                                                CHString chstrFullWin32SIDPath;
                                                chstrFullWin32SIDPath.Format(_T("\\\\%s\\%s:Win32_SID.SID=\"%s\""),
                                                                             (LPCTSTR)GetLocalComputerName(),
                                                                             IDS_CimWin32Namespace,
                                                                             (LPCTSTR)sidTrustee.GetSidString());
                                                pNewAssocInst->SetCHString(IDS_Trustee, chstrFullWin32SIDPath);
                                                hr = Commit(pNewAssocInst);
                                            }
                                        }
                                    }
                                    dacl.EndEnum(aclPos);
                                }
                            }
                            pSecSetting->Release();
                            pSecSetting = NULL;
                        }
                    }
                    pinstCIMLogicalFile->Release();
                    pinstCIMLogicalFile = NULL;
                }
            }
            LCIMLogicalFiles.EndEnum();
        }
    }

	return hr;
*/
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\logicalfileaudit.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

#include "precomp.h"
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "securefile.h"
#include "logicalfileaudit.h"


typedef std::vector<_bstr_t> BSTRTVEC;


CWin32LogicalFileAudit LogicalFileAudit( LOGICAL_FILE_AUDIT_NAME, IDS_CimWin32Namespace );

/*
    [Dynamic, Association: ToInstance]
class Win32_LogicalFileAccess : Win32_SecuritySettingAccess
{
    Win32_LogicalFileSecuritySetting ref SecuritySetting;

    Win32_SID ref Trustee;
};
*/

CWin32LogicalFileAudit::CWin32LogicalFileAudit( const CHString& setName, LPCTSTR pszNameSpace /*=NULL*/)
:	Provider( setName, pszNameSpace )
{
}

CWin32LogicalFileAudit::~CWin32LogicalFileAudit()
{
}

HRESULT CWin32LogicalFileAudit::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
	HRESULT hr = WBEM_E_NOT_FOUND;

#ifdef NTONLY

	if(pInstance != NULL)
	{
		CInstancePtr pLogicalFileInstance;

		// get instance by path on Win32_LogicalFileSecuritySetting part
		CHString chsLogicalFileSecurityPath;
		pInstance->GetCHString(_T("SecuritySetting"), chsLogicalFileSecurityPath);
		MethodContext* pMethodContext = pInstance->GetMethodContext();

		if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chsLogicalFileSecurityPath, &pLogicalFileInstance, pMethodContext)) &&
           pLogicalFileInstance != NULL)
		{
			CHString chsFilePath;

			pLogicalFileInstance->GetCHString(IDS_Path, chsFilePath);

			CSecureFile secFile(chsFilePath, TRUE); // Need SACL
			CSACL sacl;
			secFile.GetSACL(sacl);

			// walk SACL looking for the sid path passed in....
			ACLPOSITION aclPos;
            // Need merged list...
            CAccessEntryList t_ael;
            if(sacl.GetMergedACL(t_ael))
            {
			    if(t_ael.BeginEnum(aclPos))
                {
			        CAccessEntry ACE;
			        CSid sidTrustee;
                    bool fFoundIt = false;
			        while(t_ael.GetNext(aclPos, ACE ) && !fFoundIt)
			        {
				        ACE.GetSID(sidTrustee);
				        CHString chsTrustee = sidTrustee.GetSidString();

				        CInstancePtr pSIDInstance;
				        CHString chstrSIDPath;
				        pInstance->GetCHString(_T("Trustee"), chstrSIDPath);
		                //CHString chstrFullSIDPath;
                        //chstrFullSIDPath.Format("\\\\%s\\%s:Win32_SID.SID=\"%s\"",
                        //             GetLocalComputerName(),
                        //             IDS_CimWin32Namespace,
                        //             (LPCTSTR)chstrSIDPath);
			  	        if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrSIDPath, &pSIDInstance, pInstance->GetMethodContext())))
				        {
					        if(pSIDInstance != NULL)
					        {
						        CHString chsInstanceSID;
						        pSIDInstance->GetCHString(_T("SID"), chsInstanceSID);
						        if(chsTrustee.CompareNoCase(chsInstanceSID) == 0)
						        {
							        hr = WBEM_S_NO_ERROR;
                                    fFoundIt = true;
						        }
					        }
				        }
			        }
			        t_ael.EndEnum(aclPos);
                }
            }
		}
	}
#endif

	return(hr);
}


HRESULT CWin32LogicalFileAudit::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_S_NO_ERROR;

#ifdef NTONLY

    // We optimize for one scenario only:  the query specified one or more SecuritySettings, requesting associations with the Trustees of
    // each; if the query specified one or more Trustees, we would have to enumerate all instances of cim_logicalfile and
    // determine the Trustees of each, so we don't support that "optimization".
    BSTRTVEC vectorSecuritySettings;
    BSTRTVEC vectorTrustees;
    pQuery.GetValuesForProp(IDS_SecuritySetting, vectorSecuritySettings);
    pQuery.GetValuesForProp(IDS_Trustee, vectorTrustees);
    DWORD dwSettings = vectorSecuritySettings.size();
    DWORD dwTrustees = vectorTrustees.size();
    if(dwSettings >= 1 && dwTrustees == 0)
    {
        CInstancePtr pSecSetting;
        for(LONG m = 0; m < dwSettings && SUCCEEDED(hr); m++)
        {
            CHString chstrLFSSPath;  // LogicalFileSecuritySetting path
            pSecSetting = NULL;
            chstrLFSSPath.Format(L"\\\\%s\\%s:%s",
                                 (LPCTSTR)GetLocalComputerName(),
                                 IDS_CimWin32Namespace,
                                 (LPCTSTR)CHString((WCHAR*)vectorSecuritySettings[m]));

            if(SUCCEEDED(hr = CWbemProviderGlue::GetInstanceKeysByPath(chstrLFSSPath, &pSecSetting, pMethodContext)))
            {
                if(pSecSetting != NULL)
                {
                    CHString chstrSSPath; // SecuritySetting path
                    pSecSetting->GetCHString(IDS_Path, chstrSSPath);
                    if(!chstrSSPath.IsEmpty())
                    {
                        CSecureFile secFile(chstrSSPath, TRUE);  // need SACL
                        // Get the SACL and for each entry create an instance of this association...
			            CSACL sacl;
                        CSid sidTrustee;
                        ACLPOSITION aclPos;
                        CAccessEntry ACE;
			            secFile.GetSACL(sacl);
                        // Need merged list...
                        CAccessEntryList t_ael;
                        if(sacl.GetMergedACL(t_ael))
                        {
                            if(t_ael.BeginEnum(aclPos))
                            {
                                while(t_ael.GetNext(aclPos, ACE) && SUCCEEDED(hr))
			                    {
                                    ACE.GetSID(sidTrustee);
                                    if(sidTrustee.IsValid())
                                    {
                                        CInstancePtr pNewAssocInst;
                                        pNewAssocInst.Attach(CreateNewInstance(pMethodContext));
                                        if(pNewAssocInst != NULL)
                                        {
                                            // Set the SecuritySetting property of the association instance.
                                            pNewAssocInst->SetCHString(IDS_SecuritySetting, chstrLFSSPath);
                                            // Set the Trustee property of the association instance.
                                            CHString chstrFullWin32SIDPath;
                                            chstrFullWin32SIDPath.Format(L"\\\\%s\\%s:Win32_SID.SID=\"%s\"",
                                                                         (LPCTSTR)GetLocalComputerName(),
                                                                         IDS_CimWin32Namespace,
                                                                         (LPCTSTR)sidTrustee.GetSidString());
                                            pNewAssocInst->SetCHString(IDS_Trustee, chstrFullWin32SIDPath);
                                            hr = pNewAssocInst->Commit();
                                        }
                                    }
                                }
                                t_ael.EndEnum(aclPos);
                            }
                        }
                    }
                }
            }
        }
    }
    else
    {
        // hr = EnumerateInstances(pMethodContext, lFlags);
        // commented out since some other classes may support exec queries of this type, and returning provider not
        // capable from this class results in some instances (from other classes) being returned, followed by an abort
        // of the enumeration due to this class's returning provider not capable.
    }

#endif

    return hr;
}


HRESULT CWin32LogicalFileAudit::EnumerateInstances( MethodContext*  pMethodContext, long lFlags /*= 0L*/ )
{
/*	HRESULT hr = WBEM_S_NO_ERROR;

    if(m_dwPlatformID != VER_PLATFORM_WIN32_NT)
    {
		return(hr);
	}

    TRefPointerCollection<CInstance> LCIMLogicalFiles;

    CHString chstrAllFilesQuery;
    chstrAllFilesQuery = L"SELECT __PATH FROM CIM_LogicalFile";
    if(SUCCEEDED(CWbemProviderGlue::GetInstancesByQuery(chstrAllFilesQuery,
                                                        &LCIMLogicalFiles,
                                                        pMethodContext,
                                                        IDS_CimWin32Namespace)))

    {
        REFPTRCOLLECTION_POSITION pos;
        if(LCIMLogicalFiles.BeginEnum(pos))
        {
            CInstance* pinstCIMLogicalFile = NULL;
            CInstance* pSecSetting = NULL;
            while((SUCCEEDED(hr)) && (pinstCIMLogicalFile = LCIMLogicalFiles.GetNext(pos)))
            {
                if(pinstCIMLogicalFile != NULL)
                {
                    // For each logicalfile instance, need to create an association instance.
                    // For each association instance, need to fill in two properties: Trustee and SecuritySetting.

                    // Get and set the SecuritySetting property:
                    // First get the name property of the CIM_LogicalFile instance:
                    CHString chstrCLFName;
                    pinstCIMLogicalFile->GetCHString(IDS_Name, chstrCLFName);
                    CHString chstrDblEscCLFName;
                    EscapeBackslashes(chstrCLFName, chstrDblEscCLFName);
                    CHString chstrLFSSPath;  // LogicalFileSecuritySetting path
                    pSecSetting = NULL;
                    chstrLFSSPath.Format(L"\\\\%s\\%s:Win32_LogicalFileSecuritySetting.Path=\"%s\"",
                                         (LPCTSTR)GetLocalComputerName(),
                                         IDS_CimWin32Namespace,
                                         (LPCTSTR)chstrDblEscCLFName);

                    if(SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath(chstrLFSSPath, &pSecSetting)))
                    {
                        if(pSecSetting != NULL)
                        {
                            CHString chstrSSPath; // SecuritySetting path
                            pSecSetting->GetCHString(IDS_Path, chstrSSPath);
                            if(!chstrSSPath.IsEmpty())
                            {
                                CSecureFile secFile(chstrSSPath, TRUE);  // need SACL
                                // Get the SACL and for each entry create an instance of this association...
			                    CSACL sacl;
                                CSid sidTrustee;
                                ACLPOSITION aclPos;
                                CAccessEntry ACE;
			                    secFile.GetSACL(sacl);
                                if(sacl.BeginEnum(aclPos))
                                {
                                    while(sacl.GetNext(aclPos, ACE))
			                        {
                                        ACE.GetSID(sidTrustee);
                                        if(sidTrustee.IsValid())
                                        {
                                            CInstance* pNewAssocInst = CreateNewInstance(pMethodContext);
                                            if(pNewAssocInst != NULL)
                                            {
                                                // Set the SecuritySetting property of the association instance.
                                                pNewAssocInst->SetCHString(IDS_SecuritySetting, chstrLFSSPath);
                                                // Set the Trustee property of the association instance.
                                                CHString chstrFullWin32SIDPath;
                                                chstrFullWin32SIDPath.Format(L"\\\\%s\\%s:Win32_SID.SID=\"%s\"",
                                                                             (LPCTSTR)GetLocalComputerName(),
                                                                             IDS_CimWin32Namespace,
                                                                             (LPCTSTR)sidTrustee.GetSidString());
                                                pNewAssocInst->SetCHString(IDS_Trustee, chstrFullWin32SIDPath);
                                                hr = Commit(pNewAssocInst);
                                            }
                                        }
                                    }
                                    sacl.EndEnum(aclPos);
                                }
                            }
                            pSecSetting->Release();
                            pSecSetting = NULL;
                        }
                    }
                    pinstCIMLogicalFile->Release();
                    pinstCIMLogicalFile = NULL;
                }
            }
            LCIMLogicalFiles.EndEnum();
        }
    }

	return hr;
*/
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\logicalfileaudit.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

#define  LOGICAL_FILE_AUDIT_NAME L"Win32_LogicalFileAuditing" 

// provider provided for test provisions
class CWin32LogicalFileAudit: public Provider
{
    private:
	public:	
		CWin32LogicalFileAudit(const CHString& setName, const WCHAR* pszNamespace );
		~CWin32LogicalFileAudit();

		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags /*= 0L*/);
		virtual HRESULT GetObject( CInstance* pInstance, long lFlags /*= 0L*/ );
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, 
                                  CFrameworkQuery& pQuery, 
                                  long lFlags = 0L);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\logicalfilegroup.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

#define  LOGICAL_FILE_GROUP_NAME "Win32_LogicalFileGroup" 

// provider provided for test provisions
class CWin32LogicalFileGroup: public Provider
{
	private:
    public:	
		CWin32LogicalFileGroup(const CHString& setName, const WCHAR* pszNamespace );
		~CWin32LogicalFileGroup();

		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags /*= 0L*/);
		virtual HRESULT GetObject( CInstance* pInstance, long lFlags /*= 0L*/ );
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, 
                                  CFrameworkQuery& pQuery, 
                                  long lFlags = 0L);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\logicalfileowner.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/


#define  LOGICAL_FILE_OWNER_NAME "Win32_LogicalFileOwner" 

// provider provided for test provisions
class CWin32LogicalFileOwner: public Provider
{
    private:
	public:	
		CWin32LogicalFileOwner(const CHString& setName, const WCHAR* pszNamespace );
		~CWin32LogicalFileOwner();
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, 
                                  CFrameworkQuery& pQuery, 
                                  long lFlags = 0L);
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags /*= 0L*/);
		virtual HRESULT GetObject( CInstance* pInstance, long lFlags /*= 0L*/ );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\logicalfilegroup.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

#include "precomp.h"
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "securefile.h"
#include "logicalfilegroup.h"


typedef std::vector<_bstr_t> BSTRTVEC;



CWin32LogicalFileGroup LogicalFileGroup( LOGICAL_FILE_GROUP_NAME, IDS_CimWin32Namespace );

/*
    [Dynamic, Provider, Association: ToInstance]
class Win32_LogicalFileGroup : Win32_SecuritySettingGroup
{
    Win32_LogicalFileSecuritySetting ref SecuritySetting;

    Win32_SID ref Group;
};
*/

CWin32LogicalFileGroup::CWin32LogicalFileGroup( const CHString& setName, LPCTSTR pszNameSpace /*=NULL*/)
:	Provider( setName, pszNameSpace )
{
}

CWin32LogicalFileGroup::~CWin32LogicalFileGroup()
{
}

HRESULT CWin32LogicalFileGroup::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
	HRESULT hr = WBEM_E_NOT_FOUND;

#ifdef NTONLY

	if(pInstance != NULL)
	{
		CInstancePtr pLogicalFileInstance;

		// get instance by path on Win32_LogicalFileSecuritySetting part
		CHString chsLogicalFileSecurityPath;
		pInstance->GetCHString(_T("SecuritySetting"), chsLogicalFileSecurityPath);
		MethodContext* pMethodContext = pInstance->GetMethodContext();

		if(SUCCEEDED(CWbemProviderGlue::GetInstanceKeysByPath(chsLogicalFileSecurityPath, &pLogicalFileInstance, pMethodContext)))
		{
			if(pLogicalFileInstance != NULL)
            {
                CHString chsFilePath;

			    pLogicalFileInstance->GetCHString(IDS_Path, chsFilePath);

			    CSecureFile secFile(chsFilePath, TRUE);
			    CSid sidGroup;
			    secFile.GetGroup(sidGroup);
			    CHString chsGroup = sidGroup.GetSidString();

			    CInstancePtr pSIDInstance;
			    CHString chstrSIDPath;
			    pInstance->GetCHString(_T("Group"), chstrSIDPath);
                //CHString chstrFullSIDPath;
                //chstrFullSIDPath.Format("\\\\%s\\%s:Win32_SID.SID=\"%s\"",
                //             GetLocalComputerName(),
                //             IDS_CimWin32Namespace,
                //             (LPCTSTR)chstrSIDPath);

		  	    if (SUCCEEDED(CWbemProviderGlue::GetInstanceKeysByPath(chstrSIDPath, &pSIDInstance, pMethodContext)))
			    {
			        if(pSIDInstance != NULL)
                    {
            	        // compare SID
				        CHString chsSIDCompare;
				        pSIDInstance->GetCHString(_T("SID"), chsSIDCompare);

				        if (chsGroup.CompareNoCase(chsSIDCompare) == 0)
				        {
					        hr = WBEM_S_NO_ERROR;
				        }
                    }
			    }
            }
		}
	}

#endif

	return(hr);
}


HRESULT CWin32LogicalFileGroup::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_S_NO_ERROR;

#ifdef NTONLY

    // We optimize for one scenario only:  the query specified one or more SecuritySettings, requesting associations with the group of
    // each; if the query specified one or more Groups, for each we would have to enumerate all instances of cim_logicalfile and
    // determine the Group of each, so we don't support that "optimization".
    BSTRTVEC vectorSecuritySettings;
    BSTRTVEC vectorGroups;
    pQuery.GetValuesForProp(IDS_SecuritySetting, vectorSecuritySettings);
    pQuery.GetValuesForProp(IDS_Group, vectorGroups);
    DWORD dwSettings = vectorSecuritySettings.size();
    DWORD dwGroups = vectorGroups.size();
    if(dwSettings >= 1 && dwGroups == 0)
    {
        CInstancePtr pSecSetting;
        for(LONG m = 0; m < dwSettings && SUCCEEDED(hr); m++)
        {
            CHString chstrLFSSPath;  // LogicalFileSecuritySetting path
            pSecSetting = NULL;
            chstrLFSSPath.Format(_T("\\\\%s\\%s:%s"),
                                 (LPCTSTR)GetLocalComputerName(),
                                 IDS_CimWin32Namespace,
                                 (LPCTSTR)CHString((WCHAR*)vectorSecuritySettings[m]));

            if(SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath(chstrLFSSPath, &pSecSetting, pMethodContext)))
            {
                if(pSecSetting != NULL)
                {
                    CHString chstrSSPath; // SecuritySetting path
                    pSecSetting->GetCHString(IDS_Path, chstrSSPath);
                    if(!chstrSSPath.IsEmpty())
                    {
                        CSecureFile secFile(chstrSSPath, FALSE);  // don't need SACL
			            CSid sidGroup;
			            secFile.GetGroup(sidGroup);
                        if(sidGroup.IsValid())
                        {
                            CInstancePtr pNewAssocInst;
                            pNewAssocInst.Attach(CreateNewInstance(pMethodContext));
                            if(pNewAssocInst != NULL)
                            {
                                // Set the SecuritySetting property of the association instance.
                                pNewAssocInst->SetCHString(IDS_SecuritySetting, chstrLFSSPath);
                                // Set the Group property of the association instance.
                                CHString chstrFullWin32SIDPath;
                                chstrFullWin32SIDPath.Format(_T("\\\\%s\\%s:Win32_SID.SID=\"%s\""),
                                                             (LPCTSTR)GetLocalComputerName(),
                                                             IDS_CimWin32Namespace,
                                                             (LPCTSTR)sidGroup.GetSidString());
                                pNewAssocInst->SetCHString(IDS_Group, chstrFullWin32SIDPath);
                                hr = pNewAssocInst->Commit();
                            }
                        }
                    }
                }
            }
        }
    }
    else
    {
        // hr = EnumerateInstances(pMethodContext, lFlags);
        // commented out since some other classes may support exec queries of this type, and returning provider not
        // capable from this class results in some instances (from other classes) being returned, followed by an abort
        // of the enumeration due to this class's returning provider not capable.
    }

#endif

    return hr;
}


HRESULT CWin32LogicalFileGroup::EnumerateInstances( MethodContext*  pMethodContext, long lFlags /*= 0L*/ )
{/*
	HRESULT hr = WBEM_S_NO_ERROR;

    if(m_dwPlatformID != VER_PLATFORM_WIN32_NT)
    {
		return(hr);
	}

    TRefPointerCollection<CInstance> LCIMLogicalFiles;

    CHString chstrAllFilesQuery;
    chstrAllFilesQuery = _T("SELECT __PATH FROM CIM_LogicalFile");
    if(SUCCEEDED(CWbemProviderGlue::GetInstancesByQuery(chstrAllFilesQuery,
                                                        &LCIMLogicalFiles,
                                                        pMethodContext,
                                                        IDS_CimWin32Namespace)))

    {
        REFPTRCOLLECTION_POSITION pos;
        if(LCIMLogicalFiles.BeginEnum(pos))
        {
            CInstance* pinstCIMLogicalFile = NULL;
            CInstance* pSecSetting = NULL;
            //CInstance* pW32SID = NULL;
            while((SUCCEEDED(hr)) && (pinstCIMLogicalFile = LCIMLogicalFiles.GetNext(pos)))
            {
                if(pinstCIMLogicalFile != NULL)
                {
                    // For each logicalfile instance, need to create an association instance.
                    // For each association instance, need to fill in two properties: Group and SecuritySetting.

                    // Get and set the SecuritySetting property:
                    // First get the name property of the CIM_LogicalFile instance:
                    CHString chstrCLFName;
                    pinstCIMLogicalFile->GetCHString(IDS_Name, chstrCLFName);
                    CHString chstrDblEscCLFName;
                    EscapeBackslashes(chstrCLFName, chstrDblEscCLFName);
                    CHString chstrLFSSPath;  // LogicalFileSecuritySetting path
                    pSecSetting = NULL;
                    chstrLFSSPath.Format(_T("\\\\%s\\%s:Win32_LogicalFileSecuritySetting.Path=\"%s\""),
                                         (LPCTSTR)GetLocalComputerName(),
                                         IDS_CimWin32Namespace,
                                         (LPCTSTR)chstrDblEscCLFName);

                    if(SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath(chstrLFSSPath, &pSecSetting)))
                    {
                        if(pSecSetting != NULL)
                        {
                            CHString chstrSSPath; // SecuritySetting path
                            pSecSetting->GetCHString(IDS_Path, chstrSSPath);
                            if(!chstrSSPath.IsEmpty())
                            {
                                CInstance* pNewAssocInst = CreateNewInstance(pMethodContext);
                                if(pNewAssocInst != NULL)
                                {
                                    // Set the SecuritySetting property of the association instance...
                                    pNewAssocInst->SetCHString(IDS_SecuritySetting, chstrLFSSPath);
                                    // Now set the Group property...
                                    CSecureFile secFile(chstrSSPath, FALSE);  // don't need SACL
			                        CSid sidGroup;
			                        secFile.GetGroup(sidGroup);
                                    if(sidGroup.IsValid())
                                    {
                                        CHString chstrFullWin32SIDPath;
                                        chstrFullWin32SIDPath.Format(_T("\\\\%s\\%s:Win32_SID.SID=\"%s\""),
                                                                     (LPCTSTR)GetLocalComputerName(),
                                                                     IDS_CimWin32Namespace,
                                                                     (LPCTSTR)sidGroup.GetSidString());
                                        pNewAssocInst->SetCHString(IDS_Group, chstrFullWin32SIDPath);
                                        hr = Commit(pNewAssocInst);
                                    }
                                }
                            }
                            pSecSetting->Release();
                            pSecSetting = NULL;
                        }
                    }
                    pinstCIMLogicalFile->Release();
                    pinstCIMLogicalFile = NULL;
                }
            }
            LCIMLogicalFiles.EndEnum();
        }
    }

	return hr;
*/
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\logicalfileowner.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

#include "precomp.h"
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "securefile.h"
#include "logicalfileowner.h"

typedef std::vector<_bstr_t> BSTRTVEC;

CWin32LogicalFileOwner LogicalFileOwner( LOGICAL_FILE_OWNER_NAME, IDS_CimWin32Namespace );

/*
    [Dynamic, Association: ToInstance]
class Win32_LogicalFileOwner : Win32_SecuritySettingOwner
{
    Win32_LogicalFileSecuritySetting ref SecuritySetting;

    Win32_SID ref Owner;
};
*/

CWin32LogicalFileOwner::CWin32LogicalFileOwner( const CHString& setName, LPCTSTR pszNameSpace /*=NULL*/)
:	Provider( setName, pszNameSpace )
{
}

CWin32LogicalFileOwner::~CWin32LogicalFileOwner()
{
}

HRESULT CWin32LogicalFileOwner::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
	HRESULT hr = WBEM_E_NOT_FOUND;

#ifdef NTONLY

	if(pInstance != NULL)
	{
		CInstancePtr pLogicalFileInstance;

		// get instance by path on Win32_LogicalFileSecuritySetting part
		CHString chsLogicalFileSecurityPath;
		pInstance->GetCHString(L"SecuritySetting", chsLogicalFileSecurityPath);
		MethodContext* pMethodContext = pInstance->GetMethodContext();

		if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chsLogicalFileSecurityPath, &pLogicalFileInstance, pMethodContext)))
		{
            if(pLogicalFileInstance != NULL)
            {
			    CHString chsFilePath;
			    pLogicalFileInstance->GetCHString(IDS_Path, chsFilePath);

			    CSecureFile secFile(chsFilePath, TRUE);
			    CSid sidOwner;
			    secFile.GetOwner(sidOwner);
			    CHString chsOwner = sidOwner.GetSidString();

			    CInstancePtr pSIDInstance ;
			    CHString chstrSIDPath;
			    pInstance->GetCHString(L"Owner", chstrSIDPath);
                //CHString chstrFullSIDPath;
                //chstrFullSIDPath.Format(_T("\\\\%s\\%s:Win32_SID.SID=\"%s\""),
                //             GetLocalComputerName(),
                //             IDS_CimWin32Namespace,
                //             (LPCTSTR)chstrSIDPath);

		  	    if (SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrSIDPath, &pSIDInstance, pInstance->GetMethodContext())))
			    {
			        if(pSIDInstance != NULL)
                    {
                        // compare SID
				        CHString chsSIDCompare;
				        pSIDInstance->GetCHString(L"SID", chsSIDCompare);
				        if (0 == chsOwner.CompareNoCase(chsSIDCompare))
				        {
					        hr = WBEM_S_NO_ERROR;
				        }
                    }
			    }
            }
		}
	}

#endif

	return(hr);
}


HRESULT CWin32LogicalFileOwner::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_S_NO_ERROR;

#ifdef NTONLY

    // We optimize for one scenario only:  the query specified one or more SecuritySettings, requesting associations with the owner of
    // each; if the query specified one or more Owners, for each we would have to enumerate all instances of cim_logicalfile and
    // determine the owner of each, so we don't support that "optimization".
    BSTRTVEC vectorSecuritySettings;
    BSTRTVEC vectorOwners;
    pQuery.GetValuesForProp(IDS_SecuritySetting, vectorSecuritySettings);
    pQuery.GetValuesForProp(IDS_Owner, vectorOwners);
    DWORD dwSettings = vectorSecuritySettings.size();
    DWORD dwOwners = vectorOwners.size();
    if(dwSettings >= 1 && dwOwners == 0)
    {
        CInstancePtr pSecSetting;
        for(LONG m = 0; m < dwSettings && SUCCEEDED(hr); m++)
        {
            CHString chstrLFSSPath;  // LogicalFileSecuritySetting path
            pSecSetting = NULL;
            chstrLFSSPath.Format(L"\\\\%s\\%s:%s",
                                 (LPCTSTR)GetLocalComputerName(),
                                 IDS_CimWin32Namespace,
                                 (LPCTSTR)CHString((WCHAR*)vectorSecuritySettings[m]));

            if(SUCCEEDED(hr = CWbemProviderGlue::GetInstanceKeysByPath(chstrLFSSPath, &pSecSetting, pMethodContext)))
            {
                if(pSecSetting != NULL)
                {
                    CHString chstrSSPath; // SecuritySetting path
                    pSecSetting->GetCHString(IDS_Path, chstrSSPath);
                    if(!chstrSSPath.IsEmpty())
                    {
                        CSecureFile secFile(chstrSSPath, FALSE);  // don't need SACL
			            CSid sidOwner;
			            secFile.GetOwner(sidOwner);
                        if(sidOwner.IsValid())
                        {
                            CInstancePtr pNewAssocInst;
                            pNewAssocInst.Attach(CreateNewInstance(pMethodContext));
                            if(pNewAssocInst != NULL)
                            {
                                // Set the SecuritySetting property of the association instance.
                                pNewAssocInst->SetCHString(IDS_SecuritySetting, chstrLFSSPath);
                                // Set the Owner property of the association instance.
                                //CInstance* pW32SID = NULL;
                                //if(SUCCEEDED(CWbemProviderGlue::GetEmptyInstance(pMethodContext, "Win32_SID", &pW32SID)))
			                    //{
                                //    if(pW32SID != NULL)
                                //    {
                                //        hr = FillW32SIDFromSid(pW32SID, sidOwner);
                                //        if(SUCCEEDED(hr))
                                //        {
                                //            pNewAssocInst->SetEmbeddedObject(IDS_Owner, *pW32SID);
                                //            hr = Commit(pNewAssocInst);
                                //        }
                                //        pW32SID->Release();
                                //    }
                                //}
                                CHString chstrFullWin32SIDPath;
                                chstrFullWin32SIDPath.Format(L"\\\\%s\\%s:Win32_SID.SID=\"%s\"",
                                                             (LPCTSTR)GetLocalComputerName(),
                                                             IDS_CimWin32Namespace,
                                                             (LPCTSTR)sidOwner.GetSidString());
                                pNewAssocInst->SetCHString(IDS_Owner, chstrFullWin32SIDPath);
                                hr = pNewAssocInst->Commit();
                            }
                        }
                    }
                }
            }
        }
    }
    else
    {
        // hr = EnumerateInstances(pMethodContext, lFlags);
        // commented out since some other classes may support exec queries of this type, and returning provider not
        // capable from this class results in some instances (from other classes) being returned, followed by an abort
        // of the enumeration due to this class's returning provider not capable.
    }

#endif

    return hr;
}



HRESULT CWin32LogicalFileOwner::EnumerateInstances(MethodContext*  pMethodContext, long lFlags /*= 0L*/)
{/*
	HRESULT hr = WBEM_S_NO_ERROR;

    if(m_dwPlatformID != VER_PLATFORM_WIN32_NT)
    {
		return(hr);
	}

    TRefPointerCollection<CInstance> LCIMLogicalFiles;

    CHString chstrAllFilesQuery;
    chstrAllFilesQuery = L"SELECT __PATH FROM CIM_LogicalFile";
    if(SUCCEEDED(CWbemProviderGlue::GetInstancesByQuery(chstrAllFilesQuery,
                                                        &LCIMLogicalFiles,
                                                        pMethodContext,
                                                        IDS_CimWin32Namespace)))

    {
        REFPTRCOLLECTION_POSITION pos;
        if(LCIMLogicalFiles.BeginEnum(pos))
        {
            CInstance* pinstCIMLogicalFile = NULL;
            CInstance* pSecSetting = NULL;
            //CInstance* pW32SID = NULL;
            while((SUCCEEDED(hr)) && (pinstCIMLogicalFile = LCIMLogicalFiles.GetNext(pos)))
            {
                if(pinstCIMLogicalFile != NULL)
                {
                    // For each logicalfile instance, need to create an association instance.
                    // For each association instance, need to fill in two properties: Owner and SecuritySetting.

                    // Get and set the SecuritySetting property:
                    // First get the name property of the CIM_LogicalFile instance:
                    CHString chstrCLFName;
                    pinstCIMLogicalFile->GetCHString(IDS_Name, chstrCLFName);
                    CHString chstrDblEscCLFName;
                    EscapeBackslashes(chstrCLFName, chstrDblEscCLFName);
                    CHString chstrLFSSPath;  // LogicalFileSecuritySetting path
                    pSecSetting = NULL;
                    chstrLFSSPath.Format(L"\\\\%s\\%s:Win32_LogicalFileSecuritySetting.Path=\"%s\"",
                                         (LPCTSTR)GetLocalComputerName(),
                                         IDS_CimWin32Namespace,
                                         (LPCTSTR)chstrDblEscCLFName);

                    if(SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath(chstrLFSSPath, &pSecSetting)))
                    {
                        if(pSecSetting != NULL)
                        {
                            CHString chstrSSPath; // SecuritySetting path
                            pSecSetting->GetCHString(IDS_Path, chstrSSPath);
                            if(!chstrSSPath.IsEmpty())
                            {
                                CInstance* pNewAssocInst = CreateNewInstance(pMethodContext);
                                if(pNewAssocInst != NULL)
                                {
                                    // Set the SecuritySetting property of the association instance...
                                    pNewAssocInst->SetCHString(IDS_SecuritySetting, chstrLFSSPath);
                                    // Now set the Owner property...
                                    CSecureFile secFile(chstrSSPath, FALSE);  // don't need SACL
			                        CSid sidOwner;
			                        secFile.GetOwner(sidOwner);
                                    if(sidOwner.IsValid())
                                    {
                                        CHString chstrFullWin32SIDPath;
                                        chstrFullWin32SIDPath.Format(L"\\\\%s\\%s:Win32_SID.SID=\"%s\"",
                                                                     (LPCTSTR)GetLocalComputerName(),
                                                                     IDS_CimWin32Namespace,
                                                                     (LPCTSTR)sidOwner.GetSidString());
                                        pNewAssocInst->SetCHString(IDS_Owner, chstrFullWin32SIDPath);
                                        hr = Commit(pNewAssocInst);
                                    }
                                }
                            }
                            pSecSetting->Release();
                        }
                    }
                    pinstCIMLogicalFile->Release();
                }
            }
            LCIMLogicalFiles.EndEnum();
        }
    }

	return hr;
*/
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\logicalmemory.cpp ===
/////////////////////////////////////////////////////////////////

//

// logmem.cpp -- Implementation of MO Provider for Logical Memory

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  9/03/96     jennymc     Updated to meet current standards
//
/////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <cregcls.h>
#include "logicalmemory.h"
#include "resource.h"
#include "Kernel32Api.h"

typedef BOOL (WINAPI *lpKERNEL32_GlobalMemoryStatusEx) (IN OUT LPMEMORYSTATUSEX lpBuffer);

// Property set declaration
//=========================

CWin32LogicalMemoryConfig win32LogicalMemConfig ( PROPSET_NAME_LOGMEM , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalMemoryConfig::CWin32LogicalMemoryConfig
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32LogicalMemoryConfig :: CWin32LogicalMemoryConfig (

	LPCWSTR strName,
	LPCWSTR pszNamespace

) : Provider ( strName, pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalMemoryConfig::~CWin32LogicalMemoryConfig
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32LogicalMemoryConfig :: ~CWin32LogicalMemoryConfig ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalMemoryConfig::CWin32LogicalMemoryConfig
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

HRESULT CWin32LogicalMemoryConfig :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
	// Find the instance depending on platform id.

	CHString chsKey;
	pInstance->GetCHString ( IDS_Name , chsKey ) ;
	if ( chsKey.CompareNoCase ( L"LogicalMemoryConfiguration" ) == 0 )
    {
#ifdef NTONLY

		hr = RefreshNTInstance ( pInstance ) ? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND ;

#endif

    }

	return hr ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalMemoryConfig::CWin32LogicalMemoryConfig
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

HRESULT CWin32LogicalMemoryConfig :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
	HRESULT hr;

	CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
	// Get the proper OS dependent instance

#ifdef NTONLY
	BOOL fReturn = GetNTInstance ( pInstance ) ;
#endif

	// Commit the instance if'n we got it.

	if ( fReturn )
	{
		hr = pInstance->Commit (  ) ;
	}
    else
    {
        hr = WBEM_E_FAILED;
    }

	return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalMemoryConfig::CWin32LogicalMemoryConfig
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

#ifdef NTONLY

BOOL CWin32LogicalMemoryConfig :: GetNTInstance ( CInstance *pInstance )
{
    AssignMemoryStatus ( pInstance ) ;

    return TRUE;
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalMemoryConfig::CWin32LogicalMemoryConfig
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

#ifdef NTONLY

BOOL CWin32LogicalMemoryConfig :: RefreshNTInstance ( CInstance *pInstance )
{
	// We used to get this value, but we don't appear to be doing
	// anything with it.  Because I'm superstitous, I'm leaving
	// this call in.

    CHString chsTmp;
    GetWinntSwapFileName ( chsTmp ) ;

	AssignMemoryStatus ( pInstance ) ;

    return TRUE;
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalMemoryConfig::CWin32LogicalMemoryConfig
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

void CWin32LogicalMemoryConfig::AssignMemoryStatus( CInstance* pInstance )
{
	// We really only have one logical configuration to concern our little
	// heads with.

    pInstance->SetCharSplat( IDS_Name, L"LogicalMemoryConfiguration" );
	pInstance->SetCharSplat( L"SettingID", L"LogicalMemoryConfiguration" );

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_LogicalMemoryConfiguration);

    pInstance->SetCHString( IDS_Caption,     sTemp2);
	pInstance->SetCHString( IDS_Description, sTemp2);

	// By setting the length, we tell GlobalMemoryStatus()
	// how much info we want
	//====================================================

	MEMORYSTATUS MemoryStatus;
	MemoryStatus.dwLength = sizeof (MEMORYSTATUS);

	// Get the amount of memory both physical and
	// pagefile
	//===========================================
#ifdef NTONLY

	if( IsWinNT5() )
	{
		CKernel32Api* pKernel32 = (CKernel32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidKernel32Api, NULL);
        if(pKernel32 != NULL)
        {
			try
			{
				MEMORYSTATUSEX	stMemoryVLM;
				stMemoryVLM.dwLength = sizeof( MEMORYSTATUSEX );

				BOOL fRet = FALSE;
				if ( pKernel32->GlobalMemoryStatusEx ( &stMemoryVLM, &fRet) && fRet )
				{

   					// Value current in bytes, to convert to k >> 10 (divide by 1024)
					//***************************************************************

					DWORDLONG ullTotalVirtual	= stMemoryVLM.ullTotalVirtual>>10;
					DWORDLONG ullTotalPhys		= stMemoryVLM.ullTotalPhys>>10;
					DWORDLONG ullTotalPageFile	= stMemoryVLM.ullTotalPageFile>>10;
					DWORDLONG ullAvailVirtual	= stMemoryVLM.ullAvailVirtual>>10;

					pInstance->SetDWORD( IDS_TotalVirtualMemory, (DWORD)(stMemoryVLM.ullTotalPhys + stMemoryVLM.ullTotalPageFile ) / 1024 );
					pInstance->SetDWORD( IDS_TotalPhysicalMemory, (DWORD)ullTotalPhys );
					pInstance->SetDWORD( IDS_TotalPageFileSpace, (DWORD)ullTotalPageFile );
					pInstance->SetDWORD( IDS_AvailableVirtualMemory, (DWORD)( stMemoryVLM.ullAvailPhys + stMemoryVLM.ullAvailPageFile ) / 1024 );
				}
			}
			catch ( ... )
			{
				CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidKernel32Api, pKernel32);

				throw ;
			}

			CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidKernel32Api, pKernel32);
			pKernel32 = NULL;

		}
	}
	else
#endif
	{
		GlobalMemoryStatus ( & MemoryStatus );

  		// Value current in bytes, to convert to k >> 10 (divide by 1024)
		//***************************************************************

		pInstance->SetDWORD( IDS_TotalVirtualMemory, ( MemoryStatus.dwTotalPhys + MemoryStatus.dwTotalPageFile )/10 );
		pInstance->SetDWORD( IDS_TotalPhysicalMemory, MemoryStatus.dwTotalPhys>>10 );
		pInstance->SetDWORD( IDS_TotalPageFileSpace, MemoryStatus.dwTotalPageFile>>10 );
		pInstance->SetDWORD( IDS_AvailableVirtualMemory, ( MemoryStatus.dwAvailPhys + MemoryStatus.dwAvailPageFile )/10 );
    }
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalMemoryConfig::CWin32LogicalMemoryConfig
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

#ifdef NTONLY
BOOL CWin32LogicalMemoryConfig :: GetWinntSwapFileName ( CHString &chsTmp )
{
    CRegistry PrimaryReg ;

	BOOL bRet = PrimaryReg.OpenLocalMachineKeyAndReadValue (

		LOGMEM_REGISTRY_KEY,
        PAGING_FILES,
		chsTmp
	) ;

    if ( bRet == ERROR_SUCCESS )
	{
		// keep the text preceeding the space
		int ndex = chsTmp.Find(' ');

		if (ndex != -1)
		{
			chsTmp = chsTmp.Left(ndex);
		}
	}
	else
	{
        LogEnumValueError( _T(__FILE__), __LINE__,PAGING_FILES,LOGMEM_REGISTRY_KEY);
	}

	return bRet ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\logicalmemory.h ===
///////////////////////////////////////////////////////////////////////

//                                                                   

// logicalmemory.h        	

//                                                                  

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//                                                                   
//  9/05/96     jennymc     Updated to meet current standards
//                                                                   
///////////////////////////////////////////////////////////////////////

#define	PROPSET_NAME_LOGMEM	L"Win32_LogicalMemoryConfiguration"

/////////////////////////////////////////////////////////////////////
#define LOGMEM_REGISTRY_KEY L"System\\CurrentControlSet\\Control\\Session Manager\\Memory Management"
#define PAGING_FILES _T("PagingFiles")
#define REFRESH 1
#define INITIAL_ASSIGN 2

class CWin32LogicalMemoryConfig : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32LogicalMemoryConfig(LPCWSTR strName, LPCWSTR pszNamespace ) ;
       ~CWin32LogicalMemoryConfig() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

	private:

        // Utility function(s)
        //====================

        void AssignMemoryStatus( CInstance* pInstance );
        BOOL GetWinntSwapFileName( CHString & chsTmp );
        BOOL GetWin95SwapFileName( CHString & chsTmp );

        BOOL GetWin95Instance( CInstance* pInstance );
        BOOL RefreshWin95Instance( CInstance* pInstance );

        BOOL GetNTInstance( CInstance* pInstance );
        BOOL RefreshNTInstance( CInstance* pInstance );

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\logicalprogramgroup.h ===
//=================================================================

//

// LogicalProgramGroup.h -- Logical Program group property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/19/98 a-kevhu created
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_LOGICALPRGGROUP   L"Win32_LogicalProgramGroup"           


class CWin32LogicalProgramGroup : public Provider
{
    public:

        // Constructor/destructor
        //=======================

        CWin32LogicalProgramGroup(LPCWSTR name, LPCWSTR pszNameSpace);
       ~CWin32LogicalProgramGroup() ;

        // Funcitons provide properties with current values
        //=================================================
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);



    private:
        // Utility function(s)
        //====================

        HRESULT CreateSubDirInstances(LPCTSTR pszUserName,
                                      LPCTSTR pszBaseDirectory,
                                      LPCTSTR pszParentDirectory,
                                      MethodContext* pMethodContext,
                                      bool fOnNTFS) ;

        HRESULT CreateThisDirInstance 
        (
	        LPCTSTR pszUserName,
            LPCTSTR pszBaseDirectory,
            MethodContext *pMethodContext,
            bool fOnNTFS
        );

        HRESULT EnumerateGroupsTheHardWay(MethodContext* pMethodContext) ;

        HRESULT InstanceHardWayGroups(LPCWSTR pszUserName, 
                                      LPCWSTR pszRegistryKeyName,
                                      MethodContext* pMethodContext) ;

        HRESULT SetCreationDate
        (
            CHString &a_chsPGName, 
            CHString &a_chsUserName,
            CInstance *a_pInstance,
            bool fOnNTFS
        );
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\logicalprogramgroupitem.h ===
//=================================================================

//

// LogicalProgramGroupItem.h -- Logical Program group item property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-kevhu       Created
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_LOGICALPRGGROUPITEM   L"Win32_LogicalProgramGroupItem"


class CWin32LogProgramGroupItem : public Provider
{
    public:

        // Constructor/destructor
        //=======================

        CWin32LogProgramGroupItem(LPCWSTR name, LPCWSTR pszNameSpace);
       ~CWin32LogProgramGroupItem() ;

        // Funcitons provide properties with current values
        //=================================================
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);



    private:
        HRESULT QueryForSubItemsAndCommit(CHString& chstrUserAccount,
                                          CHString& chstrQuery,
                                          MethodContext* pMethodContext,
                                          bool fOnNTFS);

        VOID RemoveDoubleBackslashes(CHString& chstring);

		HRESULT SetCreationDate
        (
            CHString &a_chsPGIName, 
            CHString &a_chsUserName,
            CInstance *a_pInstance,
            bool fOnNTFS
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\logicalprogramgroup.cpp ===
//=================================================================

//

// LogicalProgramGroup.CPP -- Logical Program group property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/19/98  a-kevhu created
//
//=================================================================
#include "precomp.h"
#include <cregcls.h>

#include "UserHive.h"
#include <io.h>

#include "LogicalProgramGroup.h"
#include "wbemnetapi32.h"
#include "user.h"
#include <strsafe.h>

// Property set declaration
//=========================
CWin32LogicalProgramGroup MyCWin32LogicalProgramGroupSet ( PROPSET_NAME_LOGICALPRGGROUP , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalProgramGroup::CWin32LogicalProgramGroup
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32LogicalProgramGroup :: CWin32LogicalProgramGroup (

	LPCWSTR name,
	LPCWSTR pszNameSpace

) : Provider ( name , pszNameSpace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalProgramGroup::~CWin32LogicalProgramGroup
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32LogicalProgramGroup :: ~CWin32LogicalProgramGroup ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32LogicalProgramGroup :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
	TRefPointerCollection<CInstance> Groups;


	HRESULT	hr = CWbemProviderGlue :: GetAllInstances (

		PROPSET_NAME_LOGICALPRGGROUP,
		&Groups,
		IDS_CimWin32Namespace,
		pInstance->GetMethodContext ()
	) ;

	if ( SUCCEEDED (hr ) )
	{
		REFPTRCOLLECTION_POSITION pos;

		CInstancePtr pProgramGroupInstance;
		if ( Groups.BeginEnum ( pos ) )
		{
            hr = WBEM_E_NOT_FOUND;

			CHString Name;
			pInstance->GetCHString( IDS_Name , Name);

            // We're going to need to know whether the file system of the drive
            // on which the start menu folder resides is ntfs or not so that
            // we can accurately report the installtime property.
            bool fOnNTFS;
#ifdef NTONLY
            fOnNTFS = true;
            TCHAR tstrRoot[4] = _T("");
            TCHAR tstrFSName[_MAX_PATH] = _T("");
            TCHAR tstrWindowsDir[_MAX_PATH];
            if(GetWindowsDirectory(tstrWindowsDir, sizeof(tstrWindowsDir)/sizeof(TCHAR)))
            {
                _tcsncpy(tstrRoot, tstrWindowsDir, 3);
                GetVolumeInformation(tstrRoot, NULL, 0, NULL, NULL, NULL, tstrFSName, sizeof(tstrFSName)/sizeof(TCHAR));
                if(tstrFSName != NULL && _tcslen(tstrFSName) > 0)
                {
                    if(_tcsicmp(tstrFSName,_T("FAT")) == 0 || _tcsicmp(tstrFSName,_T("FAT32")) == 0)
                    {
                        fOnNTFS = false;
                    }
                }
            }
#endif


            for (pProgramGroupInstance.Attach(Groups.GetNext( pos ));
                 pProgramGroupInstance != NULL;
                 pProgramGroupInstance.Attach(Groups.GetNext( pos )))
			{
				CHString chsCompName ;

				pProgramGroupInstance->GetCHString ( IDS_Name , chsCompName ) ;

				if ( chsCompName.CompareNoCase ( Name ) == 0 )
				{
                    // Parse out the user name

					CHString chsUserName = chsCompName.SpanExcluding ( L":" ) ;
			    	pInstance->SetCHString ( IDS_UserName, chsUserName ) ;

                    // Parse out the group
					int nUserLength = ( chsUserName.GetLength () + 1 ) ;
					int nGroupLength = chsCompName.GetLength() - nUserLength ;

					CHString chsGroupName = chsCompName.Right ( nGroupLength ) ;
					pInstance->SetCHString ( IDS_GroupName, chsGroupName ) ;


                    SetCreationDate(chsGroupName, chsUserName, pInstance, fOnNTFS);

                    CHString chstrTmp2;
                    chstrTmp2.Format(L"Logical program group \"%s\"", (LPCWSTR) Name);
                    pInstance->SetCHString(L"Description" , chstrTmp2) ;
                    pInstance->SetCHString(L"Caption" , chstrTmp2) ;

                    hr = WBEM_S_NO_ERROR ;

                    break;
				}

			}	// WHILE GetNext

			Groups.EndEnum() ;

		}	// IF BeginEnum

	}

	return hr;

}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32LogicalProgramGroup :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
	HRESULT hr = WBEM_E_FAILED;

    CHString sTemp;

    TCHAR szWindowsDir[_MAX_PATH];
    if ( GetWindowsDirectory ( szWindowsDir , sizeof ( szWindowsDir ) / sizeof(TCHAR)) )
    {
		CRegistry RegInfo ;

        // We're going to need to know whether the file system of the drive
        // on which the start menu folder resides is ntfs or not so that
        // we can accurately report the installtime property.
        bool fOnNTFS;
#ifdef NTONLY
        fOnNTFS = true;
        TCHAR tstrRoot[4] = _T("");
        TCHAR tstrFSName[_MAX_PATH] = _T("");
        _tcsncpy(tstrRoot, szWindowsDir, 3);
        GetVolumeInformation(tstrRoot, NULL, 0, NULL, NULL, NULL, tstrFSName, sizeof(tstrFSName)/sizeof(TCHAR));
        if(tstrFSName != NULL && _tcslen(tstrFSName) > 0)
        {
            if(_tcsicmp(tstrFSName,_T("FAT")) == 0 || _tcsicmp(tstrFSName,_T("FAT32")) == 0)
            {
                fOnNTFS = false;
            }
        }
#endif


#ifdef NTONLY
        {
            DWORD dwMajVer = GetPlatformMajorVersion();
            if ( dwMajVer < 4 )
            {
                hr = EnumerateGroupsTheHardWay ( pMethodContext ) ;
            }
            else
            {
                if(dwMajVer >= 5)
                {
                    // Default user doesn't show up under profiles
				    DWORD dwRet = RegInfo.Open (

					    HKEY_LOCAL_MACHINE,
					    _T("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"),
					    KEY_READ
				    ) ;

                    if ( dwRet == ERROR_SUCCESS )
                    {
                        if ( RegInfo.GetCurrentKeyValue ( _T("DefaultUserProfile") , sTemp ) == ERROR_SUCCESS )
                        {
                            CHString sTemp2 ;
                            if ( RegInfo.GetCurrentKeyValue ( _T("ProfilesDirectory") , sTemp2 ) == ERROR_SUCCESS )
                            {
                                // sTemp2 contains something like "%SystemRoot\Profiles%".  Need to expand the environment variable...

                                TCHAR tstrProfileImagePath [ _MAX_PATH ] ;
                                ZeroMemory ( tstrProfileImagePath , sizeof ( tstrProfileImagePath ) ) ;

                                dwRet = ExpandEnvironmentStrings ( sTemp2 , tstrProfileImagePath , _MAX_PATH ) ;
                                if ( dwRet != 0 && dwRet < _MAX_PATH )
                                {
                                    CHString sTemp3 ;
                                    sTemp3.Format (

									    _T("%s\\%s\\%s"),
									    tstrProfileImagePath,
									    sTemp,
									    IDS_Start_Menu
								    ) ;
                                    hr = CreateThisDirInstance(sTemp, sTemp3, pMethodContext, fOnNTFS);
                                    hr = CreateSubDirInstances(

									    sTemp,
									    sTemp3,
									    _T("."),
									    pMethodContext,
                                        fOnNTFS
								    ) ;


                                }
                            }
                        }
						RegInfo.Close();
                    }
				    else
				    {
					    if ( dwRet == ERROR_ACCESS_DENIED )
                        {
						    hr = WBEM_E_ACCESS_DENIED ;
                        }
				    }
                }
                // NT 4 just has to be different...
                if(dwMajVer == 4)
                {
                    DWORD dwRet = RegInfo.Open(HKEY_USERS,
					                           _T(".DEFAULT\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"),
					                           KEY_READ);

                    if(dwRet == ERROR_SUCCESS)
                    {
                        if(RegInfo.GetCurrentKeyValue(_T("Programs"), sTemp) == ERROR_SUCCESS)
                        {
                            // sTemp looks like c:\\winnt\\profiles\\default user\\start menu\\programs.
                            // Don't want the programs dir on the end, so hack it off...
                            int iLastWhackPos = sTemp.ReverseFind(_T('\\'));
                            if(iLastWhackPos > -1)
                            {
                                sTemp = sTemp.Left(iLastWhackPos);
                                // We also want to extract the name of the "Default User" directory...
                                CHString sTemp2;
                                iLastWhackPos = sTemp.ReverseFind(_T('\\'));
                                if(iLastWhackPos > -1)
                                {
                                    sTemp2 = sTemp.Left(iLastWhackPos);
                                    iLastWhackPos = sTemp2.ReverseFind(_T('\\'));
                                    if(iLastWhackPos > -1)
                                    {
                                        sTemp2 = sTemp2.Right(sTemp2.GetLength() - iLastWhackPos -1);
                                        hr = CreateThisDirInstance(sTemp2, sTemp, pMethodContext, fOnNTFS);
                                        hr = CreateSubDirInstances(sTemp2,
							                                       sTemp,
							                                       _T("."),
							                                       pMethodContext,
                                                                   fOnNTFS);


                                    }
                                }
                            }
                        }
						RegInfo.Close();
                    }
				    else
				    {
					    if ( dwRet == ERROR_ACCESS_DENIED )
                        {
						    hr = WBEM_E_ACCESS_DENIED ;
                        }
				    }
                }


                // Neither does All Users.  The following works for all users for both nt 4 and 5.
				DWORD dwRet = RegInfo.Open (

					HKEY_LOCAL_MACHINE,
					_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"),
					KEY_READ
				) ;

                if ( dwRet == ERROR_SUCCESS )
                {
                    if ( RegInfo.GetCurrentKeyValue ( _T("Common Programs") , sTemp ) == ERROR_SUCCESS )
                    {
                        // we do want to start in the Start Menu subdir, not the Programs dir under it
                        int iLastWhackPos = sTemp.ReverseFind(_T('\\'));
                        if(iLastWhackPos > -1)
                        {
                            sTemp = sTemp.Left(iLastWhackPos);

							// We also want to extract the name of the "All Users" directory...
                            CHString sTemp2;
                            iLastWhackPos = sTemp.ReverseFind(_T('\\'));
                            if(iLastWhackPos > -1)
                            {
                                sTemp2 = sTemp.Left(iLastWhackPos);
                                iLastWhackPos = sTemp2.ReverseFind(_T('\\'));
                                if(iLastWhackPos > -1)
                                {
                                    sTemp2 = sTemp2.Right(sTemp2.GetLength() - iLastWhackPos -1);
									hr = CreateThisDirInstance(sTemp2, sTemp, pMethodContext, fOnNTFS);
                                    hr = CreateSubDirInstances(sTemp2,
															   sTemp,
															   _T("."),
															   pMethodContext,
                                                               fOnNTFS);


								}
							}
                        }
                    }
					RegInfo.Close();
                }
				else
				{
					if ( dwRet == ERROR_ACCESS_DENIED )
                    {
						hr = WBEM_E_ACCESS_DENIED ;
                    }
				}


                // Now walk the registry looking for the rest
                CRegistry regProfileList;
				dwRet = regProfileList.OpenAndEnumerateSubKeys (

					HKEY_LOCAL_MACHINE,
					IDS_RegNTProfileList,
					KEY_READ
				) ;

                if ( dwRet == ERROR_SUCCESS )
                {
                    CUserHive UserHive ;
                    CHString strProfile, strUserName, sKeyName2;

		            for ( int i = 0 ; regProfileList.GetCurrentSubKeyName ( strProfile ) == ERROR_SUCCESS ; i++ )
		            {
                        // Try to load the hive.  If the user has been deleted, but the directory
                        // is still there, this will return ERROR_NO_SUCH_USER

		                if ( UserHive.LoadProfile ( strProfile, strUserName ) == ERROR_SUCCESS && 
                            strUserName.GetLength() > 0 )
		                {
                            try
                            {
                                sKeyName2 = strProfile + _T("\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");

                                if(RegInfo.Open(HKEY_USERS, sKeyName2, KEY_READ) == ERROR_SUCCESS)
                                {
                                    if(RegInfo.GetCurrentKeyValue(_T("Programs"), sTemp) == ERROR_SUCCESS)
                                    {
                                        // wack off the "Programs" directory...
                                        int iLastWhackPos = sTemp.ReverseFind(_T('\\'));
                                        if(iLastWhackPos > -1)
                                        {
                                            sTemp = sTemp.Left(iLastWhackPos);
                                            hr = CreateThisDirInstance(strUserName, sTemp, pMethodContext, fOnNTFS);
                                            hr = CreateSubDirInstances(strUserName,
										                               sTemp,
										                               _T("."),
										                               pMethodContext,
                                                                       fOnNTFS);


                                        }
                                    }
                                    RegInfo.Close();
                                }
                            }
                            catch ( ... )
                            {
                                UserHive.Unload(strProfile) ;
                                throw ;
                            }

                            UserHive.Unload(strProfile) ;
                        }
			            regProfileList.NextSubKey();
		            }
		            regProfileList.Close();
                }
				else
				{
					if ( dwRet == ERROR_ACCESS_DENIED )
					{
						hr = WBEM_E_ACCESS_DENIED ;
					}
				}
            }
        }
#endif
    }

    return hr ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalProgramGroup::CreateSubDirInstances
 *
 *  DESCRIPTION : Creates instance of property set for each directory
 *                beneath the one passed in
 *
 *  INPUTS      : pszBaseDirectory    : Windows directory + "Profiles\<user>\Start Menu"
 *                pszParentDirectory  : Parent directory to enumerate
 *
 *  OUTPUTS     : pdwInstanceCount : incremented for each instance created
 *
 *  RETURNS     : Zip
 *
 *  COMMENTS    : Recursive descent thru profile directories
 *
 *****************************************************************************/

HRESULT CWin32LogicalProgramGroup :: CreateSubDirInstances (

	LPCTSTR pszUserName,
    LPCTSTR pszBaseDirectory,
    LPCTSTR pszParentDirectory,
    MethodContext *pMethodContext,
    bool fOnNTFS
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

#if (defined(UNICODE) || defined(_UNICODE))
    WIN32_FIND_DATAW FindData ;
#else
    WIN32_FIND_DATA FindData ;
#endif

    // Put together search spec for this level
    //========================================

	TCHAR szDirSpec[_MAX_PATH] ;
    StringCchPrintf(szDirSpec, _MAX_PATH,_T("%s\\%s\\*.*"), pszBaseDirectory, pszParentDirectory) ;

    // We're also going to need the name of the Start Menu directory (the default
    // is 'Start Menu'; however, the user may have changed it).  pszBaseDirectory
    // contains the name of the Start Menu directory after the final backslash.
    CHString chstrStartMenuDir(pszBaseDirectory);
    chstrStartMenuDir = chstrStartMenuDir.Mid(chstrStartMenuDir.ReverseFind(_T('\\')) + 1);

    // Enumerate subdirectories ( == program groups)
    //==============================================

    SmartFindClose lFindHandle = FindFirstFile(szDirSpec, &FindData) ;
    bool fContinue = true;
    while ( lFindHandle != INVALID_HANDLE_VALUE && SUCCEEDED ( hr ) && fContinue )
    {
        if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY && _tcscmp(FindData.cFileName, _T(".")) && _tcscmp(FindData.cFileName, _T("..")))
        {
            CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
			TCHAR szTemp[_MAX_PATH] ;
			StringCchPrintf(szTemp, _MAX_PATH, _T("%s\\%s"), pszParentDirectory, FindData.cFileName ) ;

			TCHAR *pszGroupName = _tcschr(szTemp, _T('\\')) + 1 ;
            pInstance->SetCHString(L"UserName" , pszUserName);

            CHString chstrTmp;
            chstrTmp.Format(L"%s\\%s", (LPCWSTR)chstrStartMenuDir, (LPCWSTR)TOBSTRT(pszGroupName));
			pInstance->SetCHString(L"GroupName" , chstrTmp);

            chstrTmp.Format(L"%s:%s\\%s", (LPCWSTR)TOBSTRT(pszUserName), (LPCWSTR)chstrStartMenuDir, (LPCWSTR)TOBSTRT(pszGroupName));
			pInstance->SetCHString(L"Name" , chstrTmp) ;

            // How we set it depends on whether we are on NTFS or not.
            if(fOnNTFS)
            {
                pInstance->SetDateTime(IDS_InstallDate, WBEMTime(FindData.ftCreationTime));
            }
            else
            {
                WBEMTime wbt(FindData.ftCreationTime);
                BSTR bstrRealTime = wbt.GetDMTFNonNtfs();
                if((bstrRealTime != NULL) && (SysStringLen(bstrRealTime) > 0))
                {
                    pInstance->SetWCHARSplat(IDS_InstallDate, bstrRealTime);
                    SysFreeString(bstrRealTime);
                }
            }

            CHString chstrTmp2;
            chstrTmp2.Format(L"Logical program group \"%s\"", (LPCWSTR) chstrTmp);
            pInstance->SetCHString(L"Description" , chstrTmp2) ;
            pInstance->SetCHString(L"Caption" , chstrTmp2) ;

			hr = pInstance->Commit (  ) ;

            // Enumerate directories sub to this one
            //======================================

            StringCchPrintf ( szDirSpec, _MAX_PATH, _T("%s\\%s"), pszParentDirectory, FindData.cFileName) ;

            CreateSubDirInstances (

				pszUserName,
				pszBaseDirectory,
				szDirSpec,
				pMethodContext,
                fOnNTFS
			) ;
        }

        fContinue = FindNextFile(lFindHandle, &FindData) ;
    }

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalProgramGroup::CreateThisDirInstance
 *
 *  DESCRIPTION : Creates instance of property set for the directory passed in.
 *
 *  INPUTS      : pszBaseDirectory    : Windows directory + "Profiles\<user>\Start Menu"
 *                pszParentDirectory  : Parent directory to enumerate
 *
 *  OUTPUTS     : pdwInstanceCount : incremented for each instance created
 *
 *  RETURNS     : Zip
 *
 *  COMMENTS    : Recursive descent thru profile directories
 *
 *****************************************************************************/

HRESULT CWin32LogicalProgramGroup :: CreateThisDirInstance
(
	LPCTSTR pszUserName,
    LPCTSTR pszBaseDirectory,
    MethodContext *pMethodContext,
    bool fOnNTFS
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

#if (defined(UNICODE) || defined(_UNICODE))
    WIN32_FIND_DATAW FindData ;
#else
    WIN32_FIND_DATA FindData ;
#endif

    // Put together search spec for this level
    //========================================

	TCHAR szDirSpec[_MAX_PATH] ;
    StringCchPrintf(szDirSpec, _MAX_PATH, _T("%s"), pszBaseDirectory) ;

    // Enumerate subdirectories ( == program groups)
    //==============================================

    SmartFindClose lFindHandle = FindFirstFile(szDirSpec, &FindData) ;
    if( lFindHandle != INVALID_HANDLE_VALUE)
    {
        CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
		TCHAR *pszGroupName = _tcsrchr(pszBaseDirectory, _T('\\')) + 1 ;

		pInstance->SetCHString ( L"UserName" , pszUserName );
		pInstance->SetCHString ( L"GroupName" , pszGroupName );

        CHString chstrTmp;
        chstrTmp.Format(L"%s:%s", (LPCWSTR)TOBSTRT(pszUserName), (LPCWSTR)TOBSTRT(pszGroupName));
		pInstance->SetCHString ( L"Name" , chstrTmp ) ;

        // How we set it depends on whether we are on NTFS or not.
        if(fOnNTFS)
        {
            pInstance->SetDateTime(IDS_InstallDate, WBEMTime(FindData.ftCreationTime));
        }
        else
        {
            WBEMTime wbt(FindData.ftCreationTime);
            BSTR bstrRealTime = wbt.GetDMTFNonNtfs();
            if((bstrRealTime != NULL) && (SysStringLen(bstrRealTime) > 0))
            {
                pInstance->SetWCHARSplat(IDS_InstallDate, bstrRealTime);
                SysFreeString(bstrRealTime);
            }
        }

        CHString chstrTmp2;
        chstrTmp2.Format(L"Logical program group \"%s\"", (LPCWSTR) chstrTmp);
        pInstance->SetCHString(L"Description" , chstrTmp2) ;
        pInstance->SetCHString(L"Caption" , chstrTmp2) ;

		hr = pInstance->Commit ( ) ;

    }

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalProgramGroup::EnumerateGroupsTheHardWay
 *
 *  DESCRIPTION : Creates instances for program groups by drilling into
 *                user profiles
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : dwInstanceCount receives the total number of instances created
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32LogicalProgramGroup :: EnumerateGroupsTheHardWay (

	MethodContext *pMethodContext
)
{
    HRESULT hr = WBEM_E_FAILED;


    // Get default user first
    //=======================

    InstanceHardWayGroups ( L"Default User", L".DEFAULT", pMethodContext) ;

    // Get the users first
    //====================
        // Create instances for each user
    //===============================

	TRefPointerCollection<CInstance> users ;

	hr = CWbemProviderGlue :: GetAllInstances (

		PROPSET_NAME_USER,
		&users,
		IDS_CimWin32Namespace,
		pMethodContext
	) ;

	if ( SUCCEEDED ( hr ) )
	{
		REFPTRCOLLECTION_POSITION pos ;

		if ( users.BeginEnum ( pos ) )
		{
            hr = WBEM_S_NO_ERROR ;

			CUserHive UserHive ;

			CInstancePtr pUser ;

            for (pUser.Attach(users.GetNext ( pos ));
                 pUser != NULL;
                 pUser.Attach(users.GetNext ( pos )))
			{
    				// Look up the user's account info
					//================================

				CHString userName;
				pUser->GetCHString(IDS_Name, userName) ;

				WCHAR szKeyName[_MAX_PATH] ;

				if ( UserHive.Load ( userName , szKeyName, _MAX_PATH ) == ERROR_SUCCESS )
				{
                    try
                    {
    					InstanceHardWayGroups ( userName , szKeyName , pMethodContext ) ;
                    }
                    catch ( ... )
                    {
    					UserHive.Unload ( szKeyName ) ;
                        throw;
                    }

    				UserHive.Unload ( szKeyName ) ;
				}
			}

			users.EndEnum();
		}
	}

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalProgramGroup::InstanceHardWayGroups
 *
 *  DESCRIPTION : Creates instances of program groups for specified user
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : dwInstanceCount receives the total number of instances created
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32LogicalProgramGroup :: InstanceHardWayGroups (

	LPCWSTR pszUserName ,
    LPCWSTR pszRegistryKeyName ,
    MethodContext * pMethodContext
)
{
    HRESULT hr= WBEM_S_NO_ERROR;

    // UNICODE groups
    //===============

    WCHAR szTemp[_MAX_PATH] ;
    StringCchPrintf (
		szTemp ,
        _MAX_PATH,
		L"%s\\%s\\UNICODE Groups",
		pszRegistryKeyName,
		IDS_BASE_REG_KEY
	) ;

    CRegistry Reg ;

	LONG lRet = Reg.Open(HKEY_USERS, szTemp, KEY_READ) ;
    if( lRet == ERROR_SUCCESS)
	{
        for ( DWORD i = 0 ; i < Reg.GetValueCount () && SUCCEEDED(hr); i++)
		{
			WCHAR *pValueName = NULL ;
			BYTE *pValueData = NULL ;

            DWORD dwRetCode = Reg.EnumerateAndGetValues ( i , pValueName , pValueData ) ;
            if ( dwRetCode == ERROR_SUCCESS )
			{
				try
				{
					CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
					pInstance->SetCHString ( L"UserName" , pszUserName ) ;
					pInstance->SetCHString ( L"GroupName", (LPCTSTR) pValueData ) ;
					pInstance->SetCHString ( L"Name", CHString(pszUserName) + CHString(_T(":")) + CHString((TCHAR)pValueData ) );

					hr = pInstance->Commit ( ) ;
				}
				catch ( ... )
				{
					delete [] pValueName ;
					delete [] pValueData ;

					throw ;
				}

				delete [] pValueName ;
				delete [] pValueData ;
			}
        }

        Reg.Close() ;
    }

    // Get the Common Groups
    //======================

    StringCchPrintf (

		szTemp,
        _MAX_PATH,
		L"%s\\%s\\Common Groups",
		pszRegistryKeyName,
		IDS_BASE_REG_KEY
	) ;

	lRet = Reg.Open(HKEY_USERS, szTemp, KEY_READ) ;
    if ( lRet == ERROR_SUCCESS )
	{
        for ( DWORD i = 0 ; i < Reg.GetValueCount() && SUCCEEDED(hr); i++)
		{
			WCHAR *pValueName = NULL ;
			BYTE *pValueData = NULL ;

            DWORD dwRetCode = Reg.EnumerateAndGetValues ( i , pValueName , pValueData ) ;
            if ( dwRetCode == ERROR_SUCCESS )
			{
				try
				{
					// Scan past window coord info (7 decimal #s)
					//===========================================

					WCHAR *c = wcschr ( ( WCHAR * ) pValueData , ' ') ;
					for ( int j = 0 ; j < 6 ; j++ )
					{

						if( c == NULL)
						{
							break ;
						}

						c = wcschr ( c + 1 , ' ' ) ; // L10N OK
					}

					// Check conformance to expected format
					//=====================================

					if ( c != NULL )
					{
						CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
						pInstance->SetCHString ( L"UserName" , pszUserName ) ;
						pInstance->SetCHString ( L"GroupName" , c+1);
						pInstance->SetCHString ( L"Name" , CHString ( pszUserName ) + CHString ( L":" ) + CHString ( c + 1 ) ) ;

						hr = pInstance->Commit (  ) ;
					}
				}
				catch ( ... )
				{
					delete [] pValueName ;
					delete [] pValueData ;

					throw ;
				}

				delete [] pValueName ;
				delete [] pValueData ;
			}
        }

        Reg.Close() ;
    }

	if ( lRet == ERROR_ACCESS_DENIED )
	{
		hr = WBEM_E_ACCESS_DENIED ;
	}

    return hr ;
}


/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalProgramGroup::SetCreationDate
 *
 *  DESCRIPTION : Sets the CreationDate property
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32LogicalProgramGroup::SetCreationDate
(
    CHString &a_chstrPGName,
    CHString &a_chstrUserName,
    CInstance *a_pInstance,
    bool fOnNTFS
)
{
	HRESULT t_hr = WBEM_S_NO_ERROR;
	CHString t_chstrUserNameUpr(a_chstrUserName);
	t_chstrUserNameUpr.MakeUpper();
    CHString t_chstrStartMenuFullPath;
    CHString t_chstrPGFullPath;
	CHString t_chstrDefaultUserName;
	CHString t_chstrAllUsersName;
	CHString t_chstrProfilesDir;
	CHString t_chstrTemp;


#ifdef NTONLY
	bool t_fGotMatchedUser = false;
	CRegistry t_RegInfo;
	TCHAR t_tstrProfileImagePath[_MAX_PATH];
	ZeroMemory(t_tstrProfileImagePath , sizeof(t_tstrProfileImagePath));


#if NTONLY >= 5
    // Default user doesn't show up under profiles
	DWORD t_dwRet = t_RegInfo.Open(HKEY_LOCAL_MACHINE,
								   _T("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"),
								   KEY_READ);

    if(t_dwRet == ERROR_SUCCESS)
    {
        t_RegInfo.GetCurrentKeyValue( _T("DefaultUserProfile") , t_chstrDefaultUserName);
		t_chstrDefaultUserName.MakeUpper();
		if(t_chstrUserNameUpr.Find(t_chstrDefaultUserName) != -1)
		{
			t_fGotMatchedUser = true;

			if(t_RegInfo.GetCurrentKeyValue ( _T("ProfilesDirectory") , t_chstrTemp) == ERROR_SUCCESS)
			{
				// chstrTemp contains something like "%SystemRoot\Profiles%".  Need to expand the environment variable...


				t_dwRet = ExpandEnvironmentStrings( t_chstrTemp , t_tstrProfileImagePath , _MAX_PATH );
				if ( t_dwRet != 0 && t_dwRet < _MAX_PATH )
				{
					t_chstrPGFullPath.Format(_T("%s\\%s\\%s"),
										     t_tstrProfileImagePath,
											 (LPCTSTR)t_chstrDefaultUserName,
											 (LPCTSTR)a_chstrPGName);
				}
			}
		}
		t_RegInfo.Close();
    }
	else
	{
		if(t_dwRet == ERROR_ACCESS_DENIED)
        {
			t_hr = WBEM_E_ACCESS_DENIED;
        }
	}
#endif
#if NTONLY == 4
    // NT 4 just has to be different...
    DWORD t_dwRet = t_RegInfo.Open(HKEY_USERS,
					               _T(".DEFAULT\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"),
					               KEY_READ);

    if(t_dwRet == ERROR_SUCCESS)
    {
        CHString t_chstrProfileImagePath;
		if(t_RegInfo.GetCurrentKeyValue(_T("Programs"), t_chstrProfileImagePath) == ERROR_SUCCESS)
        {
            // sTemp looks like c:\\winnt\\profiles\\default user\\start menu\\programs.
            // Don't want the programs dir on the end, so hack it off...
            int t_iLastWhackPos = t_chstrProfileImagePath.ReverseFind(_T('\\'));
            if(t_iLastWhackPos > -1)
            {
                t_chstrProfileImagePath = t_chstrProfileImagePath.Left(t_iLastWhackPos);
                // We also don't want the "start menu" on the end, so hack it off too...
                t_iLastWhackPos = t_chstrProfileImagePath.ReverseFind(_T('\\'));
                if(t_iLastWhackPos > -1)
                {
                    t_chstrProfileImagePath = t_chstrProfileImagePath.Left(t_iLastWhackPos);
                    // We also want to extract the name of the "Default User" directory...
                    t_iLastWhackPos = t_chstrProfileImagePath.ReverseFind(_T('\\'));
                    if(t_iLastWhackPos > -1)
                    {
                        t_chstrDefaultUserName = t_chstrProfileImagePath.Right(t_chstrProfileImagePath.GetLength() - t_iLastWhackPos -1);
						t_chstrDefaultUserName.MakeUpper();
						if(t_chstrUserNameUpr.Find(t_chstrDefaultUserName) != -1)
						{
							t_fGotMatchedUser = true;
							t_chstrPGFullPath.Format(_T("%s\\%s"),
													 t_chstrProfileImagePath,
													 (LPCTSTR)a_chstrPGName);
						}
                    }
                }
            }
        }
		t_RegInfo.Close();
    }
	else
	{
		if ( t_dwRet == ERROR_ACCESS_DENIED )
        {
			t_hr = WBEM_E_ACCESS_DENIED ;
        }
	}
#endif

    if(!t_fGotMatchedUser)
	{
		// Neither does All Users.  The following works for all users for both nt 4 and 5.
		DWORD t_dwRet = t_RegInfo.Open(HKEY_LOCAL_MACHINE,
									   _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"),
									   KEY_READ);

		if(t_dwRet == ERROR_SUCCESS)
		{
			CHString t_chstrProfileImagePath;
			if(t_RegInfo.GetCurrentKeyValue(_T("Common Programs"), t_chstrProfileImagePath) == ERROR_SUCCESS)
			{
				// we do want to start in the Start Menu subdir, not the Programs dir under it
				int t_iLastWhackPos = t_chstrProfileImagePath.ReverseFind(_T('\\'));
				if(t_iLastWhackPos > -1)
				{
					t_chstrProfileImagePath = t_chstrProfileImagePath.Left(t_iLastWhackPos);
					// We also don't want the "start menu" on the end, so hack it off too...
					t_iLastWhackPos = t_chstrProfileImagePath.ReverseFind(_T('\\'));
					if(t_iLastWhackPos > -1)
					{
						t_chstrProfileImagePath = t_chstrProfileImagePath.Left(t_iLastWhackPos);
                        // We also want to extract the name of the "All Users" directory...
						t_iLastWhackPos = t_chstrProfileImagePath.ReverseFind(_T('\\'));
						if(t_iLastWhackPos > -1)
						{
							t_chstrAllUsersName = t_chstrProfileImagePath.Right(t_chstrProfileImagePath.GetLength() - t_iLastWhackPos -1);
							t_chstrAllUsersName.MakeUpper();
							if(t_chstrUserNameUpr.Find(t_chstrAllUsersName) != -1)
							{
								t_fGotMatchedUser = true;
								t_chstrPGFullPath.Format(_T("%s\\%s"),
														 t_chstrProfileImagePath,
														 (LPCTSTR)a_chstrPGName);
							}
						}
					}
				}
			}
			t_RegInfo.Close();
		}
		else
		{
			if ( t_dwRet == ERROR_ACCESS_DENIED )
			{
				t_hr = WBEM_E_ACCESS_DENIED ;
			}
		}
	}

	if(!t_fGotMatchedUser)
	{
		// Now walk the registry looking for the rest
		CRegistry t_regProfileList;
		DWORD t_dwRet = t_regProfileList.OpenAndEnumerateSubKeys(HKEY_LOCAL_MACHINE,
																 IDS_RegNTProfileList,
																 KEY_READ);

		if(t_dwRet == ERROR_SUCCESS)
		{
			CUserHive t_UserHive ;
			CHString t_chstrProfile, t_chstrUserName, t_chstrKeyName2;

			for(int i = 0; t_regProfileList.GetCurrentSubKeyName(t_chstrProfile) == ERROR_SUCCESS && !t_fGotMatchedUser; i++)
			{
				// Try to load the hive.  If the user has been deleted, but the directory
				// is still there, this will return ERROR_NO_SUCH_USER
				if(t_UserHive.LoadProfile(t_chstrProfile, t_chstrUserName) == ERROR_SUCCESS && 
                            t_chstrUserName.GetLength() > 0 )
				{
				    try
				    {
					    t_chstrUserName.MakeUpper();
					    if(t_chstrUserNameUpr.Find(t_chstrUserName) != -1)
					    {
						    t_fGotMatchedUser = true;
							t_chstrKeyName2 = t_chstrProfile + _T("\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");

							if(t_RegInfo.Open(HKEY_USERS, t_chstrKeyName2, KEY_READ) == ERROR_SUCCESS)
							{
								if(t_RegInfo.GetCurrentKeyValue(_T("Programs"), t_chstrTemp) == ERROR_SUCCESS)
								{
									// wack off the "Programs" directory...
									int t_iLastWhackPos = t_chstrTemp.ReverseFind(_T('\\'));
									if(t_iLastWhackPos > -1)
									{
										t_chstrTemp = t_chstrTemp.Left(t_iLastWhackPos);
                                        // wack off the "start menu" part too...
                                        t_iLastWhackPos = t_chstrTemp.ReverseFind(_T('\\'));
									    if(t_iLastWhackPos > -1)
									    {
										    t_chstrTemp = t_chstrTemp.Left(t_iLastWhackPos);
										    t_chstrPGFullPath.Format(_T("%s\\%s"),
														     t_chstrTemp,
														     (LPCTSTR)a_chstrPGName);
                                        }
									}
								}
								t_RegInfo.Close();
							}
    					}
				    }
				    catch ( ... )
				    {
					    t_UserHive.Unload(t_chstrProfile) ;
					    throw ;
				    }
					t_UserHive.Unload(t_chstrProfile) ;
				}
				t_regProfileList.NextSubKey();
			}
			t_regProfileList.Close();
		}
		else
		{
			if ( t_dwRet == ERROR_ACCESS_DENIED )
			{
				t_hr = WBEM_E_ACCESS_DENIED ;
			}
		}
	}

#endif

	// Finally we can start the real work.  Check that we have the full path
	// to the element...
	if(t_chstrPGFullPath.GetLength() > 0)
	{
		// We have a path.  Open it up and get the creation date...
#if (defined(UNICODE) || defined(_UNICODE))
		WIN32_FIND_DATAW t_FindData ;
#else
		WIN32_FIND_DATA t_FindData ;
#endif

		SmartFindClose lFindHandle = FindFirstFile((LPTSTR)(LPCTSTR)TOBSTRT(t_chstrPGFullPath), &t_FindData) ;

		if(lFindHandle != INVALID_HANDLE_VALUE)
		{
			// How we set it depends on whether we are on NTFS or not.
            if(fOnNTFS)
            {
                a_pInstance->SetDateTime(IDS_InstallDate, WBEMTime(t_FindData.ftCreationTime));
            }
            else
            {
                WBEMTime wbt(t_FindData.ftCreationTime);
                BSTR bstrRealTime = wbt.GetDMTFNonNtfs();
                if((bstrRealTime != NULL) && (SysStringLen(bstrRealTime) > 0))
                {
                    a_pInstance->SetWCHARSplat(IDS_InstallDate, bstrRealTime);
                    SysFreeString(bstrRealTime);
                }
            }
		}
		else
		{
			t_hr = WBEM_E_NOT_FOUND;
		}

    }

    return t_hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\logicalprogramgroupitem.cpp ===
//=================================================================

//

// PrgGroup.CPP -- Program group item property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/19/98   a-kevhu     created
//
//=================================================================
#include "precomp.h"
#include <cregcls.h>

#include "UserHive.h"
#include <io.h>

#include "LogicalProgramGroupItem.h"
#include "LogicalProgramGroup.h"
#include <strsafe.h>

// Property set declaration
//=========================

CWin32LogProgramGroupItem MyCWin32LogProgramGroupItemSet ( PROPSET_NAME_LOGICALPRGGROUPITEM , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogProgramGroupItem::CWin32LogProgramGroupItem
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32LogProgramGroupItem :: CWin32LogProgramGroupItem (

	LPCWSTR name,
	LPCWSTR pszNameSpace

) : Provider ( name , pszNameSpace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogProgramGroupItem::~CWin32LogProgramGroupItem
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32LogProgramGroupItem :: ~CWin32LogProgramGroupItem ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32LogProgramGroupItem::GetObject(CInstance* pInstance, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_E_NOT_FOUND ;

    CHString chstrSuppliedName ;
	pInstance->GetCHString(IDS_Name, chstrSuppliedName);

    CHString chstrSuppliedFilenameExt = chstrSuppliedName.Mid(chstrSuppliedName.ReverseFind(_T('\\'))+1);
    CHString chstrSuppliedProgGrpItemProgGrp = chstrSuppliedName.Left(chstrSuppliedName.ReverseFind(_T('\\')));

    // chstrSuppliedProgGrpItemProgGrp contents need to be double escaped (even though they will get
    // double escaped again below, since they will need to be quadrouple escaped for the query of the association proggroup to dir)

    CHString chstrDblEscSuppliedProgGrpItemProgGrp;
    EscapeBackslashes ( chstrSuppliedProgGrpItemProgGrp , chstrDblEscSuppliedProgGrpItemProgGrp ) ;

    CHString chstrDirAntecedent ;
    chstrDirAntecedent.Format (

		L"\\\\%s\\%s:%s.Name=\"%s\"",
		GetLocalComputerName(),
		IDS_CimWin32Namespace,
		PROPSET_NAME_LOGICALPRGGROUP,
		chstrDblEscSuppliedProgGrpItemProgGrp
	) ;

    CHString chstrDblEscPGName ;
    EscapeBackslashes ( chstrDirAntecedent , chstrDblEscPGName ) ;

    CHString chstrDblEscPGNameAndEscQuotes ;
    EscapeQuotes ( chstrDblEscPGName , chstrDblEscPGNameAndEscQuotes ) ;

    CHString chstrProgGroupDirQuery ;
    chstrProgGroupDirQuery.Format (

		L"SELECT * FROM Win32_LogicalProgramGroupDirectory WHERE Antecedent = \"%s\"",
		chstrDblEscPGNameAndEscQuotes
	);

    TRefPointerCollection<CInstance> GroupDirs;

    HRESULT t_Result = CWbemProviderGlue::GetInstancesByQuery (

		chstrProgGroupDirQuery,
        &GroupDirs,
        pInstance->GetMethodContext(),
        IDS_CimWin32Namespace
	) ;

    if ( SUCCEEDED ( t_Result ) )
    {
		REFPTRCOLLECTION_POSITION pos;

		if(GroupDirs.BeginEnum(pos))
		{
            CHString chstrAntecedent;
            CHString chstrProgroupName;
            CHString chstrDependent;
            CHString chstrFullFileName;

			CInstancePtr pProgramGroupDirInstance;

            // We're going to need to know whether the file system of the drive
            // on which the start menu folder resides is ntfs or not so that
            // we can accurately report the installtime property.
            bool fOnNTFS;
#ifdef NTONLY
            fOnNTFS = true;
            TCHAR tstrRoot[4] = _T("");
            TCHAR tstrFSName[_MAX_PATH] = _T("");
            TCHAR tstrWindowsDir[_MAX_PATH];
            if(GetWindowsDirectory(tstrWindowsDir, sizeof(tstrWindowsDir)/sizeof(TCHAR)))
            {
                _tcsncpy(tstrRoot, tstrWindowsDir, 3);
                GetVolumeInformation(tstrRoot, NULL, 0, NULL, NULL, NULL, tstrFSName, sizeof(tstrFSName)/sizeof(TCHAR));
                if(tstrFSName != NULL && _tcslen(tstrFSName) > 0)
                {
                    if(_tcsicmp(tstrFSName,_T("FAT")) == 0 || _tcsicmp(tstrFSName,_T("FAT32")) == 0)
                    {
                        fOnNTFS = false;
                    }
                }
            }
#endif

            for (pProgramGroupDirInstance.Attach(GroupDirs.GetNext ( pos ));
                 pProgramGroupDirInstance != NULL;
                 pProgramGroupDirInstance.Attach(GroupDirs.GetNext ( pos )))
			{
				pProgramGroupDirInstance->GetCHString ( IDS_Antecedent , chstrAntecedent ) ;
				pProgramGroupDirInstance->GetCHString ( IDS_Dependent , chstrDependent ) ;

				// See if the program group name matches the supplied program group item name minus the filename

                chstrProgroupName = chstrAntecedent.Mid ( chstrAntecedent.Find ( _T('=')) + 2 ) ;

                // The name we were supplied with did not have escaped backslashes, so remove them from the one coming from the antecedent...

                RemoveDoubleBackslashes ( chstrProgroupName ) ;
                chstrProgroupName = chstrProgroupName.Left ( chstrProgroupName.GetLength () - 1 ) ;

                if(chstrSuppliedProgGrpItemProgGrp == chstrProgroupName)
                {
                    // See if there is a file of that name on the file system
                    chstrFullFileName = chstrDependent.Mid ( chstrDependent.Find ( _T('=') ) + 2 ) ;
                    chstrFullFileName = chstrFullFileName.Left ( chstrFullFileName.GetLength () - 1 ) ;
                    RemoveDoubleBackslashes ( chstrFullFileName ) ;

					CHString chstrTemp ;
                    chstrTemp.Format (

						L"%s\\%s",
						chstrFullFileName,
						chstrSuppliedFilenameExt
					) ;

                    HANDLE hFile = CreateFile (

						TOBSTRT(chstrTemp),
						FILE_ANY_ACCESS ,
						FILE_SHARE_READ,
						NULL,
						OPEN_EXISTING,
						0,
						NULL
					) ;

                    if ( hFile != INVALID_HANDLE_VALUE )
                    {
                        hr = WBEM_S_NO_ERROR ;
                        CloseHandle ( hFile ) ;

						// Set the creation date...
						CHString chstrUserName = chstrSuppliedProgGrpItemProgGrp.SpanExcluding(L":");
                        CHString chstrPGIPart = chstrSuppliedProgGrpItemProgGrp.Right(chstrSuppliedProgGrpItemProgGrp.GetLength() - chstrUserName.GetLength() - 1);
                        chstrPGIPart += L"\\";
                        chstrPGIPart += chstrSuppliedFilenameExt;

						SetCreationDate(chstrPGIPart, chstrUserName, pInstance, fOnNTFS);

                        CHString chstrTmp2;
                        chstrTmp2.Format(L"Logical program group item \'%s\\%s\'", (LPCWSTR) chstrProgroupName, (LPCWSTR) chstrSuppliedFilenameExt);
                        pInstance->SetCHString(L"Description" , chstrTmp2) ;
                        pInstance->SetCHString(L"Caption" , chstrTmp2) ;

						break ;
                    }
                }
            }

			GroupDirs.EndEnum();

		}	// IF BeginEnum
	}
	return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32LogProgramGroupItem::EnumerateInstances(MethodContext*  pMethodContext, long lFlags /*= 0L*/)
{
    // Step 1: Get an enumeration of all the ProgramGroupDirectory association class instances

    TRefPointerCollection<CInstance> ProgGroupDirs;

    HRESULT hr = CWbemProviderGlue::GetAllInstances (

		L"Win32_LogicalProgramGroupDirectory",
		&ProgGroupDirs,
		IDS_CimWin32Namespace,
		pMethodContext
	) ;

    if ( SUCCEEDED ( hr ) )
    {
	    REFPTRCOLLECTION_POSITION pos ;
	    if ( ProgGroupDirs.BeginEnum ( pos ) )
	    {
            CHString chstrDependent;
            CHString chstrFullPathName;
            CHString chstrPath;
            CHString chstrDrive;
            CHString chstrAntecedent;
            CHString chstrUserAccount;
            CHString chstrSearchPath;

		    CInstancePtr pProgramGroupDirInstance;

            // We're going to need to know whether the file system of the drive
            // on which the start menu folder resides is ntfs or not so that
            // we can accurately report the installtime property.
            bool fOnNTFS;
#ifdef NTONLY
            fOnNTFS = true;
            TCHAR tstrRoot[4] = _T("");
            TCHAR tstrFSName[_MAX_PATH] = _T("");
            TCHAR tstrWindowsDir[_MAX_PATH];

            if(GetWindowsDirectory(tstrWindowsDir, sizeof(tstrWindowsDir)/sizeof(TCHAR)))
            {
                _tcsncpy(tstrRoot, tstrWindowsDir, 3);
                GetVolumeInformation(tstrRoot, NULL, 0, NULL, NULL, NULL, tstrFSName, sizeof(tstrFSName)/sizeof(TCHAR));
                if(tstrFSName != NULL && _tcslen(tstrFSName) > 0)
                {
                    if(_tcsicmp(tstrFSName,_T("FAT")) == 0 || _tcsicmp(tstrFSName,_T("FAT32")) == 0)
                    {
                        fOnNTFS = false;
                    }
                }
            }
#endif

            for (pProgramGroupDirInstance.Attach(ProgGroupDirs.GetNext ( pos ));
                 (pProgramGroupDirInstance != NULL) && SUCCEEDED ( hr );
                 pProgramGroupDirInstance.Attach(ProgGroupDirs.GetNext ( pos )))
			{
				// Step 2: For each program group, get the drive and path associated on disk with it:

				pProgramGroupDirInstance->GetCHString(IDS_Dependent, chstrDependent);
				chstrFullPathName = chstrDependent.Mid(chstrDependent.Find(_T('='))+1);
				chstrDrive = chstrFullPathName.Mid(1,2);
				chstrPath = chstrFullPathName.Mid(3);
				chstrPath = chstrPath.Left(chstrPath.GetLength() - 1);
				chstrPath += _T("\\\\");

				// Steo 3: For each program group, get the user account it is associated with:

				pProgramGroupDirInstance->GetCHString(IDS_Antecedent, chstrAntecedent);
				chstrUserAccount = chstrAntecedent.Mid(chstrAntecedent.Find(_T('='))+2);
				chstrUserAccount = chstrUserAccount.Left(chstrUserAccount.GetLength() - 1);

				// Step 4: Query that directory for all the CIM_DataFile instances (of any type) it contains:

				chstrSearchPath.Format(L"%s%s",chstrDrive,chstrPath);

				// The user account has the backslashes escaped, which is not correct.  So unescape them:

				RemoveDoubleBackslashes(chstrUserAccount);

				// The function QueryForSubItemsAndCommit needs a search string with single backslashes...

				RemoveDoubleBackslashes(chstrSearchPath);
				hr = QueryForSubItemsAndCommit(chstrUserAccount, chstrSearchPath, pMethodContext, fOnNTFS);

			}

            ProgGroupDirs.EndEnum();
        }
    }

    return hr;
}




/*****************************************************************************
 *
 *  FUNCTION    : QueryForSubItemsAndCommit
 *
 *  DESCRIPTION : Helper to fill property and commit instances of prog group items
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32LogProgramGroupItem :: QueryForSubItemsAndCommit (

	CHString &chstrUserAccount,
    CHString &chstrQuery,
    MethodContext *pMethodContext,
    bool fOnNTFS
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

#ifdef NTONLY
    {
        // we're on NT

        WIN32_FIND_DATAW stFindData;
        ZeroMemory ( & stFindData , sizeof ( stFindData ) ) ;

        _bstr_t bstrtSearchString ( ( LPCTSTR ) chstrQuery ) ;

		WCHAR wstrDriveAndPath[_MAX_PATH];
        hr = StringCchCopy ( wstrDriveAndPath, _MAX_PATH, ( wchar_t * ) bstrtSearchString ) ;

        if(FAILED(hr)) return hr;

        bstrtSearchString += L"*.*" ;

        SmartFindClose hFind = FindFirstFileW (

			( wchar_t * ) bstrtSearchString,
			&stFindData
		) ;

        DWORD dw = GetLastError();
        if ( hFind == INVALID_HANDLE_VALUE || dw != ERROR_SUCCESS )
        {
            hr = WinErrorToWBEMhResult ( dw ) ;
        }

        if ( hr == WBEM_E_ACCESS_DENIED )  // keep going - might have access to others
        {
            hr = WBEM_S_NO_ERROR ;
        }


        do
        {
            if(!(stFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
               (wcscmp(stFindData.cFileName, L".") != 0) &&
               (wcscmp(stFindData.cFileName, L"..") != 0))
            {
                CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                _bstr_t bstrtName((LPCTSTR)chstrUserAccount);
                bstrtName += L"\\";
                bstrtName += stFindData.cFileName;
                pInstance->SetWCHARSplat(IDS_Name, (wchar_t*)bstrtName);

                if(fOnNTFS)
                {
                    pInstance->SetDateTime(IDS_InstallDate, WBEMTime(stFindData.ftCreationTime));
                }
                else
                {
                    WBEMTime wbt(stFindData.ftCreationTime);
                    BSTR bstrRealTime = wbt.GetDMTFNonNtfs();
                    if((bstrRealTime != NULL) && (SysStringLen(bstrRealTime) > 0))
                    {
                        pInstance->SetWCHARSplat(IDS_InstallDate, bstrRealTime);
                        SysFreeString(bstrRealTime);
                    }
                }

                CHString chstrTmp2;
                chstrTmp2.Format(L"Logical program group item \'%s\'", (LPCWSTR) bstrtName);
                pInstance->SetCHString(L"Description" , chstrTmp2) ;
                pInstance->SetCHString(L"Caption" , chstrTmp2) ;

                hr = pInstance->Commit();
            }
            if(hr == WBEM_E_ACCESS_DENIED)  // keep going - might have access to others
            {
                hr = WBEM_S_NO_ERROR;
            }
        }while((FindNextFileW(hFind, &stFindData)) && (SUCCEEDED(hr)));

    }
#endif
    return(hr);
}

/*****************************************************************************
 *
 *  FUNCTION    : RemoveDoubleBackslashes
 *
 *  DESCRIPTION : Helper to change double backslashes to single backslashes
 *
 *  INPUTS      : CHString& containing the string with double backslashes,
 *                which will be changed by this function to the new string.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

VOID CWin32LogProgramGroupItem :: RemoveDoubleBackslashes ( CHString &chstrIn )
{
    CHString chstrBuildString;
    CHString chstrInCopy = chstrIn;

    BOOL fDone = FALSE;
    while ( ! fDone )
    {


	    LONG lPos = chstrInCopy.Find(L"\\\\");
        if(lPos != -1)
        {
            chstrBuildString += chstrInCopy.Left(lPos);
            chstrBuildString += L"\\";

            chstrInCopy = chstrInCopy.Mid(lPos+2);
        }
        else
        {
            chstrBuildString += chstrInCopy;
            fDone = TRUE;
        }
    }

    chstrIn = chstrBuildString;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogProgramGroupItem::SetCreationDate
 *
 *  DESCRIPTION : Sets the CreationDate property
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32LogProgramGroupItem::SetCreationDate
(
    CHString &a_chstrPGIName,
    CHString &a_chstrUserName,
    CInstance *a_pInstance,
    bool fOnNTFS
)
{
	HRESULT t_hr = WBEM_S_NO_ERROR;
	CHString t_chstrUserNameUpr(a_chstrUserName);
	t_chstrUserNameUpr.MakeUpper();
    CHString t_chstrStartMenuFullPath;
    CHString t_chstrPGIFullPath;
	CHString t_chstrDefaultUserName;
	CHString t_chstrAllUsersName;
	CHString t_chstrProfilesDir;
	CHString t_chstrTemp;


#ifdef NTONLY
	bool t_fGotMatchedUser = false;
	CRegistry t_RegInfo;
	TCHAR t_tstrProfileImagePath[_MAX_PATH];
	ZeroMemory(t_tstrProfileImagePath , sizeof(t_tstrProfileImagePath));


#if NTONLY >= 5
    // Default user doesn't show up under profiles
	DWORD t_dwRet = t_RegInfo.Open(HKEY_LOCAL_MACHINE,
								   _T("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"),
								   KEY_READ);

    if(t_dwRet == ERROR_SUCCESS)
    {
        t_RegInfo.GetCurrentKeyValue( _T("DefaultUserProfile") , t_chstrDefaultUserName);
		t_chstrDefaultUserName.MakeUpper();
		if(t_chstrUserNameUpr.Find(t_chstrDefaultUserName) != -1)
		{
			t_fGotMatchedUser = true;

			if(t_RegInfo.GetCurrentKeyValue ( _T("ProfilesDirectory") , t_chstrTemp) == ERROR_SUCCESS)
			{
				// chstrTemp contains something like "%SystemRoot\Profiles%".  Need to expand the environment variable...


				t_dwRet = ExpandEnvironmentStrings( t_chstrTemp , t_tstrProfileImagePath , _MAX_PATH );
				if ( t_dwRet != 0 && t_dwRet < _MAX_PATH )
				{
					t_chstrPGIFullPath.Format(_T("%s\\%s\\%s"),
										     t_tstrProfileImagePath,
											 (LPCTSTR)t_chstrDefaultUserName,
											 (LPCTSTR)a_chstrPGIName);
				}
			}
		}
		t_RegInfo.Close();
    }
	else
	{
		if(t_dwRet == ERROR_ACCESS_DENIED)
        {
			t_hr = WBEM_E_ACCESS_DENIED;
        }
	}
#endif
#if NTONLY == 4
    // NT 4 just has to be different...
    DWORD t_dwRet = t_RegInfo.Open(HKEY_USERS,
					               _T(".DEFAULT\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"),
					               KEY_READ);

    if(t_dwRet == ERROR_SUCCESS)
    {
        CHString t_chstrProfileImagePath;
		if(t_RegInfo.GetCurrentKeyValue(_T("Programs"), t_chstrProfileImagePath) == ERROR_SUCCESS)
        {
            // sTemp looks like c:\\winnt\\profiles\\default user\\start menu\\programs.
            // Don't want the programs dir on the end, so hack it off...
            int t_iLastWhackPos = t_chstrProfileImagePath.ReverseFind(_T('\\'));
            if(t_iLastWhackPos > -1)
            {
                t_chstrProfileImagePath = t_chstrProfileImagePath.Left(t_iLastWhackPos);
                // We also don't want the "start menu" on the end, so hack it off too...
                t_iLastWhackPos = t_chstrProfileImagePath.ReverseFind(_T('\\'));
                if(t_iLastWhackPos > -1)
                {
                    t_chstrProfileImagePath = t_chstrProfileImagePath.Left(t_iLastWhackPos);
                    // We also want to extract the name of the "Default User" directory...
                    t_iLastWhackPos = t_chstrProfileImagePath.ReverseFind(_T('\\'));
                    if(t_iLastWhackPos > -1)
                    {
                        t_chstrDefaultUserName = t_chstrProfileImagePath.Right(t_chstrProfileImagePath.GetLength() - t_iLastWhackPos -1);
						t_chstrDefaultUserName.MakeUpper();
						if(t_chstrUserNameUpr.Find(t_chstrDefaultUserName) != -1)
						{
							t_fGotMatchedUser = true;
							t_chstrPGIFullPath.Format(_T("%s\\%s"),
													 t_chstrProfileImagePath,
													 (LPCTSTR)a_chstrPGIName);
						}
                    }
                }
            }
        }
		t_RegInfo.Close();
    }
	else
	{
		if ( t_dwRet == ERROR_ACCESS_DENIED )
        {
			t_hr = WBEM_E_ACCESS_DENIED ;
        }
	}
#endif

    if(!t_fGotMatchedUser)
	{
		// Neither does All Users.  The following works for all users for both nt 4 and 5.
		DWORD t_dwRet = t_RegInfo.Open(HKEY_LOCAL_MACHINE,
									   _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"),
									   KEY_READ);

		if(t_dwRet == ERROR_SUCCESS)
		{
			CHString t_chstrProfileImagePath;
			if(t_RegInfo.GetCurrentKeyValue(_T("Common Programs"), t_chstrProfileImagePath) == ERROR_SUCCESS)
			{
				// we do want to start in the Start Menu subdir, not the Programs dir under it
				int t_iLastWhackPos = t_chstrProfileImagePath.ReverseFind(_T('\\'));
				if(t_iLastWhackPos > -1)
				{
					t_chstrProfileImagePath = t_chstrProfileImagePath.Left(t_iLastWhackPos);
					// We also don't want the "start menu" on the end, so hack it off too...
                    t_iLastWhackPos = t_chstrProfileImagePath.ReverseFind(_T('\\'));
                    if(t_iLastWhackPos > -1)
                    {
                        t_chstrProfileImagePath = t_chstrProfileImagePath.Left(t_iLastWhackPos);
					    // We also want to extract the name of the "All Users" directory...
					    t_iLastWhackPos = t_chstrProfileImagePath.ReverseFind(_T('\\'));
					    if(t_iLastWhackPos > -1)
					    {
							t_chstrAllUsersName = t_chstrProfileImagePath.Right(t_chstrProfileImagePath.GetLength() - t_iLastWhackPos -1);
							t_chstrAllUsersName.MakeUpper();
							if(t_chstrUserNameUpr.Find(t_chstrAllUsersName) != -1)
							{
								t_fGotMatchedUser = true;
								t_chstrPGIFullPath.Format(_T("%s\\%s"),
														 t_chstrProfileImagePath,
														 (LPCTSTR)a_chstrPGIName);
							}
					    }
                    }
				}
			}
			t_RegInfo.Close();
		}
		else
		{
			if ( t_dwRet == ERROR_ACCESS_DENIED )
			{
				t_hr = WBEM_E_ACCESS_DENIED ;
			}
		}
	}

	if(!t_fGotMatchedUser)
	{
		// Now walk the registry looking for the rest
		CRegistry t_regProfileList;
		DWORD t_dwRet = t_regProfileList.OpenAndEnumerateSubKeys(HKEY_LOCAL_MACHINE,
																 IDS_RegNTProfileList,
																 KEY_READ);

		if(t_dwRet == ERROR_SUCCESS)
		{
			CUserHive t_UserHive ;
			CHString t_chstrProfile, t_chstrUserName, t_chstrKeyName2;

			for(int i = 0; t_regProfileList.GetCurrentSubKeyName(t_chstrProfile) == ERROR_SUCCESS && !t_fGotMatchedUser; i++)
			{
				// Try to load the hive.  If the user has been deleted, but the directory
				// is still there, this will return ERROR_NO_SUCH_USER
				if(t_UserHive.LoadProfile(t_chstrProfile, t_chstrUserName) == ERROR_SUCCESS && 
                            t_chstrUserName.GetLength() > 0 )
				{
					try
					{
					    t_chstrUserName.MakeUpper();
					    if(t_chstrUserNameUpr.Find(t_chstrUserName) != -1)
					    {
						    t_fGotMatchedUser = true;
							t_chstrKeyName2 = t_chstrProfile + _T("\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");

							if(t_RegInfo.Open(HKEY_USERS, t_chstrKeyName2, KEY_READ) == ERROR_SUCCESS)
							{
								if(t_RegInfo.GetCurrentKeyValue(_T("Programs"), t_chstrTemp) == ERROR_SUCCESS)
								{
									// wack off the "Programs" directory...
									int t_iLastWhackPos = t_chstrTemp.ReverseFind(_T('\\'));
									if(t_iLastWhackPos > -1)
									{
										t_chstrTemp = t_chstrTemp.Left(t_iLastWhackPos);
                                        // wack off the "start menu" part too...
                                        t_iLastWhackPos = t_chstrTemp.ReverseFind(_T('\\'));
									    if(t_iLastWhackPos > -1)
									    {
										    t_chstrTemp = t_chstrTemp.Left(t_iLastWhackPos);
										    t_chstrPGIFullPath.Format(_T("%s\\%s"),
														     t_chstrTemp,
														     (LPCTSTR)a_chstrPGIName);
                                        }
									}
								}
								t_RegInfo.Close();
							}
    					}
					}
					catch ( ... )
					{
						t_UserHive.Unload(t_chstrProfile) ;
						throw ;
					}
					t_UserHive.Unload(t_chstrProfile) ;
				}
				t_regProfileList.NextSubKey();
			}
			t_regProfileList.Close();
		}
		else
		{
			if ( t_dwRet == ERROR_ACCESS_DENIED )
			{
				t_hr = WBEM_E_ACCESS_DENIED ;
			}
		}
	}

#endif

	// Finally we can start the real work.  Check that we have the full path
	// to the element...
	if(t_chstrPGIFullPath.GetLength() > 0)
	{
		// We have a path.  Open it up and get the creation date...
#ifdef NTONLY
		WIN32_FIND_DATAW t_stFindData;
        SmartFindClose t_hFind = FindFirstFileW(TOBSTRT(t_chstrPGIFullPath), &t_stFindData) ;
#endif

        DWORD t_dw = GetLastError();
        if (t_hFind == INVALID_HANDLE_VALUE || t_dw != ERROR_SUCCESS)
        {
            t_hr = WinErrorToWBEMhResult(GetLastError());
        }
		else
		{
			// How we set it depends on whether we are on NTFS or not.
            if(fOnNTFS)
            {
                a_pInstance->SetDateTime(IDS_InstallDate, WBEMTime(t_stFindData.ftCreationTime));
            }
            else
            {
                WBEMTime wbt(t_stFindData.ftCreationTime);
                BSTR bstrRealTime = wbt.GetDMTFNonNtfs();
                if((bstrRealTime != NULL) && (SysStringLen(bstrRealTime) > 0))
                {
                    a_pInstance->SetWCHARSplat(IDS_InstallDate, bstrRealTime);
                    SysFreeString(bstrRealTime);
                }
            }
		}
    }

    return t_hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\logicalshareaccess.h ===
//=================================================================

//

// LogicalShareAccess.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef __LOGICALSHAREACCESS_H__
#define __LOGICALSHAREACCESS_H__

#define  LOGICAL_SHARE_ACCESS_NAME L"Win32_LogicalShareAccess"

// provider provided for test provisions
class CWin32LogicalShareAccess: public Provider
{
	public:	
		CWin32LogicalShareAccess(LPCWSTR setName, LPCWSTR pszNamespace );
		~CWin32LogicalShareAccess();

		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags /*= 0L*/);
		virtual HRESULT GetObject( CInstance* pInstance, long lFlags /*= 0L*/ );
		HRESULT CWin32LogicalShareAccess::FillSidInstance(CInstance* pInstance, CSid& sid) ;
		HRESULT CWin32LogicalShareAccess::GetEmptyInstanceHelper(CHString chsClassName, CInstance**ppInstance, MethodContext* pMethodContext ) ;
		HRESULT CWin32LogicalShareAccess::FillProperties(CInstance* pInstance, CAccessEntry& ACE ) ;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\logicalshareaudit.h ===
//=================================================================

//

// LogicalShareAudit.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef __LOGICALSHAREACCESS_H__
#define __LOGICALSHAREACCESS_H__

#define  LOGICAL_SHARE_AUDIT_NAME L"Win32_LogicalShareAuditing"

// provider provided for test provisions
class CWin32LogicalShareAudit: public Provider
{
	public:	
		CWin32LogicalShareAudit(LPCWSTR setName, LPCWSTR pszNamespace );
		~CWin32LogicalShareAudit();

		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags /*= 0L*/);
		virtual HRESULT GetObject( CInstance* pInstance, long lFlags /*= 0L*/ );
		HRESULT CWin32LogicalShareAudit::FillSidInstance(CInstance* pInstance, CSid& sid) ;
		HRESULT CWin32LogicalShareAudit::GetEmptyInstanceHelper(CHString chsClassName, CInstance**ppInstance, MethodContext* pMethodContext ) ;
		HRESULT CWin32LogicalShareAudit::FillProperties(CInstance* pInstance, CAccessEntry& ACE ) ;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\logicalshareaccess.cpp ===
//=================================================================

//

// LogicalShareAccess.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "secureshare.h"
#include "logicalshareaccess.h"


CWin32LogicalShareAccess LogicalShareAccess( LOGICAL_SHARE_ACCESS_NAME, IDS_CimWin32Namespace );

//const LPCTSTR IDS_SecuritySetting		=	"SecuritySetting" ;
//const LPCTSTR IDS_BinaryRepresentation	=	"BinaryRepresentation" ;

/*

    [Dynamic, Provider, Association: ToInstance]
class Win32_LogicalShareAccess : Win32_SecuritySettingAccess
{
    Win32_LogicalShareSecuritySetting ref SecuritySetting;

    Win32_SID ref Trustee;
};

*/

CWin32LogicalShareAccess::CWin32LogicalShareAccess(LPCWSTR setName, LPCWSTR pszNameSpace /*=NULL*/)
:	Provider( setName, pszNameSpace )
{
}

CWin32LogicalShareAccess::~CWin32LogicalShareAccess()
{
}

HRESULT CWin32LogicalShareAccess::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
	HRESULT hr = WBEM_E_NOT_FOUND;
#ifdef NTONLY
	if (pInstance)
	{
		CInstancePtr pLogicalShareSecurityInstance  , pTrustee ;

		// get instance by path on CIM_LogicalFile part
		CHString chsTrusteePath,chsSecuritySettingPath;

		pInstance->GetCHString(IDS_Trustee, chsTrusteePath);
		pInstance->GetCHString(IDS_SecuritySetting, chsSecuritySettingPath);


		MethodContext* pMethodContext = pInstance->GetMethodContext();

		if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chsSecuritySettingPath, &pLogicalShareSecurityInstance, pMethodContext) ) )
		{
			if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chsTrusteePath, &pTrustee, pMethodContext) ) )
			{

				CHString chsShareName ;
				pLogicalShareSecurityInstance->GetCHString(IDS_Name,chsShareName) ;

				CSecureShare secShare(chsShareName);
				CDACL dacl;
				secShare.GetDACL(dacl);

				// walk DACL looking for the sid path passed in....
				ACLPOSITION aclPos;
                // Need merged list...
                CAccessEntryList t_ael;
                if(dacl.GetMergedACL(t_ael))
                {
				    t_ael.BeginEnum(aclPos);
				    CAccessEntry ACE;
				    CSid sidTrustee;

				    while (t_ael.GetNext(aclPos, ACE ))
				    {
					    ACE.GetSID(sidTrustee);
					    //CHString chsTrustee = sidTrustee.GetSidString();
					    CHString chsPath;

					    CInstancePtr pSID ;

			  		    if (SUCCEEDED(GetEmptyInstanceHelper(_T("Win32_SID"), &pSID, pInstance->GetMethodContext() ) ) )
					    {
						    FillSidInstance( pSID, sidTrustee);
						    GetLocalInstancePath(pSID,chsPath) ;

						    if (0 == chsTrusteePath.CompareNoCase(chsPath))
						    {
							    hr = WBEM_S_NO_ERROR;
							    FillProperties(pInstance, ACE) ;
							    break ;
						    }

					    }
				    }//while

				    t_ael.EndEnum(aclPos);
                }
			}

		}
	}
#endif

	return(hr);
}


HRESULT CWin32LogicalShareAccess::EnumerateInstances( MethodContext*  pMethodContext, long lFlags /*= 0L*/ )
{
	HRESULT hr = WBEM_S_NO_ERROR;

#ifdef NTONLY
	TRefPointerCollection<CInstance> SecuritySettingsList;

	hr = CWbemProviderGlue::GetAllInstances(_T("Win32_LogicalShareSecuritySetting"),
											&SecuritySettingsList,
											NULL,
											pMethodContext) ;

	if( SUCCEEDED(hr) )
	{
		REFPTRCOLLECTION_POSITION	pos;
		if( SecuritySettingsList.BeginEnum(pos) )
		{

			CInstancePtr pSetting  ;
			CHString chsShareName ;
			for (	pSetting.Attach ( SecuritySettingsList.GetNext ( pos ) ) ;
					( pSetting != NULL ) && SUCCEEDED ( hr ) ;
					pSetting.Attach ( SecuritySettingsList.GetNext ( pos ) )
				)
			{

				pSetting->GetCHString(IDS_Name, chsShareName);
				CSecureShare secShare(chsShareName);
				CDACL dacl;
				secShare.GetDACL(dacl);

				// walk DACL & create new instance for each ACE....
				ACLPOSITION aclPos;
                // Need merged list...
                CAccessEntryList t_ael;
                if(dacl.GetMergedACL(t_ael))
                {
				    t_ael.BeginEnum(aclPos);
				    CAccessEntry ACE;
				    CSid sidTrustee;

				    while (t_ael.GetNext(aclPos, ACE ) && SUCCEEDED(hr))
				    {
					    ACE.GetSID(sidTrustee);
					    CHString chsPath;
					    CHString chsSettingPath ;
					    CInstancePtr pSID ;

			  		    if (SUCCEEDED(GetEmptyInstanceHelper(_T("Win32_SID"), &pSID, pMethodContext ) ) )
					    {
						    FillSidInstance( pSID, sidTrustee);
						    GetLocalInstancePath(pSID,chsPath) ;

						    GetLocalInstancePath(pSetting,chsSettingPath) ;
						    CInstancePtr pInstance ( CreateNewInstance( pMethodContext ), false ) ;
                            if ( pInstance != NULL )
                            {
						        pInstance->SetCHString(IDS_SecuritySetting, chsSettingPath) ;
						        pInstance->SetCHString(IDS_Trustee, chsPath) ;
						        FillProperties(pInstance, ACE) ;

						        hr = pInstance->Commit () ;
                            }
                            else
                            {
                                hr = WBEM_E_OUT_OF_MEMORY;
                            }
					    }
				    }

				    t_ael.EndEnum(aclPos);
                }
			} //while

			SecuritySettingsList.EndEnum() ;
		}
	} //if( SUCCEEDED(hr) )
#endif

return hr ;

}


HRESULT CWin32LogicalShareAccess::FillSidInstance(CInstance* pInstance, CSid& sid)
{
	HRESULT hr = WBEM_E_NOT_FOUND;

#ifdef NTONLY
	if (sid.IsValid())
	{
		//set the key
		CHString chsSid = sid.GetSidString() ;
		pInstance->SetCHString(IDS_SID, chsSid) ;

		// get account name
		CHString chsAccount = sid.GetAccountName();
		pInstance->SetCHString(IDS_AccountName, chsAccount);

		// get domain name
		CHString chsDomain = sid.GetDomainName();
		pInstance->SetCHString(IDS_ReferencedDomainName, chsDomain);

		PSID pSid = sid.GetPSid();

		// set the UINT8 array for the pSid
		DWORD dwSidLength = sid.GetLength();
//			BYTE bByte;

		SAFEARRAYBOUND rgsabound[1];
		rgsabound[0].cElements = dwSidLength;
		rgsabound[0].lLbound = 0;

		variant_t vValue;
		void* pVoid = NULL ;

        V_ARRAY(&vValue) = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if ( V_ARRAY ( &vValue ) == NULL )
		{
			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}

		V_VT(&vValue) = VT_UI1 | VT_ARRAY;

		// Get a pointer to read the data into
  		SafeArrayAccessData ( V_ARRAY ( &vValue ), &pVoid ) ;
  		memcpy ( pVoid, pSid, rgsabound[0].cElements ) ;
  		SafeArrayUnaccessData ( V_ARRAY ( &vValue ) ) ;

		// Put the safearray into a variant, and send it off
		pInstance->SetVariant(IDS_BinaryRepresentation, vValue);
		CHString chsPath ;
		GetLocalInstancePath(pInstance,chsPath) ;
	}	// end if
#endif
	return(hr);
}

#ifdef NTONLY
HRESULT CWin32LogicalShareAccess::GetEmptyInstanceHelper(CHString chsClassName, CInstance **ppInstance, MethodContext* pMethodContext )
{
 	CHString chsServer ;
	CHString chsPath ;
	HRESULT hr = S_OK ;

	chsServer = GetLocalComputerName() ;

	chsPath = _T("\\\\") + chsServer + _T("\\") + IDS_CimWin32Namespace + _T(":") + chsClassName ;

	CInstancePtr  pClassInstance ;
	if(SUCCEEDED( hr = CWbemProviderGlue::GetInstanceByPath(chsPath, &pClassInstance, pMethodContext) ) )
	{
		IWbemClassObjectPtr pClassObject ( pClassInstance->GetClassObjectInterface(), false ) ;

		IWbemClassObjectPtr piClone = NULL ;
		if(SUCCEEDED(hr = pClassObject->SpawnInstance(0, &piClone) ) )
		{
			*ppInstance = new CInstance ( piClone, pMethodContext ) ;
		}
	}

	return hr ;
}
#endif


#ifdef NTONLY
HRESULT CWin32LogicalShareAccess::FillProperties(CInstance* pInstance, CAccessEntry& ACE )
{

	pInstance->SetDWORD(IDS_AccessMask, ACE.GetAccessMask() ) ;
	pInstance->SetDWORD(IDS_Inheritance, (DWORD) ACE.GetACEFlags() ) ;
	pInstance->SetDWORD(IDS_Type, (DWORD) ACE.GetACEType() ) ;

	return S_OK ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\logicalshareaudit.cpp ===
//=================================================================

//

// LogicalShareAudit.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "secureshare.h"
#include "logicalshareaudit.h"

CWin32LogicalShareAudit LogicalShareAudit( LOGICAL_SHARE_AUDIT_NAME, IDS_CimWin32Namespace );

//const LPCWSTR IDS_SecuritySetting		=	"SecuritySetting" ;
//const LPCWSTR IDS_BinaryRepresentation	=	"BinaryRepresentation" ;

/*

    [Dynamic, Provider("cimwin33"), Association: ToInstance]
class Win32_LogicalShareAuditing : Win32_SecuritySettingAuditing
{
    Win32_LogicalShareSecuritySetting ref SecuritySetting;

    Win32_SID ref Trustee;
};

*/

CWin32LogicalShareAudit::CWin32LogicalShareAudit(LPCWSTR setName, LPCWSTR pszNameSpace /*=NULL*/)
:	Provider( setName, pszNameSpace )
{
}

CWin32LogicalShareAudit::~CWin32LogicalShareAudit()
{
}

HRESULT CWin32LogicalShareAudit::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
	HRESULT hr = WBEM_E_NOT_FOUND;
#ifdef NTONLY
	if (pInstance)
	{
		CInstancePtr pLogicalShareSecurityInstance  , pTrustee ;

		// get instance by path on CIM_LogicalFile part
		CHString chsTrusteePath,chsSecuritySettingPath;

		pInstance->GetCHString(IDS_Trustee, chsTrusteePath);
		pInstance->GetCHString(IDS_SecuritySetting, chsSecuritySettingPath);


		MethodContext* pMethodContext = pInstance->GetMethodContext();

		if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chsSecuritySettingPath, &pLogicalShareSecurityInstance, pMethodContext) ) )
		{
			if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chsTrusteePath, &pTrustee, pMethodContext) ) )
			{

				CHString chsShareName ;
				pLogicalShareSecurityInstance->GetCHString(IDS_Name,chsShareName) ;

				CSecureShare secShare(chsShareName);
				CSACL sacl;
				secShare.GetSACL(sacl);

				// walk DACL looking for the sid path passed in....
				ACLPOSITION aclPos;
                // Need merged list...
                CAccessEntryList t_ael;
                if(sacl.GetMergedACL(t_ael))
                {
				    t_ael.BeginEnum(aclPos);
				    CAccessEntry ACE;
				    CSid sidTrustee;

				    while (t_ael.GetNext(aclPos, ACE ))
				    {
					    ACE.GetSID(sidTrustee);
					    //CHString chsTrustee = sidTrustee.GetSidString();
					    CHString chsPath;

					    CInstancePtr pSID ;

			  		    if (SUCCEEDED(GetEmptyInstanceHelper(L"Win32_SID", &pSID, pInstance->GetMethodContext() ) ) )
					    {
						    FillSidInstance( pSID, sidTrustee);
						    GetLocalInstancePath(pSID,chsPath) ;

						    if (0 == chsTrusteePath.CompareNoCase(chsPath))
						    {
							    hr = WBEM_S_NO_ERROR;
							    FillProperties(pInstance, ACE) ;
							    break ;
						    }

					    }
				    }//while

				    t_ael.EndEnum(aclPos);
                }
			}

		}
	}
#endif

	return(hr);
}


HRESULT CWin32LogicalShareAudit::EnumerateInstances( MethodContext*  pMethodContext, long lFlags /*= 0L*/ )
{
	HRESULT hr = WBEM_S_NO_ERROR;

#ifdef NTONLY
	TRefPointerCollection<CInstance> SecuritySettingsList;

	hr = CWbemProviderGlue::GetAllInstances(_T("Win32_LogicalShareSecuritySetting"),
											&SecuritySettingsList,
											NULL,
											pMethodContext) ;

	if( SUCCEEDED(hr) )
	{
		REFPTRCOLLECTION_POSITION	pos;
		if( SecuritySettingsList.BeginEnum(pos) )
		{

			CInstancePtr pSetting ;
			CHString chsShareName ;
			for (	pSetting.Attach ( SecuritySettingsList.GetNext(pos) ) ;
					( pSetting != NULL ) && SUCCEEDED(hr) ;
					pSetting.Attach ( SecuritySettingsList.GetNext(pos) )
				)
			{

				pSetting->GetCHString(IDS_Name, chsShareName);
				CSecureShare secShare(chsShareName);
				CSACL sacl;
				secShare.GetSACL(sacl);

				// walk DACL & create new instance for each ACE....
				ACLPOSITION aclPos;
                // Need merged list...
                CAccessEntryList t_ael;
                if(sacl.GetMergedACL(t_ael))
                {
				    t_ael.BeginEnum(aclPos);
				    CAccessEntry ACE;
				    CSid sidTrustee;

				    while (t_ael.GetNext(aclPos, ACE ) && SUCCEEDED(hr))
				    {
					    ACE.GetSID(sidTrustee);
					    CHString chsPath;
					    CHString chsSettingPath ;
					    CInstancePtr pSID ;

			  		    if (SUCCEEDED(GetEmptyInstanceHelper(_T("Win32_SID"), &pSID, pMethodContext ) ) )
					    {
						    FillSidInstance( pSID, sidTrustee);
						    GetLocalInstancePath(pSID,chsPath) ;

						    GetLocalInstancePath(pSetting,chsSettingPath) ;
						    CInstancePtr pInstance ( CreateNewInstance( pMethodContext ), false ) ;
                            if(pInstance != NULL)
                            {
						        pInstance->SetCHString(IDS_SecuritySetting, chsSettingPath) ;
						        pInstance->SetCHString(IDS_Trustee, chsPath) ;

						        FillProperties(pInstance, ACE) ;
						        hr = pInstance->Commit () ;
                            }
                            else
                            {
                                hr = WBEM_E_OUT_OF_MEMORY;
                            }

					    }
				    }

				    t_ael.EndEnum(aclPos);
                }
			} //while

			SecuritySettingsList.EndEnum() ;
		}
	} //if( SUCCEEDED(hr) )
#endif

return hr ;

}


#ifdef NTONLY
HRESULT CWin32LogicalShareAudit::FillSidInstance(CInstance* pInstance, CSid& sid)
{
	HRESULT hr = WBEM_E_NOT_FOUND;

	if (sid.IsValid())
	{
		//set the key
		CHString chsSid = sid.GetSidString() ;
		pInstance->SetCHString(IDS_SID, chsSid) ;

		// get account name
		CHString chsAccount = sid.GetAccountName();
		pInstance->SetCHString(IDS_AccountName, chsAccount);

		// get domain name
		CHString chsDomain = sid.GetDomainName();
		pInstance->SetCHString(IDS_ReferencedDomainName, chsDomain);

		PSID pSid = sid.GetPSid();

		// set the UINT8 array for the pSid
		DWORD dwSidLength = sid.GetLength();
//			BYTE bByte;
		SAFEARRAYBOUND rgsabound[1];
		rgsabound[0].cElements = dwSidLength;
		rgsabound[0].lLbound = 0;

		variant_t vValue;
		void* pVoid = NULL ;


		V_ARRAY(&vValue) = SafeArrayCreate(VT_UI1, 1, rgsabound);
		if ( V_ARRAY ( &vValue ) == NULL )
		{
			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}

		V_VT(&vValue) = VT_UI1 | VT_ARRAY;

		     // Get a pointer to read the data into
  		SafeArrayAccessData ( V_ARRAY ( &vValue ), &pVoid ) ;
  		memcpy(pVoid, pSid, rgsabound[0].cElements);
  		SafeArrayUnaccessData ( V_ARRAY ( &vValue ) ) ;

		// Put the safearray into a variant, and send it off
		pInstance->SetVariant(IDS_BinaryRepresentation, vValue);
		CHString chsPath ;
		GetLocalInstancePath(pInstance,chsPath) ;
	}	// end if
	return(hr);
}
#endif

#ifdef NTONLY
HRESULT CWin32LogicalShareAudit::GetEmptyInstanceHelper(CHString chsClassName, CInstance**ppInstance, MethodContext* pMethodContext )
{
	CHString chsServer ;
	CHString chsPath ;
	HRESULT hr = S_OK ;

	chsServer = GetLocalComputerName() ;

	chsPath = _T("\\\\") + chsServer + _T("\\") + IDS_CimWin32Namespace + _T(":") + chsClassName ;

	CInstancePtr pClassInstance ;
	if(SUCCEEDED( hr = CWbemProviderGlue::GetInstanceByPath(chsPath, &pClassInstance, pMethodContext) ) )
	{
		IWbemClassObjectPtr pClassObject( pClassInstance->GetClassObjectInterface(), false ) ;

		IWbemClassObjectPtr piClone = NULL ;
		if(SUCCEEDED(hr = pClassObject->SpawnInstance(0, &piClone) ) )
		{
			*ppInstance = new CInstance(piClone, pMethodContext ) ;
		}
	}

	return hr ;
}
#endif

#ifdef NTONLY
HRESULT CWin32LogicalShareAudit::FillProperties(CInstance* pInstance, CAccessEntry& ACE )
{

	pInstance->SetDWORD(IDS_AccessMask, ACE.GetAccessMask() ) ;
	pInstance->SetDWORD(IDS_Inheritance, (DWORD) ACE.GetACEFlags() ) ;
	pInstance->SetDWORD(IDS_Type, (DWORD) ACE.GetACEType() ) ;

	return S_OK ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\loginprofile.cpp ===
//=================================================================

//

// LogProf.CPP -- Network login profile property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//				04/29/98	a-brads		Hacked Logon Hours
//
//=================================================================
#include "precomp.h"
#include <cregcls.h>

#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>

#include "wbemnetapi32.h"
#include "LoginProfile.h"
#include <time.h>
#include "UserHive.h"
#include "sid.h"
// Property set declaration
//=========================
CWin32NetworkLoginProfile MyCWin32NetworkLoginProfileSet(PROPSET_NAME_USERPROF, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetworkLoginProfile::CWin32NetworkLoginProfile
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32NetworkLoginProfile::CWin32NetworkLoginProfile(LPCWSTR name, LPCWSTR pszNamespace)
: Provider(name, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetworkLoginProfile::~CWin32NetworkLoginProfile
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32NetworkLoginProfile::~CWin32NetworkLoginProfile()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32NetworkLoginProfile::GetObject(CInstance* pInstance, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
	CHString chsKey;

	pInstance->GetCHString(IDS_Name, chsKey);

#ifdef NTONLY
        hr = RefreshInstanceNT(pInstance) ;
#endif
    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32NetworkLoginProfile::EnumerateInstances(MethodContext*  pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT hr = WBEM_E_NOT_FOUND;

#ifdef NTONLY
        hr = EnumInstancesNT(pMethodContext) ;
#endif
    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : EnumInstancesNT
 *
 *  DESCRIPTION : Creates instance for all known local users (NT)
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef NTONLY
HRESULT CWin32NetworkLoginProfile::EnumInstancesNT(MethodContext * pMethodContext)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    NET_API_STATUS nRetCode, nModalRetCode ;
    USER_INFO_3 *pUserInfo = NULL ;
	USER_MODALS_INFO_0 *pUserModal = NULL ;
    CUserHive UserHive;
    CHString chstrProfile;
    CHString chstrUserName;
    CNetAPI32 NetAPI;

	try
	{
		// Get NETAPI32.DLL entry points
		if(NetAPI.Init() == ERROR_SUCCESS)
		{
			nModalRetCode = NetAPI.NetUserModalsGet(NULL, 0, (LPBYTE*) &pUserModal);

			if(nModalRetCode != NERR_Success)
			{
				pUserModal = NULL;
			}

            CRegistry regProfileList;
	        DWORD dwErr = regProfileList.OpenAndEnumerateSubKeys(HKEY_LOCAL_MACHINE,
		                                                         IDS_RegNTProfileList,
		                                                         KEY_READ);

            CHString chstrLocalCompName = GetLocalComputerName();
            // Open the ProfileList key so we know which profiles to load up.
	        if(dwErr == ERROR_SUCCESS)
	        {
                CHString chstrDomainName;
		        for(int i = 0; regProfileList.GetCurrentSubKeyName(chstrProfile) == ERROR_SUCCESS && SUCCEEDED(hr); i++)
		        {
			        // Get user name out of user hive...
                    if((dwErr = UserHive.LoadProfile(chstrProfile, chstrUserName)) == ERROR_SUCCESS)
                    {
                        // Get the logon server from the registry to find
                        // out where we should go to resolve the sid to 
                        // domain/account.  Only bother if we don't have
                        // the username already.
                        if(chstrUserName.GetLength() == 0)
                        {
                            CRegistry regLogonServer;
                            CHString chstrLogonServerKey;
                            CHString chstrLogonServerName;
                        
                            chstrLogonServerKey.Format(
                                L"%s\\Volatile Environment",
                                (LPCWSTR)chstrProfile);

                            if(regLogonServer.Open(HKEY_USERS,
                                chstrLogonServerKey,
                                KEY_READ) == ERROR_SUCCESS)
                            {
                                if(regLogonServer.GetCurrentKeyValue(
                                    L"LOGONSERVER",
                                    chstrLogonServerName) == ERROR_SUCCESS)
                                {
                                    PSID psidUserName = NULL;
                                    try
                                    {
                                        psidUserName = StrToSID(chstrProfile);
                                        if(psidUserName != NULL)
                                        {
                                            CSid sidUserName(psidUserName, chstrLogonServerName);
                                            if(sidUserName.IsValid() && sidUserName.IsOK())
                                            {
                                                chstrUserName = sidUserName.GetAccountName();
                                                chstrUserName += L"\\";
                                                chstrUserName += sidUserName.GetDomainName();
                                            }
                                        }
                                    }
                                    catch(...)
                                    {
                                        if(psidUserName != NULL)
                                        {
                                            ::FreeSid(psidUserName);
                                            psidUserName = NULL;
                                        }
                                        throw;
                                    }
                                    
                                    ::FreeSid(psidUserName);
                                    psidUserName = NULL;
                                }
                            }
                        }
                        
                        // Now get net info on that user...
                        // First break their name into domain and name pieces...
                        int pos = chstrUserName.Find(L'\\');
                        CHString chstrNamePart = chstrUserName.Mid(pos+1);
                        CHString chstrDomainPart = chstrUserName.Left(pos);

                        // If it is not a local profile, then...
                        if(chstrDomainPart.CompareNoCase(chstrLocalCompName) != 0)
                        {
                            GetDomainName(chstrDomainName);

                            // 1) try to get the info off of the dc
                            nRetCode = NetAPI.NetUserGetInfo(chstrDomainName, chstrNamePart, 3, (LPBYTE*) &pUserInfo);
                            // 2) If couldn't get the info from the dc, try the logon server...
                            if(nRetCode != NERR_Success)
                            {
                                GetLogonServer(chstrDomainName);
                                nRetCode = NetAPI.NetUserGetInfo(chstrDomainName, chstrNamePart, 3, (LPBYTE*) &pUserInfo);
                            }
                        }
                        else  // the profile should exist on the local machine, given the name
                        {
                            // If couldn't get the info from the logon server, try the local machine...
                            nRetCode = NetAPI.NetUserGetInfo(NULL, chstrNamePart, 3, (LPBYTE*) &pUserInfo);
                        }

                        // Then fill out their values...
                        if(nRetCode == NERR_Success)
                        {
                            CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                            
                            LoadLogProfValuesForNT(chstrUserName, pUserInfo, pUserModal, pInstance, TRUE);
                            hr = pInstance->Commit();
                        }
                        else
                        {
                            // we couldn't get any details, but we should still commit an instance...
                            CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                          
                            pInstance->SetCHString(_T("Name"), chstrUserName);
                            pInstance->SetCHString(_T("Caption"), chstrUserName);
                            CHString chstrTmp;
                            CHString chstrTmp2 = chstrUserName.SpanExcluding(L"\\");
                            chstrTmp.Format(L"Network login profile settings for %s on %s", (LPCWSTR)chstrNamePart, (LPCWSTR)chstrTmp2);
                            pInstance->SetCHString(_T("Description"), chstrTmp);
                            hr = pInstance->Commit();
                        }
                        UserHive.Unload(chstrProfile);
                    }
			        regProfileList.NextSubKey();
		        }
                regProfileList.Close();
	        }
	        else
	        {
		        hr = WinErrorToWBEMhResult(dwErr);
	        }

		}
	}
	catch ( ... )
	{
		if ( pUserInfo )
		{
			NetAPI.NetApiBufferFree ( pUserInfo ) ;
			pUserInfo = NULL ;
		}

		if ( pUserModal )
		{
			NetAPI.NetApiBufferFree ( pUserModal ) ;
			pUserModal = NULL ;
		}

		throw ;
	}

	if(pUserInfo != NULL)
    {
        NetAPI.NetApiBufferFree(pUserInfo);
        pUserInfo = NULL;
    }

	if(pUserModal != NULL)
	{
		NetAPI.NetApiBufferFree(pUserModal);
		pUserModal = NULL;
	}

	return hr;

}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : RefreshInstanceNT
 *
 *  DESCRIPTION : Loads property values according to key value set by framework
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef NTONLY
HRESULT CWin32NetworkLoginProfile::RefreshInstanceNT(CInstance * pInstance)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    NET_API_STATUS nRetCode, nModalRetCode ;
    USER_INFO_3 *pUserInfo = NULL ;
	USER_MODALS_INFO_0 *pUserModal = NULL ;
    CNetAPI32 NetAPI ;
    CHString Name;
    CUserHive UserHive;
    bool fUserIsInProfiles = false;
    CHString chstrUserName;
    CHStringArray profiles;
    int p;

    pInstance->GetCHString(_T("Name"),Name);

	try
	{
		// First get the names of everyone under the profiles key
        CRegistry regProfileList ;

	    DWORD dwErr = regProfileList.OpenAndEnumerateSubKeys(HKEY_LOCAL_MACHINE,
		                                                     IDS_RegNTProfileList,
		                                                     KEY_READ);

        // Open the ProfileList key so we know which profiles to load up.
	    if ( dwErr == ERROR_SUCCESS )
	    {
		    profiles.SetSize(regProfileList.GetCurrentSubKeyCount(), 5);

		    CHString strProfile ;
		    for(p = 0; regProfileList.GetCurrentSubKeyName(strProfile) == ERROR_SUCCESS; p++)
		    {
			    profiles.SetAt(p, strProfile);
			    regProfileList.NextSubKey();
		    }
		    regProfileList.Close() ;

            // Use the userhive to convert to user names; see if a user in the subkeys matches us...
            int j = profiles.GetSize();
            for(p = 0; p < j && !fUserIsInProfiles; p++)
            {
                dwErr = UserHive.LoadProfile(profiles[p], chstrUserName);
                if(dwErr == ERROR_SUCCESS)
                {
                    // Get the logon server from the registry to find
                    // out where we should go to resolve the sid to 
                    // domain/account.  Only bother if we don't have
                    // the username already.
                    if(chstrUserName.GetLength() == 0)
                    {
                        CRegistry regLogonServer;
                        CHString chstrLogonServerKey;
                        CHString chstrLogonServerName;
                    
                        chstrLogonServerKey.Format(
                            L"%s\\Volatile Environment",
                            (LPCWSTR)profiles[p]);

                        if(regLogonServer.Open(HKEY_USERS,
                            chstrLogonServerKey,
                            KEY_READ) == ERROR_SUCCESS)
                        {
                            if(regLogonServer.GetCurrentKeyValue(
                                L"LOGONSERVER",
                                chstrLogonServerName) == ERROR_SUCCESS)
                            {
                                PSID psidUserName = NULL;
                                try
                                {
                                    psidUserName = StrToSID(profiles[p]);
                                    if(psidUserName != NULL)
                                    {
                                        CSid sidUserName(psidUserName, chstrLogonServerName);
                                        if(sidUserName.IsValid() && sidUserName.IsOK())
                                        {
                                            chstrUserName = sidUserName.GetAccountName();
                                            chstrUserName += L"\\";
                                            chstrUserName += sidUserName.GetDomainName();
                                        }
                                    }
                                }
                                catch(...)
                                {
                                    if(psidUserName != NULL)
                                    {
                                        ::FreeSid(psidUserName);
                                        psidUserName = NULL;
                                    }
                                    throw;
                                }
                                
                                ::FreeSid(psidUserName);
                                psidUserName = NULL;
                            }
                        }
                    }

                    
                    if(chstrUserName.CompareNoCase(Name) == 0)
                    {
                        fUserIsInProfiles = true;
                    }

                    UserHive.Unload(profiles[p]);
                }
            }

            if(fUserIsInProfiles)
            {
                if(NetAPI.Init() == ERROR_SUCCESS)
		        {
   			        nModalRetCode = NetAPI.NetUserModalsGet(NULL, 0, (LPBYTE *) &pUserModal);
			        if (nModalRetCode != NERR_Success)
			        {
				        pUserModal = NULL;
			        }

                    // Now get net info on that user...
                    // First break their name into domain and name pieces...
                    int pos = chstrUserName.Find(L'\\');
                    CHString chstrNamePart = chstrUserName.Mid(pos+1);
                    CHString chstrDomainPart = chstrUserName.Left(pos);
                    CHString chstrDomainName;

                    // If it is not a local profile, then...
                    if(chstrDomainPart.CompareNoCase(GetLocalComputerName()) != 0)
                    {
                        GetDomainName(chstrDomainName);

                        // 1) try to get the info off of the dc
                        nRetCode = NetAPI.NetUserGetInfo(chstrDomainName, chstrNamePart, 3, (LPBYTE*) &pUserInfo);
                        // 2) If couldn't get the info from the dc, try the logon server...
                        if(nRetCode != NERR_Success)
                        {
                            GetLogonServer(chstrDomainName);
                            nRetCode = NetAPI.NetUserGetInfo(chstrDomainName, chstrNamePart, 3, (LPBYTE*) &pUserInfo);
                        }
                    }
                    else  // the profile should exist on the local machine, given the name
                    {
                        // If couldn't get the info from the logon server, try the local machine...
                        nRetCode = NetAPI.NetUserGetInfo(NULL, chstrNamePart, 3, (LPBYTE*) &pUserInfo);
                    }

                    // If we got the logon info, fill it out...
                    if(nRetCode == NERR_Success)
                    {
                        CHString chstrNamePart = Name.Mid(Name.Find(L'\\')+1);
                        if(pUserInfo->usri3_flags & UF_NORMAL_ACCOUNT &&
							(0 == chstrNamePart.CompareNoCase(CHString(pUserInfo->usri3_name))))
                        {
							LoadLogProfValuesForNT(chstrUserName, pUserInfo, pUserModal, pInstance, FALSE);
							pInstance->SetCHString(IDS_Caption, pUserInfo->usri3_name);
							hr = WBEM_S_NO_ERROR;
						}
                    }
                    else
                    {
                        // we couldn't get any details, but we should still commit an instance...
                        pInstance->SetCHString(_T("Name"), chstrUserName);
                        pInstance->SetCHString(_T("Caption"), chstrUserName);
                        CHString chstrTmp;
                        CHString chstrTmp2 = chstrUserName.SpanExcluding(L"\\");
                        chstrTmp.Format(L"Network login profile settings for %s on %s", (LPCWSTR)chstrNamePart, (LPCWSTR)chstrTmp2);
                        pInstance->SetCHString(_T("Description"), chstrTmp);
                        hr = pInstance->Commit();
                    }
                }
            }
        }
	}

	catch ( ... )
	{
		if ( pUserInfo )
		{
			NetAPI.NetApiBufferFree ( pUserInfo ) ;
			pUserInfo = NULL ;
		}

		if ( pUserModal )
		{
			NetAPI.NetApiBufferFree ( pUserModal ) ;
			pUserModal = NULL ;
		}

		throw ;
	}

	if ( pUserInfo )
	{
		NetAPI.NetApiBufferFree ( pUserInfo ) ;
		pUserInfo = NULL ;
	}

    if(pUserModal != NULL)
    {
        NetAPI.NetApiBufferFree(pUserModal);
		pUserModal = NULL;
    }

    return hr;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : LoadLogProfValuesNT
 *
 *  DESCRIPTION : Loads property values according to passed user name
 *
 *  INPUTS      : pUserInfo : pointer to USER_INFO_3 struct
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : zip
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef NTONLY
void CWin32NetworkLoginProfile::LoadLogProfValuesForNT(CHString &chstrUserDomainName,
                                                USER_INFO_3 *pUserInfo,
												USER_MODALS_INFO_0 *pUserModal,
                                                CInstance * pInstance,
                                                BOOL fAssignKey)
{

   TCHAR szBuff[32];

    //========================================================
    // Assign NT properties -- string values are unassigned if
    // NULL or empty
    //========================================================
    if( fAssignKey ){
        //pInstance->SetCHString(_T("Name"), pUserInfo->usri3_name);
        pInstance->SetCHString(_T("Name"), chstrUserDomainName);
	}

    pInstance->SetCHString(_T("Caption"), pUserInfo->usri3_name);

    CHString chstrTemp, chstrTemp2;
    chstrTemp.Format(L"Network login profile settings for %s", pUserInfo->usri3_full_name);
    CHString chstrDomainName = chstrUserDomainName.SpanExcluding(L"\\");
    chstrTemp2.Format(L" on %s", (LPCWSTR)chstrDomainName);
    chstrTemp += chstrTemp2;
    pInstance->SetCHString(IDS_Description,chstrTemp);


    if(pUserInfo->usri3_home_dir && pUserInfo->usri3_home_dir[0]) {
        pInstance->SetCHString(_T("HomeDirectory"),pUserInfo->usri3_home_dir);
    }
	else {
        pInstance->SetCHString(_T("HomeDirectory"),_T(""));
	}

    if(pUserInfo->usri3_comment && pUserInfo->usri3_comment[0]) {
        pInstance->SetCHString(_T("Comment"),pUserInfo->usri3_comment);
    }
	else {
        pInstance->SetCHString(_T("Comment"),_T(""));
	}

    if(pUserInfo->usri3_script_path && pUserInfo->usri3_script_path[0]) {
        pInstance->SetCHString(_T("ScriptPath"),pUserInfo->usri3_script_path);
    }
	else {
        pInstance->SetCHString(_T("ScriptPath"),_T(""));
	}

    if(pUserInfo->usri3_full_name && pUserInfo->usri3_full_name[0]) {
        pInstance->SetCHString(_T("FullName"),pUserInfo->usri3_full_name) ;
    }
	else {
        pInstance->SetCHString(_T("FullName"),_T(""));
	}

    if(pUserInfo->usri3_usr_comment && pUserInfo->usri3_usr_comment[0]) {
        pInstance->SetCHString(_T("UserComment"),pUserInfo->usri3_usr_comment );
    }
	else {
        pInstance->SetCHString(_T("UserComment"),_T(""));
	}

    if(pUserInfo->usri3_workstations && pUserInfo->usri3_workstations[0]) {
        pInstance->SetCHString(_T("Workstations"),pUserInfo->usri3_workstations );
    }
	else {
        pInstance->SetCHString(_T("Workstations"),_T(""));
	}

    if(pUserInfo->usri3_logon_server && pUserInfo->usri3_logon_server[0]) {
        pInstance->SetCHString(_T("LogonServer"),pUserInfo->usri3_logon_server );
    }
	else {
        pInstance->SetCHString(_T("LogonServer"),_T(""));
	}

    if(pUserInfo->usri3_profile && pUserInfo->usri3_profile[0]) {
        pInstance->SetCHString(_T("Profile"),pUserInfo->usri3_profile );
    }
	else {
        pInstance->SetCHString(_T("Profile"),_T(""));
	}

    if(pUserInfo->usri3_parms && pUserInfo->usri3_parms[0]) {
        pInstance->SetCHString(_T("Parameters"),pUserInfo->usri3_parms);
    }
	else {
        pInstance->SetCHString(_T("Parameters"),_T(""));
	}

    if(pUserInfo->usri3_home_dir_drive && pUserInfo->usri3_home_dir_drive[0]) {
        pInstance->SetCHString(_T("HomeDirectoryDrive"),pUserInfo->usri3_home_dir_drive );
    }
	else {
        pInstance->SetCHString(_T("HomeDirectoryDrive"),_T(""));
	}

    if(pUserInfo->usri3_flags & UF_NORMAL_ACCOUNT) {
        pInstance->SetCHString(_T("UserType"),L"Normal Account") ;
    }
    else if(pUserInfo->usri3_flags & UF_TEMP_DUPLICATE_ACCOUNT) {
        pInstance->SetCHString(_T("UserType"),L"Duplicate Account") ;
    }
    else if(pUserInfo->usri3_flags & UF_WORKSTATION_TRUST_ACCOUNT) {
        pInstance->SetCHString(_T("UserType"),L"Workstation Trust Account" );
    }
    else if(pUserInfo->usri3_flags & UF_SERVER_TRUST_ACCOUNT) {
        pInstance->SetCHString(_T("UserType"),L"Server Trust Account") ;
    }
    else if(pUserInfo->usri3_flags & UF_INTERDOMAIN_TRUST_ACCOUNT) {
        pInstance->SetCHString(_T("UserType"),L"Interdomain Trust Account") ;
    }
    else {
        pInstance->SetCHString(_T("UserType"),L"Unknown") ;
    }

#if (defined(UNICODE) || defined(_UNICODE))
    pInstance->SetWBEMINT64(L"MaximumStorage", _i64tow(pUserInfo->usri3_max_storage, szBuff, 10) );
#else
    pInstance->SetWBEMINT64("MaximumStorage", _i64toa(pUserInfo->usri3_max_storage, szBuff, 10) );
#endif
    pInstance->SetDWORD(_T("CountryCode"), pUserInfo->usri3_country_code) ;
    pInstance->SetDWORD(_T("CodePage"), pUserInfo->usri3_code_page) ;
    pInstance->SetDWORD(_T("UserId"), pUserInfo->usri3_user_id );
    pInstance->SetDWORD(_T("PrimaryGroupId"),pUserInfo->usri3_primary_group_id );

	if (0 != pUserInfo->usri3_last_logon)
	{
		pInstance->SetDateTime(_T("LastLogon"), (WBEMTime)pUserInfo->usri3_last_logon );
	}
	else
	{
		pInstance->SetCHString(_T("LastLogon"), StartEndTimeToDMTF(pUserInfo->usri3_last_logon));
	}

	if (0 != pUserInfo->usri3_last_logoff)
	{
		pInstance->SetDateTime(_T("LastLogoff"), (WBEMTime)pUserInfo->usri3_last_logoff );
	}
	else
	{
		pInstance->SetCHString(_T("LastLogoff"), StartEndTimeToDMTF(pUserInfo->usri3_last_logoff));
	}

	time_t timevar = pUserInfo->usri3_acct_expires;

	if (TIMEQ_FOREVER != timevar)
	{
		pInstance->SetDateTime(_T("AccountExpires"), (WBEMTime)pUserInfo->usri3_acct_expires );
	}
//	else
//	{
//		pInstance->SetCHString("AccountExpires", StartEndTimeToDMTF(0));
//	}



    // The following properties are buried in the usri3_flags and usri3_auth_flags
    // fields and should be broken out individually.  Returning the flag values
    // is all but meaningless.
    //============================================================================

//    ScriptExecuted      = pUserInfo->usri3_flags & UF_SCRIPT                ? TRUE  : FALSE ;
//    AccountDisabled     = pUserInfo->usri3_flags & UF_ACCOUNTDISABLE        ? TRUE  : FALSE ;
//    PWRequired          = pUserInfo->usri3_flags & UF_PASSWD_NOTREQD        ? FALSE : TRUE  ;
//    PWUserChangeable    = pUserInfo->usri3_flags & UF_PASSWD_CANT_CHANGE    ? FALSE : TRUE  ;
//    AccountLockOut           = pUserInfo->usri3_flags & UF_LOCKOUT               ? TRUE  : FALSE ;
//    PrintOperator       = pUserInfo->usri3_auth_flags & AF_OP_PRINT         ? TRUE  : FALSE ;
//    ServerOperator      = pUserInfo->usri3_auth_flags & AF_OP_SERVER        ? TRUE  : FALSE ;
//    AccountOperator     = pUserInfo->usri3_auth_flags & AF_OP_ACCOUNTS      ? TRUE  : FALSE ;

    pInstance->SetDWORD(_T("Flags"),pUserInfo->usri3_flags );
    pInstance->SetDWORD(_T("AuthorizationFlags"), pUserInfo->usri3_auth_flags );
//    pInstance->Setbool("PasswordExpires", pUserInfo->usri3_password_expired                 ? TRUE  : FALSE );
	if (pUserModal)
	{
		time_t modaltime, timetoexpire, currenttime, expirationtime;
		timevar = pUserInfo->usri3_password_age;
		modaltime = pUserModal->usrmod0_max_passwd_age;
		if (TIMEQ_FOREVER != modaltime && !(pUserInfo->usri3_flags & UF_DONT_EXPIRE_PASSWD))
		{
			timetoexpire = modaltime - timevar;
			time(&currenttime);
			expirationtime = currenttime + timetoexpire;
			pInstance->SetDateTime(_T("PasswordExpires"), (WBEMTime)expirationtime);
		}
	}

	time_t passwordage = pUserInfo->usri3_password_age;
	if (0 != passwordage)
	{
		if (TIMEQ_FOREVER != passwordage)
		{
            WBEMTimeSpan wts = GetPasswordAgeAsWbemTimeSpan(pUserInfo->usri3_password_age);
            pInstance->SetTimeSpan (_T("PasswordAge"), wts);
		}	// end if
	}
    pInstance->SetDWORD(_T("Privileges"),pUserInfo->usri3_priv);
    pInstance->SetDWORD(_T("UnitsPerWeek"),pUserInfo->usri3_units_per_week);
//    pInstance->SetCHString("Password",pUserInfo->usri3_password) ;

	if (pUserInfo->usri3_logon_hours == NULL)
	{
		pInstance->SetCHString(_T("LogonHours"), _T("Disabled"));
	}
	else
	{
		CHString chsLogonHours;
		GetLogonHoursString(pUserInfo->usri3_logon_hours, chsLogonHours);
		pInstance->SetCHString(_T("LogonHours"), chsLogonHours);
	}	// end else

    pInstance->SetDWORD(_T("BadPasswordCount"),pUserInfo->usri3_bad_pw_count);
    pInstance->SetDWORD(_T("NumberOfLogons"),pUserInfo->usri3_num_logons);
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : EnumInstancesWin9X(MethodContext * pMethodContext)
 *
 *  DESCRIPTION : Creates instance for all known local users (Win95)
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : pdwInstanceCount -- receives count of all instances created
 *
 *  RETURNS     : yes
 *
 *  COMMENTS    :
 *
 *****************************************************************************/


void CWin32NetworkLoginProfile::GetLogonHoursString (PBYTE pLogonHours, CHString& chsProperty)
{
	CHString chsDayString;
	CHString chsTime;
	PBYTE pLogonBytes = pLogonHours;

	// copy the first byte into it's own spot.
	int iSaturdayByte = *pLogonHours;

	// advance the pointer to the first byte of Sunday.
	pLogonBytes++;

	int iBool, iByte, x, i, iBit;
	bool bLimited = false;
	bool bAccessDenied = true;
	DWORD dwByte = *pLogonHours;
	UINT nDayIndex = 0;
	WCHAR* rgDays[7] =
	{
		L"Saturday:",
		L"Sunday:",
		L"Monday:",
		L"Tuesday:",
		L"Wednesday:",
		L"Thursday:",
		L"Friday:"
	};

	int iLogonByte;
	bool rgHours[24];

	for (x=1;x<7 ;x++ )
	{
		// skip saturday until the end
		bLimited = false;
		bAccessDenied = true;
		for (i=0;i<24 ;i++ )
		{
			rgHours[i] = true;
		}

		iBool = 0;
		for (iByte=0; iByte<3; ++iByte)
		{
			iLogonByte = *pLogonBytes++;
			for (iBit=0; iBit<8; ++iBit)
			{
				rgHours[iBool] = iLogonByte & 1;
				iLogonByte >>= 1;
				++iBool;
			}
		}
		chsDayString = _T("");
		chsDayString += rgDays[x];
		chsDayString += _T(" ");

		for (i=0;i<24 ;i++ )
		{
			if (!rgHours[i])
			{
				bLimited = true;
			}
			else
			{
				bAccessDenied = false;
				chsTime = _T("");
				chsTime.Format(L"%d", i);
				chsTime = chsTime + _T("00, ");
				chsDayString += chsTime;
			}
		}
		if (!bLimited)
		{
			chsDayString = _T("");
			chsDayString += rgDays[x];
			chsDayString += _T(" ");
			chsDayString += _T("No Limit");
		}

		if (bAccessDenied)
		{
			chsDayString = _T("");
			chsDayString += rgDays[x];
			chsDayString += _T(" ");
			chsDayString += _T("Access Denied");
		}

		if (x < 7)
			chsDayString += _T(" -- ");

		chsProperty += chsDayString;
	}	// end stepping through week

	// now, we've got to do Saturday
	// step through the first byte ()
	iBool = 0;
//	iLogonByte = *pLogonBytes--;
	for (iByte=1;iByte<3 ;++iByte )
	{
		iLogonByte = *pLogonBytes++;
		for (iBit=0; iBit<8; ++iBit)
		{
			rgHours[iBool] = iLogonByte & 1;
			iLogonByte >>= 1;
			++iBool;
		}
	}

	// now step through the last byte that we held onto at the
	// beginning.
	for (iBit=0;iBit<8 ;++iBit )
	{
		rgHours[iBool] = iSaturdayByte & 1;
		iSaturdayByte >>=1;
		++iBool;
	}	// end for loop for last byte of Saturday

	// now, fill in day string with Saturday data
		chsDayString = _T("");
		chsDayString += rgDays[0];
		chsDayString += _T(" ");
		// reinitialize bLimited for Saturday
		bLimited = false;
		bAccessDenied = true;
		for (i=0;i<24 ;i++ )
		{
			if (!rgHours[i])
			{
				bLimited = true;
			}
			else
			{
				bAccessDenied = false;
				chsTime = _T("");
				chsTime.Format(L"%d", i);
				chsTime = chsTime + _T("00, ");
				chsDayString += chsTime;
			}
		}
		if (!bLimited)
		{
			chsDayString = _T("");
			chsDayString += rgDays[0];
			chsDayString += _T(" ");
			chsDayString += _T("No Limit");
		}

		if (bAccessDenied)
		{
			chsDayString = _T("");
			chsDayString += rgDays[0];
			chsDayString += _T(" ");
			chsDayString += _T("Access Denied");
		}

		chsProperty += chsDayString;
}

// converts the start and end time DWORDS from the USER_INFO_3 to CHStrings
// the dwords APPEAR to be minutes from midnight GMT.
CHString CWin32NetworkLoginProfile::StartEndTimeToDMTF(DWORD time)
{
	CHString gazotta;
	if ((time == 0))
	{
		gazotta = _T("**************.******+***");
	}
	else
	{
		int hour, minute;
		hour = time / 60;
		minute = time % 60;

		/************************
		_tzset();
		long tmptz = _timezone;

		// remove 60 minutes from the timezone if  daylight savings time
		if(_daylight) //NOTE: THIS WILL NOT WORK NEED TO USE tm struct's tm_isdst
		{
			tmptz -= 3600;
		}
		// convert to minutes
		tmptz /= 60;

		// what's your sign?
		char sign = '-';
		if (tmptz < 0)
		{
			tmptz = tmptz * -1;
			sign = '+';
		}
		***************************/

		//gazotta.Format("********%02d%02d00.000000%c%03d", hour, minute, sign, tmptz);
		gazotta.Format(L"********%02d%02d00.000000+000", hour, minute);
	}
	return gazotta;
}

WBEMTimeSpan CWin32NetworkLoginProfile::GetPasswordAgeAsWbemTimeSpan (DWORD dwSeconds)
{
	int nDays = 0;
	int nHours = 0;
	int nMinutes = 0;
	int nSeconds = 0;
	div_t time;

	if (dwSeconds > 60)
	{
		time = div(dwSeconds, 60);
		nMinutes = time.quot;
		nSeconds = time.rem;

		if (nMinutes > 60)
		{
			time = div(nMinutes, 60);
			nHours = time.quot;
			nMinutes = time.rem;

			if (nHours > 24)
			{
				time = div(nHours, 24);
				nDays = time.quot;
				nHours = time.rem;
			}
		}
	}

	// Create a WBEMTimeSpan with the above information
	return WBEMTimeSpan(nDays, nHours, nMinutes, nSeconds, 0, 0, 0);
}


bool CWin32NetworkLoginProfile::GetDomainName(CHString &a_chstrDomainName)
{
    bool t_fRet = false;
#ifdef NTONLY
    CNetAPI32 NetAPI;
    DWORD dwError;
    if(NetAPI.Init() == ERROR_SUCCESS)
    {
#if NTONLY < 5
        LPBYTE lpbBuff = NULL;
        try
        {
            dwError = NetAPI.NetGetDCName(NULL, NULL, &lpbBuff);
        }
        catch(...)
        {
            if(lpbBuff != NULL)
            {
                NetAPI.NetApiBufferFree(lpbBuff);
                lpbBuff = NULL;
            }
            throw;
        }
        if(dwError == NO_ERROR)
        {
            a_chstrDomainName = (LPCWSTR)lpbBuff;
            NetAPI.NetApiBufferFree(lpbBuff);
            lpbBuff = NULL;
            t_fRet = true;
        }

#else
        PDOMAIN_CONTROLLER_INFO pDomInfo = NULL;
        try
        {
            dwError = NetAPI.DsGetDcName(NULL, NULL, NULL, NULL, DS_PDC_REQUIRED, &pDomInfo);
            if(dwError != NO_ERROR)
            {
                dwError = NetAPI.DsGetDcName(NULL, NULL, NULL, NULL, DS_PDC_REQUIRED | DS_FORCE_REDISCOVERY, &pDomInfo);
            }
        }
        catch(...)
        {
            if(pDomInfo != NULL)
            {
                NetAPI.NetApiBufferFree(pDomInfo);
                pDomInfo = NULL;
            }
            throw;
        }
        if(dwError == NO_ERROR)
        {
            a_chstrDomainName = pDomInfo->DomainControllerName;
            NetAPI.NetApiBufferFree(pDomInfo);
            pDomInfo = NULL;
            t_fRet = true;
        }
#endif
    }
#endif
    return t_fRet;
}

#ifdef NTONLY
bool CWin32NetworkLoginProfile::GetLogonServer(CHString &a_chstrLogonServer)
{
    CRegistry RegInfo;
    CHString chstrTemp;
    bool fRet = false;



    DWORD dwRegStat = RegInfo.OpenCurrentUser(
		                           L"Volatile Environment",
		                           KEY_READ);
    if(dwRegStat == ERROR_SUCCESS)
    {
        dwRegStat = RegInfo.GetCurrentKeyValue(L"LOGONSERVER", chstrTemp);
        if(dwRegStat == ERROR_SUCCESS)
        {
            a_chstrLogonServer = chstrTemp;
            fRet = true;
        }
    }
    RegInfo.Close();

    return fRet;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\loginprofile.h ===
//=================================================================

//

// LogProf.h -- Network login profile property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/24/97    jennymc        Moved to new framework
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_USERPROF L"Win32_NetworkLoginProfile"

typedef NET_API_STATUS (WINAPI *FREEBUFF) (LPVOID) ;
typedef NET_API_STATUS (WINAPI *ENUMUSER) (LPWSTR, DWORD, DWORD, LPBYTE *,
                                           DWORD, LPDWORD, LPDWORD, LPDWORD) ;   

class CWin32NetworkLoginProfile : public Provider{

    public:

        // Constructor/destructor
        //=======================

        CWin32NetworkLoginProfile(LPCWSTR name, LPCWSTR pszNamespace);
       ~CWin32NetworkLoginProfile() ;

        // Funcitons provide properties with current values
        //=================================================
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		void GetLogonHoursString (PBYTE pLogonHours, CHString& chsProperty);
		CHString StartEndTimeToDMTF(DWORD time);
		WBEMTimeSpan GetPasswordAgeAsWbemTimeSpan (DWORD dwSeconds);
        bool GetDomainName(CHString &a_chstrDomainName);
        
        // Utility
        //========
    private:
#ifdef NTONLY
        void LoadLogProfValuesForNT(CHString &chstrUserDomainName, USER_INFO_3 *pUserInfo, USER_MODALS_INFO_0 * pUserModal, CInstance * pInstance, BOOL fAssignKey);
        HRESULT RefreshInstanceNT(CInstance * pInstance);
        HRESULT EnumInstancesNT(MethodContext * pMethodContext);
        bool GetLogonServer(CHString &a_chstrLogonServer);
#endif

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\logonsession.cpp ===
//***************************************************************************

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//  LogonSession.cpp
//
//  Purpose: Logon session property set provider
//
//***************************************************************************

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>
//#include <ntlsa.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"
#include <frqueryex.h>

#include <Session.h>
#include "LogonSession.h"
#include "AdvApi32Api.h"
#include "cominit.h"


#define MAX_PROPS			CWin32_LogonSession::e_End_Property_Marker
#define MAX_PROP_IN_BYTES	MAX_PROPS/8 + 1


// Property set declaration
//=========================
CWin32_LogonSession s_Win32_LogonSession( PROPSET_NAME_LOGONSESSION , IDS_CimWin32Namespace ) ;


/*****************************************************************************
 *
 *  FUNCTION    : CWin32_LogonSession::CWin32_LogonSession
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32_LogonSession::CWin32_LogonSession (

LPCWSTR a_Name,
LPCWSTR a_Namespace
)
: Provider(a_Name, a_Namespace)
{
	SetPropertyTable() ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_LogonSession::~CWin32_LogonSession
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32_LogonSession :: ~CWin32_LogonSession()
{
}

//
void CWin32_LogonSession::SetPropertyTable()
{
	// property set names for query optimization
	m_pProps.SetSize( MAX_PROPS ) ;

	// Win32_LogonSession
	m_pProps[e_LogonId]		=(LPVOID) IDS_LogonId;

	// Win32_Session
	m_pProps[e_StartTime]	=(LPVOID) IDS_StartTime ;

	// CIM_ManagedSystemElement
	m_pProps[e_Caption]		=(LPVOID) IDS_Caption ;
	m_pProps[e_Description]	=(LPVOID) IDS_Description ;
	m_pProps[e_InstallDate]	=(LPVOID) IDS_InstallDate ;
	m_pProps[e_Status]		=(LPVOID) IDS_Status ;
}


////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_LogonSession::GetObject
//
//  Inputs:     CInstance*      pInstance - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The calling function will commit the instance.
//
////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
HRESULT CWin32_LogonSession::GetObject(

CInstance *a_pInstance,
long a_Flags,
CFrameworkQuery &a_rQuery
)
{
	HRESULT					t_hResult = WBEM_E_NOT_FOUND ;
	
	CHString				t_chsLogonId ;
	DWORD					t_dwBits ;
	CFrameworkQueryEx		*t_pQuery2 ;
	CUserSessionCollection	t_oSessionColl ;

	// object key
	a_pInstance->GetCHString( IDS_LogonId, t_chsLogonId ) ;
	
	if( !t_chsLogonId.IsEmpty() )
	{					
		//  locate the session 
        // The logonid string could have had non-numeric
        // characters in it.  The _wtoi64 function will
        // convert numeric characters to numbers UNTIL
        // A NON-NUMERIC CHARACTER IS ENCOUNTERED!  This
        // means that "123" will give the same value as
        // "123-foo".  We should reject the latter as an
        // invalid logon it.  Hence the following logic:
        CSession sesTmp;

        if(sesTmp.IsSessionIDValid(t_chsLogonId))
        {
		    __int64 t_i64LuidKey = _wtoi64( t_chsLogonId ) ;

		    if( t_oSessionColl.IsSessionMapped( t_i64LuidKey ) )
		    {
			    // properties required
			    t_pQuery2 = static_cast <CFrameworkQueryEx*>( &a_rQuery ) ;
			    t_pQuery2->GetPropertyBitMask( m_pProps, &t_dwBits ) ;

			    t_hResult = GetSessionInfo(	t_i64LuidKey,
										    a_pInstance,
										    t_dwBits,
                                            t_oSessionColl ) ;
		    }
        }
	}

	return t_hResult ;
}
#endif

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_LogonSession::EnumerateInstances
//
//  Inputs:     MethodContext*  a_pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
HRESULT CWin32_LogonSession::EnumerateInstances(

MethodContext *a_pMethodContext,
long a_Flags
)
{
	// Property mask -- include all
	DWORD t_dwBits = 0xffffffff;

	return EnumerateInstances(	a_pMethodContext,
								a_Flags,
								t_dwBits ) ;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_LogonSession::ExecQuery
 *
 *  DESCRIPTION : Query optimizer
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32_LogonSession::ExecQuery(

MethodContext *a_pMethodContext,
CFrameworkQuery &a_rQuery,
long a_lFlags
)
{
    HRESULT					t_hResult = WBEM_S_NO_ERROR ;
	DWORD					t_dwBits ;
	CFrameworkQueryEx		*t_pQuery2 ;
	std::vector<_bstr_t>	t_vectorReqSessions ;


	// properties required
	t_pQuery2 = static_cast <CFrameworkQueryEx*>( &a_rQuery ) ;
	t_pQuery2->GetPropertyBitMask( m_pProps, &t_dwBits ) ;

	// keys supplied
	a_rQuery.GetValuesForProp( IDS_Name, t_vectorReqSessions ) ;

	// General enum if query is ambigious
	if( !t_vectorReqSessions.size() )
	{
		t_hResult = EnumerateInstances( a_pMethodContext,
										a_lFlags,
										t_dwBits ) ;
	}
	else
	{
		CUserSessionCollection	t_oSessionColl ;

		// smart ptr
		CInstancePtr t_pInst;

	
		// by query list
		for ( UINT t_uS = 0; t_uS < t_vectorReqSessions.size(); t_uS++ )
		{	
			//  locate the session 
			__int64 t_i64LuidKey = _wtoi64( t_vectorReqSessions[t_uS] ) ;
			
			if( t_oSessionColl.IsSessionMapped( t_i64LuidKey ) )
			{
				t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;
					
				t_hResult = GetSessionInfo(	t_i64LuidKey,
											t_pInst,
											t_dwBits,
                                            t_oSessionColl ) ;
				if( SUCCEEDED( t_hResult ) )
				{
					// the key
					t_pInst->SetCHString( 
                        IDS_LogonId, 
                        (wchar_t*)t_vectorReqSessions[t_uS] ) ;

					t_hResult = t_pInst->Commit() ;
				}
			}
		}
	}

    return t_hResult ;
}
#endif

//
#ifdef NTONLY
HRESULT CWin32_LogonSession::EnumerateInstances(

MethodContext	*a_pMethodContext,
long			a_Flags,
DWORD			a_dwProps
)
{
	HRESULT	t_hResult = WBEM_S_NO_ERROR ;
	WCHAR	t_buff[MAXI64TOA] ;
	
	CUserSessionCollection	t_oSessionColl ;
	__int64					t_i64LuidKey ;

	// smart ptr
	CInstancePtr t_pInst ;
    USER_SESSION_ITERATOR sesiter;
    SmartDelete<CSession> pses;

	// emumerate sessions	
	pses = t_oSessionColl.GetFirstSession( sesiter ) ;

	while( pses )
	{								
        t_i64LuidKey = pses->GetLUIDint64();
        t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;
		
		t_hResult = GetSessionInfo(	t_i64LuidKey,
									t_pInst,
									a_dwProps,
                                    t_oSessionColl ) ;

		if( SUCCEEDED( t_hResult ) )
		{
			// the key
			_i64tow( t_i64LuidKey, t_buff, 10 ) ;		
			t_pInst->SetCHString( IDS_LogonId, t_buff ) ;

			t_hResult = t_pInst->Commit() ;
		}
		else
		{
			break ;
		}

		pses = t_oSessionColl.GetNextSession( sesiter ) ;
	}

	return t_hResult ;
}
#endif

//
#ifdef NTONLY
HRESULT CWin32_LogonSession::GetSessionInfo(

__int64		i64LUID,
CInstance	*pInst,
DWORD		dwProps,
CUserSessionCollection& usc
)
{
	HRESULT	t_hResult = WBEM_S_NO_ERROR ;

	// REVIEW: the following for population
	
	//	e_StartTime, IDS_StartTime
	//	e_InstallDate, IDS_InstallDate
	//	e_Status, IDS_Status;
	//  e_Name, IDS_Name;
	//  e_Caption, IDS_Caption ;
	//  e_Description, IDS_Description ;

    SmartDelete<CSession> sesPtr;

    sesPtr = usc.FindSession(
        i64LUID);

    if(sesPtr)
    {
        // Load Authentication package...
        pInst->SetCHString(
            IDS_AuthenticationPackage,
            sesPtr->GetAuthenticationPkg());

        // Load Logontype...
        pInst->SetDWORD(
            IDS_LogonType,
            sesPtr->GetLogonType());

        // Load LogonTime...
        __int64 i64LogonTime = 
            sesPtr->GetLogonTime();

        FILETIME* ft = 
            static_cast<FILETIME*>(
                static_cast<PVOID>(&i64LogonTime));

        pInst->SetDateTime(
            IDS_StartTime,
            *ft);
    }

	return t_hResult ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\logonsession.h ===
//***************************************************************************

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//  LogonSession.h
//
//  Purpose: Logon session property set provider
//
//***************************************************************************

#ifndef _LOGON_SESSION_H
#define _LOGON_SESSION_H

// into strings.h
extern LPCWSTR IDS_LogonId ;
extern LPCWSTR IDS_StartTime ;

//==================================
#define  PROPSET_NAME_LOGONSESSION      L"Win32_LogonSession"
#define  METHOD_NAME_TERMINATESESSION   L"TerminateSession"
#define  METHOD_ARG_NAME_RETURNVALUE	L"ReturnValue"


#define WIN32_LOGOFFOPTIONS (EWX_FORCE | EWX_FORCEIFHUNG)



// PROPERTY SET
//=============
class CWin32_LogonSession: public Provider
{
private:

	// property names 
    CHPtrArray m_pProps ;

	void SetPropertyTable() ; 
    
	HRESULT CWin32_LogonSession::GetSessionInfo(

		__int64		a_LUID,
		CInstance	*a_pInst,
		DWORD		a_dwProps,
        CUserSessionCollection& usc
	) ;

	HRESULT EnumerateInstances(

		MethodContext	*a_pMethodContext,
		long			a_Flags,
		DWORD			a_dwProps
	) ;



public:

    // Constructor/destructor
    //=======================

    CWin32_LogonSession( LPCWSTR a_Name, LPCWSTR a_Namespace ) ;
   ~CWin32_LogonSession() ;

    // Functions that provide properties with current values
    //======================================================

    HRESULT GetObject ( 
		
		CInstance *a_Instance,
		long a_Flags,
		CFrameworkQuery &a_rQuery
	) ;

    HRESULT EnumerateInstances ( 

		MethodContext *a_pMethodContext, 
		long a_Flags = 0L 
	) ;


	HRESULT ExecQuery ( 

		MethodContext *a_pMethodContext, 
		CFrameworkQuery &a_rQuery, 
		long a_Flags = 0L
	) ;

    

	// Property offset defines
	enum ePropertyIDs { 
		e_LogonId,						// Win32_LogonSession
		e_StartTime,					// Win32_Session
		e_Caption,						// CIM_ManagedSystemElement						
		e_Description,
		e_InstallDate,
		e_Name,						
		e_Status,
		e_End_Property_Marker,			// end marker
		e_32bit = 32					// gens compiler error if additions to this set >= 32 
	};
};

#endif // _LOGON_SESSION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\maindll.cpp ===
///***************************************************************************
//
//  MAINDLL.CPP
//
//  Module: WBEM Framework Instance provider
//
//  Purpose: Contains DLL entry points.  Also has code that controls
//           when the DLL can be unloaded by tracking the number of
//           objects and locks as well as routines that support
//           self registration.
//
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <dllunreg.h>
#include <DllCommon.h>
#include <initguid.h>
#include "FactoryRouter.h"
#include "ResourceManager.h"
#include "timerqueue.h"
#include <powermanagement.h>
#include <systemconfigchange.h>
#ifdef NTONLY
#include "ntlastboottime.h"
#include <diskguid.h>
#endif

HMODULE ghModule;

// {d63a5850-8f16-11cf-9f47-00aa00bf345c}
DEFINE_GUID(CLSID_CimWinProvider,
0xd63a5850, 0x8f16, 0x11cf, 0x9f, 0x47, 0x0, 0xaa, 0x0, 0xbf, 0x34, 0x5c);
// {3DD82D10-E6F1-11d2-B139-00105A1F77A1}
DEFINE_GUID(CLSID_PowerEventProvider,0x3DD82D10, 0xE6F1, 0x11d2, 0xB1, 0x39, 0x0, 0x10, 0x5A, 0x1F, 0x77, 0xA1);
// {D31B6A3F-9350-40de-A3FC-A7EDEB9B7C63}
DEFINE_GUID(CLSID_SystemConfigChangeEventProvider, 
0xd31b6a3f, 0x9350, 0x40de, 0xa3, 0xfc, 0xa7, 0xed, 0xeb, 0x9b, 0x7c, 0x63);
#define PROVIDER_NAME L"CimWin32"

// initialize class globals
CFactoryRouterData          g_FactoryRouterData;
CPowerEventFactory*         gp_PowerEventFactory = NULL;
CSystemConfigChangeFactory* gp_SystemConfigChangeFactory = NULL;

CTimerQueue CTimerQueue :: s_TimerQueue ;
CResourceManager CResourceManager::sm_TheResourceManager ;

//Count number of objects and number of locks.
long g_cLock = 0;

//
// resource management failures
//
extern BOOL bAddInstanceCreatorFailure ;

//
// initialization flags
//

BOOL g_bEventFactoriesInit = FALSE ;
BOOL g_bCritSecInit = FALSE ;

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr = S_OK;

    try
    {
        if ( CLSID_CimWinProvider == rclsid )
        {
            hr = CommonGetClassObject(riid, ppv, PROVIDER_NAME, g_cLock);
        }
        else
        {
            hr = g_FactoryRouterData.DllGetClassObject( rclsid, riid, ppv );
        }
    }
    catch ( ... )
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow()
{
    SCODE sc = S_FALSE;

    try
    {
        // It is OK to unload if there are no locks on the
        // class factory and the framework allows us to go.
        if (g_FactoryRouterData.DllCanUnloadNow())
        {
            sc = CommonCanUnloadNow(PROVIDER_NAME, g_cLock);
        }

        if ( sc == S_OK )
        {
            CTimerQueue::s_TimerQueue.OnShutDown();
            CResourceManager::sm_TheResourceManager.ForcibleCleanUp () ;

        }
    }
    catch ( ... )
    {
        // sc should already be set correctly
    }

    return sc;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{
    HRESULT t_status = S_OK;

    try
    {
        t_status = RegisterServer( _T("WBEM Framework Instance Provider"), CLSID_CimWinProvider ) ;
        if( NOERROR == t_status )
        {
            t_status = g_FactoryRouterData.DllRegisterServer() ;
        }
    }
    catch ( ... )
    {
        t_status = E_OUTOFMEMORY;
    }

    return t_status ;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    HRESULT t_status = S_OK;

    try
    {
        t_status = UnregisterServer( CLSID_CimWinProvider ) ;
        if( NOERROR == t_status )
        {
            t_status = g_FactoryRouterData.DllUnregisterServer() ;
        }
    }
    catch ( ... )
    {
        t_status = E_OUTOFMEMORY;
    }

    return t_status ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL InitializeEventFactories(void)
{
	BOOL fRet = FALSE;

	gp_PowerEventFactory = new CPowerEventFactory( CLSID_PowerEventProvider, POWER_EVENT_CLASS ) ;
	if( gp_PowerEventFactory )
	{
		gp_SystemConfigChangeFactory = new CSystemConfigChangeFactory(CLSID_SystemConfigChangeEventProvider, SYSTEM_CONFIG_EVENT) ;
		if( gp_SystemConfigChangeFactory )
		{
			fRet = TRUE;
		}
	}
	return fRet;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
void CleanupEventFactories(void)
{
	if( gp_PowerEventFactory )
	{
		delete gp_PowerEventFactory;
		gp_PowerEventFactory = NULL;
	}
	if( gp_SystemConfigChangeFactory )
	{
		delete gp_SystemConfigChangeFactory;
		gp_SystemConfigChangeFactory = NULL;
	}
}
//***************************************************************************
//
// DllMain
//
// Purpose: Called by the operating system when processes and threads are
//          initialized and terminated, or upon calls to the LoadLibrary
//          and FreeLibrary functions
//
// Return:  TRUE if load was successful, else FALSE
//***************************************************************************

BOOL APIENTRY DllMain( HINSTANCE hInstDLL,  // handle to DLL module
                       DWORD fdwReason,     // reason for calling function
                       LPVOID lpReserved )  // reserved
{
    BOOL bRet = TRUE;

	try
	{
		LogMessage2( L"%s  -> DllMain", PROVIDER_NAME);

		// Perform actions based on the reason for calling.
		switch( fdwReason )
		{
			case DLL_PROCESS_ATTACH:
			{
			    if (CStaticCritSec::anyFailure()) return FALSE;
			    
				if ( TRUE == ( bRet = !bAddInstanceCreatorFailure ) )
				{
					bRet = CommonProcessAttach(PROVIDER_NAME, g_cLock, hInstDLL);
					if( bRet )
					{
						bRet = InitializeEventFactories();
						g_bEventFactoriesInit = bRet ;
					}
				}
			}
			break;

			case DLL_THREAD_ATTACH:
			{
			 // Do thread-specific initialization.
			}
			break;

			case DLL_THREAD_DETACH:
			{
			 // Do thread-specific cleanup.
			}
			break;

			case DLL_PROCESS_DETACH:
			{
				if ( g_bEventFactoriesInit )
				{
					CleanupEventFactories();
				}

				// Perform any necessary cleanup.
				LogMessage( L"DLL_PROCESS_DETACH" );
			}
			break;
		}
	}
	catch ( ... )
	{
		bRet = FALSE;
	}

    return bRet;  // Status of DLL_PROCESS_ATTACH.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\modem.h ===
///////////////////////////////////////////////////////////////////////

//                                                                   

// MOMODEM.h 

//                                                                  

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//                                                                   
//  9/05/96     jennymc     Updated to meet current standards
//                                                                   
///////////////////////////////////////////////////////////////////////

#define PROPSET_NAME_MODEM L"Win32_PotsModem"

/////////////////////////////////////////////////////////////////////
#define WIN95_MODEM_REGISTRY_KEY L"SYSTEM\\CurrentControlSet\\Services\\Class\\Modem"
#define WINNT_MODEM_REGISTRY_KEY L"SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E96D-E325-11CE-BFC1-08002BE10318}"
#define WINNT_MODEM_KEY L"SYSTEM\\CurrentControlSet\\Control\\Class\\"
#define WINNT_MODEM_CLSID L"{4D36E96D-E325-11CE-BFC1-08002BE10318}"
#define REFRESH_INSTANCE         1
#define ENUMERATE_INSTANCES      2
#define QUERY_KEYS_ONLY          4
#define MODEM_CLASS              L"Modem"
#define CLASS                    L"Class"
#define NULL_MODEM               L"Null Modem"
#define INTERNAL_MODEM           L"Internal Modem"
#define EXTERNAL_MODEM           L"External Modem"
#define PCMCIA_MODEM             L"PCMCIA Modem"
#define UNKNOWN_MODEM            L"Unknown"
#define DRIVER_DESC              L"DriverDesc"
#define HARDWARE_ID              L"HardwareID"
#define MFG                      L"Mfg"
#define MANUFACTURER             L"Manufacturer"
#define FRIENDLY_NAME            L"FriendlyName"
#define DEVICE_TYPE_STR          L"DeviceType"
#define ID                       L"ID"
#define MODEM                    L"Modem"
#define ATTACHED_TO              L"AttachedTo"
#define COMPATIBILITY_FLAGS      L"CompatibilityFlags"
#define CONFIG_DIALOG            L"ConfigDialog"
#define _DCB                     L"DCB"
#define DEFAULT                  L"Default"
#define INACTIVITY_SCALE         L"InactivityScale"
#define INFPATH                  L"InfPath"
#define INFSECTION               L"InfSection"
#define MODEL                    L"Model"
#define PORTSUBCLASS             L"PortSubClass"
#define PROPERTIES               L"Properties"
#define PROVIDERNAME             L"ProviderName"
#define RESET                    L"Reset"
#define RESPONSESKEYNAME         L"ResponsesKeyName"
#define INACTIVITYTIMEOUT        L"InactivityTimeout"
#define MODULATION_BELL          L"Modulation_Bell"
#define MODULATION_CCITT         L"Modulation_CCITT"
#define PREFIX                   L"Prefix"
#define PULSE                    L"Pulse"
#define SPEAKERMODE_DIAL         L"SpeakerMode_Dial"
#define SPEAKERMODE_OFF          L"SpeakerMode_Off"
#define SPEAKERMODE_ON           L"SpeakerMode_On"
#define SPEAKERMODE_SETUP        L"SpeakerMode_Setup"
#define SPEAKERVOLUME_HIGH       L"SpeakerVolume_High"
#define SPEAKERVOLUME_LOW        L"SpeakerVolume_Low"
#define SPEAKERVOLUME_MED        L"SpeakerVolume_Med"
#define TERMINATOR               L"Terminator"
#define TONE                     L"Tone"
#define BLIND_OFF                L"Blind_Off"
#define BLIND_ON                 L"Blind_On"
#define COMPRESSION_ON           L"Compression_On"
#define COMPRESSION_OFF          L"Compression_Off"
#define DIALPREFIX               L"DialPrefix"
#define DIALSUFFIX               L"DialSuffix"
#define ERRORCONTROL_FORCED      L"ErrorControl_Forced"
#define ERRORCONTROL_OFF         L"ErrorControl_Off"
#define ERRORCONTROL_ON          L"ErrorControl_On"
#define FLOWCONTROL_HARD         L"FlowControl_Hard"
#define FLOWCONTROL_OFF          L"FlowControl_Off"
#define FLOWCONTROL_SOFT         L"FlowControl_Soft"
#define ASCII_STRING             L"ASCII string format"
#define DBCS_STRING              L"DBCS string format"
#define UNICODE_STRING           L"UNICODE string format"
#define CALLSETUPFAILTIMER       L"CallSetupFailTimer"
#define SETTINGS                 L"\\Settings"
#define DRIVER_DATE              L"DriverDate"
#define DEV_LOADER               L"DevLoader"
#define VOICE_SWITCH_FEATURE     L"VoiceSwitchFeatures"
#define FRIENDLY_DRIVER          L"FriendlyDriver"

#define ERR_PLATFORM_NOT_SUPPORTED       L"Platform not supported"
#define ERR_INSUFFICIENT_BUFFER          L"Insufficient buffer"
#define ERR_TAPI_REINIT                  L"A telephony application need to relinquish its use of Telephony."
#define ERR_TAPI_INIT                    L"Error <0x%lX> in initializing TAPI API"
#define ERR_TAPI_NEGOTIATE               L"Error <0x%lX> in negotiating API version for line #%d"
#define ERR_LOW_MEMORY                   L"Low in memory"
#define ERR_LINE_GET_DEVCAPS             L"Error <0x%lX> in getting line device capabilities of line #%d"
#define ERR_TAPI_SHUTDOWN                L"Error <0x%lX> in shutting down the applicatiomn usage of TAPI API"
#define ERR_INVALID_MODEM_DEVICE_TYPE    L"Invalid Modem device type"
#define ERR_INVALID_MODEM_SPEAKER_MODE   L"Invalid speaker mode <0x%lX>"
#define ERR_INVALID_MODEM_SPEAKER_VOLUME L"Invalid speaker volume <0x%lX>"
#define APIHIVERSION    0x00030000              // 2.2
#define APILOWVERSION   0x00010001              // 1.1 
#define DT_NULL_MODEM      L"\"00\""
#define DT_EXTERNAL_MODEM  L"\"01\""
#define DT_INTERNAL_MODEM  L"\"02\""
#define DT_PCMCIA_MODEM    L"\"03\""

//////////////////////////////////////////////////////////////////////
class CWin32Modem: public Provider
{
private:
        // Common to both platforms
        BOOL AssignCommonDeviceType (

			CInstance *pInstance, 
			CRegistry *pregPrimary,
            CRegistry *pregSettings
		);

        BOOL AssignCommonFields(

			CInstance *pInstance, 
			CRegistry *pregPrimary,
            CRegistry *pregSettings
		);

        BOOL AssignCfgMgrFields(

			CInstance *pInstance, 
            CConfigMgrDevice *pDevice
		);

        BOOL GetFieldsFromTAPI(

			CTapi32Api &a_Tapi32Api ,
			CInstance *pInstance
		);

        BOOL GetModemInfo(
			CTapi32Api &a_Tapi32Api , 
			DWORD dwWhatToDo, 
			MethodContext *pMethodContext, 
			CInstance *pInstance, 
			LPCWSTR szDeviceID
		);

        // Win95 Private

#ifdef NTONLY
        // WinNT Private
        BOOL GetNTInstance(CInstance *pInstance);
        BOOL RefreshNTInstance(CInstance *pInstance);

        BOOL NTSpecificRegistryValues(
			CInstance *pInstance, 
			CRegistry *CPrimaryReg,
            CRegistry *pregSettings);
#endif

        ///////////////////////////////////////////////////////////////////////
        //  The TAPI Stuff
        ///////////////////////////////////////////////////////////////////////

        BOOL InitializeTAPI ( CTapi32Api &a_Tapi32Api , HLINEAPP *hLineApp , DWORD &a_NumberOfTapiDevices ) ;
        void ShutDownLine ( CTapi32Api &a_Tapi32Api , HLINEAPP *phLineApp ) ;
        BOOL OpenClassInfo ();

        BOOL GetModemInfoFromTAPI (

			CTapi32Api &a_Tapi32Api ,
			HLINEAPP *phLineApp, 
			CHString &a_DeviceIdentifier ,
			DWORD &a_NumberOfTapiDevices,
			LINEDEVCAPS *&pLineDevCaps
		) ;

        LINEDEVCAPS *GetModemCapabilityInfoFromTAPI (

			CTapi32Api &a_Tapi32Api ,
			HLINEAPP *phLineApp, 
			DWORD dwIndex, 
			DWORD dwVerAPI
		);

        BOOL HandleLineErr ( long lLineErr ) ;
  
		// A utility function to convert from a "mm-dd-yyyy" format to WbemTime
        BOOL ToWbemTime(LPCWSTR mmddyy, CHString &strRet);

public:

      virtual HRESULT GetObject ( CInstance *pInstance, long lFlags, CFrameworkQuery &pQuery);// Refresh the property set propeties     
      virtual HRESULT EnumerateInstances ( MethodContext *pMethodContext, long lFlags = 0L);
      virtual HRESULT ExecQuery ( MethodContext *pMethodContext, CFrameworkQuery &pQuery, long lFlags /*= 0L*/ );

      // Constructor sets the name and description of the property set
      // and initializes the properties to their startup values

       CWin32Modem(LPCWSTR name, LPCWSTR pszNamespace);  
      ~CWin32Modem();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\modem.cpp ===
///////////////////////////////////////////////////////////////////////

//

// MODEM.CPP

//

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
//  9/05/96     jennymc     Updated to meet current standards
//  1/11/98     a-brads		Updated to CIMOM V2 standards
//
///////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <cominit.h>
#include <cregcls.h>

#define TAPI_CURRENT_VERSION 0x00030000
#include <tapi.h>

#include <lockwrap.h>
#include "DllWrapperBase.h"
#include "TapiApi.h"

#include "Modem.h"

///////////////////////////////////////////////////////////////////////
CWin32Modem MyModemSet(PROPSET_NAME_MODEM, IDS_CimWin32Namespace);

///////////////////////////////////////////////////////////////////////
VOID FAR PASCAL lineCallback(	DWORD dwDevice,
								DWORD dwMsg,
                                DWORD_PTR dwCallbackInst,
								DWORD_PTR dwParam1,
                                DWORD_PTR dwParam2,
								DWORD_PTR dwParam3){};

//////////////////////////////////////////////////////////////////
//
//  Function:      CWin32Modem
//
//  Description:   This function is the constructor, adds a
//                 few more properties to the class, identifies
//                 the key, and logs into the framework
//
//  Return:        None
//
//  History:
//         jennymc  11/21/96    Documentation/Optimization
//
//////////////////////////////////////////////////////////////////
CWin32Modem::CWin32Modem (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider (name , pszNamespace)
{
}

//////////////////////////////////////////////////////////////////
CWin32Modem::~CWin32Modem()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Modem::ExecQuery
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32Modem::ExecQuery (

	MethodContext *pMethodContext,
	CFrameworkQuery &query,
	long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

   	CTapi32Api *pTapi32Api = (CTapi32Api *)CResourceManager::sm_TheResourceManager.GetResource (g_guidTapi32Api, NULL) ;
	if (pTapi32Api)
	{
		if (query.KeysOnly())
		{
			hr =
                GetModemInfo (
				    *pTapi32Api ,
				    ENUMERATE_INSTANCES | QUERY_KEYS_ONLY,
				    pMethodContext,
				    NULL,
                    NULL) ? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND;
		}
		else
		{
			hr = WBEM_E_PROVIDER_NOT_CAPABLE;
		}

		CResourceManager::sm_TheResourceManager.ReleaseResource (g_guidTapi32Api , pTapi32Api) ;
	}
	else
	{
		hr = WBEM_E_FAILED;
	}

	return hr;
}

//////////////////////////////////////////////////////////////////
//
//  Function:      GetObject
//
//  Description:   This function assigns values to properties
//                 in our set for a single instance.
//
//  Return:        HRESULT
//
//  History:
//         jennymc  11/21/96    Documentation/Optimization
//
//////////////////////////////////////////////////////////////////

HRESULT CWin32Modem::GetObject (CInstance *pInstance, long lFlags, CFrameworkQuery &query)
{
	BOOL bRetCode = FALSE;
	HRESULT t_Result = WBEM_S_NO_ERROR ;
    DWORD dwParms;

	if (query.KeysOnly())
    {
        dwParms = REFRESH_INSTANCE | QUERY_KEYS_ONLY;
    }
    else
    {
        dwParms = REFRESH_INSTANCE;
    }

  	CTapi32Api *pTapi32Api = (CTapi32Api *) CResourceManager::sm_TheResourceManager.GetResource (g_guidTapi32Api, NULL) ;
	if (pTapi32Api)
	{
		CHString deviceID;
		if (pInstance->GetCHString (IDS_DeviceID , deviceID))
		{
			bRetCode = GetModemInfo (

				*pTapi32Api ,
				dwParms,
				NULL,
				pInstance,
				deviceID
			) ;
		}

		if (bRetCode)
		{
			t_Result = WBEM_S_NO_ERROR ;
		}
		else
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}

		CResourceManager::sm_TheResourceManager.ReleaseResource (g_guidTapi32Api , pTapi32Api) ;
	}
	else
	{
		t_Result = WBEM_E_FAILED;
	}

	return t_Result ;
}

//////////////////////////////////////////////////////////////////
//
//  Function:      CWin32Modem::EnumerateInstances
//
//  Description:   This function gets info for all modems
//
//  Return:        Number of instances
//
//  History:
//         jennymc  11/21/96    Documentation/Optimization
//
//////////////////////////////////////////////////////////////////
HRESULT CWin32Modem::EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
	BOOL bRetCode = FALSE;

  	CTapi32Api *pTapi32Api = (CTapi32Api *) CResourceManager::sm_TheResourceManager.GetResource (g_guidTapi32Api, NULL) ;
	if (pTapi32Api)
	{

	// Note that we don't get the tapi stuff here since that is considered
	// 'expensive.'

		bRetCode = GetModemInfo (

			*pTapi32Api,
			ENUMERATE_INSTANCES,
			pMethodContext,
			NULL,
            NULL
		) ;

		CResourceManager::sm_TheResourceManager.ReleaseResource (g_guidTapi32Api , pTapi32Api) ;
	}

	if (bRetCode)
	{
		return WBEM_S_NO_ERROR ;
	}
	else
	{
		return WBEM_E_NOT_FOUND ;
	}
}

//////////////////////////////////////////////////////////////////

#ifdef NTONLY
#define MODEM_KEY   WINNT_MODEM_REGISTRY_KEY
#endif

BOOL CWin32Modem::GetModemInfo (

	CTapi32Api &a_Tapi32Api ,
	DWORD dwWhatToDo,
	MethodContext *pMethodContext,
	CInstance *pParmInstance,
	LPCWSTR szDeviceID
)
{
    BOOL        bRet = FALSE,
                bDone,
                bAnother;
    CRegistry   regModem;
    CInstancePtr
                pInstance;
	HRESULT     hr = WBEM_S_NO_ERROR;
    int         iModem = 0;

	// regModem will contain one entry for each modem.
	if (regModem.OpenAndEnumerateSubKeys( HKEY_LOCAL_MACHINE, MODEM_KEY, KEY_READ) != ERROR_SUCCESS)
	{
		return FALSE;
	}

	// bDone is for GetObject when we have found the correct entry
	// bAnother indicates if there is another entry in the registry
	bDone = FALSE;
	bAnother = (regModem.GetCurrentSubKeyCount() > 0);
	for ( ;
        !bDone && bAnother && SUCCEEDED(hr);
        bAnother = (regModem.NextSubKey() == ERROR_SUCCESS))
	{
        DWORD    dwModemIndex;
        CHString strKey,
	             strDriverName,	    // ConfigMngr key name
	             strDriverNumber,	// driver number
                 strPortName,       // Used for PCMCIA modems (won't have AttachedTo).
	             strDeviceID;	    // deviceID returned from ConfigManager

		regModem.GetCurrentSubKeyPath(strKey);
		dwModemIndex = _wtol(strKey.Right(4));
		strDriverNumber = strKey.Right(4);

#ifdef NTONLY
		strDriverName = WINNT_MODEM_CLSID;
		strDriverName += L"\\";
#endif
		strDriverName += strDriverNumber;	// this should be a 4 digit number

		// now, using this data, get the values out of the configmanager.
		CConfigManager      configMngr;
		CDeviceCollection   devCollection;
        CConfigMgrDevicePtr pDevice;

		if (configMngr.GetDeviceListFilterByDriver(devCollection, strDriverName))
		{
			REFPTR_POSITION pos;

			devCollection.BeginEnum(pos);

			for (pDevice.Attach(devCollection.GetNext(pos));
                pDevice != NULL;
                pDevice.Attach(devCollection.GetNext(pos)))
			{
				pDevice->GetDeviceID(strDeviceID);
                pDevice->GetRegStringProperty( L"PORTNAME", strPortName);

                break;
			}
		}

        // If we don't have a device ID (like in the case where the modem is
        // installed but config mgr isn't reporting it), make up a device ID.
        if (strDeviceID.IsEmpty())
            strDeviceID.Format(L"Modem%d", iModem++);

        CRegistry regPrimary,
                  regSettings;

		if (regPrimary.Open(HKEY_LOCAL_MACHINE, strKey, KEY_READ) != ERROR_SUCCESS)
		{
			return FALSE;
		}

        strKey += L"\\Settings";

		if (regSettings.Open(HKEY_LOCAL_MACHINE, strKey, KEY_READ) != ERROR_SUCCESS)
		{
			return FALSE;
		}

        // If we are doing GetObject and this is the Object
		if (dwWhatToDo & REFRESH_INSTANCE)
		{
            // Don't do an attach here.  We need the addref()
			pInstance = pParmInstance ;

			if (0 == strDeviceID.CompareNoCase(szDeviceID))
			{
				pInstance->SetDWORD(IDS_Index, dwModemIndex);

				bDone = TRUE;
                bRet = TRUE;
			}
			else
			{
				continue;
			}
		}
		else
		{
			// We are doing an enum, create a new instance
			pInstance.Attach (CreateNewInstance (pMethodContext)) ;
			if (pInstance != NULL)
            {
			    bRet = TRUE;
                pInstance->SetDWORD(IDS_Index, dwModemIndex);
                pInstance->SetCHString(L"DeviceID", strDeviceID);
            }
            else
                bRet = FALSE;
		}

		// The nt and win95 registries contain different info
        if (bRet && !(dwWhatToDo & QUERY_KEYS_ONLY))
        {
#ifdef NTONLY
            bRet =
                NTSpecificRegistryValues(
                    pInstance,
                    &regPrimary,
                    &regSettings);
#endif
        }

		// Some registry entries are the same
        if (bRet && !(dwWhatToDo & QUERY_KEYS_ONLY))
		{
			AssignCommonFields(pInstance, &regPrimary, &regSettings);

            // Call this even if pDevice is NULL.
            AssignCfgMgrFields(pInstance, pDevice);

            // PCMCIA modems don't have the 'AttachedTo' registry string,
            // so use the 'PortName' string instead.
            if (!strPortName.IsEmpty())
			{
                pInstance->SetCharSplat(L"AttachedTo", strPortName);
			}

            // Only get the expensive ones if we have to.
			if (!(dwWhatToDo & QUERY_KEYS_ONLY))
			{
	   			GetFieldsFromTAPI ( a_Tapi32Api , pInstance ) ;
			}
		}

		// If enum and if everything went all right, commit
		if (dwWhatToDo & ENUMERATE_INSTANCES)
		{
			if (bRet)
			{
				hr = pInstance->Commit();
			}
		}
	}	// end for loop

	// If getobject and didn't find it
	if ((dwWhatToDo & REFRESH_INSTANCE) && !bRet)
	{
		return FALSE;
	}

	return SUCCEEDED(hr);
}

///////////////////////////////////////////////////////////////////////
#ifdef NTONLY
BOOL CWin32Modem::NTSpecificRegistryValues(

	CInstance *pInstance,
	CRegistry *pregPrimary,
	CRegistry *regSettings
)
{
    CHString strTmp;
    CRegistry reg;
	DWORD dwSpeed;

    // Compatibility Flags
    if (pregPrimary->GetCurrentBinaryKeyValue(COMPATIBILITY_FLAGS, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_CompatibilityFlags, strTmp);

    if (pregPrimary->GetCurrentKeyValue(L"MaximumPortSpeed", dwSpeed) == ERROR_SUCCESS)
    {
        pInstance->SetDWORD(IDS_MaxTransmissionSpeed, dwSpeed);
    }
    else
    {
        // The default is 115200, which the os will use
        // until a user changes the port speed.  If the
        // user changes the speed, the MaximumPortSpeed
        // key is added.  Until the speed is changed,
        // however, there is no such key and the default
        // value of 115200 is used.  Hence, if we don't
        // see the key, report the default ourselves...
        pInstance->SetDWORD(IDS_MaxTransmissionSpeed, 115200);
    }

    // ResponsesKeyName
    if (pregPrimary->GetCurrentKeyValue(RESPONSESKEYNAME, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_ResponsesKeyName, strTmp);

    // Name
    if (pregPrimary->GetCurrentKeyValue(FRIENDLY_NAME, strTmp) == ERROR_SUCCESS)
		pInstance->SetCHString(IDS_Name, strTmp);

    return TRUE;
}
#endif

//////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
BOOL CWin32Modem::AssignCommonDeviceType (

	CInstance *pInstance,
	CRegistry *regPrimary,
	CRegistry *regSettings
)
{
    DWORD		dwValue = 0;
    CHString	strTmp;

    if (regPrimary->GetCurrentBinaryKeyValue(DEVICE_TYPE_STR, strTmp) != ERROR_SUCCESS)
        return FALSE;

	// The string MUST be in the format: "0n", where n is a digit 0 - 3.

	// Set the Modem device type if it is known, otherwise just drop out
	// with an error.

	BOOL fKnownType = TRUE;

	if (strTmp.CompareNoCase(DT_NULL_MODEM) == 0)
	{
		 pInstance->SetCHString(IDS_DeviceType, NULL_MODEM);
	}
	else if (strTmp.CompareNoCase(DT_INTERNAL_MODEM) == 0)
	{
		 pInstance->SetCHString(IDS_DeviceType, INTERNAL_MODEM);
	}
	else if (strTmp.CompareNoCase(DT_EXTERNAL_MODEM) == 0)
	{
		 pInstance->SetCHString(IDS_DeviceType, EXTERNAL_MODEM);
	}
	else if (strTmp.CompareNoCase(PCMCIA_MODEM) == 0)
	{
		 pInstance->SetCHString(IDS_DeviceType, PCMCIA_MODEM);
	}
	else
	{
		fKnownType = FALSE;
        LogErrorMessage(ERR_INVALID_MODEM_DEVICE_TYPE);
		pInstance->SetCHString(IDS_DeviceType, UNKNOWN_MODEM);
	}

    return fKnownType;
}

//////////////////////////////////////////////////////////////////////
BOOL CWin32Modem::AssignCommonFields (

	CInstance *pInstance,
	CRegistry *pregPrimary,
	CRegistry *pregSettings
)
{
    CHString strTmp;
    CRegistry reg;
    void *vptr;

    ///////////////////////////////////////////////////////
    // Fields from the Settings subkey

    // Prefix
    if (pregSettings->GetCurrentKeyValue(PREFIX, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_Prefix, strTmp);

    // Pulse
    if (pregSettings->GetCurrentKeyValue(PULSE, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_Pulse, strTmp);

    // Terminator
    if (pregSettings->GetCurrentKeyValue(TERMINATOR, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_Terminator, strTmp);

    // Tone
    if (pregSettings->GetCurrentKeyValue(TONE, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_Tone, strTmp);

    // Blind_Off
    if (pregSettings->GetCurrentKeyValue(BLIND_OFF, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_BlindOff, strTmp);

    // Blind_On
    if (pregSettings->GetCurrentKeyValue(BLIND_ON, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_BlindOn, strTmp);

    // InactivityTimeout
    if (pregSettings->GetCurrentKeyValue(INACTIVITYTIMEOUT, strTmp) == ERROR_SUCCESS)
    {
        INT i = _wtoi(strTmp);
        // per spec -1 isn't supported.  Not sure if this ever really gets put in the
        // registry, but whatever.
        if (i != -1)
        {
            pInstance->SetDWORD(IDS_InactivityTimeout, i);
        }
    }

    // Modulation_Bell
    if (pregSettings->GetCurrentKeyValue(MODULATION_BELL, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_ModulationBell, strTmp);

    // Modulation_CCITT
    if (pregSettings->GetCurrentKeyValue(MODULATION_CCITT, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_ModulationCCITT, strTmp);

    // SpeakerMode_Dial
    if (pregSettings->GetCurrentKeyValue(SPEAKERMODE_DIAL, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_SpeakerModeDial, strTmp);

    // SpeakerMode_Off
    if (pregSettings->GetCurrentKeyValue(SPEAKERMODE_OFF, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_SpeakerModeOff, strTmp);

    // SpeakerMode_On
    if (pregSettings->GetCurrentKeyValue(SPEAKERMODE_ON, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_SpeakerModeOn, strTmp);

    // SpeakerMode_Setup
    if (pregSettings->GetCurrentKeyValue(SPEAKERMODE_SETUP, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_SpeakerModeSetup, strTmp);

    // SpeakerMode_High
    if (pregSettings->GetCurrentKeyValue(SPEAKERVOLUME_HIGH, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_SpeakerVolumeHigh, strTmp);

    // SpeakerMode_Low
    if (pregSettings->GetCurrentKeyValue(SPEAKERVOLUME_LOW, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_SpeakerVolumeLow, strTmp);

    // SpeakerMode_Med
    if (pregSettings->GetCurrentKeyValue(SPEAKERVOLUME_MED, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_SpeakerVolumeMed, strTmp);

    // Compression_On
    if (pregSettings->GetCurrentKeyValue(COMPRESSION_ON, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_CompressionOn, strTmp);

    // Compression_Off
    if (pregSettings->GetCurrentKeyValue(COMPRESSION_OFF, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_CompressionOff, strTmp);

    // ErrorControl_Forced
    if (pregSettings->GetCurrentKeyValue(ERRORCONTROL_FORCED, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_ErrorControlForced, strTmp);

    // ErrorControl_Off
    if (pregSettings->GetCurrentKeyValue(ERRORCONTROL_OFF, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_ErrorControlOff, strTmp);

    // ErrorControl_On
    if (pregSettings->GetCurrentKeyValue(ERRORCONTROL_ON, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_ErrorControlOn, strTmp);

    // FlowControl_Hard
    if (pregSettings->GetCurrentKeyValue(FLOWCONTROL_HARD, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_FlowControlHard, strTmp);

    // FlowControl_Off
    if (pregSettings->GetCurrentKeyValue(FLOWCONTROL_OFF, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_FlowControlOff, strTmp);

    // FlowControl_Soft
    if (pregSettings->GetCurrentKeyValue(FLOWCONTROL_SOFT, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_FlowControlSoft, strTmp);

    ///////////////////////////////////////////////////////
    // Fields from the primary key

    // DriverDate
    if (pregPrimary->GetCurrentKeyValue(DRIVER_DATE, strTmp) == ERROR_SUCCESS)
	{
		CHString strDate;

        if (ToWbemTime(strTmp, strDate))
			pInstance->SetCharSplat(IDS_DriverDate, strDate);
	}

    // InactivityScale
    if (pregPrimary->GetCurrentBinaryKeyValue(INACTIVITY_SCALE, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_InactivityScale, strTmp);

    // ProviderName
    if (pregPrimary->GetCurrentKeyValue(PROVIDERNAME, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_ProviderName, strTmp);

    // InfPath
    if (pregPrimary->GetCurrentKeyValue(INFPATH, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_ModemInfPath, strTmp);

    // InfSection
    if (pregPrimary->GetCurrentKeyValue(INFSECTION, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_ModemInfSection, strTmp);

    // Model
    if (pregPrimary->GetCurrentKeyValue(MODEL, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_Model, strTmp);

    // PortSubClass
    if (pregPrimary->GetCurrentBinaryKeyValue(PORTSUBCLASS, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_PortSubClass, strTmp);

    // VoiceSwitchFeature
    if (pregPrimary->GetCurrentBinaryKeyValue(VOICE_SWITCH_FEATURE, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_VoiceSwitchFeature, strTmp);

    // Properties
    if (pregPrimary->GetCurrentKeyValue(PROPERTIES, strTmp) == ERROR_SUCCESS)
	{
        _variant_t      vValue;
        SAFEARRAYBOUND  rgsabound[1];

        // Create the array
        rgsabound[0].cElements = strTmp.GetLength();
        rgsabound[0].lLbound = 0;

        V_ARRAY(&vValue) = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (V_ARRAY (&vValue) == NULL)
		{
			throw CHeap_Exception (CHeap_Exception::E_ALLOCATION_ERROR) ;
		}

		V_VT(&vValue) = VT_UI1 | VT_ARRAY;

        // Put the data in
        SafeArrayAccessData(V_ARRAY(&vValue), &vptr);
        memcpy(vptr, strTmp, rgsabound[0].cElements);
        SafeArrayUnaccessData(V_ARRAY(&vValue));

        pInstance->SetVariant(IDS_Properties, vValue);
    }

    // Reset
    if (pregPrimary->GetCurrentKeyValue(RESET, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_Reset, strTmp);

    // Description
    if (pregPrimary->GetCurrentKeyValue(DRIVER_DESC, strTmp) == ERROR_SUCCESS)
    {
        pInstance->SetCHString(IDS_Description, strTmp);
        pInstance->SetCHString(IDS_Caption, strTmp);
    }

    // AttachedTo
    if (pregPrimary->GetCurrentKeyValue(ATTACHED_TO, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_AttachedTo, strTmp);

    // Config Dialog
    if (pregPrimary->GetCurrentKeyValue(CONFIG_DIALOG, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_ConfigurationDialog, strTmp);

    // DCB
    if (pregPrimary->GetCurrentKeyValue(_DCB, strTmp) == ERROR_SUCCESS)
	{
        variant_t      vValue;
        SAFEARRAYBOUND rgsabound[1];

        // Create the array
        rgsabound[0].cElements = strTmp.GetLength();
        rgsabound[0].lLbound = 0;


        V_ARRAY(&vValue) = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (V_ARRAY (&vValue) == NULL)
		{
			throw CHeap_Exception (CHeap_Exception::E_ALLOCATION_ERROR) ;
		}

		V_VT(&vValue) = VT_UI1 | VT_ARRAY;

        // Put the data in
        SafeArrayAccessData(V_ARRAY(&vValue), &vptr);
        memcpy(vptr, strTmp, rgsabound[0].cElements);
        SafeArrayUnaccessData(V_ARRAY(&vValue));

        pInstance->SetVariant(IDS_DCB, vValue);
    }

    // Default
    if (pregPrimary->GetCurrentKeyValue(DEFAULT, strTmp) == ERROR_SUCCESS)
	{
        variant_t      vValue;
        SAFEARRAYBOUND rgsabound[1];

		// Create the array
        rgsabound[0].cElements = strTmp.GetLength();
        rgsabound[0].lLbound = 0;


        V_ARRAY(&vValue) = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (V_ARRAY (&vValue) == NULL)
		{
			throw CHeap_Exception (CHeap_Exception::E_ALLOCATION_ERROR) ;
		}

		V_VT(&vValue) = VT_UI1 | VT_ARRAY;

        // Put the data in
        SafeArrayAccessData(V_ARRAY(&vValue), &vptr);
        memcpy(vptr, strTmp, rgsabound[0].cElements);
        SafeArrayUnaccessData(V_ARRAY(&vValue));

        pInstance->SetVariant(IDS_Default, vValue);
    }

    // DeviceType
    AssignCommonDeviceType(pInstance, pregPrimary, pregSettings);

    // Easy properties
    pInstance->SetCharSplat(IDS_SystemCreationClassName, L"Win32_ComputerSystem");
	pInstance->SetCHString(IDS_SystemName, GetLocalComputerName());
	SetCreationClassName(pInstance);
	pInstance->Setbool(IDS_PowerManagementSupported, FALSE);

    // Country
    DWORD dwID;

    if (reg.Open(
        HKEY_LOCAL_MACHINE,
        L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations",
        KEY_READ) == ERROR_SUCCESS &&
        reg.GetCurrentKeyValue(L"CurrentID", dwID) == ERROR_SUCCESS)
    {
        CHString    strKey;
        DWORD       dwCountry;

#if !defined(NTONLY) || NTONLY < 5
        // Everyone but NT5 subtracts 1 from this ID first.
        dwID--;
#endif

        strKey.Format(
            L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations"
            L"\\Location%d", dwID);

        if (reg.Open(
            HKEY_LOCAL_MACHINE,
            strKey,
            KEY_READ) == ERROR_SUCCESS &&
            reg.GetCurrentKeyValue(L"Country", dwCountry) == ERROR_SUCCESS)
        {
            CHString strCountry;

            strKey.Format(
                L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Telephony\\"
                L"Country List\\%d", dwCountry);

            if (reg.OpenLocalMachineKeyAndReadValue(
                strKey,
                L"Name",
                strCountry) == ERROR_SUCCESS)
            	pInstance->SetCHString(L"CountrySelected", strCountry);
        }
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
BOOL CWin32Modem::AssignCfgMgrFields (

    CInstance *pInstance,
    CConfigMgrDevice *pDevice
)
{
    // 2 means we don't know if the device is enabled or not.
    DWORD       dwStatusInfo = 2;
    CHString    strInfo = L"Unknown";

    if (pDevice)
    {
        CHString strTemp;

        SetConfigMgrProperties(pDevice, pInstance);

	    if (pDevice->GetStatus(strInfo))
	    {
	        if (strInfo == L"OK")
		    {
                // Means the device is enabled.
                dwStatusInfo = 3;
	        }
        }
    }

    pInstance->SetCHString(L"Status", strInfo);
    pInstance->SetDWORD(L"StatusInfo", dwStatusInfo);

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
BOOL CWin32Modem::GetFieldsFromTAPI (

	CTapi32Api &a_Tapi32Api ,
	CInstance *pInstance
)
{
    HLINEAPP      hLineApp = NULL;
    LINEDEVCAPS * pLineDevCaps = NULL;
    BOOL bRet = FALSE;

	try
	{
		CHString t_DeviceIdentifier ;

        // Can't use GetCHString directly because it ASSERTs and records an
        // error if the value is null.
        if (pInstance->IsNull(L"AttachedTo"))
		{
			return FALSE;
		}

		pInstance->GetCHString(L"AttachedTo", t_DeviceIdentifier);
		DWORD t_NumberOfTapiDevices ;

		if ( InitializeTAPI ( a_Tapi32Api , &hLineApp , t_NumberOfTapiDevices ) )
		{
			if ( GetModemInfoFromTAPI ( a_Tapi32Api, & hLineApp, t_DeviceIdentifier , t_NumberOfTapiDevices , pLineDevCaps ) )
			{
			  // TAPI field:  MaxSpeed

				pInstance->SetDWORD ( IDS_MaxTransmissionSpeedToPhone , pLineDevCaps->dwMaxRate ) ;

			  // TAPI field:  StringFormat

				switch ( pLineDevCaps->dwStringFormat )
				{
					case STRINGFORMAT_ASCII:
					{
						pInstance->SetCharSplat(IDS_StringFormat, ASCII_STRING);
					}
					break;

					case STRINGFORMAT_DBCS:
					{
						pInstance->SetCharSplat(IDS_StringFormat, DBCS_STRING);
					}
					break;

					case STRINGFORMAT_UNICODE:
					{
						pInstance->SetCharSplat(IDS_StringFormat, UNICODE_STRING);
					}
					break;
				}

				bRet = TRUE;
			}
		}
	}
	catch (...)
	{
		if (hLineApp)
		{
			ShutDownLine (a_Tapi32Api , & hLineApp) ;
			hLineApp = NULL ;
		}

		if (pLineDevCaps)
		{
			delete [] ((char *) pLineDevCaps) ;
			pLineDevCaps = NULL ;
		}

		throw ;
	}

	if (hLineApp)
	{
		ShutDownLine (a_Tapi32Api , & hLineApp) ;
		hLineApp = NULL ;
	}

	if (pLineDevCaps)
	{
		delete [] (PCHAR) pLineDevCaps ;
		pLineDevCaps = NULL ;
	}

	return bRet ;
}

///////////////////////////////////////////////////////////////////////
//  The TAPI Stuff
///////////////////////////////////////////////////////////////////////
BOOL CWin32Modem::InitializeTAPI (

	CTapi32Api &a_Tapi32Api ,
	HLINEAPP *hLineApp ,
	DWORD &a_NumberOfTapiDevices
)
{
	LONG lRc;
	HMODULE hInstance = GetModuleHandle (NULL);
    char szAppName[20] = "modem"; // DONOT change to TCHAR.
    BOOL bTryReInit = TRUE;

    // initialize application's use of the telephone API
	//==================================================
    do
	{
		lRc = a_Tapi32Api.lineInitialize (

			hLineApp,
			hInstance,
			lineCallback,
            szAppName,
			&a_NumberOfTapiDevices
		) ;

		// If we get this error, its because some other app has yet
        // to respond to the REINIT message.  Wait 5 seconds and try
        // again.  If it still doesn't respond, tell the user.
		//===========================================================
        if (lRc == LINEERR_REINIT)
		{
             if (bTryReInit)
			 {
                  Sleep(5000);
                  bTryReInit = FALSE;
                  continue;
             }
			 else
			 {
				 LogErrorMessage(ERR_TAPI_REINIT);
                 return(FALSE);
			 }
        }
		else if (lRc  == LINEERR_NODEVICE)
		{
            return FALSE;
		}
		else if (lRc < 0)
		{
			if (IsErrorLoggingEnabled())
			{
				CHString msg;
				msg.Format(ERR_TAPI_INIT, lRc);
				LogErrorMessage(msg);
			}

            return FALSE;
		}
		else
		{
            return TRUE;
		}

	} while (lRc != 0);

    return TRUE;
}

///////////////////////////////////////////////////////////////////////
void CWin32Modem::ShutDownLine (

	CTapi32Api &a_Tapi32Api ,
	HLINEAPP *phLineApp
)
{
    long lRc;

    if (*phLineApp)
	{
	    lRc = a_Tapi32Api.lineShutdown (*phLineApp);
        if (lRc < 0)
		{
			if (IsErrorLoggingEnabled())
			{
				CHString foo;
				foo.Format(ERR_TAPI_SHUTDOWN, lRc);
				LogErrorMessage(foo);
			}
        }
        *phLineApp = 0;
    }
}

///////////////////////////////////////////////////////////////////////
BOOL CWin32Modem::GetModemInfoFromTAPI (

	CTapi32Api &a_Tapi32Api ,
	HLINEAPP *a_LineApp,
	CHString &a_DeviceIdentifier ,
	DWORD &a_NumberOfTapiDevices,
	LINEDEVCAPS *&ppLineDevCaps
)
{
    BOOL bRet = FALSE ;

	// negotiate the line API version

	for ( DWORD t_Index = 0 ; t_Index < a_NumberOfTapiDevices ; t_Index ++ )
	{
		LINEEXTENSIONID t_LineExtension;
		DWORD t_Version = 0;

		LONG lRc = a_Tapi32Api.lineNegotiateAPIVersion (

			*a_LineApp,
			t_Index,
			APILOWVERSION,
			APIHIVERSION,
			& t_Version ,
			& t_LineExtension
		) ;

		if ( lRc == 0 )
		{
			// Get the modem capability values into an allocated block of memory. The memory block
			// is at the size of dwNeededSize which guaranties to receive all of the information from
			// the call to the lineGetDevCaps.

		   ppLineDevCaps = GetModemCapabilityInfoFromTAPI (

			   a_Tapi32Api,
			   a_LineApp,
			   t_Index,
			   t_Version
			) ;

			if ( ppLineDevCaps )
			{
				try
				{
					if ( ppLineDevCaps->dwMediaModes & LINEMEDIAMODE_DATAMODEM )
					{
						HLINE t_Line ;

						LONG t_Status = a_Tapi32Api.TapilineOpen (

							*a_LineApp,
							t_Index ,
							& t_Line ,
							t_Version,
							0,
							0 ,
							LINECALLPRIVILEGE_NONE ,
							LINEMEDIAMODE_DATAMODEM,
							NULL
						);

						if ( t_Status == 0 )
						{
							VARSTRING *t_VarString = ( VARSTRING * ) new BYTE [ sizeof ( VARSTRING ) + 1024 ] ;
							if ( t_VarString )
							{
								try
								{
									t_VarString->dwTotalSize = sizeof ( VARSTRING ) + 1024 ;

									t_Status = a_Tapi32Api.TapilineGetID (

										t_Line,
										0,
										0,
										LINECALLSELECT_LINE ,
										t_VarString ,
										_T("comm/datamodem/portname")
									);

									if ( t_Status == 0 )
									{
										CHString t_Port ( ( char * ) ( ( BYTE * ) t_VarString + t_VarString->dwStringOffset ) ) ;

										if ( a_DeviceIdentifier.CompareNoCase ( t_Port ) == 0 )
										{
											delete [] ((BYTE *)t_VarString) ;
											t_VarString = NULL ;

											return TRUE;
										}
									}
								}
								catch ( ... )
								{
									if ( t_VarString )
									{
										delete [] ((BYTE *)t_VarString) ;
									}

									throw ;
								}

								delete [] ((BYTE *)t_VarString) ;
								t_VarString = NULL ;
							}
							else
							{
								throw CHeap_Exception (CHeap_Exception::E_ALLOCATION_ERROR) ;
							}
						}
					}
				}
				catch ( ... )
				{
					delete [] ((char *)ppLineDevCaps) ;
					ppLineDevCaps = NULL;
					throw ;
				}
			}
			else
			{
				if ( IsErrorLoggingEnabled())
				{
					CHString foo;
					foo.Format(ERR_LINE_GET_DEVCAPS, lRc, t_Index);
					LogErrorMessage(foo);

					bRet = FALSE;
					break ;
				}
			}

			delete [] ((char *)ppLineDevCaps) ;
			ppLineDevCaps = NULL;
		}
		else
		{
			if ( IsErrorLoggingEnabled () )
			{
				CHString foo;
				foo.Format(ERR_TAPI_NEGOTIATE, lRc, t_Index);
				LogErrorMessage(foo);

				break ;
			}
		}
	}

	return bRet ;
}

///////////////////////////////////////////////////////////////////////
LINEDEVCAPS *CWin32Modem::GetModemCapabilityInfoFromTAPI (

	CTapi32Api &a_Tapi32Api ,
	HLINEAPP *phLineApp,
	DWORD dwIndex,
	DWORD dwVerAPI
)
{
    // Allocate enough space for the structure plus 1024.
	DWORD dwLineDevCaps = sizeof (LINEDEVCAPS) + 1024;
    LONG lRc;
    LINEDEVCAPS *pLineDevCaps = NULL ;

	try
	{
		// Continue this loop until the structure is big enough.
		while(TRUE)
		{
			pLineDevCaps = (LINEDEVCAPS *) new char [dwLineDevCaps];
			if (!pLineDevCaps)
			{
				LogErrorMessage(ERR_LOW_MEMORY);
				throw CHeap_Exception (CHeap_Exception::E_ALLOCATION_ERROR) ;
			}

			pLineDevCaps->dwTotalSize = dwLineDevCaps;

			// Make the call to fill the structure.
			do
			{
				lRc = a_Tapi32Api.TapilineGetDevCaps (

					*phLineApp,
					dwIndex,
					dwVerAPI,
					0,
					pLineDevCaps
				) ;

				if (HandleLineErr(lRc))
				{
					continue;
				}
				else
				{
					delete [] (PCHAR) pLineDevCaps ;
					pLineDevCaps = NULL ;
					return NULL;
				}
			}
			while (lRc != 0);

			// If the buffer was big enough, then succeed.
			if ((pLineDevCaps->dwNeededSize) <= (pLineDevCaps->dwTotalSize))
				break;

			// Buffer wasn't big enough.  Make it bigger and try again.
			dwLineDevCaps = pLineDevCaps->dwNeededSize;
		}
		return pLineDevCaps;

	}
	catch (...)
	{
		if (pLineDevCaps)
		{
			delete [] (PCHAR) pLineDevCaps ;
			pLineDevCaps = NULL ;
		}

		throw ;
	}
}

///////////////////////////////////////////////////////////////////////
BOOL CWin32Modem::HandleLineErr(long lLineErr)
{
    BOOL bRet = FALSE;

    // lLineErr is really an async request ID, not an error.
    if (lLineErr > 0)
        return bRet;

    // All we do is dispatch the correct error handler.
    switch(lLineErr)
    {
		case LINEERR_INCOMPATIBLEAPIVERSION:
            LogErrorMessage(L"Incompatible api version.\n");
		break;

		case LINEERR_OPERATIONFAILED:
            LogErrorMessage(L"Operation failed.\n");
		break;

		case LINEERR_INCOMPATIBLEEXTVERSION:
            LogErrorMessage(L"Incompatible ext version.\n");
		break;

		case LINEERR_INVALAPPHANDLE:
            LogErrorMessage(L"Invalid app handle.\n");
		break;

		case LINEERR_STRUCTURETOOSMALL:
            LogErrorMessage(L"structure too small.\n");
			bRet = TRUE;
		break;

		case LINEERR_INVALPOINTER:
            LogErrorMessage(L"Invalid pointer.\n");
		break;

		case LINEERR_UNINITIALIZED:
            LogErrorMessage(L"Unitialized.\n");
		break;

		case LINEERR_NODRIVER:
            LogErrorMessage(L"No driver.\n");
		break;

		case LINEERR_OPERATIONUNAVAIL:
            LogErrorMessage(L"Operation unavailable.\n");
		break;

		case LINEERR_NODEVICE:
            LogErrorMessage(L"No device ID.\n");
		break;

		case LINEERR_BADDEVICEID:
            LogErrorMessage(L"Bad device ID.\n");
		break;

        case 0:
            bRet = TRUE;
        break;

        case LINEERR_INVALCARD:
        case LINEERR_INVALLOCATION:
        case LINEERR_INIFILECORRUPT:
            LogErrorMessage(L"The values in the INI file are invalid.\n");
        break;

        case LINEERR_REINIT:
            LogErrorMessage(L"LineReinit err.\n");
        break;

        case LINEERR_NOMULTIPLEINSTANCE:
            LogErrorMessage(L"Remove one of your copies of your Telephony driver.\n");
        break;

        case LINEERR_NOMEM:
            LogErrorMessage(L"Out of memory. Cancelling action.\n");
        break;

        case LINEERR_RESOURCEUNAVAIL:
            LogErrorMessage(L"A TAPI resource is unavailable at this time.\n");
        break;

        // Unhandled errors fail.
        default:
            LogErrorMessage(L"Unhandled and unknown TAPI error.\n");
        break;
    }

    return bRet;
}


//
// Converts a string in the "mm-dd-yyyy" "mm/dd/yyyy" "mm-dd/yyyy" "mm/dd-yyyy"
// format to a WBEMTime object. Returns false if the conversion was not successful
//
BOOL CWin32Modem::ToWbemTime(LPCWSTR szDate, CHString &strRet)
{
    CHString strDate = szDate;
    int      iSlash1 = -1,
	         iSlash2 = -1 ;
    BOOL     bRet;

    if ( ( iSlash1 = strDate.Find ('-') ) == -1 )
	{
		iSlash1 = strDate.Find ( '//' );
	}

	if ( ( iSlash2 = strDate.ReverseFind ('-') ) == -1 )
	{
		iSlash2 = strDate.ReverseFind ( '//' );
	}

    if (iSlash1 != -1 && iSlash2 != -1 && iSlash1 != iSlash2 )
	{
	    int iMonth,
            iDay,
            iYear;

		iMonth  = _wtoi(strDate.Left(iSlash1));
		iYear = _wtoi(strDate.Mid(iSlash2 + 1));
        if (iYear < 100)
            iYear += 1900;

        iDay = _wtoi(strDate.Mid(iSlash1 + 1, iSlash2 - iSlash1 - 1)) ;

		// Convert to the DMTF format and send it in
        strRet.Format(
            L"%d%02d%02d******.******+***",
            iYear,
            iMonth,
            iDay);

        bRet = TRUE;
	}
    else
        bRet = FALSE;

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\motherboard.cpp ===
//////////////////////////////////////////////////////////////////////

//

//  MBoard.CPP -- system managed object implementation

//

//  Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
//  10/16/95    a-skaja     Prototype for demo
//  09/03/96    jennymc     Updated to meet current standards
//                          Removed custom registry access to use the
//                          standard CRegCls
// 10/23/97		a-hhance	updated to new framework paradigm
//	1/15/98		a-brads		updated to V2 MOF
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <ole2.h>
#include <conio.h>
//#include <commonutil.h>

#include "MotherBoard.h"
#include "resource.h"

// For CBusList
#include "bus.h"
#include <strsafe.h>

//////////////////////////////////////////////////////////////////////
// Declare the property set
//////////////////////////////////////////////////////////////////////
MotherBoard MyMotherBoardSet(PROPSET_NAME_MOTHERBOARD, IDS_CimWin32Namespace);

 //////////////////////////////////////////////////////////////////
//
//  Function:      Motherboard
//
//  Description:   This function is the constructor
//
//  Return:        None
//
//  History:
//         jennymc  11/21/96    Documentation/Optimization
//
//////////////////////////////////////////////////////////////////
MotherBoard::MotherBoard(LPCWSTR name, LPCWSTR pszNamespace)
: Provider(name, pszNamespace)
{
}

HRESULT MotherBoard::GetObject(CInstance* pInstance, long lFlags /*= 0L*/)
{
	HRESULT hr;
    CHString sObj;

    pInstance->GetCHString(IDS_DeviceID, sObj);

    if (sObj.CompareNoCase(L"Motherboard") == 0)
    {

	    hr = GetCommonInstance(pInstance);
#ifdef NTONLY
		    hr = GetNTInstance(pInstance);
#endif
    } else
    {
        hr = WBEM_E_NOT_FOUND;
    }

	return hr;
}

HRESULT MotherBoard::EnumerateInstances(MethodContext*  pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT hr = WBEM_E_FAILED;

	CInstancePtr pInstance ( CreateNewInstance(pMethodContext), false ) ;

	if (pInstance != NULL )
	{
		hr = GetCommonInstance(pInstance);

#ifdef NTONLY
			hr = GetNTInstance(pInstance);
#endif

		if (SUCCEEDED(hr))
		{
			hr = pInstance->Commit () ;
		}
	}

	return hr;
}

HRESULT MotherBoard::GetCommonInstance(CInstance* pInstance )
{
	SetCreationClassName(pInstance);
	pInstance->SetCharSplat(IDS_DeviceID, _T("Motherboard"));

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_Motherboard);

	pInstance->SetCHString(IDS_Name, sTemp2);
	pInstance->SetCHString(IDS_Caption, sTemp2);
	pInstance->SetCHString(IDS_Description, sTemp2);
	pInstance->SetCharSplat(IDS_SystemCreationClassName, _T("Win32_ComputerSystem"));
//	pInstance->Setbool(IDS_HotSwappable, FALSE);
	pInstance->SetCHString(IDS_SystemName, GetLocalComputerName());
	return(WBEM_S_NO_ERROR);

}

#ifdef NTONLY
////////////////////////////////////////////////////////////////////
HRESULT MotherBoard::GetNTInstance(CInstance* pInstance)
{
    CRegistry   regAdapters;
	CHString    strPrimarySubKey;
	HRESULT     hRc = WBEM_E_FAILED;
	DWORD       dwPrimaryRc;

    //****************************************
    //  Open the registry
    //****************************************
    if (regAdapters.OpenAndEnumerateSubKeys(
        HKEY_LOCAL_MACHINE,
        WINNT_MOTHERBOARD_REGISTRY_KEY,
        KEY_READ ) != ERROR_SUCCESS)
		return WBEM_E_FAILED;

	// Holders for BIOS bus types we might encounter, so if we find no
	// other more common bus types, we'll go ahead and use these
    // values, since they are still reported as BUS types.
	CHString    strFirstBIOSBusType,
				strSecondBIOSBusType,
				strFirstBusType,
                strSecondBusType;
	BOOL		bDone = FALSE;


    //****************************************
    //  Our goal is to find any subkey that
    //  has the string "Adapter" in it and
    //  then read the "Identifier" value.
    //****************************************
    for ( ;
        !bDone && ((dwPrimaryRc = regAdapters.GetCurrentSubKeyName(strPrimarySubKey))
            == ERROR_SUCCESS);
        regAdapters.NextSubKey())
    {
        //************************************
        // If this is one of the keys we want
        // since it has "Adapter" in it
        // then get the "Identifier" value
        //************************************
		if (wcsstr(strPrimarySubKey, ADAPTER))
        {
            WCHAR		szKey[_MAX_PATH];
			CRegistry	reg;

            StringCchPrintf(
				szKey,
                _MAX_PATH,
				L"%s\\%s",
                WINNT_MOTHERBOARD_REGISTRY_KEY,
				(LPCWSTR) strPrimarySubKey);

            if (reg.OpenAndEnumerateSubKeys(
                HKEY_LOCAL_MACHINE,
                szKey,
                KEY_READ) == ERROR_SUCCESS)
            {
				CHString strSubKey;

                //************************************
        	    // Enumerate the  system components
                // (like 0,1....)
                //************************************
                for ( ;
                    reg.GetCurrentSubKeyName(strSubKey) == ERROR_SUCCESS;
                    reg.NextSubKey())
                {
                    CHString strBus;

                    //****************************************
                    // PrimaryBusType - KEY
                    // SecondaryBusType
                    //****************************************
                    if (reg.GetCurrentSubKeyValue(IDENTIFIER, strBus) ==
                        ERROR_SUCCESS)
                    {
				        // Give precedence to PCI, ISA and EISA.
				        if (strBus == L"PCI" || strBus == L"ISA" ||
							strBus == L"EISA")
				        {
					        if (strFirstBusType.IsEmpty())
					        {
						        // Save the type of this first BUS to prevent
                                // duplicates.
						        strFirstBusType = strBus;
					        }
					        // Beware of duplicates
                            else if (strFirstBusType != strBus)
					        {
						        strSecondBusType = strBus;

								// Always let PCI be the 'primary' bus to
								// be consistent with other platforms.
								if (strSecondBusType == L"PCI")
								{
									strSecondBusType = strFirstBusType;
									strFirstBusType = L"PCI";
								}

                                // We got both buses, so get out.
								bDone = TRUE;
                                break;
					        }
				        }
				        else if (strFirstBIOSBusType.IsEmpty())
				        {
					        strFirstBIOSBusType = strBus;
				        }
				        else if (strSecondBIOSBusType.IsEmpty())
				        {
					        strSecondBIOSBusType = strBus;
				        }
                    }
                }
            }
        }
    }

	// If we're missing either bus type, fill them in using stored BIOS bus
    // types if we can.
	if (strFirstBusType.IsEmpty())
    {
		strFirstBusType = strFirstBIOSBusType;
        strSecondBusType = strSecondBIOSBusType;
	}
    else if (strSecondBusType.IsEmpty())
    {
		strSecondBusType = strSecondBIOSBusType;
    }

	if (!strFirstBusType.IsEmpty())
	{
		pInstance->SetCHString(IDS_PrimaryBusType, strFirstBusType);

		if (!strSecondBusType.IsEmpty())
			pInstance->SetCHString(IDS_SecondaryBusType,
				strSecondBusType);
	}


    // Return no error if everything went OK.
    if (dwPrimaryRc == ERROR_NO_MORE_ITEMS || dwPrimaryRc == ERROR_SUCCESS)
        hRc = WBEM_S_NO_ERROR;

    return hRc;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\motherboard.h ===
///////////////////////////////////////////////////////////////////////

//                                                                   

// MBoard.h -- System property set description for WBEM MO       	

//                                                                  

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//                                                                   
// 10/18/95     a-skaja     Prototype                                
//  9/03/96     jennymc     Updated to meet current standards
// 10/23/97		a-hhance	updated to new framework paradigm
//	1/15/98		a-brads		added CommonInstance function
//                                                                   
///////////////////////////////////////////////////////////////////////

#define     PROPSET_NAME_MOTHERBOARD L"Win32_MotherBoardDevice"
//#define     PROPSET_UUID_MOTHERBOARD "{fdecc210-09aa-11cf-921b-00aa00a74d1b}"

///////////////////////////////////////////////////////////////////////////////////////
#define WIN95_MOTHERBOARD_REGISTRY_KEY L"Enum\\Root\\*PNP0C01\\0000"
#define WINNT_MOTHERBOARD_REGISTRY_KEY L"HARDWARE\\Description\\System"
#define REVISION L"Revision"
#define ADAPTER L"Adapter"
#define BUSTYPE L"BusType"
#define IDENTIFIER L"Identifier"
//#define QUOTE L("\"")
#define	BIOS	L"BIOS"

///////////////////////////////////////////////////////////////////////////////////////
class MotherBoard:public Provider
{
    private:
		HRESULT GetCommonInstance(CInstance* pInstance);
        HRESULT GetWin95Instance(CInstance* pInstance);
        HRESULT GetNTInstance(CInstance* pInstance);

    public:
        //**********************************************
        // Constructor/destructor -- constructor 
        // initializes property values, enumerating them 
        // into property set.
        //**********************************************
        MotherBoard(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~MotherBoard() {  }

        //**********************************************
        // Function provides properties with current 
        // values (REQUIRED)
        //**********************************************
   		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);

        //**********************************************
        // This class has dynamic instances
        //**********************************************
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\multimonitor.cpp ===
//=================================================================

//

// MultiMonitor.CPP -- Performance Data Helper class

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:	11/23/97    a-sanjes		Created
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>
#include "multimonitor.h"

// This will get us the multi-monitor stubs.
#define COMPILE_MULTIMON_STUBS

#include <multimon.h>

// Static Initialization
//////////////////////////////////////////////////////////
//
//	Function:	CMultiMonitor::CMultiMonitor
//
//	Default constructor
//
//	Inputs:
//				None
//
//	Outputs:
//				None
//
//	Returns:
//				None
//
//	Comments:
//
//////////////////////////////////////////////////////////

CMultiMonitor::CMultiMonitor()
{
	Init();
}

//////////////////////////////////////////////////////////
//
//	Function:	CMultiMonitor::~CMultiMonitor
//
//	Destructor
//
//	Inputs:
//				None
//
//	Outputs:
//				None
//
//	Returns:
//				None
//
//	Comments:
//
//////////////////////////////////////////////////////////

CMultiMonitor::~CMultiMonitor()
{
}

void CMultiMonitor::Init()
{
#if NTONLY >= 5
    CConfigManager cfgManager;

    cfgManager.GetDeviceListFilterByClass(m_listAdapters, L"Display");
#else
    // NT4 behaves badly.  It may have several cfg mgr objects of type
    // "Display", or none at all.  So, we'll use the registry to try to find
    // the cfg mgr device for the display adapter.  There can only be one on
    // NT4.

    CRegistry reg;

    // The key is always in the same place on NT4 and lower.
    reg.OpenLocalMachineKeyAndReadValue(
	    L"HARDWARE\\DEVICEMAP\\VIDEO",
		L"\\Device\\Video0",
		m_strSettingsKey);


    // \REGISTRY\Machine\System\ControlSet001\Services\mga64\Device0
    // We need to strip off the \REGISTRY\Machine stuff.
    TrimRawSettingsKey(m_strSettingsKey);


    // Parse out just the service name.  The key currently looks like
    // System\ControlSet001\Services\mga64\Device0
    // and we only want the 'mga64' part.
    int iBegin = m_strSettingsKey.Find(L"SERVICES\\");
	if (iBegin != -1)
	{
        CConfigManager cfgManager;

	    // This will get us past the SERVICES\\.
		m_strService = m_strSettingsKey.Mid(iBegin +
                           sizeof(_T("SERVICES"))/sizeof(TCHAR));
		m_strService = m_strService.SpanExcluding(L"\\");

        // Now try to find the cfg mgr device.
        cfgManager.GetDeviceListFilterByService(m_listAdapters, m_strService);
    }
#endif
}

BOOL CMultiMonitor::GetAdapterDevice(int iWhich, CConfigMgrDevicePtr & pDeviceAdapter)
{
	BOOL bRet = FALSE;

	// Don't use GetNumAdapters() here because GetNumAdapters() isn't necessarily
    // the same as the size of the adapters list (especially for NT4).
    if ( iWhich < m_listAdapters.GetSize())
	{
        // Assuming a 1 to 1 correspondence between the monitors returned by the
        // multi-monitor apis and the monitors returned by Config Manager.
        CConfigMgrDevice *pDevice = m_listAdapters.GetAt(iWhich);

        if (pDevice)
        {
            // Don't AddRef or release the device here, because we're just
            // passing the device through.
            pDeviceAdapter.Attach(pDevice);
            bRet = TRUE;
		}
	}

	return bRet;
}

BOOL CMultiMonitor::GetMonitorDevice(int iWhich, CConfigMgrDevicePtr & pDeviceMonitor)
{
    CConfigMgrDevicePtr pDeviceAdapter;
    BOOL                bRet = FALSE;

    if ( GetAdapterDevice(iWhich, pDeviceAdapter))
    {
        bRet = pDeviceAdapter->GetChild(pDeviceMonitor);
    }

    return bRet;
}

BOOL CMultiMonitor::GetAdapterDisplayName(int iWhich, CHString &strName)
{
    BOOL bRet = FALSE;

    if (iWhich >= 0 || iWhich < GetNumAdapters())
    {
#if NTONLY == 4
        strName = L"DISPLAY";
#endif

#if NTONLY >= 5

		CHString strDeviceID;
		if ( GetAdapterDeviceID ( iWhich, strDeviceID ) )
		{
			// Get it from EnumDisplayDevices.
			// We can't just use iWhich in EnumDisplayDevices because more
			// than just display adapters show up from this call.  So, enum
			// them and stop when we find a matching PNPID.
			DISPLAY_DEVICE device = { sizeof(device) };
			int i = 0;
			int iDisplay = 0;

			while (	EnumDisplayDevices(NULL, i++, &device, 0) )
			{
				if ( ! device.DeviceName && ( device.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP ) )
				{
					// only those attached to desktop
					iDisplay++;
				}

				if (!_wcsicmp(device.DeviceID, strDeviceID))
				{
					if ( device.DeviceName )
					{
						strName = device.DeviceName;
					}
					else
					{
						strName.Format(L"\\\\.\\Display%d", iDisplay);
					}

					return TRUE;
				}
			}
		}

		return FALSE;
#endif
        bRet = TRUE;
    }

    return bRet;
}

BOOL CMultiMonitor::GetAdapterDeviceID(int iWhich, CHString &strDeviceID)
{
    BOOL bRet = FALSE;
	CConfigMgrDevicePtr pDevice;

	if ( GetAdapterDevice ( iWhich, pDevice ) )
	{
		if (pDevice)
		{
			if ( bRet = pDevice->GetDeviceID(strDeviceID) )
			{
				int iLast = strDeviceID.ReverseFind ( L'\\' );
				strDeviceID = strDeviceID.Left ( strDeviceID.GetLength() - ( strDeviceID.GetLength() - iLast ) );
			}
		}
	}

    return bRet;
}

DWORD CMultiMonitor::GetNumAdapters()
{
#if NTONLY >= 5
    return m_listAdapters.GetSize();
#else
    return 1;
#endif
}

#if NTONLY == 4
void CMultiMonitor::GetAdapterServiceName(CHString &strName)
{
    strName = m_strService;
}
#endif

#ifdef NTONLY
BOOL CMultiMonitor::GetAdapterSettingsKey(
    int iWhich,
    CHString &strKey)
{
    BOOL     bRet = FALSE;
#if NTONLY == 4
    if (iWhich == 1)
    {
        strKey = m_strSettingsKey;

        bRet = TRUE;
    }
#else
    CHString strName;

    if (GetAdapterDeviceID(iWhich, strName))
    {
        // Get it from EnumDisplayDevices.
        // We can't just use iWhich in EnumDisplayDevices because more
        // than just display adapters show up from this call.  So, enum
        // them and stop when we find a matching PNPID.
        DISPLAY_DEVICE device = { sizeof(device) };

        for (int i = 0;
            EnumDisplayDevices(NULL, i, &device, 0);
            i++)
        {
            // Match up the display name (like \\.\Display#)
            if (!_wcsicmp(device.DeviceID, strName))
            {
                strKey = device.DeviceKey;
                TrimRawSettingsKey(strKey);

                bRet = TRUE;

                break;
            }
        }
    }

#endif
    return bRet;
}
#endif // #ifdef NTONLY

#ifdef NTONLY
void CMultiMonitor::TrimRawSettingsKey(CHString &strKey)
{
    // Key looks like:
    // \REGISTRY\Machine\System\ControlSet001\Services\mga64\Device0
    // We need to strip off the \REGISTRY\Machine stuff.
    int iBegin;

    strKey.MakeUpper();
    iBegin = strKey.Find(L"\\SYSTEM");

    if (iBegin != -1)
        strKey = strKey.Mid(iBegin + 1);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\msinfo_cdrom.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  MSInfo_CDRom.cpp
//
//  Purpose: Routines from msinfo for transfer rate and drive integrity
//
//***************************************************************************

#include "precomp.h"
#include <assertbreak.h>


#include <stack>
#include "msinfo_cdrom.h"
#include "mmsystem.h"
#include <io.h>
#include <strsafe.h>
#pragma warning(disable : 4995) // we introduced as including strsafe.h gives error for all unsafe string functions
//-----------------------------------------------------------------------------
// Find the next CD-ROM drive after the cCurrentDrive parameter. If
// cCurrentDrive is '\0', find the first CD-ROM drive. Return '\0' if there
// are no more CD drives.
//-----------------------------------------------------------------------------

#define FIRST_DRIVE	'C'
#define LAST_DRIVE	'Z'

char FindNextCDDrive(char cCurrentDrive)
{
	//CHString	strDriveRoot;
    TCHAR   szDriveRoot[10];
	char	cDrive = '\0';
	char	cStart = (cCurrentDrive == '\0') ? FIRST_DRIVE : (char) ((int)cCurrentDrive + 1);

	for (char c = cStart; c <= LAST_DRIVE; c++)
	{
		_stprintf(szDriveRoot, _T("%c:\\"), c);
		if (GetDriveType(szDriveRoot) == DRIVE_CDROM)
		{
			cDrive = c;
			break;
		}
	}

	return (cDrive);
}

//-----------------------------------------------------------------------------
// Get the total space on the CD-ROM drive. This code comes from version
// 2.51 of MSInfo. Returns zero if the information can not be found.
//-----------------------------------------------------------------------------

DWORD GetTotalSpace(LPCTSTR szRoot)
{
    DWORD dwSectorsPerCluster, dwBytesPerSector, dwFreeClusters, dwTotalClusters;
	DWORD dwTotalSpace = 0;

    BOOL bOK = GetDiskFreeSpace(szRoot, &dwSectorsPerCluster, &dwBytesPerSector,
                                &dwFreeClusters, &dwTotalClusters);
	if (bOK)
		dwTotalSpace = (dwTotalClusters * dwSectorsPerCluster * dwBytesPerSector);

	return (dwTotalSpace);
}

//-----------------------------------------------------------------------------
// These two functions are used to determine the transfer and integrity files
// for testing the CD-ROM drive.
//-----------------------------------------------------------------------------

#define MEGABYTE (1024 * 1024)

CHString GetIntegrityFile(LPCTSTR szRoot)
{
	return FindFileBySize(szRoot, _T("*.*"), MEGABYTE * 3/4, MEGABYTE * 2, TRUE);
}

CHString GetTransferFile(LPCTSTR szRoot)
{
	DWORD	dwMinSize = MEGABYTE, dwMaxSize;

	// Information from MSInfo 2.51:
	// Due to a problem disabling the file cache under Windows 95, the size of
	// the file must be greater than the supplemental cache used in the CD file
	// system (CDFS). This value is determined from the following:
	//
	// HLM\System\CurrentControlSet\Control\FileSystem\CDFS: CacheSize=<reg binary>

    // TODO: ADD THIS IDS TO STRINGG.CPP & H:
    //const char* IDS_REG_KEY_CD_CACHE = "System\\CurrentControlSet\\Control\\FileSystem\\CDFS";
    //const char* IDS_REG_VAL_CD_CACHE = "CacheSize";


	dwMaxSize = ((dwMinSize > MEGABYTE) ? dwMinSize : MEGABYTE) * 2;
	return FindFileBySize(szRoot, _T("*.*"), dwMinSize, dwMaxSize, TRUE);
}

//-----------------------------------------------------------------------------
// This function (mostly lifted from the 2.51 version) is used to find a file
// in the specified directory tree which meets the specified size requirements.
//-----------------------------------------------------------------------------

CHString FindFileBySize(LPCTSTR szDirectory, LPCTSTR szFileSpec, DWORD dwMinSize, DWORD dwMaxSize, BOOL bRecursive)
{
	//CStringList		listSubdir;
    std::stack<CHString> stackchstrSubdirList;
    WIN32_FIND_DATA		ffd;
	CHString			strReturnFile, strDirSpec;
	BOOL				bMore = TRUE;
	DWORD				dwAttr;

	// Find the first available file to match the file specifications.

	strDirSpec = MakePath(szDirectory, szFileSpec);
    HANDLE hFindFile = FindFirstFile(TOBSTRT(strDirSpec), &ffd);
    if (hFindFile == INVALID_HANDLE_VALUE)
		return strReturnFile;

	// Then check each file in the directory. Add any subdirectories found to the
	// string list, so we can process them after we've done all the files (so this
	// is a breadth-first search). In this loop we check for non-system files, and
	// for files which fit the size requirements.

	while (bMore)
	{
        if (bRecursive && ((ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY))
        {
			if ((lstrcmp(ffd.cFileName, _T(".")) != 0) && (lstrcmp(ffd.cFileName, _T("..")) != 0))
            {
				//listSubdir.AddTail(ffd.cFileName);
                CHString chstrTemp = ffd.cFileName;
                stackchstrSubdirList.push(chstrTemp);
            }
        }

		dwAttr = ffd.dwFileAttributes;
		if (((dwAttr & FILE_ATTRIBUTE_SYSTEM) == 0) && ((dwAttr & FILE_ATTRIBUTE_HIDDEN) == 0))
        {
			if ((dwMinSize <= ffd.nFileSizeLow) && (ffd.nFileSizeLow <= dwMaxSize))
			{
				strReturnFile = MakePath(szDirectory, ffd.cFileName);
				break;
			}
        }
        bMore = FindNextFile(hFindFile, &ffd);
	}

    FindClose(hFindFile);

	// If we haven't found a suitable file (strReturnFile is empty), then call this
	// function recursively on all of the sub-directories.

	while (strReturnFile.IsEmpty() && !stackchstrSubdirList.empty())
	{
		CHString strSubdir = MakePath(szDirectory, TOBSTRT(stackchstrSubdirList.top()));
        stackchstrSubdirList.pop();
		strReturnFile = FindFileBySize(TOBSTRT(strSubdir), szFileSpec, dwMinSize, dwMaxSize, bRecursive);
	}

	// Well, the destructor should take care of this, but it's good to be tidy...

	// listSubdir.RemoveAll();	 well, we're not that tidy

	return strReturnFile;
}

//-----------------------------------------------------------------------------
// This simple little function combines two strings together into a path.
// It will make sure that the backslash is placed correctly (and only one).
//-----------------------------------------------------------------------------

CHString MakePath(LPCTSTR szFirst, LPCTSTR szSecond)
{
	CHString	strFirst(szFirst), strSecond(szSecond);

	if (strFirst.Right(1) == CHString(_T("\\")))
		strFirst = strFirst.Left(strFirst.GetLength() - 1);

	if (strSecond.Left(1) == CHString(_T("\\")))
		strSecond = strFirst.Right(strSecond.GetLength() - 1);

	strFirst += CHString(_T("\\")) + strSecond;
	return strFirst;
}

//=============================================================================
// NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE
//
// The following code is lifted from version 2.51 (and 2.5) of MSInfo. It's
// been modified only enough to get it to compile in this environment. It seems
// to have worked in the older version, so it should work here.
//=============================================================================

// IMPLEMENT_DYNAMIC(CCdTest, CObject);

//#if defined(_DEBUG)
//#define new DEBUG_NEW
//#endif

#if !defined(HKEY_DYN_DATA)
	#define HKEY_DYN_DATA	((HKEY)0x80000006)
#endif

LPCTSTR szDOT_DOT = _T("..");                              // for common.h
TCHAR cFIRST_DRIVE = _T('C');
TCHAR cLAST_DRIVE = _T('Z');
LPCTSTR szPERF_STATS_DATA_KEY = _T("PerfStats\\StatData");
LPCTSTR szCPU_USAGE = _T("KERNEL\\CPUUsage");

DWORD MyGetFileSize(LPCTSTR pszFile, BOOL bSystemFile);
CONST DWORD dwINVALID_SIZE = 0xFFFFFFFF;

DWORD MyGetFileSize (LPCTSTR pszFile, BOOL bSystemFile)
{
    DEBUG_OUTF(TL_VERBOSE, (_T("MyGetFileSize(%s, %d)\n"), pszFile, bSystemFile));
    DWORD dwSize = dwINVALID_SIZE;

#if defined(WIN32)
    DWORD dwFileAttributes = bSystemFile ? FILE_ATTRIBUTE_SYSTEM : FILE_ATTRIBUTE_NORMAL;
    HANDLE hFile = CreateFile(pszFile,                      // full pathname
                      0,                                    // access mode: just query attributes
                      FILE_SHARE_READ | FILE_SHARE_WRITE,   // share mode
                      NULL,                                 // security attributes
                      OPEN_EXISTING,                        // how to create
                      FILE_ATTRIBUTE_SYSTEM,                // file attributes
                      NULL);                                // template file
    if (ValidHandle(hFile))
        {
        dwSize = GetFileSize(hFile, NULL);
        CloseHandle(hFile);
        hFile = NULL;
        }

    if (dwSize == dwINVALID_SIZE)
        {
        DEBUG_OUTF(TL_BASIC, (_T("MyGetFileSize: error %lu when getting size of %s\n"),
                               GetLastError(), pszFile));
        }
#endif

    return (dwSize);
}

//-----------------------------------------------------------------------------
//	CCdTest class implementation
//-----------------------------------------------------------------------------

//	Constuct an instance of a CdTest class. This initializes the instance
//	and allocates memory for the file buffers, aligned on a CD sector boundary.
//
CCdTest::CCdTest (VOID)
{
	DEBUG_OUTF(TL_VERBOSE, _T("CCdTest::CCdTest()\n"));
	//	Allocate memory for the file buffers.
	m_pBufferSrcStart = new BYTE[nCD_SECTOR_SIZE + dwBUFFER_SIZE];
	if ( ! m_pBufferSrcStart )
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}

	m_pBufferDestStart = new BYTE[nCD_SECTOR_SIZE + dwBUFFER_SIZE];
	if ( ! m_pBufferDestStart )
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}

	//	Align buffers on a sector boundary. This is a requirement for using
	//	Win32 nonbuffered I/O.
	m_pBufferSrc = (PBYTE)AlignPointer(m_pBufferSrcStart, nCD_SECTOR_SIZE);
	m_pBufferDest = (PBYTE)AlignPointer(m_pBufferDestStart, nCD_SECTOR_SIZE);
	m_dwBufferSize = dwBUFFER_SIZE;
    m_hFileSrc = NULL;
    m_hFileDest = NULL;
	Reset();
}


//	Destruct an instance of a CdTest class. This frees memory used by the file buffers.
//
CCdTest::~CCdTest (VOID)
{
	DEBUG_OUTF(TL_VERBOSE, _T("CCdTest::~CCdTest()\n"));
	if (m_pBufferSrcStart)
	{
		delete [] m_pBufferSrcStart;
	}
	if (m_pBufferDestStart)
	{
		delete [] m_pBufferDestStart;
	}
	//_ASSERT(m_fileSrc.m_hFile == CFile::hFileNull);
	//_ASSERT(m_fileDest.m_hFile == CFile::hFileNull);
    //_ASSERT(m_hFileSrc == NULL);
	//_ASSERT(m_hFileDest == NULL);
    if(m_hFileSrc != NULL)
    {
        CloseHandle(m_hFileSrc);
        m_hFileSrc = NULL;
    }
    if(m_hFileDest != NULL)
    {
        CloseHandle(m_hFileDest);
        m_hFileDest = NULL;
    }
}


BOOL KeepBusy (DWORD dwNumMilliSecs)
{
    DEBUG_OUTF(TL_GARRULOUS, (_T("KeepBusy(%lu)\n"), dwNumMilliSecs));
    DWORD dwStart = GetTickCount();
    while ((GetTickCount() - dwStart) < dwNumMilliSecs)
    {
		DWORD dwNum = GetTickCount();
		dwNum *= 2;
    }
    return (TRUE);
}


//	Reset the test results
//
//	TODO: flush the disk cache
//
VOID CCdTest::Reset (VOID)
{
	DEBUG_OUTF(TL_VERBOSE, (_T("CCdTest::Reset()\n")));
	m_cDrive = cNULL;
	m_rTransferRate = 0.0;
	m_rCpuUtil = 0.0;
	m_dwTotalTime = 0;
	m_dwTotalBusy = 0;
	m_dwTotalBytes = 0;
	m_dwTotalCPU = 0;
	m_nNumSamples = 0;
	m_dwFileSize = 0;
}


//	Read a block of data from the drive, maintaining timing stats.
//
BOOL CCdTest::ProfileBlockRead (DWORD dwBlockSize, BOOL bIgnoreTrial /* = FALSE */)
{
	BOOL bOK = FALSE;
	try
		{
		DEBUG_OUTF(TL_VERBOSE, (_T("CCdTest::ProfileBlockRead(%lu, %d): offset=%lu\n"),
							    dwBlockSize, bIgnoreTrial, m_fileSrc.GetPosition()));
		ASSERT_BREAK(dwBlockSize <= m_dwBufferSize);

		//	Initialize the trial: for example, set up a high priority for the timing
		//	interval.
		HANDLE hThread = GetCurrentThread();
		DWORD dwOldPriority = GetThreadPriority(hThread);
		SetThreadPriority(hThread, THREAD_PRIORITY_TIME_CRITICAL);
		DWORD dwStartTime = GetTickCount();

		//	Read in the next block from the drive
		//DWORD dwNum = m_fileSrc.Read(m_pBufferSrc, dwBlockSize);
        DWORD dwNum = 0;
        ReadFile(m_hFileSrc,m_pBufferSrc, dwBlockSize, &dwNum, NULL);
		bOK = (dwNum == dwBlockSize);

		//	Determine the time for the trial; restore the priority
		DWORD dwEndTime = GetTickCount();
		DWORD dwTime = (dwEndTime - dwStartTime);
#if TRUE
		DWORD dwWorkLeft = 0;
		if (m_bDoPacing)
			{
			INT nExtra = (INT)m_dwExpTimePerBlock - dwTime;
			nExtra = max(0, nExtra);
			dwWorkLeft = nExtra;
			KeepBusy(dwWorkLeft);
			}
#endif

		SetThreadPriority(hThread, dwOldPriority);
		DEBUG_OUTF(TL_GARRULOUS, (_T("Time: (%lu, %lu); Block Size: %lu; Num Read: %lu\n"),
							  	   dwStartTime, dwEndTime, dwBlockSize, dwNum));
        DWORD dwBytesPerMs = (dwTime > 0) ? (dwBlockSize / dwTime) : -1;
		DEBUG_OUTF(TL_VERBOSE, (_T("Time: %lu (%lu B/ms)\n"), dwTime, dwBytesPerMs));

		//	Accumulate the statistics
		if (!bIgnoreTrial)
			{
			m_dwTotalTime += dwTime;
			m_dwTotalBusy += dwWorkLeft;
			//m_dwTotalCPU += dwCpuUtil;
			m_dwTotalBytes += dwBlockSize;
			m_nNumSamples++;
			}
		}

	catch (...)
		{
		DEBUG_OUTF(TL_VERBOSE, (_T("Exception during block read\n")));
		bOK = FALSE;
		}

	return (bOK);
}


//	Prepare to start profiling the CD drive: The test file for checking transfer rate
//	is opened.
//
BOOL CCdTest::InitProfiling (LPCTSTR pszCdTestFile)
{
	BOOL bOK = FALSE;

	try
		{
		DEBUG_OUTF(TL_VERBOSE, (_T("CCdTest::InitProfiling(%s)\n"),
							    F1(pszCdTestFile)));

		//	Determine expected time per block, etc (in milliseconds)
		m_dwExpTimePerBlock = (dwBLOCK_SIZE * 1000) / dwEXP_RATE;

	    //  Determine the location on the hard drive where to copy it
//		ASSERT_BREAK(FileExists(pszCdTestFile));
	    m_dwFileSize = MyGetFileSize(pszCdTestFile, FALSE);      // not a system file
		if (m_dwFileSize < dwBLOCK_SIZE)
			{
			DEBUG_OUTF(TL_BASIC, (_T("File too small (< %lu) to profile\n"),
								  F1(pszCdTestFile), dwBLOCK_SIZE));
			return (FALSE);
			}
		DEBUG_OUTF(TL_DETAILED, (_T("Reading %s of size %lu\n"), pszCdTestFile, m_dwFileSize));

		//	Open the file
		HANDLE hFile = OpenFileNonbuffered(pszCdTestFile);
		//m_fileSrc.m_hFile = (UINT)hFile;
        m_hFileSrc = hFile;
		bOK = (ValidHandle(hFile));
		}

	catch (...)
		{
		DEBUG_OUTF(TL_VERBOSE, (_T("Exception during profiling initialization\n")));
		bOK = FALSE;
		}

	return (bOK);
}


//  Profile the CD drive's speed and check its integrity.
//	Pacing is used to determine CPU util at 300KB/sec. Then the drive is
//	let loose to determine raw throughput.
//
BOOL CCdTest::ProfileDrive (LPCTSTR pszCdTestFile)
{
	BOOL bOK = TRUE;

	try
	{
		DEBUG_OUTF(TL_VERBOSE, (_T("CCdTest::ProfileCdDrive(%s)\n"),
							    F1(pszCdTestFile)));

		if (!InitProfiling(pszCdTestFile))
		{
			return (FALSE);
		}
		ASSERT_BREAK(m_dwFileSize > 0);

		//	Determine the number of samples
		DWORD dwNumBlocks = m_dwFileSize / dwBLOCK_SIZE;
		DWORD dwExtraSize = m_dwFileSize % dwBLOCK_SIZE;
		m_bDoPacing = FALSE;

		//	Read a block of data to prime the drive
		dwNumBlocks--;
		ProfileBlockRead(dwBLOCK_SIZE, TRUE);		// discard stats

		//	Read the first half of the file and maintain stats for nonpaced reads
		DWORD dwNumPacedSamples = dwNumBlocks/2;
		for (DWORD b = 0; (bOK) && (b < dwNumPacedSamples); b++)
		{
			bOK = ProfileBlockRead(dwBLOCK_SIZE);
		}

	    //  Determine the drive performance
		if (bOK)
		{
			DEBUG_OUTF(TL_DETAILED, (_T("ProfileCdDrive NonPaced Totals: Time=%lu Samples=%lu Bytes=%lu\n"),
									 m_dwTotalTime, m_nNumSamples, m_dwTotalBytes));
			if ((m_nNumSamples > 0) && (m_dwTotalTime > 0))
			{
	    		m_rTransferRate = ((DOUBLE)m_dwTotalBytes / 1024) / m_dwTotalTime;  // rate in KB/ms
	    		m_rTransferRate *= 1000;                                  			// rate in KB/s
			}
		}

		//	Read the remaining the blocks and maintain stats during
		//	paced reads
		m_bDoPacing = TRUE;
		m_dwTotalTime = 0;
		m_dwTotalBytes = 0;
		m_nNumSamples = 0;
		for (; (bOK) && (b < dwNumBlocks); b++)
		{
			bOK = ProfileBlockRead(dwBLOCK_SIZE);
		}
		if (bOK)
		{
			DEBUG_OUTF(TL_DETAILED, (_T("ProfileCdDrive Paced Totals: CdTime=%lu WorkloadTime=%lu Samples=%lu Bytes=%lu\n"),
									 m_dwTotalTime, m_dwTotalBusy, m_nNumSamples, m_dwTotalBytes));
			if ((m_nNumSamples > 0) && (m_dwTotalTime > 0))
			{
				DOUBLE dMaxExpTime = ((DOUBLE)m_nNumSamples * m_dwExpTimePerBlock);
				ASSERT_BREAK(dMaxExpTime > 0);
				m_rCpuUtil = ((DOUBLE)m_dwTotalTime * 100.0) / dMaxExpTime;
			}
		}

		//	Complain if things went wrong
		if (!bOK)
		{
			DEBUG_OUTF(TL_DETAILED, (_T("The test results are vacuous\n")));
			bOK = FALSE;
		}
		//m_fileSrc.Close();
        CloseHandle(m_hFileSrc);
        m_hFileSrc = NULL;
#if TRUE
		//	Clean up after the test (eg, delete the large temporary file)
		if (FileExists(TOBSTRT(m_sTempFileSpec)))
		{
			SetFileAttributes(TOBSTRT(m_sTempFileSpec), FILE_ATTRIBUTE_NORMAL);
			DeleteFile(TOBSTRT(m_sTempFileSpec));
		}
#endif

    }
	catch (...)
	{
		DEBUG_OUTF(TL_VERBOSE, (_T("Exception during profiling\n")));
		bOK = FALSE;
	}
    return bOK;
}


//	Initialize for the integrity checks. Copy the test file to the hard drive,
//	and then open both versions of the file for a subsequent comparison.
//
BOOL CCdTest::InitIntegrityCheck (LPCTSTR pszCdTestFile)
{
	BOOL bOK = FALSE;

	m_dwFileSize = MyGetFileSize(pszCdTestFile, FALSE);      // not a system file

	//	Derive name for temp file to contain a copy of the CD file
	//	TODO: delete the file after the test is done
    TCHAR szTempFileSpec[MAX_PATH];
    if (!GetTempDirectory(szTempFileSpec, STR_LEN(szTempFileSpec)))
		{
		DEBUG_OUTF(TL_VERBOSE, (_T("Failed to GetTempDirectory\n")));
		return (FALSE);
		}

    size_t size;
    if(SUCCEEDED(StringCchLength(pszCdTestFile, MAX_PATH, &size))){
        LPCTSTR szTemp = pszCdTestFile + size;
        for(;szTemp!=pszCdTestFile;)
        {
            if(*(szTemp - 1) == L'\\') break;
            szTemp--;
        }

        if(FAILED(StringCchCat(szTempFileSpec,MAX_PATH , szTemp)))
            return FALSE;
    } else {
        return FALSE;
    }


#if TRUE
	m_sTempFileSpec = szTempFileSpec;
#endif

	//	If the temp file already exists, delete it
	if (FileExists(szTempFileSpec))
		{
		SetFileAttributes(szTempFileSpec, FILE_ATTRIBUTE_NORMAL);
		BOOL bDeleteOK = DeleteFile(szTempFileSpec);
		if (!bDeleteOK)
			{
			DEBUG_OUTF(TL_BASIC, (_T("Error %lu deleting %s\n"),
							  	  GetLastError(), szTempFileSpec));
			}
		}

	//	Copy the file to the temporary directory
	BOOL bCopyOK = CopyFile(pszCdTestFile, szTempFileSpec, FALSE);    // overwrites if source exists
	if (!bCopyOK)
		{
		DEBUG_MSGF(TL_BASIC, (_T("Error %lu copying %s to %s\n"),
							  GetLastError(), pszCdTestFile, szTempFileSpec));
		return (FALSE);
		}

	//	Open the two files for a subsequent binary comparison
	try
		{
		DEBUG_OUTF(TL_VERBOSE, (_T("CCdTest::InitIntegrityCheck(%s)\n"),
							    F1(pszCdTestFile)));

	    //  Determine the location on the hard drive where to copy it
		ASSERT_BREAK(FileExists(pszCdTestFile));
		ASSERT_BREAK(FileExists(szTempFileSpec));

		//	Open the files
#if FALSE
		bOK = m_fileSrc.Open(pszCdTestFile, CFile::modeRead | CFile::shareCompat);
		bOK = bOK && m_fileDest.Open(szTempFileSpec, CFile::modeRead | CFile::shareCompat);
#else
		//	Open the files w/o any buffering whatsoever
		HANDLE hSource = OpenFileNonbuffered(pszCdTestFile);
		//m_fileSrc.m_hFile = (UINT)hSource;
        m_hFileSrc = hSource;
		HANDLE hDest = OpenFileNonbuffered(szTempFileSpec);
		//m_fileDest.m_hFile = (UINT)hDest;
        m_hFileDest = hDest;
		bOK = (ValidHandle(hSource) && ValidHandle(hDest));
#endif
		}

	catch (...)
		{
		DEBUG_OUTF(TL_VERBOSE, (_T("Exception during integrity check initialization\n")));
		bOK = FALSE;
		}

	//	Clean up after a failure
	if (!bOK)
	{
		//if (ValidHandle((HANDLE)m_fileSrc.m_hFile))
		//{
		//	m_fileSrc.Close();
		//}
		//if (ValidHandle((HANDLE)m_fileDest.m_hFile))
		//{
		//	m_fileDest.Close();
		//}
        if(ValidHandle((HANDLE)m_hFileSrc))
		{
			CloseHandle(m_hFileSrc);
            m_hFileSrc = NULL;
		}
		if(ValidHandle((HANDLE)m_hFileDest))
		{
			CloseHandle(m_hFileDest);
            m_hFileDest = NULL;
		}
	}

	return (bOK);
}


//	Compare the next blocks from the test file and its copy during the integrity check.
//
BOOL CCdTest::CompareBlocks ()
{
	DEBUG_OUTF(TL_VERBOSE, (_T("CCdTest::CompareBlocks(): block size = %lu\n"),
							dwBLOCK_SIZE));
	BOOL bOK = TRUE;

	// Perform a blockwise comparison of the files
	DWORD dwNumBlocks = (m_dwFileSize + dwBLOCK_SIZE - 1) / dwBLOCK_SIZE;
	for (DWORD dwBlock = 1; dwBlock <= dwNumBlocks; dwBlock++)
		{
		DEBUG_OUTF(TL_GARRULOUS, (_T("Testing block %lu; offset = %lu\n"), dwBlock, m_fileSrc.GetPosition()));

		//	Read in the next block from the drive
		//DWORD dwNumSrc = m_fileSrc.Read(m_pBufferSrc, dwBLOCK_SIZE);
		//DWORD dwNumDest = m_fileDest.Read(m_pBufferDest, dwBLOCK_SIZE);
        DWORD dwNumSrc = 0;
        DWORD dwNumDest = 0;
        ReadFile(m_hFileSrc, m_pBufferSrc, dwBLOCK_SIZE, &dwNumSrc, NULL);
		ReadFile(m_hFileDest, m_pBufferDest, dwBLOCK_SIZE, &dwNumDest, NULL);
		if (dwNumSrc != dwNumDest)
		{
			DEBUG_OUTF(TL_DETAILED, (_T("Num bytes read differ for block %lu (%lu vs %lu)\n"),
								    dwBlock, dwNumSrc, dwNumDest));
			bOK = FALSE;
			break;
		}

		//	Make sure that both blocks were read successfully
		if ((dwNumSrc != dwBLOCK_SIZE) && (dwBlock != dwNumBlocks))
		{
			DEBUG_OUTF(TL_DETAILED, (_T("Only %lu bytes were read for block %lu\n"),
								    dwNumSrc, dwBlock));
			bOK = FALSE;
			break;
		}

		//	Make sure that the blocks are identical
		if (CompareMemory(m_pBufferSrc, m_pBufferDest, dwNumSrc) != 0)
			{
			DEBUG_OUTF(TL_DETAILED, (_T("The files differ at block %lu\n"),
								    dwBlock));
			bOK = FALSE;
			break;
			}
		}
	if (bOK && (dwBlock <= dwNumBlocks))
		{
		ASSERT_BREAK(dwBlock != dwNumBlocks);
		DEBUG_OUTF(TL_DETAILED, (_T("Only %lu of %lu blocks were read/compared\n"),
								dwBlock, dwNumBlocks));
		bOK = FALSE;
		}

	return (bOK);
}


//  Profile the CD drive's speed and check its integrity
//
BOOL CCdTest::TestDriveIntegrity (LPCTSTR pszCdTestFile)
{
	BOOL bOK = FALSE;

	try
	{
		DEBUG_OUTF(TL_VERBOSE, (_T("CCdTest::TestDriveIntegrity(%s)\n"),
							    F1(pszCdTestFile)));

		bOK = InitIntegrityCheck(pszCdTestFile);
		if (bOK)
		{
			bOK = CompareBlocks();
			//m_fileSrc.Close();
			//m_fileDest.Close();
            CloseHandle(m_hFileSrc);
            m_hFileSrc = NULL;
			CloseHandle(m_hFileDest);
            m_hFileDest = NULL;
		}
#if TRUE
		//	Clean up after the test (eg, delete the large temporary file)
		if (FileExists(TOBSTRT(m_sTempFileSpec)))
		{
			SetFileAttributes(TOBSTRT(m_sTempFileSpec), FILE_ATTRIBUTE_NORMAL);
			DeleteFile(TOBSTRT(m_sTempFileSpec));
		}
#endif

	    //  Note that the drive passed or failed
		m_bIntegityOK = bOK;
	}

	catch (...)
		{
		DEBUG_OUTF(TL_VERBOSE, (_T("Exception during integrity checks\n")));
		bOK = FALSE;
		}

	return (bOK);
}


//-----------------------------------------------------------------------------
//	Utility functions
//-----------------------------------------------------------------------------


//	Obsolete function for determining the CPU utilization. This only works
//	under Windows 95.
//
DWORD GetCpuUtil (VOID)
{
    DWORD dwUtil = 0;

    if (IsWin95Running())
        {
        GetRegistryBinary(HKEY_DYN_DATA, (LPTSTR)szPERF_STATS_DATA_KEY, (LPTSTR)szCPU_USAGE,
                          &dwUtil, sizeof(dwUtil));
        }

    return (dwUtil);
}


//	OLDFindFileBySize: find the first file in the given directory branch matching
//	the size contraints.
//
CHString OLDFindFileBySize (LPCTSTR pszDirectory, LPCTSTR pszFileSpec, DWORD dwMinSize, DWORD dwMaxSize, BOOL bRecursive)
{
    DEBUG_OUTF(TL_VERBOSE, (_T("OLDFindFileBySize(%s, %s, %lu, %lu, %d)\n"),
    						F1(pszDirectory), F2(pszFileSpec), dwMinSize, dwMaxSize, bRecursive));
    WIN32_FIND_DATA ffd;
	CHString sFile;

	// Initialize the search
	CHString sDirSpec = MakePath(pszDirectory, pszFileSpec);
	//CHStringList listSubdir;
    std::stack<CHString> stackchstrSubdirList;
    HANDLE hFindFile = FindFirstFile(TOBSTRT(sDirSpec), &ffd);
    if (hFindFile == INVALID_HANDLE_VALUE)
    {
        DEBUG_OUTF(TL_DETAILED, (_T("OLDFindFileBySize: FindFirstFile('%s',...) failed with code %lu\n"),
                                 F1(sDirSpec), GetLastError()));
		return (sFile);
    }

	//	Check each file in the directory
	BOOL bMore = TRUE;
    while (bMore)
    {
    	//  Postpone checking subdirectories until current direcoty processed
        if ((ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY)
        {
			if (bRecursive)
			{
				//	Add the directory unless its one of the special ones ('.' and '..')
				if ((StringCompare(ffd.cFileName, szDOT) != 0)
					&& (StringCompare(ffd.cFileName, szDOT_DOT) != 0))
				{
					// listSubdir.AddTail(ffd.cFileName);
                    CHString chstrTemp = ffd.cFileName;
                    stackchstrSubdirList.push(chstrTemp);
				}
			}
        }

		//	Ignore system files
        if (((ffd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM) == FILE_ATTRIBUTE_SYSTEM)
			|| ((ffd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN) == FILE_ATTRIBUTE_HIDDEN))
		{
			//	do nothing
		}

		//	See if the file size contraints are met
        else if ((dwMinSize <= ffd.nFileSizeLow) && (ffd.nFileSizeLow <= dwMaxSize))
		{
			//sFile.Format("%s\\%s", pszDirectory, ffd.cFileName);
			sFile = MakePath(pszDirectory, ffd.cFileName);
			break;
		}

        bMore = FindNextFile(hFindFile, &ffd);
    }

	//	If subdirectories should be checked, traverse each one until a right-sized file
	//	is encountered.
	if (sFile.IsEmpty())
	{
		ASSERT_BREAK(bRecursive || stackchstrSubdirList.empty());
		while (!stackchstrSubdirList.empty())
		{
			//CHString sSubdir = MakePath(pszDirectory, listSubdir.RemoveHead());
            CHString sSubdir = MakePath(pszDirectory, TOBSTRT(stackchstrSubdirList.top()));
            stackchstrSubdirList.pop();
			sFile = OLDFindFileBySize(TOBSTRT(sSubdir), pszFileSpec, dwMinSize, dwMaxSize, bRecursive);
			if (!sFile.IsEmpty())
			{
				break;
			}
		}
	}

	//	Cleanup after the search
	// listSubdir.RemoveAll();	// done for us with std::stack

	return (sFile);
}


//	Determine whether the specified logical drive is for a CD ROM.
//
BOOL IsCdDrive (CHAR cDrive)
{
	CHString sDriveRoot = MakeRootPath(cDrive);

    UINT uDriveType = GetDriveType(TOBSTRT(sDriveRoot));
    DEBUG_OUTF(TL_GARRULOUS, (_T("%u <= GetDriveType(%s)\n"), uDriveType, (LPCTSTR)sDriveRoot));
	return (uDriveType == DRIVE_CDROM);
}


//	Determine whether the specified logical drive is a local drive.
//
BOOL IsLocalDrive (CHAR cDrive)
{
	CHString sDriveRoot = MakeRootPath(cDrive);

    UINT uDriveType = GetDriveType(TOBSTRT(sDriveRoot));
    DEBUG_OUTF(TL_GARRULOUS, (_T("%u <= GetDriveType(%s)\n"), uDriveType, (LPCTSTR)sDriveRoot));
	return ((uDriveType != DRIVE_REMOTE)
			&& (uDriveType != DRIVE_UNKNOWN)
			&& (uDriveType != DRIVE_NO_ROOT_DIR));
}


//	Find the next CD drive in the system after the specified logical drive. If the
//	drive specified is empty, the first CD drive will be returned.
//
CHAR FindNextCdDrive (CHAR cCurrentDrive)
{
	DEBUG_OUTF(TL_VERBOSE, (_T("FindNextCdDrive(%x)\n"), cCurrentDrive));

    //  Find the next CD rom drive
    CHAR cCdDrive = cNULL;
	CHAR cStart = (cCurrentDrive == cNULL)
					? cFIRST_DRIVE
					: (cCurrentDrive + 1);

	for (CHAR cDrive = cStart; (cDrive <= cLAST_DRIVE); cDrive++)
		{
		if (IsCdDrive(cDrive))
            {
            cCdDrive = cDrive;
            break;
            }
        }

	return (cCdDrive);
}


//	Find the next local drive in the system after the specified logical drive. If the
//	drive specified is empty, the first local drive will be returned.
//
CHAR FindNextLocalDrive (CHAR cCurrentDrive)
{
	DEBUG_OUTF(TL_VERBOSE, (_T("FindNextCdDrive(%x)\n"), cCurrentDrive));

    //  Find the next local drive
    CHAR cLocalDrive = cNULL;
	CHAR cStart = (cCurrentDrive == cNULL)
					? cFIRST_DRIVE
					: (cCurrentDrive + 1);

	for (CHAR cDrive = cStart; (cDrive <= cLAST_DRIVE); cDrive++)
		{
		if (IsLocalDrive(cDrive))
			{
			cLocalDrive = cDrive;
			break;
			}
		}

	return (cLocalDrive);
}


//	Find the next local drive in the system after the specified logical drive. If the
//	drive specified is empty, the first local drive will be returned.
//
CHAR FindDriveByVolume (CHString sVolume)
{
	DEBUG_OUTF(TL_VERBOSE, (_T("FindDriveByVolume(%s)\n"), F(sVolume)));

    //  Find the next local drive
    CHAR cDrive = cNULL;
	for (CHAR cCurrent = cFIRST_DRIVE; (cCurrent <= cLAST_DRIVE); cCurrent++)
		{
		CHString sRootDir = MakeRootPath(cCurrent);
		CHString sDriveVolume = GetVolumeName(TOBSTRT(sRootDir));
		if (sDriveVolume.CompareNoCase(sVolume) == 0)
			{
			cDrive = cCurrent;
			break;
			}
		}

	return (cDrive);
}


//	Open a binary file with access depending on several boolean switches, such as
//	whether the file should be created if new.
//
HANDLE OpenBinaryFile (LPCTSTR pszFile, BOOL bNew, BOOL bBuffered, BOOL bWritable)
{
	HANDLE hFile = INVALID_HANDLE_VALUE;

    DWORD dwCreate = bNew ? CREATE_ALWAYS : OPEN_ALWAYS;
	DWORD dwAccess = GENERIC_READ;
	DWORD dwAttrsAndFlags = FILE_ATTRIBUTE_NORMAL;
	if (bWritable)
		{
		dwAccess |= GENERIC_WRITE;
		}
	if (!bBuffered)
		{
		dwAttrsAndFlags |= (FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING);
		}
    hFile = CreateFile(pszFile,                         // full pathname
                       dwAccess,    					// access mode
                       FILE_SHARE_READ,                 // share mode
                       NULL,                            // security attributes
                       dwCreate,                        // how to create
                       dwAttrsAndFlags,           		// file attributes
                       NULL);                           // template file
	return (hFile);
}


//	Open an existing (binary) file for nonbuffered read-only access.
//
HANDLE OpenFileNonbuffered (LPCTSTR pszFile)
{
	return (OpenBinaryFile(pszFile, 	// name
						   FALSE,		// must exist
						   FALSE,		// non-buffered I/O
						   FALSE));		// not for write access
}


//	Return a pointer that is aligned on a given boundary. That is, the pointer
//	must be a integer multiple of the alignment factor (eg, 8192 for 512 alignment).
//
PVOID AlignPointer (PVOID pData, INT nAlignment)
{
	PBYTE pStart = (PBYTE)pData;
	DWORD_PTR dwStart = (DWORD_PTR)pData;
	INT nOffset = (dwStart % nAlignment);
	if (nOffset > 0)
		{
		dwStart = (dwStart + nAlignment - nOffset);
		}
	ASSERT_BREAK((dwStart % nAlignment) == 0);

	return ((PVOID)dwStart);
}

BOOL FileExists (LPCTSTR pszFile) //, POFSTRUCT pofs)
{
//    ASSERT_BREAK(pofs);

    //  Make sure that annoying error message boxes don't pop up
    // this is done in the core, right now.
    // UINT uPrevErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);


#if TRUE
	TCHAR szFile[MAX_PATH];
	if (pszFile[0] == cDOUBLE_QUOTE)
		{
		ParseString(pszFile, szFile, STR_LEN(szFile));
		pszFile = szFile;
		}
#endif
    //BOOL bExists = (OpenFile(pszFile, pofs, OF_EXIST) != HFILE_ERROR);
    BOOL bExists = _taccess(pszFile, 0) != -1;
    DEBUG_OUTF(TL_VERBOSE, (_T("%d <= FileExists(%s)\n"), bExists, pszFile));

    //  Restore the error state
    // this is done in the core, global to the process.
    // SetErrorMode(uPrevErrorMode);

    return (bExists);
}

BOOL GetTempDirectory (LPTSTR pszTempDir, INT nMaxLen)
{
    DEBUG_OUTF(TL_VERBOSE, (_T("GetTempDirectory(%08lx,%d)\n"), pszTempDir, nMaxLen));
    BOOL bOK = FALSE;

#if defined(WIN32)

    DWORD dwLen = GetTempPath(nMaxLen, pszTempDir);
    bOK = (dwLen > 0);
    if (!bOK)
    	{
        DEBUG_OUTF(TL_BASIC, (_T("GetTempDirectory: error %lu from GetTempPath(%d,%08lx)\n"),
                              GetLastError(), nMaxLen, pszTempDir));
    	}

#else

    bOK = GetEnvironmentVar(szTEMP, pszTempDir, nMaxLen);

#endif

    return (bOK);
}

BOOL GetRegistryBinary (HKEY hBaseKey, LPCTSTR pszSubKey, LPCTSTR pszValue,
                        PVOID pData, DWORD dwMaxDataLen)
{
    DWORD dwType;
    BOOL bOK = GetRegistryValue(hBaseKey, pszSubKey, pszValue, &dwType, pData, dwMaxDataLen);
    if (bOK)
    {
        ASSERT_BREAK(IsRegBinaryType(dwType)
               || ((dwMaxDataLen == sizeof(DWORD)) && IsRegNumberType(dwType)));
    }

    return (bOK);
}

BOOL GetRegistryValue (HKEY hBaseKey, LPCTSTR pszSubKey, LPCTSTR pszValue,
                       PDWORD pdwValueType, PVOID pData, DWORD dwMaxDataLen)
{
    DEBUG_OUTF(TL_GARRULOUS, (_T("GetRegistryValue(%x,%s,%s,%x,%x,%lu)\n"),
                            hBaseKey, pszSubKey, pszValue,
                            pdwValueType, pData, dwMaxDataLen));
    ASSERT_BREAK(pszSubKey);
    ASSERT_BREAK(pszValue);
    ASSERT_BREAK(pdwValueType);
    ASSERT_BREAK(pData);
    ASSERT_BREAK(dwMaxDataLen > 0);

    //  Initialize variables
    HKEY hSubKey = NULL;
    BOOL bOK = FALSE;
    *pdwValueType = REG_NONE;

    //  Open the section for the specified key (eg, HLM: SYSTEM\CurrentControlSet)
    LONG lStatus = RegOpenKeyEx(hBaseKey,   // handle of open parent key
                           pszSubKey,       // address of name of subkey to open
                           0,               // reserved (must be zero)
                           KEY_READ,        // security access mask
                           &hSubKey);       // address of handle of open key
    if (lStatus != ERROR_SUCCESS)
    {
        DEBUG_OUTF(TL_BASIC, (_T("Error %ld opening registry key %s\n"), lStatus, pszSubKey));
    }
    else
    {
        //  Read in the requested value
        LPTSTR pszValueName = (LPTSTR)pszValue;     // shameless cast required by RegQueryValueEx
        lStatus = RegQueryValueEx(hSubKey,          // handle of key to query
                                  pszValueName,     // address of value name for query
                                  NULL,             // reserved
                                  pdwValueType,     // address of buffer for value type
                                  (PBYTE)pData,     // address of data buffer
                                  &dwMaxDataLen);   // address of data buffer size
        if (lStatus != ERROR_SUCCESS)
        {
            DEBUG_OUTF(TL_BASIC, (_T("Error %ld reading data for registry value %s (of %s)\n"),
                                     lStatus, pszValueName, pszSubKey));
        }
        else
        {
            bOK = TRUE;
        }
    }

    if (ValidHandle(hSubKey))
    {
        RegCloseKey(hSubKey);
    }

    DEBUG_OUTF(TL_GARRULOUS, (_T("GetRegistryValue => %d (pData => %s; pdwValueType => %lu)\n"),
                            bOK,
                            (IsRegStringType(*pdwValueType) ? (LPCTSTR)pData : szBINARY),
                            *pdwValueType));
    return (bOK);
}

CHString GetVolumeName (LPCTSTR pszRootPath)
{
	DEBUG_OUTF(TL_VERBOSE, (_T("GetVolumeName(%s): "), F1(pszRootPath)));
	CHString    sVolumeName;
    TCHAR       szBuff[MAX_PATH] = _T("");

	//DWORD dwF
//	LPTSTR pszVolume = sVolumeName.GetBuffer(MAX_PATH);
	GetVolumeInformation(pszRootPath, szBuff, MAX_PATH, NULL, NULL, NULL, NULL, 0);
//	sVolumeName.ReleaseBuffer();
    sVolumeName = szBuff;
	DEBUG_OUTF(TL_VERBOSE, (L"%s\n", F1(sVolumeName)));

	return (sVolumeName);
}


LPCTSTR ParseString (
    LPCTSTR pszSource,
    LPTSTR pszBuffer,
    INT nLen
    )
{
    pszSource = SkipSpaces((LPTSTR) pszSource);
    if (IsQuoteChar(*pszSource))
    	{
        pszSource = ParseQuotedString(pszSource, pszBuffer, nLen);
    	}
    else
    	{
        pszSource = ParseToken(pszSource, pszBuffer, nLen);
    	}

    return (pszSource);
}

LPCTSTR ParseToken (
    LPCTSTR pszSource,
    LPTSTR pszBuffer,
    INT nLen
    )
{
    ASSERT_BREAK(pszSource);
    ASSERT_BREAK(pszBuffer);

    //  Skip any leading whitespace, and then accumulate a token char run
    pszSource = SkipSpaces((LPTSTR) pszSource);

	// If this is for DBCS, the string needs to be scanned with a little more care.
	// This is from the Japanese version. (a-jammar, 5/10/96, japanese)

#ifdef DBCS
	while (*pszSource && (nLen > 0) && (IsDBCSLeadByte(*pszSource) || IsTokenChar(*pszSource)))
#else
	while (*pszSource && (nLen > 0) && IsTokenChar(*pszSource))
#endif
   	{
        *pszBuffer = *pszSource;

		#ifdef DBCS
	  		if(IsDBCSLeadByte(*pszBuffer))
	  		{
	  			*(pszBuffer + 1) = *(pszSource + 1);
	  			nLen--;
	  		}
		#endif

        pszBuffer = PszAdvance(pszBuffer);
        pszSource = PcszAdvance(pszSource);
        nLen--;
    }
    *pszBuffer = cNULL;

    return (pszSource);
}

LPCTSTR ParseQuotedString (
    LPCTSTR pszSource,
    LPTSTR pszBuffer,
    INT nLen
    )
{
    LPCTSTR pszStart = pszSource;

    //  Skip leading whitespace, and then check for optional quote
    CHAR cEndQuote = cNULL;
    pszSource = SkipSpaces(pszSource);
    if (IsQuoteChar(*pszSource))
    	{
        cEndQuote = *pszSource;
        pszSource = PcszAdvance(pszSource);
    	}

    //  Accumulate a run of chars until closing quote encounted (or EOS)
    while (*pszSource && (nLen > 0))
    	{

        //  Check for the matching quote character
        if (*pszSource == cEndQuote)
        	{
            ASSERT_BREAK(IsQuoteChar(*pszSource));

            //  Check for an escaped quote (works w/ DBCS: first quote not lead byte)
            if (*(pszSource + 1) == cEndQuote)
            	{
                //  Ignore the first quote and let second be added to text below
                pszSource = PcszAdvance(pszSource);
                }
            else
            	{
                break;
                }
            }

        //  Add the character to the string
        CopyCharAdvance(pszBuffer, pszSource, nLen);
        }

    //  Terminate the return buffer and check for truncation
    *pszBuffer = cNULL;
    if ((nLen == 0) && *pszSource)
    	{
        DEBUG_OUTF(TL_BASIC, (_T("Buffer insufficient in ParseQuotedString\n")));
        }

    //  Advance past the closing quote, if found
    if (*pszSource == cEndQuote)
    	{
        pszSource = PcszAdvance(pszSource);
        }
    else
    	{
        DEBUG_OUTF(TL_DETAILED, (_T("ParseQuotedString: Ending quote character (%c) not found in string %s\n"),
                                 cEndQuote, pszStart));
        }

    return (pszSource);
}

BOOL FindCdRomDriveInfo (TCHAR cDrive, CHString& sDriver, CHString& sDescription)
{
    DEBUG_OUTF(TL_VERBOSE, (_T("FindCdRomDriveInfo(%c, %x, %x)\n"), cDrive, &sDriver, &sDescription));
	BOOL bOK = FALSE;

	if (IsWin95Running())
		{
		bOK = FindWin95CdRomDriveInfo(cDrive, sDriver, sDescription);
		}
    else if (IsNtRunning())
        {
		bOK = FindNtCdRomDriveInfo(cDrive, sDriver, sDescription);
        }

	return (bOK);
}


LPCWSTR apszENUM_BRANCH[]	= 		{
								 L"EISA",		// Extended ISA bus devices
								 L"ESDI",
								 L"MF",
								 L"PCI", 		// PCI bus devices
								 L"SCSI",		// SCSI devices
								 L"ROOT",		// legacy devices
#if defined(_DEBUG)
								 L"ISAPNP",		// ISA plug n' play
								 L"FLOP",		// floppy devices
#endif
								 };
WCHAR szBRANCH_KEY_FMT[] =		L"Enum\\%s";
TCHAR szCURRENT_DRIVE[] =		_T("CurrentDriveLetterAssignment");
//CHAR szDRIVER[] =				"Driver";
TCHAR szDEVICE_DESC[] =			_T("DeviceDesc");


//	This inefficient function tries to locate the information about the
//	specified CD drive in the HKEY_LOCAL_MACHINE\Enum branch of the Windows 95
//	registry. Instead of using a generic (but more inefficient) recursive search,
//	this just checks at a particular depth (namely 2) from the start for the
//	CurrentDriveLetterAssignment & Class values. This depth corresponds to keys
//	of the form ENUM\enumerator\device-id\instance
//
//	An example follows:
//
//  HKEY_LOCAL_MACHINE\Enum
//		SCSI
//			NEC_____CD-ROM_DRIVE:5002
//				PCI&VEN_1000&DEV_0001&BUS_00&DEV_0F&FUNC_0020
//					CurrentDriveLetterAssignment	E
//					Class							CDROM
//					Driver							CDROM\0000
//					DeviceDesc						NEC CD-ROM DRIVE:500
//
//	See the Plug N' Play documentation from the Win95 DDK for details on the
//	Enum branch layout.
//
//	TODO: see if there are Plug N' Play functions for doing this
//
BOOL FindWin95CdRomDriveInfo (TCHAR cDrive, CHString& sDriver, CHString& sDescription)
{
    DEBUG_OUTF(TL_VERBOSE, (_T("FindWin95RomDriveInfo(%c, %x, %x)\n"), cDrive, &sDriver, &sDescription));
	BOOL bOK = FALSE;

	cDrive = ToUpper(cDrive);

	//	Check each plug & play enumerator that might contain a CD ROM device.
	//	This includes SCSI, PCI, ROOT and ESDI.
	for (INT i = 0; i < NUM_ELEMENTS(apszENUM_BRANCH); i++)
		{
		CHString sEnumBranch;
		sEnumBranch.Format(szBRANCH_KEY_FMT, apszENUM_BRANCH[i]);
		CHStringArray sBranchSubkeys;

		//	Walk each of the device ID sections for the enumerator.
		BOOL bHasSubkeys = GetRegistrySubkeys(HKEY_LOCAL_MACHINE, TOBSTRT(sEnumBranch), sBranchSubkeys);
		for (INT j = 0; j < sBranchSubkeys.GetSize(); j++)
			{
			CHString sEnumBranchSubkey = MakePath(TOBSTRT(sEnumBranch), TOBSTRT(sBranchSubkeys[j]));
			CHStringArray sBranchSubsubkeys;

			//	Enumerate the instances for the device
			BOOL bHasSubsubkeys = GetRegistrySubkeys(HKEY_LOCAL_MACHINE, TOBSTRT(sEnumBranchSubkey), sBranchSubsubkeys);
			for (INT k = 0; k < sBranchSubsubkeys.GetSize(); k++)
				{
				//	See if the device's letter assignment matches the given drive
				CHString sSubsubkey = MakePath(TOBSTRT(sEnumBranchSubkey), TOBSTRT(sBranchSubsubkeys[k]));
				CHString sDrive = GetRegistryString(HKEY_LOCAL_MACHINE, TOBSTRT(sSubsubkey), szCURRENT_DRIVE);
				if (!sDrive.IsEmpty() && (ToUpper(sDrive[0]) == cDrive))
					{
					bOK = TRUE;
					sDriver = GetRegistryString(HKEY_LOCAL_MACHINE, TOBSTRT(sSubsubkey), szDRIVER);
					sDescription = GetRegistryString(HKEY_LOCAL_MACHINE, TOBSTRT(sSubsubkey), szDEVICE_DESC);
					break;
					}
				}
			}
		}

	return (bOK);
}

BOOL GetRegistrySubkeys (HKEY hBaseKey, LPCTSTR pszKey, CHStringArray& asSubkeys)
{
	DEBUG_OUTF(TL_VERBOSE, (_T("GetRegistrySubkeys(%x, %s, %x)\n"),
							hBaseKey, pszKey, &asSubkeys));

	asSubkeys.RemoveAll();

    //  Open the section for the specified key (eg, HLM: SYSTEM\CurrentControlSet)
    HKEY hKey = NULL;
    LONG lStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, // handle of open parent key
                           		pszKey,       	 	// address of name of subkey to open
                           		0,               	// reserved (must be zero)
                           		KEY_ALL_ACCESS,  	// security access mask
                           		&hKey);       		// address of handle of open key
    if (lStatus != ERROR_SUCCESS)
        {
        DEBUG_OUTF(TL_BASIC, (_T("Error %ld opening registry key %s\n"), lStatus, pszKey));
		return (FALSE);
        }

	for (INT nSubKey = 0; ; nSubKey++)
		{
		//	Determine the next subkey's name
		TCHAR szSubKey[MAX_PATH] = { cNULL };
		lStatus = RegEnumKey(hKey, nSubKey, szSubKey, STR_LEN(szSubKey));
		if (lStatus != ERROR_SUCCESS)
			{
			break;
			}

		asSubkeys.Add(TOBSTRT(szSubKey));
		}

	return (TRUE);
}


//  Get a string value from the registry, returning it as a CHString.
//
CHString GetRegistryString (HKEY hBaseKey, LPCTSTR pszSubkey, LPCTSTR pszValueName)
{
	CHString    sValue;
    TCHAR       szBuffer[nTEXT_BUFFER_MAX];

//	LPTSTR pszBuffer = sValue.GetBuffer(nTEXT_BUFFER_MAX);
	GetRegistryString(hBaseKey, pszSubkey, pszValueName, szBuffer, nTEXT_BUFFER_MAX);
    sValue = szBuffer;
//	sValue.ReleaseBuffer();

	return (sValue);
}

//	Retrieve the drive information associated with the logical drive specification
//	(a DOS device name). This is only applicable to NT.
//
BOOL FindNtCdRomDriveInfo (TCHAR cDrive, CHString& sDriver, CHString& sDescription)
{
    DEBUG_OUTF(TL_VERBOSE, (_T("FindWin95RomDriveInfo(%c, %x, %x)\n"), cDrive, &sDriver, &sDescription));
	BOOL bOK = FALSE;

	cDrive = ToUpper(cDrive);
//    CHString sDevice;
//    sDevice.Format(szDOS_DEVICE_FMT, cDrive);
    TCHAR szDevice[100];

    wsprintf(szDevice, szDOS_DEVICE_FMT, cDrive);

    TCHAR szNtDeviceName[MAX_PATH];
    DWORD dwLen = QueryDosDevice(szDevice, szNtDeviceName, STR_LEN(szNtDeviceName));
    if (dwLen > 0)
        {
        sDriver = szNtDeviceName;
        bOK = TRUE;
        }

	return (bOK);
}

BOOL GetRegistryString (HKEY hBaseKey, LPCTSTR pszSubKey, LPCTSTR pszValue,
                        LPTSTR pszData, DWORD dwMaxDataLen)
{
    DWORD dwType;
    BOOL bOK = GetRegistryValue(hBaseKey, pszSubKey, pszValue, &dwType, pszData, dwMaxDataLen);
    if (bOK)
    {
        ASSERT_BREAK(IsRegStringType(dwType));
    }

    return (bOK);
}





////////// the great main //////////////////////////////
//void main(void)
//{
//    CCdTest cd;
//    // Need drive letter of cd drive:
//    CHAR cCDDrive = FindNextCdDrive('C');
//    CHString chstrCDDrive;
//    chstrCDDrive.Format("%c:\\", cCDDrive);
//    // Need to find a file of adequate size for use in profiling:
//    CHString chstrTransferFile = GetTransferFile(chstrCDDrive);
//    // Need to find a file correct for integrity check:
//    CHString chstrIntegrityFile = GetIntegrityFile(chstrCDDrive);
//    cd.ProfileDrive(cCDDrive, chstrTransferFile);
//    cd.TestDriveIntegrity(cCDDrive, chstrIntegrityFile);
//}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\multimonitor.h ===
//============================================================

//

// Multimonitor.h - Multiple Monitor API helper class definition

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// 11/23/97     a-sanjes     created
//
//============================================================

#ifndef __MULTIMONITOR_H__
#define __MULTIMONITOR_H__

// Forward class definitions
class CConfigMgrDevice;
class CDeviceCollection;

class CMultiMonitor
{
public:
    CMultiMonitor();
    ~CMultiMonitor();

    BOOL GetMonitorDevice(
        int iWhich, 
        CConfigMgrDevicePtr & pDeviceMonitor);

    BOOL GetAdapterDevice(
        int iWhich, 
        CConfigMgrDevicePtr & pDeviceAdapter);

	BOOL GetAdapterDeviceID(int iWhich, CHString &strDeviceID);

    DWORD GetNumAdapters();
    BOOL GetAdapterDisplayName(int iWhich, CHString &strName);

#if NTONLY == 4
    void GetAdapterServiceName(CHString &strName);
#endif

#ifdef NTONLY
    BOOL GetAdapterSettingsKey(int iWhich, CHString &strKey);
#endif

protected:
	void Init();
	
	CDeviceCollection m_listAdapters;

#if NTONLY == 4
    CHString m_strService,
             m_strSettingsKey;
#endif

    void TrimRawSettingsKey(CHString &strKey);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\msinfo_cdrom.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  MSInfo_CDRom.h
//
//  Purpose: Routines from msinfo for transfer rate and drive integrity
//
//***************************************************************************

#ifndef _MSINFO_CDROM_H
#define _MSINFO_CDROM_H





extern char FindNextCDDrive(char cCurrentDrive);
extern DWORD GetTotalSpace(LPCTSTR szRoot);
extern CHString FindFileBySize(LPCTSTR szDirectory, LPCTSTR szFileSpec, DWORD dwMinSize, DWORD dwMaxSize, BOOL bRecursive);
extern CHString MakePath(LPCTSTR szFirst, LPCTSTR szSecond);
extern CHString GetIntegrityFile(LPCTSTR szRoot);
extern CHString GetTransferFile(LPCTSTR szRoot);

//=============================================================================
// The following is for a class lifted from version 2.51 (and 2.5).
// First, we need to do some #define's to make this code compile.
//=============================================================================


//#define VOID			void
#define DEBUG_OUTF(X,Y)
#define DEBUG_MSGF(X,Y)	
//#define CHAR			char
//#define CONST			const
#define INLINE			inline
//#define Assert			ASSERT
#define cNULL			'\0'

//#ifndef BYTE
//	#define BYTE			unsigned char
//#endif

//#ifndef PBYTE
//	#define PBYTE			unsigned char *
//#endif

//#if !defined(_CDTEST_H)
//#define _CDTEST_H

///* These don't work with UNICODE, so we'll use the TCHAR typedefs.
#if !defined(PSZ)
typedef CHAR*           PSZ;
#endif
#if !defined(LPCTSTR)
typedef CONST TCHAR*     LPCTSTR;
#endif
//*/

INLINE BOOL ValidHandle (HANDLE handle)
{
    return ((handle != NULL) && (handle != INVALID_HANDLE_VALUE));
}

#ifdef _WIN32
#ifndef _WINMM_
#define	WINMMAPI	DECLSPEC_IMPORT
#else
#define	WINMMAPI
#endif
#define _loadds
#define _huge
#else
#define	WINMMAPI
#endif

//WINMMAPI DWORD WINAPI timeGetTime(void);

BOOL FileExists (LPCTSTR pszFile); //, POFSTRUCT pofs);
/*
INLINE BOOL FileDoesExist (LPCTSTR pszFile)
{
//    OFSTRUCT ofs;
    return (FileExists((LPCTSTR)pszFile));
}
*/

BOOL GetTempDirectory (LPTSTR pszTempDir, INT nMaxLen);

typedef double DOUBLE;

#define NUM_ELEMENTS(arr)       (sizeof(arr)/sizeof(arr[0]))
#define STR_LEN(str)            (NUM_ELEMENTS(str) - 1)

INLINE INT StringLength (LPCTSTR psz)
{
    return (lstrlen(psz));
}

#define PCVOID		const void *

INLINE INT CompareMemory (PCVOID pBlock1, PCVOID pBlock2, DWORD dwSize)
{
	return (memcmp(pBlock1, pBlock2, dwSize));
}

typedef enum _OS
{
    OS_WINDOWS95,
    OS_WIN32S,
    OS_WINNT
}
OS_TYPE;
CONST DWORD dwWIN32S_BIT =  0x80000000;
CONST DWORD dwWIN95_BIT =   0x40000000;

INLINE OS_TYPE GetOperatingSystem (VOID)
{
    DWORD dwVersion = GetVersion();
//    DEBUG_OUTF(TL_GARRULOUS, ("dwVersion = 0x%08lx\n", dwVersion));
    OS_TYPE os = ((dwVersion & dwWIN95_BIT) ?    OS_WINDOWS95 :
                  (dwVersion & dwWIN32S_BIT) ?   OS_WIN32S :
                                                 OS_WINNT);
    return (os);
}


#define szDOT _T(".")

CHString GetVolumeName (LPCTSTR pszRootPath);

INLINE BOOL IsWin95Running (VOID)
{
    BOOL bRunningWin95 = (GetOperatingSystem() == OS_WINDOWS95);

    return (bRunningWin95);
}

INLINE BOOL IsRegBinaryType (DWORD dwType)
{
    return (dwType == REG_BINARY);
}

INLINE BOOL IsRegStringType (DWORD dwType)
{
    return ((dwType == REG_SZ) || (dwType == REG_EXPAND_SZ)|| (dwType == REG_MULTI_SZ));
}

INLINE BOOL IsRegNumberType (DWORD dwType)
{
    return (dwType == REG_DWORD);
}

BOOL GetRegistryBinary (HKEY hBaseKey, LPCTSTR pszSubKey, LPCTSTR pszValue, 
                        PVOID pData, DWORD dwMaxDataLen);
BOOL GetRegistryValue (HKEY hBaseKey, LPCTSTR pszSubKey, LPCTSTR pszValue,
                       PDWORD pdwValueType, PVOID pData, DWORD dwMaxDataLen);

CONST CHAR  cDOUBLE_QUOTE = '"';
CONST CHAR  cSINGLE_QUOTE = '\'';
CONST CHAR  cCOMMA =        ',';

INLINE BOOL IsSpace (CHAR c)        { return (isspace(c) != 0); }

INLINE BOOL IsTokenChar (CHAR c)    { return (!IsSpace(c) && (c != cCOMMA)); }

INLINE INT StringCompare (LPCTSTR psz1, LPCTSTR psz2)
{
    return (lstrcmp(psz1, psz2));
}

//CONST DWORD dwBLOCK_SIZE = 4096;
CONST INT nCD_SECTOR_SIZE = 2048;
//CONST DWORD dwBLOCK_SIZE = 24 * 1024;
CONST DWORD dwBLOCK_SIZE = 12 * nCD_SECTOR_SIZE;
CONST DWORD dwBUFFER_SIZE = 2 * dwBLOCK_SIZE;
//CONST DWORD dwMIN_RATE = 150 * 1024;
CONST DWORD dwEXP_RATE = 300 * 1024;
//CONST DWORD dwMAX_TIME_PER_BLOCK = dwMIN_RATE / dwBLOCK_SIZE;
CONST DWORD dwEXP_TIME_PER_BLOCK = dwEXP_RATE / dwBLOCK_SIZE;
CONST WCHAR szDRIVE_FMT[] = L"%c:\\";

INLINE LPTSTR PszAdvance (LPTSTR pszSource)
{
#if defined(DBCS)
    return AnsiNext(pszSource);
#else
    return (pszSource + 1);
#endif
}

INLINE LPCTSTR PcszAdvance (LPCTSTR pszSource)
{
#if defined(DBCS)
    return AnsiNext(pszSource);
#else
    return (pszSource + 1);
#endif
}

INLINE VOID CopyCharAdvance (LPTSTR& pszBuffer, LPCTSTR& pszSource, INT& nMax)
{
#if defined(DBCS)
    //  If the current character is a lead byte, copy it and advance pointers
    if (IsDBCSLeadByte(*pszSource))
    {
       *pszBuffer++ = *pszSource++;
       nMax--;
    }  
#endif
    //  Copy the current character and advance the pointers
    *pszBuffer++ = *pszSource++;
    nMax--;
}

#if defined(WIN32)
CONST INT nTEXT_BUFFER_MAX =    2048;
#else
CONST INT nTEXT_BUFFER_MAX =    512;
#endif

CONST TCHAR szDOS_DEVICE_FMT[] =         _T("%c:");
CONST TCHAR szDRIVER[] = 			_T("Driver");

BOOL FindCdRomDriveInfo (TCHAR cDrive, CHString& sDriver, CHString& sDescription);
BOOL FindWin95CdRomDriveInfo (TCHAR cDrive, CHString& sDriver, CHString& sDescription);
BOOL GetRegistrySubkeys (HKEY hBaseKey, LPCTSTR pszKey, CHStringArray& asSubkeys);
//BOOL GetRegistrySubkeys (HKEY hBaseKey, LPCTSTR pszKey, std::vector<CHString>& asSubkeys);
CHString GetRegistryString (HKEY hBaseKey, LPCTSTR pszSubkey, LPCTSTR pszValueName);
BOOL FindNtCdRomDriveInfo (TCHAR cDrive, CHString& sDriver, CHString& sDescription);
BOOL GetRegistryString (HKEY hBaseKey, LPCTSTR pszSubKey, LPCTSTR pszValue,
                        LPTSTR pszData, DWORD dwMaxDataLen);

INLINE BOOL IsQuoteChar (CHAR c)
{
    return ((c == cDOUBLE_QUOTE) || (c == cSINGLE_QUOTE));
}

INLINE LPCTSTR SkipSpaces (LPCTSTR pszSource)
{
    while (IsSpace(*pszSource))
    {
        pszSource = PcszAdvance(pszSource);
    }

    return (pszSource);
}

LPCTSTR ParseString (
    LPCTSTR pszSource,
    LPTSTR pszBuffer,
    INT nLen
    );
LPCTSTR ParseToken (
    LPCTSTR pszSource,
    LPTSTR pszBuffer,
    INT nLen
    );
LPCTSTR ParseQuotedString (
    LPCTSTR pszSource,
    LPTSTR pszBuffer,
    INT nLen
    );

INLINE BOOL IsNtRunning (VOID)
{
    BOOL bRunningNT = (GetOperatingSystem() == OS_WINNT);

    return (bRunningNT);
}

INLINE CHAR IntToChar (INT nChar)
{
    return ((CHAR)nChar);
}

INLINE CHAR ToUpper (CHAR c)        { return (IntToChar(toupper(c))); }

class CCdTest // : public CObject
{
//	DECLARE_DYNAMIC(CCdTest);

	//	Construction
public:
	CCdTest();
	//CCdTest (CHAR cDrive, LPCTSTR pszFile);
	~CCdTest();

	//	Implementation
public:
	CHAR m_cDrive;						// letter for CD drive
	CHString m_sCdTestFile;				// file to test
	CHString m_sTempFileSpec;			// file for temporary storage
	DOUBLE m_rTransferRate;				// profiled transfer rate
	DOUBLE m_rCpuUtil;					// est. CPU usage during the test
	DWORD m_dwExpTimePerBlock;			// time per block based on expected rate
	PBYTE m_pBufferSrc;					// main buffer for file transfers
	PBYTE m_pBufferDest;				// another buffer for file transfers
	PBYTE m_pBufferSrcStart;			// start of buffer for file transfers
	PBYTE m_pBufferDestStart;			// start of another buffer for file transfers
	DWORD m_dwBufferSize;				// size of the buffers
	//CFile m_fileSrc;					// file for the profiling & intregrity tests
	//CFile m_fileDest;					// additional file for the integrity test
    HANDLE m_hFileSrc;					// file handle for the profiling & intregrity tests
	HANDLE m_hFileDest;					// additional file handle for the integrity test
	DWORD m_dwTotalTime;				// total time spent blocked
	DWORD m_dwTotalBusy;				// total time during which the CD drive was busy
	BOOL m_bDoPacing;					// should the reads be paced at the expeected rate
	DWORD m_dwTotalBytes;				// total bytes read (so far)
	DWORD m_dwTotalCPU;					// total CPU time (sum of samples)
	INT m_nNumSamples;					// number of samples (blocks read)
	DWORD m_dwFileSize;					// size of the file (bytes)
	BOOL m_bIntegityOK;					// true unless integrity checks fail

	//	Attributes
	DOUBLE GetTransferRate (VOID)		{ return (m_rTransferRate); }
	DOUBLE GetCpuUsage (VOID)			{ return (m_rCpuUtil); }

	//	Operations
public:
	VOID Reset (VOID);
	BOOL ProfileBlockRead (DWORD dwBlockSize, BOOL bIgnoreTrial = FALSE);
	BOOL ProfileDrive (LPCTSTR pszFile);
	BOOL TestDriveIntegrity (LPCTSTR pszCdTestFile);
private:
	BOOL InitProfiling (LPCTSTR pszFile);
	BOOL InitIntegrityCheck (LPCTSTR pszFile);
	BOOL CompareBlocks (VOID);
};


//	Utility functions
//
DWORD GetCpuUtil (VOID);
CHString OLDFindFileBySize (LPCTSTR pszDirectory, LPCTSTR pszFileSpec, DWORD dwMinSize, DWORD dwMaxSize, BOOL bRecursive);
BOOL IsCdDrive (CHAR cDrive);
BOOL IsLocalDrive (CHAR cDrive);
CHAR FindNextCdDrive (CHAR cCurrent);
CHAR FindNextLocalDrive (CHAR cCurrentDrive);
CHAR FindDriveByVolume (CHString sVolume);
HANDLE OpenBinaryFile (LPCTSTR pszFile, BOOL bNew, BOOL bBuffered, BOOL bWritable);
HANDLE OpenFileNonbuffered (LPCTSTR pszFile);
PVOID AlignPointer (PVOID pData, INT nAlignment);


INLINE CHString MakeRootPath (CHAR cDrive)
{
    CHString sRootPath;
    sRootPath.Format(szDRIVE_FMT, cDrive);
    return (sRootPath);
}


#endif	// !defined(MSINFO_CDROM_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\mychkdsk.h ===
#ifndef _MYCHKDSKLOGDISK_H
#define _MYCHKDSKLOGDISK_H

// ChkDisk Method Return type
#define CHKDSKERR_NOERROR						0
#define CHKDSKERR_REMOTE_DRIVE					1
#define CHKDSKERR_DRIVE_REMOVABLE				2
#define CHKDSKERR_DRIVE_UNKNOWN					4
#define CHKDSKERR_DRIVE_NO_ROOT_DIR				3

#define	CHKDSK_VOLUME_LOCKED					1
#define CHKDSK_UNKNOWN_FS						2
#define CHKDSK_FAILED							3
#define CHKDSK_UNSUPPORTED_FS					4

// Method Names
#define METHOD_NAME_CHKDSK							L"chkdsk"
#define METHOD_NAME_SCHEDULEAUTOCHK					L"ScheduleAutoChk"
#define METHOD_NAME_EXCLUDEFROMAUTOCHK				L"ExcludeFromAutochk"

// argument names to the methods
#define METHOD_ARG_NAME_RETURNVALUE					L"ReturnValue"
#define METHOD_ARG_NAME_LOSTCLUSTERTREATMENT		L"LostClusterTreatMent"
#define METHOD_ARG_NAME_FIXERRORS					L"FixErrors"
#define METHOD_ARG_NAME_PHYSICALINTEGRITYCHECK		L"PhysicalIntegrityCheck"
#define METHOD_ARG_NAME_VIGOROUSINDEXCHECK			L"VigorousIndexCheck"
#define METHOD_ARG_NAME_SKIPFOLDERCYCLE				L"SkipFolderCycle"
#define METHOD_ARG_NAME_FORCEDISMOUNT				L"ForceDismount"
#define METHOD_ARG_NAME_RECOVERBADSECTORS			L"RecoverBadSectors"
#define METHOD_ARG_NAME_CHKDSKATBOOTUP				L"OkToRunAtBootup"
#define METHOD_ARG_NAME_LOGICALDISKARRAY			L"LogicalDisk"


#define CHKNTFS								L"ChkNtfs"

#ifdef NTONLY

// Definition for ChkDsk Call Back routines
typedef BOOLEAN (* QUERYFILESYSTEMNAME )(PWSTR, PWSTR, PUCHAR, PUCHAR, PNTSTATUS);

// This method is given as a callback routine to schedule on boot if the volume is locked.
BOOLEAN ScheduleAutoChkIfLocked( FMIFS_PACKET_TYPE PacketType, ULONG PacketLenght, PVOID PacketData );
// This is given as a callback routine to chkdsk to not to schedule for autochkdsk on boot up 
//if the volume is Lock
BOOLEAN DontScheduleAutoChkIfLocked( FMIFS_PACKET_TYPE PacketType, ULONG PacketLenght, PVOID PacketData );

BOOLEAN ProcessInformation ( FMIFS_PACKET_TYPE PacketType, ULONG	PacketLength, PVOID	PacketData );
// this variable is required to get the return value from the call back routine.

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\netadapter.h ===
//=================================================================

//

// NetAdapt.h -- Network adapter card property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/28/96    a-jmoon        Created
//
//=================================================================
#define	NTOS_PERF_DATA_SYSTEM_INDEX_STR		_T("2")
#define	NTOS_PERF_DATA_SYSTEM_INDEX			2
#define	NTOS_PERF_DATA_SYSTEMUPTIME_INDEX	674

// Property set identification
//============================

#define	PROPSET_NAME_NETADAPTER	L"Win32_NetworkAdapter"

// Utility defines
//================

typedef struct _NDIS_MEDIA_DESCRIPTION {
    
    DWORD		dwIDR_;
    NDIS_OID    NDISOid ;
    
} NDIS_MEDIA_DESCRIPTION ;


// Comparison class required for imap
// costructor involving non-standard key
// type (i.e., a LPWSTR) in the map.
class CWSTRComp
{
public:
    CWSTRComp() {}
    virtual ~CWSTRComp() {}

    // return true if p < q lexicographically...
    bool operator()(
        const LPWSTR& p,
        const LPWSTR& q) const
    {
        return (wcscmp(p, q) < 0);
    }
};

class NCPROP
{
public:
    NCPROP() {}
    NCPROP(
        LPCWSTR wstrNCID,
        DWORD dwNCStatus,
        DWORD MediaType)
    {
        m_bstrtNCID = wstrNCID;
        m_dwNCStatus = dwNCStatus;
        m_MediaType = MediaType;
    }

    NCPROP(const NCPROP& ncpRight)
    {
        m_bstrtNCID = ncpRight.m_bstrtNCID;
        m_dwNCStatus = ncpRight.m_dwNCStatus;    
        m_MediaType = ncpRight.m_MediaType;
    }

    virtual ~NCPROP() {}

    DWORD m_dwNCStatus;
    _bstr_t m_bstrtNCID;
    DWORD m_MediaType;
};


typedef std::map<_bstr_t,NCPROP,CWSTRComp> BSTRT2NCPROPMAP;


// Property set identification
//============================

class CWin32NetworkAdapter : public Provider
{
	private:

			// Utility functions
			//==================

			HRESULT GetNetworkAdapterInfoNT( MethodContext *pMethodContext, CInstance *a_pInst ) ;

			void GetStatusInfo( CHString a_sTemp, CInstance *a_pInst ) ;



			HRESULT DoItNT4Way( CInstance *a_pInst, DWORD a_dwIndex, CRegistry &a_RegInfo ) ;
			HRESULT GetCommonNTStuff( CInstance *a_pInst, CHString a_chsService ) ;

			// PNP DeviceID helpers
			void GetWinNT4PNPDeviceID( CInstance *a_pInst, LPCTSTR a_pszServiceName ) ;
			void GetWinNT5PNPDeviceID( CInstance *a_pInst, LPCTSTR a_pszDriver ) ;

			BOOL fGetMacAddressAndType(CHString &a_rDeviceName,
										BYTE a_MACAddress[ 6 ],
										CHString &a_rTypeName, 
                                        short& a_sNetAdapterTypeID,
                                        CHString &a_FriendlyName,
                                        CHString & a_IPHLP_Description) ;


			BOOL fCreateSymbolicLink( CHString &a_rDeviceName ) ;
			BOOL fDeleteSymbolicLink(  CHString &a_rDeviceName ) ; 

			void vSetCaption( CInstance *a_pInst, CHString &a_rchsDesc, DWORD a_dwIndex, int a_iFormatSize ) ;
    public:

        // Constructor/destructor
			//=======================

			CWin32NetworkAdapter(LPCWSTR a_strName, LPCWSTR a_pszNamespace ) ;
		   ~CWin32NetworkAdapter() ;

			// Functions provide properties with current values
			//=================================================

			virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags = 0L ) ;
			virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;
		

			virtual HRESULT EnumNetAdaptersInNT5(
                MethodContext *a_pMethodContext,
                BSTRT2NCPROPMAP& mapNCProps);

			HRESULT GetNetCardInfoForNT5(
                CW2kAdapterInstance *a_pAdapterInst, 
                CInstance *a_pInst,
                BSTRT2NCPROPMAP& mapNCProps);

			HRESULT GetObjectNT5( 
                CInstance *a_pInst,
                BSTRT2NCPROPMAP& mapNCProps);

            void GetNetConnectionProps(
                BSTRT2NCPROPMAP& mapNCProps);

            BOOL SetNetConnectionProps(
                CInstance* pInst,
                CHString& chstrNetConInstID, 
                BSTRT2NCPROPMAP& mapNCProps);

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\netadapter.cpp ===
//=================================================================

//

// NetAdapt.CPP -- Network Adapter Card property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:   08/28/96    a-jmoon        Created
//
//				03/03/99				Added graceful exit on SEH and memory failures,
//											syntactic clean up
//
//=================================================================

#include "precomp.h"

#ifndef MAX_INTERFACE_NAME_LEN
#define MAX_INTERFACE_NAME_LEN  256
#endif

#include <winsock2.h>
#include <assertbreak.h>
#include "resource.h"
#include <cregcls.h>
#include <devioctl.h>
#include <ntddndis.h>
#include "chwres.h"
#include "W2kEnum.h"
#include "NetAdapter.h"
#include "perfdata.h"
#include "poormansresource.h"
#include "resourcedesc.h"
#include "ntlastboottime.h"
#include <helper.h>
#include "netcon.h"


#include <iphlpapi.h>
#include <iptypes.h>


//STDAPI_(VOID) NcFreeNetconProperties (NETCON_PROPERTIES* pProps);
typedef VOID(_stdcall * fnNcFreeNetconProperties)(NETCON_PROPERTIES* pProps);
fnNcFreeNetconProperties NcFreeNetconProperties_;


// BA126AD1-2166-11D1-B1D0-00805FC1270E     CLSID_ConnectionManager
DEFINE_GUID(CLSID_ConnectionManager,          
0xBA126AD1,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);



#define NTINVALID 1
#define NT4 2
#define NT5 3
// Property set declaration
//=========================
CWin32NetworkAdapter	win32NetworkAdapter( PROPSET_NAME_NETADAPTER, IDS_CimWin32Namespace ) ;

static NDIS_MEDIA_DESCRIPTION g_NDISMedia[] =  {

    { IDR_NdisMedium802_3,		OID_802_3_CURRENT_ADDRESS	},
    { IDR_NdisMedium802_5,		OID_802_5_CURRENT_ADDRESS	},
    { IDR_NdisMediumFddi,		OID_FDDI_LONG_CURRENT_ADDR	},
    { IDR_NdisMediumWan,		OID_WAN_CURRENT_ADDRESS		},
    { IDR_NdisMediumLocalTalk,	OID_802_3_CURRENT_ADDRESS	},
	{ IDR_NdisMediumDix,		OID_802_3_CURRENT_ADDRESS	},
	{ IDR_NdisMediumArcnetRaw,	OID_ARCNET_CURRENT_ADDRESS	},
	{ IDR_NdisMediumArcnet878_2,OID_ARCNET_CURRENT_ADDRESS	},
	{ IDR_NdisMediumAtm,		OID_802_3_CURRENT_ADDRESS	},
	{ IDR_NdisMediumWirelessWan,OID_802_3_CURRENT_ADDRESS	}, // should be OID_WW_GEN_CURRENT_ADDRESS
	{ IDR_NdisMediumIrda,		OID_802_3_CURRENT_ADDRESS	},
	{ IDR_NdisMediumBpc,		OID_802_3_CURRENT_ADDRESS	},
	{ IDR_NdisMediumCoWan,		OID_802_3_CURRENT_ADDRESS	},
	{ IDR_NdisMedium1394,		OID_802_3_CURRENT_ADDRESS	}
} ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetworkAdapter::CWin32NetworkAdapter
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *                LPCTSTR pszNamespace - Namespace for provider.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32NetworkAdapter::CWin32NetworkAdapter(LPCWSTR a_strName, LPCWSTR a_pszNamespace /*=NULL*/ )
:	Provider( a_strName, a_pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetworkAdapter::~CWin32NetworkAdapter
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32NetworkAdapter::~CWin32NetworkAdapter()
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32NetworkAdapter::GetObject
//
//	Inputs:		CInstance*		a_pInst - Instance into which we
//											retrieve data.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32NetworkAdapter::GetObject( CInstance *a_pInst, long a_lFlags /*= 0L*/ )
{

    HRESULT t_hResult ;

    BSTRT2NCPROPMAP mapNCProps;
    GetNetConnectionProps(mapNCProps);
    t_hResult = GetObjectNT5( a_pInst,mapNCProps ) ;

    return t_hResult ;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32NetworkAdapter::EnumerateInstances
//
//	Inputs:		MethodContext   *pMethodContext - Context to enum
//								instance data in.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32NetworkAdapter::EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/ )
{
    HRESULT t_hResult;

    BSTRT2NCPROPMAP mapNCProps;
    GetNetConnectionProps(mapNCProps);
    t_hResult = EnumNetAdaptersInNT5( a_pMethodContext,mapNCProps) ;

    return t_hResult;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetworkAdapter::GetStatusInfo
 *
 *  DESCRIPTION : Loads property values according to passed network card index
 *
 *  INPUTS      : DWORD Index -- index of desired network card
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if indicated card was found, FALSE otherwise
 *
 *  COMMENTS    : The return code is based solely on the ability to discover
 *                the indicated card.  Any properties not found are simply not
 *                available
 *
 *****************************************************************************/

void CWin32NetworkAdapter::GetStatusInfo( CHString a_sTemp, CInstance *a_pInst )
{
	CHString	t_chsKey,
				t_chsTmp;
	CRegistry	t_Reg;

	t_chsKey = _T("System\\CurrentControlSet\\Services\\") + a_sTemp + _T("\\Enum" ) ;

	if( ERROR_SUCCESS == t_Reg.Open( HKEY_LOCAL_MACHINE, t_chsKey, KEY_READ ) )
	{
		if( ERROR_SUCCESS == t_Reg.GetCurrentKeyValue( _T("0"), t_chsTmp ) )
		{
			t_chsKey = _T("System\\CurrentControlSet\\Enum\\") + t_chsTmp ;

			if( ERROR_SUCCESS == t_Reg.Open( HKEY_LOCAL_MACHINE, t_chsKey, KEY_READ ) )
			{
				DWORD t_dwTmp ;

				if( ERROR_SUCCESS == t_Reg.GetCurrentKeyValue( _T("StatusFlags"), t_dwTmp ) )
				{
    				ConfigStatusToCimStatus ( t_dwTmp , t_chsTmp ) ;

					a_pInst->SetCHString(IDS_Status, t_chsTmp ) ;

                    if ( t_chsTmp.CompareNoCase( IDS_STATUS_OK ) == 0)
					{
    					a_pInst->SetWBEMINT16( IDS_StatusInfo, 3 ) ;
					    a_pInst->SetWBEMINT16( IDS_Availability, 3 ) ;

                    }
					else if ( t_chsTmp.CompareNoCase( IDS_STATUS_Degraded ) == 0 )
					{
    					a_pInst->SetWBEMINT16( IDS_StatusInfo, 3 ) ;
					    a_pInst->SetWBEMINT16( IDS_Availability, 10 ) ;
                    }
					else if ( t_chsTmp.CompareNoCase( IDS_STATUS_Error ) == 0 )
					{
    					a_pInst->SetWBEMINT16( IDS_StatusInfo, 4 ) ;
					    a_pInst->SetWBEMINT16( IDS_Availability, 4 ) ;
                    }
					else
					{
					    a_pInst->SetWBEMINT16( IDS_Availability, 2 ) ;
    					a_pInst->SetWBEMINT16( IDS_StatusInfo, 2 ) ;
                    }
				}
			}
		}
	}
}


//

HRESULT CWin32NetworkAdapter::DoItNT4Way( CInstance *a_pInst, DWORD dwIndex, CRegistry &a_RegInfo )
{
    CHString	t_sTemp,
				t_chsKey,
				t_chsService ;
    CRegistry	t_Reg ;
    BOOL		t_fRc = FALSE ;
	FILETIME	t_ft ;

	a_pInst->SetDWORD( IDS_Index,dwIndex ) ;

	if( a_RegInfo.GetCurrentKeyValue( _T("ProductName"), t_sTemp ) == ERROR_SUCCESS )
	{
		//========================================================
		//  if we are going for a specific device here, let us
		//  check and see if it is the correct one.
		//========================================================

		// Pull up our Device ID.
		GetWinNT4PNPDeviceID( a_pInst, t_sTemp ) ;

		// Note: Under nt4 ProductName is a ServiceName and
		// ServiceName is a ProductName
		a_pInst->SetCHString( IDS_ServiceName, t_sTemp ) ;

		GetStatusInfo( t_sTemp,a_pInst ) ;
	}

	SetCreationClassName( a_pInst ) ;
	a_pInst->SetWCHARSplat( IDS_SystemCreationClassName, L"Win32_ComputerSystem" ) ;

	a_pInst->Setbool( IDS_PowerManagementSupported, FALSE ) ;

//	a_pInst->Setbool( IDS_PowerManagementEnabled, FALSE ) ;
 	a_pInst->SetDWORD( IDS_MaxNumberControlled,0 ) ;

	// Get the last boot time
	CNTLastBootTime	t_ntLastBootTime ;

	if ( t_ntLastBootTime.GetLastBootTime( t_ft ) )
	{
		a_pInst->SetDateTime( IDS_TimeOfLastReset, WBEMTime(t_ft) ) ;
	}

	if( a_RegInfo.GetCurrentKeyValue(_T("Title"), t_sTemp) == ERROR_SUCCESS )
	{
    	// NOTE: For NT4 we need not call vSetCaption() to build
		// an instance description _T("Title") has the instance prepended.
		a_pInst->SetCHString( IDS_Caption, t_sTemp ) ;

		a_pInst->SetCHString( IDS_Name, t_sTemp ) ;
		t_sTemp.MakeUpper() ;
	}

    if( a_RegInfo.GetCurrentKeyValue( _T("ServiceName"), t_chsService ) == ERROR_SUCCESS )
	{
	    a_pInst->SetCHString( IDS_DeviceID, t_chsService ) ;
        t_fRc = TRUE ;
    }
    if( a_RegInfo.GetCurrentKeyValue( _T("Manufacturer"), t_sTemp ) == ERROR_SUCCESS)
	{
        a_pInst->SetCHString( IDS_Manufacturer, t_sTemp ) ;
	}

	WBEMTime	t_wbemtime ;
    DWORD		t_dwTemp ;

    if( a_RegInfo.GetCurrentKeyValue( _T("InstallDate"), t_dwTemp ) == ERROR_SUCCESS )
	{
        t_wbemtime = t_dwTemp ;
		a_pInst->SetDateTime( IDS_InstallationDate, t_wbemtime ) ;
	}


	CHString t_csDescription ;
	if( a_RegInfo.GetCurrentKeyValue( _T("Description"), t_csDescription ) == ERROR_SUCCESS )
	{
	    a_pInst->SetCHString( IDS_Description, t_csDescription ) ;
	}

	// Retrieve the adapter MAC address
	BYTE t_MACAddress[ 6 ] ;
	CHString t_csAdapterType ;
    short t_sAdapterTypeID;
	CHString t_FriendlyName ;
	CHString t_IPHLP_Description;
	
	if( fGetMacAddressAndType( t_chsService, t_MACAddress, t_csAdapterType, t_sAdapterTypeID, t_FriendlyName, t_IPHLP_Description ) )
	{
		CHString	t_chsMACAddress;
					t_chsMACAddress.Format( _T("%02X:%02X:%02X:%02X:%02X:%02X"),
											t_MACAddress[ 0 ], t_MACAddress[ 1 ],
											t_MACAddress[ 2 ], t_MACAddress[ 3 ],
											t_MACAddress[ 4 ], t_MACAddress[ 5 ] ) ;

		a_pInst->SetCHString( IDS_MACAddress, t_chsMACAddress ) ;
	}

	// AdapterType
	if( !t_csAdapterType.IsEmpty() )
	{
		a_pInst->SetCHString( IDS_AdapterType, t_csAdapterType ) ;
        a_pInst->SetWBEMINT16( IDS_AdapterTypeID, t_sAdapterTypeID );
	}




	return GetCommonNTStuff( a_pInst, t_chsService ) ;
}


////////////////////////////////////////////////////////////////////////

HRESULT CWin32NetworkAdapter::GetCommonNTStuff( CInstance *a_pInst, CHString a_chsService )
{
	TCHAR	t_szTemp[ _MAX_PATH ] ;
			t_szTemp[ 0 ] = NULL ;

	// Note: Under nt4 ProductName is a ServiceName and
	// ServiceName is a ProductName
	a_pInst->SetCHString( IDS_ProductName, a_chsService ) ;

	a_pInst->SetCHString( IDS_SystemName, GetLocalComputerName() ) ;

	SetCreationClassName( a_pInst ) ;

	a_pInst->SetWCHARSplat( IDS_SystemCreationClassName, L"Win32_ComputerSystem" ) ;

    return WBEM_S_NO_ERROR ;
}


/*******************************************************************
    NAME:       fGetMacAddressAndType

    SYNOPSIS:	retrieves the MAC address from the adapter driver.


    ENTRY:      BYTE* MACAddress[6]		:
				CHString& rDeviceName		:


    HISTORY:
                  08-Aug-1998     Created
********************************************************************/

BOOL CWin32NetworkAdapter::fGetMacAddressAndType(
CHString &a_rDeviceName,
BYTE a_MACAddress[ 6 ],
CHString &a_rAdapterType,
short& a_sAdapterTypeID,
CHString &a_FriendlyName,
CHString & a_IPHLP_Description)
{
	BOOL t_fRet = FALSE;

	BOOL	t_fCreatedSymLink = fCreateSymbolicLink( a_rDeviceName ) ;
    OnDeleteObjIf<CHString &,CWin32NetworkAdapter,
    	         BOOL(CWin32NetworkAdapter:: *)(CHString &),
    	         &CWin32NetworkAdapter::fDeleteSymbolicLink> DelSymLink(this,a_rDeviceName);
	DelSymLink.dismiss(FALSE == t_fCreatedSymLink);
		
	SmartCloseHandle	t_hMAC;

	//
	// Construct a device name to pass to CreateFile
	//
	CHString t_chsAdapterPathName(_T("\\\\.\\") ) ;
			 t_chsAdapterPathName += a_rDeviceName;

	t_hMAC = CreateFile(
				t_chsAdapterPathName,
				GENERIC_READ,
				FILE_SHARE_READ | FILE_SHARE_WRITE,
				NULL,
				OPEN_EXISTING,
				0,
				INVALID_HANDLE_VALUE
				 ) ;

    if( INVALID_HANDLE_VALUE != t_hMAC )
	{	
		//
		// We successfully opened the driver, format the
		// IOCTL to pass the driver.
		//
		UCHAR       t_OidData[ 4096 ] ;
		NDIS_OID    t_OidCode ;
		DWORD       t_ReturnedCount ;

		// get the supported media types
		t_OidCode = OID_GEN_MEDIA_IN_USE ;

		if( DeviceIoControl(
							t_hMAC,
							IOCTL_NDIS_QUERY_GLOBAL_STATS,
							&t_OidCode,
							sizeof( t_OidCode ),
							t_OidData,
							sizeof( t_OidData ),
							&t_ReturnedCount,
							NULL
							) && (4 <= t_ReturnedCount ) )
		{


			// Seek out the media type for MAC address reporting.
			// Since this adapter may support more than one media type we'll use
			// the enumeration preference order. In most all cases only one type
			// will be current.

			_NDIS_MEDIUM *t_pTypes = (_NDIS_MEDIUM*)&t_OidData ;
			_NDIS_MEDIUM t_eMedium = t_pTypes[ 0 ] ;

			for( DWORD t_dwtypes = 1; t_dwtypes < t_ReturnedCount / 4; t_dwtypes++ )
			{
				if( t_eMedium > t_pTypes[ t_dwtypes ] )
				{
					t_eMedium = t_pTypes[ t_dwtypes ] ;
				}
			}

			// map to current address OID and medium type string
			if( t_eMedium < sizeof( g_NDISMedia ) / sizeof( g_NDISMedia[0] ) )
			{
				LoadStringW( a_rAdapterType, g_NDISMedia[ t_eMedium ].dwIDR_ ) ;
                a_sAdapterTypeID = t_eMedium;

				t_OidCode = g_NDISMedia[ t_eMedium ].NDISOid ;
			}
			else
			{
				t_OidCode = OID_802_3_CURRENT_ADDRESS ;
			}
		}
		else
		{
			t_OidCode = OID_802_3_CURRENT_ADDRESS ;
		}

		if( DeviceIoControl(
								t_hMAC,
								IOCTL_NDIS_QUERY_GLOBAL_STATS,
								&t_OidCode,
								sizeof( t_OidCode ),
								t_OidData,
								sizeof( t_OidData ),
								&t_ReturnedCount,
								NULL  ) )
		{
			if( 6 == t_ReturnedCount )
			{
				memcpy( a_MACAddress, &t_OidData, 6 ) ;
			    t_fRet = TRUE;
			}
		}
   	}
    else // use the iphlpapi
    {
        do 
        {
		    HMODULE hIpHlpApi = LoadLibraryEx(L"iphlpapi.dll",0,0);
		    if (NULL == hIpHlpApi) break;
		    OnDelete<HMODULE,BOOL(__stdcall *)(HMODULE),FreeLibrary> fl(hIpHlpApi);

		    typedef DWORD ( __stdcall * fnGetAdaptersAddresses )(ULONG Family,DWORD Flags,PVOID Reserved,IP_ADAPTER_ADDRESSES * pAdapterAddresses,PULONG pOutBufLen);
		    fnGetAdaptersAddresses GetAdaptersAddresses_ = (fnGetAdaptersAddresses)GetProcAddress(hIpHlpApi,"GetAdaptersAddresses");
		    if (NULL == GetAdaptersAddresses_) break;

            DWORD dwErr;
		    ULONG SizeAdapAddr = 0;
		    dwErr = GetAdaptersAddresses_(AF_INET,
		    	                          GAA_FLAG_SKIP_DNS_SERVER|GAA_FLAG_SKIP_ANYCAST|GAA_FLAG_SKIP_MULTICAST,
		    	                          NULL,
		    	                          NULL,
		    	                          &SizeAdapAddr);
		    if (ERROR_BUFFER_OVERFLOW != dwErr) break;
		    IP_ADAPTER_ADDRESSES * pAdapAddr = (IP_ADAPTER_ADDRESSES *)LocalAlloc(0,SizeAdapAddr);
		    if (NULL == pAdapAddr) break;
		    OnDelete<HLOCAL,HLOCAL(_stdcall *)(HLOCAL),LocalFree> fmAdapAddr(pAdapAddr);
		    dwErr = GetAdaptersAddresses_(AF_INET,
		    	                          GAA_FLAG_SKIP_DNS_SERVER|GAA_FLAG_SKIP_ANYCAST|GAA_FLAG_SKIP_MULTICAST,
		    	                          NULL,
		    	                          pAdapAddr,
		    	                          &SizeAdapAddr);   
		    if (NO_ERROR != dwErr) break;

		    DWORD InterfaceIndex = (DWORD)-1;

		    IP_ADAPTER_ADDRESSES * pCurrentAdapAddr = pAdapAddr;
		    do
		    {
		        if (0 == _wcsicmp((LPCWSTR)a_rDeviceName,(LPCWSTR)CHString(pCurrentAdapAddr->AdapterName)))
		        {
		            InterfaceIndex = pCurrentAdapAddr->IfIndex;
		            break;
		        }
		        // prepare to move forwad
		        pCurrentAdapAddr = pCurrentAdapAddr->Next;
		    } while(pCurrentAdapAddr);
		    if ((DWORD)-1 == InterfaceIndex) break; // not found

		    memcpy( a_MACAddress,pCurrentAdapAddr->PhysicalAddress, max(6,pCurrentAdapAddr->PhysicalAddressLength));
        	a_FriendlyName = pCurrentAdapAddr->FriendlyName;
        	a_IPHLP_Description = pCurrentAdapAddr->Description;
        	
        	t_fRet = TRUE;
       	}while(0);
    }

 	return t_fRet ;
}


/*******************************************************************
    NAME:       fCreateSymbolicLink

    SYNOPSIS:	Tests for and creates if necessary a symbolic device link.


    ENTRY:      CHString& rDeviceName		: device name

	NOTES:		Unsupported for Win95

	HISTORY:
                  08-Aug-1998     Created
********************************************************************/
BOOL CWin32NetworkAdapter::fCreateSymbolicLink( CHString &a_rDeviceName )
{
	TCHAR	t_LinkName[ 512 ] ;

	// Check to see if the DOS name for the device already exists.
	// Its not created automatically in version 3.1 but may be later.
	//
	if( !QueryDosDevice( TOBSTRT( a_rDeviceName ), (LPTSTR) t_LinkName, sizeof( t_LinkName ) / sizeof( TCHAR ) ) )
	{
		// On any error other than "file not found" return
		if( ERROR_FILE_NOT_FOUND != GetLastError() )
		{
			return FALSE ;
		}

		//
		// It doesn't exist so create it.
		//
		CHString t_chsTargetPath = _T("\\Device\\") ;
				 t_chsTargetPath += a_rDeviceName ;

		if( !DefineDosDevice( DDD_RAW_TARGET_PATH, TOBSTRT( a_rDeviceName ), TOBSTRT( t_chsTargetPath ) ) )
		{
			return FALSE ;
		}

		return TRUE ;
	}
	return FALSE ;
}

/*******************************************************************
    NAME:       fDeleteSymbolicLink

    SYNOPSIS:	deletes a symbolic device name.


    ENTRY:      CHString& rSymDeviceName	: symbolic device name

	NOTES:		Unsupported for Win95

    HISTORY:
                  08-Aug-1998     Created
********************************************************************/
BOOL CWin32NetworkAdapter::fDeleteSymbolicLink(  CHString &a_rDeviceName )
{
	//
	// The driver wasn't visible in the Win32 name space so we created
	// a link.  Now we have to delete it.
	//
	CHString t_chsTargetPath = L"\\Device\\" ;
			 t_chsTargetPath += a_rDeviceName ;

	if( !DefineDosDevice(
							DDD_RAW_TARGET_PATH |
							DDD_REMOVE_DEFINITION |
							DDD_EXACT_MATCH_ON_REMOVE,
							TOBSTRT( a_rDeviceName ),
							TOBSTRT( t_chsTargetPath ) ) )
	{
		return FALSE ;
	}

	return TRUE ;
}

//////////////////////////////////////////////////////////////////////////

HRESULT CWin32NetworkAdapter::GetNetworkAdapterInfoNT( MethodContext	*a_pMethodContext,
													   CInstance		*a_pSpecificInstance )
{
    HRESULT		t_hResult;
	DWORD		t_dwIndex = 0 ;
    CHString	t_chsService ;
	CRegistry	t_Reg ;
	CHString	t_sTmp ;

   	// smart ptr
	CInstancePtr t_pInst ;


	if (a_pMethodContext)
    {
        t_hResult = WBEM_S_NO_ERROR;
    }
    else
    {
        t_hResult = WBEM_E_NOT_FOUND;
    }

    if( ERROR_SUCCESS == t_Reg.OpenAndEnumerateSubKeys( HKEY_LOCAL_MACHINE,
														_T("Software\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards"),
														KEY_READ ) )
	{
		for( int t_i = 0; t_i < t_Reg.GetCurrentSubKeyCount(); t_i++ )
		{
		    if( ERROR_SUCCESS == t_Reg.GetCurrentSubKeyName( t_sTmp ) )
			{
				t_dwIndex = _ttoi( t_sTmp ) ;

				CRegistry t_SubKeyReg ;

				if( t_SubKeyReg.Open( t_Reg.GethKey(), t_sTmp, KEY_READ ) == ERROR_SUCCESS )
				{
				    CHString	t_chsDeviceId,
								t_chsTmp ;

                    // Getobject
					if( !a_pMethodContext )
					{
					    t_pInst = a_pSpecificInstance ;

						t_pInst->GetCHString( IDS_DeviceID, t_chsDeviceId ) ;

						if( t_SubKeyReg.GetCurrentKeyValue( _T("ServiceName" ), t_chsTmp ) == ERROR_SUCCESS )
						{
							if( t_chsTmp.CompareNoCase( t_chsDeviceId ) == 0 )
							{
								t_hResult = DoItNT4Way( t_pInst, t_dwIndex, t_SubKeyReg ) ;

								break ;
							}
						}
					}
					else
					{
                        // Enumerate
				    	t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;

						t_hResult = DoItNT4Way( t_pInst, t_dwIndex, t_SubKeyReg ) ;

						if( SUCCEEDED( t_hResult ) )
				        {
				        	t_hResult = t_pInst->Commit() ;
					    }

						if( !SUCCEEDED( t_hResult ) )
						{
							break;
						}
					}
				}
			}

			t_Reg.NextSubKey() ;
		}
	}

	return t_hResult;
}



HRESULT CWin32NetworkAdapter::EnumNetAdaptersInNT5(
    MethodContext *a_pMethodContext,
    BSTRT2NCPROPMAP& mapNCProps)
{
	HRESULT				t_hResult = WBEM_S_NO_ERROR ;
	CW2kAdapterEnum		t_oAdapterEnum ;
	CW2kAdapterInstance *t_pAdapterInst ;

	// smart ptr
	CInstancePtr t_pInst;

	// loop through the W2k identified instances
	for( int t_iCtrIndex = 0 ; t_iCtrIndex < t_oAdapterEnum.GetSize() ; t_iCtrIndex++ )
	{
		if( !( t_pAdapterInst = (CW2kAdapterInstance*) t_oAdapterEnum.GetAt( t_iCtrIndex ) ) )
		{
			continue;
		}

		t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;

		// Drop out nicely if the Instance allocation fails
		if ( NULL != t_pInst )
		{
			// set the association index
			t_pInst->SetDWORD(IDS_Index, t_pAdapterInst->dwIndex ) ;

			CHString	t_chsIndex ;
						t_chsIndex.Format(_T("%u"), t_pAdapterInst->dwIndex ) ;

			// primary key
			t_pInst->SetCHString( IDS_DeviceID, t_chsIndex ) ;

			// We load adapter data here.
			t_hResult = GetNetCardInfoForNT5(
                t_pAdapterInst, 
                t_pInst,
                mapNCProps) ;

			if (SUCCEEDED( t_hResult ) )
			{
				t_hResult = t_pInst->Commit() ;
			}
			else
			{
				break ;
			}
		}
	}

	return t_hResult ;
}



HRESULT CWin32NetworkAdapter::GetNetCardInfoForNT5(
    CW2kAdapterInstance *a_pAdapterInst,
    CInstance	*a_pInst,
    BSTRT2NCPROPMAP& mapNCProps)
{
	HRESULT		t_hResult = WBEM_S_NO_ERROR;
	FILETIME	t_ft ;
	CHString	t_sTemp ;

	// PNP deviceID
	CHString t_strDriver(_T("{4D36E972-E325-11CE-BFC1-08002BE10318}\\") ) ;

	t_strDriver += a_pAdapterInst->chsPrimaryKey ;

	GetWinNT5PNPDeviceID( a_pInst, t_strDriver ) ;

	// descriptions
	CHString t_csDeviceID( a_pAdapterInst->chsCaption ) ;
	CHString t_csDescription( a_pAdapterInst->chsDescription ) ;

	// in the event one of the descriptions is missing as with NT5 bld 1991
	if( t_csDescription.IsEmpty() )
	{
		t_csDescription = t_csDeviceID;
	}
	else if( t_csDeviceID.IsEmpty() )
	{
		t_csDeviceID = t_csDescription;
	}

	// Caption/Description
	vSetCaption( a_pInst, t_csDeviceID, a_pAdapterInst->dwIndex, 8 ) ;

	a_pInst->SetCHString( IDS_Description, t_csDescription ) ;
	a_pInst->SetCHString( IDS_Name, t_csDescription ) ;
	a_pInst->SetCHString( IDS_ProductName, t_csDescription ) ;
	a_pInst->SetCHString( _T("SystemName"), GetLocalComputerName() ) ;

	SetCreationClassName( a_pInst ) ;

	a_pInst->SetWBEMINT16( IDS_Availability, 3 ) ;

	a_pInst->Setbool( IDS_Installed, true ) ;


	// CIM
	a_pInst->Setbool( IDS_PowerManagementSupported, FALSE ) ;
	a_pInst->SetDWORD( IDS_MaxNumberControlled,0 ) ;
	a_pInst->SetWCHARSplat( IDS_SystemCreationClassName, L"Win32_ComputerSystem" ) ;

	// Get the last boot time
	CNTLastBootTime	t_ntLastBootTime;

	if ( t_ntLastBootTime.GetLastBootTime( t_ft ) )
	{
		a_pInst->SetDateTime( IDS_TimeOfLastReset, WBEMTime(t_ft) ) ;
	}

	// Retrieve the adapter MAC address
	CHString t_csAdapterType ;
	CHString t_FriendlyName ;
	CHString t_IPHLP_Description ;	
	BYTE t_MACAddress[ 6 ] ;
    short t_sAdapterTypeID = NdisMedium802_3;

	if( fGetMacAddressAndType( a_pAdapterInst->chsNetCfgInstanceID , 
		                       t_MACAddress, t_csAdapterType, t_sAdapterTypeID,
		                       t_FriendlyName, t_IPHLP_Description) )
	{
		CHString	t_chsMACAddress;
					t_chsMACAddress.Format( _T("%02X:%02X:%02X:%02X:%02X:%02X"),
											t_MACAddress[ 0 ], t_MACAddress[ 1 ],
											t_MACAddress[ 2 ], t_MACAddress[ 3 ],
											t_MACAddress[ 4 ], t_MACAddress[ 5 ] ) ;

		a_pInst->SetCHString( IDS_MACAddress, t_chsMACAddress ) ;
	}

	// AdapterType
	if( !t_csAdapterType.IsEmpty() )
	{
		a_pInst->SetCHString( IDS_AdapterType, t_csAdapterType ) ;        
    	a_pInst->SetWBEMINT16( IDS_AdapterTypeID, t_sAdapterTypeID );		
	}

    // NetConnectionID
    if (!SetNetConnectionProps(
        a_pInst,
        a_pAdapterInst->chsNetCfgInstanceID,
        mapNCProps))
    {
        if(!t_FriendlyName.IsEmpty())
        {
		    // maps to IP_ADAPTER_ADDRESSES::FriendlyName => NETCON_PROPERTIES::pszwName
		    a_pInst->SetWCHARSplat(L"NetConnectionID",(LPCWSTR)t_FriendlyName);
		    // maps to NETCON_PROPERTIES::ncStatus
		    BSTRT2NCPROPMAP::iterator iterFound = mapNCProps.begin();
            for(;iterFound!=mapNCProps.end();++iterFound)
            {
                if (0 == _wcsicmp(iterFound->second.m_bstrtNCID,(LPCWSTR)t_FriendlyName))
                {
	    	        a_pInst->SetDWORD(L"NetConnectionStatus",iterFound->second.m_dwNCStatus);
	    	        // the  NETCON_MEDIATYPE enum is not the same asa the _NDIS_MEDIUM enum
                        // so don't be tempted to uncomment this line
    		        //a_pInst->SetWBEMINT16( IDS_AdapterTypeID, iterFound->second.m_MediaType );                
                }
            }
            // should we mimic ipconfig.exe of the Network COnnections UI ?
            // for the moment the Network Connections UI
            /*
			vSetCaption( a_pInst, t_IPHLP_Description, a_pAdapterInst->dwIndex, 8 ) ;

			a_pInst->SetCHString( IDS_Description, t_IPHLP_Description ) ;
			a_pInst->SetCHString( IDS_Name, t_IPHLP_Description ) ;
			a_pInst->SetCHString( IDS_ProductName, t_IPHLP_Description ) ;		    
            */
        }
    }

    // InterfaceIndex
    if (!a_pAdapterInst->chsNetCfgInstanceID.IsEmpty())
	{
		do
		{
            HMODULE hIpHlpApi = LoadLibraryEx(L"iphlpapi.dll",0,0);
            if (NULL == hIpHlpApi) break;
            OnDelete<HMODULE,BOOL(__stdcall *)(HMODULE),FreeLibrary> fl(hIpHlpApi);

            DWORD dwErr;
            typedef DWORD (__stdcall * fnGetAdapterIndex )(LPWSTR AdapterName,PULONG IfIndex );	                
            fnGetAdapterIndex GetAdapterIndex_ = (fnGetAdapterIndex)GetProcAddress(hIpHlpApi,"GetAdapterIndex");
            if (NULL == GetAdapterIndex_) break;

            CHString FullAdapterName = L"\\DEVICE\\TCPIP_";
            FullAdapterName += a_pAdapterInst->chsNetCfgInstanceID;
            ULONG AdapterIndex = (ULONG)(-1);
            dwErr = GetAdapterIndex_((LPWSTR)(LPCWSTR)FullAdapterName,&AdapterIndex);
            if (NO_ERROR != dwErr) break;
            
            a_pInst->SetDWORD(IDS_InterfaceIndex,AdapterIndex) ;
		} while(0);
	}

	return t_hResult ;
}



HRESULT CWin32NetworkAdapter::GetObjectNT5(
    CInstance* a_pInst,
    BSTRT2NCPROPMAP& mapNCProps)
{
	HRESULT				t_hResult = WBEM_E_NOT_FOUND ;
	CW2kAdapterEnum		t_oAdapterEnum ;
	CW2kAdapterInstance *t_pAdapterInst ;
	DWORD				t_dwTestIndex = 0 ;
	CHString			t_csPassedInKey ;

	// key
	a_pInst->GetCHString( IDS_DeviceID, t_csPassedInKey ) ;

	// check to see if the key is numeric
	if ( !t_csPassedInKey.IsEmpty() )
	{
		int t_nStrLength = t_csPassedInKey.GetLength() ;
		for ( int t_i = 0; t_i < t_nStrLength ; t_i++ )
		{
			if (!isdigit( t_csPassedInKey.GetAt( t_i ) ) )
			{
				return t_hResult ;
			}
		}

		t_dwTestIndex = _ttol( t_csPassedInKey.GetBuffer( 0 ) ) ;
	}
	else
	{
		return t_hResult ;
	}

	// loop through the W2k identified instances
	for( int t_iCtrIndex = 0 ; t_iCtrIndex < t_oAdapterEnum.GetSize() ; t_iCtrIndex++ )
	{
		if( !( t_pAdapterInst = (CW2kAdapterInstance*) t_oAdapterEnum.GetAt( t_iCtrIndex ) ) )
		{
			continue;
		}

		// match to instance
		if ( t_dwTestIndex != t_pAdapterInst->dwIndex )
		{
			continue ;
		}

		// set the association index
		a_pInst->SetDWORD(IDS_Index, t_pAdapterInst->dwIndex ) ;

		// We load adapter data here.
		t_hResult = GetNetCardInfoForNT5( 
            t_pAdapterInst, 
            a_pInst,
            mapNCProps ) ;

		break;
	}

	return t_hResult ;
}



// WinNT4.  Use the service name to get the device and from there get it's
// PNP Device ID.

void CWin32NetworkAdapter::GetWinNT4PNPDeviceID( CInstance *a_pInst, LPCTSTR t_pszServiceName )
{
	CConfigManager		t_cfgmgr ;
	CDeviceCollection	t_deviceList ;
	BOOL				t_fGotList = FALSE ;

	// On NT filter by the service name _T("of the net card
	if ( t_cfgmgr.GetDeviceListFilterByService( t_deviceList, t_pszServiceName ) )
	{
		// On NT 4, just get at 0.  If we ever have to deal with multiple
		// net cards under the same service, this must change.  However, this
		// class will have to change, since it's using the service name as
		// the key.

		// smart ptr
		CConfigMgrDevicePtr t_pNetAdapter( t_deviceList.GetAt( 0 ), false );

		if ( NULL != t_pNetAdapter )
		{
			SetConfigMgrProperties( t_pNetAdapter, a_pInst ) ;

            // Get the service name while we're here
            CHString t_sServiceName ;

			t_pNetAdapter->GetService( t_sServiceName ) ;

            a_pInst->SetCHString( IDS_ServiceName, t_sServiceName ) ;
		}
	}
}


// WinNT5.  Use the Driver key name to get the device and from there get it's PNP Device ID.

void CWin32NetworkAdapter::GetWinNT5PNPDeviceID( CInstance *a_pInst, LPCTSTR a_pszDriver )
{
	CConfigManager		t_cfgmgr ;
	CDeviceCollection	t_deviceList ;
	BOOL				t_fGotList = FALSE ;

	// On NT filter by the driver key name for the net card
	if ( t_cfgmgr.GetDeviceListFilterByDriver( t_deviceList, a_pszDriver ) )
	{
		// smart ptr
		CConfigMgrDevicePtr t_pNetAdapter( t_deviceList.GetAt( 0 ), false );

		if ( NULL != t_pNetAdapter )
        {
			SetConfigMgrProperties( t_pNetAdapter, a_pInst ) ;

            CHString t_Manufacturer ;

			if ( t_pNetAdapter->GetMfg ( t_Manufacturer ) )
			{
				a_pInst->SetCHString ( IDS_Manufacturer, t_Manufacturer ) ;
			}

			// Get the service name while we're here
            CHString t_sServiceName ;

			t_pNetAdapter->GetService( t_sServiceName ) ;

			a_pInst->SetCHString( IDS_ServiceName, t_sServiceName ) ;
        }
	}
}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  void CWin32NetworkAdapter::vSetCaption( CInstance* a_pInst, CHString& rchsDesc, DWORD dwIndex, int iFormatSize )

 Description: Lays in the registry index instance id into the caption property.
			  Then concats the description
			  This will be used with the view provider to associacte WDM NDIS class instances
			  with an instance of this class

 Arguments:	a_pInst [IN], rchsDesc [IN], dwIndex [IN], iFormatSize [IN]
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:					  02-Oct-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
void CWin32NetworkAdapter::vSetCaption( CInstance	*a_pInst,
										CHString	&a_rchsDesc,
										DWORD		a_dwIndex,
										int			a_iFormatSize )
{
	CHString t_chsFormat;
			 t_chsFormat.Format( L"%%0%uu", a_iFormatSize ) ;

	CHString t_chsRegInstance;
			 t_chsRegInstance.Format( t_chsFormat, a_dwIndex ) ;

	CHString t_chsCaption(_T("[") ) ;
			 t_chsCaption += t_chsRegInstance ;
			 t_chsCaption += _T("] " ) ;
			 t_chsCaption += a_rchsDesc ;

	a_pInst->SetCHString( IDS_Caption, t_chsCaption ) ;
}

void CWin32NetworkAdapter::GetNetConnectionProps(
    BSTRT2NCPROPMAP& mapNCProps)
{
	HRESULT hr = S_OK;

	HMODULE hNetShell = LoadLibraryExW(L"netshell.dll",NULL,0);

	if (NULL == hNetShell) return;
	OnDelete<HMODULE,BOOL(*)(HMODULE),FreeLibrary> FreeMe(hNetShell);

	NcFreeNetconProperties_ = (fnNcFreeNetconProperties)GetProcAddress(hNetShell,"NcFreeNetconProperties");
	if (NULL == NcFreeNetconProperties_) return;

	INetConnectionManager* pconmgr = NULL;
	IEnumNetConnection* pnetenum = NULL;
	INetConnection* pinet = NULL;
	ULONG ulFetched = 0L;
	LPWSTR wstrTemp = NULL;    

	hr = ::CoCreateInstance(CLSID_ConnectionManager,NULL,CLSCTX_ALL,
		                               __uuidof(INetConnectionManager),(void**) &pconmgr);

	if (FAILED(hr) || (NULL == pconmgr)) return;        
	OnDelete<IUnknown *,VOID(*)(IUnknown *),RM> ReleaseMe1(pconmgr);

	hr = pconmgr->EnumConnections(NCME_DEFAULT,&pnetenum);

	if (FAILED(hr) || (NULL == pnetenum)) return;        
	OnDelete<IUnknown *,VOID(*)(IUnknown *),RM> ReleaseMe2(pnetenum);        


	hr = pnetenum->Next(1,&pinet,&ulFetched);

	while(SUCCEEDED(hr) && pinet != NULL)
	{
	    OnDeleteIf<IUnknown *,VOID(*)(IUnknown *),RM> ReleaseMe3(pinet);
	    
	    NETCON_PROPERTIES* pprops = NULL;

	    hr = pinet->GetProperties(&pprops);

	    if(SUCCEEDED(hr) && pprops != NULL)
	    {
	        OnDelete<NETCON_PROPERTIES*,fnNcFreeNetconProperties const &,NcFreeNetconProperties_> FreeProp(pprops);
	        
	        hr = ::StringFromCLSID(pprops->guidId, &wstrTemp);
	        
	        if(SUCCEEDED(hr))
	        {
	            OnDelete<void *,void(*)(void *),CoTaskMemFree> FreeMe(wstrTemp);
	            
	            NCPROP ncp(pprops->pszwName, pprops->Status,pprops->MediaType);
	    
	            mapNCProps.insert(BSTRT2NCPROPMAP::value_type(wstrTemp, ncp));
	            
	            wstrTemp = NULL;
	        }
	    }

	    pinet->Release();
	    pinet = NULL;
	    ReleaseMe3.dismiss();

	    hr = pnetenum->Next(1,&pinet,&ulFetched);
	}

}


// Finds the proper netconnectionid by looking
// it up in the map using pInst->"Name".
BOOL CWin32NetworkAdapter::SetNetConnectionProps(
    CInstance* pInst,
    CHString& chstrNetConInstID,  
    BSTRT2NCPROPMAP& mapNCProps)
{
    _bstr_t bstrtNetConInstID = chstrNetConInstID;
    BSTRT2NCPROPMAP::iterator iterFound = NULL;
    iterFound = mapNCProps.find(
        bstrtNetConInstID);
    if(iterFound != mapNCProps.end())
    {
        pInst->SetWCHARSplat(
            L"NetConnectionID",
            (LPWSTR) iterFound->second.m_bstrtNCID);

        pInst->SetDWORD(
            L"NetConnectionStatus",
            iterFound->second.m_dwNCStatus);

        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\netadaptercfg.h ===
//=================================================================

//

// NetAdaptCfg.h -- Network card configuration property set provider

//

//  Copyright (c) 1996-2002 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/28/96    a-jmoon        Created
//               11/4/97     jennymc        moved to new framework
//                                          and rewrote Win95 stuff
//
//				09/15/98					extensive rewrite 
//
//				03/03/99				Added graceful exit on SEH and memory failures,
//											syntactic clean up		  
//
//
//=================================================================
#ifndef _NETADAPTERCFG_H_
#define _NETADAPTERCFG_H_





#define PROPSET_NAME_NETADAPTERCFG  L"Win32_NetworkAdapterConfiguration"


// NT4 registry key values
#define SERVICES_HOME		L"SYSTEM\\CurrentControlSet\\Services"
#define DHCP				L"\\DHCP"
#define PARAMETERS			L"\\Parameters"
#define OPTIONS				L"\\Options"
#define TCPIP_PARAMETERS	L"\\Tcpip\\Parameters"
#define PARAMETERS_TCPIP	L"\\Parameters\\Tcpip"
#define NETBT_PARAMETERS	L"\\Netbt\\Parameters"
#define NETBT_ADAPTERS		L"\\Netbt\\Adapters"
#define TCPIP				L"\\tcpip"
#define IPX					L"\\nwlnkipx"
#define NETCONFIG			L"\\NetConfig"

// DHCP special deletable values
#define RGAS_DHCP_OPTION_IPADDRESS  L"System\\CurrentControlSet\\Services\\?\\Parameters\\Tcpip\\DhcpIPAddress"
#define RGAS_DHCP_OPTION_SUBNETMASK L"System\\CurrentControlSet\\Services\\?\\Parameters\\Tcpip\\DhcpSubnetMask"
#define RGAS_DHCP_OPTION_NAMESERVERBACKUP L"System\\CurrentControlSet\\Services\\NetBT\\Adapters\\?\\DhcpNameServerBackup"

// NT4 DNS registry key items
#define RVAL_HOSTNAME		L"Hostname"
#define RVAL_DOMAIN			L"Domain"
#define RVAL_DHCPDOMAIN		L"DhcpDomain"
#define RVAL_NAMESERVER		L"NameServer"
#define RVAL_DHCPNAMESERVER L"DhcpNameServer" 
#define RVAL_SEARCHLIST		L"SearchList"

// NT5 DNS
#define RVAL_DisableDynamicUpdate					L"DisableDynamicUpdate"
#define RVAL_EnableAdapterDomainNameRegistration	L"EnableAdapterDomainNameRegistration"

// NT5 IP 
#define RVAL_ConnectionMetric	L"InterfaceMetric"

//NT4 WINS registry key values
#define RVAL_DNS_ENABLE_WINS    L"EnableDNS"
#define RVAL_PRIMARY_WINS       L"NameServer"
#define RVAL_SECONDARY_WINS     L"NameServerBackup"
#define RVAL_DNS_ENABLE_LMHOST	L"EnableLMHOSTS"
#define RVAL_SCOPEID            L"ScopeID"

#define RVAL_NETBT_NETBIOSOPTIONS   L"NetbiosOptions"

//NT4 IP Security key values
#define RVAL_SECURITY_TCP       L"TCPAllowedPorts"
#define RVAL_SECURITY_UDP       L"UDPAllowedPorts"
#define RVAL_SECURITY_IP        L"RawIPAllowedProtocols"
#define RVAL_SECURITY_ENABLE    L"EnableSecurityFilters"

//NT4 IPX key values
#define RVAL_VIRTUAL_NET_NUM	L"VirtualNetworkNumber"
#define RVAL_MEDIA_TYPE			L"MediaType"
#define RVAL_PKT_TYPE			L"PktType"
#define	RVAL_NETWORK_NUMBER		L"NetworkNumber"

//NT4 TCP/IP misc key values
#define RVAL_DB_PATH			L"DatabasePath"
#define RVAL_ZERO_BROADCAST		L"UseZeroBroadcast"
#define RVAL_ARP_ALWAYS_SOURCE	L"ArpAlwaysSourceRoute"
#define RVAL_USE_SNAP			L"ArpUseEtherSNAP"
#define RVAL_DEFAULT_TOS		L"DefaultTOS"
#define RVAL_DEFAULT_TTL		L"DefaultTTL"
#define RVAL_DEAD_GW_DETECT		L"EnableDeadGWDetect"
#define RVAL_BLACK_HOLE_DETECT	L"EnablePMTUBHDetect"
#define RVAL_MTU_DISCOVERY		L"EnablePMTUDiscovery"
#define RVAL_FORWARD_MEM_BUFF	L"ForwardBufferMemory"
#define RVAL_IGMP_LEVEL			L"IGMPLevel"
#define RVAL_IP_KEEP_ALIVE_INT	L"KeepAliveInterval"
#define RVAL_IP_KEEP_ALIVE_TIME	L"KeepAliveTime" 
#define RVAL_MTU				L"MTU" 
#define RVAL_NUM_FORWARD_PKTS	L"NumForwardPackets" 
#define RVAL_MAX_CON_TRANS		L"TcpMaxConnectRetransmissions" 
#define RVAL_MAX_DATA_TRANS		L"TcpMaxDataRetransmissions" 
#define RVAL_NUM_CONNECTIONS	L"TcpNumConnections" 
#define RVAL_RFC_URGENT_PTR		L"TcpUseRFC1122UrgentPointer" 
#define RVAL_TCP_WINDOW_SIZE	L"TcpWindowSize"

// NetBios Options ( win2k )
#define UNSET_Netbios	0x0
#define ENABLE_Netbios	0x01
#define DISABLE_Netbios	0x02

// IPX media types
#define ETHERNET_MEDIA  0x1
#define TOKEN_MEDIA     0x2
#define FDDI_MEDIA      0x3
#define ARCNET_MEDIA    0x8

// IPX frame types
#define	ETHERNET	0x0
#define	F802_3		0x1
#define	F802_2		0x2
#define SNAP		0x3
#define ARCNET		0x4
#define AUTO		0xff

// NT4.0 file paths
#define LMHOSTS_PATH			L"\\drivers\\etc"
#define LMHOSTS_FILE			L"\\lmhosts"

// framework class methods 
#define METHOD_NAME_EnableHCP			L"EnableDHCP"
#define METHOD_NAME_EnableStatic		L"EnableStatic"

#define METHOD_NAME_RenewDHCPLease		L"RenewDHCPLease"
#define METHOD_NAME_RenewDHCPLeaseAll	L"RenewDHCPLeaseAll"
#define METHOD_NAME_ReleaseDHCPLease	L"ReleaseDHCPLease"
#define METHOD_NAME_ReleaseDHCPLeaseAll	L"ReleaseDHCPLeaseAll"

#define METHOD_NAME_SetGateways			L"SetGateways"
#define METHOD_NAME_EnableDNS			L"EnableDNS"

#define METHOD_NAME_SetDNSDomain			L"SetDNSDomain"
#define METHOD_NAME_SetDNSSuffixSearchOrder	L"SetDNSSuffixSearchOrder"
#define METHOD_NAME_SetDNSServerSearchOrder	L"SetDNSServerSearchOrder"

// W2k SP1 additions
#define METHOD_NAME_SetDynamicDNSRegistration L"SetDynamicDNSRegistration" 
#define METHOD_NAME_SetIPConnectionMetric	L"SetIPConnectionMetric"
#define METHOD_NAME_SetTcpipNetbios			L"SetTcpipNetbios"
// end additions  

#define METHOD_NAME_SetDNSSearches		L"SetDNSSearches"
#define METHOD_NAME_SetWINSServer		L"SetWINSServer"
#define METHOD_NAME_EnableWINS			L"EnableWINS"
#define METHOD_NAME_EnableIPFilterSec	L"EnableIPFilterSec"
#define METHOD_NAME_EnableIPSec			L"EnableIPSec"
#define METHOD_NAME_DisableIPSec		L"DisableIPSec"
#define METHOD_NAME_IPXVirtualNetNum	L"SetIPXVirtualNetworkNumber"
#define METHOD_NAME_IPXSetFrameNetPairs	L"SetIPXFrameTypeNetworkPairs"

#define METHOD_NAME_SetDBPath			L"SetDatabasePath"
#define METHOD_NAME_SetIPUseZero		L"SetIPUseZeroBroadcast"
#define METHOD_NAME_SetArpAlwaysSource	L"SetArpAlwaysSourceRoute"
#define METHOD_NAME_SetArpUseEtherSNAP	L"SetArpUseEtherSNAP"
#define METHOD_NAME_SetTOS				L"SetDefaultTOS"
#define METHOD_NAME_SetTTL				L"SetDefaultTTL"
#define METHOD_NAME_SetDeadGWDetect		L"SetDeadGWDetect"
#define METHOD_NAME_SetPMTUBHDetect		L"SetPMTUBHDetect"
#define METHOD_NAME_SetPMTUDiscovery	L"SetPMTUDiscovery"
#define METHOD_NAME_SetForwardBufMem	L"SetForwardBufferMemory"
#define METHOD_NAME_SetIGMPLevel		L"SetIGMPLevel"
#define METHOD_NAME_SetKeepAliveInt		L"SetKeepAliveInterval"
#define METHOD_NAME_SetKeepAliveTime	L"SetKeepAliveTime"
#define METHOD_NAME_SetMTU				L"SetMTU"
#define METHOD_NAME_SetNumForwardPkts	L"SetNumForwardPackets"
#define METHOD_NAME_SetTcpMaxConRetrans	L"SetTcpMaxConnectRetransmissions"
#define METHOD_NAME_SetTcpMaxDataRetrans	L"SetTcpMaxDataRetransmissions"
#define METHOD_NAME_SetTcpNumCons		L"SetTcpNumConnections"
#define METHOD_NAME_SetTcpUseRFC1122UP	L"SetTcpUseRFC1122UrgentPointer"
#define METHOD_NAME_SetTcpWindowSize	L"SetTcpWindowSize"

//Win32_NetworkAdapterConfiguration property names ( matches method arguments ) 
#define ADAPTER_SERVICENAME		L"ServiceName"

#define DNS_HOSTNAME			L"DNSHostName"
#define DNS_DOMAIN				L"DNSDomain"
#define DNS_SERVERSEARCHORDER	L"DNSServerSearchOrder"
#define DNS_SUFFIXSEARCHORDER	L"DNSDomainSuffixSearchOrder"

#define DNS_OVER_WINS			L"DNSEnabledForWINSResolution"
#define PRIMARY_WINS_SERVER		L"WINSPrimaryServer"
#define SECONDARY_WINS_SERVER	L"WINSSecondaryServer"
#define SCOPE_ID				L"WINSScopeID"
#define WINS_ENABLE_LMHOSTS		L"WINSEnableLMHostsLookup"
#define	WINS_HOST_LOOKUP_FILE	L"WINSHostLookupFile"

// W2k SP1 additions
#define FULL_DNS_REGISTRATION	L"FullDNSRegistrationEnabled"
#define DOMAIN_DNS_REGISTRATION L"DomainDNSRegistrationEnabled"
#define IP_CONNECTION_METRIC	L"IPConnectionMetric"
#define TCPIP_NETBIOS_OPTIONS	L"TcpipNetbiosOptions"
// end additions

#define IP_SECURITY_ENABLED		L"IPFilterSecurityEnabled"
#define PERMIT_TCP_PORTS		L"IPSecPermitTCPPorts"
#define PERMIT_UDP_PORTS		L"IPSecPermitUDPPorts"
#define PERMIT_IP_PROTOCOLS		L"IPSecPermitIPProtocols"

#define IPX_VIRTUAL_NET_NUM		L"IPXVirtualNetNumber"
#define IPX_MEDIATYPE			L"IPXMediaType"
#define IPX_FRAMETYPE			L"IPXFrameType"
#define IPX_NETNUMBER			L"IPXNetworkNumber"

// TCP misc
#define DATA_BASE_PATH			L"DatabasePath"
#define IP_USE_ZERO_BROADCAST	L"IPUseZeroBroadcast"
#define ARP_ALWAYS_SOURCE_ROUTE	L"ArpAlwaysSourceRoute"
#define ARP_USE_ETHER_SNAP		L"ArpUseEtherSNAP"
#define DEFAULT_TOS				L"DefaultTOS"
#define DEFAULT_TTL				L"DefaultTTL"
#define ENABLE_DEAD_GW_DETECT	L"DeadGWDetectEnabled"
#define ENABLE_PMTUBH_DETECT	L"PMTUBHDetectEnabled"
#define ENABLE_PMTU_DISCOVERY	L"PMTUDiscoveryEnabled"
#define FORWARD_BUFFER_MEMORY	L"ForwardBufferMemory"
#define IGMP_LEVEL				L"IGMPLevel"
#define KEEP_ALIVE_INTERVAL		L"KeepAliveInterval"
#define KEEP_ALIVE_TIME			L"KeepAliveTime"
#define MTU						L"MTU"
#define NUM_FORWARD_PACKETS		L"NumForwardPackets"
#define TCP_MAX_CONNECT_RETRANS	L"TcpMaxConnectRetransmissions"
#define TCP_MAX_DATA_RETRANS	L"TcpMaxDataRetransmissions"
#define TCP_NUM_CONNECTIONS		L"TcpNumConnections"
#define TCP_USE_RFC1122_URG_PTR	L"TcpUseRFC1122UrgentPointer"
#define TCP_WINDOW_SIZE			L"TcpWindowSize"


// Win32_NetworkAdapterConfigReturn return values 
//		NOTE:	These enums are documented returns 
//				do not change or reorder.   
#define METHOD_ARG_NAME_METHODRESULT	L"ReturnValue"
enum E_RET	{
	E_RET_OK,
	E_RET_OK_REBOOT_REQUIRED,
	E_RET_UNSUPPORTED = 64,	// errors start here
	E_RET_UNKNOWN_FAILURE,
	E_RET_IP_MASK_FAILURE,
	E_RET_INSTANCE_CALL_FAILED,
	E_RET_INPARM_FAILURE,
	E_RET_MORE_THAN_FIVE_GATEWAYS,
	E_RET_IP_INVALID,
	E_RET_GATEWAY_IP_INVALID,	
	E_RET_REGISTRY_FAILURE,
	E_RET_INVALID_DOMAINNAME,
	E_RET_INVALID_HOSTNAME,
	E_RET_WINS_SEC_NO_PRIME,
	E_RET_INVALID_FILE,
	E_RET_SYSTEM_PATH_INVALID,
	E_RET_FILE_COPY_FAILED,
	E_RET_INVALID_SECURITY_PARM,
	E_RET_UNABLE_TO_CONFIG_TCPIP_SERVICE,
	E_RET_UNABLE_TO_CONFIG_DHCP_SERVICE,
	E_RET_UNABLE_TO_RENEW_DHCP_LEASE,
	E_RET_UNABLE_TO_RELEASE_DHCP_LEASE,
	E_RET_IP_NOT_ENABLED_ON_ADAPTER,
	E_RET_IPX_NOT_ENABLED_ON_ADAPTER,
	E_RET_FRAME_NETNUM_BOUNDS_ERR,
	E_RET_INVALID_FRAMETYPE,
	E_RET_INVALID_NETNUM,
	E_RET_DUPLICATE_NETNUM,
	E_RET_PARAMETER_BOUNDS_ERROR,
	E_RET_ACCESS_DENIED,
	E_RET_OUT_OF_MEMORY,
	E_RET_ALREADY_EXISTS,
	E_RET_OBJECT_NOT_FOUND,			// path, file or object
	E_RET_UNABLE_TO_NOTIFY_SERVICE,
	E_RET_UNABLE_TO_NOTIFY_DNS_SERVICE,
	E_RET_INTERFACE_IS_NOT_CONFIGURABLE,
	E_RET_PARTIAL_COMPLETION,
	E_RET_DHCP_NOT_ENABLED_ON_ADAPTER = 100
	};

// framework method returns
#define	TO_CALLER	S_OK;  


// misc defines
#define HOST_LIMIT				63
#define HOSTNAME_LENGTH         64
#define DOMAINNAME_LENGTH       255
#define MAX_IP_SIZE				16

#ifndef _ENUM_SERVICE_ENABLE_DEFINED
#define _ENUM_SERVICE_ENABLE_DEFINED
typedef enum _SERVICE_ENABLE {
    IgnoreFlag,
    DhcpEnable,
    DhcpDisable
} SERVICE_ENABLE, *LPSERVICE_ENABLE;
#endif

//DHCP defines and entry points into dhcpcsvc.dll
#define DHCP_DLL		_T("dhcpcsvc.dll")
#define DHCP_ACQUIRE	"DhcpAcquireParameters"
#define DHCP_RELEASE	"DhcpReleaseParameters"
#define DHCP_NOTIFY		"DhcpNotifyConfigChange"

typedef DWORD (APIENTRY *DHCP_ACQUIRE_ROUTINE)(LPWSTR) ;
typedef DWORD (APIENTRY *DHCP_RELEASE_ROUTINE)(LPWSTR) ;
typedef DWORD (APIENTRY *DHCP_NOTIFY_ROUTINE)(LPWSTR, LPWSTR, BOOL, DWORD, DWORD, DWORD, SERVICE_ENABLE) ;

class CMParms
{
	public:
        
		CInstance	*m_pInst;
		BSTR		*m_pbstrMethodName;
		CInstance	*m_pInParams;
		CInstance	*m_pOutParams;
		long		m_lFlags;
		
		//=================================================
        // Constructors/destructor
        //=================================================
        CMParms() ;
		CMParms( const CInstance& rInstance ) ;
		CMParms( const CInstance& rInstance, const CInstance& rInParams ) ;
		CMParms( const CInstance& rInstance, const BSTR& rbstrMethodName, 
					  CInstance* pInParams, CInstance* pOutParams, long lFlags ) ;
       ~CMParms() ;

		// operations

		CInstance* pInst()
			{ return m_pInst; }	
		
		CInstance* pInParams()
			{ return m_pInParams; }	

		HRESULT hSetResult( E_RET eValue )
			{ m_pOutParams->SetDWORD( METHOD_ARG_NAME_METHODRESULT, eValue ) ; return S_OK; }
};


// incapsulated SAFEARRAY* for garbage cleanup
class saAutoClean
{
protected:
	SAFEARRAY **m_ppArray;
public:	
	saAutoClean( SAFEARRAY **a_ppArray ) ;
	~saAutoClean() ;
};


// Provider class
class CWin32NetworkAdapterConfig : public Provider
{
	private:

        BOOL GetServiceName( DWORD a_dwIndex, CInstance *a_pInst, CHString &a_ServiceName ) ;


        BOOL GetNTBusInfo( LPCTSTR a_pszServiceName, CInstance *a_pInst ) ;
        
		BOOL GetIPInfoNT( CInstance *a_pInst, LPCTSTR a_szKey, CAdapters &a_rAdapters ) ;
		BOOL GetIPInfoNT351( CInstance *a_pInst, CRegistry &a_rRegistry ) ;
		BOOL GetIPInfoNT4orBetter( CInstance *a_pInst, LPCTSTR a_szKey, CRegistry &a_rRegistry, CAdapters &a_rAdapters ) ;
        BOOL ResetGateways(CInstance *a_pInst);

		
		BOOL fSetIPBindingInfo( CInstance *a_pInst, _ADAPTER_INFO *a_pAdapterInfo ) ;
		
	


    HRESULT hGetDNSW2K(
        CInstance *a_pInst, 
        DWORD a_dwIndex,
        CHString& a_chstrRootDevice,
        CHString& a_chstrIpInterfaceKey);
    



	#ifdef NTONLY

		E_RET fLoadAndValidateDNS_Settings( 
								CMParms		&a_rMParms,
								CHString	&a_csHostName, 
								CHString	&a_csDomain,
								SAFEARRAY	**a_ServerSearchOrder,
								SAFEARRAY	**a_SuffixSearchOrder,
								DWORD		*a_dwValidBits
								) ;

		HRESULT hGetNtIpSec(	CInstance *a_pInst, 
								LPCTSTR a_szKey ) ;
		
		bool	IsConfigurableTcpInterface( CHString a_chsLink ) ;
		
		int		GetCAdapterIndexViaInterfaceContext(

										CRegistry &a_rRegistry,
                                        LPCTSTR a_szKey,
										CAdapters &a_rAdapters 
										) ;

		BOOL	fMapIndextoKey( 		DWORD a_dwIndex, 
										CHString &a_chsLinkKey
										) ;

		BOOL    fGetNtTcpRegAdapterKey( DWORD a_dwIndex,
										CHString &a_chsRegKey,
										CHString &a_chsLinkKey ) ;
		
		BOOL	fGetNtNBRegAdapterKey(	DWORD a_dwIndex, 
										CHString &a_csNBBindingKey, 
										CHString &a_chsLink ) ;

		BOOL	fGetNtIpxRegAdapterKey(	DWORD a_dwIndex, 
										CHString &a_csIPXNetBindingKey,
										CHString &a_chsLink ) ;
	#endif

        BOOL IsContextIncluded( DWORD a_Context, DWORD a_contextlist[], int a_len_contextlist ) ;

		LONG ReadRegistryList( HKEY a_Key, LPCTSTR a_ParameterName, DWORD a_NumList[], int *a_MaxList ) ;
		LONG RegQueryForString( HKEY a_hKey, LPCTSTR a_pszTarget, LPTSTR a_pszDestBuffer, DWORD a_dDestBufferSize ) ;
		
		LONG RegGetStringArray( CRegistry &a_rRegistry, LPCWSTR  a_szSubKey, SAFEARRAY **a_t_Array, TCHAR a_cDelimiter = ' ' ) ;
        LONG RegGetStringArrayEx(CRegistry &a_rRegistry,
								 LPCWSTR a_szSubKey,
								 SAFEARRAY** a_Array );

		LONG RegGetHEXtoINTArray( CRegistry &a_rRegistry, LPCTSTR a_szSubKey, SAFEARRAY **a_t_Array ) ;

		LONG RegPutStringArray(HKEY a_hKey, LPCTSTR a_pszTarget, SAFEARRAY &a_strArray,	TCHAR a_cDelimiter = ' ' ) ;
		LONG RegPutStringArray(CRegistry &a_rRegPut, LPCTSTR a_pszTarget, SAFEARRAY &a_strArray, TCHAR a_cDelimiter = ' ' )
			{ return RegPutStringArray( a_rRegPut.GethKey(), a_pszTarget, a_strArray, a_cDelimiter) ; };
		
		LONG RegPutINTtoStringArray(	HKEY a_hKey, 
										LPCTSTR a_pszTarget,
										SAFEARRAY *a_strArray, 
										CHString &a_chsFormat,
										int iMinOutSize ) ;
		
		LONG RegPutINTtoStringArray(	CRegistry &a_rRegPut,
										LPCTSTR a_pszTarget,
										SAFEARRAY *a_strArray, 
										CHString &a_chsFormat, 
										int a_iMinOutSize )
			{ return RegPutINTtoStringArray( a_rRegPut.GethKey(), a_pszTarget, a_strArray, a_chsFormat, a_iMinOutSize ) ; };
		

#ifdef NTONLY
#if NTONLY >= 5
		HRESULT hGetWinsW2K(
            CInstance *a_pInst, 
            DWORD a_dwIndex,
            CHString& a_chstrRootDevice,
            CHString& a_chstrIpInterfaceKey);
#else
        HRESULT hGetWinsNT( CInstance *a_pInst, DWORD a_dwIndex ) ;
#endif
		HRESULT hGetIPXGeneral( CInstance *a_pInst, DWORD a_dwIndex ) ;
		HRESULT hGetTcpipGeneral( CInstance *a_pInst ) ;
		BOOL	fValidateIPGateways( CMParms &a_rMParms, SAFEARRAY *a_IpGatewayArray, SAFEARRAY **a_CostMetric ) ;
#endif

      	// framework class methods
		HRESULT hEnableDHCP( CMParms &a_rMParms ) ;
		HRESULT hEnableStatic( CMParms &a_rMParms ) ;
        HRESULT hEnableStaticHelper( CMParms &a_rMParms, SAFEARRAY *a_IpArray, SAFEARRAY *a_MaskArray);
		HRESULT hRenewDHCPLease( CMParms &a_rMParms ) ;
		HRESULT hRenewDHCPLeaseAll( CMParms &a_rMParms ) ;
		HRESULT hReleaseDHCPLease( CMParms &a_rMParms ) ;
		HRESULT hReleaseDHCPLeaseAll( CMParms &a_rMParms ) ;
		HRESULT hSetGateways( CMParms &a_rMParms ) ;
		HRESULT hEnableIPFilterSec( CMParms &a_rMParms ) ;
		HRESULT hEnableIPSec( CMParms &a_rMParms ) ;
		HRESULT hDisableIPSec( CMParms &a_rMParms ) ;			
		HRESULT hEnableWINSServer( CMParms &a_rMParms ) ;
		HRESULT hEnableWINS( CMParms &a_rMParms ) ;			
		HRESULT hEnableDNS( CMParms &a_rMParms ) ;

		HRESULT hSetDNSDomain( CMParms &a_rMParms ) ;
		HRESULT hSetDNSSuffixSearchOrder( CMParms &a_rMParms ) ;
		HRESULT hSetDNSServerSearchOrder( CMParms &a_rMParms ) ;
	
		HRESULT hSetVirtualNetNum( CMParms &a_rMParms ) ;
		HRESULT hSetFrameNetPairs( CMParms &a_rMParms ) ;
		HRESULT hSetDBPath( CMParms &a_rMParms ) ;
		HRESULT hSetIPUseZero( CMParms &a_rMParms ) ;
		HRESULT hSetArpAlwaysSource( CMParms &a_rMParms ) ;
		HRESULT hSetArpUseEtherSNAP( CMParms &a_rMParms ) ;
		HRESULT hSetTOS( CMParms &a_rMParms ) ;
		HRESULT hSetTTL( CMParms &a_rMParms ) ;
		HRESULT hSetDeadGWDetect( CMParms &a_rMParms ) ;
		HRESULT hSetPMTUBHDetect( CMParms &a_rMParms ) ;
		HRESULT hSetPMTUDiscovery( CMParms &a_rMParms ) ;
		HRESULT hSetForwardBufMem( CMParms &a_rMParms ) ;
		HRESULT hSetIGMPLevel( CMParms &a_rMParms ) ;
		HRESULT hSetKeepAliveInt( CMParms &a_rMParms ) ;
		HRESULT hSetKeepAliveTime( CMParms &a_rMParms ) ;
		HRESULT hSetMTU( CMParms &a_rMParms ) ;
		HRESULT hSetNumForwardPkts( CMParms &a_rMParms ) ;
		HRESULT hSetTcpMaxConRetrans( CMParms &a_rMParms ) ;
		HRESULT hSetTcpMaxDataRetrans( CMParms &a_rMParms ) ;
		HRESULT hSetTcpNumCons( CMParms &a_rMParms ) ;
		HRESULT hSetTcpUseRFC1122UP( CMParms &a_rMParms ) ;
		HRESULT hSetTcpWindowSize( CMParms &a_rMParms ) ;

		HRESULT hSetDynamicDNSRegistration( CMParms &a_rMParms ) ;
		HRESULT hSetTcpipNetbios( CMParms &a_rMParms ) ;
		HRESULT hSetIPConnectionMetric( CMParms &a_rMParms ) ;
		
		// utilities
		BOOL	fCreateAddEntry( SAFEARRAY **a_t_Array, CHString &a_chsStr ) ;
		BOOL	fCreateBoolToReg( CMParms &a_rMParms, CHString &a_oSKey, LPCTSTR a_pSource, LPCTSTR a_pTarget ) ;
		BOOL	fBoolToReg( CMParms &a_rMParms, CRegistry &a_oReg, LPCTSTR a_pSource, LPCTSTR a_pTarget ) ;

		E_RET eValidateIPSecParms( SAFEARRAY *a_IpArray, int a_iMax ) ;
		BOOL fValidateIPs( SAFEARRAY *a_IpArray ) ;
	
		BOOL fValidFrameNetPairs(	CMParms &a_rMParms,
									SAFEARRAY *a_FrameType,
									SAFEARRAY *a_NetNumber,
									BOOL *t_fIsAuto ) ;

		BOOL fIsValidIP( CHString &a_strIP ) ;
		BOOL fIsValidateDNSDomain( CHString &a_rchDomain ) ;
		BOOL fIsValidateDNSHost( CHString &a_rchHost ) ;
		BOOL fIsIPEnabled( CMParms &a_rMParms ) ;
		BOOL fIsIPXEnabled( CMParms &a_rMParms ) ;
		BOOL fIsDhcpEnabled( CMParms &a_rMParms ) ;
		E_RET eIsValidIPandSubnets( SAFEARRAY *a_IpAddressArray, SAFEARRAY *a_IpMaskArray ) ;
		E_RET eIsValidIPandSubnet( DWORD a_ardwIP[ 4 ], DWORD a_ardwMask[ 4 ] ) ;
		BOOL fGetNodeNum( CHString &a_strIP, DWORD a_ardw[ 4 ] ) ;
		void vBuildIP( DWORD a_ardwIP[ 4 ], CHString &a_strIP ) ;
		BOOL fValidateWINSLookupFile( CHString &a_rchsFile ) ;

		DWORD  dwEnableService( LPCTSTR a_lpServiceName, BOOL a_fEnable ) ;
		DWORD  dwSendServiceControl( LPCTSTR a_lpServiceName, DWORD a_dwControl ) ;

		HRESULT hConfigDHCP( CMParms &a_rMParms, SAFEARRAY *a_IpArray = NULL, SAFEARRAY *a_MaskArray = NULL ) ;
		E_RET   hDHCPAcquire( CMParms &a_rMParms, CHString &a_chsAdapter ) ;
		E_RET   hDHCPRelease( CMParms &a_rMParms, CHString &a_chsAdapter ) ;
		HRESULT hDHCPNotify(	CMParms &a_rMParms, 
								CHString &a_chsAdapter,
								BOOL a_fIsNewIpAddress,
								DWORD a_dwIpIndex,
								DWORD a_dwIpAddress,
								DWORD a_dwSubnetMask, 
								SERVICE_ENABLE a_DhcpServiceEnabled ) ;

		BOOL    fCleanDhcpReg( CHString &t_chsLink ) ;
		BOOL	fDeleteValuebyPath( CHString &a_chsDelLocation ) ;

		
		BOOL fGetWinsServers( CHString &a_rDeviceName, CHString &a_chsPrimary, CHString &a_chsSecondary ) ; 
		BOOL fSetWinsServers( CHString &a_rDeviceName, CHString &a_chsPrimary, CHString &a_chsSecondary ) ; 
		BOOL fGetMacAddress( BYTE a_MACAddress[ 6 ], CHString &a_rDeviceName ) ;
		BOOL fCreateSymbolicLink( CHString &a_rDeviceName ) ;
		BOOL fDeleteSymbolicLink(  CHString &a_rDeviceName ) ; 
	
		BOOL fMapResError( CMParms &a_rMParms, LONG a_lError, E_RET a_eDefaultError ) ;
		void vSetCaption( CInstance *a_pInst, CHString &a_rchsDesc, DWORD a_dwIndex, int a_iFormatSize ) ;
		BOOL GetSettingID( CInstance *a_pInst, CW2kAdapterInstance *a_pAdapterInst ) ;

#if NTONLY >= 5
		E_RET eSetNetBiosOptions( DWORD a_dwOption, DWORD a_dwIndex ) ;
#endif   
	public:
        
        //=================================================
        // Constructor/destructor
        //=================================================

        CWin32NetworkAdapterConfig( LPCWSTR a_name, LPCWSTR a_pszNamespace ) ;
       ~CWin32NetworkAdapterConfig() ;

        //=================================================
        // Functions provide properties with current values
        //=================================================
		virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags = 0L ) ;
		virtual HRESULT EnumerateInstances(MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;
		
		virtual	HRESULT ExecMethod(	const CInstance &a_Inst, const BSTR a_MethodName, 
									CInstance *a_InParams, CInstance *a_OutParams, long a_Flags = 0L ) ;


	#ifdef NTONLY
        HRESULT GetNetCardConfigInfoNT( MethodContext *a_pMethodContext,
										CInstance *a_pSpecificInstance,
										DWORD a_dwIndex,
										CAdapters &a_rAdapters ) ;
	#endif

	#if NTONLY >= 5
	
		HRESULT EnumNetAdaptersInNT5(MethodContext *a_pMethodContext, CAdapters &a_rAdapters ) ;
		
		HRESULT GetNetCardConfigForNT5 (	CW2kAdapterInstance *a_pAdapterInst,
											CInstance *a_pInst, 
											CAdapters &a_rAdapters ) ;

		HRESULT GetNetAdapterInNT5( CInstance *a_pInst, CAdapters &a_rAdapters ) ;
	#endif

		BOOL GetIPXAddresses ( CInstance *a_pInst, BYTE a_MACAddress[ 6 ] ) ;
		//=================================================
		// Utility
		//=================================================
  	
} ;


//
class CDhcpIP_Instruction
{
public:
	CHString chsIPAddress;
	CHString chsIPMask;
	
	DWORD			dwIndex ;
	BOOL			bIsNewAddress ;
	SERVICE_ENABLE  eDhcpFlag ;
};

//
class CDhcpIP_InstructionList : public CHPtrArray
{

public:

		~CDhcpIP_InstructionList();

		E_RET BuildStaticIPInstructionList( 

			CMParms				&a_rMParms, 
			SAFEARRAY			*a_IpArray,
			SAFEARRAY			*a_MaskArray,
			CRegistry			&a_Registry,
			bool				t_fDHCPCurrentlyActive ) ;
		
		void AddDhcpInstruction(

			BSTR a_bstrIPAddr,
			BSTR a_bstrIPMask,
			BOOL a_bIsNewAddress,
			DWORD a_dwIndex,
			SERVICE_ENABLE a_eDhcpFlag ) ; 
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\netclient.h ===
//=================================================================

//

// NetClient.h -- Network client property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/25/97    davwoh         Moved to curly
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_NETWORK_CLIENT L"Win32_NetworkClient"

class CWin32NetCli ;

class CWin32NetCli:public Provider {

    public:
        // Constructor/destructor
        //=======================

        CWin32NetCli(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CWin32NetCli() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
#ifdef NTONLY
		virtual HRESULT GetNTObject(CInstance* pInstance, long lFlags = 0L);
#endif
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);
    private:
#ifdef NTONLY
        HRESULT EnumerateNTInstances(MethodContext *&pMethodContext);
		HRESULT FillNTInstance(CInstance* pInstance, CHString& chsClient);
#endif

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\netadaptercfg.cpp ===
//=================================================================
//
// NetAdaptCfg.CPP -- Network Card configuration property set provider
//
//  Copyright (c) 1996-2002 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/28/96    a-jmoon        Created
//
//              10/23/97    jennymc         Changed to new framework
//
//				7/23/98					Added the following NT4 support:
//												DHCP configuration
//												DNS configuration
//												WINS configuration
//												TCP/IP configuration
//												IP configuration
//												IPX configuration
//
//				09/03/98		        Major rewrite to virtually all of this provider
//											regarding the resolution adapters and MAC adresses.
//											This to correct for OS deficiencies in resolving adapters
//											and the adapter's relationship to the registry.
//
//				03/03/99				Added graceful exit on SEH and memory failures,
//											syntactic clean up
//
//=================================================================
#include "precomp.h"

#ifndef MAX_INTERFACE_NAME_LEN
#define MAX_INTERFACE_NAME_LEN  256
#endif

#include <winsock2.h>

#include <iphlpapi.h>

#include <cregcls.h>

#include <devioctl.h>
#include <ntddndis.h>
#include <winsock.h>
#include <wsipx.h>
#include <wsnwlink.h>
#include "chwres.h"

typedef LONG NTSTATUS;
#include "nbtioctl.h"

#include "chptrarr.h"
#include "wsock32api.h"
#include "CAdapters.h"
#include "irq.h"

#include "ntdevtosvcsearch.h"
#include "nt4svctoresmap.h"

#include "dhcpinfo.h"
#include <wchar.h>
#include <tchar.h>
#include "DhcpcsvcApi.h"
#include "CNdisApi.h"
#include "W2kEnum.h"

#include "NetAdapterCfg.h"

#include <dnsapi.h>
#include <algorithm>
#include <vector>

#include <algorithm>
#include <vector>

#include <netcfgp.h>
#include <netcfgn.h>
#include <netconp.h>
#include <devguid.h>

#include <iphlpapi.h>
#include <iptypes.h>



#define ZERO_ADDRESS    _T("0.0.0.0")
#define FF_ADDRESS		_T("255.0.0.0")

#define ConvertIPDword(dwIPOrSubnet)    ((dwIPOrSubnet[3]<<24) | (dwIPOrSubnet[2]<<16) | (dwIPOrSubnet[1]<<8) | (dwIPOrSubnet[0]))

// Property set declaration
//=========================
CWin32NetworkAdapterConfig	MyCWin32NetworkAdapterConfig( PROPSET_NAME_NETADAPTERCFG, IDS_CimWin32Namespace  ) ;

/*******************************************************************

    NAME:       saAutoClean, constructor and destructor

    SYNOPSIS:   Used for block scope cleanup of SAFEARRAYs

    ENTRY:      SAFEARRAY** ppArray		: on construction

    HISTORY:
                  19-Jul-1998     Created

********************************************************************/
saAutoClean::saAutoClean( SAFEARRAY	**a_ppArray )
{ m_ppArray = a_ppArray;}

saAutoClean::~saAutoClean()
{
	if( m_ppArray && *m_ppArray )
	{
		SafeArrayDestroy( *m_ppArray ) ;
		*m_ppArray = NULL ;
	}
}

/*******************************************************************

    NAME:       CMParms, constructor

    SYNOPSIS:   Sets up a parameter class for method calls from the framework.

    ENTRY:      CInstance& a_Instance,
				const BSTR a_MethodName,
				CInstance *a_InParams,
				CInstance *a_OutParams,
				long lFlags

    HISTORY:
                  19-Jul-1998     Created

********************************************************************/
CMParms::CMParms()
{
	m_pInst				= NULL;
	m_pbstrMethodName	= NULL;
	m_pInParams			= NULL;
	m_pOutParams		= NULL;
	m_lFlags			= NULL;
}

CMParms::CMParms( const CInstance &a_rInstance )
{
	CMParms( ) ;
	m_pInst	= (CInstance*) &a_rInstance;
}

CMParms::CMParms( const CInstance &a_rInstance, const CInstance &a_rInParams )
{
	CMParms( ) ;
	m_pInst		= (CInstance*) &a_rInstance ;
	m_pInParams	= (CInstance*) &a_rInParams ;
}

CMParms::CMParms( const CInstance &a_rInstance, const BSTR &a_rbstrMethodName,
						    CInstance *a_pInParams, CInstance *a_pOutParams, long a_lFlags )
{
	m_pInst				= (CInstance*) &a_rInstance;
	m_pbstrMethodName	= (BSTR*) &a_rbstrMethodName;
	m_pInParams			= a_pInParams;
	m_pOutParams		= a_pOutParams;
	m_lFlags			= a_lFlags;

	// Initialize Win32_NetworkAdapterConfigReturn
	if( m_pOutParams )
	{
		hSetResult( E_RET_UNKNOWN_FAILURE  ) ;
	}
}

CMParms::~CMParms()
{}

//
// TIME_ADJUST - DHCP uses seconds since 1980 as its time value; the C run-time
// uses seconds since 1970. To get the C run-times to produce the correct time
// given a DHCP time value, we need to add on the number of seconds elapsed
// between 1970 and 1980, which includes allowance for 2 leap years (1972 and 1976)
//

#define TIME_ADJUST(t)  ((time_t)(t) + ((time_t)(((10L * 365L) + 2L) * 24L * 60L * 60L)))

///////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetworkAdapterConfig::CWin32NetworkAdapterConfig
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/
CWin32NetworkAdapterConfig::CWin32NetworkAdapterConfig( LPCWSTR a_name, LPCWSTR a_pszNamespace )
: Provider( a_name, a_pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetworkAdapterConfig::~CWin32NetworkAdapterConfig
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/
CWin32NetworkAdapterConfig::~CWin32NetworkAdapterConfig()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Process::ExecMethod
 *
 *  DESCRIPTION : Executes a method
 *
 *  INPUTS      : Instance to execute against, method name, input parms instance
 *                Output parms instance.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32NetworkAdapterConfig::ExecMethod(	const CInstance &a_Instance, const BSTR a_MethodName,
												CInstance *a_InParams, CInstance *a_OutParams, long a_Flags )
{
	if ( !a_OutParams )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	// package these parameters
	CMParms t_oMParms( a_Instance, a_MethodName, a_InParams, a_OutParams, a_Flags  ) ;

	// Do we recognize the method?
	if( !_wcsicmp ( a_MethodName , METHOD_NAME_EnableHCP ) )
	{
		return hEnableDHCP( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_EnableStatic ) )
	{
		return hEnableStatic( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_RenewDHCPLease ) )
	{
		return hRenewDHCPLease( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_RenewDHCPLeaseAll ) )
	{
		return hRenewDHCPLeaseAll( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_ReleaseDHCPLease ) )
	{
		return hReleaseDHCPLease( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_ReleaseDHCPLeaseAll ) )
	{
		return hReleaseDHCPLeaseAll( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetGateways ) )
	{
		return hSetGateways( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_EnableDNS ) )
	{
		return hEnableDNS( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetDNSDomain ) )
	{
		return hSetDNSDomain( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetDNSSuffixSearchOrder ) )
	{
		return hSetDNSSuffixSearchOrder( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetDNSServerSearchOrder ) )
	{
		return hSetDNSServerSearchOrder( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetWINSServer ) )
	{
		return hEnableWINSServer( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_EnableWINS ) )
	{
		return hEnableWINS( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_EnableIPFilterSec ) )
	{
		return hEnableIPFilterSec( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_EnableIPSec ) )
	{
		return hEnableIPSec( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_DisableIPSec ) )
	{
		return hDisableIPSec( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_IPXVirtualNetNum ) )
	{
		return hSetVirtualNetNum( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_IPXSetFrameNetPairs ) )
	{
		return hSetFrameNetPairs( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetDBPath ) )
	{
		return hSetDBPath( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetIPUseZero ) )
	{
		return hSetIPUseZero( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetArpAlwaysSource ) )
	{
		return hSetArpAlwaysSource( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetArpUseEtherSNAP ) )
	{
		return hSetArpUseEtherSNAP( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetTOS ) )
	{
		return hSetTOS( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetTTL ) )
	{
		return hSetTTL( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetDeadGWDetect ) )
	{
		return hSetDeadGWDetect( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetPMTUBHDetect ) )
	{
		return hSetPMTUBHDetect( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetPMTUDiscovery ) )
	{
		return hSetPMTUDiscovery( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetForwardBufMem ) )
	{
		return hSetForwardBufMem( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetIGMPLevel ) )
	{
		return hSetIGMPLevel( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetKeepAliveInt ) )
	{
		return hSetKeepAliveInt( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetKeepAliveTime ) )
	{
		return hSetKeepAliveTime( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetMTU ) )
	{
		return hSetMTU( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetNumForwardPkts ) )
	{
		return hSetNumForwardPkts( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetTcpMaxConRetrans ) )
	{
		return hSetTcpMaxConRetrans( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetTcpMaxDataRetrans ) )
	{
		return hSetTcpMaxDataRetrans( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetTcpNumCons ) )
	{
		return hSetTcpNumCons( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetTcpUseRFC1122UP ) )
	{
		return hSetTcpUseRFC1122UP( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetTcpWindowSize ) )
	{
		return hSetTcpWindowSize( t_oMParms ) ;
	}

	// W2k SP1 additions

	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetDynamicDNSRegistration ) )
	{
		return hSetDynamicDNSRegistration( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetIPConnectionMetric ) )
	{
		return hSetIPConnectionMetric( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetTcpipNetbios ) )
	{
		return hSetTcpipNetbios( t_oMParms ) ;
	}

	// end additions

	return WBEM_E_INVALID_METHOD ;
}
/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32NetworkAdapterConfig::GetObject(CInstance *a_pInst, long a_lFlags /*= 0L*/)
{
    HRESULT		t_hResult = WBEM_E_FAILED ;
    DWORD		t_i ;
	CAdapters	t_oAdapters ;

    a_pInst->GetDWORD( L"Index", t_i ) ;

	{
		t_hResult = GetNetAdapterInNT5( a_pInst, t_oAdapters ) ;
	}

    return t_hResult ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetworkAdapterConfig::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each logical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32NetworkAdapterConfig::EnumerateInstances(MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/)
{
    HRESULT		t_hResult = WBEM_S_NO_ERROR ;
    CAdapters	t_oAdapters ;  // don't care about startup errors in enum function - just won't return any instances

	t_hResult = EnumNetAdaptersInNT5( a_pMethodContext, t_oAdapters ) ;
	
    return t_hResult ;
}

//
BOOL CWin32NetworkAdapterConfig::GetServiceName(DWORD a_dwIndex,
                                                CInstance *a_pInst,
                                                CHString &a_ServiceName )
{
    CRegistry	t_RegInfo ;
    BOOL		t_fRc = FALSE ;
    WCHAR		t_szTemp[ MAX_PATH + 2 ] ;
	CHString	t_chsServiceName ;
    CHString	t_sTemp ;

    // If we can't open this key, the card doesn't exist
    //==================================================
    swprintf( t_szTemp, L"Software\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards\\%d", a_dwIndex ) ;

	if( t_RegInfo.Open(HKEY_LOCAL_MACHINE, t_szTemp, KEY_READ ) == ERROR_SUCCESS )
	{
        if( t_RegInfo.GetCurrentKeyValue( L"Description", t_sTemp ) == ERROR_SUCCESS )
		{
			a_pInst->SetCHString( IDS_Description, t_sTemp ) ;
		}

        if( t_RegInfo.GetCurrentKeyValue( L"Title", t_sTemp ) == ERROR_SUCCESS )
		{
        	// NOTE: For NT4 we need not call vSetCaption() to build
			// an instance description. "Title" has the instance prepended.
			a_pInst->SetCHString( IDS_Caption, t_sTemp ) ;
		}

		// Extract other values from registry
        //===================================
        if( t_RegInfo.GetCurrentKeyValue( L"ServiceName", t_chsServiceName ) == ERROR_SUCCESS )
		{
            a_ServiceName = t_chsServiceName ;
            t_fRc = TRUE ;
        }

        t_RegInfo.Close() ;
    }
    return t_fRc ;
}
//////////////////////////////////////////////////////////////////////////
// NT4 and NT3.51 only helper function (could work on NT 5 if needed)

BOOL CWin32NetworkAdapterConfig::GetNTBusInfo( LPCTSTR a_pszServiceName, CInstance *a_pInst )
{
	BOOL	t_fReturn = FALSE ;

#ifdef _OPAL_DISCDLL
	return(true) ;
#else


	CHString					t_strBusType = _T("UNKNOWN_BUS_TYPE") ;
	CNT4ServiceToResourceMap	t_serviceMap ;

	// If our service is shown to be using resources, the resources will show a
	// bus type, which we can convert to a human readable string.

	if ( t_serviceMap.NumServiceResources( a_pszServiceName ) > 0 )
	{
		LPRESOURCE_DESCRIPTOR	t_pResource = t_serviceMap.GetServiceResource( a_pszServiceName, 0 ) ;

		if ( NULL != t_pResource )
		{
			// Convert to human readable form.
			t_fReturn = StringFromInterfaceType( t_pResource->InterfaceType, t_strBusType ) ;
		}
	}
#endif
    return t_fReturn ;
}


/////////////////////////////////////////////////////////////////////////

BOOL CWin32NetworkAdapterConfig::GetIPInfoNT(CInstance *a_pInst, LPCTSTR a_szKey, CAdapters &a_rAdapters )
{
	CRegistry	t_Registry ;
	CHString	t_chsValue ;
	DWORD		t_dwDHCPBool ;
	BOOL		t_fIPEnabled = false ;

	// IP interface location
	if ( ERROR_SUCCESS == t_Registry.Open(HKEY_LOCAL_MACHINE, a_szKey, KEY_READ))
	{
		if( IsWinNT351() )
		{
			t_fIPEnabled = GetIPInfoNT351( a_pInst, t_Registry ) ;
		}
		else
		{
			t_fIPEnabled = GetIPInfoNT4orBetter( a_pInst, a_szKey, t_Registry, a_rAdapters ) ;
		}

		// DHCP enabled
		t_Registry.GetCurrentKeyValue( _T("EnableDHCP"), t_dwDHCPBool ) ;
		a_pInst->Setbool( _T("DHCPEnabled"), (bool)t_dwDHCPBool ) ;

		if( t_fIPEnabled  )
		{
			// DHCP Leases
			if( t_dwDHCPBool )
			{
				// DHCP LeaseTerminatesTime
				t_Registry.GetCurrentKeyValue( _T("LeaseTerminatesTime"), t_chsValue ) ;
				DWORD t_dwTimeTerm = _ttol( t_chsValue.GetBuffer( 0 ) ) ;

				// DHCP LeaseObtainedTime
				t_Registry.GetCurrentKeyValue( _T("LeaseObtainedTime"), t_chsValue ) ;
				DWORD t_dwTimeObtained = _ttol( t_chsValue.GetBuffer( 0 ) ) ;

				// reflect lease times only if both are valid
				if( t_dwTimeTerm && t_dwTimeObtained )
				{
					a_pInst->SetDateTime( _T("DHCPLeaseExpires"), WBEMTime( t_dwTimeTerm ) ) ;
					a_pInst->SetDateTime( _T("DHCPLeaseObtained"), WBEMTime( t_dwTimeObtained ) ) ;
				}

				// DHCPServer
				t_Registry.GetCurrentKeyValue( _T("DhcpServer"), t_chsValue ) ;
				a_pInst->SetCHString( _T("DHCPServer"), t_chsValue ) ;
			}

			// IP interface metric
            DWORD dwMinMetric = 0xFFFFFFFF;

            int iIndex = GetCAdapterIndexViaInterfaceContext(t_Registry, a_szKey, a_rAdapters);
            _ADAPTER_INFO* pAdapterInfo = NULL;

		    if(( pAdapterInfo = (_ADAPTER_INFO*) a_rAdapters.GetAt(iIndex)) != NULL)
            {
                DWORD dwIPCount = pAdapterInfo->aIPInfo.GetSize();
                if(dwIPCount > 0)
                {
                    for(int n = 0; n < dwIPCount; n++)
                    {
                        _IP_INFO* pIPInfo = (_IP_INFO*) pAdapterInfo->aIPInfo.GetAt(n);
                        if(pIPInfo != NULL)
                        {
                            if(pIPInfo->dwCostMetric < dwMinMetric)
                            {
                                dwMinMetric = pIPInfo->dwCostMetric;
                            }
                        }
                    }
                }
            }


            // If ip is enabled, and we didn't get the metric via the adapter info, try to set the metric from the registry.
			if( t_fIPEnabled )
			{
				DWORD t_dwRegistryInterfaceMetric ;
				
                // Only if we couldn't get the metric from the adapter info then set from the registry.
                if(dwMinMetric == 0xFFFFFFFF)
                {
                    if( ERROR_SUCCESS == t_Registry.GetCurrentKeyValue( RVAL_ConnectionMetric, t_dwRegistryInterfaceMetric ) )
				    {
					    dwMinMetric = t_dwRegistryInterfaceMetric;
				    }
                }
			}

            // Change default value to what the schema specifies.
            if(dwMinMetric == 0xFFFFFFFF)
            {
                dwMinMetric = 1; // default value
            }

			a_pInst->SetDWORD( IP_CONNECTION_METRIC, dwMinMetric ) ;
		}
	}	// end open binding key

	return t_fIPEnabled ;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  BOOL CWin32NetworkAdapterConfig::GetIPInfoNT351(CInstance *a_pInst, CRegistry& rRegistry )

 Description: extracts IP info specific to NT3.51

 Arguments:	a_pInst [IN], rRegistry [IN]
 Returns:	returns TRUE is the protocol has an IP address
 Inputs:
 Outputs:
 Caveats:	This method is used since we are unable to get the required info
			using the default NT extraction method
 Raid:
 History:					  05-Oct-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

BOOL CWin32NetworkAdapterConfig::GetIPInfoNT351(CInstance *a_pInst, CRegistry &a_rRegistry )
{
	BOOL			t_IsEnabled = FALSE ;

	CRegistry		t_Registry ;
	DWORD			t_dwDHCPBool = FALSE ;
	DWORD			t_dwRAS = FALSE ;
	CHStringArray	t_chsIPGateways ;
	CHStringArray	t_chsIPAddresses ;
	CHString		t_chsAddress ;
	CHString		t_chsValue ;
	CHString		t_chsSubnet ;

	// smart ptr
	variant_t		t_vValue ;

	SAFEARRAYBOUND	t_rgsabound[ 1 ] ;
	DWORD			t_dwSize ;
	long			t_ix[ 1 ] ;

	// DHCPEnabled
	a_rRegistry.GetCurrentKeyValue( _T("EnableDHCP"), t_dwDHCPBool ) ;

	// RAS swaps into DHCP IPs and masks
	if( !t_dwDHCPBool )
	{
		CHStringArray t_chsIPAddrs;
		a_rRegistry.GetCurrentKeyValue( _T("IPAddress"), t_chsIPAddrs ) ;

		CHString t_chsIPAddress = t_chsIPAddrs.GetAt( 0 ) ;

		if( t_chsAddress == ZERO_ADDRESS )
		{
			t_dwRAS = TRUE ;
		}
	}

	if ( t_dwDHCPBool )
	{
		a_rRegistry.GetCurrentKeyValue( _T("DhcpDefaultGateway"), t_chsIPGateways ) ;
	}
	else
	{
		a_rRegistry.GetCurrentKeyValue( _T("DefaultGateway"), t_chsIPGateways ) ;
	}

	// load up the gateways
	SAFEARRAY *t_saIPGateways ;
	t_dwSize				= t_chsIPGateways.GetSize() ;
	t_rgsabound->cElements	= t_dwSize;
	t_rgsabound->lLbound	= 0;
	t_ix[0]					= 0 ;

	if( !( t_saIPGateways = SafeArrayCreate( VT_BSTR, 1, t_rgsabound ) ) )
	{
		throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
	}

	V_VT( &t_vValue ) = VT_BSTR | VT_ARRAY; V_ARRAY( &t_vValue ) = t_saIPGateways ;

	for ( int t_i = 0; t_i < t_dwSize ; t_i++ )
	{
		t_ix[ 0 ] = t_i ;
		bstr_t t_bstrBuf( t_chsIPGateways.GetAt( t_i ) ) ;

		SafeArrayPutElement( t_saIPGateways, &t_ix[0], (wchar_t*)t_bstrBuf ) ;
	}

	// finished walking array
	a_pInst->SetVariant( _T("DefaultIPGateway"), t_vValue ) ;

	if ( t_dwDHCPBool || t_dwRAS )
	{
		a_rRegistry.GetCurrentKeyValue( _T("DhcpIPAddress"), t_chsAddress ) ;
		t_chsIPAddresses.Add( t_chsAddress ) ;
	}
	else
	{
		a_rRegistry.GetCurrentKeyValue( _T("IPAddress"), t_chsIPAddresses ) ;
	}

	// load up the IPAddresses
	VariantClear( &t_vValue ) ;

	SAFEARRAY *t_saIPAddresses ;
	t_dwSize = t_chsIPAddresses.GetSize() ;
	t_rgsabound->cElements = t_dwSize ;
	t_rgsabound->lLbound = 0 ;
	t_ix[ 0 ] = 0 ;

	if( !( t_saIPAddresses = SafeArrayCreate( VT_BSTR, 1, t_rgsabound ) ) )
	{
		throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
	}

	V_VT( &t_vValue ) = VT_BSTR | VT_ARRAY; V_ARRAY( &t_vValue ) = t_saIPAddresses ;

	for ( t_i = 0; t_i < t_dwSize ; t_i++ )
	{
		t_ix[ 0 ] = t_i ;
		bstr_t t_bstrBuf( t_chsIPAddresses.GetAt( t_i ) ) ;

		SafeArrayPutElement( t_saIPAddresses, &t_ix[0], (wchar_t*)t_bstrBuf ) ;
	}

	// Enabled if an IP address exists
	if( t_dwSize )
	{
		t_IsEnabled = TRUE ;
	}

	// finished walking array
	a_pInst->SetVariant( _T("IPAddress"), t_vValue ) ;

	CHStringArray t_chsSubnets ;

	if ( t_dwDHCPBool || t_dwRAS )
	{
		a_rRegistry.GetCurrentKeyValue( _T("DhcpSubnetMask"), t_chsSubnet ) ;
		t_chsSubnets.Add( t_chsSubnet ) ;
	}
	else
	{
		a_rRegistry.GetCurrentKeyValue( _T("SubnetMask"), t_chsSubnets ) ;
	}

	// IPSubnets
	VariantClear( &t_vValue ) ;
	SAFEARRAY	*t_saSubnets ;

	t_dwSize = t_chsSubnets.GetSize() ;

	t_rgsabound->cElements = t_dwSize ;
	t_rgsabound->lLbound = 0 ;
	t_ix[ 0 ] = 0 ;

		if( !( t_saSubnets = SafeArrayCreate( VT_BSTR, 1, t_rgsabound ) ) )
	{
		throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
	}

	V_VT( &t_vValue ) = VT_BSTR | VT_ARRAY; V_ARRAY( &t_vValue ) = t_saSubnets;

	for ( t_i = 0; t_i < t_dwSize; t_i++ )
	{
		t_ix[ 0 ] = t_i ;
		bstr_t t_bstrBuf( t_chsSubnets.GetAt( t_i ) ) ;

		SafeArrayPutElement( t_saSubnets, &t_ix[0], (wchar_t*)t_bstrBuf ) ;
	}

	a_pInst->SetVariant( _T("IPSubnet"), t_vValue ) ;

	return t_IsEnabled ;
}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  void CWin32NetworkAdapterConfig::IsInterfaceContextAvailable( CRegistry& rRegistry, CAdapters& rAdapters )

 Description: Extracts IP info specific for NT greater than NT3.51

 Arguments:	 rRegistry [IN], rAdapters [IN]
 Returns:
 Inputs:
 Outputs:	index to the TDI adapter in question,
			-1 if a context binding could not be established.
 Caveats:
 Raid:
 History:					  07-July-1999     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
#define CONTEXT_LIST_LEN	1000


int CWin32NetworkAdapterConfig::GetCAdapterIndexViaInterfaceContext(

CRegistry &a_rRegistry,
LPCTSTR a_szKey,
CAdapters &a_rAdapters )
{
	DWORD	t_dwContextList[ CONTEXT_LIST_LEN ] ;
	int		t_iContextListLen = CONTEXT_LIST_LEN ;

	// extract the IP context(s)
	if( IsWinNT5() )
	{
        //
        // we get the long string of registry path with Interface guid at the
        // end. The sizeof interface guid is 38 so we extract that info as below
        //

        a_szKey = a_szKey + ( _tcslen(a_szKey) - 38 );

        _ADAPTER_INFO *t_pAdapterInfo;
		for( int t_iCtrIndex = 0 ; t_iCtrIndex < a_rAdapters.GetSize() ; t_iCtrIndex++ )
		{
			if( !( t_pAdapterInfo = (_ADAPTER_INFO*) a_rAdapters.GetAt( t_iCtrIndex ) ) )
			{
				continue;
			}

            if(0 == t_pAdapterInfo->Interface.Compare(CHString(a_szKey)))
            {
                return t_iCtrIndex;
            }
		}
        return -1;
	}
	else // NT4
	{
		if( ERROR_SUCCESS == a_rRegistry.GetCurrentKeyValue( _T("IPInterfaceContext"), (DWORD&) t_dwContextList ) )
		{
	     
            t_iContextListLen  = 1;

		    // bind the adapter via the TDI IP context
		    _ADAPTER_INFO *t_pAdapterInfo ;
		    for( int t_iCtrIndex = 0 ; t_iCtrIndex < a_rAdapters.GetSize() ; t_iCtrIndex++ )
		    {
			    if( !( t_pAdapterInfo = (_ADAPTER_INFO*) a_rAdapters.GetAt( t_iCtrIndex ) ) )
			    {
				    continue;
			    }

			    _IP_INFO *t_pIPInfo ;
			    for (int t_iIPIndex = 0 ; t_iIPIndex < t_pAdapterInfo->aIPInfo.GetSize() ; t_iIPIndex++ )
			    {
				    if( !( t_pIPInfo = (_IP_INFO*) t_pAdapterInfo->aIPInfo.GetAt( t_iIPIndex ) ) )
				    {
					    continue;
				    }

				    if( IsContextIncluded( t_pIPInfo->dwContext, &t_dwContextList[ 0 ], t_iContextListLen ) )
				    {
					    // found the adapter
					    return t_iCtrIndex;
				    }
			    }
		    }
		}
	}
	return -1 ;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  BOOL CWin32NetworkAdapterConfig::GetIPInfoNT4orBetter(CInstance *a_pInst, CRegistry& rRegistry,CAdapters& rAdapters )

 Description: Extracts IP info specific for NT greater than NT3.51

 Arguments:	a_pInst [IN], rRegistry [IN], rAdapters [IN]
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:					  05-Oct-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

BOOL CWin32NetworkAdapterConfig::GetIPInfoNT4orBetter(	CInstance *a_pInst,
                                                        LPCTSTR a_szKey, 
														CRegistry &a_rRegistry,
														CAdapters &a_rAdapters )
{
	BOOL t_fIPEnabled = FALSE ;

	int t_iCtrIndex = GetCAdapterIndexViaInterfaceContext( a_rRegistry, a_szKey, a_rAdapters ) ;

	if( -1 != t_iCtrIndex )
	{
		// bind the adapter via the TDI IP context
		_ADAPTER_INFO *t_pAdapterInfo ;

		if( t_pAdapterInfo = (_ADAPTER_INFO*) a_rAdapters.GetAt( t_iCtrIndex ) )
		{
			// this is our adapter
			if( fSetIPBindingInfo( a_pInst, t_pAdapterInfo ) )
			{
				t_fIPEnabled = TRUE ;
			}

			// MAC address
			if(	t_pAdapterInfo->AddressLength )
			{
				// NOTE: the MAC address overrides the address obtained
				// earlier from the adapter driver. In the case of a RAS
				// dialup connection the driver will report something
				// different. We correct for that here by reporting what
				// TDI has.
				CHString t_chsMACAddress ;

				t_chsMACAddress.Format( _T("%02X:%02X:%02X:%02X:%02X:%02X"),
						t_pAdapterInfo->Address[ 0 ], t_pAdapterInfo->Address[ 1 ],
						t_pAdapterInfo->Address[ 2 ], t_pAdapterInfo->Address[ 3 ],
						t_pAdapterInfo->Address[ 4 ], t_pAdapterInfo->Address[ 5 ] ) ;

				a_pInst->SetCHString( _T("MACAddress"), t_chsMACAddress ) ;

				// Override the IPX address using CAdapter's IPX - adapter
				// relationship. A match was previously attempted using the
				// adapter driver's MAC address to bind an IPX address. This
				// may have failed in the RAS case since the driver's MAC address
				// may be wrong. We correct for it here using an IPContext binding
				// to get from the registry to the TDI adapter. This adapter object
				// has knowledge of IPX adapter bindings.
				if( t_pAdapterInfo->IPXEnabled )
				{
					// IPX address
					if(	!t_pAdapterInfo->IPXAddress.IsEmpty() )
						a_pInst->SetCHString( _T("IPXAddress"), t_pAdapterInfo->IPXAddress ) ;
				}
			}

			// found the adapter
			return t_fIPEnabled ;
		}
	}

	// if we are unable to get TDI adapter INFO ...
	// fall back to the old standby - the registry.
	//return GetIPInfoNT351( a_pInst,  a_rRegistry ) ;
	return FALSE ;
}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  void CWin32NetworkAdapterConfig::fSetIPBindingInfo(CInstance *a_pInst, _ADAPTER_INFO* pAdapterInfo )

 Description: Sets IP extracted info from TDI.

 Arguments:	a_pInst [IN], pAdapterInfo [IN]
 Returns:
 Inputs:
 Outputs:
 Caveats:	NT4 or greater
 Raid:
 History:					  05-Oct-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
BOOL CWin32NetworkAdapterConfig::fSetIPBindingInfo( CInstance *a_pInst, _ADAPTER_INFO *a_pAdapterInfo )
{
	BOOL	t_fIsIpEnabled = FALSE ;

	if( !a_pAdapterInfo )
	{
		return FALSE;
	}

	a_pInst->SetCHString( IDS_Description, a_pAdapterInfo->Description ) ;

	// IP address and mask info
	VARIANT			t_vValue;
	SAFEARRAYBOUND	t_rgsabound[ 1 ] ;

	t_rgsabound->lLbound = 0;
	t_rgsabound->cElements = a_pAdapterInfo->aIPInfo.GetSize() ;

	if( t_rgsabound->cElements )
	{
		// if at least one address is available, IP is Enabled.
		// 0.0.0.0 although invalid is used to maintain IP
		t_fIsIpEnabled = TRUE ;

		SAFEARRAY *t_saIPAddresses	= SafeArrayCreate( VT_BSTR, 1, t_rgsabound ) ;
		SAFEARRAY *t_saIPMasks		= SafeArrayCreate( VT_BSTR, 1, t_rgsabound ) ;
		saAutoClean t_acIPAddr( &t_saIPAddresses ) ;	// block scope cleanup
		saAutoClean t_acIPMask( &t_saIPMasks ) ;

		// the addresses come in reverse order
		long lIpOrder = 0;

		// zero-ed ip address
		bstr_t t_bstrIPBuf(L"0.0.0.0") ;

		_IP_INFO *t_pIPInfo;
		for( long t_lIPIndex = t_rgsabound->cElements - 1; t_lIPIndex >= 0; t_lIPIndex-- )
		{
			if( !( t_pIPInfo = (_IP_INFO*) a_pAdapterInfo->aIPInfo.GetAt( t_lIPIndex ) ) )
			{
				continue;
			}

			// if not 0.0.0.0 add it
			if( t_pIPInfo->dwIPAddress )
			{
				// IP address
				bstr_t t_bstrIPBuf( t_pIPInfo->chsIPAddress ) ;
				SafeArrayPutElement( t_saIPAddresses, &lIpOrder, (wchar_t*)t_bstrIPBuf ) ;

				if ( t_pIPInfo->dwIPMask )
				{
					// IP Mask
					bstr_t t_bstrMaskBuf( t_pIPInfo->chsIPMask ) ;
					SafeArrayPutElement( t_saIPMasks, &lIpOrder, (wchar_t*)t_bstrMaskBuf ) ;
				}
				else
				{
					// IP Mask
					SafeArrayPutElement( t_saIPMasks, &lIpOrder, (wchar_t*)t_bstrIPBuf ) ;
				}

				lIpOrder++ ;
			}
            else // bugs 161362 (and 183951 to some extent)
            {
				SafeArrayPutElement( t_saIPAddresses, &lIpOrder, (wchar_t*)t_bstrIPBuf ) ;

				if ( t_pIPInfo->dwIPMask )
				{
					// IP Mask
					bstr_t t_bstrMaskBuf( t_pIPInfo->chsIPMask ) ;
					SafeArrayPutElement( t_saIPMasks, &lIpOrder, (wchar_t*)t_bstrMaskBuf ) ;
				}
				else
				{
					// IP Mask
					SafeArrayPutElement( t_saIPMasks, &lIpOrder, (wchar_t*)t_bstrIPBuf ) ;
				}

				lIpOrder++ ;
            }
		}

		V_VT( &t_vValue) = VT_BSTR | VT_ARRAY; V_ARRAY( &t_vValue ) = t_saIPAddresses ;
		a_pInst->SetVariant(L"IPAddress", t_vValue) ;

		V_VT( &t_vValue) = VT_BSTR | VT_ARRAY; V_ARRAY( &t_vValue) = t_saIPMasks ;
		a_pInst->SetVariant(L"IPSubnet", t_vValue) ;
	}

	// IP gateway info
	t_rgsabound->lLbound = 0;
	t_rgsabound->cElements = a_pAdapterInfo->aGatewayInfo.GetSize() ;

	if( t_rgsabound->cElements )
	{
		SAFEARRAY *t_saGateways = SafeArrayCreate( VT_BSTR, 1, t_rgsabound ) ;
		saAutoClean t_acGateways( &t_saGateways ) ;	// block scope cleanup

		SAFEARRAY *t_saCostMetric = SafeArrayCreate( VT_I4, 1, t_rgsabound ) ;
		saAutoClean t_acCostMetric( &t_saCostMetric ) ;	// block scope cleanup

		_IP_INFO* t_pIPGatewayInfo;
		for( long t_lIPGateway = 0; t_lIPGateway < t_rgsabound->cElements; t_lIPGateway++ )
		{
			if( !( t_pIPGatewayInfo = (_IP_INFO*)a_pAdapterInfo->aGatewayInfo.GetAt( t_lIPGateway ) ) )
			{
				continue;
			}

			bstr_t t_bstrBuf( t_pIPGatewayInfo->chsIPAddress ) ;
			SafeArrayPutElement( t_saGateways, &t_lIPGateway, (wchar_t*)t_bstrBuf ) ;

			if( IsWinNT5() )
			{
				SafeArrayPutElement( t_saCostMetric, &t_lIPGateway, &t_pIPGatewayInfo->dwCostMetric ) ;
			}
		}

		V_VT( &t_vValue ) = VT_BSTR | VT_ARRAY; V_ARRAY( &t_vValue ) = t_saGateways ;
		a_pInst->SetVariant( L"DefaultIPGateway", t_vValue ) ;

		V_VT( &t_vValue ) = VT_I4 | VT_ARRAY; V_ARRAY( &t_vValue ) = t_saCostMetric ;
		a_pInst->SetVariant( L"GatewayCostMetric", t_vValue ) ;
	}

	return t_fIsIpEnabled ;
}


/*******************************************************************
    NAME:       fGetMacAddress

    SYNOPSIS:	retrieves the MAC address from the adapter driver.


    ENTRY:      BYTE* MACAddress[6]		:
				CHString& rDeviceName		:


    HISTORY:
                  08-Aug-1998     Created
********************************************************************/
BOOL CWin32NetworkAdapterConfig::fGetMacAddress( BYTE a_MACAddress[ 6 ], CHString &a_rDeviceName )
{
	BOOL t_fRet = FALSE;

	BOOL t_fCreatedSymLink = fCreateSymbolicLink( a_rDeviceName  ) ;

	SmartCloseHandle t_hMAC;

	try
	{
		//
		// Construct a device name to pass to CreateFile
		//
		CHString t_chsAdapterPathName( _T("\\\\.\\") ) ;
				 t_chsAdapterPathName += a_rDeviceName;

		t_hMAC = CreateFile(
                    TOBSTRT( t_chsAdapterPathName ),
					GENERIC_READ,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					0,
					INVALID_HANDLE_VALUE
					) ;

		do	// breakout
		{
			if( INVALID_HANDLE_VALUE == t_hMAC )
			{
				break ;
			}

			//
			// We successfully opened the driver, format the
			// IOCTL to pass the driver.
			//
			UCHAR       t_OidData[ 4096 ] ;
			NDIS_OID    t_OidCode ;
			DWORD       t_ReturnedCount ;

			// get the supported media types
			t_OidCode = OID_GEN_MEDIA_IN_USE ;

			if( DeviceIoControl(
					t_hMAC,
					IOCTL_NDIS_QUERY_GLOBAL_STATS,
					&t_OidCode,
					sizeof( t_OidCode ),
					t_OidData,
					sizeof( t_OidData ),
					&t_ReturnedCount,
					NULL
					) && ( 4 <= t_ReturnedCount ) )
			{


				// Seek out the media type for MAC address reporting.
				// Since this adapter may support more than one media type we'll use
				// the enumeration preference order. In most all cases only one type
				// will be current.

				_NDIS_MEDIUM *t_pTypes = (_NDIS_MEDIUM*)&t_OidData;
				_NDIS_MEDIUM t_eMedium = t_pTypes[0 ] ;

				for( DWORD t_dwtypes = 1; t_dwtypes < t_ReturnedCount/4; t_dwtypes++ )
				{
					if( t_eMedium > t_pTypes[ t_dwtypes ] )
					{
						t_eMedium = t_pTypes[ t_dwtypes ] ;
					}
				}

				switch( t_eMedium )
				{
					default:
					case NdisMedium802_3:
						t_OidCode = OID_802_3_CURRENT_ADDRESS ;
						break;
					case NdisMedium802_5:
						t_OidCode = OID_802_5_CURRENT_ADDRESS ;
						break;
					case NdisMediumFddi:
						t_OidCode = OID_FDDI_LONG_CURRENT_ADDR ;
						break;
					case NdisMediumWan:
						t_OidCode = OID_WAN_CURRENT_ADDRESS ;
						break;
				}
			}
			else
			{
				t_OidCode = OID_802_3_CURRENT_ADDRESS ;
			}

			if(!DeviceIoControl(
					t_hMAC,
					IOCTL_NDIS_QUERY_GLOBAL_STATS,
					&t_OidCode,
					sizeof( t_OidCode ),
					t_OidData,
					sizeof( t_OidData ),
					&t_ReturnedCount,
					NULL
					) )
			{
				break ;
			}

			if( 6 != t_ReturnedCount )
			{
				break ;
			}

			memcpy( a_MACAddress, &t_OidData, 6 ) ;

			t_fRet = TRUE;

		} while( FALSE ) ;

	}
	catch( ... )
	{
		if( t_fCreatedSymLink )
		{
			fDeleteSymbolicLink( a_rDeviceName  ) ;
		}

		throw ;
	}

	if( t_fCreatedSymLink )
	{
		fDeleteSymbolicLink( a_rDeviceName  ) ;
		t_fCreatedSymLink = FALSE ;
	}

 	return t_fRet ;

}

/*******************************************************************
    NAME:       fCreateSymbolicLink

    SYNOPSIS:	Tests for and creates if necessary a symbolic device link.


    ENTRY:      CHString& rDeviceName		: device name

	NOTES:		Unsupported for Win95

	HISTORY:
                  08-Aug-1998     Created
********************************************************************/
BOOL CWin32NetworkAdapterConfig::fCreateSymbolicLink( CHString &a_rDeviceName )
{
	TCHAR t_LinkName[ 512 ] ;

	// Check to see if the DOS name for the device already exists.
	// Its not created automatically in version 3.1 but may be later.
	//
	if(!QueryDosDevice( TOBSTRT( a_rDeviceName ), (LPTSTR)t_LinkName, sizeof( t_LinkName ) / sizeof( TCHAR ) ) )
	{
		// On any error other than "file not found" return
		if( ERROR_FILE_NOT_FOUND != GetLastError() )
		{
			return FALSE;
		}

		//
		// It doesn't exist so create it.
		//
		CHString t_chsTargetPath = _T("\\Device\\" ) ;
				 t_chsTargetPath += a_rDeviceName ;

		if( !DefineDosDevice( DDD_RAW_TARGET_PATH, TOBSTRT( a_rDeviceName ), TOBSTRT( t_chsTargetPath ) ) )
		{
			return FALSE ;
		}
		return TRUE ;
	}
	return FALSE ;
}

/*******************************************************************
    NAME:       fDeleteSymbolicLink

    SYNOPSIS:	deletes a symbolic device name.


    ENTRY:      CHString& rSymDeviceName	: symbolic device name

	NOTES:		Unsupported for Win95

    HISTORY:
                  08-Aug-1998     Created
********************************************************************/
BOOL CWin32NetworkAdapterConfig::fDeleteSymbolicLink(  CHString &a_rDeviceName )
{
	//
	// The driver wasn't visible in the Win32 name space so we created
	// a link.  Now we have to delete it.
	//
	CHString t_chsTargetPath = _T("\\Device\\" ) ;
			 t_chsTargetPath += a_rDeviceName ;

	if( !DefineDosDevice(
							DDD_RAW_TARGET_PATH |
							DDD_REMOVE_DEFINITION |
							DDD_EXACT_MATCH_ON_REMOVE,
							TOBSTRT( a_rDeviceName ),
							TOBSTRT( t_chsTargetPath ) )
							)
	{
		return FALSE ;
	}
	return TRUE;
}

/*******************************************************************
    NAME:       fGetWinsServers

    SYNOPSIS:	retrieves the WINS Servers from the kernel driver


    ENTRY:      CHString& rDeviceName	:
				CHString& chsPrimary	:
				CHString& chsSecondary  :


    HISTORY:
                  09-Sep-1998     Created
********************************************************************/
// seems that if WINS addresses not specified, NetBT reports 127.0.0.0 so if
// this value is returned, we won't display them
#define LOCAL_WINS_ADDRESS  0x7f000000  // 127.0.0.0


BOOL CWin32NetworkAdapterConfig::fGetWinsServers(	CHString &a_rDeviceName,
													CHString &a_chsPrimary,
													CHString &a_chsSecondary )
{
	BOOL			t_fRet = FALSE ;
	DWORD			t_ReturnedCount ;
	tWINS_ADDRESSES t_oWINs ;

    HANDLE          t_hnbt = INVALID_HANDLE_VALUE;
	BOOL			t_fCreatedSymLink = FALSE ;
	CHString		t_chsDeviceName ;

	try
	{
		t_chsDeviceName = _T("NetBT_") ;
		t_chsDeviceName	+= a_rDeviceName;

		t_fCreatedSymLink = fCreateSymbolicLink( t_chsDeviceName  ) ;

		//
		// Construct a device name to pass to CreateFile
		//
		CHString t_chsNBTAdapterPathName( _T("\\Device\\") ) ;
				 t_chsNBTAdapterPathName += t_chsDeviceName ;

        NTDriverIO myio(const_cast<LPWSTR>(static_cast<LPCWSTR>(t_chsNBTAdapterPathName)));

		do	// breakout
		{
            if((t_hnbt = myio.GetHandle()) == INVALID_HANDLE_VALUE)
            {
                break;
            }

			//
			// We successfully opened the driver, format the
			// IOCTL to pass the driver.
			//
			if( !DeviceIoControl(
					t_hnbt,
					IOCTL_NETBT_GET_WINS_ADDR,
					NULL,
					0,
					&t_oWINs,
					sizeof( t_oWINs ),
					&t_ReturnedCount,
					NULL
					))
			{
				break ;
			}

			// if we get 127.0.0.0 back then convert it to the NULL address.
			// See ASSUMES in function header
			if( t_oWINs.PrimaryWinsServer == LOCAL_WINS_ADDRESS )
			{
				t_oWINs.PrimaryWinsServer = 0 ;
			}

			if( t_oWINs.BackupWinsServer == LOCAL_WINS_ADDRESS )
			{
				t_oWINs.BackupWinsServer = 0;
			}
			DWORD t_ardwIP[ 4 ] ;

			if( t_oWINs.PrimaryWinsServer )
			{
				t_ardwIP[3] =  t_oWINs.PrimaryWinsServer        & 0xff ;
				t_ardwIP[2] = (t_oWINs.PrimaryWinsServer >>  8) & 0xff ;
				t_ardwIP[1] = (t_oWINs.PrimaryWinsServer >> 16) & 0xff ;
				t_ardwIP[0] = (t_oWINs.PrimaryWinsServer >> 24) & 0xff ;

				vBuildIP( t_ardwIP, a_chsPrimary ) ;
			}

			if( t_oWINs.BackupWinsServer )
			{
				t_ardwIP[3] =  t_oWINs.BackupWinsServer	       & 0xff ;
				t_ardwIP[2] = (t_oWINs.BackupWinsServer >>  8) & 0xff ;
				t_ardwIP[1] = (t_oWINs.BackupWinsServer >> 16) & 0xff ;
				t_ardwIP[0] = (t_oWINs.BackupWinsServer >> 24) & 0xff ;

				vBuildIP( t_ardwIP, a_chsSecondary  ) ;
			}

			t_fRet = TRUE;

		} while( FALSE ) ;

	}
	catch( ... )
	{
		if( t_fCreatedSymLink )
		{
			fDeleteSymbolicLink( t_chsDeviceName  ) ;
		}
		throw ;
	}

	if( t_fCreatedSymLink )
	{
		fDeleteSymbolicLink( t_chsDeviceName  ) ;
		t_fCreatedSymLink = FALSE ;
	}
 	return t_fRet ;
}

/*******************************************************************
    NAME:       fSetWinsServers

    SYNOPSIS:	Sets the WINS Servers via the kernel driver


    ENTRY:      CHString& rDeviceName	:
				CHString& chsPrimary	:
				CHString& chsSecondary  :


    HISTORY:
                  09-Sep-1998     Created
********************************************************************/
BOOL CWin32NetworkAdapterConfig::fSetWinsServers(	CHString &a_rDeviceName,
													CHString &a_chsPrimary,
													CHString &a_chsSecondary )
{
	// TODO: This is a post release DCR.
	//		 We'll need to test further what servers are to be updated; DHCP or NCPA overrides.
	//		 Test also for the vulgarities between DNS, DHCP and WINS by comparing active
	//		 updating verses reboot.
	return FALSE ;	// Until then ...
/*

	BOOL				t_fRet = FALSE ;
	DWORD				t_ReturnedCount = 0 ;
	NETBT_SET_WINS_ADDR t_oWINs ;
	DWORD				t_ardwIP[ 4 ] ;

	CHString			t_chsDeviceName ;
	BOOL				t_fCreatedSymLink = FALSE ;
	SmartCloseHandle	t_hnbt;


	try
	{
		if( !fGetNodeNum( a_chsPrimary, t_ardwIP ) )
		{
			t_oWINs.PrimaryWinsAddr = LOCAL_WINS_ADDRESS ;
		}
		else
		{
			t_oWINs.PrimaryWinsAddr = t_ardwIP[ 3 ] |
								  ( ( t_ardwIP[ 2 ] & 0xff ) << 8 )  |
								  ( ( t_ardwIP[ 1 ] & 0xff ) << 16 ) |
								  ( ( t_ardwIP[ 0 ] & 0xff ) << 24 ) ;
		}
		if( !fGetNodeNum( a_chsSecondary, t_ardwIP ) )
		{
			t_oWINs.SecondaryWinsAddr = LOCAL_WINS_ADDRESS ;
		}
		else
		{
			t_oWINs.SecondaryWinsAddr =   t_ardwIP[ 3 ] |
									  ( ( t_ardwIP[ 2 ] & 0xff ) << 8 )  |
									  ( ( t_ardwIP[ 1 ] & 0xff ) << 16 ) |
									  ( ( t_ardwIP[ 0 ] & 0xff ) << 24 ) ;
		}


		t_chsDeviceName = _T("NetBT_") ;
		t_chsDeviceName += a_rDeviceName;

		t_fCreatedSymLink = fCreateSymbolicLink( t_chsDeviceName  ) ;

		//
		// Construct a device name to pass to CreateFile
		//
		CHString t_chsNBTAdapterPathName( _T("\\\\.\\") ) ;
				 t_chsNBTAdapterPathName += t_chsDeviceName;


		t_hnbt = CreateFile(
					TOBSTRT( t_chsNBTAdapterPathName ),
					GENERIC_READ,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					0,
					INVALID_HANDLE_VALUE
					 ) ;

		do	// breakout
		{
			if( INVALID_HANDLE_VALUE == t_hnbt )
			{
				break;
			}

			//
			// We successfully opened the driver, format the
			// IOCTL to pass the driver.
			//
			if( !DeviceIoControl(
					t_hnbt,
					IOCTL_NETBT_SET_WINS_ADDRESS,
					&t_oWINs,
					sizeof( t_oWINs ),
					NULL,
					0,
					&t_ReturnedCount,
					NULL
					))
			{
				break ;
			}
			t_fRet = TRUE;

		} while( FALSE ) ;

	}
	catch( ... )
	{
		if( t_fCreatedSymLink )
		{
			fDeleteSymbolicLink( t_chsDeviceName ) ;
		}

		throw ;
	}

	if( t_fCreatedSymLink )
	{
		fDeleteSymbolicLink( t_chsDeviceName  ) ;
		t_fCreatedSymLink = FALSE ;
	}
 	return t_fRet ;
*/
}


HRESULT CWin32NetworkAdapterConfig::EnumNetAdaptersInNT5(MethodContext *a_pMethodContext, CAdapters &a_rAdapters )
{
	HRESULT				t_hResult = WBEM_S_NO_ERROR ;
	CW2kAdapterEnum		t_oAdapterEnum ;
	CW2kAdapterInstance *t_pAdapterInst ;

	// smart ptr
	CInstancePtr t_pInst ;

	// loop through the W2k identified instances
	for( int t_iCtrIndex = 0 ; t_iCtrIndex < t_oAdapterEnum.GetSize() ; t_iCtrIndex++ )
	{
		if( !( t_pAdapterInst = (CW2kAdapterInstance*) t_oAdapterEnum.GetAt( t_iCtrIndex ) ) )
		{
			continue;
		}

		t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;

		// Drop out nicely if the Instance allocation fails
		if ( NULL != t_pInst )
		{
			// set the index since we will NEVER return to this key
			// the index is the key...for some ungodly reason.
			t_pInst->SetDWORD(IDS_Index, t_pAdapterInst->dwIndex ) ;			

			// We load adapter data here.
			t_hResult = GetNetCardConfigForNT5( t_pAdapterInst,
												t_pInst,
												a_rAdapters ) ;

			if (SUCCEEDED( t_hResult ) )
			{
				t_hResult = t_pInst->Commit() ;
			}
			else
			{
				break ;
			}
		}
	}

	return t_hResult ;
}



HRESULT CWin32NetworkAdapterConfig::GetNetCardConfigForNT5 (	CW2kAdapterInstance *a_pAdapterInst,
																CInstance *a_pInst,
																CAdapters &a_rAdapters )
{
	HRESULT	t_hResult = WBEM_S_NO_ERROR;
	bool	t_fIPXEnabled	= false ;
	bool	t_fIPEnabled	= false ;

	// initialize to false
	a_pInst->Setbool(_T("DHCPEnabled"), false ) ;

	// Retrieve the adapter MAC address
	BYTE t_MACAddress[ 6 ] ;

	if( fGetMacAddress( t_MACAddress, a_pAdapterInst->chsNetCfgInstanceID ) )
	{
		CHString	t_chsMACAddress ;
					t_chsMACAddress.Format( _T("%02X:%02X:%02X:%02X:%02X:%02X"),
											t_MACAddress[ 0 ], t_MACAddress[ 1 ],
											t_MACAddress[ 2 ], t_MACAddress[ 3 ],
											t_MACAddress[ 4 ], t_MACAddress[ 5 ] ) ;

		a_pInst->SetCHString( _T("MACAddress"), t_chsMACAddress ) ;

		// get IPX address for this card, key by mac address
		if( GetIPXAddresses( a_pInst, t_MACAddress ) )
		{
			t_fIPXEnabled = true ;

			// IPX info
			hGetIPXGeneral( a_pInst, a_pAdapterInst->dwIndex ) ;
		}
	}

	//
	GetSettingID( a_pInst, a_pAdapterInst ) ;

	// descriptions
	CHString t_chsCaption( a_pAdapterInst->chsCaption ) ;
	CHString t_chsDescription( a_pAdapterInst->chsDescription ) ;

	// in the event one of the descriptions is missing as with NT5 bld 1991
	if( t_chsDescription.IsEmpty() )
	{
		t_chsDescription = t_chsCaption ;
	}
	else if( t_chsCaption.IsEmpty() )
	{
		t_chsCaption = t_chsDescription ;
	}

	vSetCaption( a_pInst, t_chsCaption, a_pAdapterInst->dwIndex, 8  ) ;
	a_pInst->SetCHString( IDS_Description, t_chsDescription ) ;

	// service name
	a_pInst->SetCHString(_T("ServiceName"), a_pAdapterInst->chsService ) ;


	if( !a_pAdapterInst->chsIpInterfaceKey.IsEmpty() )
	{
		if( GetIPInfoNT( a_pInst, a_pAdapterInst->chsIpInterfaceKey, a_rAdapters ) )
		{
			t_fIPEnabled = true ;

			hGetNtIpSec( a_pInst, a_pAdapterInst->chsIpInterfaceKey ) ;

			// WINS
			hGetWinsW2K(
                a_pInst, 
                a_pAdapterInst->dwIndex,
                a_pAdapterInst->chsRootdevice,
                a_pAdapterInst->chsIpInterfaceKey);

			// DNS
			t_hResult = hGetDNSW2K(
                a_pInst, 
                a_pAdapterInst->dwIndex,
                a_pAdapterInst->chsRootdevice,
                a_pAdapterInst->chsIpInterfaceKey);

			// TCP/IP general
			t_hResult = hGetTcpipGeneral( a_pInst ) ;
		}
	}

	// note the state of the protocols
	a_pInst->Setbool( _T("IPXEnabled"), t_fIPXEnabled ) ;
	a_pInst->Setbool( _T("IPEnabled"), t_fIPEnabled ) ;

    if (!a_pAdapterInst->chsNetCfgInstanceID.IsEmpty())
	{
		do
		{
            HMODULE hIpHlpApi = LoadLibraryEx(L"iphlpapi.dll",0,0);
            if (NULL == hIpHlpApi) break;
            OnDelete<HMODULE,BOOL(__stdcall *)(HMODULE),FreeLibrary> fl(hIpHlpApi);

            DWORD dwErr;
            typedef DWORD (__stdcall * fnGetAdapterIndex )(LPWSTR AdapterName,PULONG IfIndex );	                
            fnGetAdapterIndex GetAdapterIndex_ = (fnGetAdapterIndex)GetProcAddress(hIpHlpApi,"GetAdapterIndex");
            if (NULL == GetAdapterIndex_) break;

            CHString FullAdapterName = L"\\DEVICE\\TCPIP_";
            FullAdapterName += a_pAdapterInst->chsNetCfgInstanceID;
            ULONG AdapterIndex = (ULONG)(-1);
            dwErr = GetAdapterIndex_((LPWSTR)(LPCWSTR)FullAdapterName,&AdapterIndex);
            if (NO_ERROR != dwErr) break;
            a_pInst->SetDWORD(IDS_InterfaceIndex,AdapterIndex) ;
		} while(0);
	}

	return( t_hResult ) ;
}

HRESULT CWin32NetworkAdapterConfig::GetNetAdapterInNT5(CInstance *a_pInst, CAdapters &a_rAdapters )
{
	HRESULT				t_hResult = WBEM_E_NOT_FOUND ;
	CW2kAdapterEnum		t_oAdapterEnum ;
	CW2kAdapterInstance *t_pAdapterInst ;
	DWORD				t_dwTestIndex = 0 ;

	// check the index to see if it is a match
	a_pInst->GetDWORD( _T("Index"), t_dwTestIndex ) ;

	// loop through the W2k identified instances
	for( int t_iCtrIndex = 0 ; t_iCtrIndex < t_oAdapterEnum.GetSize() ; t_iCtrIndex++ )
	{
		if( !( t_pAdapterInst = (CW2kAdapterInstance*) t_oAdapterEnum.GetAt( t_iCtrIndex ) ) )
		{
			continue;
		}

		// match to instance
		if ( t_dwTestIndex != t_pAdapterInst->dwIndex )
		{
			continue ;
		}

		// We load adapter data here.
		t_hResult = GetNetCardConfigForNT5( t_pAdapterInst,
											a_pInst,
											a_rAdapters ) ;
		break;
	}

	return t_hResult ;
}


BOOL CWin32NetworkAdapterConfig::GetIPXAddresses( CInstance *a_pInst, BYTE a_bMACAddress[ 6 ] )
{
	BOOL t_fRet = FALSE ;

	CWsock32Api *t_pwsock32api = (CWsock32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidWsock32Api, NULL);
	if ( t_pwsock32api )
	{
		CHString		t_chsAddress ;
		CHString		t_chsNum ;
		WSADATA			t_wsaData ;
		int				t_cAdapters,
						t_res,
						t_cbOpt  = sizeof( t_cAdapters ),
						t_cbAddr = sizeof( SOCKADDR_IPX  ) ;
		SOCKADDR_IPX	t_Addr ;

		// guarded resource
		SOCKET			t_s = INVALID_SOCKET ;

		if( !t_pwsock32api->WsWSAStartup( 0x0101, &t_wsaData ) )
		{
			try
			{
				// Create IPX socket.
				t_s = t_pwsock32api->Wssocket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX  ) ;

				if( INVALID_SOCKET != t_s )
				{
					// Socket must be bound prior to calling IPX_MAX_ADAPTER_NUM.
					memset( &t_Addr, 0, sizeof( t_Addr ) ) ;
					t_Addr.sa_family = AF_IPX ;

					t_res = t_pwsock32api->Wsbind( t_s, (SOCKADDR*) &t_Addr, t_cbAddr ) ;

					// Get the number of adapters => cAdapters.
					t_res = t_pwsock32api->Wsgetsockopt( (SOCKET) t_s,
										NSPROTO_IPX,
										IPX_MAX_ADAPTER_NUM,
										(char *) &t_cAdapters,
										&t_cbOpt  ) ;

					int t_cIndex = 0 ;

					do
					{
						IPX_ADDRESS_DATA  t_IpxData ;

						memset( &t_IpxData, 0, sizeof( t_IpxData ) ) ;

						// Specify which adapter to check.
						t_IpxData.adapternum = t_cIndex ;
						t_cbOpt = sizeof( t_IpxData  ) ;

						// Get information for the current adapter.
						t_res = t_pwsock32api->Wsgetsockopt( t_s,
											NSPROTO_IPX,
											IPX_ADDRESS,
											(char*) &t_IpxData,
											&t_cbOpt ) ;

						// end of adapter array
						if ( t_res != 0 || t_IpxData.adapternum != t_cIndex )
						{
							break;
						}

						// is this the right adapter?
						bool t_fRightAdapter = true ;

						for( int t_j = 0; t_j < 6; t_j++ )
						{
							if( a_bMACAddress[ t_j ] != t_IpxData.nodenum[ t_j ] )
							{
								t_fRightAdapter = false ;
							}
						}

						if( t_fRightAdapter )
						{
							// IpxData contains the address for the current adapter.
							int t_i;
							for ( t_i = 0; t_i < 4; t_i++ )
							{
								t_chsNum.Format( L"%02X", t_IpxData.netnum[ t_i ] ) ;
								t_chsAddress += t_chsNum ;
							}
							t_chsAddress += _T(":" ) ;

							for ( t_i = 0; t_i < 5; t_i++ )
							{
								t_chsNum.Format( L"%02X", t_IpxData.nodenum[ t_i ] ) ;
								t_chsAddress += t_chsNum ;
							}

							t_chsNum.Format( L"%02X", t_IpxData.nodenum[ t_i ] ) ;
							t_chsAddress += t_chsNum ;

							a_pInst->SetCHString( L"IPXAddress", t_chsAddress ) ;

							t_fRet = true ;

							break;
						}
					}
					while( ++t_cIndex  ) ;

				}

			}
			catch( ... )
			{
				if( INVALID_SOCKET != t_s )
				{
					t_pwsock32api->Wsclosesocket( t_s ) ;
				}
				t_pwsock32api->WsWSACleanup() ;

				throw ;
			}

			if ( t_s != INVALID_SOCKET )
			{
				t_pwsock32api->Wsclosesocket( t_s ) ;
				t_s = INVALID_SOCKET ;
			}

			t_pwsock32api->WsWSACleanup() ;
		}

		CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidWsock32Api, t_pwsock32api);
	}
	return t_fRet ;
}

// max length of REG_MULTI_SZ.
#define MAX_VALUE 132
LONG CWin32NetworkAdapterConfig::ReadRegistryList(	HKEY a_hKey,
													LPCTSTR a_ParameterName,
													DWORD a_NumList[],
													int *a_MaxList )
{
	LONG	t_err ;
	DWORD	t_valueType ;
	BYTE	t_Buffer[ MAX_VALUE ] ;
	DWORD	t_BufferLength = MAX_VALUE ;

	BYTE	*t_pBuffer = t_Buffer ;
	BYTE	*t_pHeapBuffer = NULL ;

	int		t_k = 0 ;

	try
	{
		t_err = RegQueryValueEx(	a_hKey,
									a_ParameterName,
									NULL,
									&t_valueType,
									t_pBuffer,
									&t_BufferLength ) ;

		// then allocate off the heap
		if( t_err == ERROR_MORE_DATA )
		{
			t_pHeapBuffer = new BYTE[ t_BufferLength ] ;

			if( !t_pHeapBuffer )
			{
				throw ;
			}
			t_pBuffer = t_pHeapBuffer ;

			t_err = RegQueryValueEx(a_hKey,
									a_ParameterName,
									NULL,
									&t_valueType,
									t_pBuffer,
									&t_BufferLength ) ;
		}


		if( ( t_err == ERROR_SUCCESS ) && ( t_valueType == REG_MULTI_SZ ) )
		{
			TCHAR* t_NumValue = (TCHAR*) t_pBuffer;

			while( *t_NumValue && ( t_k < ( *a_MaxList ) ) )
			{
				a_NumList[ t_k++ ] = _tcstoul( t_NumValue, NULL, 0 ) ;
				t_NumValue += _tcslen( t_NumValue ) + 1 ;
			}

			*a_MaxList = t_k ;
		}
		else
		{
			*a_MaxList = 0 ;
			t_err = !ERROR_SUCCESS ;
		}

	}
	catch( ... )
	{
		if( t_pHeapBuffer )
		{
			delete t_pHeapBuffer ;
		}

		throw ;
	}

	if( t_pHeapBuffer )
	{
		delete t_pHeapBuffer ;
		t_pHeapBuffer = NULL ;
	}

	return t_err ;
}

//
BOOL CWin32NetworkAdapterConfig::IsContextIncluded( DWORD a_dwContext,
													DWORD a_dwContextList[],
													int a_iContextListLen )
{
	for( int t_i = 0; t_i < a_iContextListLen; t_i++ )
	{
		if( a_dwContext == a_dwContextList[ t_i ] )
		{
			return TRUE;
		}
	}
	return FALSE ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetworkAdapterConfig::RegPutString
 *
 *  DESCRIPTION : Wrapper for RegQueryValueEx for the case where the registry
 *                value is in actuality a REG_MULTI_SZ and we don't
 *                necessarily want all of the strings.
 *
 *  INPUTS      : HKEY   hKey           : opened registry key
 *                char  *pszTarget      : desired entry
 *                char  *pszDestBuffer  : buffer to receive result
 *                DWORD  dwBufferSize   : size of output buffer
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : RegQueryValueEx error/success code
 *
 *  COMMENTS    :
 *
 *****************************************************************************/


LONG CWin32NetworkAdapterConfig::RegPutStringArray(	HKEY a_hKey,
													LPCTSTR a_pszTarget,
													SAFEARRAY &a_strArray,
													TCHAR a_cDelimiter )
{
    LONG	t_lRetCode = ERROR_BADKEY;
	WCHAR	*t_Buffer = NULL ;

	try
	{
		if ( SafeArrayGetDim ( &a_strArray ) == 1 )
		{
			LONG t_Dimension = 1 ;

			LONG t_LowerBound ;
			SafeArrayGetLBound ( &a_strArray, t_Dimension , & t_LowerBound ) ;

			LONG t_UpperBound ;
			SafeArrayGetUBound ( &a_strArray, t_Dimension , &t_UpperBound ) ;

			LONG t_Count = ( t_UpperBound - t_LowerBound ) + 1 ;

			DWORD t_BufferLength = 0 ;

			for ( LONG t_Index = t_LowerBound; t_Index <= t_UpperBound; t_Index++ )
			{
				BSTR t_bstr = NULL ;
				SafeArrayGetElement ( &a_strArray, &t_Index, &t_bstr ) ;

				bstr_t t_bstrElement( t_bstr, FALSE ) ;

				t_BufferLength += t_bstrElement.length() + 1 ;
			}

			t_BufferLength++ ;

			t_Buffer = new WCHAR [ t_BufferLength ] ;
			if( !t_Buffer )
			{
				throw ;
			}

			memset( t_Buffer, 0, sizeof( WCHAR ) * t_BufferLength ) ;

			DWORD t_BufferPos = 0 ;
			for ( t_Index = t_LowerBound; t_Index <= t_UpperBound; t_Index ++ )
			{
				BSTR t_bstr = NULL ;
				SafeArrayGetElement ( &a_strArray, &t_Index, &t_bstr ) ;

				bstr_t t_bstrElement( t_bstr, FALSE ) ;

				CHString t_String ;

				if( t_Index != t_LowerBound && a_cDelimiter )
				{
					t_String += a_cDelimiter;
				}

				t_String += (wchar_t*)t_bstrElement;

				lstrcpyW( &t_Buffer[ t_BufferPos ] , t_String ) ;

				t_BufferPos += t_String.GetLength() + !a_cDelimiter;
			}

			t_Buffer[ t_BufferPos ] = 0 ;

			DWORD t_BufferType ;

			if( NULL == a_cDelimiter )
			{
				t_BufferType = REG_MULTI_SZ ;
			}
			else
			{
				t_BufferType = REG_SZ ;
				t_BufferLength--;
			}

			t_lRetCode = RegSetValueEx(
										a_hKey ,
										a_pszTarget,
										0,
										t_BufferType ,
										( LPBYTE ) t_Buffer,
										t_BufferLength * sizeof( WCHAR ) ) ;
		}

	}
	catch( ... )
	{
		if( t_Buffer )
		{
			delete t_Buffer ;
		}

		throw ;
	}

	if( t_Buffer )
	{
		delete t_Buffer ;
		t_Buffer = NULL;
	}

    return t_lRetCode ;
}

/*******************************************************************
    NAME:       RegPutINTtoStringArray

    SYNOPSIS:   Update the registry with an array of uint converted character strings

    ENTRY:      CRegistry& rRegistry	:
				char* szSubKey			:
				SAFEARRAY** a_Array		:	this is a VT_4 array
				CHString chsFormat		:	output format
				int iMaxOutSize			:	maximum per element output size

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
LONG CWin32NetworkAdapterConfig::RegPutINTtoStringArray(	HKEY a_hKey,
															LPCTSTR a_pszTarget,
															SAFEARRAY *a_strArray,
															CHString& a_chsFormat,
															int a_iMaxOutSize )
 {
    LONG	t_lRetCode = ERROR_BADKEY ;
	WCHAR	*t_Buffer = NULL ;

	try
	{
		if ( SafeArrayGetDim ( a_strArray ) == 1 )
		{
			LONG t_Dimension = 1 ;
			LONG t_LowerBound ;
			LONG t_UpperBound ;

			SafeArrayGetLBound( a_strArray , t_Dimension , & t_LowerBound ) ;
			SafeArrayGetUBound( a_strArray , t_Dimension , & t_UpperBound ) ;

			LONG t_Count = ( t_UpperBound - t_LowerBound ) + 1 ;

			//iMaxOutSize includes space for the NULL after every integer string
			DWORD t_BufferLength = t_Count * ( a_iMaxOutSize ) ;

			//one for the double null at the end
			t_BufferLength++ ;

			t_Buffer = new WCHAR [ t_BufferLength ] ;

			if( !t_Buffer )
			{
				throw ;
			}

			//no need to add the terminating NULL
			memset( (void*) t_Buffer, 0, t_BufferLength * sizeof( WCHAR ) ) ;

			t_BufferLength = 0 ;
			WCHAR *t_ptr = t_Buffer ;

			for ( LONG t_Index = t_LowerBound ; t_Index <= t_UpperBound ; t_Index ++ )
			{
				int t_iElement ;
				SafeArrayGetElement ( a_strArray , &t_Index , &t_iElement ) ;

				CHString t_temp ;
				t_temp.Format( a_chsFormat, t_iElement ) ;

				lstrcpyW( t_ptr, t_temp ) ;

				DWORD t_offset = t_temp.GetLength() + 1 ;

				t_BufferLength	+= t_offset ;
				t_ptr			+= t_offset ;
			}
			t_BufferLength++;	// Double NULL

			DWORD t_BufferType = REG_MULTI_SZ ;

			t_lRetCode = RegSetValueEx(
										a_hKey ,
										a_pszTarget,
										0,
										t_BufferType,
										( LPBYTE ) t_Buffer,
										t_BufferLength * sizeof( WCHAR ) ) ;
		}

	}
	catch( ... )
	{
		if( t_Buffer )
		{
			delete t_Buffer ;
		}

		throw ;
	}

	if( t_Buffer )
	{
		delete t_Buffer ;
		t_Buffer = NULL;
	}

    return t_lRetCode ;
}
/*******************************************************************
    NAME:       RegGetStringArray

    SYNOPSIS:   Retrieve an array of strings from the registry

    ENTRY:      CRegistry& rRegistry	:
				char* szSubKey			:
				SAFEARRAY** a_Array		:

    HISTORY:
                  19-Jul-1998     Created
********************************************************************/

LONG CWin32NetworkAdapterConfig::RegGetStringArray(	CRegistry &a_rRegistry,
													LPCWSTR a_szSubKey,
													SAFEARRAY** a_Array,
													TCHAR a_cDelimiter )
{
	CRegistry		t_Registry ;
	CHString		t_chsTemp ;
	LONG			t_lRetCode ;
	SAFEARRAYBOUND	t_rgsabound[1 ] ;
	DWORD			t_dwSize = 0;
	long			t_ix[ 1 ] ;

	if( NULL == a_cDelimiter )
	{
		CHStringArray t_chsMZArray ;

		if( ERROR_SUCCESS != ( t_lRetCode = a_rRegistry.GetCurrentKeyValue( a_szSubKey, t_chsMZArray ) ) )
		{
			return t_lRetCode ;
		}

		t_dwSize = t_chsMZArray.GetSize( ) ;

		if( t_dwSize )
		{
			t_rgsabound->cElements = t_dwSize ;
			t_rgsabound->lLbound = 0 ;

			if( !( *a_Array = SafeArrayCreate( VT_BSTR, 1, t_rgsabound ) ) )
			{
				throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
			}

			for (int t_i = 0; t_i < t_dwSize; t_i++ )
			{
				t_ix[ 0 ] = t_i;
				bstr_t t_bstrBuf( t_chsMZArray.GetAt( t_i ) );

				SafeArrayPutElement( *a_Array, &t_ix[0], (wchar_t*)t_bstrBuf ) ;
			}
		}
	}
	else
	{
		CHString t_chsArray;
		if( ERROR_SUCCESS != ( t_lRetCode = a_rRegistry.GetCurrentKeyValue( a_szSubKey, t_chsArray ) ) )
		{
			return t_lRetCode;
		}

		int t_iTokLen ;

		// count the elements
		CHString t_strTok = t_chsArray;

		while( TRUE )
		{
			t_iTokLen = t_strTok.Find( a_cDelimiter  ) ;
			if( -1 == t_iTokLen )
				break;

			t_dwSize++ ;
			t_strTok = t_strTok.Mid( t_iTokLen + 1  ) ;
		}

		// may not be t_cDelimiter postpended for a single element
		if(!t_strTok.IsEmpty() )
		{
			t_dwSize++ ;
		}

		if( t_dwSize )
		{
			t_rgsabound->cElements = t_dwSize;
			t_rgsabound->lLbound = 0 ;

			if( !( *a_Array = SafeArrayCreate( VT_BSTR, 1, t_rgsabound ) ) )
			{
				throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
			}

			int t_i = 0 ;
			t_strTok = t_chsArray ;

			do
			{
				t_iTokLen = t_strTok.Find( a_cDelimiter ) ;

				if( -1 != t_iTokLen )
				{
					t_chsTemp = t_strTok.Left( t_iTokLen ) ;
				}
				else
				{
					t_chsTemp = t_strTok ;
				}

				t_ix[ 0 ] = t_i ;
				bstr_t t_bstrBuf( t_chsTemp ) ;

				SafeArrayPutElement( *a_Array, &t_ix[0], (wchar_t*)t_bstrBuf ) ;

				if( -1 == t_iTokLen )
				{
					break;
				}

				t_strTok = t_strTok.Mid( t_iTokLen + 1  ) ;

			} while( ++t_i ) ;
		}
	}
	return t_lRetCode ;
}



/*******************************************************************
    NAME:       RegGetStringArrayEx

    SYNOPSIS:   Retrieve an array of strings from the registry. 
                Checks for comma in string and if present, parses
                based on that.  Otherwise, assumes space based
                parsing.

    ENTRY:      CRegistry& rRegistry	:
				char* szSubKey			:
				SAFEARRAY** a_Array		:

    HISTORY:
                  24-Aug-20008     Created
********************************************************************/

LONG CWin32NetworkAdapterConfig::RegGetStringArrayEx(CRegistry &a_rRegistry,
													LPCWSTR a_szSubKey,
													SAFEARRAY** a_Array )
{
	CRegistry		t_Registry ;
	CHString		t_chsTemp ;
	LONG			t_lRetCode ;
	SAFEARRAYBOUND	t_rgsabound[1 ] ;
	DWORD			t_dwSize = 0;
	long			t_ix[ 1 ] ;
    WCHAR           t_cDelimiter = L',';

	CHString t_chsArray;
	if( ERROR_SUCCESS != ( t_lRetCode = a_rRegistry.GetCurrentKeyValue( a_szSubKey, t_chsArray ) ) )
	{
		return t_lRetCode;
	}

	int t_iTokLen ;

	// count the elements
	CHString t_strTok = t_chsArray;

    // See if we have a comma delimiter...
    if(wcschr(t_strTok, t_cDelimiter) == NULL)
    {
        t_cDelimiter = L' ';
    }

	while( TRUE )
	{
		t_iTokLen = t_strTok.Find( t_cDelimiter  ) ;
		if( -1 == t_iTokLen )
			break;

		t_dwSize++ ;
		t_strTok = t_strTok.Mid( t_iTokLen + 1  ) ;
	}

	// may not be t_cDelimiter postpended for a single element
	if(!t_strTok.IsEmpty() )
	{
		t_dwSize++ ;
	}

	if( t_dwSize )
	{
		t_rgsabound->cElements = t_dwSize;
		t_rgsabound->lLbound = 0 ;

		if( !( *a_Array = SafeArrayCreate( VT_BSTR, 1, t_rgsabound ) ) )
		{
			throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
		}

		int t_i = 0 ;
		t_strTok = t_chsArray ;

		do
		{
			t_iTokLen = t_strTok.Find( t_cDelimiter ) ;

			if( -1 != t_iTokLen )
			{
				t_chsTemp = t_strTok.Left( t_iTokLen ) ;
			}
			else
			{
				t_chsTemp = t_strTok ;
			}

			t_ix[ 0 ] = t_i ;
			bstr_t t_bstrBuf( t_chsTemp ) ;

			SafeArrayPutElement( *a_Array, &t_ix[0], (wchar_t*)t_bstrBuf ) ;

			if( -1 == t_iTokLen )
			{
				break;
			}

			t_strTok = t_strTok.Mid( t_iTokLen + 1  ) ;

		} while( ++t_i ) ;
	}
	return t_lRetCode ;
}


/*******************************************************************
    NAME:       RegGetHEXtoINTArray

    SYNOPSIS:   Retrieve an array of ints converted from HEX strings in the registry.

    ENTRY:      CRegistry& rRegistry	:
				char* szSubKey			:
				SAFEARRAY** a_Array		:

    HISTORY:
                  19-Jul-1998     Created
********************************************************************/

LONG CWin32NetworkAdapterConfig::RegGetHEXtoINTArray(	CRegistry &a_rRegistry,
														LPCTSTR a_szSubKey,
														SAFEARRAY **a_Array )
{
	CRegistry		t_Registry ;
	CHStringArray	t_chsArray ;
	LONG			t_lRetCode ;

	if( ERROR_SUCCESS != ( t_lRetCode = a_rRegistry.GetCurrentKeyValue( TOBSTRT( a_szSubKey ), t_chsArray ) ) )
	{
		return t_lRetCode;
	}

	// walk array adding to the safe array
	SAFEARRAYBOUND	t_rgsabound[ 1 ] ;
	DWORD			t_dwSize ;
	long			t_ix[ 1 ] ;

	t_dwSize = t_chsArray.GetSize() ;
	t_rgsabound->cElements = t_dwSize ;
	t_rgsabound->lLbound = 0 ;

	if( !( *a_Array = SafeArrayCreate( VT_I4, 1, t_rgsabound ) ) )
	{
		throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
	}

	t_ix[ 0 ] = 0 ;

	for ( int t_i = 0; t_i < t_dwSize ; t_i++ )
	{
		t_ix[ 0 ] = t_i ;

		// HEX char to int
		int t_iElement = wcstoul( t_chsArray.GetAt( t_i ), NULL, 16 ) ;

		SafeArrayPutElement( *a_Array, &t_ix[0], &t_iElement ) ;
	}

	return t_lRetCode ;
}

/*******************************************************************
    NAME:       fCreateArrayEntry

    SYNOPSIS:   Adds the string to the array. If the safearray does not exist
				it will be created.

    ENTRY:      SAFEARRAY** a_Array		:
				CHString& chsStr		:
    HISTORY:
                  31-Jul-1998     Created
********************************************************************/

BOOL CWin32NetworkAdapterConfig::fCreateAddEntry( SAFEARRAY **a_Array, CHString &a_chsStr )
{
	if( !*a_Array )
	{

		SAFEARRAYBOUND t_rgsabound[ 1 ] ;
		t_rgsabound->cElements	= 1 ;
		t_rgsabound->lLbound	= 0 ;

		if( !( *a_Array = SafeArrayCreate( VT_BSTR, 1, t_rgsabound ) ) )
		{
			throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
		}
	}

	long	t_ix[ 1 ] ;
			t_ix[ 0 ] = 0;

	bstr_t t_bstrBuf( a_chsStr ) ;

	HRESULT t_hRes = SafeArrayPutElement( *a_Array, &t_ix[0], (wchar_t*)t_bstrBuf ) ;

	if( S_OK != t_hRes )
	{
		return FALSE ;
	}

	return TRUE ;
}

/*******************************************************************
    NAME:       hSetDBPath

    SYNOPSIS:   Set TCP/IP database path
    ENTRY:      CMParms &a_rMParms	:

	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetDBPath( CMParms &a_rMParms )
{


	if ( !a_rMParms.pInParams() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	CRegistry	t_oReg;
	CHString	t_chsSKey =  SERVICES_HOME ;
				t_chsSKey += TCPIP_PARAMETERS ;

	// extract the database path
	CHString t_chsDBPath ;
	if( !a_rMParms.pInParams()->GetCHString( DATA_BASE_PATH, t_chsDBPath ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// registry open
	HRESULT t_hRes = t_oReg.Open( HKEY_LOCAL_MACHINE, t_chsSKey.GetBuffer( 0 ), KEY_WRITE ) ;

	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	// load the registry
	if( ERROR_SUCCESS != t_oReg.SetCurrentKeyValue( RVAL_DB_PATH, t_chsDBPath ) )
	{
		return a_rMParms.hSetResult(E_RET_REGISTRY_FAILURE ) ;
	}

	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;

}

/*******************************************************************
    NAME:       hSetIPUseZero

    SYNOPSIS:   Set IP use zero broadcast
    ENTRY:      CMParms &a_rMParms	:

	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetIPUseZero( CMParms &a_rMParms )
{


	CHString t_chsSKey =  SERVICES_HOME ;
			 t_chsSKey += TCPIP_PARAMETERS ;

	if( fCreateBoolToReg( a_rMParms, t_chsSKey, IP_USE_ZERO_BROADCAST, RVAL_ZERO_BROADCAST ) )
	{
		a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED  ) ;
	}

	return S_OK;

}

/*******************************************************************
    NAME:       hSetArpAlwaysSource

    SYNOPSIS:   Set ARP to transmit ARP queries with source routing on
				token ring networks
    ENTRY:      CMParms &a_rMParms	:

	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetArpAlwaysSource( CMParms &a_rMParms )
{
	// Supported only for the NT4 drop at this time


	CHString t_chsSKey =  SERVICES_HOME ;
			 t_chsSKey += TCPIP_PARAMETERS ;

	if( fCreateBoolToReg( a_rMParms, t_chsSKey, ARP_ALWAYS_SOURCE_ROUTE, RVAL_ARP_ALWAYS_SOURCE ) )
		a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;

	return S_OK ;

}

/*******************************************************************
    NAME:       hSetArpUseEtherSNAP

    SYNOPSIS:   Set TCP/IP to use SNAP
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetArpUseEtherSNAP( CMParms &a_rMParms )
{
	// Supported only for the NT4 drop at this time


	CHString t_chsSKey =  SERVICES_HOME ;
			 t_chsSKey += TCPIP_PARAMETERS ;

	if( fCreateBoolToReg( a_rMParms, t_chsSKey, ARP_USE_ETHER_SNAP, RVAL_USE_SNAP ) )
	{
		a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED  ) ;
	}

	return S_OK;

}

/*******************************************************************
    NAME:       hSetTOS

    SYNOPSIS:   Set default type of service
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetTOS( CMParms &a_rMParms )
{

	if ( !a_rMParms.pInParams() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	CRegistry t_oReg;
	CHString t_chsSKey =  SERVICES_HOME ;
			 t_chsSKey += TCPIP_PARAMETERS ;

	// extract the Default TOS
	DWORD t_dwDefaultTOS = 0 ;
	if( !a_rMParms.pInParams()->GetByte( DEFAULT_TOS, (BYTE&)t_dwDefaultTOS ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}
	// on bogus
	if( 255 < t_dwDefaultTOS )
	{
		return a_rMParms.hSetResult( E_RET_PARAMETER_BOUNDS_ERROR ) ;
	}

	// insure the key is there on open
	HRESULT t_hRes = t_oReg.CreateOpen( HKEY_LOCAL_MACHINE, t_chsSKey.GetBuffer( 0 ) ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	// load the registry entry
	if( ERROR_SUCCESS != t_oReg.SetCurrentKeyValue( RVAL_DEFAULT_TOS, t_dwDefaultTOS ) )
	{
		return a_rMParms.hSetResult(E_RET_REGISTRY_FAILURE ) ;
	}

	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;

}

/*******************************************************************
    NAME:       hSetTTL

    SYNOPSIS:   Set default time to live
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetTTL( CMParms &a_rMParms )
{
	// Supported only for the NT4 drop at this time


	if ( !a_rMParms.pInParams() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	CRegistry t_oReg;
	CHString t_chsSKey =  SERVICES_HOME ;
			 t_chsSKey += TCPIP_PARAMETERS ;

	// extract the Default TTL
	DWORD t_dwDefaultTTL = 0 ;
	if( !a_rMParms.pInParams()->GetByte( DEFAULT_TTL, (BYTE&)t_dwDefaultTTL ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE  ) ;
	}

	// on bogus
	if( 255 < t_dwDefaultTTL  || !t_dwDefaultTTL )
	{
		return a_rMParms.hSetResult( E_RET_PARAMETER_BOUNDS_ERROR ) ;
	}

	// insure the key is there on open
	HRESULT t_hRes = t_oReg.CreateOpen( HKEY_LOCAL_MACHINE, t_chsSKey.GetBuffer( 0 ) ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	// load the registry entry
	if( ERROR_SUCCESS != t_oReg.SetCurrentKeyValue( RVAL_DEFAULT_TTL, t_dwDefaultTTL ) )
	{
		return a_rMParms.hSetResult( E_RET_REGISTRY_FAILURE ) ;
	}

	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;

}

/*******************************************************************
    NAME:       hSetDeadGWDetect

    SYNOPSIS:   Set the dead gateway detect flag
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetDeadGWDetect( CMParms &a_rMParms )
{
	CHString t_chsSKey =  SERVICES_HOME;
			 t_chsSKey += TCPIP_PARAMETERS;

	if( fCreateBoolToReg( a_rMParms, t_chsSKey, ENABLE_DEAD_GW_DETECT, RVAL_DEAD_GW_DETECT ) )
	{
		a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
	}

	return S_OK;
}

/*******************************************************************
    NAME:       hSetPMTUBHDetect

    SYNOPSIS:   Set the black hole detect flag
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetPMTUBHDetect( CMParms &a_rMParms )
{
	CHString t_chsSKey =  SERVICES_HOME ;
			 t_chsSKey += TCPIP_PARAMETERS ;

	if( fCreateBoolToReg( a_rMParms, t_chsSKey, ENABLE_PMTUBH_DETECT, RVAL_BLACK_HOLE_DETECT ) )
	{
		a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
	}

	return S_OK;
}

/*******************************************************************
    NAME:       hSetPMTUDiscovery

    SYNOPSIS:   Set the MTU discovery flag
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetPMTUDiscovery( CMParms &a_rMParms )
{

	CHString t_chsSKey =  SERVICES_HOME;
			 t_chsSKey += TCPIP_PARAMETERS;

	if( fCreateBoolToReg( a_rMParms, t_chsSKey, ENABLE_PMTU_DISCOVERY, RVAL_MTU_DISCOVERY ) )
	{
		a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
	}

	return S_OK;

}

/*******************************************************************
    NAME:       hSetForwardBufMem

    SYNOPSIS:   Set IP forward memory buffer size
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetForwardBufMem( CMParms &a_rMParms )
{

	if ( !a_rMParms.pInParams() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	CRegistry	t_oReg;
	CHString	t_chsSKey =  SERVICES_HOME ;
				t_chsSKey += TCPIP_PARAMETERS ;

	// extract the forward memory buffer size
	DWORD t_dwFMB;
	if( !a_rMParms.pInParams()->GetDWORD( FORWARD_BUFFER_MEMORY, t_dwFMB ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE  ) ;
	}

	// insure the key is there on open
	HRESULT t_hRes = t_oReg.CreateOpen( HKEY_LOCAL_MACHINE, t_chsSKey.GetBuffer( 0 ) ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	// load the registry
	if( ERROR_SUCCESS != t_oReg.SetCurrentKeyValue( RVAL_FORWARD_MEM_BUFF, t_dwFMB ) )
	{
		return a_rMParms.hSetResult( E_RET_REGISTRY_FAILURE ) ;
	}

	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;

}

/*******************************************************************
    NAME:       hSetIGMPLevel

    SYNOPSIS:   Set IP multicasting parm
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetIGMPLevel( CMParms &a_rMParms )
{
	if ( !a_rMParms.pInParams() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	CRegistry	t_oReg;
	CHString	t_chsSKey =  SERVICES_HOME ;
				t_chsSKey += TCPIP_PARAMETERS ;

	// extract the IP multicasting parm
	DWORD t_dwIGMPLevel = 0;
	if( !a_rMParms.pInParams()->GetByte( IGMP_LEVEL, (BYTE&)t_dwIGMPLevel ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE  ) ;
	}

	// test the parameter
	if( 0 != t_dwIGMPLevel && 1 != t_dwIGMPLevel && 2 != t_dwIGMPLevel )
	{
		return a_rMParms.hSetResult( E_RET_PARAMETER_BOUNDS_ERROR ) ;
	}
	// insure the key is there on open
	HRESULT t_hRes = t_oReg.CreateOpen(HKEY_LOCAL_MACHINE, t_chsSKey.GetBuffer( 0 ) ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	// load the registry
	if( ERROR_SUCCESS != t_oReg.SetCurrentKeyValue( RVAL_IGMP_LEVEL, t_dwIGMPLevel ) )
	{
		return a_rMParms.hSetResult( E_RET_REGISTRY_FAILURE ) ;
	}

	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;

}

/*******************************************************************
    NAME:       hSetKeepAliveInt

    SYNOPSIS:   Set the IP keep alive interval
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetKeepAliveInt( CMParms &a_rMParms )
{
	if ( !a_rMParms.pInParams() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	CRegistry	t_oReg;
	CHString	t_chsSKey =  SERVICES_HOME ;
				t_chsSKey += TCPIP_PARAMETERS ;

	// extract the keep alive interval
	DWORD t_dwKeepAliveInterval ;
	if( !a_rMParms.pInParams()->GetDWORD( KEEP_ALIVE_INTERVAL, t_dwKeepAliveInterval ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}
	// test the parameter
	if( !t_dwKeepAliveInterval )
	{
		return a_rMParms.hSetResult( E_RET_PARAMETER_BOUNDS_ERROR ) ;
	}

	// insure the key is there on open
	HRESULT t_hRes = t_oReg.CreateOpen(HKEY_LOCAL_MACHINE, t_chsSKey.GetBuffer( 0 ) ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	// load the registry
	if( ERROR_SUCCESS != t_oReg.SetCurrentKeyValue( RVAL_IP_KEEP_ALIVE_INT, t_dwKeepAliveInterval ) )
	{
		return a_rMParms.hSetResult(E_RET_REGISTRY_FAILURE ) ;
	}

	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;

}

/*******************************************************************
    NAME:       hSetKeepAliveTime

    SYNOPSIS:   Set the IP keep alive interval
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetKeepAliveTime( CMParms &a_rMParms )
{

	if ( !a_rMParms.pInParams() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	CRegistry	t_oReg;
	CHString	t_chsSKey =  SERVICES_HOME ;
				t_chsSKey += TCPIP_PARAMETERS ;

	// extract the keep alive time
	DWORD t_dwKeepAliveTime ;
	if( !a_rMParms.pInParams()->GetDWORD( KEEP_ALIVE_TIME, t_dwKeepAliveTime ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE  ) ;
	}

	// test the parameter
	if( !t_dwKeepAliveTime )
	{
		return a_rMParms.hSetResult( E_RET_PARAMETER_BOUNDS_ERROR ) ;
	}

	// insure the key is there on open
	HRESULT t_hRes = t_oReg.CreateOpen( HKEY_LOCAL_MACHINE, t_chsSKey.GetBuffer( 0 ) ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	// load the registry
	if( ERROR_SUCCESS != t_oReg.SetCurrentKeyValue( RVAL_IP_KEEP_ALIVE_TIME, t_dwKeepAliveTime ) )
	{
		return a_rMParms.hSetResult(E_RET_REGISTRY_FAILURE ) ;
	}

	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;

}

/*******************************************************************
    NAME:       hSetMTU

    SYNOPSIS:   Set the Max Transmission Unit
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetMTU( CMParms &a_rMParms )
{


	if ( !a_rMParms.pInParams() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	CRegistry	t_oReg;
	CHString	t_chsSKey =  SERVICES_HOME ;
				t_chsSKey += TCPIP_PARAMETERS ;

	// extract the MTU
	DWORD t_dwMTU ;
	if( !a_rMParms.pInParams()->GetDWORD( MTU, t_dwMTU ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// test the parameter
	if( 68 > t_dwMTU )
	{
		return a_rMParms.hSetResult( E_RET_PARAMETER_BOUNDS_ERROR ) ;
	}

	// insure the key is there on open
	HRESULT t_hRes = t_oReg.CreateOpen( HKEY_LOCAL_MACHINE, t_chsSKey.GetBuffer( 0 ) ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	// load the registry
	if( ERROR_SUCCESS != t_oReg.SetCurrentKeyValue( RVAL_MTU, t_dwMTU ) )
	{
		return a_rMParms.hSetResult(E_RET_REGISTRY_FAILURE ) ;
	}

	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;

}

/*******************************************************************
    NAME:       hSetNumForwardPkts

    SYNOPSIS:   Set the number of IP forward header packets
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetNumForwardPkts( CMParms &a_rMParms )
{

	if ( !a_rMParms.pInParams() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	CRegistry	t_oReg;
	CHString	t_chsSKey =  SERVICES_HOME ;
				t_chsSKey += TCPIP_PARAMETERS ;

	// extract the number of forward header packets
	DWORD t_dwFHP ;
	if( !a_rMParms.pInParams()->GetDWORD( NUM_FORWARD_PACKETS, t_dwFHP ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// test the parameter
	if( !t_dwFHP )
	{
		return a_rMParms.hSetResult(E_RET_PARAMETER_BOUNDS_ERROR ) ;
	}

	// insure the key is there on open
	HRESULT t_hRes = t_oReg.CreateOpen( HKEY_LOCAL_MACHINE, t_chsSKey.GetBuffer( 0 ) ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	// load the registry
	if( ERROR_SUCCESS != t_oReg.SetCurrentKeyValue( RVAL_NUM_FORWARD_PKTS, t_dwFHP ) )
	{
		return a_rMParms.hSetResult( E_RET_REGISTRY_FAILURE ) ;
	}

	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;

}

/*******************************************************************
    NAME:       hSetTcpMaxConRetrans

    SYNOPSIS:   Set the max connect retransmissions
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetTcpMaxConRetrans( CMParms &a_rMParms )
{



	if ( !a_rMParms.pInParams() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	CRegistry	t_oReg;
	CHString	t_chsSKey =  SERVICES_HOME ;
				t_chsSKey += TCPIP_PARAMETERS ;

	// extract the number of max connect retransmissions
	DWORD t_dwMCR ;
	if( !a_rMParms.pInParams()->GetDWORD( TCP_MAX_CONNECT_RETRANS, t_dwMCR ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE  ) ;
	}

	// insure the key is there on open
	HRESULT t_hRes = t_oReg.CreateOpen(HKEY_LOCAL_MACHINE, t_chsSKey.GetBuffer( 0 ) ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	// load the registry
	if( ERROR_SUCCESS != t_oReg.SetCurrentKeyValue( RVAL_MAX_CON_TRANS, t_dwMCR ) )
	{
		return a_rMParms.hSetResult(E_RET_REGISTRY_FAILURE ) ;
	}

	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;

}

/*******************************************************************
    NAME:       hSetTcpMaxDataRetrans

    SYNOPSIS:   Set the max data retransmissions
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetTcpMaxDataRetrans( CMParms &a_rMParms )
{


	if ( !a_rMParms.pInParams() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	CRegistry	t_oReg;
	CHString	t_chsSKey =  SERVICES_HOME;
				t_chsSKey += TCPIP_PARAMETERS;

	// extract the number of max data retransmissions
	DWORD t_dwMDR ;
	if( !a_rMParms.pInParams()->GetDWORD( TCP_MAX_DATA_RETRANS, t_dwMDR ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE  ) ;
	}

	// insure the key is there on open
	HRESULT t_hRes = t_oReg.CreateOpen( HKEY_LOCAL_MACHINE, t_chsSKey.GetBuffer( 0 ) ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	// load the registry
	if( ERROR_SUCCESS != t_oReg.SetCurrentKeyValue( RVAL_MAX_DATA_TRANS, t_dwMDR ) )
	{
		return a_rMParms.hSetResult(E_RET_REGISTRY_FAILURE ) ;
	}

	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;

}

/*******************************************************************
    NAME:       hSetTcpNumCons

    SYNOPSIS:   Set the max data retransmissions
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetTcpNumCons( CMParms &a_rMParms )
{


	if ( !a_rMParms.pInParams() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	CRegistry	t_oReg;
	CHString	t_chsSKey =  SERVICES_HOME ;
				t_chsSKey += TCPIP_PARAMETERS ;

	// extract the max number of connections
	DWORD t_dwMaxConnections ;
	if( !a_rMParms.pInParams()->GetDWORD( TCP_NUM_CONNECTIONS, t_dwMaxConnections ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// test the parameter
	if( 0xfffffe < t_dwMaxConnections )
	{
		return a_rMParms.hSetResult(E_RET_PARAMETER_BOUNDS_ERROR ) ;
	}

	// insure the key is there on open
	HRESULT t_hRes = t_oReg.CreateOpen( HKEY_LOCAL_MACHINE, t_chsSKey.GetBuffer( 0 ) ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER ;
	}

	// load the registry
	if( ERROR_SUCCESS != t_oReg.SetCurrentKeyValue( RVAL_NUM_CONNECTIONS, t_dwMaxConnections ) )
	{
		return a_rMParms.hSetResult( E_RET_REGISTRY_FAILURE ) ;
	}

	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;

}

/*******************************************************************
    NAME:       hSetTcpUseRFC1122UP

    SYNOPSIS:   Set the RFC1122 urgent pointer value
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetTcpUseRFC1122UP( CMParms &a_rMParms )
{


	CHString t_chsSKey =  SERVICES_HOME;
			 t_chsSKey += TCPIP_PARAMETERS;

	if( fCreateBoolToReg( a_rMParms, t_chsSKey, TCP_USE_RFC1122_URG_PTR, RVAL_RFC_URGENT_PTR ) )
	{
		a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
	}

	return S_OK;

}

/*******************************************************************
    NAME:       hSetTcpWindowSize

    SYNOPSIS:   Set the TCP window size
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetTcpWindowSize( CMParms &a_rMParms )
{


	if ( !a_rMParms.pInParams() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	CRegistry	t_oReg;
	CHString	t_chsSKey =  SERVICES_HOME ;
				t_chsSKey += TCPIP_PARAMETERS ;

	// extract the TCP window size
	DWORD t_dwTCPWindowSize = 0 ;
	if( !a_rMParms.pInParams()->GetWORD( TCP_WINDOW_SIZE, (WORD&)t_dwTCPWindowSize ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// test the parameter
	if( 0xffff < t_dwTCPWindowSize )
		return a_rMParms.hSetResult(E_RET_PARAMETER_BOUNDS_ERROR ) ;

	// insure the key is there on open
	HRESULT t_hRes = t_oReg.CreateOpen(HKEY_LOCAL_MACHINE, t_chsSKey.GetBuffer( 0 ) ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	// load the registry
	if( ERROR_SUCCESS != t_oReg.SetCurrentKeyValue( RVAL_TCP_WINDOW_SIZE, t_dwTCPWindowSize ) )
	{
		return a_rMParms.hSetResult( E_RET_REGISTRY_FAILURE ) ;
	}

	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;

}

/*******************************************************************
    NAME:       fCreateBoolToReg

    SYNOPSIS:   Set a boolean from the Inparms to the registry
				insuring the subkey is created if it is not already there.

    ENTRY:      CMParms &a_rMParms,
				CHString& oSKey,
				LPCTSTR pSource,
				LPCTSTR pTarget

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
BOOL CWin32NetworkAdapterConfig::fCreateBoolToReg(	CMParms &a_rMParms,
													CHString &a_oSKey,
													LPCTSTR a_pSource,
													LPCTSTR a_pTarget )
{
	CRegistry t_oReg;

	// insure the key is there on open
	HRESULT t_hRes = t_oReg.CreateOpen(HKEY_LOCAL_MACHINE, a_oSKey.GetBuffer( 0 ) ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return FALSE;
	}

	return fBoolToReg( a_rMParms, t_oReg, a_pSource, a_pTarget ) ;
}

/*******************************************************************
    NAME:       fBoolToReg

    SYNOPSIS:   Set a boolean from the Inparms to the registry

    ENTRY:      CMParms &a_rMParms,
				Registry& oReg,
				LPCTSTR pSource,
				LPCTSTR pTarget

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
BOOL CWin32NetworkAdapterConfig::fBoolToReg(	CMParms &a_rMParms,
												CRegistry &a_rReg,
												LPCTSTR a_pSource,
												LPCTSTR a_pTarget )
{
	// extract the value
	bool	t_bValue ;
	DWORD	t_dwValue ;
	DWORD	t_dwRes ;

	if( !a_rMParms.pInParams() || !a_rMParms.pInParams()->Getbool( TOBSTRT( a_pSource ), t_bValue ) )
	{
		a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
		return FALSE ;
	}

	// load the registry
	t_dwValue = t_bValue ? 1 : 0 ;

	t_dwRes = a_rReg.SetCurrentKeyValue( TOBSTRT( a_pTarget ), t_dwValue ) ;
	if( fMapResError( a_rMParms, t_dwRes, E_RET_REGISTRY_FAILURE ) )
	{
		return FALSE;
	}

	a_rMParms.hSetResult( E_RET_OK ) ;

	return TRUE;
}

/*******************************************************************
    NAME:       hGetTcpipGeneral

    SYNOPSIS:   Retrieves the TCP/IP misc settings
    ENTRY:      CInstance *a_pInst	:

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/

HRESULT CWin32NetworkAdapterConfig::hGetTcpipGeneral( CInstance *a_pInst )
{
	CRegistry	t_oReg;
	CHString	t_csBindingKey =  SERVICES_HOME ;
				t_csBindingKey += TCPIP_PARAMETERS ;

	// open the registry
	long t_lRes = t_oReg.Open(HKEY_LOCAL_MACHINE, t_csBindingKey.GetBuffer( 0 ), KEY_READ ) ;

	// on error map to WBEM
	HRESULT t_hError = WinErrorToWBEMhResult( t_lRes ) ;
	if( WBEM_S_NO_ERROR != t_hError )
	{
		return t_hError;
	}

	// database path
	CHString t_chsDBPath;

	t_oReg.GetCurrentKeyValue( RVAL_DB_PATH, t_chsDBPath ) ;

	a_pInst->SetCHString(DATA_BASE_PATH, t_chsDBPath ) ;

	// extract the IP use zero source flag
	DWORD t_dwUseZeroBroadcast ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_ZERO_BROADCAST, t_dwUseZeroBroadcast ) )
	{
		a_pInst->Setbool( IP_USE_ZERO_BROADCAST, (bool)t_dwUseZeroBroadcast ) ;
	}

	// extract the Arp always source flag
	DWORD t_dwArpAlwaysSource ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_ARP_ALWAYS_SOURCE, t_dwArpAlwaysSource ) )
	{
		a_pInst->Setbool( ARP_ALWAYS_SOURCE_ROUTE, (bool)t_dwArpAlwaysSource  ) ;
	}

	// extract the Arp SNAP flag
	DWORD t_dwArpUseSNAP ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_USE_SNAP, t_dwArpUseSNAP ) )
	{
		a_pInst->Setbool( ARP_USE_ETHER_SNAP, t_dwArpUseSNAP ) ;
	}

	// extract the Default TOS
	DWORD t_dwDefaultTOS;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_DEFAULT_TOS, t_dwDefaultTOS ) )
	{
		a_pInst->SetByte( DEFAULT_TOS, (BYTE&) t_dwDefaultTOS ) ;
	}

	// extract the default TTL
	DWORD t_dwDefaultTTL ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_DEFAULT_TTL, t_dwDefaultTTL ) )
	{
		a_pInst->SetByte( DEFAULT_TTL, (BYTE)t_dwDefaultTTL ) ;
	}

	// extract the dead gateway detect flag
	DWORD t_dwDGEDetect ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_DEAD_GW_DETECT, t_dwDGEDetect ) )
	{
		a_pInst->Setbool( ENABLE_DEAD_GW_DETECT, (bool)t_dwDGEDetect ) ;
	}

	// extract the black hole detect flag
	DWORD t_dwBHDetect ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_BLACK_HOLE_DETECT, t_dwBHDetect ) )
	{
		a_pInst->Setbool( ENABLE_PMTUBH_DETECT, (bool)t_dwBHDetect ) ;
	}

	// extract the MTU discovery flag
	DWORD t_dwMTUDiscovery ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_MTU_DISCOVERY, t_dwMTUDiscovery ) )
	{
		a_pInst->Setbool( ENABLE_PMTU_DISCOVERY, (bool)t_dwMTUDiscovery ) ;
	}

	// extract the forward memory buffer size
	DWORD t_dwFMB;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_FORWARD_MEM_BUFF, t_dwFMB ) )
	{
		a_pInst->SetDWORD( FORWARD_BUFFER_MEMORY, t_dwFMB ) ;
	}

	// extract the IP multicasting parm
	DWORD t_dwIGMPLevel;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_IGMP_LEVEL, t_dwIGMPLevel ) )
	{
		a_pInst->SetByte( IGMP_LEVEL, (BYTE)t_dwIGMPLevel ) ;
	}

	// extract the keep alive interval
	DWORD t_dwKeepAliveInterval ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_IP_KEEP_ALIVE_INT, t_dwKeepAliveInterval ) )
	{
		a_pInst->SetDWORD( KEEP_ALIVE_INTERVAL, t_dwKeepAliveInterval  ) ;
	}

	// extract the keep alive time
	DWORD t_dwKeepAliveTime ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_IP_KEEP_ALIVE_TIME, t_dwKeepAliveTime ) )
	{
		a_pInst->SetDWORD( KEEP_ALIVE_TIME, t_dwKeepAliveTime ) ;
	}

	// extract the MTU
	DWORD t_dwMTU ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_MTU, t_dwMTU ) )
	{
		a_pInst->SetDWORD( MTU, t_dwMTU ) ;
	}

	// extract the number of forward header packets
	DWORD t_dwFHP ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_NUM_FORWARD_PKTS, t_dwFHP ) )
	{
		a_pInst->SetDWORD( NUM_FORWARD_PACKETS, t_dwFHP ) ;
	}

	// extract the number of max connect retransmissions
	DWORD t_dwMCR ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_MAX_CON_TRANS, t_dwMCR ) )
	{
		a_pInst->SetDWORD( TCP_MAX_CONNECT_RETRANS, t_dwMCR  ) ;
	}

	// extract the number of max data retransmissions
	DWORD t_dwMDR ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_MAX_DATA_TRANS, t_dwMDR ) )
	{
		a_pInst->SetDWORD( TCP_MAX_DATA_RETRANS, t_dwMDR  ) ;
	}

	// extract the max number of connections
	DWORD t_dwMaxConnections ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_NUM_CONNECTIONS, t_dwMaxConnections ) )
	{
		a_pInst->SetDWORD( TCP_NUM_CONNECTIONS, t_dwMaxConnections  ) ;
	}

	// extract the RFE1122 urgent pointer flag
	DWORD t_dwRFC1122 ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_RFC_URGENT_PTR, t_dwRFC1122 ) )
	{
		a_pInst->Setbool( TCP_USE_RFC1122_URG_PTR, (bool)t_dwRFC1122 ) ;
	}

	// extract the TCP window size
	DWORD t_dwTCPWindowSize ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_TCP_WINDOW_SIZE, t_dwTCPWindowSize ) )
	{
		a_pInst->SetWORD( TCP_WINDOW_SIZE, (WORD&)t_dwTCPWindowSize  ) ;
	}
	return S_OK ;
}


/*******************************************************************
    NAME:       hGetIPXGeneral

    SYNOPSIS:   Retrieve from the registry specific IPX info
    ENTRY:      CInstance *a_pInst	:

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/

HRESULT CWin32NetworkAdapterConfig::hGetIPXGeneral( CInstance *a_pInst, DWORD a_dwIndex )
{
	// Open IPX parms from the registry
	CHString t_csIPXParmsBindingKey =  SERVICES_HOME ;
			 t_csIPXParmsBindingKey += IPX ;
			 t_csIPXParmsBindingKey += PARAMETERS ;

	// open the registry
	CRegistry t_oRegIPX ;
	long t_lRes = t_oRegIPX.Open(HKEY_LOCAL_MACHINE, t_csIPXParmsBindingKey.GetBuffer( 0 ), KEY_READ ) ;

	// on error map to WBEM
	HRESULT t_hError = WinErrorToWBEMhResult( t_lRes ) ;
	if( WBEM_S_NO_ERROR != t_hError )
	{
		return t_hError ;
	}

	// Get the virtual network number
	DWORD t_dwNetworkNum = 0 ;
	t_oRegIPX.GetCurrentKeyValue( RVAL_VIRTUAL_NET_NUM, t_dwNetworkNum ) ;

	CHString t_chsVirtualNum;
			 t_chsVirtualNum.Format( _T("%08X"), t_dwNetworkNum ) ;

	// update
	if( !a_pInst->SetCHString( IPX_VIRTUAL_NET_NUM, t_chsVirtualNum ) )
	{
		return WBEM_E_FAILED;
	}

	// Unable to locate MediaType under NT5
	if( !IsWinNT5() )
	{
		 // extract the service name
		CHString t_ServiceName ;
		a_pInst->GetCHString( _T("ServiceName"), t_ServiceName ) ;


		// default media type
		DWORD t_dwMediaType = ETHERNET_MEDIA ;

		// Open adapter specific IPX parms from the registry
		CHString t_csKey =  SERVICES_HOME ;
				 t_csKey += _T("\\" ) ;
				 t_csKey += t_ServiceName ;
				 t_csKey += PARAMETERS ;

		CRegistry t_oRegIPXAdapter ;
		t_lRes = t_oRegIPXAdapter.Open(HKEY_LOCAL_MACHINE, t_csKey.GetBuffer( 0 ), KEY_READ ) ;

		if( ERROR_SUCCESS == t_lRes )
		{
			// Media type
			t_oRegIPXAdapter.GetCurrentKeyValue( RVAL_MEDIA_TYPE, t_dwMediaType ) ;
		}
		else if( REGDB_E_KEYMISSING != t_lRes )
		{
			return WinErrorToWBEMhResult( t_lRes ) ;
		}


		if( !a_pInst->SetDWORD( IPX_MEDIATYPE, t_dwMediaType ) )
		{
			return WBEM_E_FAILED;
		}
	}

	// registry for adapter specific IPX binding
	CHString t_csIPXNetBindingKey ;
	CHString t_chsLink ;
	if( !fGetNtIpxRegAdapterKey( a_dwIndex, t_csIPXNetBindingKey, t_chsLink ) )
	{
		LogErrorMessage(L"Call to fGetNtIpxRegAdapterKey failed");
        return E_RET_OBJECT_NOT_FOUND ;
	}

	SAFEARRAY *t_FrameType	= NULL ;
	SAFEARRAY *t_NetNumber	= NULL ;

	saAutoClean acFrameType( &t_FrameType ) ;	// stack scope cleanup
	saAutoClean acNetNumber( &t_NetNumber ) ;

	CRegistry t_oRegIPXNetDriver ;
	t_lRes = t_oRegIPXNetDriver.Open( HKEY_LOCAL_MACHINE, t_csIPXNetBindingKey.GetBuffer( 0 ), KEY_READ ) ;

	// determine if AUTO frame detection is in place
	BOOL t_bAuto = TRUE;
	if( ERROR_SUCCESS == t_lRes )
	{
		CHStringArray	t_chsArray ;

		if( ERROR_SUCCESS == t_oRegIPXNetDriver.GetCurrentKeyValue( TOBSTRT( RVAL_PKT_TYPE ), t_chsArray ) )
		{
			if( t_chsArray.GetSize()  )
			{
				// HEX char to int
				int t_iElement = wcstoul( t_chsArray.GetAt( 0 ), NULL, 16 ) ;

				// the 1st ( and only ) element will be 255 for AUTO
				if( 255 != t_iElement )
				{
					t_bAuto = FALSE;
				}
			}
		}
	}

	// Collect the frame type / net number pairs
	if( !t_bAuto )
	{
		// Frame type
		RegGetHEXtoINTArray( t_oRegIPXNetDriver, RVAL_PKT_TYPE, &t_FrameType  ) ;

		// network number
		RegGetStringArray( t_oRegIPXNetDriver, RVAL_NETWORK_NUMBER, &t_NetNumber, '\n' ) ;
	}
	// supply defaults
	else
	{
		//default frame type
		SAFEARRAYBOUND t_rgsabound[ 1 ] ;
		long t_ix[ 1 ] ;

		t_rgsabound->cElements = 1 ;
		t_rgsabound->lLbound = 0 ;

		if( !( t_FrameType = SafeArrayCreate( VT_I4, 1, t_rgsabound ) ) )
		{
			throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
		}

		t_ix[ 0 ] = 0 ;

		int t_iElement = AUTO ;

		SafeArrayPutElement( t_FrameType, &t_ix[0], &t_iElement ) ;

		// default network number
		if( !( t_NetNumber = SafeArrayCreate( VT_BSTR, 1, t_rgsabound ) ) )
		{
			throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
		}

		CHString t_chsNULL( _T("") ) ;
		bstr_t t_bstrBuf( t_chsNULL ) ;

		SafeArrayPutElement( t_NetNumber, &t_ix[0], (wchar_t*)t_bstrBuf ) ;
	}

	/* update the instance */

	VARIANT t_vValue;

	// frame type
	V_VT( &t_vValue ) = VT_I4 | VT_ARRAY; V_ARRAY( &t_vValue ) = t_FrameType;
	if( !a_pInst->SetVariant( IPX_FRAMETYPE, t_vValue ) )
	{
		return WBEM_E_FAILED;
	}

	// net number
	V_VT( &t_vValue ) = VT_BSTR | VT_ARRAY; V_ARRAY( &t_vValue ) = t_NetNumber;
	if( !a_pInst->SetVariant( IPX_NETNUMBER, t_vValue ) )
	{
		return WBEM_E_FAILED;
	}
	return S_OK;
}


/*******************************************************************
    NAME:       hSetVirtualNetNum

    SYNOPSIS:   Sets the virtual network number associated with IPX on
				this system

    ENTRY:      CMParms		:

	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetVirtualNetNum( CMParms &a_rMParms )
{

	// Open IPX parms from the registry
	CHString t_csIPXParmsBindingKey =  SERVICES_HOME ;
			 t_csIPXParmsBindingKey += IPX ;
			 t_csIPXParmsBindingKey += PARAMETERS ;

	// registry open
	CRegistry	t_oRegIPX;
	HRESULT		t_hRes = t_oRegIPX.Open( HKEY_LOCAL_MACHINE, t_csIPXParmsBindingKey.GetBuffer( 0 ), KEY_WRITE  ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return a_rMParms.hSetResult( E_RET_IPX_NOT_ENABLED_ON_ADAPTER  ) ;;
	}

	// extract the virtual network number
	CHString t_chsVirtNetNum ;
	if( !a_rMParms.pInParams() || !a_rMParms.pInParams()->GetCHString( IPX_VIRTUAL_NET_NUM, t_chsVirtNetNum ) )
	{
		return a_rMParms.hSetResult( E_RET_INVALID_NETNUM  ) ;
	}

    // validate parameter...
    t_chsVirtNetNum.MakeUpper();
    int t_iLen = t_chsVirtNetNum.GetLength();
    if( t_iLen > 8 || t_iLen == 0)
	{
		return a_rMParms.hSetResult(E_RET_INVALID_NETNUM) ;
	}
    int t_iSpan = wcsspn( (LPCWSTR)t_chsVirtNetNum, L"0123456789ABCDEF" ) ;
	if( t_iLen != t_iSpan )
	{
		return a_rMParms.hSetResult(E_RET_INVALID_NETNUM) ;
	}
	// HEX char to int
	DWORD t_dwVirtNetNum = wcstoul( t_chsVirtNetNum, NULL, 16 ) ;

	// update to the registry
	t_oRegIPX.SetCurrentKeyValue( RVAL_VIRTUAL_NET_NUM, t_dwVirtNetNum ) ;


	E_RET t_eRet = E_RET_OK ;


	{
		// pnp notification
		CNdisApi t_oNdisApi ;
		if( !t_oNdisApi.PnpUpdateIpxGlobal() )
		{
			t_eRet = E_RET_OK_REBOOT_REQUIRED ;
		}
	}


	return a_rMParms.hSetResult( t_eRet ) ;

}

/*******************************************************************
    NAME:       hSetFrameNetPairs

    SYNOPSIS:   Sets the frame type network number pairs for a specific
				IPX associated adapter

    ENTRY:      CMParms		:

	NOTES:		This is a non static, instance dependent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetFrameNetPairs( CMParms &a_rMParms )
{


	// nonstatic method requires an instance
	if( !a_rMParms.pInst() )
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;

	// collect the instance
	GetObject( a_rMParms.pInst() ) ;

	// IPX must be enabled and bound to this adapter
	if( !fIsIPXEnabled( a_rMParms ) )
	{
		return S_OK;
	}

	SAFEARRAY *t_NetNumber	= NULL ;
	saAutoClean acNetNumber( &t_NetNumber ) ;	// stack scope cleanup

	// obtain the index key
	DWORD t_dwIndex ;
	if( !a_rMParms.pInst()->GetDWORD( _T("Index"), t_dwIndex ) )
	{
		return a_rMParms.hSetResult( E_RET_INSTANCE_CALL_FAILED ) ;
	}

	// registry binding
	CHString t_csIPXNetBindingKey ;
	CHString t_chsLink ;
	if( !fGetNtIpxRegAdapterKey( t_dwIndex, t_csIPXNetBindingKey, t_chsLink ) )
	{
		LogErrorMessage(L"Call to fGetNtIpxRegAdapterKey failed");
        return a_rMParms.hSetResult(E_RET_OBJECT_NOT_FOUND ) ;
	}

	// registry open
	CRegistry	t_oRegIPXNetDriver;
	HRESULT		t_hRes = t_oRegIPXNetDriver.Open( HKEY_LOCAL_MACHINE, t_csIPXNetBindingKey.GetBuffer( 0 ), KEY_WRITE ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	//	retrieve the frame type array
	VARIANT t_vFrametype;
	VariantInit( &t_vFrametype ) ;

	if( !a_rMParms.pInParams() || !a_rMParms.pInParams()->GetVariant( IPX_FRAMETYPE, t_vFrametype ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE  ) ;
	}

	if( t_vFrametype.vt != (VT_I4 | VT_ARRAY) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE  ) ;
	}

	//	And the network number array
	if(	!a_rMParms.pInParams() || !a_rMParms.pInParams()->GetStringArray( IPX_NETNUMBER, t_NetNumber ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// validate pairs
	BOOL t_fIsAuto ;
	if( !fValidFrameNetPairs( a_rMParms, t_vFrametype.parray, t_NetNumber, &t_fIsAuto ) )
	{
		return S_OK;
	}

	// update the registry
	if( ERROR_SUCCESS != RegPutStringArray( t_oRegIPXNetDriver, RVAL_NETWORK_NUMBER, *t_NetNumber, NULL ) )
	{
		return a_rMParms.hSetResult( E_RET_REGISTRY_FAILURE ) ;
	}

	//maximum length is 3 characters e.g. "FF\0"
	CHString t_chsFormat( _T("%x") ) ;
	if( ERROR_SUCCESS != RegPutINTtoStringArray(	t_oRegIPXNetDriver,
													RVAL_PKT_TYPE,
													t_vFrametype.parray,
													t_chsFormat,
													3 ) )
	{
		return a_rMParms.hSetResult( E_RET_REGISTRY_FAILURE ) ;
	}

	VariantClear( &t_vFrametype ) ;

	E_RET t_eRet = E_RET_OK ;


	{
		// pnp notification
		CNdisApi t_oNdisApi ;
		if( !t_oNdisApi.PnpUpdateIpxAdapter( t_chsLink, t_fIsAuto ) )
		{
			t_eRet = E_RET_OK_REBOOT_REQUIRED ;
		}
	}


	return a_rMParms.hSetResult( t_eRet ) ;

}

/*******************************************************************
    NAME:       fValidFrameNetPairs

    SYNOPSIS:   Given an array of frame types and net numbers validate
				the series.

    ENTRY:      CMParms &a_rMParms
				SAFEARRAY *t_FrameType
                SAFEARRAY *t_NetNumber

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
BOOL CWin32NetworkAdapterConfig::fValidFrameNetPairs(	CMParms		&a_rMParms,
														SAFEARRAY	*a_FrameType,
														SAFEARRAY	*a_NetNumber,
														BOOL		*a_fIsAuto )
{
    LONG t_lFrameUBound		= 0;
	LONG t_lNetNumUBound	= 0;
	LONG t_lFrameLBound		= 0;
	LONG t_lNetNumLBound	= 0;
    BOOL t_fRet = TRUE;

	if( 1 != SafeArrayGetDim( a_FrameType ) ||
		1 != SafeArrayGetDim( a_NetNumber ))
	{
		a_rMParms.hSetResult( E_RET_FRAME_NETNUM_BOUNDS_ERR ) ;
        t_fRet = FALSE;
	}

    if(t_fRet)
    {
	    // one frame for each net number, minimum of 1 pair
	    if( S_OK != SafeArrayGetLBound( a_NetNumber, 1, &t_lNetNumLBound )	||
	        S_OK != SafeArrayGetUBound( a_NetNumber, 1, &t_lNetNumUBound )	||

		    S_OK != SafeArrayGetLBound( a_FrameType, 1, &t_lFrameLBound )		||
		    S_OK != SafeArrayGetUBound( a_FrameType, 1, &t_lFrameUBound )		||

		    ( t_lFrameUBound - t_lFrameLBound ) != ( t_lNetNumUBound - t_lNetNumLBound ) )
	    {
		    a_rMParms.hSetResult( E_RET_FRAME_NETNUM_BOUNDS_ERR ) ;
		    t_fRet = FALSE ;
	    }
    }

	// more that 4 entries?
    if(t_fRet)
    {
	    if( 4 <= (t_lFrameUBound - t_lFrameLBound) )
	    {
		    a_rMParms.hSetResult( E_RET_FRAME_NETNUM_BOUNDS_ERR ) ;
		    t_fRet = FALSE;
	    }
    }

	*a_fIsAuto = FALSE ;

	// loop through all the frame pairs testing for uniqueness
	// and validity
	for( LONG t_lOuter = t_lNetNumLBound; t_lOuter <= t_lNetNumUBound && t_fRet; t_lOuter++ )
	{
		BSTR t_bstr = NULL ;

		SafeArrayGetElement( a_NetNumber, &t_lOuter, &t_bstr ) ;

		bstr_t t_bstrNetNum( t_bstr, FALSE );

		// Network number test
		int t_iLen  = t_bstrNetNum.length( ) ;
		int t_iSpan = wcsspn( (wchar_t*)t_bstrNetNum, L"0123456789" ) ;
		if( t_iLen != t_iSpan )
		{
			a_rMParms.hSetResult( E_RET_INVALID_NETNUM ) ;
			t_fRet = FALSE ;
		}

        if(t_fRet)
        {
            // Check that the network number is
            // less than or equal to 4294967295
            // (0xFFFFFFFF)...
            if(((LPCWSTR)t_bstrNetNum != NULL) &&
                (wcslen(t_bstrNetNum) <= 10))
            {
                // Using i64 here should prevent any
                // overflow problems, as the check for
                // ten or fewer digits will catch us
                // well before that point...
                __int64 t_i64Tmp = _wtoi64(t_bstrNetNum);
                if(t_i64Tmp > 4294967295)
                {
			        a_rMParms.hSetResult( E_RET_INVALID_NETNUM ) ;
			        t_fRet = FALSE ;
                }
            }
            else
            {
			    a_rMParms.hSetResult( E_RET_INVALID_NETNUM ) ;
			    t_fRet = FALSE ;
            }
        }
        
        if(t_fRet)
        {
		    int		t_iFrameType;
		    LONG	t_lFrameIndex = t_lFrameLBound + ( t_lOuter - t_lNetNumLBound ) ;

		    SafeArrayGetElement( a_FrameType, &t_lFrameIndex, &t_iFrameType ) ;

		    // frame type test
		    if( ( 0 > t_iFrameType ) || ( 3 < t_iFrameType ) )
		    {
			    if( 255 == t_iFrameType )
			    {	//AUTO

				    // clear net number on AUTO detect
				    CHString t_chsZERO( _T("0") ) ;
				    bstr_t t_bstrBuf( t_chsZERO ) ;

				    SafeArrayPutElement( a_NetNumber, &t_lOuter, (wchar_t*)t_bstrBuf ) ;

				    *a_fIsAuto = TRUE ;
			    }
			    else
			    {
				    a_rMParms.hSetResult( E_RET_INVALID_FRAMETYPE ) ;
				    t_fRet = FALSE ;
			    }
		    }

		    // scan for duplicate network numbers
		    for( LONG t_lInner = t_lOuter + 1; t_lInner <= t_lNetNumUBound && t_fRet; t_lInner++ )
		    {
			    BSTR t_bstrtest = NULL ;

			    SafeArrayGetElement( a_NetNumber, &t_lInner, &t_bstrtest ) ;

			    bstr_t t_bstrIPtest( t_bstrtest, FALSE ) ;

			    // duplicate IP test
			    if( t_bstrNetNum == t_bstrIPtest )
			    {
				    a_rMParms.hSetResult( E_RET_DUPLICATE_NETNUM ) ;
				    t_fRet = FALSE ;
			    }
		    }
        }
    }
	return t_fRet ;
}


/*******************************************************************
    NAME:       eIsValidIPandSubnets

    SYNOPSIS:   Given an array of IP addresses and subnet masks, return a boolean
                to indicate whether the addresses are valid or not.

    ENTRY:      SAFEARRAY *t_IpAddressArray - IP addresses
                SAFEARRAY *t_IpMaskArray - Subnet Masks

    HISTORY:
                  19-Jul-1998     Created
********************************************************************/

E_RET CWin32NetworkAdapterConfig::eIsValidIPandSubnets( SAFEARRAY *a_IpAddressArray, SAFEARRAY *a_IpMaskArray )
{
    LONG t_lIP_UBound		= 0;
	LONG t_lMask_UBound		= 0;
	LONG t_lIP_LBound		= 0;
	LONG t_lMask_LBound		= 0;

	if( 1 != SafeArrayGetDim( a_IpAddressArray ) ||
		1 != SafeArrayGetDim( a_IpMaskArray ) )
	{
		return E_RET_INPARM_FAILURE ;
	}

	// get the array bounds
	if( S_OK != SafeArrayGetLBound( a_IpAddressArray, 1, &t_lIP_LBound )	||
		S_OK != SafeArrayGetUBound( a_IpAddressArray, 1, &t_lIP_UBound )	||

	    S_OK != SafeArrayGetLBound( a_IpMaskArray, 1, &t_lMask_LBound )	||
		S_OK != SafeArrayGetUBound( a_IpMaskArray, 1, &t_lMask_UBound ) )
	{
		return E_RET_PARAMETER_BOUNDS_ERROR ;
	}

	LONG t_lIPLen	= t_lIP_UBound - t_lIP_LBound + 1 ;
	LONG t_lMasklen	= t_lMask_UBound - t_lMask_LBound + 1 ;

	// one ip for each mask, minimum of 1 pair
	if( ( t_lIPLen != t_lMasklen ) || !t_lIPLen )
	{
		return E_RET_PARAMETER_BOUNDS_ERROR;
	}

	// loop through all IPs testing for uniqueness
	// and validity against its associated mask
	for( LONG t_lOuter = t_lIP_LBound; t_lOuter <= t_lIP_UBound; t_lOuter++ )
	{
		// collect up a str version of the the IP and Mask @ the lOuter element
		BSTR t_bsIP		= NULL ;
		BSTR t_bsMask	= NULL ;

		SafeArrayGetElement( a_IpAddressArray, &t_lOuter, &t_bsIP ) ;
		bstr_t t_bstrIP( t_bsIP, FALSE ) ;

		LONG t_lMaskIndex = t_lMask_LBound + ( t_lOuter - t_lIP_LBound ) ;

		SafeArrayGetElement( a_IpMaskArray,	&t_lMaskIndex, &t_bsMask ) ;
		bstr_t t_bstrMask( t_bsMask, FALSE ) ;

		// break the IP and Mask into 4 DWORDs
		DWORD t_ardwIP[ 4 ] ;
		if( !fGetNodeNum( CHString( (wchar_t*) t_bstrIP ), t_ardwIP ) )
		{
			return E_RET_IP_INVALID ;
		}

		DWORD t_ardwMask[ 4 ] ;
		if( !fGetNodeNum( CHString( (wchar_t*) t_bstrMask ), t_ardwMask ) )
		{
			return E_RET_IP_MASK_FAILURE ;
		}

		// IP, Mask validity
		E_RET t_eRet ;
		if( t_eRet = eIsValidIPandSubnet( t_ardwIP, t_ardwMask ) )
		{
			return t_eRet ;
		}

		// IP uniqueness across all IPs associated with this adapter
		for( LONG t_lInner = t_lOuter + 1; t_lInner <= t_lIP_UBound; t_lInner++ )
		{
			if( t_lInner > t_lOuter )
			{
				BSTR t_bstrtest = NULL ;

				SafeArrayGetElement( a_IpAddressArray,	&t_lInner, &t_bstrtest  ) ;
				bstr_t t_bstrIPtest( t_bstrtest, FALSE ) ;

				DWORD t_ardwIPtest[ 4 ] ;
				if( !fGetNodeNum( CHString( (wchar_t*) t_bstrIPtest ), t_ardwIPtest ) )
				{
					return E_RET_IP_INVALID ;
				}

				// duplicate IP test
				if( t_ardwIP[ 0 ] == t_ardwIPtest[ 0 ] &&
					t_ardwIP[ 1 ] == t_ardwIPtest[ 1 ] &&
					t_ardwIP[ 2 ] == t_ardwIPtest[ 2 ] &&
					t_ardwIP[ 3 ] == t_ardwIPtest[ 3 ] )
				{
					return E_RET_IP_INVALID ;
				}
			}
		}
	}
	return E_RET_OK ;
}

/*******************************************************************
    NAME:       fGetNodeNum

    SYNOPSIS:   Get an IP Address and return the 4 numbers in the IP address.

    ENTRY:      CHString & strIP - IP Address
                DWORD *dw1, *dw2, *dw3, *dw4 - the 4 numbers in the IP Address

    HISTORY:
                  19-Jul-1998     Created
********************************************************************/

BOOL CWin32NetworkAdapterConfig::fGetNodeNum( CHString &a_strIP, DWORD a_ardw[ 4 ] )
{
    TCHAR	t_DOT = '.' ;
	int		t_iOffSet = 0 ;
	int		t_iTokLen ;

	// string validatation
	if( a_strIP.IsEmpty() )
	{
		return FALSE;
	}

	int t_iLen  = a_strIP.GetLength( ) ;
	int t_iSpan = wcsspn(a_strIP, L"0123456789." ) ;

	if( t_iLen != t_iSpan )
	{
		return FALSE;
	}

	if( t_iLen > MAX_IP_SIZE - 1 )
	{
		return FALSE;
	}

    // Go through each node and get the number value
    for( int t_i = 0; t_i < 4; t_i++ )
	{
		CHString t_strTok( a_strIP.Mid( t_iOffSet ) ) ;

		if( 255 < ( a_ardw[ t_i ] = _wtol( t_strTok ) ) )
		{
			return FALSE;
		}

		t_iTokLen = t_strTok.Find( t_DOT ) ;

		// breakout to avoid the last loop test
		if( 3 == t_i )
		{
			break;
		}

		// too few nodes
		if( -1 == t_iTokLen )
		{
			return FALSE ;
		}

		t_iOffSet += t_iTokLen + 1 ;
	}

	if(-1 != t_iTokLen )
	{
		return FALSE;	// to many nodes
	}
	else
	{
		return TRUE ;
	}
}

/*******************************************************************
    NAME:       eIsValidIPandSubnet

    SYNOPSIS:   Given an IP address and subnet mask, return a boolean
                to indicate whether the addresses are valid or not.

    ENTRY:      DWORD[4] ardwIP - IP addresses
                DWORD[4] ardwMask - Subnet Mask

    HISTORY:
                  19-Jul-1998     Created
********************************************************************/

E_RET CWin32NetworkAdapterConfig::eIsValidIPandSubnet( DWORD a_ardwIP[ 4 ], DWORD a_ardwMask[ 4 ] )
{
    BOOL	t_fReturn = TRUE;

   	// test for contiguous mask
	{
		DWORD t_dwMask = (a_ardwMask[0] << 24) +
						 (a_ardwMask[1] << 16) +
						 (a_ardwMask[2] << 8)  +
						 a_ardwMask[3] ;

		// test for all Net but no Host
		if( 0xffffffff == t_dwMask )
		{
			return E_RET_IP_MASK_FAILURE ;
		}
		// test for all Host but no Net
		else if( 0x00 == t_dwMask )
		{
			return E_RET_IP_MASK_FAILURE ;
		}

		DWORD t_i, t_dwContiguousMask;

		// Find out where the first '1' is in binary going right to left
		t_dwContiguousMask = 0;
		for ( t_i = 0; t_i < sizeof( t_dwMask ) * 8; t_i++ )
		{
			t_dwContiguousMask |= 1 << t_i;

			if( t_dwContiguousMask & t_dwMask )
			{
				break ;
			}
		}

		// At this point, dwContiguousMask is 000...0111...  If we inverse it,
		// we get a mask that can be or'd with dwMask to fill in all of
		// the holes.
		t_dwContiguousMask = t_dwMask | ~t_dwContiguousMask ;

		// If the new mask is different, note it here
		if( t_dwMask != t_dwContiguousMask )
		{
			return E_RET_IP_MASK_FAILURE ;
		}
	}

	DWORD	t_ardwNetID[ 4 ] ;

    INT t_nFirstByte = a_ardwIP[ 0 ] & 0xFF ;

    // setup Net ID
    t_ardwNetID[ 0 ] = a_ardwIP[ 0 ] & a_ardwMask[ 0 ] & 0xFF ;
    t_ardwNetID[ 1 ] = a_ardwIP[ 1 ] & a_ardwMask[ 1 ] & 0xFF ;
    t_ardwNetID[ 2 ] = a_ardwIP[ 2 ] & a_ardwMask[ 2 ] & 0xFF ;
    t_ardwNetID[ 3 ] = a_ardwIP[ 3 ] & a_ardwMask[ 3 ] & 0xFF ;

    // setup Host ID
    DWORD t_ardwHostID[ 4 ] ;

    t_ardwHostID[ 0 ] = a_ardwIP[ 0 ] & ( ~( a_ardwMask[ 0 ] ) & 0xFF ) ;
    t_ardwHostID[ 1 ] = a_ardwIP[ 1 ] & ( ~( a_ardwMask[ 1 ] ) & 0xFF ) ;
    t_ardwHostID[ 2 ] = a_ardwIP[ 2 ] & ( ~( a_ardwMask[ 2 ] ) & 0xFF ) ;
    t_ardwHostID[ 3 ] = a_ardwIP[ 3 ] & ( ~( a_ardwMask[ 3 ] ) & 0xFF ) ;

    // check each case
    if ( ( ( t_nFirstByte & 0xF0 ) == 0xE0 )  || /* Class D */
         ( ( t_nFirstByte & 0xF0 ) == 0xF0 )  || /* Class E */
           ( t_ardwNetID[ 0 ] == 127 ) ||           /* NetID cannot be 127...*/
         ( ( t_ardwNetID[ 0 ] == 0 ) &&            /* netid cannot be 0.0.0.0 */
           ( t_ardwNetID[ 1 ] == 0 ) &&
           ( t_ardwNetID[ 2 ] == 0 ) &&
           ( t_ardwNetID[ 3 ] == 0 )) ||

		  /* netid cannot be equal to sub-net mask */
         ( ( t_ardwNetID[0] == a_ardwMask[ 0 ] ) &&
           ( t_ardwNetID[1] == a_ardwMask[ 1 ] ) &&
           ( t_ardwNetID[2] == a_ardwMask[ 2 ] ) &&
           ( t_ardwNetID[3] == a_ardwMask[ 3 ] )) ||

		  /* hostid cannot be 0.0.0.0 */
         ( ( t_ardwHostID[ 0 ] == 0 ) &&
           ( t_ardwHostID[ 1 ] == 0 ) &&
           ( t_ardwHostID[ 2 ] == 0 ) &&
           ( t_ardwHostID[ 3 ] == 0 ) ) ||

		  /* hostid cannot be 255.255.255.255 */
         ( ( t_ardwHostID[0] == 0xFF ) &&
           ( t_ardwHostID[1] == 0xFF ) &&
           ( t_ardwHostID[2] == 0xFF ) &&
           ( t_ardwHostID[3] == 0xFF ) ) ||

		  /* test for all 255 */
         ( ( a_ardwIP[ 0 ] == 0xFF ) &&
           ( a_ardwIP[ 1 ] == 0xFF ) &&
           ( a_ardwIP[ 2 ] == 0xFF ) &&
           ( a_ardwIP[ 3 ] == 0xFF ) ) )
    {
        return E_RET_IP_INVALID ;
    }

    return E_RET_OK ;
}

/*******************************************************************
    NAME:       fBuildIP

    SYNOPSIS:   Build a valid IP Address from DWORD[4] array

    ENTRY:      DWORD *dw1, *dw2, *dw3, *dw4 - the 4 numbers of the IP Address
				CHString & a_strIP - new IP Address
    HISTORY:
                  31-Jul-1998     Created
********************************************************************/

void CWin32NetworkAdapterConfig::vBuildIP( DWORD a_ardwIP[ 4 ], CHString &a_strIP )
{
	a_strIP.Format(L"%u.%u.%u.%u", a_ardwIP[ 0 ], a_ardwIP[ 1 ], a_ardwIP[ 2 ], a_ardwIP[ 3 ] ) ;
}

/*******************************************************************
    NAME:       hEnableDHCP

    SYNOPSIS:   Enables all DHCP settings supplied supplied with
				the framework method call

    ENTRY:      CMParms, framework return class

  	NOTES:		This is a non static, instance dependent method call

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/

HRESULT CWin32NetworkAdapterConfig::hEnableDHCP( CMParms &a_rMParms )
{

	DWORD t_dwError;

	// nonstatic method requires an instance
	if( !a_rMParms.pInst() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// collect the instance
	GetObject( a_rMParms.pInst() ) ;

	// IP must be enabled and bound to this adapter
	if( !fIsIPEnabled( a_rMParms ) )
	{
		return S_OK;
	}

	// same for DHCP
	t_dwError = dwEnableService( _T("DHCP"), TRUE  ) ;

	if( ERROR_SUCCESS != t_dwError &&
		ERROR_SERVICE_DOES_NOT_EXIST != t_dwError )
	{
        LogErrorMessage2(L"Unable to configure DHCP svc : 0x%x\n", t_dwError);
		return a_rMParms.hSetResult( E_RET_UNABLE_TO_CONFIG_DHCP_SERVICE ) ;
	}

    //call the function to reset to dhcp
    HRESULT t_hReturn =  hConfigDHCP( a_rMParms ) ;

    if (SUCCEEDED(t_hReturn))
    {
        // reset gateways to the default(bug 128101)
        if (!ResetGateways(a_rMParms.pInst()))
        {
            //is now dhcp with old gateways set i.e. possibly not the default for dhcp
            return a_rMParms.hSetResult( E_RET_PARTIAL_COMPLETION ) ;
        }
    }

    return t_hReturn ;

}

/*******************************************************************
    NAME:       hEnableStatic

    SYNOPSIS:

    ENTRY:      CMParms, framework return class

	NOTES:		This is a non static, instance dependent method call

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/

DWORD BuildCSListFromSA(SAFEARRAY * pSA,CHString & CSString )
{
    if (NULL == pSA) return ERROR_INVALID_PARAMETER;
    
    LONG lBound;
    LONG uBound;
    RETURN_ON_ERR(SafeArrayGetLBound(pSA,1,&lBound));
    RETURN_ON_ERR(SafeArrayGetUBound(pSA,1,&uBound));
    LONG iter;
    LONG lCount = 0;
    CSString.Empty();
    for (iter=lBound;iter<=uBound;iter++,lCount++)
    {    
        BSTR bstrIp = NULL;
        RETURN_ON_ERR(SafeArrayGetElement(pSA,&iter,&bstrIp));
        OnDelete<BSTR,void(*)(BSTR),SysFreeString> fm(bstrIp);
        if (lCount) CSString += L",";
        CSString += bstrIp;
    }   
    return NO_ERROR;
}

typedef OnDeleteObj0<IUnknown,ULONG(__stdcall IUnknown:: *)(),&IUnknown::Release> CRelMe;

HRESULT EnableStatic(WCHAR * pGuidAdapter,
                     WCHAR * pIpList,
                     WCHAR * pMaskList)
{
    //DbgPrintfA(0,"BEFORE :  adapter %S\n",pGuidAdapter);

    INetCfg* pNetCfg = NULL;
    RETURN_ON_ERR(CoCreateInstance(CLSID_CNetCfg,NULL,CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,IID_INetCfg,(void**)&pNetCfg));
    CRelMe rmNetCfg(pNetCfg);

    INetCfgLock * pCfgLock = NULL;
    RETURN_ON_ERR(pNetCfg->QueryInterface(IID_INetCfgLock,(void**)&pCfgLock));
    CRelMe rmNetCfgLock(pCfgLock);

    WCHAR * pOwner = NULL;
    RETURN_ON_ERR(pCfgLock->AcquireWriteLock(10,L"cimwin32",&pOwner));
    OnDelete<void*,void(*)(void *),CoTaskMemFree> delstr(pOwner);    
    OnDeleteObj0<INetCfgLock,HRESULT(__stdcall INetCfgLock:: *)(),&INetCfgLock::ReleaseWriteLock> UnlockMe(pCfgLock);

    RETURN_ON_ERR(pNetCfg->Initialize(NULL));
    OnDeleteObj0<INetCfg,HRESULT(__stdcall INetCfg:: *)(),&INetCfg::Uninitialize> UnInitMe(pNetCfg);

    INetCfgClass * pCfgClass = NULL;
    RETURN_ON_ERR(pNetCfg->QueryNetCfgClass(&GUID_DEVCLASS_NETTRANS,IID_INetCfgClass,(void **)&pCfgClass));
    CRelMe rmCfgClass(pCfgClass);

    IEnumNetCfgComponent * pEnumCfgCmp2 = NULL;
    RETURN_ON_ERR(pCfgClass->EnumComponents(&pEnumCfgCmp2));
    CRelMe rmEnumCfgCmp2(pEnumCfgCmp2);

    INetCfgComponent * pComp = NULL;
    RETURN_ON_ERR(pCfgClass->FindComponent(L"MS_TCPIP",&pComp));
    CRelMe rmComp(pComp);

    INetCfgComponentPrivate * pCfgPrivate = NULL;
    RETURN_ON_ERR(pComp->QueryInterface(IID_INetCfgComponentPrivate,(void **)&pCfgPrivate));
    CRelMe rmPriv(pCfgPrivate);
 
    ITcpipProperties * pTcpProp = NULL;
    RETURN_ON_ERR(pCfgPrivate->QueryNotifyObject(IID_ITcpipProperties,(void**)&pTcpProp));
    CRelMe rmTcpProp(pTcpProp);

    GUID GuidAdapter;
    RETURN_ON_ERR(CLSIDFromString(pGuidAdapter,&GuidAdapter));

    REMOTE_IPINFO * pRemInfo = NULL;
    RETURN_ON_ERR(pTcpProp->GetIpInfoForAdapter(&GuidAdapter,&pRemInfo));
    OnDelete<void*,void(*)(void *),CoTaskMemFree> ci(pRemInfo);

    //DbgPrintfA(0,"          EnableDhcp     %08x\n",pRemInfo->dwEnableDhcp);
    //DbgPrintfA(0,"          IpAddrList     %S\n",pRemInfo->pszwIpAddrList);
    //DbgPrintfA(0,"          SubnetMaskList %S\n",pRemInfo->pszwSubnetMaskList);
    //DbgPrintfA(0,"          OptionList     %S\n",pRemInfo->pszwOptionList);

    //DbgPrintfA(0,"SETTING : IPs   %S\n",pIpList);
    //DbgPrintfA(0,"        : Masks %S\n",pMaskList);

    WCHAR * pTrail = L"NoPopupsInPnp=1;";
    int Len = wcslen(pRemInfo->pszwOptionList) + wcslen(pTrail) + 1;
    WCHAR * pNewOpt = (WCHAR *)LocalAlloc(0,sizeof(WCHAR)*Len);
    if (NULL == pNewOpt) return E_OUTOFMEMORY;
    OnDelete<HLOCAL,HLOCAL(*)(HLOCAL),LocalFree> fstring(pNewOpt);
    StringCchCopy(pNewOpt,Len,pRemInfo->pszwOptionList);
    StringCchCat(pNewOpt,Len,pTrail);

    REMOTE_IPINFO RemInfoNew;
    RemInfoNew.dwEnableDhcp = 0;
    RemInfoNew.pszwIpAddrList = pIpList;
    RemInfoNew.pszwSubnetMaskList = pMaskList;
    RemInfoNew.pszwOptionList = pNewOpt;

    RETURN_ON_ERR(pTcpProp->SetIpInfoForAdapter(&GuidAdapter,&RemInfoNew));
    
    HRESULT hr;
    RETURN_ON_ERR(hr = pNetCfg->Apply());

    //
    // maybe here add code to cross check if the addresses actually went to the adapter
    //
    return hr;
}

HRESULT CWin32NetworkAdapterConfig::hEnableStatic( CMParms &a_rMParms )
{


	SAFEARRAY *t_IpAddressArray = NULL ;
	SAFEARRAY *t_IpMaskArray	= NULL ;
    DWORD t_dwError;

	// register for stack scope cleanup of SAFEARRAYs
	saAutoClean acIPAddrs( &t_IpAddressArray ) ;
	saAutoClean acMasks( &t_IpMaskArray ) ;

	// nonstatic method requires an instance
	if( !a_rMParms.pInst() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE  ) ;
	}

	// collect the instance
	GetObject( a_rMParms.pInst() ) ;

	// IP must be enabled and bound to this adapter
	if( !fIsIPEnabled( a_rMParms ) )
	{
		return S_OK ;
	}

	//	retrieve the IP arrays
	if(	!a_rMParms.pInParams() || 
		!a_rMParms.pInParams()->GetStringArray( _T("IpAddress"), t_IpAddressArray ) ||
		!a_rMParms.pInParams()->GetStringArray( _T("SubnetMask"), t_IpMaskArray ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// validate IPs
	// validate addresses...
	E_RET t_eRet ;
	if( t_eRet = eIsValidIPandSubnets( t_IpAddressArray, t_IpMaskArray ) )
	{
		return a_rMParms.hSetResult( t_eRet ) ;
	}

	return hEnableStaticHelper( a_rMParms, t_IpAddressArray, t_IpMaskArray ) ;
}


HRESULT CWin32NetworkAdapterConfig::hEnableStaticHelper(	CMParms &a_rMParms,
													    SAFEARRAY *a_IpArray,
    													SAFEARRAY *a_MaskArray )
{
	DWORD t_dwError = 0 ;

	// get the current DHCP enabled setting
	bool t_fDHCPCurrentlyActive = false ;
	if(	!a_rMParms.pInst()->Getbool( L"DHCPEnabled", t_fDHCPCurrentlyActive) )
	{
		return a_rMParms.hSetResult( E_RET_INSTANCE_CALL_FAILED ) ;
	}

	// obtain the index key
	DWORD t_dwIndex ;
	if( !a_rMParms.pInst()->GetDWORD( _T("Index"), t_dwIndex ) )
	{
		return a_rMParms.hSetResult( E_RET_INSTANCE_CALL_FAILED ) ;
	}

	// retrieve the adapter identifier
	CHString t_chsRegKey ;
	CHString t_chsLink ;
	if( !fGetNtTcpRegAdapterKey( t_dwIndex, t_chsRegKey, t_chsLink ) )
	{
		LogErrorMessage(L"Call to fGetNtTcpRegAdapterKey failed");
        return a_rMParms.hSetResult(E_RET_OBJECT_NOT_FOUND ) ;
	}


    CHString StringIPs;
    CHString StringMasks;
    if (NO_ERROR != BuildCSListFromSA(a_IpArray,StringIPs))
	{
    	    LogErrorMessage(L"Failure converting SAFEARRAY to Comma Separated String of IPs");
	    return a_rMParms.hSetResult( E_RET_INPARM_FAILURE );
	}
	if (NO_ERROR != BuildCSListFromSA(a_MaskArray,StringMasks))
	{
    	LogErrorMessage(L"Failure converting SAFEARRAY to Comma Separated String of Masks");	
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE );
	}

    HRESULT hr = EnableStatic((WCHAR*)(LPCWSTR)t_chsLink,(WCHAR*)(LPCWSTR)StringIPs,(WCHAR*)(LPCWSTR)StringMasks);
	if (NETCFG_S_REBOOT == hr) return a_rMParms.hSetResult(E_RET_OK_REBOOT_REQUIRED);
	if (FAILED(hr)) return a_rMParms.hSetResult((E_RET)hr); //E_RET_UNKNOWN_FAILURE

    a_rMParms.hSetResult(E_RET_OK);
    
    return TO_CALLER;
}

//
// true if the 2 array of strings are the same
//
bool CompareCHStringArray(CHStringArray & left,CHStringArray & right)
{    
    if (right.GetSize() != left.GetSize()) return false;
    if (0 == right.GetSize()) return true;
    int Length = right.GetSize();

    std::vector<CHString> leftArray;
    leftArray.reserve(Length);
    std::vector<CHString> rightArray;  
    rightArray.reserve(Length);    
    int i;
    for ( i=0;i<Length;i++)
    {
        leftArray.push_back(left.ElementAt(i));
        rightArray.push_back(right.ElementAt(i));        
    }

    std::sort(leftArray.begin(),leftArray.end());
    std::sort(rightArray.begin(),rightArray.end());    

    for ( i=0;i<Length;i++)
    {
        if (leftArray[i] != rightArray[i]) return false;
    }

    return true;
}

/*******************************************************************
    NAME:       hConfigDHCP

    SYNOPSIS:	configures DHCP for service on this adapter or if an IP array
				is supplied configures for static addressing

    ENTRY:      CMParms &a_rMParms,					:
				SAFEARRAY * t_IpArray = NULL,		: static if supplied
				SAFEARRAY * t_MaskArray = NULL		: required for static addressing

    HISTORY:
                  23-Jul-1998     Created
				  02-May-1999     updated support for W2k
********************************************************************/


HRESULT CWin32NetworkAdapterConfig::hConfigDHCP(	CMParms &a_rMParms,
													SAFEARRAY *a_IpArray,
													SAFEARRAY *a_MaskArray )
{
	DWORD t_dwError = 0 ;

	// get the current DHCP enabled setting
	bool t_fDHCPCurrentlyActive = false ;
	if(	!a_rMParms.pInst()->Getbool( L"DHCPEnabled", t_fDHCPCurrentlyActive) )
	{
		return a_rMParms.hSetResult( E_RET_INSTANCE_CALL_FAILED ) ;
	}

	// obtain the index key
	DWORD t_dwIndex ;
	if( !a_rMParms.pInst()->GetDWORD( _T("Index"), t_dwIndex ) )
	{
		return a_rMParms.hSetResult( E_RET_INSTANCE_CALL_FAILED ) ;
	}

	// retrieve the adapter identifier
	CHString t_chsRegKey ;
	CHString t_chsLink ;
	if( !fGetNtTcpRegAdapterKey( t_dwIndex, t_chsRegKey, t_chsLink ) )
	{
		LogErrorMessage(L"Call to fGetNtTcpRegAdapterKey failed");
        return a_rMParms.hSetResult(E_RET_OBJECT_NOT_FOUND ) ;
	}

	// force wide char
	bstr_t t_bstrAdapter( t_chsLink ) ;

	// open the registry for update
	CRegistry	t_oRegistry ;

	HRESULT t_hRes = t_oRegistry.CreateOpen(HKEY_LOCAL_MACHINE, t_chsRegKey.GetBuffer( 0 ) ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER ;
	}

	// DHCP and registry update
	DWORD t_dwSysError		= S_OK ;
	E_RET t_eMethodError	= E_RET_OK ;


    CDhcpcsvcApi *t_pdhcpcsvc = (CDhcpcsvcApi*) CResourceManager::sm_TheResourceManager.GetResource( g_guidDhcpcsvcApi, NULL ) ;

	if( !t_pdhcpcsvc )
	{
		throw ;
	}

	if( t_pdhcpcsvc != NULL )
    {
		// Static
		if( a_IpArray )
		{
			int i = 0 ;
			CHStringArray		t_RegIPList ;
			CHStringArray		t_RegMaskList ;

			CDhcpIP_InstructionList t_IP_InstList ;

			// Generate an IP instruction list to feed DhcpNotifyConfigChange
			if( E_RET_OK == (t_eMethodError = t_IP_InstList.BuildStaticIPInstructionList(
											a_rMParms,
											a_IpArray,
											a_MaskArray,
											t_oRegistry,
											t_fDHCPCurrentlyActive ) ) )
			{
				DWORD	t_dwIP[ 4 ] ;
                // We need to first update the registry, then update DHCP, because
                // with Whistler, DHCP now manages static ips as well as dynamic
                // ones, and in doing so, checks the registry for the set of
                // ips to modify.
                
                // Build up registry array...
                for( i = 0; i < t_IP_InstList.GetSize(); i++ )
				{
					CDhcpIP_Instruction *t_pInstruction = (CDhcpIP_Instruction *)t_IP_InstList.GetAt( i ) ;

					fGetNodeNum( t_pInstruction->chsIPAddress, t_dwIP ) ;
				    DWORD t_dwNewIP = ConvertIPDword( t_dwIP ) ;

					fGetNodeNum( t_pInstruction->chsIPMask, t_dwIP ) ;
				    DWORD t_dwNewMask = ConvertIPDword( t_dwIP ) ;
					
					// add to our registry list as we go
					if( t_dwNewIP )
					{
						t_RegIPList.Add( t_pInstruction->chsIPAddress ) ;
						t_RegMaskList.Add( t_pInstruction->chsIPMask ) ;
					}
				}
                
                // update the registry...
                // update successful additions/changes only
			    if( ERROR_SUCCESS != t_oRegistry.SetCurrentKeyValue( _T("IpAddress"), t_RegIPList ) ||
				    ERROR_SUCCESS != t_oRegistry.SetCurrentKeyValue( _T("SubnetMask"), t_RegMaskList ) )
			    {
				    t_eMethodError = E_RET_REGISTRY_FAILURE ;
			    }

			    // new adapter DHCP state
			    DWORD t_dwFALSE = FALSE ;
			    if( ERROR_SUCCESS != t_oRegistry.SetCurrentKeyValue( L"EnableDHCP", t_dwFALSE ) )
			    {
				    t_eMethodError = E_RET_REGISTRY_FAILURE ;
			    }


                // Now notify dhcp...
				for( i = 0; i < t_IP_InstList.GetSize(); i++ )
				{
					CDhcpIP_Instruction *t_pInstruction = (CDhcpIP_Instruction *)t_IP_InstList.GetAt( i ) ;

					fGetNodeNum( t_pInstruction->chsIPAddress, t_dwIP ) ;
				    DWORD t_dwNewIP = ConvertIPDword( t_dwIP ) ;

					fGetNodeNum( t_pInstruction->chsIPMask, t_dwIP ) ;
				    DWORD t_dwNewMask = ConvertIPDword( t_dwIP ) ;

					if( t_pInstruction->bIsNewAddress )
					{
						// notify DHCP
						DWORD t_dwDHCPError = t_pdhcpcsvc->DhcpNotifyConfigChange(
												NULL,
												(wchar_t*)t_bstrAdapter,
												t_pInstruction->bIsNewAddress,
												t_pInstruction->dwIndex,
												t_dwNewIP,
												t_dwNewMask,
												t_pInstruction->eDhcpFlag ) ;

						// if for some reason t_pInstruction->bIsNewAddress is true, 
                        // but dhcp doesn't think so, we'll get this error; however, 
                        // we don't care about it.
                        if( t_dwDHCPError  && 
                            t_dwDHCPError != STATUS_DUPLICATE_OBJECTID)  
						{
							t_dwError = t_dwDHCPError;

							// bypass registry update for this failed
							// IP modification
							continue;
						}
					}
				}
			}
			else
			{
			    // error reporting here ?
			}

			// we have to post back to the NT4 registry area
			// in order to keep existing apps in the field running
			if( IsWinNT5() )
			{

                // validate what we've done so far 
                // get the AdapterName
    			CHStringArray EffectiveRegIPList ;
	    		CHStringArray EffectiveRegMaskList ;

                do 
                {
	                HMODULE hIpHlpApi = LoadLibraryEx(L"iphlpapi.dll",0,0);
	                if (NULL == hIpHlpApi) break;
	                OnDelete<HMODULE,BOOL(__stdcall *)(HMODULE),FreeLibrary> fl(hIpHlpApi);

                    DWORD dwErr;
                    DWORD iter;
	                typedef DWORD (__stdcall * fnGetAdapterIndex )(LPWSTR AdapterName,PULONG IfIndex );	                
                    fnGetAdapterIndex GetAdapterIndex_ = (fnGetAdapterIndex)GetProcAddress(hIpHlpApi,"GetAdapterIndex");
                    if (NULL == GetAdapterIndex_) break;

                    CHString FullAdapterName = L"\\DEVICE\\TCPIP_";
                    FullAdapterName += t_chsLink;
                    ULONG AdapterIndex = (ULONG)(-1);
                    dwErr = GetAdapterIndex_((LPWSTR)(LPCWSTR)FullAdapterName,&AdapterIndex);
                    if (NO_ERROR != dwErr) break;

                    ULONG InterfaceIndex = AdapterIndex;

	                typedef DWORD (__stdcall * fnGetIpAddrTable)(PMIB_IPADDRTABLE pIpAddrTable,PULONG pdwSize,BOOL bOrder);
                    fnGetIpAddrTable GetIpAddrTable_ = (fnGetIpAddrTable)GetProcAddress(hIpHlpApi,"GetIpAddrTable");
                    if (NULL == GetIpAddrTable_) break;

                    ULONG SizeTable = 0;
                    dwErr = GetIpAddrTable_(NULL,&SizeTable,FALSE);
                    if (ERROR_INSUFFICIENT_BUFFER != dwErr) break;
                    MIB_IPADDRTABLE * pMibTable = (MIB_IPADDRTABLE *)LocalAlloc(0,SizeTable);
                    if (NULL == pMibTable) break;
                    OnDelete<HLOCAL,HLOCAL(_stdcall *)(HLOCAL),LocalFree> fm(pMibTable);
                    dwErr = GetIpAddrTable_(pMibTable,&SizeTable,FALSE);
                    if (NO_ERROR != dwErr) break;

                    for (iter = 0;iter < pMibTable->dwNumEntries;iter++)
                    {
                        if (InterfaceIndex == pMibTable->table[iter].dwIndex)
                        {
                            BYTE * pAddr_;
                            WCHAR IpAddrBuff[16]; // 3*4+3+1
                            pAddr_ = (BYTE *)&pMibTable->table[iter].dwAddr;
                            StringCchPrintfW(IpAddrBuff,LENGTH_OF(IpAddrBuff),L"%d.%d.%d.%d",pAddr_[0],pAddr_[1],pAddr_[2],pAddr_[3]);
                            EffectiveRegIPList.Add(IpAddrBuff);

                          	pAddr_ = (BYTE *)&pMibTable->table[iter].dwMask;
                            StringCchPrintfW(IpAddrBuff,LENGTH_OF(IpAddrBuff),L"%d.%d.%d.%d",pAddr_[0],pAddr_[1],pAddr_[2],pAddr_[3]);
                            EffectiveRegMaskList.Add(IpAddrBuff);
                        }
                    }
                    	
                } while (0);

                bool bSameAddrList = CompareCHStringArray(t_RegIPList,EffectiveRegIPList);
                bool bSameMaskList = CompareCHStringArray(t_RegMaskList,EffectiveRegMaskList);

				CRegistry	t_oNT4Reg ;
				CHString	t_csBindingKey = SERVICES_HOME ;
							t_csBindingKey += _T("\\" ) ;
							t_csBindingKey += t_chsLink ;
							t_csBindingKey += PARAMETERS_TCPIP ;

				// insure the key is there on open
				HRESULT t_hRes = t_oNT4Reg.CreateOpen( HKEY_LOCAL_MACHINE, t_csBindingKey.GetBuffer( 0 ) ) ;
				if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
				{
					return TO_CALLER;
				}

				// update successful additions/changes only
				if( ERROR_SUCCESS != t_oNT4Reg.SetCurrentKeyValue( _T("IpAddress"), t_RegIPList ) ||
					ERROR_SUCCESS != t_oNT4Reg.SetCurrentKeyValue( _T("SubnetMask"), t_RegMaskList ) )
				{
					t_eMethodError = E_RET_REGISTRY_FAILURE ;
				}

				// new adapter DHCP state
				DWORD t_dwFALSE = FALSE ;
				if( ERROR_SUCCESS != t_oNT4Reg.SetCurrentKeyValue( L"EnableDHCP", t_dwFALSE ) )
				{
					t_eMethodError = E_RET_REGISTRY_FAILURE ;
				}

				if ((!bSameAddrList || !bSameMaskList) && E_RET_OK == t_eMethodError)
				{
					t_eMethodError = E_RET_OK_REBOOT_REQUIRED;
				}
			}
		}

		/* Static -> DHCP */
		else if( !t_fDHCPCurrentlyActive && !a_IpArray )
		{
			// update registry
			CHStringArray t_chsaZERO ;
			CHStringArray t_chsaFF ;

			CHString t_chsZERO( ZERO_ADDRESS ) ;
			CHString t_chsFF( FF_ADDRESS ) ;

			t_chsaZERO.Add( t_chsZERO ) ;
			t_chsaFF.Add( t_chsFF ) ;

			if( ERROR_SUCCESS != t_oRegistry.SetCurrentKeyValue( L"IpAddress", t_chsaZERO )	||
				ERROR_SUCCESS != t_oRegistry.SetCurrentKeyValue( L"SubnetMask", t_chsaFF )	||
				ERROR_SUCCESS != t_oRegistry.SetCurrentKeyValue( L"DhcpIPAddress", t_chsZERO )	||
				ERROR_SUCCESS != t_oRegistry.SetCurrentKeyValue( L"DhcpSubnetMask", t_chsFF ) )
			{
				t_eMethodError = E_RET_REGISTRY_FAILURE ;
			}
			else
			{
				// notify DHCP
				if( !(t_dwError = t_pdhcpcsvc->DhcpNotifyConfigChange(	NULL,
																	(wchar_t*) t_bstrAdapter,
																	FALSE,
																	0,
																	0,
																	0,
																	DhcpEnable ) )  )
				{

					// new adapter DHCP state
					DWORD t_dwTRUE = TRUE ;
					if( ERROR_SUCCESS != t_oRegistry.SetCurrentKeyValue( L"EnableDHCP", t_dwTRUE ) )
					{
						t_eMethodError = E_RET_REGISTRY_FAILURE ;
					}
				}
			}
		}


        CResourceManager::sm_TheResourceManager.ReleaseResource( g_guidDhcpcsvcApi, t_pdhcpcsvc ) ;
        t_pdhcpcsvc = NULL;
    }

	// map any error
	if( t_dwError && fMapResError( a_rMParms, t_dwError, E_RET_UNABLE_TO_CONFIG_DHCP_SERVICE ) )
	{
        LogErrorMessage2(L"Unable to configure DHCP svc : 0x%x\n", t_dwError);
		return TO_CALLER ;
	}

	//
	if( E_RET_OK == t_eMethodError )
	{
		// if DHCP -> Static
		if( a_IpArray && t_fDHCPCurrentlyActive )
		{
			// switch to Netbios over TCP if NetBios was enabled via DHCP
			// ( to be consistant with NT Raid 206974 )
			DWORD t_dwNetBiosOptions ;
			if( a_rMParms.pInst()->GetDWORD( TCPIP_NETBIOS_OPTIONS,
									t_dwNetBiosOptions ) )
			{
				if( UNSET_Netbios == t_dwNetBiosOptions )
				{
					t_eMethodError = eSetNetBiosOptions( ENABLE_Netbios, t_dwIndex ) ;
				}
			}
		}

		// DNS notification
		DWORD t_dwError = dwSendServiceControl( L"Dnscache", SERVICE_CONTROL_PARAMCHANGE ) ;

		// map any error
		if( t_dwError && fMapResError( a_rMParms, t_dwError, E_RET_UNABLE_TO_NOTIFY_DNS_SERVICE ) )
		{
			return TO_CALLER ;
		}
	}

	return a_rMParms.hSetResult( t_eMethodError ) ;

}


/*******************************************************************
    NAME:       fCleanDhcpReg

    SYNOPSIS:	cleans out the DHCP registry entries no longer needed
				when enabling for static addressing

    ENTRY:      CHString& ServiceName

    HISTORY:
                  13-Oct-1998     Created
********************************************************************/

BOOL CWin32NetworkAdapterConfig::fCleanDhcpReg( CHString &t_chsLink )
{
	// open the registry for update
	CRegistry	t_oReg,
				t_RegOptionPath ;
	CHString	t_csOptKey ;
	CHString	t_csKey =  SERVICES_HOME ;
				t_csKey += DHCP ;
				t_csKey += PARAMETERS ;
				t_csKey += OPTIONS ;

	if( ERROR_SUCCESS == t_oReg.OpenAndEnumerateSubKeys( HKEY_LOCAL_MACHINE, t_csKey, KEY_READ ) )
	{
		// Walk through each instance under this key.
		while (	( ERROR_SUCCESS == t_oReg.GetCurrentSubKeyPath( t_csOptKey )))
		{
			CHString t_chsLocation ;
			if( ERROR_SUCCESS ==
				t_RegOptionPath.OpenLocalMachineKeyAndReadValue( t_csOptKey, L"RegLocation", t_chsLocation ) )
			{
				int t_iToklen = t_chsLocation.Find('?' ) ;

				if( -1 != t_iToklen )
				{
					CHString t_chsDelLocation;
							 t_chsDelLocation  = t_chsLocation.Left( t_iToklen ) ;
							 t_chsDelLocation += t_chsLink;
							 t_chsDelLocation += t_chsLocation.Mid( t_iToklen + 1 ) ;

					fDeleteValuebyPath( t_chsDelLocation  ) ;
				}
			}
			t_oReg.NextSubKey() ;
		}

		// delete the registry unaware values
		fDeleteValuebyPath( CHString( RGAS_DHCP_OPTION_IPADDRESS ) ) ;
		fDeleteValuebyPath( CHString( RGAS_DHCP_OPTION_SUBNETMASK ) ) ;
		fDeleteValuebyPath( CHString( RGAS_DHCP_OPTION_NAMESERVERBACKUP ) ) ;
	}
	return TRUE ;
}

/*******************************************************************
    NAME:       fDeleteValuebyPath

    SYNOPSIS:	deletes the value in the path described by chsDelLocation

    ENTRY:      CHString& chsDelLocation

    HISTORY:
                  13-Oct-1998     Created
********************************************************************/
BOOL CWin32NetworkAdapterConfig::fDeleteValuebyPath( CHString &a_chsDelLocation )
{
	CRegistry t_oReg ;

	int t_iTokLen = a_chsDelLocation.ReverseFind( '\\' ) ;

	if( -1 == t_iTokLen )
	{
		return FALSE ;
	}

	if( ERROR_SUCCESS == t_oReg.CreateOpen( HKEY_LOCAL_MACHINE, a_chsDelLocation.Left( t_iTokLen ) ) )
	{
		if( ERROR_SUCCESS == t_oReg.DeleteValue( a_chsDelLocation.Mid( t_iTokLen + 1 ) ) )
		{
			return TRUE ;
		}
	}
	return FALSE ;
}

/*******************************************************************
    NAME:       hSetIPConnectionMetric

    SYNOPSIS:   Sets IP connection metric, W2k only

    ENTRY:      CMParms

	NOTE:

	HISTORY:
                  21-Nov-1999     Created
********************************************************************/

//
HRESULT CWin32NetworkAdapterConfig::hSetIPConnectionMetric( CMParms &a_rMParms )
{

	// nonstatic method requires an instance
	if( !a_rMParms.pInst() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// collect the instance
	GetObject( a_rMParms.pInst() ) ;

	// IP must be enabled and bound to this adapter
	if( !fIsIPEnabled( a_rMParms ) )
	{
		return S_OK ;
	}

	// extract the index key
	DWORD t_dwIndex ;
	if(	!a_rMParms.pInst()->GetDWORD(_T("Index"), t_dwIndex) )
	{
		return a_rMParms.hSetResult(E_RET_INSTANCE_CALL_FAILED ) ;
	}

	// Get the instance interface location
	CHString t_chsLink;
	CHString t_csInterfaceBindingKey ;
	if( !fGetNtTcpRegAdapterKey( t_dwIndex, t_csInterfaceBindingKey, t_chsLink ) )
	{
		LogErrorMessage(L"Call to fGetNtTcpRegAdapterKey failed");
        return a_rMParms.hSetResult( E_RET_OBJECT_NOT_FOUND ) ;
	}

	// we have a network interface but, is it for a configurable adapter?
	if( !IsConfigurableTcpInterface( t_chsLink ) )
	{
		return a_rMParms.hSetResult( E_RET_INTERFACE_IS_NOT_CONFIGURABLE ) ;
	}


	// extract the connection metric
	DWORD t_dwConnectionMetric ;
	if(	!a_rMParms.pInParams() || !a_rMParms.pInParams()->GetDWORD( IP_CONNECTION_METRIC, t_dwConnectionMetric) )
	{
		t_dwConnectionMetric = 1;	// default
	}


	// have the parms
	CRegistry	t_oRegistry ;
	HRESULT		t_hRes ;

	// registry open and post
	if( !(t_hRes = t_oRegistry.CreateOpen( HKEY_LOCAL_MACHINE, t_csInterfaceBindingKey.GetBuffer( 0 ) ) ) )
	{
		t_hRes = t_oRegistry.SetCurrentKeyValue( RVAL_ConnectionMetric, t_dwConnectionMetric ) ;
	}

	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	// NDIS notification
	CNdisApi t_oNdisApi ;
	if( !t_oNdisApi.PnpUpdateGateway( t_chsLink ) )
	{
		return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
	}
	else
	{
		// DNS notification
		DWORD t_dwError = dwSendServiceControl( L"Dnscache", SERVICE_CONTROL_PARAMCHANGE ) ;

		// map any error
		if( t_dwError && fMapResError( a_rMParms, t_dwError, E_RET_UNABLE_TO_NOTIFY_DNS_SERVICE ) )
		{
			return TO_CALLER ;
		}
	}

	return a_rMParms.hSetResult( E_RET_OK ) ;

}

/*******************************************************************
    NAME:       hRenewDHCPLease

    SYNOPSIS:   Renews a DHCP IP lease for a specific adapter

  	NOTES:		This is a non static, instance dependent method call

    ENTRY:      CMParms, framework return class

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/

HRESULT CWin32NetworkAdapterConfig::hRenewDHCPLease( CMParms &a_rMParms )
{

	// nonstatic method requires an instance
	if( !a_rMParms.pInst() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// collect the instance
	GetObject( a_rMParms.pInst() ) ;

	// IP must be enabled and bound to this adapter
	if( !fIsIPEnabled( a_rMParms ) )
	{
		return S_OK ;
	}

	// obtain the index key
	DWORD t_dwIndex ;
	if( !a_rMParms.pInst()->GetDWORD( _T("Index"), t_dwIndex ) )
	{
		return a_rMParms.hSetResult( E_RET_INSTANCE_CALL_FAILED ) ;
	}

	// retrieve the adapter identifier
	CHString t_chsRegKey ;
	CHString t_chsLink ;
	if( !fGetNtTcpRegAdapterKey( t_dwIndex, t_chsRegKey, t_chsLink ) )
	{
		LogErrorMessage(L"Call to fGetNtTcpRegAdapterKey failed");
        return a_rMParms.hSetResult(E_RET_OBJECT_NOT_FOUND ) ;
	}

	E_RET t_eRet = hDHCPAcquire( a_rMParms, t_chsLink ) ;

	return a_rMParms.hSetResult( t_eRet ) ;


}

/*******************************************************************
    NAME:       hRenewDHCPLeaseAll

    SYNOPSIS:	Renews DHCP IP leases across all adapters

    ENTRY:      CMParms, framework return class

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/

HRESULT CWin32NetworkAdapterConfig::hRenewDHCPLeaseAll( CMParms &a_rMParms )
{

	CRegistry	t_RegAdapters ;
	CRegistry	t_RegService ;
	CHString	t_csAdapterKey ;
	CHString	t_chsServiceField ;
	E_RET		t_eRet = E_RET_OK ;
    short       sNumSuccesses = 0;
    short       sNumTotalTries = 0;
    E_RET       t_eTempRet = E_RET_OK;

	if( IsWinNT5() )
	{
		t_chsServiceField = _T("NetCfgInstanceID" ) ;
		t_csAdapterKey = _T("SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}" ) ;
	}
	else // NT4 and below
	{
		t_chsServiceField = _T("ServiceName" ) ;
		t_csAdapterKey = _T("Software\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards" ) ;
	}

	if( ERROR_SUCCESS == t_RegAdapters.OpenAndEnumerateSubKeys( HKEY_LOCAL_MACHINE, t_csAdapterKey, KEY_READ ) )
	{
		// Walk through each instance under this key.
		while (	( ERROR_SUCCESS == t_RegAdapters.GetCurrentSubKeyPath( t_csAdapterKey ) ) )
		{
			CHString t_cshService ;
			t_RegService.OpenLocalMachineKeyAndReadValue( t_csAdapterKey, t_chsServiceField, t_cshService ) ;

			if( !t_cshService.IsEmpty() )
			{
				if( IsConfigurableTcpInterface( t_cshService ) )
				{
                    sNumTotalTries++;

                    t_eTempRet = hDHCPAcquire( a_rMParms, t_cshService ) ;

					// stow the error and continue
					if( E_RET_OK == t_eTempRet )
					{
						sNumSuccesses++;
					}
				}
			}
			t_RegAdapters.NextSubKey() ;
		}
	}

    // If we failed for every call to hDHCPAquire, and
    // at least called it once, report the actual error
    // that occured. Bug 161142 fix.
    if(sNumTotalTries > 0)
    {
        if(sNumSuccesses == 0)
        {
            t_eRet = t_eTempRet;
        }
        else
        {
            if(sNumSuccesses < sNumTotalTries)
            {
                t_eRet = E_RET_OK;
            }
        }
    }

	return a_rMParms.hSetResult( t_eRet ) ;

}

/*******************************************************************
    NAME:       hReleaseDHCPLease

    SYNOPSIS:   Releases a DHCP IP lease for a specific adapter

    ENTRY:      CMParms, framework return class

  	NOTES:		This is a non static, instance dependent method call

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hReleaseDHCPLease( CMParms &a_rMParms )
{

	// nonstatic method requires an instance
	if( !a_rMParms.pInst() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// collect the instance
	GetObject(a_rMParms.pInst() ) ;

	// IP must be enabled and bound to this adapter
	if( !fIsIPEnabled( a_rMParms ) )
	{
		return S_OK;
	}

	// obtain the index key
	DWORD t_dwIndex ;
	if( !a_rMParms.pInst()->GetDWORD( _T("Index"), t_dwIndex ) )
	{
		return a_rMParms.hSetResult( E_RET_INSTANCE_CALL_FAILED ) ;
	}

	// retrieve the adapter identifier
	CHString t_chsRegKey ;
	CHString t_chsLink ;
	if( !fGetNtTcpRegAdapterKey( t_dwIndex, t_chsRegKey, t_chsLink ) )
	{
		LogErrorMessage(L"Call to fGetNtTcpRegAdapterKey failed");
        return a_rMParms.hSetResult(E_RET_OBJECT_NOT_FOUND ) ;
	}

	E_RET t_eRet = hDHCPRelease( a_rMParms, t_chsLink ) ;

	return a_rMParms.hSetResult( t_eRet ) ;

}

/*******************************************************************
    NAME:       hReleaseDHCPLeaseAll

    SYNOPSIS:	Releases DHCP IP leases across all adapters

    ENTRY:      CMParms, framework return class

	NOTES:		This is a static, instance independent method call

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hReleaseDHCPLeaseAll( CMParms &a_rMParms )
{

	CRegistry	t_RegAdapters ;
	CRegistry	t_RegService ;
	CHString	t_csAdapterKey ;
	CHString	t_chsServiceField ;
	E_RET		t_eRet = E_RET_OK ;
    short       sNumSuccesses = 0;
    short       sNumTotalTries = 0;
    E_RET       t_eTempRet = E_RET_OK;


	if( IsWinNT5() )
	{
		t_chsServiceField = _T("NetCfgInstanceID" ) ;
		t_csAdapterKey = _T("SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}" ) ;
	}
	else	// NT4 and below
	{
		t_chsServiceField = _T("ServiceName" ) ;
		t_csAdapterKey = _T("Software\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards" ) ;
	}


	if(ERROR_SUCCESS == t_RegAdapters.OpenAndEnumerateSubKeys(HKEY_LOCAL_MACHINE, t_csAdapterKey, KEY_READ ) )
	{
		// Walk through each instance under this key.
		while (	( ERROR_SUCCESS == t_RegAdapters.GetCurrentSubKeyPath( t_csAdapterKey ) ) )
		{
			CHString t_cshService ;
			t_RegService.OpenLocalMachineKeyAndReadValue( t_csAdapterKey, t_chsServiceField, t_cshService ) ;

			if( !t_cshService.IsEmpty() )
			{
				if( IsConfigurableTcpInterface( t_cshService ) )
				{
					sNumTotalTries++;

                    t_eTempRet = hDHCPRelease( a_rMParms, t_cshService ) ;

					// stow the error and continue
					if( E_RET_OK == t_eTempRet )
					{
						sNumSuccesses++;
					}
				}
			}
			t_RegAdapters.NextSubKey() ;
		}
	}

    // If we failed for every call to hDHCPAquire, and
    // at least called it once, report the actual error
    // that occured. Bug 161142 fix.
    if(sNumTotalTries > 0)
    {
        if(sNumSuccesses == 0)
        {
            t_eRet = t_eTempRet;
        }
        else
        {
            if(sNumSuccesses < sNumTotalTries)
            {
                t_eRet = E_RET_OK;
            }
        }
    }

	return a_rMParms.hSetResult( t_eRet ) ;

}


/*******************************************************************
    NAME:       hDHCPRelease

    SYNOPSIS:	Releases one or all DHCP enabled adapters

    ENTRY:      CMParms rMParms		: framework return class
				CHString chsAdapter	: empty for all adapters

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/
E_RET CWin32NetworkAdapterConfig::hDHCPRelease( CMParms &a_rMParms, CHString &a_chsAdapter )
{
	DWORD t_dwError ;

    CDhcpcsvcApi *t_pdhcpcsvc = (CDhcpcsvcApi*) CResourceManager::sm_TheResourceManager.GetResource(g_guidDhcpcsvcApi, NULL ) ;

	if( t_pdhcpcsvc != NULL)
	{
		// force wide char
		bstr_t t_bstrAdapter( a_chsAdapter ) ;

		// call the DHCP Notification API
		t_dwError = t_pdhcpcsvc->DhcpReleaseParameters( (wchar_t*)t_bstrAdapter ) ;

		//FreeLibrary( hDll  ) ;
        CResourceManager::sm_TheResourceManager.ReleaseResource( g_guidDhcpcsvcApi, t_pdhcpcsvc ) ;
        t_pdhcpcsvc = NULL;
	}
	else
		t_dwError = GetLastError( ) ;

	// map any error
	if( t_dwError )
	{
		return E_RET_UNABLE_TO_RELEASE_DHCP_LEASE ;
	}

	return E_RET_OK ;
}

/*******************************************************************
    NAME:       hDHCPAcquire

    SYNOPSIS:	Leases one or all DHCP enabled adapters

    ENTRY:      CMParms rMParms		: framework return class
				CHString chsAdapter	: empty for all adapters

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/
E_RET CWin32NetworkAdapterConfig::hDHCPAcquire( CMParms &a_rMParms, CHString& a_chsAdapter )
{
	DWORD t_dwError ;

    CDhcpcsvcApi *t_pdhcpcsvc = (CDhcpcsvcApi*) CResourceManager::sm_TheResourceManager.GetResource( g_guidDhcpcsvcApi, NULL ) ;

	if( t_pdhcpcsvc != NULL )
	{
		// force wide char
		bstr_t t_bstrAdapter( a_chsAdapter ) ;

		// call the DHCP Notification API
		t_dwError = t_pdhcpcsvc->DhcpAcquireParameters( (wchar_t*)t_bstrAdapter ) ;

		//FreeLibrary( hDll  ) ;
        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidDhcpcsvcApi, t_pdhcpcsvc ) ;
        t_pdhcpcsvc = NULL ;
	}
	else
		t_dwError = GetLastError( ) ;

	// map any error
	if( t_dwError )
	{
		return E_RET_UNABLE_TO_RENEW_DHCP_LEASE ;
	}

	return E_RET_OK ;
}

/*******************************************************************
    NAME:       hDHCPNotify

    SYNOPSIS:	Notifies DHCP of IP change to an adapter

    ENTRY:      CMParms &a_rMParms,					: Inparms
				CHString& chsAdapter,				: Adapter
				BOOL fIsNewIpAddress,				: TRUE if new IP
				DWORD dwIpIndex,					: Index of IP in the registry IP array ( zero based
				DWORD dwIpAddress,					: New IP
				DWORD dwSubnetMask,					: new subnet mask
				SERVICE_ENABLE DhcpServiceEnabled	: DhcpEnable, IgnoreFlag or DhcpDisable

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hDHCPNotify( CMParms &a_rMParms,
												 CHString &a_chsAdapter,
												 BOOL a_fIsNewIpAddress,
												 DWORD a_dwIpIndex,
												 DWORD a_dwIpAddress,
												 DWORD a_dwSubnetMask,
												 SERVICE_ENABLE a_DhcpServiceEnabled )
{
	DWORD t_dwError ;

    CDhcpcsvcApi *t_pdhcpcsvc = (CDhcpcsvcApi*) CResourceManager::sm_TheResourceManager.GetResource( g_guidDhcpcsvcApi, NULL ) ;

    if( t_pdhcpcsvc != NULL )
	{
		// force wide char
		bstr_t t_bstrAdapter( a_chsAdapter ) ;

		// call the DHCP Notification API
		t_dwError = t_pdhcpcsvc->DhcpNotifyConfigChange(NULL,				// name of server where this will be executed
								                        (wchar_t*)t_bstrAdapter,	// which adapter is going to be reconfigured?
								                        a_fIsNewIpAddress,	// is address new/ or address is same?
								                        a_dwIpIndex,			// index of addr for this adapter -- 0 ==> first interface...
								                        a_dwIpAddress,		// the ip address that is being set
								                        a_dwSubnetMask,		// corresponding subnet mask
								                        a_DhcpServiceEnabled	// DHCP Enable, disable or Ignore this flag
								                         ) ;

		//FreeLibrary( hDll  ) ;
        CResourceManager::sm_TheResourceManager.ReleaseResource( g_guidDhcpcsvcApi, t_pdhcpcsvc ) ;
        t_pdhcpcsvc = NULL ;
	}
	else
		t_dwError = GetLastError( ) ;

	// map any error
	if( t_dwError && fMapResError( a_rMParms, t_dwError, E_RET_UNABLE_TO_CONFIG_DHCP_SERVICE ) )
	{
        LogErrorMessage2(L"Unable to configure DHCP svc : 0x%x\n", t_dwError);
		return TO_CALLER;
	}
	return a_rMParms.hSetResult( E_RET_OK ) ;
}

/*******************************************************************
    NAME:       hSetGateways

    SYNOPSIS:

    ENTRY:      CMParms, framework return class

  	NOTES:		This is a non static, instance dependent method call

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetGateways( CMParms &a_rMParms )
{


	if ( fIsDhcpEnabled ( a_rMParms ) )
	{
		return a_rMParms.hSetResult( E_RET_UNSUPPORTED ) ;
	}
	else
	{
		// obtain the index key
		DWORD t_dwIndex ;
		if( !a_rMParms.pInst()->GetDWORD( _T("Index"), t_dwIndex ) )
		{
			return a_rMParms.hSetResult( E_RET_INSTANCE_CALL_FAILED ) ;
		}

		// retrieve the adapter identifier
		CHString t_chsRegKey ;
		CHString t_chsLink ;
		if( !fGetNtTcpRegAdapterKey( t_dwIndex, t_chsRegKey, t_chsLink ) )
		{
			LogErrorMessage(L"Call to fGetNtTcpRegAdapterKey failed");
			return a_rMParms.hSetResult(E_RET_OBJECT_NOT_FOUND ) ;
		}

		// registry open
		CRegistry	t_oRegTcpInterfaceRead ;
		if( fMapResError( a_rMParms, t_oRegTcpInterfaceRead.Open( HKEY_LOCAL_MACHINE, t_chsRegKey, KEY_READ  ), E_RET_REGISTRY_FAILURE ) )
		{
			return TO_CALLER;
		}

		// Is DHCP for interface enabled in registry ?
		DWORD t_dwDHCPBool = 0;
		if( fMapResError( a_rMParms, t_oRegTcpInterfaceRead.GetCurrentKeyValue( _T("EnableDHCP"), t_dwDHCPBool ), E_RET_REGISTRY_FAILURE ) )
		{
			return TO_CALLER;
		}

		if ( ! t_dwDHCPBool )
		{
			TCHAR		t_cDelimiter = NULL ;
			SAFEARRAY	*t_IpGatewayArray		= NULL;

			// register for stack scope cleanup of SAFEARRAYs
			saAutoClean acGateway( &t_IpGatewayArray ) ;

			// nonstatic method requires an instance
			if( !a_rMParms.pInst() )
			{
				return a_rMParms.hSetResult( E_RET_INPARM_FAILURE  ) ;
			}

			// collect the instance
			GetObject( a_rMParms.pInst() ) ;

			// IP must be enabled and bound to this adapter
			if( !fIsIPEnabled( a_rMParms ) )
			{
				return S_OK;
			}

			if( !a_rMParms.pInParams() )
			{
				return a_rMParms.hSetResult( E_RET_INPARM_FAILURE  ) ;
			}

			//	retrieve the IP gateway array (array could be NULL)
			a_rMParms.pInParams()->GetStringArray( _T("DefaultIpGateway"), t_IpGatewayArray );

			// Gateway cost metric
			variant_t t_vCostMetric;

			if( IsWinNT5() )
			{
				t_vCostMetric.vt		= VT_I4 | VT_ARRAY ;
				t_vCostMetric.parray	= NULL ;
				a_rMParms.pInParams()->GetVariant( _T("GatewayCostMetric"), t_vCostMetric ) ;
			}

			// test IPs
			if( !t_IpGatewayArray )
			{
				CHString t_chsNULL(_T("") ) ;
				if( !fCreateAddEntry( &t_IpGatewayArray, t_chsNULL ) )
				{
					return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
				}
			}
			else
			{
				// validate gateway IPs
				if( !fValidateIPGateways( a_rMParms, t_IpGatewayArray, &t_vCostMetric.parray ) )
				{
					return S_OK ;
				}
			}

			// OK to update, save to the registry

			// registry open
			CRegistry	t_oRegTcpInterface ;
			HRESULT		t_hRes = t_oRegTcpInterface.Open( HKEY_LOCAL_MACHINE, t_chsRegKey, KEY_WRITE  ) ;
			if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
			{
				return TO_CALLER;
			}

			// load the registry
			if( ERROR_SUCCESS != RegPutStringArray( t_oRegTcpInterface, _T("DefaultGateway") , *t_IpGatewayArray, t_cDelimiter ) )
			{
				return a_rMParms.hSetResult( E_RET_REGISTRY_FAILURE  ) ;
			}

			{
				// cost metric
				if( t_vCostMetric.parray )
				{
					//maximum length is 6 characters e.g. "99999\0"
					CHString t_chsFormat( _T("%u") ) ;
					if( ERROR_SUCCESS != RegPutINTtoStringArray(	t_oRegTcpInterface,
																	_T("DefaultGatewayMetric"),
																	t_vCostMetric.parray,
																	t_chsFormat,
																	6 ) )
					{
						return a_rMParms.hSetResult( E_RET_REGISTRY_FAILURE  ) ;
					}
				}

				// we have to post back to the NT4 registry area
				// in order to keep existing apps in the field running

				CRegistry	t_oNT4Reg ;
				CHString	t_csBindingKey = SERVICES_HOME ;
							t_csBindingKey += _T("\\" ) ;
							t_csBindingKey += t_chsLink ;
							t_csBindingKey += PARAMETERS_TCPIP ;

				// insure the key is there on open
				HRESULT t_hRes = t_oNT4Reg.CreateOpen( HKEY_LOCAL_MACHINE, t_csBindingKey.GetBuffer( 0 ) ) ;
				if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
				{
					return TO_CALLER;
				}

				// load the registry entry
				if( ERROR_SUCCESS != RegPutStringArray( t_oNT4Reg, _T("DefaultGateway") , *t_IpGatewayArray, t_cDelimiter ) )
				{
					return a_rMParms.hSetResult( E_RET_REGISTRY_FAILURE  ) ;
				}

				// NDIS notification
				CNdisApi t_oNdisApi ;
				if( !t_oNdisApi.PnpUpdateGateway( t_chsLink ) )
				{
					return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
				}
				else
				{
					// DNS notification
					DWORD t_dwError = dwSendServiceControl( L"Dnscache", SERVICE_CONTROL_PARAMCHANGE ) ;

					// map any error
					if( t_dwError && fMapResError( a_rMParms, t_dwError, E_RET_UNABLE_TO_NOTIFY_DNS_SERVICE ) )
					{
						return TO_CALLER ;
					}
				}
			}
		}
		else
		{
			return a_rMParms.hSetResult( E_RET_UNSUPPORTED ) ;
		}
	}

	return a_rMParms.hSetResult( E_RET_OK ) ;

}

/*******************************************************************
    NAME:       hGetDNS

    SYNOPSIS:   Retrieves all DNS settings from the registry

    ENTRY:      CInstance

    HISTORY:
                  23-Jul-1998     Created

	NOTE:		This is not adapter specific.
				It retrieves from the common TCP/IP area.
********************************************************************/

HRESULT CWin32NetworkAdapterConfig::hGetDNSW2K(
    CInstance *a_pInst, 
    DWORD a_dwIndex,
    CHString& a_chstrRootDevice,
    CHString& a_chstrIpInterfaceKey)
{
	CRegistry	t_oRegistry;
	CHString	t_csBindingKey ;
	CHString	t_csHostName ;
	CHString	t_csDomain ;
	TCHAR		t_cDelimiter ;

	t_csBindingKey	=  SERVICES_HOME ;


	// NT4 is global with these setting across adapters
	t_csBindingKey	+= TCPIP_PARAMETERS ;

	// searchlist delimiter
	t_cDelimiter = ',' ;


	SAFEARRAY* t_DHCPNameServers = NULL;
	SAFEARRAY* t_ServerSearchOrder = NULL;
	SAFEARRAY* t_SuffixSearchOrder = NULL;

	// register for stack scope cleanup of SAFEARRAYs
	saAutoClean acDHCPServers( &t_DHCPNameServers ) ;
	saAutoClean acDefServers( &t_ServerSearchOrder ) ;
	saAutoClean acSuffix( &t_SuffixSearchOrder ) ;

	// registry open
	LONG t_lRes = t_oRegistry.Open( HKEY_LOCAL_MACHINE, t_csBindingKey.GetBuffer( 0 ), KEY_READ  ) ;

	// on error map to WBEM
	HRESULT t_hError = WinErrorToWBEMhResult( t_lRes ) ;

	if( WBEM_S_NO_ERROR != t_hError )
	{
		return t_hError;
	}

	t_oRegistry.GetCurrentKeyValue( RVAL_HOSTNAME, t_csHostName ) ;

	RegGetStringArray( t_oRegistry, RVAL_SEARCHLIST, &t_SuffixSearchOrder, t_cDelimiter  ) ;


	// On W2k the Domain and ServerSearchOrder are per adapter
	{
		// Get the instance interface location
		CHString t_chsLink;
        bool fGotTCPKey = false;

        fGotTCPKey = fGetNtTcpRegAdapterKey(a_dwIndex, t_csBindingKey, t_chsLink);
		// If it is a RAS connection, we need to look elsewhere...

        if(!fGotTCPKey)
        {
            if(a_chstrRootDevice.CompareNoCase(L"NdisWanIp") == 0)
            {
                int iPos = a_chstrIpInterfaceKey.Find(L"{");
                if(iPos != -1)
                {
                    t_chsLink = a_chstrIpInterfaceKey.Mid(iPos);

					// Also fill in the BindingKey...
					t_csBindingKey = SERVICES_HOME ;
					t_csBindingKey += L"\\Tcpip\\Parameters\\Interfaces\\";
					t_csBindingKey += t_chsLink;

                    fGotTCPKey = true;
                }     
            }
        }
        
        if(!fGotTCPKey)
		{
			LogErrorMessage(L"Call to fGetNtTcpRegAdapterKey failed");
            return WBEM_E_NOT_FOUND ;
		}

		if( !a_pInst->Setbool( FULL_DNS_REGISTRATION, DnsIsDynamicRegistrationEnabled ( const_cast < LPWSTR> ( static_cast < LPCWSTR > ( t_chsLink ) ) ) ) )
		{
			return WBEM_E_FAILED ;
		}

		if( !a_pInst->Setbool( DOMAIN_DNS_REGISTRATION, DnsIsAdapterDomainNameRegistrationEnabled ( const_cast < LPWSTR> ( static_cast < LPCWSTR > ( t_chsLink ) ) ) ) )
		{
			return WBEM_E_FAILED ;
		}

		// need to open this registry as looking per adapter is required
		t_lRes = t_oRegistry.Open( HKEY_LOCAL_MACHINE, t_csBindingKey.GetBuffer( 0 ), KEY_READ ) ;
	}

	DWORD	t_dwDHCPBool = 0L;
	BOOL	t_bExists = FALSE;

	t_bExists = ( t_oRegistry.GetCurrentKeyValue( _T("EnableDHCP"), t_dwDHCPBool ) == ERROR_SUCCESS );

	if ( t_bExists && t_dwDHCPBool )
	{
		RegGetStringArrayEx( t_oRegistry, RVAL_DHCPNAMESERVER, &t_DHCPNameServers ) ; // space delimited on all platforms
	}


    // on w2k, this list is space, not comma, delimeted...
    RegGetStringArrayEx( t_oRegistry, RVAL_NAMESERVER, &t_ServerSearchOrder);


	t_oRegistry.GetCurrentKeyValue( RVAL_DOMAIN, t_csDomain ) ;

	// get the DhcpDomain if override is not present
	if( t_csDomain.IsEmpty() )
	{
		t_oRegistry.GetCurrentKeyValue( RVAL_DHCPDOMAIN, t_csDomain ) ;
	}


	/* update */
	SAFEARRAY* t_NameServers = NULL;

	if ( t_bExists && t_dwDHCPBool )
	{
		// If override nameservers are present use them
		t_NameServers = t_ServerSearchOrder ? t_ServerSearchOrder : t_DHCPNameServers ;
	}
	else
	{
		t_NameServers = t_ServerSearchOrder ;
	}

	// update the instance
	if( !t_csHostName.IsEmpty() )
	{
		if( !a_pInst->SetCHString( DNS_HOSTNAME, t_csHostName ) )
		{
			return WBEM_E_FAILED ;
		}
	}

	if( !t_csDomain.IsEmpty() )
	{
		if( !a_pInst->SetCHString( DNS_DOMAIN, t_csDomain ) )
		{
			return WBEM_E_FAILED ;
		}
	}

	VARIANT t_vValue ;

	if( t_NameServers )
	{
		V_VT( &t_vValue ) = VT_BSTR | VT_ARRAY; V_ARRAY( &t_vValue ) = t_NameServers ;
		if( !a_pInst->SetVariant( DNS_SERVERSEARCHORDER, t_vValue ) )
		{
			return WBEM_E_FAILED ;
		}
	}

	if( t_SuffixSearchOrder )
	{
		V_VT( &t_vValue ) = VT_BSTR | VT_ARRAY; V_ARRAY( &t_vValue ) = t_SuffixSearchOrder;
		if( !a_pInst->SetVariant( DNS_SUFFIXSEARCHORDER, t_vValue ) )
		{
			return WBEM_E_FAILED ;
		}
	}

	return S_OK ;
}



/*******************************************************************
    NAME:       hEnableDNS

    SYNOPSIS:   Sets all DNS properties to the registry

    ENTRY:      CMParms via CInstance depending on the context of the call

	HISTORY:
                  23-Jul-1998     Created
				  17-Jun-1999     added W2k changes

	NOTE:		Under NT4 these settings are global.
				Under W2k ServerSearchOrder and SuffixSearchOrder are
				adapter specific.

				In all cases of supported platforms this method replicates
				these setting across all adapters.
********************************************************************/

//
HRESULT CWin32NetworkAdapterConfig::hEnableDNS( CMParms &a_rMParms )
{


	HRESULT		t_hRes ;
	CHString	t_csHostName ;
	CHString	t_csDomain ;
	SAFEARRAY	*t_ServerSearchOrder = NULL ;
	SAFEARRAY	*t_SuffixSearchOrder = NULL ;

	CHString	t_csParmBindingKey( SERVICES_HOME ) ;
				t_csParmBindingKey += TCPIP_PARAMETERS ;

	// register for stack scope cleanup of SAFEARRAYs
	saAutoClean acServer( &t_ServerSearchOrder ) ;
	saAutoClean acSuffix( &t_SuffixSearchOrder ) ;

	//
	DWORD t_dwValidBits = NULL ;
	E_RET t_eRet = fLoadAndValidateDNS_Settings(	a_rMParms,
													t_csHostName,
													t_csDomain,
													&t_ServerSearchOrder,
													&t_SuffixSearchOrder,
													&t_dwValidBits ) ;
	// bail on settings error
	if( E_RET_OK != t_eRet )
	{
		return a_rMParms.hSetResult( t_eRet ) ;
	}

	// These are global on all platforms
	CRegistry	t_oParmRegistry ;
	if( !(t_hRes = t_oParmRegistry.CreateOpen( HKEY_LOCAL_MACHINE, t_csParmBindingKey.GetBuffer( 0 ) ) ) )
	{
		if( t_dwValidBits & 0x01 )
		{
			t_oParmRegistry.SetCurrentKeyValue( RVAL_HOSTNAME, t_csHostName ) ;
		}

		if( t_dwValidBits & 0x08 )
		{
			TCHAR t_cDelimiter = ' ' ;

			if( IsWinNT5() )
			{
				t_cDelimiter = ',' ;
			}

			t_hRes = RegPutStringArray( t_oParmRegistry, RVAL_SEARCHLIST , *t_SuffixSearchOrder, t_cDelimiter ) ;
		}
	}

	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	// W2k is per adapter on domain and server search order
	if( IsWinNT5() && ( t_dwValidBits & 0x06 ) )
	{
		// master adapter list
		CHString t_csAdapterKey( "SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}" ) ;

		CRegistry t_oRegNetworks ;
		if( ERROR_SUCCESS == t_oRegNetworks.OpenAndEnumerateSubKeys( HKEY_LOCAL_MACHINE, t_csAdapterKey, KEY_READ ) )
		{
			bool		t_fNotificationRequired = false ;
			CHString	t_csInterfaceBindingKey ;

			// Walk through each instance under this key.
			while (	( ERROR_SUCCESS == t_oRegNetworks.GetCurrentSubKeyName( t_csAdapterKey ) ) )
			{
				DWORD t_dwIndex = _ttol( t_csAdapterKey ) ;

				// Get the instance interface location
				CHString t_chsLink;
				if( !fGetNtTcpRegAdapterKey( t_dwIndex, t_csInterfaceBindingKey, t_chsLink ) )
				{
					LogErrorMessage(L"Call to fGetNtTcpRegAdapterKey failed");
                    return a_rMParms.hSetResult( E_RET_OBJECT_NOT_FOUND ) ;
				}

				// we have a network interface but, is it for a configurable adapter?
				if( IsConfigurableTcpInterface( t_chsLink ) )
				{
					CRegistry	t_oRegInterface ;
					HRESULT		t_hRes ;

					// registry open
					if( !(t_hRes = t_oRegInterface.CreateOpen( HKEY_LOCAL_MACHINE, t_csInterfaceBindingKey.GetBuffer( 0 ) ) ) )
					{
						if( t_dwValidBits & 0x04 )
						{
							t_hRes = RegPutStringArray( t_oRegInterface, RVAL_NAMESERVER , *t_ServerSearchOrder, ',' ) ;
						}
					}

					if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
					{
						return TO_CALLER;
					}

					if( t_dwValidBits & 0x02 )
					{
						t_oRegInterface.SetCurrentKeyValue( RVAL_DOMAIN, t_csDomain ) ;
					}
					t_fNotificationRequired = true ;
				}

				t_oRegNetworks.NextSubKey() ;
			}

			// DNS pnp notifications
			if( t_fNotificationRequired )
			{
				DWORD t_dwError = dwSendServiceControl( L"Dnscache", SERVICE_CONTROL_PARAMCHANGE ) ;

				// map any error
				if( t_dwError && fMapResError( a_rMParms, t_dwError, E_RET_UNABLE_TO_NOTIFY_DNS_SERVICE ) )
				{
					return TO_CALLER ;
				}
			}
		}
	}
	// NT4 is global across all adapters
	else if( t_dwValidBits & 0x06 )
	{
		if( t_dwValidBits & 0x04 )
		{
			t_hRes = RegPutStringArray( t_oParmRegistry, RVAL_NAMESERVER , *t_ServerSearchOrder ) ;

			if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
			{
				return TO_CALLER;
			}
		}

		if( t_dwValidBits & 0x02 )
		{
			t_oParmRegistry.SetCurrentKeyValue( RVAL_DOMAIN, t_csDomain ) ;
		}
	}

	return a_rMParms.hSetResult( E_RET_OK ) ;

}

/*******************************************************************
    NAME:       hSetDNSDomain

    SYNOPSIS:   Sets the DNSDomain property to the registry

    ENTRY:      CMParms

	HISTORY:
                  17-Jun-1999    Created

	NOTE:		Under NT4 this settings are global.
				Under W2k DNSDomain is adapter specific.

********************************************************************/

//
HRESULT CWin32NetworkAdapterConfig::hSetDNSDomain( CMParms &a_rMParms )
{


	if( !a_rMParms.pInParams() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE  ) ;
	}

	HRESULT		t_hRes ;
	CHString	t_csDomain ;

	// DNSDomain
	a_rMParms.pInParams()->GetCHString( DNS_DOMAIN, t_csDomain ) ;

	// validate domain name
	if( !fIsValidateDNSDomain( t_csDomain ) )
	{
		return E_RET_INVALID_DOMAINNAME ;
	}

	// W2k is per adapter on domain
	if( IsWinNT5() )
	{
		// nonstatic method requires an instance
		if( !a_rMParms.pInst() )
		{
			return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
		}

		// collect the instance
		GetObject( a_rMParms.pInst() ) ;

		// IP must be enabled and bound to this adapter
		if( !fIsIPEnabled( a_rMParms ) )
		{
			return S_OK ;
		}

		// extract the index key
		DWORD t_dwIndex ;
		if(	!a_rMParms.pInst()->GetDWORD(_T("Index"), t_dwIndex) )
		{
			return a_rMParms.hSetResult(E_RET_INSTANCE_CALL_FAILED ) ;
		}

		// Get the instance interface location
		CHString t_chsLink;
		CHString t_csInterfaceBindingKey ;
		if( !fGetNtTcpRegAdapterKey( t_dwIndex, t_csInterfaceBindingKey, t_chsLink ) )
		{
			LogErrorMessage(L"Call to fGetNtTcpRegAdapterKey failed");
            return a_rMParms.hSetResult( E_RET_OBJECT_NOT_FOUND ) ;
		}

		// we have a network interface but, is it for a configurable adapter?
		if( !IsConfigurableTcpInterface( t_chsLink ) )
		{
			return a_rMParms.hSetResult( E_RET_INTERFACE_IS_NOT_CONFIGURABLE ) ;
		}

		CRegistry	t_oRegistry ;
		HRESULT		t_hRes ;

		// registry open
		if( !(t_hRes = t_oRegistry.CreateOpen( HKEY_LOCAL_MACHINE, t_csInterfaceBindingKey.GetBuffer( 0 ) ) ) )
		{
			t_hRes = t_oRegistry.SetCurrentKeyValue( RVAL_DOMAIN, t_csDomain ) ;
		}

		if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
		{
			return TO_CALLER;
		}

		// DNS pnp notifications
		DWORD t_dwError = dwSendServiceControl( L"Dnscache", SERVICE_CONTROL_PARAMCHANGE ) ;

		// map any error
		if( t_dwError && fMapResError( a_rMParms, t_dwError, E_RET_UNABLE_TO_NOTIFY_DNS_SERVICE ) )
		{
			return TO_CALLER ;
		}
	}
	// NT4 is global across all adapters
	else
	{
		CRegistry	t_oRegistry ;
		CHString	t_csParmBindingKey( SERVICES_HOME ) ;
					t_csParmBindingKey += TCPIP_PARAMETERS ;

		if( !(t_hRes = t_oRegistry.CreateOpen( HKEY_LOCAL_MACHINE, t_csParmBindingKey.GetBuffer( 0 ) ) ) )
		{
			t_hRes = t_oRegistry.SetCurrentKeyValue( RVAL_DOMAIN, t_csDomain ) ;
		}

		if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
		{
			return TO_CALLER;
		}
	}

	return a_rMParms.hSetResult( E_RET_OK ) ;

}

/*******************************************************************
    NAME:       hSetDNSSuffixSearchOrder

    SYNOPSIS:   Sets the DNS SuffixSearchOrder property to the registry

    ENTRY:      CMParms

	HISTORY:
                  17-Jun-1999     Created

	NOTE:		This method applies globally across adapters.

********************************************************************/

//
HRESULT CWin32NetworkAdapterConfig::hSetDNSSuffixSearchOrder( CMParms &a_rMParms )
{


	if( !a_rMParms.pInParams() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE  ) ;
	}

	HRESULT		t_hRes ;
	SAFEARRAY	*t_SuffixSearchOrder = NULL ;
	saAutoClean acSuffix( &t_SuffixSearchOrder ) ;

	// suffix order array
	a_rMParms.pInParams()->GetStringArray( DNS_SUFFIXSEARCHORDER, t_SuffixSearchOrder ) ;

	// test suffix
	if( !t_SuffixSearchOrder )
	{
		CHString t_chsNULL(_T("") ) ;
		if( !fCreateAddEntry( &t_SuffixSearchOrder, t_chsNULL ) )
		{
			return a_rMParms.hSetResult( E_RET_UNKNOWN_FAILURE );
		}
	}

	CRegistry	t_oRegistry ;
	CHString	t_csParmBindingKey( SERVICES_HOME ) ;
				t_csParmBindingKey += TCPIP_PARAMETERS ;

	if( !(t_hRes = t_oRegistry.CreateOpen( HKEY_LOCAL_MACHINE, t_csParmBindingKey.GetBuffer( 0 ) ) ) )
	{
		TCHAR t_cDelimiter = ' ' ;

		if( IsWinNT5() )
		{
			t_cDelimiter = ',' ;
		}

		t_hRes = t_hRes = RegPutStringArray( t_oRegistry, RVAL_SEARCHLIST , *t_SuffixSearchOrder, t_cDelimiter ) ;
	}

	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}


	// DNS pnp notifications
	if( IsWinNT5() )
	{
		DWORD t_dwError = dwSendServiceControl( L"Dnscache", SERVICE_CONTROL_PARAMCHANGE ) ;

		// map any error
		if( t_dwError && fMapResError( a_rMParms, t_dwError, E_RET_UNABLE_TO_NOTIFY_DNS_SERVICE ) )
		{
			return TO_CALLER ;
		}
	}

	return a_rMParms.hSetResult( E_RET_OK ) ;


}

/*******************************************************************
    NAME:       hSetDNSServerSearchOrder

    SYNOPSIS:   Sets the ServerSearchOrder property to the registry

    ENTRY:      CMParms

	HISTORY:
                  17-Jun-1999     Created

	NOTE:		Under NT4 these settings are global.
				Under W2k SuffixSearchOrder is	adapter specific.


********************************************************************/

//
HRESULT CWin32NetworkAdapterConfig::hSetDNSServerSearchOrder( CMParms &a_rMParms )
{


	if( !a_rMParms.pInParams() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE  ) ;
	}

	HRESULT		t_hRes ;
	SAFEARRAY	*t_ServerSearchOrder = NULL ;
	saAutoClean acSuffix( &t_ServerSearchOrder ) ;

	CHString t_chsNULL(_T("") ) ;

	//retrieve the DNS Server search order array
	a_rMParms.pInParams()->GetStringArray( DNS_SERVERSEARCHORDER, t_ServerSearchOrder ) ;

	// test IPs
	if( !t_ServerSearchOrder )
	{
		if( !fCreateAddEntry( &t_ServerSearchOrder, t_chsNULL ) )
		{
			return a_rMParms.hSetResult( E_RET_UNKNOWN_FAILURE ) ;
		}
	}
	else	{
		// validate search order IPs
		if( !fValidateIPs( t_ServerSearchOrder ) )
		{
			return a_rMParms.hSetResult( E_RET_IP_INVALID ) ;
		}
	}



	// W2k is per adapter on suffix order
	if( IsWinNT5() )
	{
		// nonstatic method requires an instance
		if( !a_rMParms.pInst() )
		{
			return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
		}

		// collect the instance
		GetObject( a_rMParms.pInst() ) ;

		// IP must be enabled and bound to this adapter
		if( !fIsIPEnabled( a_rMParms ) )
		{
			return S_OK ;
		}

		// extract the index key
		DWORD t_dwIndex ;
		if(	!a_rMParms.pInst()->GetDWORD(_T("Index"), t_dwIndex) )
		{
			return a_rMParms.hSetResult(E_RET_INSTANCE_CALL_FAILED ) ;
		}

		// Get the instance interface location
		CHString t_chsLink;
		CHString t_csInterfaceBindingKey ;
		if( !fGetNtTcpRegAdapterKey( t_dwIndex, t_csInterfaceBindingKey, t_chsLink ) )
		{
			LogErrorMessage(L"Call to fGetNtTcpRegAdapterKey failed");
            return a_rMParms.hSetResult( E_RET_OBJECT_NOT_FOUND ) ;
		}

		// we have a network interface but, is it for a configurable adapter?
		if( !IsConfigurableTcpInterface( t_chsLink ) )
		{
			return a_rMParms.hSetResult( E_RET_INTERFACE_IS_NOT_CONFIGURABLE ) ;
		}

		CRegistry	t_oRegistry ;
		HRESULT		t_hRes ;

		// registry open
		if( !(t_hRes = t_oRegistry.CreateOpen( HKEY_LOCAL_MACHINE, t_csInterfaceBindingKey.GetBuffer( 0 ) ) ) )
		{
			t_hRes = RegPutStringArray( t_oRegistry, RVAL_NAMESERVER , *t_ServerSearchOrder, ',' ) ;
		}

		if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
		{
			return TO_CALLER;
		}

		// DNS pnp notifications
		DWORD t_dwError = dwSendServiceControl( L"Dnscache", SERVICE_CONTROL_PARAMCHANGE ) ;

		// map any error
		if( t_dwError && fMapResError( a_rMParms, t_dwError, E_RET_UNABLE_TO_NOTIFY_DNS_SERVICE ) )
		{
			return TO_CALLER ;
		}
	}
	// NT4 is global across all adapters
	else
	{
		CRegistry	t_oRegistry ;
		CHString	t_csParmBindingKey( SERVICES_HOME ) ;
					t_csParmBindingKey += TCPIP_PARAMETERS ;

		if( !(t_hRes = t_oRegistry.CreateOpen( HKEY_LOCAL_MACHINE, t_csParmBindingKey.GetBuffer( 0 ) ) ) )
		{
			t_hRes = t_hRes = RegPutStringArray( t_oRegistry, RVAL_NAMESERVER , *t_ServerSearchOrder ) ;
		}

		if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
		{
			return TO_CALLER;
		}
	}

	// DNS pnp notifications
	if( IsWinNT5() )
	{
		DWORD t_dwError = dwSendServiceControl( L"Dnscache", SERVICE_CONTROL_PARAMCHANGE ) ;

		// map any error
		if( t_dwError && fMapResError( a_rMParms, t_dwError, E_RET_UNABLE_TO_NOTIFY_DNS_SERVICE ) )
		{
			return TO_CALLER ;
		}
	}

	return a_rMParms.hSetResult( E_RET_OK ) ;

}

/*******************************************************************
    NAME:       hSetDynamicDNSRegistration

    SYNOPSIS:   Sets DNS for dynamic registration under W2k

    ENTRY:      CMParms

	NOTE:

	HISTORY:
                  21-Nov-1999     Created
********************************************************************/

//
HRESULT CWin32NetworkAdapterConfig::hSetDynamicDNSRegistration( CMParms &a_rMParms )
{
	bool t_fFullDnsRegistration		= false ;
	bool t_fDomainDNSRegistration	= false ;

	// nonstatic method requires an instance
	if( !a_rMParms.pInst() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// collect the instance
	GetObject( a_rMParms.pInst() ) ;

	// IP must be enabled and bound to this adapter
	if( !fIsIPEnabled( a_rMParms ) )
	{
		return S_OK ;
	}

	// extract the index key
	DWORD t_dwIndex ;
	if(	!a_rMParms.pInst()->GetDWORD(_T("Index"), t_dwIndex) )
	{
		return a_rMParms.hSetResult(E_RET_INSTANCE_CALL_FAILED ) ;
	}

	// Get the instance interface location
	CHString t_chsLink;
	CHString t_csInterfaceBindingKey ;
	if( !fGetNtTcpRegAdapterKey( t_dwIndex, t_csInterfaceBindingKey, t_chsLink ) )
	{
		LogErrorMessage(L"Call to fGetNtTcpRegAdapterKey failed");
        return a_rMParms.hSetResult( E_RET_OBJECT_NOT_FOUND ) ;
	}

	// we have a network interface but, is it for a configurable adapter?
	if( !IsConfigurableTcpInterface( t_chsLink ) )
	{
		return a_rMParms.hSetResult( E_RET_INTERFACE_IS_NOT_CONFIGURABLE ) ;
	}


	// FullDNSRegistrationEnabled is required
	if( !a_rMParms.pInParams() || !a_rMParms.pInParams()->Getbool( FULL_DNS_REGISTRATION, t_fFullDnsRegistration ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}
	else
	{
		// DomainDNSRegistrationEnabled is optional
		if( t_fFullDnsRegistration )
		{
			if( !a_rMParms.pInParams() || !a_rMParms.pInParams()->Getbool( DOMAIN_DNS_REGISTRATION, t_fDomainDNSRegistration ) )
			{
				// default
				t_fDomainDNSRegistration = false ;
			}
		}
	}

	if ( t_fFullDnsRegistration )
	{
		if ( NO_ERROR == DnsEnableDynamicRegistration ( const_cast < LPWSTR> ( static_cast < LPCWSTR > ( t_chsLink ) ) ) )
		{
			if ( t_fDomainDNSRegistration )
			{
				DnsEnableAdapterDomainNameRegistration ( const_cast < LPWSTR> ( static_cast < LPCWSTR > ( t_chsLink ) ) );
			}
			else
			{
				DnsDisableAdapterDomainNameRegistration ( const_cast < LPWSTR> ( static_cast < LPCWSTR > ( t_chsLink ) ) );
			}
		}
	}
	else
	{
		if ( NO_ERROR == DnsDisableDynamicRegistration ( const_cast < LPWSTR> ( static_cast < LPCWSTR > ( t_chsLink ) ) ) )
		{
			DnsDisableAdapterDomainNameRegistration ( const_cast < LPWSTR> ( static_cast < LPCWSTR > ( t_chsLink ) ) );
		}
	}

	// DNS pnp notifications
	DWORD t_dwError = dwSendServiceControl( L"Dnscache", SERVICE_CONTROL_PARAMCHANGE ) ;

	// map any error
	if( t_dwError && fMapResError( a_rMParms, t_dwError, E_RET_UNABLE_TO_NOTIFY_DNS_SERVICE ) )
	{
		return TO_CALLER ;
	}

	return a_rMParms.hSetResult( E_RET_OK ) ;


}

/*******************************************************************
    NAME:       fLoadAndValidateDNS_Settings

    SYNOPSIS:

    ENTRY:      CMParms		&a_rMParms,
				CHString	&a_csHostName,
				CHString	&a_csDomain,
				SAFEARRAY	*a_ServerSearchOrder,
				SAFEARRAY	*a_SuffixSearchOrder,
				DWORD		*a_dwValidBits

	HISTORY:
                  17-Jun-1999     Created

	NOTE:

********************************************************************/

E_RET CWin32NetworkAdapterConfig::fLoadAndValidateDNS_Settings(
CMParms		&a_rMParms,
CHString	&a_csHostName,
CHString	&a_csDomain,
SAFEARRAY	**a_ServerSearchOrder,
SAFEARRAY	**a_SuffixSearchOrder,
DWORD		*a_dwValidBits
)
{
	*a_dwValidBits = NULL ;

	if ( !a_rMParms.pInParams() )
	{
		return E_RET_INPARM_FAILURE ;
	}

	// under w2k the computername is preset and not otherwise useable
	// by DNS as an alternate computer identifier.
	if( !IsWinNT5() )
	{
		// extract the DNSHostName
		if( a_rMParms.pInParams()->GetCHString( DNS_HOSTNAME, a_csHostName ) )
		{
			// validate domain name
			if( !fIsValidateDNSHost( a_csHostName ) )
			{
				return E_RET_INVALID_HOSTNAME ;
			}
			*a_dwValidBits |= 0x01 ;
		}
	}

	// And the DNSDomain
	if( a_rMParms.pInParams()->GetCHString( DNS_DOMAIN, a_csDomain ) )
	{
		// validate domain name
		if( !fIsValidateDNSDomain( a_csDomain ) )
		{
			return E_RET_INVALID_DOMAINNAME ;
		}
		*a_dwValidBits |= 0x02 ;
	}

	//	retrieve the DNS Server search order array
	if( a_rMParms.pInParams()->GetStringArray( DNS_SERVERSEARCHORDER, *a_ServerSearchOrder ) )
	{
		// test IPs
		if( *a_ServerSearchOrder )
		{
			// validate search order IPs
			if( !fValidateIPs( *a_ServerSearchOrder ) )
			{
				return E_RET_IP_INVALID ;
			}
			*a_dwValidBits |= 0x04 ;
		}
	}

	// And the suffix order array
	if( a_rMParms.pInParams()->GetStringArray( DNS_SUFFIXSEARCHORDER, *a_SuffixSearchOrder ) )
	{
		if( *a_SuffixSearchOrder )
		{
			*a_dwValidBits |= 0x08 ;
		}
	}

	if( !*a_dwValidBits )
	{
		return E_RET_INPARM_FAILURE ;
	}

	return E_RET_OK ;
}


/*******************************************************************
    NAME:       fIsValidateDNSHost

    SYNOPSIS:   Validates a passed DMS host name

    ENTRY:      CHString

    HISTORY:
                  23-Jul-1998     modified
********************************************************************/

BOOL CWin32NetworkAdapterConfig::fIsValidateDNSHost( CHString &a_rchHost )
{
    int		t_nLen ;
    BOOL	t_bResult = FALSE ;

    // hostname cannot be zero
	if (( t_nLen = a_rchHost.GetLength() ) != 0 )
    {
        //HOST_LIMIT is bytes not chartacters
		if ( t_nLen <= HOST_LIMIT )
        {
			WCHAR *t_ptr = a_rchHost.GetBuffer( 0 ) ;

			//first letter must be alpha-numeric
			t_bResult = _istalpha( *t_ptr ) || _istdigit( *t_ptr ) ;

			if ( t_bResult )
			{
				t_ptr++ ;

				while ( *t_ptr != '\0' )
				{
					// check each character is either a digit or a letter
					BOOL t_fAlNum = _istalpha( *t_ptr ) || _istdigit( *t_ptr ) ;

					if ( !t_fAlNum && ( *t_ptr != L'-' ) && ( *t_ptr != '_' ) )
					{
						// must be letter, digit, '-', '_'
						t_bResult = FALSE ;
						break ;
					}

					//t_ptr = _tcsinc(t_ptr ) ;
                    t_ptr++ ;

					if ( !t_fAlNum && ( *t_ptr == '\0') )
					{
						// last letter must be a letter or a digit
						t_bResult = FALSE;
					}
				}
			}

			a_rchHost.ReleaseBuffer() ;
        }
    }
    return t_bResult;
}

/*******************************************************************
    NAME:       fIsValidateDNSDomain

    SYNOPSIS:   Validates a passed DMS domain name

    ENTRY:      CHString

    HISTORY:
                  23-Jul-1998     modified from other source
********************************************************************/

BOOL CWin32NetworkAdapterConfig::fIsValidateDNSDomain( CHString &a_rchDomain )
{
    int		t_nLen;
	BOOL	t_bResult = TRUE ;

	if ( ( t_nLen = a_rchDomain.GetLength()) != 0 )
    {
        //length in bytes
		if ( t_nLen < DOMAINNAME_LENGTH )
        {
			WCHAR *t_ptr = a_rchDomain.GetBuffer( 0 ) ;

			//first letter must be alpha-numeric
			t_bResult = _istalpha( *t_ptr ) || _istdigit( *t_ptr ) ;

			if ( t_bResult )
			{
				BOOL t_fLet_Dig = FALSE ;
				BOOL t_fDot = FALSE ;
				int t_cHostname = 0 ;

				//t_ptr = _tcsinc(t_ptr ) ;
                t_ptr++ ;

				while ( *t_ptr != '\0' )
				{
	                BOOL t_fAlNum = _istalpha( *t_ptr ) || _istdigit( *t_ptr ) ;

					if ( ( t_fDot && !t_fAlNum ) ||
							// first letter after dot must be a digit or a letter
						( !t_fAlNum && ( *t_ptr != '-' ) && ( *t_ptr != '.' ) && ( *t_ptr != '_' ) ) ||
							// must be letter, digit, - or "."
						( ( *t_ptr == '-' ) && ( !t_fLet_Dig ) ) )
							// must be letter or digit before '.'
					{
						t_bResult = FALSE ;
						break;
					}

					t_fLet_Dig = t_fAlNum ;
					t_fDot = *t_ptr == '.' ;

                    t_cHostname++ ;

					//in bytes
					if ( t_cHostname > HOSTNAME_LENGTH )
					{
						t_bResult = FALSE ;
						break ;
					}

					if ( t_fDot )
					{
						t_cHostname = 0 ;
					}

					t_ptr++ ;

					if (!t_fAlNum && ( *t_ptr == '\0' ) )
					{
						// last letter must be a letter or a digit
						t_bResult = FALSE ;
					}
				}
            }

			a_rchDomain.ReleaseBuffer() ;
        }
		else
		{
			t_bResult = FALSE ;
		}
    }
	else
	{
		t_bResult = TRUE ;
	}

    return TRUE ;
}


/*******************************************************************
    NAME:       hGetWinsNT

    SYNOPSIS:   Retrieves WINS info from the registry

    ENTRY:      CInstance

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/

HRESULT CWin32NetworkAdapterConfig::hGetWinsW2K(
    CInstance *a_pInst, 
    DWORD a_dwIndex,
    CHString& a_chstrRootDevice,
    CHString& a_chstrIpInterfaceKey)
{
	DWORD		t_dwDNSOverWINS = 0;
	DWORD		t_dwLMLookups	= 0;
	CHString	t_chPrimaryWINSServer ;
	CHString	t_chSecondaryWINSServer ;
	CHString	t_chScopeID ;
	LONG		t_lRes ;
	HRESULT		t_hError ;

	// link name for binding to the adapter
	CHString t_csNBInterfaceKey ;
	CHString t_csNBLink ;
    bool fGotNtNBKey = false;

	fGotNtNBKey = fGetNtNBRegAdapterKey(
        a_dwIndex, 
        t_csNBInterfaceKey, 
        t_csNBLink);

    // This may be a RAS connection, in which
    // case the NB info is in a different
    // location.  So try that before giving up...
    if(!fGotNtNBKey)
    {
        if(a_chstrRootDevice.CompareNoCase(L"NdisWanIp") == 0)
        {
            int iPos = a_chstrIpInterfaceKey.Find(L"{");
            if(iPos != -1)
            {
                t_csNBLink = L"Tcpip_";
                t_csNBLink += a_chstrIpInterfaceKey.Mid(iPos);

                // Also fill in the NBInterfaceKey...
                t_csNBInterfaceKey = SERVICES_HOME ;
			    t_csNBInterfaceKey += L"\\NetBT\\Parameters\\Interfaces\\";
                t_csNBInterfaceKey += t_csNBLink;

                fGotNtNBKey = true;
            }     
        }
    }

    if(!fGotNtNBKey)
	{
		LogErrorMessage(L"Call to fGetNtNBRegAdapterKey failed");
        return E_RET_OBJECT_NOT_FOUND ;
	}
	else
	{
		// Win servers from the WINS driver
		if( fGetWinsServers( t_csNBLink, t_chPrimaryWINSServer, t_chSecondaryWINSServer ) )
		{
			// load up the instance
			if(t_chPrimaryWINSServer.GetLength() > 0)
            {
               if( !a_pInst->SetCHString( PRIMARY_WINS_SERVER, t_chPrimaryWINSServer) )
			    {
				    return WBEM_E_FAILED;
			    }
            }

			if(t_chSecondaryWINSServer.GetLength() > 0)
            {
                if(	!a_pInst->SetCHString( SECONDARY_WINS_SERVER, t_chSecondaryWINSServer) )
			    {
				    return WBEM_E_FAILED;
			    }
            }
		}

		// Parameters\interfaces
		CRegistry t_oRegNBTInterface ;

		if( SUCCEEDED( t_oRegNBTInterface.Open( HKEY_LOCAL_MACHINE,
												t_csNBInterfaceKey.GetBuffer( 0 ),
												KEY_READ ) ) )
		{
			// NetbiosOptions
			DWORD t_dwNetBiosOptions ;
			if( ERROR_SUCCESS == t_oRegNBTInterface.GetCurrentKeyValue( RVAL_NETBT_NETBIOSOPTIONS,
																		t_dwNetBiosOptions ) )
			{
				if( !a_pInst->SetDWORD( TCPIP_NETBIOS_OPTIONS,
										t_dwNetBiosOptions ) )
				{
					return WBEM_E_FAILED;
				}
			}
		}
	}

	// Open registry for the NetBT parameters
	CHString	t_csNBTBindingKey =  SERVICES_HOME ;
				t_csNBTBindingKey += NETBT_PARAMETERS ;

	CRegistry t_oRegNBTParams ;

	t_lRes = t_oRegNBTParams.Open( HKEY_LOCAL_MACHINE, t_csNBTBindingKey.GetBuffer( 0 ), KEY_READ ) ;

	// on error map to WBEM
	t_hError = WinErrorToWBEMhResult( t_lRes ) ;
	if( WBEM_S_NO_ERROR != t_hError )
	{
		return t_hError;
	}

	// load the registry
	t_oRegNBTParams.GetCurrentKeyValue( RVAL_DNS_ENABLE_WINS,	t_dwDNSOverWINS ) ;
	t_oRegNBTParams.GetCurrentKeyValue( RVAL_DNS_ENABLE_LMHOST,	t_dwLMLookups ) ;
	t_oRegNBTParams.GetCurrentKeyValue( RVAL_SCOPEID,			t_chScopeID ) ;

	if( !a_pInst->Setbool( DNS_OVER_WINS, (bool)( t_dwDNSOverWINS ? true : false ) ) )
	{
		return WBEM_E_FAILED;
	}

	if(	!a_pInst->Setbool( WINS_ENABLE_LMHOSTS, (bool)( t_dwLMLookups ? true : false ) ) )
	{
		return WBEM_E_FAILED;
	}

	if(	!a_pInst->SetCHString( SCOPE_ID, t_chScopeID ) )
	{
		return WBEM_E_FAILED;
	}

	return S_OK ;
}




/*******************************************************************
    NAME:       hSetTcpipNetbios

    SYNOPSIS:   Sets Netbios options for W2k

    ENTRY:      CMParms		:

  	NOTES:		This is a non static, instance dependent method call

    HISTORY:
                  20-Nov-1999     Created
********************************************************************/

HRESULT CWin32NetworkAdapterConfig::hSetTcpipNetbios( CMParms &a_rMParms )
{
	// nonstatic method requires an instance
	if( !a_rMParms.pInst() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// collect the instance
	GetObject( a_rMParms.pInst() ) ;

	// IP must be enabled and bound to this adapter
	if( !fIsIPEnabled( a_rMParms ) )
	{
		return S_OK;
	}

	// obtain the Netbios option
	DWORD t_dwOption ;
	if( !a_rMParms.pInParams() || !a_rMParms.pInParams()->GetDWORD( TCPIP_NETBIOS_OPTIONS, t_dwOption ) )
	{
		return a_rMParms.hSetResult( E_RET_INSTANCE_CALL_FAILED ) ;
	}

	// asking for Netbios setting via DHCP?
	if( UNSET_Netbios == t_dwOption )
	{
		// DHCP must be enabled for this adapter
		if( !fIsDhcpEnabled( a_rMParms ) )
		{
			return S_OK;
		}
	}

	// obtain the index key
	DWORD t_dwIndex ;
	if( !a_rMParms.pInst()->GetDWORD( _T("Index"), t_dwIndex ) )
	{
		return a_rMParms.hSetResult( E_RET_INSTANCE_CALL_FAILED ) ;
	}

	return a_rMParms.hSetResult( eSetNetBiosOptions( t_dwOption, t_dwIndex ) ) ;

}

/*******************************************************************
    NAME:       eSetNetBiosOptions

    SYNOPSIS:   Sets Netbios options for W2k

    ENTRY:      WORD a_dwOption, DWORD a_dwIndex		:

  	NOTES:

    HISTORY:
                  20-Nov-1999     Created
********************************************************************/

E_RET CWin32NetworkAdapterConfig::eSetNetBiosOptions( DWORD a_dwOption, DWORD a_dwIndex )
{
	E_RET t_eRet ;

	if( ( UNSET_Netbios != a_dwOption ) &&
		( ENABLE_Netbios != a_dwOption ) &&
		( DISABLE_Netbios != a_dwOption ) )
	{
		t_eRet = E_RET_PARAMETER_BOUNDS_ERROR ;
	}
	else
	{
		// link name for binding to the adapter
		CHString t_csNBBindingKey ;
		CHString t_csNBLink ;
		if( !fGetNtNBRegAdapterKey( a_dwIndex, t_csNBBindingKey, t_csNBLink ) )
		{
			LogErrorMessage(L"Call to fGetNtNBRegAdapterKey failed");
            t_eRet = E_RET_OBJECT_NOT_FOUND ;
		}
		else
		{
			// registry open
			CRegistry	t_oRegNBTAdapter;
			HRESULT		t_hRes = t_oRegNBTAdapter.Open( HKEY_LOCAL_MACHINE,
														t_csNBBindingKey.GetBuffer( 0 ),
														KEY_WRITE  ) ;

			if( ERROR_SUCCESS == t_hRes )
			{
				t_hRes = t_oRegNBTAdapter.SetCurrentKeyValue( RVAL_NETBT_NETBIOSOPTIONS, a_dwOption ) ;
			}

			if( ERROR_SUCCESS != t_hRes )
			{
				t_eRet = E_RET_REGISTRY_FAILURE ;
			}
			else
			{
				// NDIS notification
				CNdisApi t_oNdisApi ;
				if( t_oNdisApi.PnpUpdateNbtAdapter( t_csNBLink ) )
				{
					t_eRet = E_RET_OK ;
				}
				else
				{
					t_eRet = E_RET_OK_REBOOT_REQUIRED ;
				}
			}
		}
	}

	return t_eRet ;
}



/*******************************************************************
    NAME:       hEnableWINSServer

    SYNOPSIS:   Sets all adapter independent WINS properties to the registry

    ENTRY:      CMParms		:

  	NOTES:		This is a non static, instance dependent method call

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/

HRESULT CWin32NetworkAdapterConfig::hEnableWINSServer( CMParms &a_rMParms )
{


	CHString	t_chPrimaryWINSServer ;
	CHString	t_chSecondaryWINSServer ;

	// nonstatic method requires an instance
	if( !a_rMParms.pInst() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// collect the instance
	GetObject( a_rMParms.pInst() ) ;

	// IP must be enabled and bound to this adapter
	if( !fIsIPEnabled( a_rMParms ) )
	{
		return S_OK;
	}

	if( !a_rMParms.pInParams() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE  ) ;
	}

	// Collect up the primary and secondary server
	if( !a_rMParms.pInParams()->GetCHString( PRIMARY_WINS_SERVER, t_chPrimaryWINSServer ) ||
		!a_rMParms.pInParams()->GetCHString( SECONDARY_WINS_SERVER, t_chSecondaryWINSServer ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	/* Validate primary and secondary server */
	int t_iPLen = t_chPrimaryWINSServer.GetLength( ) ;
	int t_iSLen = t_chSecondaryWINSServer.GetLength( ) ;

	if( !t_iPLen && t_iSLen )
	{
		return a_rMParms.hSetResult( E_RET_WINS_SEC_NO_PRIME ) ;
	}

 	if( ( t_iPLen && !fIsValidIP( t_chPrimaryWINSServer ) ) ||
		( t_iSLen && !fIsValidIP( t_chSecondaryWINSServer ) ) )
	{
		return a_rMParms.hSetResult( E_RET_IP_INVALID  ) ;
	}

	// obtain the index key
	DWORD t_dwIndex ;
	if( !a_rMParms.pInst()->GetDWORD( _T("Index"), t_dwIndex ) )
	{
		return a_rMParms.hSetResult( E_RET_INSTANCE_CALL_FAILED ) ;
	}

	// link name for binding to the adapter
	CHString t_csNBBindingKey ;
	CHString t_csNBLink ;
	if( !fGetNtNBRegAdapterKey( t_dwIndex, t_csNBBindingKey, t_csNBLink ) )
	{
		LogErrorMessage(L"Call to fGetNtNBRegAdapterKey failed");
        return a_rMParms.hSetResult( E_RET_OBJECT_NOT_FOUND ) ;
	}

	// registry open
	CRegistry	t_oRegNBTAdapter;
	HRESULT		t_hRes = t_oRegNBTAdapter.Open( HKEY_LOCAL_MACHINE, t_csNBBindingKey.GetBuffer( 0 ), KEY_WRITE  ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}


	{
		// Under W2k Wins Servers are in a MULTI_SZ
		CHStringArray	t_chsaServers ;

		t_chsaServers.Add( t_chPrimaryWINSServer ) ;
		t_chsaServers.Add( t_chSecondaryWINSServer ) ;

		t_oRegNBTAdapter.SetCurrentKeyValue( L"NameServerList", t_chsaServers ) ;

		// NDIS notification
		CNdisApi t_oNdisApi ;
		if( !t_oNdisApi.PnpUpdateNbtAdapter( t_csNBLink ) )
		{
			return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
		}
	}

	return a_rMParms.hSetResult( E_RET_OK ) ;

}

/*******************************************************************
    NAME:       hEnableWINS

    SYNOPSIS:   Sets all adapter independent WINS properties to the registry

    ENTRY:      CMParms		:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/

HRESULT CWin32NetworkAdapterConfig::hEnableWINS( CMParms &a_rMParms )
{


	CHString	t_csBindingKey;
	CRegistry	t_oRegNBTParams ;

	CHString	t_chWINSHostLookupFile ;
	CHString	t_chScopeID ;
	CHString	t_ServiceName ;
	DWORD		t_dwValidBits = NULL ;

	if( !a_rMParms.pInParams() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE  ) ;
	}

	// DNS over WINS?
	bool t_fDNSOverWINS = false ;
	if( a_rMParms.pInParams()->Getbool( DNS_OVER_WINS, t_fDNSOverWINS ) )
	{
		t_dwValidBits |= 0x01 ;
	}

	// Lookup enabled?
	bool t_fLMLookups = false ;
	if( a_rMParms.pInParams()->Getbool( WINS_ENABLE_LMHOSTS, t_fLMLookups ) )
	{
		t_dwValidBits |= 0x02 ;
	}

	// Get the Lookup source file
	if( a_rMParms.pInParams()->GetCHString( WINS_HOST_LOOKUP_FILE, t_chWINSHostLookupFile) )
	{
		t_dwValidBits |= 0x04 ;
	}

	// Scope ID
	if( a_rMParms.pInParams()->GetCHString( SCOPE_ID, t_chScopeID ) )
	{
		t_dwValidBits |= 0x08 ;
	}

	if( !t_dwValidBits )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE  ) ;
	}

	// Open the NetBT registry if nessicary
	if( t_dwValidBits & ( 0x01 | 0x02 | 0x08 ) )
	{
		t_csBindingKey =  SERVICES_HOME ;
		t_csBindingKey += NETBT_PARAMETERS ;

		// registry open
		HRESULT t_hRes = t_oRegNBTParams.Open(HKEY_LOCAL_MACHINE, t_csBindingKey.GetBuffer( 0 ), KEY_WRITE ) ;
		if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
		{
			return TO_CALLER;
		}
	}

	if( t_dwValidBits & 0x01 )
	{
		// load the registry
		DWORD t_dwDNSOverWINS = t_fDNSOverWINS ;
		t_oRegNBTParams.SetCurrentKeyValue( RVAL_DNS_ENABLE_WINS, t_dwDNSOverWINS ) ;
	}

	DWORD t_dwLMLookups ;
	if( t_dwValidBits & 0x02 )
	{
		t_dwLMLookups = t_fLMLookups ;
		t_oRegNBTParams.SetCurrentKeyValue( RVAL_DNS_ENABLE_LMHOST,	t_dwLMLookups ) ;
	}
	else
	{
		t_oRegNBTParams.GetCurrentKeyValue( RVAL_DNS_ENABLE_LMHOST,	t_dwLMLookups ) ;
	}


	if( t_dwValidBits & 0x04 )
	{
		// Try copy
		if( t_chWINSHostLookupFile.GetLength() )
		{
			CRegistry	t_oRegistry ;
			CHString	t_csBindingKey =  SERVICES_HOME ;
						t_csBindingKey += TCPIP_PARAMETERS ;

			// registry open
			HRESULT t_hRes = t_oRegistry.Open( HKEY_LOCAL_MACHINE, t_csBindingKey.GetBuffer( 0 ), KEY_READ  ) ;
			if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
			{
				return TO_CALLER ;
			}
			TCHAR t_szTemp[ 2 * MAX_PATH ] ;

			// database path
			CHString t_chsDBPath ;
			if( ERROR_SUCCESS == t_oRegistry.GetCurrentKeyValue( RVAL_DB_PATH, t_chsDBPath ) )
			{
				// expand system string(s)
				DWORD t_dwcount = ExpandEnvironmentStrings( t_chsDBPath.GetBuffer( 0 ), t_szTemp, 2 * MAX_PATH  ) ;
				if( !t_dwcount )
				{
					return a_rMParms.hSetResult( E_RET_SYSTEM_PATH_INVALID ) ;
				}
				t_chsDBPath = t_szTemp ;
			}
			else
			{
				// System path valid?
				if( !GetSystemDirectory( t_szTemp, 2 * MAX_PATH ) )	\
				{
					return a_rMParms.hSetResult( E_RET_SYSTEM_PATH_INVALID ) ;
				}
				t_chsDBPath = t_szTemp ;
				t_chsDBPath += LMHOSTS_PATH ;
			}
			t_chsDBPath += LMHOSTS_FILE ;

			// File valid?
			DWORD t_dwAttrib = GetFileAttributes( t_chWINSHostLookupFile.GetBuffer( 0 ) ) ;
			if( 0xFFFFFFFF == t_dwAttrib || FILE_ATTRIBUTE_DIRECTORY & t_dwAttrib )
			{
				return a_rMParms.hSetResult( E_RET_INVALID_FILE ) ;
			}

			// Copy ...
			if( !CopyFile( t_chWINSHostLookupFile.GetBuffer( 0 ), t_chsDBPath.GetBuffer( 0 ), FALSE ) )
			{
				// map error
				fMapResError( a_rMParms, GetLastError(), E_RET_FILE_COPY_FAILED ) ;
				return TO_CALLER ;
			}
		}
	}

	// Scope ID
	if( t_dwValidBits & 0x08 )
	{
		t_oRegNBTParams.SetCurrentKeyValue( RVAL_SCOPEID, t_chScopeID ) ;
	}

	E_RET t_eRet = E_RET_OK ;

	{
		// NDIS notification
		if( t_dwValidBits & ( 0x02 | 0x04 ) )
		{
			CNdisApi t_oNdisApi ;
			if( !t_oNdisApi.PnpUpdateNbtGlobal( t_dwLMLookups, t_dwValidBits & 0x04 ) )
			{
				t_eRet = E_RET_OK_REBOOT_REQUIRED ;
			}
		}
	}

	return a_rMParms.hSetResult( t_eRet ) ;

}

/*******************************************************************
    NAME:       hGetNtIpSec

    SYNOPSIS:   Retrieves all IP Security settings from the registry

    ENTRY:      CInstance

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/


HRESULT CWin32NetworkAdapterConfig::hGetNtIpSec( CInstance *a_pInst, LPCTSTR a_szKey )
{
	DWORD		t_dwSecurityEnabled		= FALSE ;
	SAFEARRAY	*t_PermitTCPPorts		= NULL ;
	SAFEARRAY	*t_PermitUDPPorts		= NULL ;
	SAFEARRAY	*t_PermitIPProtocols	= NULL ;

	// register for stack scope cleanup of SAFEARRAYs
	saAutoClean acTCPPorts( &t_PermitTCPPorts ) ;
	saAutoClean acUDPPorts( &t_PermitUDPPorts ) ;
	saAutoClean acTCPProto( &t_PermitIPProtocols ) ;

	CRegistry	t_oTcpipReg;
	CHString	t_chsTcpipKey =  SERVICES_HOME ;
				t_chsTcpipKey += TCPIP_PARAMETERS ;

	// tcpip registry open
	LONG t_lRes = t_oTcpipReg.Open( HKEY_LOCAL_MACHINE, t_chsTcpipKey.GetBuffer( 0 ), KEY_READ  ) ;

	// on error map to WBEM
	HRESULT t_hError = WinErrorToWBEMhResult( t_lRes ) ;
	if( WBEM_S_NO_ERROR != t_hError )
	{
		return t_hError;
	}

	// Global security setting
	t_dwSecurityEnabled = FALSE ;
	t_oTcpipReg.GetCurrentKeyValue( RVAL_SECURITY_ENABLE, t_dwSecurityEnabled ) ;

	// update the instance
	if(	!a_pInst->Setbool( IP_SECURITY_ENABLED, (bool)( t_dwSecurityEnabled ? true : false ) ) )
	{
		return WBEM_E_FAILED ;
	}

	CRegistry t_oRegistry;
	t_lRes = t_oRegistry.Open( HKEY_LOCAL_MACHINE, a_szKey, KEY_READ ) ;

	// on error map to WBEM
	t_hError = WinErrorToWBEMhResult( t_lRes ) ;
	if( WBEM_S_NO_ERROR != t_hError )
	{
		return t_hError;
	}

	RegGetStringArray( t_oRegistry, RVAL_SECURITY_TCP, &t_PermitTCPPorts, '\n' ) ;
	RegGetStringArray( t_oRegistry, RVAL_SECURITY_UDP, &t_PermitUDPPorts, '\n' ) ;
	RegGetStringArray( t_oRegistry, RVAL_SECURITY_IP, &t_PermitIPProtocols, '\n' ) ;

	// update the instance
	VARIANT t_vValue;

	V_VT( &t_vValue ) = VT_BSTR | VT_ARRAY; V_ARRAY( &t_vValue ) = t_PermitTCPPorts ;
	if( !a_pInst->SetVariant( PERMIT_TCP_PORTS, t_vValue ) )
	{
		return WBEM_E_FAILED ;
	}

	V_VT( &t_vValue) = VT_BSTR | VT_ARRAY; V_ARRAY( &t_vValue ) = t_PermitUDPPorts ;
	if( !a_pInst->SetVariant( PERMIT_UDP_PORTS, t_vValue ) )
	{
		return WBEM_E_FAILED ;
	}

	V_VT( &t_vValue ) = VT_BSTR | VT_ARRAY; V_ARRAY( &t_vValue ) = t_PermitIPProtocols ;
	if( !a_pInst->SetVariant( PERMIT_IP_PROTOCOLS, t_vValue ) )
	{
		return WBEM_E_FAILED ;
	}

	return S_OK ;
}



/*******************************************************************
    NAME:       hEnableIPFilterSec

    SYNOPSIS:   Enables or disables IP Security across all IP bound adapters

    ENTRY:      CMParms

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/

HRESULT CWin32NetworkAdapterConfig::hEnableIPFilterSec( CMParms &a_rMParms )
{

	CRegistry	t_oReg;
	CHString	t_chsSKey =  SERVICES_HOME ;
				t_chsSKey += TCPIP_PARAMETERS ;

	bool t_fIP_SecEnabled ;

	// IP security enabled globally?
	if( !a_rMParms.pInParams() ||
		!a_rMParms.pInParams()->Getbool( IP_SECURITY_ENABLED, t_fIP_SecEnabled ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// registry open
	HRESULT t_hRes = t_oReg.Open(HKEY_LOCAL_MACHINE, t_chsSKey.GetBuffer( 0 ), KEY_WRITE  ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}
	// load the registry
	DWORD t_dwSecurityEnabled = t_fIP_SecEnabled ;
	if( ERROR_SUCCESS != t_oReg.SetCurrentKeyValue( RVAL_SECURITY_ENABLE, t_dwSecurityEnabled ) )
	{
		return a_rMParms.hSetResult(E_RET_REGISTRY_FAILURE ) ;
	}

	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;

}

/*******************************************************************
    NAME:       hEnableIPSec

    SYNOPSIS:   Sets all IP Security properties to the registry

    ENTRY:      CMParms via CInstance depending on the context of the call

  	NOTES:		This is a non-static, instance dependent method call

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/

HRESULT CWin32NetworkAdapterConfig::hEnableIPSec( CMParms &a_rMParms )
{

    E_RET		t_eRet ;
	SAFEARRAY	*t_PermitTCPPorts		= NULL ;
	SAFEARRAY	*t_PermitUDPPorts		= NULL ;
	SAFEARRAY	*t_PermitIPProtocols	= NULL ;

	// register for stack scope cleanup of SAFEARRAYs
	saAutoClean acTCPPorts( &t_PermitTCPPorts ) ;
	saAutoClean acUDPPorts( &t_PermitUDPPorts ) ;
	saAutoClean acTCPProto( &t_PermitIPProtocols ) ;

	// nonstatic method requires an instance
	if( !a_rMParms.pInst() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}
	// collect the instance
	GetObject( a_rMParms.pInst() ) ;

	// IP must be enabled and bound to this adapter
	if( !fIsIPEnabled( a_rMParms ) )
	{
		return S_OK ;
	}

	if( !a_rMParms.pInParams() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE  ) ;
	}

	//	retrieve the permited TCP ports
	if(	a_rMParms.pInParams()->GetStringArray( PERMIT_TCP_PORTS, t_PermitTCPPorts ) )
	{
		// validate
		t_eRet = eValidateIPSecParms( t_PermitTCPPorts, 65535 ) ;

		if( E_RET_OK != t_eRet )
		{
			return a_rMParms.hSetResult( t_eRet ) ;
		}
	}

	//	retrieve the permited UDP ports
	if(	a_rMParms.pInParams()->GetStringArray( PERMIT_UDP_PORTS, t_PermitUDPPorts ) )
	{
		// validate
		t_eRet = eValidateIPSecParms( t_PermitUDPPorts, 65535 ) ;

		if( E_RET_OK != t_eRet )
		{
			return a_rMParms.hSetResult( t_eRet ) ;
		}
	}

	//	retrieve the permited IP protocols
	if(	a_rMParms.pInParams()->GetStringArray( PERMIT_IP_PROTOCOLS, t_PermitIPProtocols ) )
	{
		// validate
		t_eRet = eValidateIPSecParms( t_PermitIPProtocols, 255 ) ;

		if( E_RET_OK != t_eRet )
		{
			return a_rMParms.hSetResult( t_eRet ) ;
		}
	}

	// on empty call
	if( !t_PermitTCPPorts && !t_PermitUDPPorts && !t_PermitIPProtocols )
	{
		return a_rMParms.hSetResult(E_RET_INVALID_SECURITY_PARM ) ;
	}

	// OK to update, save to the registry
	CRegistry t_oRegPut ;

	// extract the index key
	DWORD t_dwIndex ;
	if(	!a_rMParms.pInst()->GetDWORD(_T("Index"), t_dwIndex) )
	{
		return a_rMParms.hSetResult(E_RET_INSTANCE_CALL_FAILED ) ;
	}

	// Registry open
	CHString t_chsRegKey;
	CHString t_chsLink;
	if( !fGetNtTcpRegAdapterKey( t_dwIndex, t_chsRegKey, t_chsLink ) )
	{
		LogErrorMessage(L"Call to fGetNtTcpRegAdapterKey failed");
        return a_rMParms.hSetResult(E_RET_OBJECT_NOT_FOUND ) ;
	}

	HRESULT t_hRes = t_oRegPut.Open( HKEY_LOCAL_MACHINE, t_chsRegKey, KEY_WRITE  ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER ;
	}

	if( t_PermitTCPPorts )
	{
		if( ERROR_SUCCESS != RegPutStringArray( t_oRegPut, RVAL_SECURITY_TCP, *t_PermitTCPPorts, NULL ) )
		{
			return a_rMParms.hSetResult( E_RET_REGISTRY_FAILURE  ) ;
		}
	}

	if( t_PermitUDPPorts )
	{
		if( ERROR_SUCCESS != RegPutStringArray( t_oRegPut, RVAL_SECURITY_UDP, *t_PermitUDPPorts, NULL ) )
		{
			return a_rMParms.hSetResult( E_RET_REGISTRY_FAILURE  ) ;
		}
	}

	if( t_PermitIPProtocols )
	{
		if(	ERROR_SUCCESS != RegPutStringArray( t_oRegPut, RVAL_SECURITY_IP, *t_PermitIPProtocols, NULL ) )
		{
			return a_rMParms.hSetResult( E_RET_REGISTRY_FAILURE  ) ;
		}
	}

	// TODO: notifications? what else ...
	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;

}

/*******************************************************************
    NAME:       hDisableIPSec

    SYNOPSIS:   Sets all IP Security properties to the registry

    ENTRY:      CMParms via CInstance depending on the context of the call

  	NOTES:		This is a non-static, instance dependent method call

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/

HRESULT CWin32NetworkAdapterConfig::hDisableIPSec( CMParms &a_rMParms )
{


	// nonstatic method requires an instance
	if( !a_rMParms.pInst() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// collect the instance
	GetObject(a_rMParms.pInst() ) ;

	// IP must be enabled and bound to this adapter
	if( !fIsIPEnabled( a_rMParms ) )
	{
		return S_OK ;
	}

	// OK to update, save to the registry

	// extract the index key
	DWORD t_dwIndex ;
	if(	!a_rMParms.pInst()->GetDWORD( _T("Index"), t_dwIndex) )
	{
		return a_rMParms.hSetResult(E_RET_INSTANCE_CALL_FAILED ) ;
	}

	// Registry open
	CHString t_chsRegKey ;
	CHString t_chsLink ;
	if( !fGetNtTcpRegAdapterKey( t_dwIndex, t_chsRegKey, t_chsLink ) )
	{
		LogErrorMessage(L"Call to fGetNtTcpRegAdapterKey failed");
        return a_rMParms.hSetResult( E_RET_OBJECT_NOT_FOUND ) ;
	}

	CRegistry t_oRegPut ;
	HRESULT hRes = t_oRegPut.Open(HKEY_LOCAL_MACHINE, t_chsRegKey, KEY_WRITE ) ;
	if( fMapResError( a_rMParms, hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER ;
	}

	// load the registry

	CHString		t_chsZero( _T("0") ) ;
	CHStringArray	t_chsaZero ;
					t_chsaZero.Add( t_chsZero ) ;

	t_oRegPut.SetCurrentKeyValue( RVAL_SECURITY_TCP, t_chsaZero ) ;
	t_oRegPut.SetCurrentKeyValue( RVAL_SECURITY_UDP, t_chsaZero ) ;
	t_oRegPut.SetCurrentKeyValue( RVAL_SECURITY_IP, t_chsaZero ) ;

	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;

}

/*******************************************************************
    NAME:       eValidateIPSecParms

    SYNOPSIS:   Tests each IP security parm for validity

    ENTRY:      SAFEARRAY*

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/

E_RET CWin32NetworkAdapterConfig::eValidateIPSecParms( SAFEARRAY * a_IpArray, int a_iMax )
{
	// Get the IP bounds
	LONG t_uLBound = 0 ;
	LONG t_uUBound = 0 ;

	if( 1 != SafeArrayGetDim( a_IpArray ) )
	{
		return E_RET_INVALID_SECURITY_PARM ;
	}

	if( S_OK != SafeArrayGetLBound( a_IpArray, 1, &t_uLBound ) ||
		S_OK != SafeArrayGetUBound( a_IpArray, 1, &t_uUBound ) )
	{
		return E_RET_INVALID_SECURITY_PARM ;
	}

	// validate the IP ports
	for( LONG t_ldx = t_uLBound; t_ldx <= t_uUBound; t_ldx++ )
	{
		BSTR t_bsParm = NULL ;

		SafeArrayGetElement( a_IpArray,	&t_ldx, &t_bsParm ) ;
		bstr_t t_bstrParm( t_bsParm, FALSE ) ;

		int t_iLen  = t_bstrParm.length() ;

		// indicates no ports
		if( !t_iLen )
		{
			return E_RET_OK;
		}

		int t_iSpan = wcsspn( (wchar_t*)t_bstrParm, L"0123456789" ) ;
		if( t_iLen != t_iSpan )
		{
			return E_RET_PARAMETER_BOUNDS_ERROR ;
		}

		DWORD t_dwParm = _wtol( (wchar_t*)t_bstrParm ) ;

		// Single zero disables security
		if( ( t_uLBound == t_ldx ) && ( '0' == (char) t_dwParm ) )
		{
			return E_RET_OK ;
		}

		// max port or protocol size
		if( ( a_iMax < t_dwParm ) )
		{
			return E_RET_PARAMETER_BOUNDS_ERROR ;
		}
	}
	return E_RET_OK ;
}


/*******************************************************************
    NAME:       hValidateIPGateways

    SYNOPSIS:   Tests each IP gateway in the passed array for validity

    ENTRY:     	CMParms&,	SAFEARRAY*

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/

BOOL CWin32NetworkAdapterConfig::fValidateIPGateways(

CMParms &a_rMParms,
SAFEARRAY *a_IpGatewayArray,
SAFEARRAY **a_CostMetric )
{
	// Get the Gateway bounds
	LONG t_uGatewayLBound = 0 ;
	LONG t_uGatewayUBound = 0 ;

	if( 1 != SafeArrayGetDim( a_IpGatewayArray ) )
	{
		a_rMParms.hSetResult( E_RET_GATEWAY_IP_INVALID ) ;
		return FALSE;
	}

	if( !fValidateIPs( a_IpGatewayArray ) )
	{
		a_rMParms.hSetResult( E_RET_GATEWAY_IP_INVALID ) ;
		return FALSE ;
	}

	if( S_OK != SafeArrayGetLBound( a_IpGatewayArray, 1, &t_uGatewayLBound ) ||
		S_OK != SafeArrayGetUBound( a_IpGatewayArray, 1, &t_uGatewayUBound ) )
	{
		a_rMParms.hSetResult( E_RET_GATEWAY_IP_INVALID ) ;
		return FALSE ;
	}

	// Gateway maximum is 5
	if( 5 < t_uGatewayUBound - t_uGatewayLBound + 1 )
	{
		a_rMParms.hSetResult( E_RET_MORE_THAN_FIVE_GATEWAYS ) ;
		return FALSE ;
	}

	// cost metric
	if( IsWinNT5() )
	{
		UINT t_uCostMetricElements	= 0 ;
		UINT t_uGatewayElements		= t_uGatewayUBound - t_uGatewayLBound + 1;

		// Get the cost metric bounds
		LONG t_uCostLBound = 0 ;
		LONG t_uCostUBound = 0 ;

		// either validate it
		if( *a_CostMetric )
		{
			if( S_OK != SafeArrayGetLBound( *a_CostMetric, 1, &t_uCostLBound ) ||
				S_OK != SafeArrayGetUBound( *a_CostMetric, 1, &t_uCostUBound ) )
			{
				a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
				return FALSE ;
			}
			t_uCostMetricElements = t_uCostUBound - t_uCostLBound + 1;

			// one to one correspondence
			if( t_uCostMetricElements != t_uGatewayElements )
			{
				a_rMParms.hSetResult( E_RET_PARAMETER_BOUNDS_ERROR ) ;
				return FALSE ;
			}

			// validate the cost metric array
			DWORD t_dwIndex = 0 ;
			for( LONG t_lIndex = t_uCostLBound; t_lIndex <= t_uCostUBound; t_lIndex++ )
			{
				DWORD t_dwCostMetric ;

				SafeArrayGetElement( *a_CostMetric,	&t_lIndex, &t_dwCostMetric ) ;

				if( !t_dwCostMetric || ( 9999 < t_dwCostMetric ) )
				{
					a_rMParms.hSetResult( E_RET_PARAMETER_BOUNDS_ERROR ) ;
					return FALSE ;
				}
			}
		}
		// or build it
		else
		{
			SAFEARRAYBOUND t_rgsabound[ 1 ] ;
			long t_ix[ 1 ] ;

			t_rgsabound->cElements	= t_uGatewayElements ;
			t_rgsabound->lLbound	= 0 ;

			if( !( *a_CostMetric = SafeArrayCreate( VT_I4, 1, t_rgsabound ) ) )
			{
				throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
			}

			UINT t_uMetric = 1 ;
			for( UINT t_u = 0; t_u < t_uGatewayElements; t_u++ )
			{
				t_ix[ 0 ] = t_u ;
				SafeArrayPutElement( *a_CostMetric, &t_ix[0], &t_uMetric ) ;
			}
		}
	}

	return TRUE ;
}


/*******************************************************************
    NAME:       hValidateIPs

    SYNOPSIS:   Tests each IP in the passed array for validity

    ENTRY:      CMParms&,	SAFEARRAY*

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/

BOOL CWin32NetworkAdapterConfig::fValidateIPs( SAFEARRAY *a_IpArray )
{
	// Get the IP bounds
	LONG t_uLBound = 0 ;
	LONG t_uUBound = 0 ;

	if( 1 != SafeArrayGetDim( a_IpArray ) )
	{
		return FALSE;
	}

	if( S_OK != SafeArrayGetLBound( a_IpArray, 1, &t_uLBound ) ||
		S_OK != SafeArrayGetUBound( a_IpArray, 1, &t_uUBound ) )
	{
		return FALSE ;
	}

	// validate the IPs
	for( LONG t_ldx = t_uLBound; t_ldx <= t_uUBound; t_ldx++ )
	{
		BSTR t_bsIP = NULL ;

		SafeArrayGetElement( a_IpArray,	&t_ldx, &t_bsIP  ) ;
		bstr_t t_bstrIP( t_bsIP, FALSE ) ;

		if( !fIsValidIP( CHString( (wchar_t*) t_bstrIP ) ) )
		{
			return FALSE ;
		}
	}
	return TRUE ;
}

/*******************************************************************
    NAME:       fIsValidIP

    SYNOPSIS:   Determine if a passed IP is valid

    ENTRY:      CHString&

    HISTORY:
********************************************************************/

BOOL CWin32NetworkAdapterConfig::fIsValidIP( CHString &a_strIP )
{
	DWORD t_ardwIP[ 4 ] ;

	if( !fGetNodeNum( a_strIP, t_ardwIP ) )
	{
		return FALSE ;
	}

	// Most significant node must be 1 <= x <= 223
	if( ( 0 == t_ardwIP[ 0 ] ) || ( 223 < t_ardwIP[ 0 ] ) )
	{
		return FALSE ;
	}

	// no other outrageous stuff
	for( int t_i = 1; t_i < 4; t_i++ )
	{
		if( 255 < t_ardwIP[ t_i ] )
		{
			return FALSE ;
		}
	}

	return TRUE;
}

/*******************************************************************
    NAME:       fIsIPEnabled

    SYNOPSIS:   Determines if IP is enabled for the specific instance

    ENTRY:      CMParms		:

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/
BOOL CWin32NetworkAdapterConfig::fIsIPEnabled( CMParms &a_rMParms )
{
	bool t_fIP_Enabled = false ;

	// IP stack enabled on this adapter?
	if( !a_rMParms.pInst() ||
		!a_rMParms.pInst()->Getbool( L"IPEnabled", t_fIP_Enabled ) )
	{
		a_rMParms.hSetResult( E_RET_INSTANCE_CALL_FAILED ) ;
		return FALSE ;
	}

	if( !t_fIP_Enabled )
	{
		a_rMParms.hSetResult( E_RET_IP_NOT_ENABLED_ON_ADAPTER ) ;
		return FALSE ;
	}
	return TRUE ;
}

/*******************************************************************
    NAME:       fIsDhcpEnabled

    SYNOPSIS:   Determines if DHCP is enabled for the specific instance

    ENTRY:      CMParms		:

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/
BOOL CWin32NetworkAdapterConfig::fIsDhcpEnabled( CMParms &a_rMParms )
{
	bool t_fDHCP_Enabled = false ;

	// DHCP enabled on this adapter?
	if( !a_rMParms.pInst() ||
		!a_rMParms.pInst()->Getbool( L"DHCPEnabled", t_fDHCP_Enabled ) )
	{
		a_rMParms.hSetResult( E_RET_INSTANCE_CALL_FAILED ) ;
		return FALSE ;
	}

	if( !t_fDHCP_Enabled )
	{
		a_rMParms.hSetResult( E_RET_DHCP_NOT_ENABLED_ON_ADAPTER ) ;
		return FALSE ;
	}
	return TRUE ;
}

/*******************************************************************
    NAME:       fIsIPXEnabled

    SYNOPSIS:   Determines if IPX is enabled for the specific instance

    ENTRY:      CMParms		:

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/
BOOL CWin32NetworkAdapterConfig::fIsIPXEnabled( CMParms &a_rMParms )
{
	bool t_fIPX_Enabled = false ;

	// IP stack enabled on this adapter?
	if( !a_rMParms.pInst() ||
		!a_rMParms.pInst()->Getbool( L"IPXEnabled", t_fIPX_Enabled ) )
	{
		a_rMParms.hSetResult( E_RET_INSTANCE_CALL_FAILED ) ;
		return FALSE;
	}

	if( !t_fIPX_Enabled )
	{
		a_rMParms.hSetResult( E_RET_IPX_NOT_ENABLED_ON_ADAPTER ) ;
		return FALSE ;
	}
	return TRUE ;
}

//
DWORD CWin32NetworkAdapterConfig::dwEnableService( LPCTSTR a_lpServiceName, BOOL a_fEnable )
{
	DWORD		t_dwError		= ERROR_SUCCESS ;
	BOOL		t_fCheckError	= TRUE ;
	SC_HANDLE	t_hSCManager	= NULL ;
	SC_HANDLE	t_hService		= NULL ;
	SC_LOCK		t_hSMLock		= NULL ;

	try
	{
		do	{	// breakout loop

			if( !( t_hSCManager = OpenSCManager( NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS ) ) )
			{
				break ;
			}

			if( !( t_hSMLock = LockServiceDatabase( t_hSCManager ) ) )
			{
				break;
			}

			if( !( t_hService = OpenService(	t_hSCManager,
												a_lpServiceName,
												GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE ) ) )
			{
				break;
			}

			// change the startup configuration for this service
			if ( !ChangeServiceConfig(	t_hService,
										SERVICE_NO_CHANGE,
										a_fEnable ? SERVICE_AUTO_START : SERVICE_DISABLED,
										SERVICE_NO_CHANGE,
										NULL,
										NULL,
										NULL,
										NULL,
										NULL,
										NULL,
										NULL ) )
			{
				 break;
			}

			t_fCheckError = FALSE ;

		} while( FALSE ) ;

		if( t_fCheckError )
		{
			t_dwError = GetLastError() ;
		}

	}
	catch( ... )
	{
		if( t_hSMLock )
		{
			UnlockServiceDatabase( t_hSMLock ) ;
		}
		if( t_hSCManager )
		{
			CloseServiceHandle( t_hSCManager ) ;
		}
		if( t_hService )
		{
			CloseServiceHandle( t_hService ) ;
		}

		throw ;
	}

	if( t_hSMLock )
	{
		if( !UnlockServiceDatabase( t_hSMLock ) )
		{
			t_dwError = GetLastError() ;
		}
		t_hSMLock = NULL ;
	}
	if( t_hSCManager )
	{
		if( !CloseServiceHandle( t_hSCManager ) )
		{
			t_dwError = GetLastError() ;
		}
		t_hSCManager = NULL ;
	}
	if( t_hService )
	{
		if( !CloseServiceHandle( t_hService ) )
		{
			t_dwError = GetLastError() ;
		}
		t_hService = NULL ;
	}

	return t_dwError ;
}

//
DWORD CWin32NetworkAdapterConfig::dwSendServiceControl( LPCTSTR a_lpServiceName, DWORD a_dwControl )
{
	DWORD		t_dwError		= ERROR_SUCCESS ;
	BOOL		t_fCheckError	= TRUE ;
	SC_HANDLE	t_hSCManager	= NULL ;
	SC_HANDLE	t_hService		= NULL ;

	try
	{
		do	{	// breakout loop

			if( !( t_hSCManager = OpenSCManager( NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS ) ) )
			{
				break ;
			}

			if( !( t_hService = OpenService(	t_hSCManager,
												a_lpServiceName,
												SERVICE_ALL_ACCESS ) ) )
			{
				break;
			}


			SERVICE_STATUS t_status ;
			if( !ControlService ( t_hService, a_dwControl, &t_status ) )
			{
				break;
			}

			t_fCheckError = FALSE ;

		} while( FALSE ) ;

		if( t_fCheckError )
		{
			t_dwError = GetLastError() ;
		}

	}
	catch( ... )
	{
		if( t_hSCManager )
		{
			CloseServiceHandle( t_hSCManager ) ;
		}
		if( t_hService )
		{
			CloseServiceHandle( t_hService ) ;
		}

		throw ;
	}

	if( t_hSCManager )
	{
		if( !CloseServiceHandle( t_hSCManager ) )
		{
			t_dwError = GetLastError() ;
		}
		t_hSCManager = NULL ;
	}
	if( t_hService )
	{
		if( !CloseServiceHandle( t_hService ) )
		{
			t_dwError = GetLastError() ;
		}
		t_hService = NULL ;
	}

	return t_dwError ;
}

/*******************************************************************
    NAME:       fMapResError

    SYNOPSIS:	tests and maps a HRESULT to a method error via the
				WBEM mapping.


    ENTRY:      CMParms &a_rMParms,		:
				LONG lError,			:
				E_RET eDefaultError		:


    HISTORY:
                  23-Jul-1998     Created
********************************************************************/
BOOL CWin32NetworkAdapterConfig::fMapResError( CMParms &a_rMParms, LONG a_lError, E_RET a_eDefaultError )
{
	HRESULT t_hError = WinErrorToWBEMhResult( a_lError ) ;

	switch ( t_hError )
	{
		case WBEM_S_NO_ERROR:	return FALSE ;

		default:
		case WBEM_E_FAILED:			{ a_rMParms.hSetResult( a_eDefaultError ) ;			break ; }
		case WBEM_E_ACCESS_DENIED:	{ a_rMParms.hSetResult(E_RET_ACCESS_DENIED ) ;		break ; }
		case WBEM_E_OUT_OF_MEMORY:	{ a_rMParms.hSetResult(E_RET_OUT_OF_MEMORY ) ;		break ; }
		case WBEM_E_ALREADY_EXISTS:	{ a_rMParms.hSetResult(E_RET_ALREADY_EXISTS ) ;		break ; }
		case WBEM_E_NOT_FOUND:		{ a_rMParms.hSetResult(E_RET_OBJECT_NOT_FOUND ) ;	break ; }
	}
	return TRUE ;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  void CWin32NetworkAdapterConfig::vSetCaption( CInstance *a_pInst, CHString& rchsDesc, DWORD dwIndex, int iFormatSize )

 Description: Lays in the registry index instance id into the caption property.
			  Then concats the description
			  This will be used with the view provider to associacte WDM NDIS class instances
			  with an instance of this class

 Arguments:	a_pInst [IN], rchsDesc [IN], dwIndex [IN], iFormatSize [IN]
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:					  02-Oct-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
void CWin32NetworkAdapterConfig::vSetCaption(	CInstance *a_pInst,
												CHString &a_rchsDesc,
												DWORD a_dwIndex,
												int a_iFormatSize )
{
	CHString t_chsFormat;
			 t_chsFormat.Format( L"[%%0%uu] %%s", a_iFormatSize  ) ;

	CHString t_chsCaption;
			 t_chsCaption.Format(	t_chsFormat, a_dwIndex, a_rchsDesc  ) ;

	a_pInst->SetCHString( IDS_Caption, t_chsCaption  ) ;

	return;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  BOOL CWin32NetworkAdapterConfig::GetSettingID( CInstance *a_pInst, DWORD a_dwIndex )

 Description: populates CIM's setting ID

 Arguments:	a_pInst [IN], a_dwIndex [IN]

 Notes:		under NT5 this will be the adapter GUID
			under NT4 this will be the adapter service name
			under 9x  this will be the adapter index ID
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:					  19-May-1999     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

BOOL CWin32NetworkAdapterConfig::GetSettingID( CInstance *a_pInst, CW2kAdapterInstance *a_pAdapterInst )
{
	CHString	t_chsLink ;
	CHString t_chsRegKey ;

	if( fGetNtTcpRegAdapterKey( a_pAdapterInst->dwIndex, t_chsRegKey, t_chsLink ) )
	{

	}
    else
    {
        t_chsLink = a_pAdapterInst->chsNetCfgInstanceID;
    }

	a_pInst->SetCharSplat( L"SettingID", t_chsLink ) ;

	return TRUE ;
}

/*******************************************************************
    NAME:       fMapIndextoKey

    SYNOPSIS:   map the class key to the registry version of the adapter identifier

  	NOTES:

    ENTRY:       DWORD a_dwIndex, CHString &a_chsLinkKey

    HISTORY:
                  1-July-1999     Created
********************************************************************/

BOOL CWin32NetworkAdapterConfig::fMapIndextoKey(

DWORD a_dwIndex,
CHString &a_chsLinkKey
)
{
    CHString t_chsLinkField ;
	CHString t_chsAdapterKey ;
	CHString t_chsInstance ;
	BOOL	 t_fRc = FALSE ;

	if (a_dwIndex == (0x0000FFFF & a_dwIndex))
	{
		t_chsLinkField = _T("NetCfgInstanceID" ) ;
		t_chsAdapterKey = _T("SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}\\" ) ;
		t_chsInstance.Format( _T("%04u"), a_dwIndex  ) ;

		t_chsAdapterKey += t_chsInstance ;

		// obtain the link key for targeting the tcp adapter
		CRegistry t_Reg;
		if( t_Reg.OpenLocalMachineKeyAndReadValue( t_chsAdapterKey, t_chsLinkField, a_chsLinkKey ) == ERROR_SUCCESS )
		{
			t_fRc = TRUE ;
		}
		else
		{
		    LogErrorMessage4(
		        L"Failed to open registry key. \r\nchsAdapterKey=%s\r\nchsLinkField=%s\r\nchsLinkKey=%s",
		        (LPCWSTR)t_chsAdapterKey,
		        (LPCWSTR)t_chsLinkField,
		        (LPCWSTR)a_chsLinkKey);
		}		
	}
	else
	{
	    DWORD dwIndexIface = a_dwIndex & 0xFFFF ;

	    CRegistry t_RegAdaptersNdisWanIp;
	    CHStringArray t_chsaInterfaces;

		if( ERROR_SUCCESS != t_RegAdaptersNdisWanIp.Open( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Services\\TCPIP\\Parameters\\Adapters\\NdisWanIp"), KEY_READ ) ) return FALSE;
		if( ERROR_SUCCESS != t_RegAdaptersNdisWanIp.GetCurrentKeyValue( _T("IpConfig"), t_chsaInterfaces ) ) return FALSE;

        if (dwIndexIface > t_chsaInterfaces.GetSize()) return FALSE;

		WCHAR * pBegin = (WCHAR*)(LPCWSTR)t_chsaInterfaces.GetAt(dwIndexIface);
		WCHAR * pBrace = wcschr(pBegin,L'{');
		if (NULL == pBrace) return FALSE;

	    a_chsLinkKey = CHString(pBrace);

	    t_fRc = TRUE;
	}

	return t_fRc ;
}

/*******************************************************************
    NAME:       fGetNtTcpRegAdapterKey

    SYNOPSIS:   develops a registry path to the TCP adapter by index

  	NOTES:

    ENTRY:       DWORD dwIndex, CHString& chsRegKey, CHString& chsLinkKey

    HISTORY:
                  30-Nov-1998     Created
********************************************************************/

BOOL CWin32NetworkAdapterConfig::fGetNtTcpRegAdapterKey(	DWORD a_dwIndex,
															CHString &a_chsRegKey,
															CHString &a_chsLinkKey )
{
	BOOL t_fRc = FALSE ;

	if( fMapIndextoKey(	a_dwIndex, a_chsLinkKey ) )
	{
		a_chsRegKey = _T("SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\" ) ;
		a_chsRegKey += a_chsLinkKey;

		t_fRc = TRUE ;
	}

	return t_fRc ;
}


/*******************************************************************
    NAME:       IsConfigurableTcpInterface

    SYNOPSIS:   Determines if a w2k interface is configurable
				by attempting to locate the interace in the Adapters section
				of the TCP

  	NOTES:		NdisWanIp will not show up as configurable, by design.

    ENTRY:      CHString a_chsLink

    HISTORY:
                  17-Jun-1999     Created
********************************************************************/

bool CWin32NetworkAdapterConfig::IsConfigurableTcpInterface( CHString a_chsLink )
{
	bool		t_fRet = false ;
	CRegistry	t_Reg;
	CHString	t_chsRegParmKey ;

	if( IsWinNT5() )
	{
		t_chsRegParmKey = _T("SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Adapters\\" ) ;
		t_chsRegParmKey	+= a_chsLink;
	}
	else
	{
		t_chsRegParmKey = _T("SYSTEM\\CurrentControlSet\\Services\\" ) ;
		t_chsRegParmKey	+= a_chsLink;
		t_chsRegParmKey	+= _T("\\Parameters\\Tcpip" ) ;
	}

	if( t_Reg.Open(HKEY_LOCAL_MACHINE, t_chsRegParmKey, KEY_READ ) == ERROR_SUCCESS )
	{
		t_fRet = true ;
	}

	return t_fRet ;
}


/*******************************************************************
    NAME:       fGetNtIpxRegAdapterKey

    SYNOPSIS:   develops a registry path to the IPX adapter by index

  	NOTES:

    ENTRY:       DWORD dwIndex, CHString& chsRegKey
    HISTORY:
                  03-MAR-1999     Created
********************************************************************/

BOOL CWin32NetworkAdapterConfig::fGetNtIpxRegAdapterKey(	DWORD a_dwIndex,
															CHString &a_csIPXNetBindingKey,
															CHString &a_chsLink )
{
	BOOL t_fRc = FALSE ;

	// retrieve the adapter identifier
	if( fMapIndextoKey( a_dwIndex, a_chsLink ) )
	{
		// build up the registry key
		a_csIPXNetBindingKey =  SERVICES_HOME ;
		a_csIPXNetBindingKey += IPX ;

		if( IsWinNT5() )
		{
			 a_csIPXNetBindingKey += _T("\\Parameters\\Adapters\\") ;
		}
		else	// NT4 and below
		{
			 a_csIPXNetBindingKey += NETCONFIG ;
			 a_csIPXNetBindingKey += _T("\\" ) ;
		}
		a_csIPXNetBindingKey += a_chsLink ;

		t_fRc = TRUE ;
	}

	return t_fRc ;
}


/*******************************************************************
    NAME:       fGetNtNBRegAdapterKey

    SYNOPSIS:   develops a registry path to the NetBios adapter by index

  	NOTES:

    ENTRY:       DWORD dwIndex, CHString& chsRegKey
    HISTORY:
                  03-MAR-1999     Created
********************************************************************/

BOOL CWin32NetworkAdapterConfig::fGetNtNBRegAdapterKey(	DWORD a_dwIndex,
														CHString &a_csNBBindingKey,
														CHString &a_chsLink )
{
	BOOL t_fRc = FALSE ;

	// retrieve the adapter identifier
	CHString t_chsKey ;
	if( fMapIndextoKey( a_dwIndex, t_chsKey ) )
	{
		// build up the registry key
		a_csNBBindingKey =  SERVICES_HOME ;

		if( IsWinNT5() )
		{
			 a_csNBBindingKey	+= _T("\\NetBT\\Parameters\\Interfaces\\") ;
			 a_chsLink			= _T("Tcpip_") ;
		}
		else	// NT4 and below
		{
			a_csNBBindingKey += NETBT_ADAPTERS ;
			a_csNBBindingKey += _T("\\" ) ;

			a_chsLink.Empty() ;
		}
		a_chsLink			+= t_chsKey ;
		a_csNBBindingKey	+= a_chsLink ;

		t_fRc = TRUE ;
	}

	return t_fRc ;
}



/*******************************************************************
    NAME:       ResetGateways

    SYNOPSIS:   makes sure that the registry values for default gateway
                are null.  c

  	NOTES:

    ENTRY:       
    HISTORY:
                 
********************************************************************/

BOOL CWin32NetworkAdapterConfig::ResetGateways(CInstance *pInst)
{
    BOOL fRet = TRUE;
    if(!pInst)
    {
        fRet = FALSE;
    }

    if(fRet)
    {
        DWORD dwIndex;
	    if(!pInst->GetDWORD(L"Index", dwIndex))
	    {
		    fRet = FALSE;
	    }

        if(fRet)
        {
	        // load the registry
            SAFEARRAYBOUND rgsabound[1];
	        rgsabound[0].cElements = 1;
	        rgsabound[0].lLbound = 0;
            SAFEARRAY *psaIpGatewayArray = NULL;
            psaIpGatewayArray = ::SafeArrayCreate(
                                VT_BSTR, 
                                1, 
                                rgsabound);

	        // register for stack scope cleanup of SAFEARRAYs
	        if(psaIpGatewayArray)
            {
                saAutoClean acGateway(&psaIpGatewayArray);
                bstr_t bstrtEmptyStr(L"");
                long index = 0;

				if(SUCCEEDED(::SafeArrayPutElement(
                    psaIpGatewayArray, 
                    &index, 
                    (void*)(BSTR)bstrtEmptyStr)))
                {
                    // retrieve the adapter identifier
	                CHString chsRegKey;
	                CHString chsLink;
	                
                    if(!fGetNtTcpRegAdapterKey(
                        dwIndex, 
                        chsRegKey, 
                        chsLink))
	                {
		                LogErrorMessage(L"Call to fGetNtTcpRegAdapterKey failed");
                        fRet = FALSE;
	                }

                    if(fRet)
                    {
	                    CRegistry RegTcpInterface;
	                    
                        HRESULT	hRes = RegTcpInterface.Open(
                            HKEY_LOCAL_MACHINE, 
                            chsRegKey, 
                            KEY_WRITE);
	                    
                        if(FAILED(hRes))
	                    {
		                    fRet = FALSE;
	                    }

                        if(fRet)
                        {
	                        if(ERROR_SUCCESS != RegPutStringArray(
                                RegTcpInterface, 
                                L"DefaultGateway", 
                                *psaIpGatewayArray, 
                                NULL))
	                        {
		                        fRet = FALSE;
	                        }        
                        }
                    }

                    // Set the NT 4 area...
                    if(fRet)
                    {
                        CRegistry oNT4Reg ;
		                CHString csBindingKey = SERVICES_HOME;
					             csBindingKey += L"\\";
					             csBindingKey += chsLink;
					             csBindingKey += PARAMETERS_TCPIP;

		                // insure the key is there on open. 
                        // not an error if it isn't...
		                if(SUCCEEDED(oNT4Reg.CreateOpen( 
                            HKEY_LOCAL_MACHINE, 
                            csBindingKey.GetBuffer(0))))
		                {
		                    // load the registry entry
                            if(ERROR_SUCCESS != RegPutStringArray(
                                oNT4Reg, 
                                L"DefaultGateway", 
                                *psaIpGatewayArray, 
                                NULL))
		                    {
			                    fRet = FALSE;
		                    }
                        }
                    }
                }
                else
                {
                    fRet = FALSE;
                }
            }
        }
    }

    return fRet;
}



/*******************************************************************
    NAME:       CDhcpIP_InstructionList::BuildStaticIPInstructionList

    SYNOPSIS:   builds a static IP instruction list for DHCP notification

  	NOTES:

    ENTRY:
    HISTORY:
                  02-May-1999     Created
********************************************************************/
E_RET CDhcpIP_InstructionList::BuildStaticIPInstructionList(

CMParms				&a_rMParms,
SAFEARRAY			*a_IpArray,
SAFEARRAY			*a_MaskArray,
CRegistry			&a_Registry,
bool				t_fDHCPCurrentlyActive )
{
	E_RET	t_eMethodError	= E_RET_OK ;
	BSTR	t_bsIP			= NULL ;
	BSTR	t_bsMask		= NULL ;

	// new element bounds
	LONG t_lIpLbound = 0;
	LONG t_lIpUbound = 0;
	if( S_OK != SafeArrayGetLBound( a_IpArray, 1, &t_lIpLbound ) ||
		S_OK != SafeArrayGetUBound( a_IpArray, 1, &t_lIpUbound ) )
	{
		return E_RET_INPARM_FAILURE ;
	}

	// DHCP -> Static
	if( t_fDHCPCurrentlyActive )
	{

		DWORD t_dwIndex = 0 ;
		for( LONG t_lIndex = t_lIpLbound; t_lIndex <= t_lIpUbound; t_lIndex++ )
		{
			// new IP
			SafeArrayGetElement( a_IpArray,	&t_lIndex, &t_bsIP ) ;

			// new mask
			SafeArrayGetElement( a_MaskArray, &t_lIndex, &t_bsMask ) ;

			SERVICE_ENABLE	t_DhcpFlag		= t_dwIndex ? IgnoreFlag	: DhcpDisable ;
			DWORD			t_IndexAction	= t_dwIndex ? 0xFFFF		: 0 ;

			AddDhcpInstruction( t_bsIP, t_bsMask, TRUE, t_IndexAction, t_DhcpFlag ) ;

			t_dwIndex++ ;
		}
	}

	// Static -> Static
	else
	{
		// old lists
		CHStringArray t_RegIPList ;
		CHStringArray t_RegMaskList ;
		if( ERROR_SUCCESS != a_Registry.GetCurrentKeyValue( L"IpAddress", t_RegIPList ) ||
			ERROR_SUCCESS != a_Registry.GetCurrentKeyValue( L"SubnetMask", t_RegMaskList ) )
		{
			return E_RET_REGISTRY_FAILURE ;
		}

		LONG t_OldCount = t_RegIPList.GetSize() ;
		LONG t_NewCount = ( t_lIpUbound - t_lIpLbound ) + 1 ;

		// seek out the first update change
		for( int t_FirstChange = 0; t_FirstChange < min( t_OldCount, t_NewCount ); t_FirstChange++ )
		{
			CHString t_chsOldIPAddress	= t_RegIPList.GetAt( t_FirstChange ) ;
			CHString t_chsOldIPMask		= t_RegMaskList.GetAt( t_FirstChange ) ;

			LONG t_index = t_lIpLbound + t_FirstChange;

			// new IP
			SafeArrayGetElement( a_IpArray,	&t_index, &t_bsIP ) ;

			// new mask
			SafeArrayGetElement( a_MaskArray, &t_index, &t_bsMask ) ;

			if( t_chsOldIPAddress.CompareNoCase( t_bsIP ) ||
				t_chsOldIPMask.CompareNoCase( t_bsMask ) )
			{
				break ;
			}

			// for registry update only
			AddDhcpInstruction( t_bsIP, t_bsMask, FALSE, t_FirstChange, IgnoreFlag ) ;
		}

		// NOTE: For items below t_FirstChange we can avoid tearing down the connection for
		//		 a specific IP by noting that the IP and mask have not changed in the update.
		//		 As soon as a change is noted all subsequent IPs and masks must be removed and
		//		 then added from the new list. The logic of plumbing stack addresses and other
		//		 anomolies in maintaining the IP/Mask list prevent the network team from
		//		 a more elegant solution ( in the W2k RTM timeframe ).

		// remove the old or possibly changing addresses, in decending order
		for( int i = t_OldCount - 1; i >= t_FirstChange; i-- )
		{
			AddDhcpInstruction( bstr_t(ZERO_ADDRESS), bstr_t(ZERO_ADDRESS), TRUE, i, IgnoreFlag ) ;
		}

		// now added in the new changing items
		for( i = t_FirstChange; i < t_NewCount; i++ )
		{
			LONG t_index = t_lIpLbound + i ;

			// new IP
			SafeArrayGetElement( a_IpArray,	&t_index, &t_bsIP ) ;

			// new mask
			SafeArrayGetElement( a_MaskArray, &t_index, &t_bsMask ) ;

			int t_IndexAction = i ? 0xFFFF : 0 ;

			AddDhcpInstruction( t_bsIP, t_bsMask, TRUE, t_IndexAction, IgnoreFlag ) ;
		}
	}
	return t_eMethodError ;
}

/*******************************************************************
    NAME:       CDhcpIP_InstructionList::Add

    SYNOPSIS:   adds a static IP instruction for DHCP notification

  	NOTES:

    ENTRY:
    HISTORY:
                  02-May-1999     Created
********************************************************************/

void CDhcpIP_InstructionList::AddDhcpInstruction(

BSTR a_bstrIPAddr,
BSTR a_bstrIPMask,
BOOL a_bIsNewAddress,
DWORD a_dwIndex,
SERVICE_ENABLE a_eDhcpFlag
 )
{
	CDhcpIP_Instruction *t_pIPInstruction = new CDhcpIP_Instruction ;
	
	try
	{
		t_pIPInstruction->chsIPAddress = a_bstrIPAddr ;
		t_pIPInstruction->chsIPMask	   = a_bstrIPMask ;

		t_pIPInstruction->dwIndex		= a_dwIndex ;
		t_pIPInstruction->bIsNewAddress	= a_bIsNewAddress ;
		t_pIPInstruction->eDhcpFlag		= a_eDhcpFlag ;

		//will only throw before adding the element so need to catch this also.
		Add( t_pIPInstruction ) ;
	}
	catch (...)
	{
		delete t_pIPInstruction;
		t_pIPInstruction = NULL;
		throw;
	}

}

//
CDhcpIP_InstructionList::~CDhcpIP_InstructionList()
{
	CDhcpIP_Instruction *t_pchsDel ;

	for( int t_iar = 0; t_iar < GetSize(); t_iar++ )
	{
		if( ( t_pchsDel = (CDhcpIP_Instruction*)GetAt( t_iar ) ) )
		{
			delete t_pchsDel ;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\netclient.cpp ===
//=================================================================

//

// NetCli.CPP -- Network client property set provider

//                 (Windows 95 only)

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>

#include "NetClient.h"
#include "poormansresource.h"
#include "resourcedesc.h"
#include "cfgmgrdevice.h"
#include <tchar.h>

// Property set declaration
//=========================
CWin32NetCli MyNetCliSet(PROPSET_NAME_NETWORK_CLIENT, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetCli::CWin32NetCli
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32NetCli::CWin32NetCli(LPCWSTR name, LPCWSTR pszNamespace)
:Provider(name, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetCli::~CWin32NetCli
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32NetCli::~CWin32NetCli()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetCli::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32NetCli::GetObject(CInstance *pInstance, long lFlags /*= 0L*/)
{
	HRESULT hr = WBEM_E_NOT_FOUND;
	// cache name for reality check at end.
	CHString name0, name1;
	CHString chsClient;
	if (pInstance->GetCHString(IDS_Name, name0))
	{

#ifdef NTONLY
		// add code to check the instance to see if it exists.
			hr = GetNTObject(pInstance, lFlags);
			return(hr);
#endif

		pInstance->GetCHString(IDS_Name, name1);

		// if name doesn't match, then someone's asking for something
		// other than what we got.  Tell 'em to go fly a kite
		if (name0.CompareNoCase(name1) != 0)
			hr = WBEM_E_NOT_FOUND; // darn, no WBEM_E_GO_FLY_A_KITE...
	}

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetCli::AddDynamicInstances
 *
 *  DESCRIPTION : Creates instance of property set for each installed client
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32NetCli::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
    HRESULT hr;

#ifdef NTONLY
        hr = EnumerateNTInstances(pMethodContext);
#endif
    return hr;

}

#ifdef NTONLY
////////////////////////////////////////////////////////////////////////
HRESULT CWin32NetCli::FillNTInstance(CInstance *pInstance, CHString &a_chsClient )
{
	CRegistry Reg;
    HRESULT hr=WBEM_E_FAILED;
    CHString chsKey,chsTmp,chsValue;
	DWORD dwTmp;

    //===========================================================
	//  Find out who we are dealing with here, lanman or netware
    //===========================================================
//    if( Reg.OpenLocalMachineKeyAndReadValue( "SYSTEM\\CurrentControlSet\\Control\\NetworkProvider\\Order", "ProviderOrder", chsTmp) == ERROR_SUCCESS)
	if (!a_chsClient.IsEmpty())
    {
		chsTmp = a_chsClient;
	    //=======================================================
		//  Get Description, Caption, Status
		//=======================================================
        chsKey = CHString(_T("SYSTEM\\CurrentControlSet\\Services\\")) + chsTmp;
	    if( Reg.OpenLocalMachineKeyAndReadValue( chsKey, _T("DisplayName"), chsValue) == ERROR_SUCCESS)
		{
			pInstance->SetCHString(IDS_Caption, chsValue);
		}

		CHString t_chsDesc ;
		Reg.OpenLocalMachineKeyAndReadValue( chsKey, _T("Description"), t_chsDesc);

		if( t_chsDesc.IsEmpty() )
		{
			t_chsDesc = a_chsClient ;
		}
		pInstance->SetCHString(IDS_Description, t_chsDesc ) ;

#ifdef NTONLY
		if( IsWinNT5() )
		{
			CHString t_chsStatus ;

			if( GetServiceStatus( a_chsClient,  t_chsStatus ) )
			{
				pInstance->SetCharSplat(IDS_Status, t_chsStatus ) ;
			}
		}
		else
#endif
		{
			// can't find status
			pInstance->SetCHString(IDS_Status, IDS_STATUS_Unknown);

			chsKey = CHString(_T("SYSTEM\\CurrentControlSet\\Services\\")) + chsTmp + CHString(_T("\\Enum"));

			if( Reg.OpenLocalMachineKeyAndReadValue( chsKey, _T("0"), chsValue) == ERROR_SUCCESS)
			{
				chsKey = CHString(_T("SYSTEM\\CurrentControlSet\\Enum\\")) + chsValue;
				if( Reg.Open( HKEY_LOCAL_MACHINE,chsKey,KEY_READ) == ERROR_SUCCESS)
				{
					if( Reg.GetCurrentKeyValue(_T("StatusFlags"),dwTmp) == ERROR_SUCCESS )
					{
						TranslateNTStatus(dwTmp,chsValue);
						pInstance->SetCHString(IDS_Status, chsValue);
					}
				}
			}
		}

	    //=======================================================
		//  Get InstallDate
		//=======================================================
		if( chsTmp.CompareNoCase(_T("LanmanWorkstation")) == 0 )
		{
			chsKey = CHString(_T("Software\\Microsoft\\LanmanWorkstation\\CurrentVersion"));
		    if( Reg.Open( HKEY_LOCAL_MACHINE,chsKey,KEY_READ) == ERROR_SUCCESS){
				if( Reg.GetCurrentKeyValue(_T("InstallDate"),dwTmp) == ERROR_SUCCESS ){
					pInstance->SetDateTime(IDS_InstallDate, (WBEMTime)dwTmp);
				}
			}
		}
	    //=======================================================
		//  Get Name, Manufacturer
		//=======================================================
        chsKey = CHString(_T("SYSTEM\\CurrentControlSet\\Services\\")) + chsTmp + CHString(_T("\\NetworkProvider"));
        if( Reg.OpenLocalMachineKeyAndReadValue( chsKey, _T("Name"), chsTmp) == ERROR_SUCCESS)
		{
			pInstance->SetCHString(IDS_Name, chsTmp);
			CHString fName;
			// try to find a manufacturer
			if( Reg.OpenLocalMachineKeyAndReadValue( chsKey, _T("ProviderPath"), fName) == ERROR_SUCCESS)
			{
				// get a filename out of it - might have %SystemRoot% in it...
				chsTmp = fName.Left(12);
				if (chsTmp.CompareNoCase(_T("%SystemRoot%")) == 0)
				{
					fName = fName.Right(fName.GetLength() - _tcslen(_T("%SystemRoot%")) );
					GetWindowsDirectory(chsTmp.GetBuffer(MAX_PATH), MAX_PATH);
					chsTmp.ReleaseBuffer();

					// if it's the root dir, it'll have a backslash at the end...
					LPTSTR pTmpTchar = chsTmp.GetBuffer(0) ;
					if( ( pTmpTchar = _tcsrchr( pTmpTchar, '\\' ) ) )
					{
						if( *(_tcsinc( pTmpTchar ) ) == '\0' )
						{
							chsTmp = chsTmp.Left(chsTmp.GetLength() -1);
						}
					}
					chsTmp.ReleaseBuffer();

					fName = chsTmp + fName;
				}

				if( GetManufacturerFromFileName( fName,chsTmp ))
				{
					pInstance->SetCHString(IDS_Manufacturer, chsTmp);
				}
			}
	        hr = WBEM_S_NO_ERROR;
		}

    }
	return hr;
}
#endif

//**********************************************************************/
#ifdef NTONLY
HRESULT CWin32NetCli::EnumerateNTInstances(MethodContext *&pMethodContext)
{
	CRegistry Reg;
	CHString chsTemp;
	CHString chsClient;
	HRESULT hr = WBEM_S_NO_ERROR;
	CInstancePtr pInstance;
	int nIndex = 0;
    if( Reg.OpenLocalMachineKeyAndReadValue( _T("SYSTEM\\CurrentControlSet\\Control\\NetworkProvider\\Order"), _T("ProviderOrder"), chsTemp) == ERROR_SUCCESS)
    {
		// multiple clients are stored here delimitted by a comma
		nIndex = chsTemp.Find(_T(","));

		while (chsTemp.GetLength() && SUCCEEDED(hr))
		{
			// now we need to get the last instance
			if (-1 == nIndex)
			{
				chsClient = chsTemp;
				chsTemp.Empty();
			}
			else
			{
				chsClient = chsTemp.Left(nIndex);
				// peel left hand string off temp string.
				chsTemp = chsTemp.Mid(nIndex+1);
			}

			pInstance.Attach(CreateNewInstance(pMethodContext));
			if(SUCCEEDED(FillNTInstance(pInstance, chsClient)))
			{
				hr = pInstance->Commit();
			}

			nIndex = chsTemp.Find(_T(","));
		}

	}

    return hr;
}
#endif

//**********************************************************************/

#ifdef NTONLY
HRESULT CWin32NetCli::GetNTObject(CInstance* pInstance, long lFlags /*= 0L*/)
{
	HRESULT	hr = WBEM_E_NOT_FOUND;
	CRegistry
				Reg;
	CHString chsTemp,
				chsName,
				chsTmp,
				chsKey,
				chsNamePassedIn,
				chsClient;
	int		nIndex = 0;
	LONG		lRes;

	BOOL bMultiple = FALSE;

	// get key from passed in instance
	if (NULL != pInstance)
    {
		pInstance->GetCHString(IDS_Name, chsNamePassedIn);
    }

	if ((lRes = Reg.OpenLocalMachineKeyAndReadValue(
		_T("SYSTEM\\CurrentControlSet\\Control\\NetworkProvider\\Order"),
		_T("ProviderOrder"), chsTemp)) != ERROR_SUCCESS)
		return WinErrorToWBEMhResult(lRes);

	// multiple clients are stored here delimitted by a comma
	nIndex = chsTemp.Find(_T(","));

	while (chsTemp.GetLength())
	{
		// now we need to get the last instance
		if (-1 == nIndex)
		{
			chsClient = chsTemp;
			chsTemp = _T("");
		}
		else
		{
			chsClient = chsTemp.Left(nIndex);

            // peel left hand string off temp string.
			chsTemp = chsTemp.Mid(nIndex + 1);
		}

		if (NULL != pInstance)
		{
			//=======================================================
			//  Get Name, Manufacturer
			//=======================================================
			chsKey = CHString(L"SYSTEM\\CurrentControlSet\\Services\\") + chsClient + CHString(L"\\NetworkProvider");
     		if( Reg.OpenLocalMachineKeyAndReadValue( chsKey, _T("Name"), chsName) == ERROR_SUCCESS)
     		{
				// compare strings to see if there is an object to get
				if (0 == chsNamePassedIn.CompareNoCase(chsName))
				{
					// fill the instance
					hr = FillNTInstance(pInstance, chsClient);
					break;
				}
			}	// end if
		}	// end if

		nIndex = chsTemp.Find(_T(","));
	}	// end while

	return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\netconn.h ===
//=================================================================

//

// NetConn.h -- ent network connection property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
// Revisions:    05/25/99    a-peterc		Reworked...
//
//=================================================================
#include "cnetconn.h"

// Property set identification
//============================

#define	PROPSET_NAME_NETCONNECTION	L"Win32_NetworkConnection"

// Utility defines
//================


// Property set identification
//============================

class CWin32NetConnection : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32NetConnection(LPCWSTR strName, LPCWSTR pszNamespace) ;
       ~CWin32NetConnection() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

	private:

        // Utility functions
        //==================
  		void LoadPropertyValues (

			CConnection *a_pConnection, 
			CInstance *a_pInst
		);

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\netconn.cpp ===
//=================================================================

//

// NetConn.CPP -- ent network connection property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:   08/01/96    a-jmoon			Created
//				09/10/97	a-sanjes		Added CImpersonateLoggedOnUser
//				05/25/99	a-peterc		Reworked...
//
//=================================================================

#include "precomp.h"
#include <lmuse.h>
#include "DllWrapperBase.h"
#include "MprApi.h"
#include "netconn.h"

#include "resource.h"

#include "sid.h"
#include "accessentrylist.h"
#include <accctrl.h>
#include "AccessRights.h"
#include "ObjAccessRights.h"

// Property set declaration
//=========================

CWin32NetConnection	win32NetConnection( PROPSET_NAME_NETCONNECTION, IDS_CimWin32Namespace );

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetConnection::CWin32NetConnection
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *                LPCTSTR pszNamespace - Namespace for provider.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CWin32NetConnection :: CWin32NetConnection (

	LPCWSTR strName,
	LPCWSTR pszNamespace /*=NULL*/

) : Provider ( strName, pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetConnection::~CWin32NetConnection
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CWin32NetConnection::~CWin32NetConnection()
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32NetConnection::GetObject
//
//	Inputs:		CInstance*		pInstance - Instance into which we
//											retrieve data.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32NetConnection :: GetObject ( CInstance* a_pInst, long lFlags /*= 0L*/ )
{
    HRESULT			t_hResult = WBEM_E_NOT_FOUND ;
    CHString		t_strName ;

	CConnection		t_oConnection ;
	CNetConnection	t_Net ;

	a_pInst->GetCHString( IDS_Name, t_strName ) ;

	if( t_Net.GetConnection( t_strName, t_oConnection ) )
	{
        LoadPropertyValues( &t_oConnection, a_pInst ) ;

		t_hResult = WBEM_S_NO_ERROR ;
 	}

    return t_hResult ;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32NetConnection::EnumerateInstances
//
//	Inputs:		MethodContext*	pMethodContext - Context to enum
//								instance data in.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32NetConnection :: EnumerateInstances (

	MethodContext *a_pMethodContext,
	long a_lFlags /*= 0L*/
)
{
	HRESULT			t_hResult = WBEM_S_NO_ERROR ;

	CInstancePtr	t_pInst ;
	CConnection		*t_pConnection= NULL ;
	CNetConnection	t_Net ;

	t_Net.BeginConnectionEnum() ;

	while( t_Net.GetNextConnection( &t_pConnection ) && t_pConnection )
	{
		if( !t_pConnection->strKeyName.IsEmpty() )
		{
            t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;

			LoadPropertyValues( t_pConnection, t_pInst ) ;

		    t_hResult = t_pInst->Commit() ;
		}
	}

    return t_hResult ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CNetConnection::LoadPropertyValues
 *
 *  DESCRIPTION : Sets property values according to contents of passed
 *                CConnection structure
 *
 *  INPUTS      : pointer to CConnection structure
 *                a_pInst - Instance object to load with values.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void CWin32NetConnection :: LoadPropertyValues (

	CConnection *a_pConnection,
	CInstance *a_pInst
)
{
    // Sanity check
    //=============
    if( a_pConnection == NULL )
	{
        return ;
    }

#ifdef NTONLY
#if 0
    ACCESS_MASK t_AccessMask;
    // Obtains an access mask reflecting the effective rights (held
    // by the user associated with the current thread) to the object.
    CObjAccessRights t_coar(a_pConnection->chsRemoteName, SE_LMSHARE, true);
    if(t_coar.GetError() == ERROR_SUCCESS)
    {
        if(t_coar.GetEffectiveAccessRights(&t_AccessMask) == ERROR_SUCCESS)
        {
            a_pInst->SetDWORD( IDS_AccessMask, t_AccessMask );
        }
    }
    else if(t_coar.GetError() == ERROR_ACCESS_DENIED)
    {
        a_pInst->SetDWORD( IDS_AccessMask, 0L );
    }
#else
	CHString dirname(a_pConnection->chsRemoteName);
	dirname += L"\\";
	SmartCloseHandle hFile = CreateFile(dirname,
										MAXIMUM_ALLOWED,
										FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
										NULL,
										OPEN_EXISTING,
										FILE_FLAG_BACKUP_SEMANTICS,
										NULL
										);

	DWORD dwErr = GetLastError();

	if ((hFile == INVALID_HANDLE_VALUE) &&
		(dwErr != ERROR_ACCESS_DENIED) &&
		!a_pConnection->chsLocalName.IsEmpty()
	)
	{
		//try the local name as a dir...
		dirname = L"\\\\.\\";
		dirname += a_pConnection->chsLocalName;
		dirname += L'\\';
		hFile = CreateFile(dirname,
							MAXIMUM_ALLOWED,
							FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
							NULL,
							OPEN_EXISTING,
							FILE_FLAG_BACKUP_SEMANTICS,
							NULL
							);
		dwErr = GetLastError();
	}

	if (hFile != INVALID_HANDLE_VALUE)
	{
		FILE_ACCESS_INFORMATION fai;
		IO_STATUS_BLOCK iosb;
		memset(&fai, 0, sizeof(FILE_ACCESS_INFORMATION));
		memset(&iosb, 0, sizeof(IO_STATUS_BLOCK));

		if ( NT_SUCCESS( NtQueryInformationFile( hFile,
                             &iosb,
                             &fai,
                             sizeof( FILE_ACCESS_INFORMATION ),
                             FileAccessInformation
                           ) )
		)
		{
			a_pInst->SetDWORD(IDS_AccessMask, (DWORD)(fai.AccessFlags));
		}
	}
	else
	{
		if (dwErr == ERROR_ACCESS_DENIED)
		{
			a_pInst->SetDWORD( IDS_AccessMask, 0L );
		}
	}

#endif
#endif

	a_pInst->SetCHString( IDS_Name, a_pConnection->strKeyName );

    if( !a_pConnection->chsLocalName.IsEmpty() )
	{
        a_pInst->SetCHString( IDS_LocalName, a_pConnection->chsLocalName ) ;
    }

    if( !a_pConnection->chsRemoteName.IsEmpty() )
	{
        a_pInst->SetCHString( IDS_RemoteName, a_pConnection->chsRemoteName ) ;
        a_pInst->SetCHString( IDS_RemotePath, a_pConnection->chsRemoteName ) ;
    }

    if( !a_pConnection->chsProvider.IsEmpty() )
	{
        a_pInst->SetCHString( IDS_ProviderName, a_pConnection->chsProvider ) ;
    }

    if( !a_pConnection->chsComment.IsEmpty() )
	{
        a_pInst->SetCHString( IDS_Comment, a_pConnection->chsComment ) ;
    }
	else
	{
        a_pInst->SetCHString( IDS_Comment, _T(" ") ) ;
	}

	// "Persistent" connection
    CHString sTemp2;

    if( CConnection::e_Remembered == a_pConnection->eScope )
    {
		a_pInst->Setbool( L"Persistent",true ) ;

		a_pInst->SetCHString( IDS_ConnectionType, IDS_Persistent ) ;

        LoadStringW(sTemp2, IDR_Resource_Remembered);

		if( !a_pConnection->chsProvider.IsEmpty() )
        {
            CHString t_chsStr;
			CHString t_chsDesc( a_pConnection->chsProvider ) ;

            Format( t_chsStr, IDR_ResourceRememberedFormat, t_chsDesc ) ;
			a_pInst->SetCHString( IDS_Description, t_chsStr ) ;
		}
	}
	else
	{
		a_pInst->Setbool( L"Persistent", false ) ;

		a_pInst->SetCHString( IDS_ConnectionType, IDS_Current ) ;

        LoadStringW(sTemp2, IDR_Resource_Connected);

		if( !a_pConnection->chsProvider.IsEmpty() )
        {
            CHString t_chsStr;
			CHString t_chsDesc( a_pConnection->chsProvider ) ;

            Format( t_chsStr, IDR_ResourceConnectedFormat, t_chsDesc ) ;

			a_pInst->SetCHString( IDS_Description, t_chsStr ) ;
		}
	}

	a_pInst->SetCHString( IDS_Caption, sTemp2 ) ;

    switch( a_pConnection->dwDisplayType )
	{
        case RESOURCEDISPLAYTYPE_DOMAIN:
		{
            a_pInst->SetCHString( IDS_DisplayType, L"Domain" );
		}
        break ;

        case RESOURCEDISPLAYTYPE_GENERIC :
		{
            a_pInst->SetCHString( IDS_DisplayType, L"Generic" );
		}
        break ;

        case RESOURCEDISPLAYTYPE_SERVER :
		{
            a_pInst->SetCHString( IDS_DisplayType, L"Server" );
		}
        break ;

        case RESOURCEDISPLAYTYPE_SHARE :
		{
            a_pInst->SetCHString( IDS_DisplayType, L"Share" );
		}
        break ;
    }

    switch( a_pConnection->dwType )
	{
        case RESOURCETYPE_DISK:
		{
            a_pInst->SetCHString( IDS_ResourceType, L"Disk" );
		}
        break ;

        case RESOURCETYPE_PRINT :
		{
            a_pInst->SetCHString( IDS_ResourceType, L"Print" );
		}
        break ;

		case RESOURCETYPE_ANY:
		{
			a_pInst->SetCHString( IDS_ResourceType, L"Any" );
		}
		break;

		default:
		{
			a_pInst->SetCHString( IDS_ResourceType, L"Any" );
		}
		break;
    }

	a_pInst->SetCHString( IDS_UserName, a_pConnection->strUserName );

    switch( a_pConnection->dwStatus )
    {
        case USE_OK:
		{
			a_pInst->SetCHString( L"ConnectionState", _T("Connected") ) ;
            a_pInst->SetCHString( IDS_Status, IDS_STATUS_OK ) ;
		}
        break;

        case USE_PAUSED:
		{
			a_pInst->SetCHString( L"ConnectionState", _T("Paused") ) ;
            a_pInst->SetCHString( IDS_Status, _T("Degraded") ) ;
        }
		break;

        case USE_DISCONN:
		{
			a_pInst->SetCHString( L"ConnectionState", _T("Disconnected") ) ;
            a_pInst->SetCHString( IDS_Status, _T("Degraded") ) ;
		}
        break;

        case USE_CONN:
		{
			a_pInst->SetCHString( L"ConnectionState", _T("Connecting") ) ;
            a_pInst->SetCHString( IDS_Status, _T("Starting") ) ;
        }
		break;

        case USE_RECONN:
		{
			a_pInst->SetCHString( L"ConnectionState", _T("Reconnecting") ) ;
            a_pInst->SetCHString( IDS_Status, _T("Starting") ) ;
        }
		break;

        case ERROR_NOT_CONNECTED:
        {
			a_pInst->SetCHString( L"ConnectionState", _T("Disconnected") ) ;
            a_pInst->SetCHString( IDS_Status, _T("Unavailable") ) ;
        }
        break;

        default:
        case USE_NETERR:
		{
			a_pInst->SetCHString( L"ConnectionState", IDS_STATUS_Error ) ;
            a_pInst->SetCHString( IDS_Status, IDS_STATUS_Error ) ;
		}
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\ntlastboottime.h ===
//============================================================

//

// ntlastboottime.h - Performance Data helper class definition

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// 11/23/97     a-sanjes     created
//
//============================================================

#ifndef __NTLASTBOOTTIME_H__
#define __NTLASTBOOTTIME_H__

class CNTLastBootTime
{
	public :
		static CStaticCritSec m_cs;

		CNTLastBootTime() ;
		~CNTLastBootTime() ;

		BOOL GetLastBootTime( FILETIME &a_ft );

	private:

		static bool			m_fGotTime;
		static FILETIME		m_ft;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\ntlastboottime.cpp ===
//=================================================================

//

// ntlastboottime.CPP -- NT Last Boot Time Helper class

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/23/97    a-sanjes        Created
//
//=================================================================

#include "precomp.h"
#include "perfdata.h"
#include <cregcls.h>
#include <cominit.h>
#include "ntlastboottime.h"

#ifdef NTONLY
// Static Initialization
bool        CNTLastBootTime::m_fGotTime = FALSE;
FILETIME    CNTLastBootTime::m_ft;
CStaticCritSec CNTLastBootTime::m_cs;

//////////////////////////////////////////////////////////
//
//    Function:    CNTLastBootTime::CNTLastBootTime
//
//    Default constructor
//
//    Inputs:
//                None
//
//    Outputs:
//                None
//
//    Returns:
//                None
//
//    Comments:
//
//////////////////////////////////////////////////////////

CNTLastBootTime::CNTLastBootTime( void )
{
}

//////////////////////////////////////////////////////////
//
//    Function:    CNTLastBootTime::~CNTLastBootTime
//
//    Destructor
//
//    Inputs:
//                None
//
//    Outputs:
//                None
//
//    Returns:
//                None
//
//    Comments:
//
//////////////////////////////////////////////////////////

CNTLastBootTime::~CNTLastBootTime( void )
{
    // Because this object is intended to be instantiated as a stack variable,
    // we do NOT want to perform the CPerformanceData.Close() operation in
    // this destructor.  We will leave it to the statically instantiated classes
    // to do this for us.  Because it only needs to happen once and only once,
    // this handles our HKEY_PERFORMANCE_DATA opens just fine.  Besides, this
    // class ensures that for getting the last boot time, we hit the performance
    // data once and only once.
}


//////////////////////////////////////////////////////////
//
//    Function:    CNTLastBootTime::GetLastBootTime
//
//    Inputs:
//        None
//
//    Outputs:
//        struct tm&        tmLastBootTime - Last Boot Time of machine
//                                            in tm format.
//
//
//    Returns: TRUE/FALSE- Whether or not we got the time.
//
//    Comments:    If we don't have the value, grabs it from
//                the performance data and caches it, so we
//                minimize the number of times we actually have
//                to hit the performance data.
//
//////////////////////////////////////////////////////////
BOOL CNTLastBootTime::GetLastBootTime ( FILETIME &a_ft )
{
    BOOL    fReturn = FALSE;

    // Check the static variable indicating that we have the time.  If it is
    // TRUE, we've already got the time.  If not, then we need to initialize the
    // data from PerformanceData, but since this may be happening on multiple
    // threads, we're going to use a named Mutex to protect the static data.

    {
            CInCritSec  ics(&m_cs);

            if ( !m_fGotTime )
            {
                SYSTEM_TIMEOFDAY_INFORMATION t_TODInformation;

                if ( NT_SUCCESS(NtQuerySystemInformation(SystemTimeOfDayInformation,
                                            &t_TODInformation,
                                            sizeof(t_TODInformation),
                                            NULL)) )
                {
                    memcpy(&m_ft, &t_TODInformation.BootTime, sizeof(t_TODInformation.BootTime));
                    m_fGotTime = TRUE;
                }
            }
    }

    // Now, if we have the time, copy the value.
    if ( m_fGotTime )
    {
        CopyMemory( &a_ft, &m_ft, sizeof(m_ft) );
        fReturn = TRUE;
    }

    return fReturn;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\ntdriverio.cpp ===
//=================================================================

//

// NTDriverIO.cpp --

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/15/98	        Created
//
//				03/03/99    		Added graceful exit on SEH and memory failures,
//											syntactic clean up
//=================================================================






#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"

#include "NTDriverIO.h"
#include <ntsecapi.h>
#include "DllWrapperBase.h"
#include "NtDllApi.h"

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  void NTDriverIO::NTDriverIO()

 Description: encapsulates the functionallity of NtDll.dll's NtCreatefile

 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:	  15-Nov-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

NTDriverIO::NTDriverIO( PWSTR a_pDriver )
{
	NTDriverIO();
	m_hDriverHandle = Open( a_pDriver );
}

NTDriverIO::NTDriverIO()
{
	m_hDriverHandle	= INVALID_HANDLE_VALUE;
}

NTDriverIO::~NTDriverIO()
{
	if( INVALID_HANDLE_VALUE != m_hDriverHandle )
	{
		Close( m_hDriverHandle ) ;
	}
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  HANDLE NTDriverIO::Open( PWSTR pDriver )

 Description: encapsulates the functionallity of NtDll.dll's NtCreatefile

 Arguments:
 Returns:	HANDLE to the driver
 Inputs:	PCWSTR pDriver
 Outputs:
 Caveats:
 Raid:
 History:	  15-Nov-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

HANDLE NTDriverIO::Open( PWSTR a_pDriver )
{
	CNtDllApi *t_pNtDll = (CNtDllApi*) CResourceManager::sm_TheResourceManager.GetResource( g_guidNtDllApi, NULL ) ;

	if( t_pNtDll == NULL )
    {
		throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
	}

	HANDLE				t_hDriverHandle ;
	OBJECT_ATTRIBUTES	t_objectAttributes ;
    IO_STATUS_BLOCK		t_iosb ;
    UNICODE_STRING		t_string ;

	t_pNtDll->RtlInitUnicodeString( &t_string, a_pDriver ) ;

    InitializeObjectAttributes(	&t_objectAttributes,
								&t_string,
								OBJ_CASE_INSENSITIVE,
								NULL,
								NULL
								);

	NTSTATUS t_status =
		t_pNtDll->NtCreateFile(
					&t_hDriverHandle,					// FileHandle
					SYNCHRONIZE | GENERIC_EXECUTE,		// DesiredAccess
					&t_objectAttributes,				// ObjectAttributes
					&t_iosb,							// IoStatusBlock
					NULL,								// AllocationSize
					FILE_ATTRIBUTE_NORMAL,				// FileAttributes
					FILE_SHARE_READ | FILE_SHARE_WRITE,	// ShareAccess
					FILE_OPEN_IF,						// CreateDisposition
					FILE_SYNCHRONOUS_IO_NONALERT,		// CreateOptions
					NULL,								// EaBuffer
					0									// EaLength
					);

    CResourceManager::sm_TheResourceManager.ReleaseResource( g_guidNtDllApi, t_pNtDll ) ;
    t_pNtDll = NULL ;

	return NT_SUCCESS( t_status) ? t_hDriverHandle : INVALID_HANDLE_VALUE ;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  HANDLE NTDriverIO::GetHandle()

 Description: returns the class creation scope driver handle

 Arguments:
 Returns:	HANDLE to the driver
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:	  15-Nov-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

HANDLE NTDriverIO::GetHandle()
{
	return m_hDriverHandle ;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  bool NTDriverIO::Close( HANDLE hDriver )

 Description: encapsulates the functionallity of NtDll.dll's NtCreatefile

 Arguments:
 Returns:	Boolean
 Inputs:	HANDLE to the driver
 Outputs:
 Caveats:
 Raid:
 History:	  15-Nov-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

bool NTDriverIO::Close( HANDLE a_hDriver )
{
    CNtDllApi *t_pNtDll = (CNtDllApi*) CResourceManager::sm_TheResourceManager.GetResource( g_guidNtDllApi, NULL ) ;

	if( t_pNtDll == NULL )
    {
		throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
	}

	NTSTATUS t_status = t_pNtDll->NtClose( a_hDriver );

    CResourceManager::sm_TheResourceManager.ReleaseResource( g_guidNtDllApi, t_pNtDll ) ;
    t_pNtDll = NULL ;

	return NT_SUCCESS( t_status ) ? true : false ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\ntdriverio.h ===
//=================================================================

//

// NTDriverIO.h -- 

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/15/98	        Created

//=================================================================
class NTDriverIO
{
	private:
		
		bool		m_fAlive;
		HANDLE		m_hDriverHandle; 
  	
	protected:
	public:
	        
        //=================================================
        // Constructor/destructor
        //=================================================
        NTDriverIO( PWSTR pDriver );
		NTDriverIO();
       ~NTDriverIO();

    	HANDLE	Open( PWSTR pDriver );
		bool	Close( HANDLE hDriver );
		HANDLE	GetHandle();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\os.h ===
//=================================================================

//

// OS.h -- Operating system property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/25/97    davwoh         Moved to curly
//
//=================================================================

// Property set identification
//============================
#include "SystemName.h"
#include "ServerDefs0.h"
#define PROPSET_NAME_OS L"Win32_OperatingSystem"

#define PROCESS_PRIORITY_SEPARATION_MASK    0x00000003
#define PROCESS_QUANTUM_VARIABLE_MASK       0x0000000c
#define PROCESS_QUANTUM_LONG_MASK           0x00000030

struct stOSStatus {
    DWORD dwFound;
    DWORD dwReturn;
    DWORD dwFlags;
    DWORD dwReserved;
};
    
class CWin32OS ;

class CWin32OS:public Provider {

    public:

        // Constructor/destructor
        //=======================

        CWin32OS(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CWin32OS() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery);
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);
        virtual HRESULT PutInstance(const CInstance &pInstance, long lFlags = 0L);
        virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ );

	private:
        // Utility functions
        //==================

        void	GetProductSuites( CInstance * pInstance );
		HRESULT hGetProductSuites(CHStringArray& rchsaProductSuites ); 

		void GetRunningOSInfo(CInstance *pInstance, const CHString &sName, CFrameworkQuery *pQuery);
        void GetNTInfo(CInstance *pInstance) ;
        void GetWin95Info(CInstance *pInstance) ;
        __int64 GetTotalSwapFileSize();
		
		// Helper time conversion function
        HRESULT ExecMethod(const CInstance& pInstance, const BSTR bstrMethodName, CInstance *pInParams, CInstance *pOutParams, long lFlags = 0L);
        bool GetLicensedUsers(DWORD *dwRetVal);
        IDispatch FAR* GetCollection(IDispatch FAR* pIn, WCHAR *wszName, DISPPARAMS *pDispParams);
        bool GetValue(IDispatch FAR* pIn, WCHAR *wszName, VARIANT *vValue);
#ifdef NTONLY

		BOOL CWin32OS::CanShutdownSystem ( const CInstance& a_Instance , DWORD &a_dwLastError ) ;
#endif
		DWORD	GetCipherStrength() ;
} ;

HRESULT WINAPI ShutdownThread(DWORD dwFlags) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\os.cpp ===
//=================================================================

//

// OS.CPP -- Operating system property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/25/97    davwoh         Moved to curly
//
//=================================================================

#include "precomp.h"
#include <assertbreak.h>
#include "wbemnetapi32.h"
#include <lmwksta.h>

#include <locale.h>

#include "File.h"
#include "Implement_LogicalFile.h"
#include "CIMDataFile.h"



#include "perfdata.h"
#include "os.h"
#include "WBEMPSAPI.h"
#include "WBEMToolH.h"

#include "pagefile.h"
#include "computersystem.h"
#include "ntlastboottime.h"
#include <cominit.h>
#include <winnls.h>
#include "Kernel32Api.h"
#include "DllWrapperBase.h"
#include "AdvApi32Api.h"

#include "SecurityApi.h"
#include <wtsapi32.h>

#include "KUserdata.h"

//#define SE_SHUTDOWN_NAME                  TEXT("SeShutdownPrivilege")
//#define SE_REMOTE_SHUTDOWN_NAME           TEXT("SeRemoteShutdownPrivilege")

#if(_WIN32_WINNT < 0x0500)
#define EWX_FORCEIFHUNG      0x00000010
#endif /* _WIN32_WINNT >= 0x0500 */

#define WIN32_SHUTDOWNOPTIONS (     EWX_LOGOFF      | \
                                    EWX_SHUTDOWN    | \
                                    EWX_REBOOT      | \
                                    EWX_FORCE       | \
                                    EWX_POWEROFF    )

#define NT5_WIN32_SHUTDOWNOPTIONS ( WIN32_SHUTDOWNOPTIONS | EWX_FORCEIFHUNG )

//typedef BOOL (WINAPI *lpKERNEL32_GlobalMemoryStatusEx) (IN OUT LPMEMORYSTATUSEX lpBuffer);

// This file can't be included since it conflicts with the nt header.  Grrr.  So,
// I have copy/pasted the structure I need into my .h file.
//#include <svrapi.h>  // Win95 NetServerGetInfo

// Property set declaration
//=========================

CWin32OS MyOSSet(PROPSET_NAME_OS, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OS::CWin32OS
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32OS::CWin32OS(LPCWSTR name, LPCWSTR pszNamespace)
:Provider(name, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OS::~CWin32OS
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32OS::~CWin32OS()
{
    // Because of performance issues with HKEY_PERFORMANCE_DATA, we close in the
    // destructor so we don't force all the performance counter dlls to get
    // unloaded from memory, and also to prevent an apparent memory leak
    // caused by calling RegCloseKey( HKEY_PERFORMANCE_DATA ).  We use the
    // class since it has its own internal synchronization.  Also, since
    // we are forcing synchronization, we get rid of the chance of an apparent
    // deadlock caused by one thread loading the performance counter dlls
    // and another thread unloading the performance counter dlls

    // Per raid 48395, we aren't going to shut this at all.

#ifdef NTONLY
#endif
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OS::ExecQuery
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32OS::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ )
{
   HRESULT hr;
   CInstancePtr pInstance (CreateNewInstance(pMethodContext), false);

   if (pInstance)
   {
      CSystemName cSN;
      cSN.SetKeys(pInstance);

      if (!pQuery.KeysOnly())
      {
         GetRunningOSInfo(pInstance, cSN.GetLocalizedName(), &pQuery) ;
      }

      hr = pInstance->Commit() ;
   }
   else
   {
      hr = WBEM_E_OUT_OF_MEMORY;
   }

   return hr;

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OS::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    : Returns info for running OS only until we discover other
 *                installed OSes
 *
 *****************************************************************************/

HRESULT CWin32OS::GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery)
{
    CSystemName cSN;

    if (!cSN.ObjectIsUs(pInstance))
    {
        return WBEM_E_NOT_FOUND;
    }

    if (!pQuery.KeysOnly())
    {
        GetRunningOSInfo(pInstance, cSN.GetLocalizedName(), NULL) ;
    }

    return WBEM_S_NO_ERROR;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OS::AddDynamicInstances
 *
 *  DESCRIPTION : Creates instance of property set for each discovered OS
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    : Returns only running OS info until we discover installed OSes
 *
 *****************************************************************************/

HRESULT CWin32OS::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
   // Create instance for running OS
   //===============================
    HRESULT hr = WBEM_S_NO_ERROR;
   CInstancePtr pInstance (CreateNewInstance(pMethodContext), false);
   if (pInstance)
   {
       CSystemName cSN;
       cSN.SetKeys(pInstance);

       GetRunningOSInfo(pInstance, cSN.GetLocalizedName(), NULL) ;
       hr = pInstance->Commit () ;
   }
   else
       hr = WBEM_E_OUT_OF_MEMORY;
   return hr;

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OS::GetRunningOSInfo
 *
 *  DESCRIPTION : Assigns property values according to currently running OS
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void CWin32OS::GetRunningOSInfo(CInstance *pInstance, const CHString &sName, CFrameworkQuery *pQuery)
{
    WCHAR   wszTemp[_MAX_PATH];
    TCHAR   szTemp[_MAX_PATH];
    CRegistry RegInfo ;
    TCHAR szBuffer[MAXI64TOA +1];

    // Refresh properties for running OS (redundant until we're discovering others)
    //=============================================================================

    // EncryptionLevel
    DWORD t_dwCipherStrength = GetCipherStrength() ;
    if( t_dwCipherStrength )
    {
        pInstance->SetWORD( L"EncryptionLevel", t_dwCipherStrength ) ;
    }

    // SystemDrive
    TCHAR t_szDir[_MAX_PATH];
    TCHAR t_szDrive[_MAX_DRIVE];

    if( GetWindowsDirectory( t_szDir, sizeof(t_szDir)/sizeof(TCHAR) ) )
    {
        _tsplitpath( t_szDir, t_szDrive, NULL, NULL, NULL ) ;

        pInstance->SetCharSplat( L"SystemDrive", t_szDrive ) ;
    }


    // Note: use the Ex fields only when an explicit test is made on dwOSVersionInfoSize for Ex length.
#ifdef NTONLY
    OSVERSIONINFOEX OSVersionInfo;
    OSVersionInfo.dwOSVersionInfoSize = IsWinNT5() ? sizeof(OSVERSIONINFOEX) : sizeof(OSVERSIONINFO) ;
#endif


    GetVersionEx((OSVERSIONINFO*)&OSVersionInfo);


#ifdef NTONLY
    // NT 5 and beyond
    if(OSVersionInfo.dwOSVersionInfoSize == sizeof(OSVERSIONINFOEX) )
    {
        pInstance->SetWORD(L"ServicePackMajorVersion", OSVersionInfo.wServicePackMajor);
        pInstance->SetWORD(L"ServicePackMinorVersion", OSVersionInfo.wServicePackMinor);
		pInstance->SetDWORD(L"ProductType", OSVersionInfo.wProductType);
		pInstance->SetDWORD(L"SuiteMask", OSVersionInfo.wSuiteMask);
        pInstance->SetDWORD(L"OSProductSuite", OSVersionInfo.wSuiteMask);
    }
#endif

    // These are 'of-course' until we start discovering 'installed' OS's
    //==================================================================

    pInstance->SetDWORD(L"MaxNumberOfProcesses", 0xffffffff);
    pInstance->SetCharSplat(IDS_Caption, sName);
    pInstance->Setbool(L"Distributed", false);
    pInstance->Setbool(L"Primary", true );
    pInstance->SetCharSplat(IDS_Manufacturer, L"Microsoft Corporation");
    pInstance->SetCharSplat(IDS_CreationClassName, PROPSET_NAME_OS);
    pInstance->SetCharSplat(IDS_CSCreationClassName, PROPSET_NAME_COMPSYS);
    pInstance->SetCHString(L"CSName", GetLocalComputerName());
    pInstance->SetCharSplat(IDS_Status, L"OK");

    SYSTEMTIME tTemp ;
    GetSystemTime(&tTemp) ;
    pInstance->SetDateTime(L"LocalDateTime",tTemp );

    // This may get overridden below
    pInstance->SetCharSplat(L"Description", sName);

    // Extract what we can from OSVERSIONINFO
    //=======================================

    StringCchPrintfW(wszTemp,LENGTH_OF(wszTemp), L"%d.%d.%hu",
        OSVersionInfo.dwMajorVersion, OSVersionInfo.dwMinorVersion,
            LOWORD(OSVersionInfo.dwBuildNumber)) ;
    pInstance->SetCharSplat(L"Version", wszTemp );

    // Windows 95 Build Number is held in the LOWORD of the dwBuildNumber.  The
    // HIWORD echoes the Major and Minor Version Numbers.  NT uses the whole dword
   // for the build number.  We'll be ok for the next ~64000 builds or so
    StringCchPrintfW(wszTemp,LENGTH_OF(wszTemp), L"%hu", LOWORD(OSVersionInfo.dwBuildNumber) ) ;
    pInstance->SetCharSplat(L"BuildNumber", wszTemp);

    pInstance->SetCharSplat(L"CSDVersion", OSVersionInfo.szCSDVersion );


    // Get system directory
    //=================================
    if(GetSystemDirectory(szTemp, sizeof(szTemp) / sizeof(TCHAR)))
    {
        pInstance->SetCharSplat(L"SystemDirectory", szTemp);
    }

    // Amazingly, locale info is in the same place in both NT & Win95 registries
    //==========================================================================

    // Obtain the locale

    if ( GetLocaleInfo( LOCALE_SYSTEM_DEFAULT, LOCALE_ILANGUAGE, szTemp, _MAX_PATH ) )
    {
        pInstance->SetCharSplat(L"Locale", szTemp);
    }

    // Get current Timezone
    TIME_ZONE_INFORMATION   tzone;
    DWORD                   dwRet;

    if (TIME_ZONE_ID_INVALID == (dwRet = GetTimeZoneInformation(&tzone)))
        return;

    if (dwRet == TIME_ZONE_ID_DAYLIGHT)
        tzone.Bias += tzone.DaylightBias;
    else
        // This is normally 0 but is non-zero in some timezones.
        tzone.Bias += tzone.StandardBias;

    pInstance->SetWBEMINT16(IDS_CurrentTimeZone, -1 * tzone.Bias);

    // Obtain the system default Country Code

    if ( GetLocaleInfo( LOCALE_SYSTEM_DEFAULT, LOCALE_ICOUNTRY, szTemp, _MAX_PATH ) )
    {
        pInstance->SetCharSplat(L"CountryCode", szTemp);
    }

    // Obtain the ANSI system default Code Page and stick this puppy in Code Set
    // It's a best guess.  We probably oughta have a separate OEM Code Set property
    // to handle Japanese/Korean/etc.

    if ( GetLocaleInfo( LOCALE_SYSTEM_DEFAULT, LOCALE_IDEFAULTANSICODEPAGE, szTemp, _MAX_PATH ) )
    {
        pInstance->SetCharSplat(L"CodeSet", szTemp);
    }



   if ((pQuery == NULL) || (pQuery->IsPropertyRequired(L"NumberOfProcesses")))
   {
      // Get list of processes
      //==================
      TRefPointerCollection<CInstance> Processes;
      DWORD dwProcesses = 0;
      MethodContext *pMethodContext = pInstance->GetMethodContext();

      if SUCCEEDED(CWbemProviderGlue::GetInstancesByQuery(L"SELECT __RELPATH FROM Win32_Process",
        &Processes, pMethodContext, GetNamespace()))
      {
         REFPTRCOLLECTION_POSITION pos;

         if (Processes.BeginEnum(pos))
         {
            CInstancePtr pProcess;
            for (pProcess.Attach(Processes.GetNext( pos ));
                 pProcess != NULL;
                 pProcess.Attach(Processes.GetNext( pos )))
            {
               dwProcesses++;
            }
         }
         Processes.EndEnum();
      }

      pInstance->SetDWORD(L"NumberOfProcesses", dwProcesses);
   }

   pInstance->Setbool(L"Debug", GetSystemMetrics(SM_DEBUG));

#ifdef NTONLY
    if( IsWinNT5() )
    {
        CKernel32Api* pKernel32 = (CKernel32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidKernel32Api, NULL);
        if(pKernel32 != NULL)
        {

            MEMORYSTATUSEX  stMemoryVLM;
                            stMemoryVLM.dwLength = sizeof( MEMORYSTATUSEX );

            BOOL bRetCode;
            if(pKernel32->GlobalMemoryStatusEx(&stMemoryVLM, &bRetCode) && bRetCode)
            {
                // All divided by 1024 because the units are in KB.
                pInstance->SetCharSplat(_T("FreePhysicalMemory"),
                    _i64tot(stMemoryVLM.ullAvailPhys / 1024, szBuffer, 10));

                pInstance->SetCharSplat(_T("FreeVirtualMemory"),
                    _i64tot( ( stMemoryVLM.ullAvailPhys + stMemoryVLM.ullAvailPageFile ) / 1024, szBuffer, 10));

                pInstance->SetCharSplat(_T("TotalVirtualMemorySize"),
                    _i64tot((stMemoryVLM.ullTotalPhys + stMemoryVLM.ullTotalPageFile ) / 1024, szBuffer, 10));

                pInstance->SetCharSplat(_T("SizeStoredInPagingFiles"),
                    _i64tot(stMemoryVLM.ullTotalPageFile  / 1024, szBuffer, 10));

                pInstance->SetCharSplat(_T("FreeSpaceInPagingFiles"),
                    _i64tot(stMemoryVLM.ullAvailPageFile / 1024, szBuffer, 10));

                pInstance->SetCharSplat(_T("MaxProcessMemorySize"),
                    _i64tot(stMemoryVLM.ullTotalVirtual / 1024, szBuffer, 10));

                pInstance->SetCharSplat(_T("TotalVisibleMemorySize"),
                    _i64tot(stMemoryVLM.ullTotalPhys / 1024, szBuffer, 10));
            }
            CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidKernel32Api, pKernel32);
            pKernel32 = NULL;
        }
  }
  else
#endif
  {
        MEMORYSTATUS stMemory;
        GlobalMemoryStatus(&stMemory);

        // All divided by 1024 because the units are in KB.
        pInstance->SetCharSplat(L"FreePhysicalMemory",
            _i64tot(stMemory.dwAvailPhys / 1024, szBuffer, 10));

        pInstance->SetCharSplat(L"FreeVirtualMemory",
            _i64tot( ( stMemory.dwAvailPhys + stMemory.dwAvailPageFile ) / 1024, szBuffer, 10));

        pInstance->SetCharSplat(L"TotalVirtualMemorySize",
            _i64tot((stMemory.dwTotalPhys + stMemory.dwTotalPageFile ) / 1024, szBuffer, 10));

        pInstance->SetCharSplat(L"SizeStoredInPagingFiles",
            _i64tot(stMemory.dwTotalPageFile  / 1024, szBuffer, 10));

        pInstance->SetCharSplat(L"FreeSpaceInPagingFiles",
            _i64tot(stMemory.dwAvailPageFile / 1024, szBuffer, 10));

        pInstance->SetCharSplat(L"MaxProcessMemorySize",
            _i64tot(stMemory.dwTotalVirtual / 1024, szBuffer, 10));

        pInstance->SetCharSplat(L"TotalVisibleMemorySize",
            _i64tot(stMemory.dwTotalPhys / 1024, szBuffer, 10));
  }


   if (GetWindowsDirectory(szTemp, sizeof(szTemp) / sizeof(TCHAR)))
       pInstance->SetCharSplat(L"WindowsDirectory", szTemp);


    // Now get OS-specific stuff
    //==========================

#ifdef NTONLY
            GetNTInfo(pInstance) ;
#endif

#ifdef _X86_

    if ((USER_SHARED_DATA->ProcessorFeatures[PF_PAE_ENABLED]) )
    {
        pInstance->Setbool(L"PAEEnabled",true);
    }
    else
    {
        pInstance->Setbool(L"PAEEnabled",false);    
    }
     
#endif
}

/*

  This function nor the population of the property TotalSwapSpaceSize
  is needed as Swap files are not distinquished from page files as defined
  by in Cim_OperatingSystem::TotalSwapSpaceSize. Pagefile information may be
  obtained either within this class or from Win32_Pagefile.

__int64 CWin32OS::GetTotalSwapFileSize()
{
    __int64 gazotta = 0;

#ifdef NTONLY
        CRegistry reg;
        CHString sRegValue;

        if(reg.OpenLocalMachineKeyAndReadValue(PAGEFILE_REGISTRY_KEY,
                                               PAGING_FILES,
                                               sRegValue) == ERROR_SUCCESS)
        {
            // pattern is name <space> min size [optional<max size>] 0A repeat...
            // I'll use an ASCII smiley face to replace the delimiter...
            int start = 0, index;
            const TCHAR smiley = '\x02';
            const TCHAR delimiter = '\x0A';
            CHString buf;

            while (-1 != (index = sRegValue.Find(delimiter)))
            {
                // copy to buffer to make life easier
                buf = sRegValue.Mid(start, index - start);
                // mash delimiter so we don't find it again.
                sRegValue.SetAt(index, smiley);
                // save start for next time around.
                start = index +1;

                index = buf.Find(' ');

                if (index != -1)
                    buf.SetAt(index, smiley);

                int end;
                end = buf.Find(' ');

                // if no more spaces, there isn't a max size written down
                // and so max size is 50 more than min
                if (end == -1)
                {
                    CHString littleBuf = buf.Mid(index +1);
                    gazotta += _ttoi(littleBuf) +50;
                }
                else
                {
                    CHString littleBuf = buf.Mid(end);
                    gazotta +=  _ttoi(littleBuf);
                }
            }
        }
#endif
#ifdef WIN9XONLY
        MEMORYSTATUS memoryStatus;
        memoryStatus.dwLength = sizeof(MEMORYSTATUS) ;
        GlobalMemoryStatus(&memoryStatus) ;

        gazotta = memoryStatus.dwTotalPageFile >> 20;
#endif

    return gazotta;
}
*/

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OS::GetNTInfo
 *
 *  DESCRIPTION : Assigns property values for NT
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : OSName is key, we must assign something to it
 *
 *****************************************************************************/

#ifdef NTONLY
void CWin32OS::GetNTInfo(CInstance *pInstance)
{
   CHString sTemp ;
   CRegistry RegInfo ;
   FILETIME   t_ft;
   DWORD dwTemp, dwLicenses;

   pInstance->SetWBEMINT16(_T("OSType"), 18);

    // Get the product id and stuff it into serial number.

    if(RegInfo.Open(HKEY_LOCAL_MACHINE,
                    _T("Software\\Microsoft\\Windows NT\\CurrentVersion"),
                    KEY_READ) == ERROR_SUCCESS) {

        if( ERROR_SUCCESS == RegInfo.GetCurrentKeyValue(_T("ProductId"), sTemp) )
        {
            pInstance->SetCHString(_T("SerialNumber"), sTemp );
        }

        if ( ERROR_SUCCESS == RegInfo.GetCurrentKeyValue(_T("RegisteredOwner"), sTemp) )
        {
           pInstance->SetCHString(_T("RegisteredUser"), sTemp);
        }

        if ( ERROR_SUCCESS == RegInfo.GetCurrentKeyValue(_T("RegisteredOrganization"), sTemp) )
        {
           pInstance->SetCHString(_T("Organization"), sTemp);
        }

        // Raid 18143
        if ( ERROR_SUCCESS == RegInfo.GetCurrentKeyValue(_T("Plus! ProductId"), sTemp) )
        {
           pInstance->SetCHString(_T("PlusProductID"), sTemp);
           if ( ERROR_SUCCESS == RegInfo.GetCurrentKeyValue(_T("Plus! VersionNumber"), sTemp) )
           {
              pInstance->SetCHString(_T("PlusVersionNumber"), sTemp);
           }

        }

        // Build Type from Current Type
        if( ERROR_SUCCESS == RegInfo.GetCurrentKeyValue(_T("CurrentType"), sTemp) )
        {
            pInstance->SetCHString(_T("BuildType"), sTemp );
        }

        // Get the Installation Date as a DWORD.  Convert to time_t
        DWORD   dwInstallDate = 0;
        if( ERROR_SUCCESS == RegInfo.GetCurrentKeyValue(_T("InstallDate"), dwInstallDate) )
        {
            time_t  tTime = (time_t) dwInstallDate;
            WBEMTime wTime(tTime);

            pInstance->SetDateTime(_T("InstallDate"), wTime);
        }

        RegInfo.Close() ;
    }

    if(RegInfo.Open(HKEY_LOCAL_MACHINE,
                    _T("SYSTEM\\Setup"),
                    KEY_READ) == ERROR_SUCCESS) {
        if( ERROR_SUCCESS == RegInfo.GetCurrentKeyValue(_T("SystemPartition"), sTemp) )
        {
            pInstance->SetCharSplat(_T("BootDevice"), sTemp);
        }
    }

    {
        //make sure the buffer goes out of scope soon
        TCHAR szPath[_MAX_PATH];

        if (GetWindowsDirectory(szPath, _MAX_PATH))
        {
            TCHAR ntDosVolume[3] = L"A:";
            ntDosVolume[0] = szPath[0];
            LPTSTR pPath = sTemp.GetBuffer(_MAX_PATH);

            if (QueryDosDevice( ntDosVolume, pPath, _MAX_PATH ) > 0)
            {
                pInstance->SetCharSplat(_T("SystemDevice"), sTemp );
            }
        }
    }

    // Get the last boot time
    CNTLastBootTime ntLastBootTime;

    if ( ntLastBootTime.GetLastBootTime( t_ft ) )
    {
        pInstance->SetDateTime(_T("LastBootupTime"), WBEMTime(t_ft) );
    }

   if(RegInfo.Open(HKEY_LOCAL_MACHINE,
              _T("SYSTEM\\CurrentControlSet\\Control\\PriorityControl"),
              KEY_READ) == ERROR_SUCCESS) {

      if ( ERROR_SUCCESS == RegInfo.GetCurrentKeyValue(_T("Win32PrioritySeparation"), sTemp) )
      {
         dwTemp = _ttoi(sTemp);

         pInstance->SetByte(_T("ForeGroundApplicationBoost"), dwTemp & PROCESS_PRIORITY_SEPARATION_MASK);
         pInstance->SetByte(_T("QuantumType"), (dwTemp & PROCESS_QUANTUM_VARIABLE_MASK) >> 2);
         pInstance->SetByte(_T("QuantumLength"), (dwTemp & PROCESS_QUANTUM_LONG_MASK) >> 4);

      }
   }

   CNetAPI32 NetApi;
   PWKSTA_INFO_102 pw = NULL;
   PSERVER_INFO_101 ps = NULL;

   if( NetApi.Init() == ERROR_SUCCESS ) {
      if (NetApi.NetWkstaGetInfo(NULL, 102, (LPBYTE *)&pw) == NERR_Success)
      {
         OnDeleteObj<void *,CNetAPI32,DWORD(__stdcall CNetAPI32::*)(void *), &CNetAPI32::NetApiBufferFree> FreeBuff(&NetApi,pw);

         pInstance->SetDWORD(_T("NumberOfUsers"), pw->wki102_logged_on_users);
      }
      if (NetApi.NetServerGetInfo(NULL, 101, (LPBYTE *)&ps) == NERR_Success)
      {
         OnDeleteObj<void *,CNetAPI32,DWORD(__stdcall CNetAPI32::*)(void *), &CNetAPI32::NetApiBufferFree> FreeBuff(&NetApi,ps);
             if (ps->sv101_comment != NULL)
             {
                pInstance->SetWCHARSplat(IDS_Description, (WCHAR *)ps->sv101_comment);
             }
      }
   }

    if (!IsWinNT5()) {
        if (RegInfo.Open(HKEY_USERS,
            _T(".DEFAULT\\Control Panel\\International"), KEY_QUERY_VALUE) == ERROR_SUCCESS) {
            CHString sLang;
            LANGID dwOSLanguage = 0;
            if (RegInfo.GetCurrentKeyValue(_T("Locale"), sLang) == ERROR_SUCCESS) {
                _stscanf(sLang, _T("%x"), &dwOSLanguage);
                pInstance->SetDWORD(_T("OSLanguage"), dwOSLanguage);
            }
        }
    } else {
        LANGID dwOSLanguage = 0;
        CKernel32Api* pKernel32 = (CKernel32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidKernel32Api, NULL);
        if(pKernel32 != NULL)
        {
            if(pKernel32->GetSystemDefaultUILanguage(&dwOSLanguage))
            {   // The function existed. Its result is in dwOSLanguage.
                pInstance->SetDWORD(_T("OSLanguage"), dwOSLanguage);
            }
            CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidKernel32Api, pKernel32);
            pKernel32 = NULL;
        }
    }

    // raid 354436
    if(IsWinNT5()) 
    {
        if(RegInfo.Open(
            HKEY_LOCAL_MACHINE,
            _T("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management"),
            KEY_READ) == ERROR_SUCCESS) 
        {
            if(ERROR_SUCCESS == RegInfo.GetCurrentKeyValue(IDS_LargeSystemCache, sTemp))
            {
                dwTemp = _ttoi(sTemp);
                pInstance->SetDWORD(IDS_LargeSystemCache, dwTemp);
            }
        }
    }

   if (GetLicensedUsers(&dwLicenses)) {
      pInstance->SetDWORD(_T("NumberOfLicensedUsers"), dwLicenses);
   }

}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OS::PutInstance
 *
 *  DESCRIPTION : Write changed instance
 *
 *  INPUTS      : pInstance to store data from
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32OS::PutInstance(const CInstance &pInstance, long lFlags /*= 0L*/)
{
    // Tell the user we can't create a new os (much as we might like to)
    if (lFlags & WBEM_FLAG_CREATE_ONLY)
        return WBEM_E_UNSUPPORTED_PARAMETER;

    CHString        sTemp,
                    newDesc;
    volatile DWORD  dwQuantum = 0;
    volatile DWORD  dwCurrent;
    HRESULT         hRet = WBEM_S_NO_ERROR;
    CRegistry       RegInfo;
    BOOL            bWrite = FALSE,
                    bNewComment = FALSE;
    BYTE            btByte;
    CSystemName     cSN;

    // store up here for possible rollback later.
    CNetAPI32       NetApi;
    LPWSTR          oldDesc = NULL;
    PSERVER_INFO_101
                    ps = NULL;

    if (!cSN.ObjectIsUs(&pInstance))
    {
        if (lFlags & WBEM_FLAG_UPDATE_ONLY)
            hRet = WBEM_E_NOT_FOUND;
        else
            hRet = WBEM_E_UNSUPPORTED_PARAMETER;
    }
    else
    {
        //BIG NOTE: even though sv101_comment is declared tchar, its always wchar.

        // Check to see which properties they set.
#ifdef NTONLY
        if (!pInstance.IsNull(IDS_Description))
        {
            pInstance.GetCHString(IDS_Description, newDesc);

            // if inited...
            if (NetApi.Init() == ERROR_SUCCESS &&
                NetApi.NetServerGetInfo(NULL, 101, (LPBYTE *) &ps) ==
                NERR_Success)
            {
                // if the comment changed....
                if (wcscmp(newDesc, (WCHAR *) ps->sv101_comment) != 0)
                {
                    // save the ptr for possible rollback. Remember is really wchar.
                    oldDesc = (LPWSTR)ps->sv101_comment;

                    // use the new comment.
                    ps->sv101_comment = (LPWSTR) (LPCWSTR) newDesc;

                    // save it.
                    NET_API_STATUS stat = NetApi.NetServerSetInfo(NULL, 101, (LPBYTE)ps, NULL);
                    if (stat == NERR_Success)
                    {
                        bNewComment = true;
                        hRet = WBEM_S_NO_ERROR;
                    }
                    else if (stat == ERROR_ACCESS_DENIED)
                        hRet = WBEM_E_ACCESS_DENIED;
                    else
                        hRet = WBEM_E_FAILED;

                } //endif newDesc

            } //endif NetServerGetInfo()
        } //endif !pInstance.IsNull(IDS_Description)

        // if anything went wrong, bail out now.
        if (hRet != WBEM_S_NO_ERROR)
        {
            // clean up for early return.
            ps->sv101_comment = (LPWSTR) (LPCTSTR) oldDesc;
            NetApi.NetApiBufferFree(ps);
            return hRet;
        }
#endif


        //-------------------------------------------
        // Assume the registry stuff is going to fail
        hRet = WBEM_E_FAILED;
        LONG regErr;
        regErr = RegInfo.Open(HKEY_LOCAL_MACHINE,
           L"SYSTEM\\CurrentControlSet\\Control\\PriorityControl",
           KEY_READ|KEY_WRITE);
        if (regErr == ERROR_SUCCESS)
        {
            if (ERROR_SUCCESS == RegInfo.GetCurrentKeyValue(
                L"Win32PrioritySeparation", sTemp))
            {

                // Ok, so now let's assume things are going to work
                hRet = WBEM_S_NO_ERROR;
                dwCurrent = _wtoi(sTemp);

                // Check to see which properties they set
                if (!pInstance.IsNull(L"ForegroundApplicationBoost"))
                {
                    // Check for value in range
                    pInstance.GetByte(L"ForegroundApplicationBoost", btByte);
                    if (((btByte & (~PROCESS_PRIORITY_SEPARATION_MASK)) != 0) ||
                        (btByte == 3))
                        hRet = WBEM_E_VALUE_OUT_OF_RANGE;
                    else
                        // Build up our dword to write
                        dwQuantum |= btByte;

                    // Clear out the bits we are going to reset
                    dwCurrent &= (~PROCESS_PRIORITY_SEPARATION_MASK);
                    bWrite = true;
                }
            }

            // Check to see which properties they set
            if (!pInstance.IsNull(L"QuantumType"))
            {
                // Check for value in range
                pInstance.GetByte(L"QuantumType", btByte);
                btByte = btByte << 2;
                if (((btByte & (~PROCESS_QUANTUM_VARIABLE_MASK)) != 0) ||
                    (btByte == 0xc))
                    hRet = WBEM_E_VALUE_OUT_OF_RANGE;
                else
                    // Build up our dword to write
                    dwQuantum |= btByte;

                // Clear out the bits we are going to reset
                dwCurrent &= (~PROCESS_QUANTUM_VARIABLE_MASK);
                bWrite = true;
            }

            // Check to see which properties they set
            if (!pInstance.IsNull(L"QuantumLength"))
            {
                pInstance.GetByte(L"QuantumLength", btByte);

                // Check for value in range
                btByte = btByte << 4;
                if (((btByte & (~PROCESS_QUANTUM_LONG_MASK)) != 0) ||
                    (btByte == 0x30))
                    hRet = WBEM_E_VALUE_OUT_OF_RANGE;
                else
                {
                    // Build up our dword to write
                    dwQuantum |= btByte;

                    // Clear out the bits we are going to reset
                    dwCurrent &= (~PROCESS_QUANTUM_LONG_MASK);
                    bWrite = TRUE;
                }
            }

            // If anything to write and none of the above failed
            if (bWrite && hRet == WBEM_S_NO_ERROR)
            {
                dwCurrent |= dwQuantum;

                // Fixes what is an optimization bug on Alphas(??)  Something
                // about accessing the variable.  Lie back and think of the
                // Z-80...

                CHString strDummy;

                strDummy.Format(L"%d",dwCurrent);

                regErr = RegSetValueEx(RegInfo.GethKey(),
                        _T("Win32PrioritySeparation"),
                        0,
                        REG_DWORD,
                        (const unsigned char *)&dwCurrent,
                        sizeof(DWORD));
                if (regErr == ERROR_ACCESS_DENIED)
                    hRet = WBEM_E_ACCESS_DENIED;
                else if (regErr != ERROR_SUCCESS)
                  hRet = WBEM_E_FAILED;
                else
                    hRet = WBEM_S_NO_ERROR;
             }
        } // endif (regErr == ERROR_SUCCESS
        else if (regErr == ERROR_ACCESS_DENIED)
            hRet = WBEM_E_ACCESS_DENIED;
        else
            hRet = WBEM_E_FAILED;
    }

#ifdef NTONLY
    // if registry went wrong, rollback the NetServerSetInfo(),
    // if necesssary...
    if (hRet != WBEM_S_NO_ERROR && bNewComment)
    {
        // if inited...
        if (NetApi.Init() == ERROR_SUCCESS && ps)
        {
            // put the old comment back.
            ps->sv101_comment = (LPWSTR) (LPCTSTR) oldDesc;

            // restore the previous comment. Keep the previous error code.
            // This is just a rollback. If its fails, oh well.
            NetApi.NetServerSetInfo(NULL, 101, (LPBYTE) ps, NULL);
        } //endif NetApi.Init()
    }

    // put the old ptr back so it can be freed.
    if (ps)
    {
        ps->sv101_comment = (LPTSTR)oldDesc;
        NetApi.NetApiBufferFree(ps);
    }

    // raid 354436
    if(hRet == WBEM_S_NO_ERROR)
    {
        if(!pInstance.IsNull(IDS_LargeSystemCache))
        {
            DWORD dwCacheSize = 0;
            pInstance.GetDWORD(IDS_LargeSystemCache, dwCacheSize);

            CRegistry reg;

            DWORD dwRet = reg.CreateOpen(
                HKEY_LOCAL_MACHINE,
                L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management");
            
            if(ERROR_SUCCESS == dwRet)
            {
                if((dwRet = reg.SetCurrentKeyValue(IDS_LargeSystemCache, dwCacheSize)) != ERROR_SUCCESS)
                {
                    hRet = WinErrorToWBEMhResult(dwRet);
                }
                
                reg.Close();
            }
            else
            {
                hRet = WinErrorToWBEMhResult(dwRet);
            }
        }
    }

#endif

    return hRet;
}

bool GetLoggedOnUserSessionIDViaTS(DWORD& sessionID)
{
    bool fRet = false;
    PWTS_SESSION_INFO psesinfo = NULL;
    DWORD dwSessions = 0;
    LPWSTR wstrUserName = NULL;
    LPWSTR wstrDomainName = NULL;
    LPWSTR wstrWinstaName = NULL;
    DWORD dwSize = 0L;
 

    if(!(::WTSEnumerateSessions(
       WTS_CURRENT_SERVER_HANDLE,
       0,
       1,
       &psesinfo,
       &dwSessions) && psesinfo)) return false;
    OnDelete<PVOID,VOID(*)(PVOID),WTSFreeMemory> relSeInfo(psesinfo);
                
    for(int j = 0; j < dwSessions && !fRet; j++)
    {
        if(psesinfo[j].State != WTSActive)
        {
            continue;
        }

        if(!(::WTSQuerySessionInformation(
            WTS_CURRENT_SERVER_HANDLE,
            psesinfo[j].SessionId,
            WTSUserName,
            &wstrUserName,
            &dwSize) && wstrUserName))
        {
            continue;
        }
        OnDelete<PVOID,VOID(*)(PVOID),WTSFreeMemory> relUser(wstrUserName);
        
        if(!(::WTSQuerySessionInformation(
            WTS_CURRENT_SERVER_HANDLE,
            psesinfo[j].SessionId,
            WTSDomainName,
            &wstrDomainName,
            &dwSize) && wstrDomainName))
        {
            continue;
        }
        OnDelete<PVOID,VOID(*)(PVOID),WTSFreeMemory> relDomain(wstrDomainName);   
            

        if(!(::WTSQuerySessionInformation(
            WTS_CURRENT_SERVER_HANDLE,
            psesinfo[j].SessionId,
            WTSWinStationName,
            &wstrWinstaName,
            &dwSize) && wstrWinstaName))   
        {
            continue;
        }
        OnDelete<PVOID,VOID(*)(PVOID),WTSFreeMemory> relWinSta(wstrWinstaName);   

        if(_wcsicmp(wstrWinstaName, L"Console") != 0)
        {
            continue;
        }
        
        sessionID = psesinfo[j].SessionId;
        fRet = true;
    }
 
    return fRet;
}


/*****************************************************************************
 *
 *  FUNCTION    : CWin32OS::ExecMethod
 *
 *  DESCRIPTION : Executes a method
 *
 *  INPUTS      : Instance to execute against, method name, input parms instance
 *                Output parms instance.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32OS::ExecMethod(const CInstance& pInstance, const BSTR bstrMethodName, CInstance *pInParams, CInstance *pOutParams, long lFlags /*= 0L*/)
{
    CSystemName cSN;
    DWORD       dwFlags,
                dwReserved;
    bool        bDoit = true;
    DWORD       dwMode = -1, dwError;
    bool        fLogoff = false;

        // Is this our instance?
    if (!cSN.ObjectIsUs(&pInstance))
    {
        return WBEM_E_NOT_FOUND;
    }

    if (_wcsicmp(bstrMethodName, L"SetDateTime") == 0)
    {    
        if( !pInParams->IsNull( L"LocalDateTime") )
        {
            SYSTEMTIME    t_SysTime ;
            WBEMTime    t_wTime ;

            if (EnablePrivilegeOnCurrentThread( SE_SYSTEMTIME_NAME ))
            {
                pInParams->GetDateTime( L"LocalDateTime", t_wTime ) ;

                if (t_wTime.IsOk())
                {
                    t_wTime.GetSYSTEMTIME( &t_SysTime ) ;

                    if( SetSystemTime( &t_SysTime ) )
                    {
                        pOutParams->SetDWORD ( L"ReturnValue", 0 ) ;
                        return WBEM_S_NO_ERROR;
                    }
                    else
                    {
                        return WBEM_E_FAILED ;
                    }
                }
                else
                {
                    return WBEM_E_INVALID_PARAMETER;
                }
            }
            else
            {
                SetSinglePrivilegeStatusObject(pInstance.GetMethodContext(), SE_SYSTEMTIME_NAME);
                return WBEM_E_ACCESS_DENIED;
            }
        }
        else
        {
            return WBEM_E_INVALID_PARAMETER;
        }
    }



    // Do we recognize the method?
    if (_wcsicmp(bstrMethodName, L"Win32ShutDown") == 0)
    {
        bool t_Exists; VARTYPE t_Type ;
        // See what they asked for
        if ( pInParams->GetStatus ( L"Flags", t_Exists , t_Type ) )
        {
            if ( t_Exists && ( t_Type == VT_I4 ) )
            {
                if ( pInParams->GetDWORD ( L"Flags" , dwFlags ) )
                {
                }
                else
                {
                    pOutParams->SetDWORD ( L"ReturnValue" , ERROR_INVALID_PARAMETER ) ;
                    return S_OK ;
                }
                if(dwFlags == 0)
                {
                    fLogoff = true;
                }
            }
            else
            {
                pOutParams->SetDWORD ( L"ReturnValue" , ERROR_INVALID_PARAMETER ) ;
                return S_OK ;
            }
        }
        else
        {
            pOutParams->SetDWORD ( L"ReturnValue" , ERROR_INVALID_PARAMETER ) ;
            return WBEM_E_PROVIDER_FAILURE ;
        }

        DWORD t_dwForceIfHungOption = 0 ;
#ifdef NTONLY
        if ( IsWinNT5() )
        {
            t_dwForceIfHungOption = EWX_FORCEIFHUNG ;
        }
#endif
        if ( dwFlags == EWX_LOGOFF || dwFlags == ( EWX_LOGOFF | EWX_FORCE ) || dwFlags == ( EWX_LOGOFF | t_dwForceIfHungOption ) ||
             dwFlags == EWX_SHUTDOWN || dwFlags == ( EWX_SHUTDOWN | EWX_FORCE ) || dwFlags == ( EWX_SHUTDOWN | t_dwForceIfHungOption ) ||
             dwFlags == EWX_REBOOT || dwFlags == ( EWX_REBOOT | EWX_FORCE ) || dwFlags == ( EWX_REBOOT | t_dwForceIfHungOption ) ||
             dwFlags == EWX_POWEROFF || dwFlags == ( EWX_POWEROFF | EWX_FORCE ) || dwFlags == ( EWX_POWEROFF | t_dwForceIfHungOption )
            )
        {
            if ( dwFlags == EWX_LOGOFF || dwFlags == ( EWX_LOGOFF | EWX_FORCE ) || dwFlags == ( EWX_LOGOFF | t_dwForceIfHungOption ) )
            {
                fLogoff = true;
            }
        }
        else
        {
            pOutParams->SetDWORD ( L"ReturnValue" , ERROR_INVALID_PARAMETER ) ;
            return S_OK ;
        }

        pInParams->GetDWORD(L"Reserved", dwReserved);
        dwMode = 0;
    }
    else if (_wcsicmp(bstrMethodName, L"ShutDown") == 0)
    {
        dwReserved = 0;
        dwMode = 1;

#ifdef NTONLY
        if ( IsWinNT5() )
        {
            dwFlags = EWX_SHUTDOWN | EWX_FORCEIFHUNG ;
        }
        else
        {
            dwFlags = EWX_SHUTDOWN | EWX_FORCE;
        }
#endif
    }
    else if (_wcsicmp(bstrMethodName, L"Reboot") == 0)
    {
        dwReserved = 0;
        dwMode = 2;
#ifdef NTONLY
        if ( IsWinNT5() )
        {
            dwFlags = EWX_REBOOT | EWX_FORCEIFHUNG ;
        }
        else
        {
            dwFlags = EWX_REBOOT | EWX_FORCE;
        }
#endif
    }
    else if (_wcsicmp(bstrMethodName, L"Win32AbortShutdown") == 0)
    {
#if NTONLY >= 5
        dwMode = 3;
#else
        return WBEM_E_NOT_SUPPORTED;
#endif
    }
    else
    {
        return WBEM_E_INVALID_METHOD;
    }


/*
 * If the user has done a remote login, check if he has remote-shutdown privilege
 * if the user has logged locally, check if he has shutdown privilege. API Calls work only on NT5.
 */
#ifdef NTONLY
    if(!fLogoff) // only need to check for these privs if we were requesting something other than logoff
    {
        DWORD t_dwLastError ;
        bDoit = CanShutdownSystem ( pInstance, t_dwLastError );
        if ( !bDoit )
        {
            return WBEM_E_PRIVILEGE_NOT_HELD ;
        }
    }
#endif


    // Clear error
    SetLastError(0);

#if NTONLY >= 5
    DWORD dwTimeout = 0;
    bool bForceShutDown = false;
    bool bRebootAfterShutdown = false;
    BOOL bInitiateShutDown = FALSE;

    CHString t_ComputerName ( GetLocalComputerName() );
    if ( bDoit )
    {
        if ( dwMode == 3 )
        {
            // AbortShutDown
            BOOL bSuccess = AbortSystemShutdown( t_ComputerName.GetBuffer ( 0 ) );
        }
        else if ( dwMode == 0  && !fLogoff )
        {
            // InitiateShutDown
            bool t_Exists; VARTYPE t_Type ;
            // See what they asked for
            if ( pInParams->GetStatus ( L"Timeout", t_Exists , t_Type ) )
            {
                if ( t_Exists && ( t_Type == VT_I4 ) )
                {
                    pInParams->GetDWORD ( L"Timeout" , dwTimeout );
                }
                else
                if ( t_Exists && ( t_Type != VT_I4 ) )
                {
                    pOutParams->SetDWORD ( L"ReturnValue" , ERROR_INVALID_PARAMETER );
                    return WBEM_E_PROVIDER_FAILURE ;
                }
            }

            if ( pInParams->GetStatus ( L"ForceShutdown", t_Exists , t_Type ) )
            {
                if ( t_Exists && ( t_Type == VT_BOOL ) )
                {
                    pInParams->Getbool ( L"ForceShutdown" , bForceShutDown );
                }
                else
                if ( t_Exists && ( t_Type != VT_BOOL ) )
                {
                    pOutParams->SetDWORD ( L"ReturnValue" , ERROR_INVALID_PARAMETER );
                    return WBEM_E_PROVIDER_FAILURE ;
                }
            }

            if ( pInParams->GetStatus ( L"RebootAfterShutdown", t_Exists , t_Type ) )
            {
                if ( t_Exists && ( t_Type == VT_BOOL ) )
                {
                    pInParams->Getbool ( L"RebootAfterShutdown" , bRebootAfterShutdown );
                }
                else
                if ( t_Exists && ( t_Type != VT_BOOL ) )
                {
                    pOutParams->SetDWORD ( L"ReturnValue" , ERROR_INVALID_PARAMETER );
                    return WBEM_E_PROVIDER_FAILURE ;
                }
            }

            // For Win32ShutDown(), set the value of bRebootAfterShutdown based on the flags parameter
            if(dwFlags & EWX_REBOOT)
                bRebootAfterShutdown = true;

            if( dwFlags & EWX_FORCE)
                bForceShutDown = true;
            
            // In case we shut down successfully, need to set the
            // return value here while we can.  If shutdown fails,
            // this value will get overwritten below.
            pOutParams->SetDWORD(L"ReturnValue", 0);

            if(dwFlags & EWX_POWEROFF)
            {
				bInitiateShutDown = ExitWindowsEx ( dwFlags, SHTDN_REASON_LEGACY_API | SHTDN_REASON_MINOR_WMI ) ;
            }
            else
            {
                bInitiateShutDown = InitiateSystemShutdownEx(
                    t_ComputerName.GetBuffer(0), 
                    NULL, 
                    dwTimeout, 
                    (bForceShutDown)? TRUE:FALSE, 
                    (bRebootAfterShutdown)? TRUE:FALSE,
                    SHTDN_REASON_LEGACY_API | SHTDN_REASON_MINOR_WMI );
            }
        }
    }
#endif
    // This might get overwritten below
    dwError = GetLastError();
    // Get the error (if any)
    pOutParams->SetDWORD(L"ReturnValue", dwError);

    // If we're still set to go, make the call
    if (bDoit)
    {
#ifdef NTONLY
        if ( dwMode != 3 )
        {
            if ( !fLogoff )
            {
#if NTONLY >= 5
                if ( ! bInitiateShutDown )
                {
                    if(dwFlags & EWX_REBOOT)
                    {
                        bRebootAfterShutdown = true;
                    }
                    if( dwFlags & EWX_FORCE)
                    {
                        bForceShutDown = true;
                    }
                    
                    if(dwFlags & EWX_POWEROFF)
                    {
						bInitiateShutDown = ExitWindowsEx ( dwFlags, SHTDN_REASON_LEGACY_API | SHTDN_REASON_MINOR_WMI ) ;
                    }
                    else
                    {
                        bInitiateShutDown = ::InitiateSystemShutdownEx( 
                            t_ComputerName.GetBuffer(0), 
                            NULL, 
                            dwTimeout, 
                            (bForceShutDown)? TRUE:FALSE, 
                            (bRebootAfterShutdown)? TRUE:FALSE,
                            SHTDN_REASON_LEGACY_API | SHTDN_REASON_MINOR_WMI );
                    }

                    dwError = GetLastError();
                }
#else
                if(dwFlags & EWX_REBOOT)
                {
                    bRebootAfterShutdown = true;
                }
                if( dwFlags & EWX_FORCE)
                {
                    bForceShutDown = true;
                }
                
                bInitiateShutDown = InitiateSystemShutdownEx( 
                    t_ComputerName.GetBuffer(0), 
                    NULL, 
                    dwTimeout, 
                    (bForceShutDown)? TRUE:FALSE, 
                    (bRebootAfterShutdown)? TRUE:FALSE,
                    SHTDN_REASON_FLAG_PLANNED | SHTDN_REASON_MINOR_NONE | SHTDN_REASON_MAJOR_NONE );

                dwError = GetLastError();
#endif
            }
            else
            {
                DWORD sessionID;

                if (GetLoggedOnUserSessionIDViaTS(sessionID))
                {
                    // Otherwise, they requested a logoff.
                    if(!::WTSLogoffSession(
                        WTS_CURRENT_SERVER_HANDLE,       // specifies the terminal server on which this process is running
                        sessionID,                       
                        FALSE))                          // return immediately, don't wait
                    {
                        dwError = GetLastError();
                    }
                }
                else
                    return WBEM_E_FAILED;
            }
        
            // Get the error (if any)
            pOutParams->SetDWORD(_T("ReturnValue"), dwError);
        }
#endif

    }
    else
    {
        return WBEM_E_PRIVILEGE_NOT_HELD ;
    }

    // The call to *us* suceeded, so WBEM_S_NO_ERROR is correct
    return WBEM_S_NO_ERROR;
}



/*****************************************************************************
 *
 *  FUNCTION    : CWin32OS::GetLicensedUsers
 *
 *  DESCRIPTION :
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : Number of licenses
 *
 *  RETURNS     : true/false (succeeded or failed)
 *
 *  COMMENTS    : This routine will fail if LLSMGR has never been run on this
 *                computer.
 *
 *****************************************************************************/
#ifdef NTONLY
bool CWin32OS::GetLicensedUsers(DWORD *dwRetVal)
{
//    Use registry as per licensing team's (rashmip) advice...
//    \HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LicenseInfo\FilePrint
//  Mode : REG_DWORD :  (0x0 = Per Seat Mode, 0x1 = Concurrent/Per Server Mode)
//  ConcurrentLimit : REG_DWORD : (0x<limit>, ie. 0x100 = 256 concurrent user limit)

    bool retVal = false;

    if (dwRetVal)
    {
        *dwRetVal = 0;
        CRegistry t_RegInfo;

        if(t_RegInfo.Open(HKEY_LOCAL_MACHINE,
            _T("SYSTEM\\CurrentControlSet\\Services\\LicenseInfo\\FilePrint"),
            KEY_READ) == ERROR_SUCCESS)
        {
            DWORD   t_dwL = 0;

            if( ERROR_SUCCESS == t_RegInfo.GetCurrentKeyValue(_T("ConcurrentLimit"), t_dwL) )
            {
                *dwRetVal = t_dwL;
                retVal = true;
            }
        }
    }

    return retVal;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OS::GetCollection
 *
 *  DESCRIPTION : Given an interface pointer, property name, and parameters,
 *                returns the IDispatch pointer for the collection
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : Either a valid pointer, or NULL on error
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
IDispatch FAR* CWin32OS::GetCollection(IDispatch FAR* pIn, WCHAR *wszName, DISPPARAMS *pDispParams)
{
   HRESULT hResult;
   DISPID didID;
   IDispatch FAR* pOut = NULL;
   variant_t VarResult;

   bstr_t szMember(wszName);
   BSTR bstrMember = szMember;
   hResult = pIn->GetIDsOfNames(IID_NULL, &bstrMember, 1,
                   LOCALE_USER_DEFAULT, &didID);

   if (SUCCEEDED(hResult) && (didID != -1)) {
      hResult = pIn->Invoke(
           didID,
           IID_NULL,
           LOCALE_USER_DEFAULT,
           DISPATCH_PROPERTYGET | DISPATCH_METHOD,
           pDispParams, &VarResult, NULL, NULL);

      if (SUCCEEDED(hResult) && (V_VT(&VarResult) == VT_DISPATCH)) {

         pOut = V_DISPATCH(&VarResult);
         if (pOut != NULL)
            pOut->AddRef();
      }
   }

   return pOut;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OS::GetValue
 *
 *  DESCRIPTION : Given an interface pointer and property name, gets the value
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : The variant containing the value
 *
 *  RETURNS     : True/false indicating whether the function succeeded.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
bool CWin32OS::GetValue(IDispatch FAR* pIn, WCHAR *wszName, VARIANT *vValue)
{
   HRESULT hResult;
   DISPID didID;
   DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};

   bstr_t szMember (wszName);
   BSTR bstrMember = szMember;

    hResult = pIn->GetIDsOfNames(IID_NULL, &bstrMember, 1,
                            LOCALE_USER_DEFAULT, &didID);
    hResult = pIn->Invoke(
                    didID,
                    IID_NULL,
                    LOCALE_USER_DEFAULT,
                    DISPATCH_PROPERTYGET | DISPATCH_METHOD,
                    &dispparamsNoArgs, vValue, NULL, NULL);

   return (SUCCEEDED(hResult));
}

#ifdef NTONLY

BOOL CWin32OS::CanShutdownSystem ( const CInstance& a_Instance , DWORD &a_dwLastError )
{

    SmartCloseHandle t_hToken;
    PSID t_pNetworkSid = NULL ;
    CAdvApi32Api *t_pAdvApi32 = NULL;
    a_dwLastError = 0 ;
    BOOL t_bStatus;

        t_bStatus = OpenThreadToken (

            GetCurrentThread () ,
            TOKEN_QUERY ,
            FALSE ,
            & t_hToken
        ) ;

        if ( !t_bStatus )
        {
            a_dwLastError = GetLastError () ;
            return t_bStatus ;
        }

#if NTONLY >= 5

        BOOL t_bNetworkLogon ;

        SID_IDENTIFIER_AUTHORITY t_NtAuthority = SECURITY_NT_AUTHORITY ;
        t_bStatus = AllocateAndInitializeSid (

                        &t_NtAuthority,
                        1,
                        SECURITY_NETWORK_RID,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        &t_pNetworkSid
                    ) ;

        if ( t_bStatus )
        {
            OnDelete<PSID,PVOID(*)(PSID),FreeSid> FreeMe(t_pNetworkSid ) ;
            
            t_pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL);

            if(t_pAdvApi32 == NULL)  return FALSE ;

            CRelResource ReMe(&CResourceManager::sm_TheResourceManager,g_guidAdvApi32Api,t_pAdvApi32);
            
 
                BOOL t_bRetVal = FALSE ;
                if ( t_pAdvApi32->CheckTokenMembership ( t_hToken, t_pNetworkSid, &t_bNetworkLogon , &t_bRetVal ) && t_bRetVal )
                {
                }
                else
                {
                    a_dwLastError = GetLastError();
                    t_bStatus = FALSE ;
                }
 
        }
        else
        {
            a_dwLastError = GetLastError() ;
        }

#endif

        if ( t_bStatus )
        {
            LUID t_PrivilegeRequired ;
            bstr_t t_bstrtPrivilege ;

#if NTONLY >= 5
            if ( t_bNetworkLogon )
            {
                t_bstrtPrivilege = SE_REMOTE_SHUTDOWN_NAME ;
            }
            else
            {
                t_bstrtPrivilege = SE_SHUTDOWN_NAME ;
            }
#else
            t_bstrtPrivilege = SE_SHUTDOWN_NAME ;
#endif


            {
                t_bStatus = LookupPrivilegeValue (

                                    (LPTSTR) NULL,
                                    t_bstrtPrivilege,
                                    &t_PrivilegeRequired
                                ) ;
            }

            if ( t_bStatus )
            {
                PRIVILEGE_SET t_PrivilegeSet ;
                t_PrivilegeSet.PrivilegeCount = 1;
                t_PrivilegeSet.Control = PRIVILEGE_SET_ALL_NECESSARY ;
                t_PrivilegeSet.Privilege[0].Luid = t_PrivilegeRequired ;
                t_PrivilegeSet.Privilege[0].Attributes = 0;

                BOOL t_bPrivileged ;
                t_bStatus = PrivilegeCheck (

                                t_hToken,
                                &t_PrivilegeSet,
                                &t_bPrivileged
                            );
                if ( t_bStatus )
                {
                    if ( !t_bPrivileged )
                    {
                        SetSinglePrivilegeStatusObject ( a_Instance.GetMethodContext () , t_bstrtPrivilege ) ;
                        t_bStatus = FALSE ;
                    }
                }
                else
                {
                    a_dwLastError = GetLastError();
                }
            }
            else
            {
                a_dwLastError = GetLastError();
            }
        }

 

        return t_bStatus ;
}

#endif

//=================================================================
// GetCipherStrength - Returns the maximum cipher strength
//=================================================================
DWORD CWin32OS::GetCipherStrength()
{
    DWORD    t_dwKeySize = 0;

    CSecurityApi* t_pSecurity = (CSecurityApi*)
                                CResourceManager::sm_TheResourceManager.GetResource(g_guidSecurApi, NULL);

    if( t_pSecurity == NULL ) return t_dwKeySize;

    CRelResource ReMe(&CResourceManager::sm_TheResourceManager,g_guidSecurApi,t_pSecurity);

    TimeStamp                    t_tsExpiry ;
    CredHandle                    t_chCred ;
    SecPkgCred_CipherStrengths    t_cs ;

    if( S_OK == t_pSecurity->AcquireCredentialsHandleW(
                    NULL,
                    UNISP_NAME_W, // Package
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &t_chCred,    // Handle
                    &t_tsExpiry ) )
    {
        if( S_OK == t_pSecurity->QueryCredentialsAttributesW(
                        &t_chCred,
                        SECPKG_ATTR_CIPHER_STRENGTHS, &t_cs ) )
        {
            t_dwKeySize = t_cs.dwMaximumCipherStrength ;
        }

        // Free the handle
        t_pSecurity->FreeCredentialsHandle( &t_chCred ) ;
    }

    return t_dwKeySize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\nvram.cpp ===
//================================================================

//

// nvram.cpp - implementation of NVRam functions from setupdll.dll

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// 08/05/98     sotteson     created
//
//================================================================








#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"
#include <cregcls.h>

//#if defined(EFI_NVRAM_ENABLED)
#if defined(_IA64_)

#include <ntsecapi.h>
#define BOOT_ENTRY_ATTRIBUTE_REMOVABLE_MEDIA    0x00000008
#include "DllWrapperBase.h"
#include "ntdllapi.h"
#include "nvram.h"

/*****************************************************************************
 *
 *  FUNCTION    : CNVRam::CNVRam
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CNVRam::CNVRam()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CNVRam::~CNVRam
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CNVRam::~CNVRam()
{
}

CNVRam::InitReturns CNVRam::Init ()
{
	if ( !EnablePrivilegeOnCurrentThread ( SE_SYSTEM_ENVIRONMENT_NAME ) )
	{
		return PrivilegeNotHeld;
	}
	else
	{
		return Success ;
	}
}


BOOL CNVRam::GetNVRamVar(LPWSTR szVar, CHSTRINGLIST *pList)
{
	CHString str;

	pList->clear();

	if (!GetNVRamVarRaw(szVar, str))
		return FALSE;

	while(str.GetLength())
	{
		CHString strValue = str.SpanExcluding(L";");

		pList->push_back(strValue);

		// Get past ';'
		str = str.Mid(strValue.GetLength() + 1);
	}

	return TRUE;
}

BOOL CNVRam::GetNVRamVar(LPWSTR szVar, DWORD *pdwValue)
{
	CHString str;

	if (!GetNVRamVar(szVar, str))
		return FALSE;

	*pdwValue = (DWORD) _wtoi(str);

	return TRUE;
}

BOOL CNVRam::GetNVRamVar(LPWSTR szVar, CHString &strValue)
{
	CHString str;

	if (!GetNVRamVarRaw(szVar, str))
		return FALSE;

	// Just return the first value.
    strValue = str.SpanExcluding(L";");

	return TRUE;
}

BOOL CNVRam::SetNVRamVar(LPWSTR szVar, CHSTRINGLIST *pList)
{
	CHString    strAll,
                strValue;
	BOOL		bFirst = TRUE;

	for (CHSTRINGLIST_ITERATOR i = pList->begin(); i != pList->end(); ++i)
	{
		CHString &strValue = *i;

		// If we're not on the first item, add ";" to the end of strAll.
		if (!bFirst)
			strAll += ";";
		else
			bFirst = FALSE;

		strAll += strValue;
	}

    bstr_t t_bstr( strAll ) ;
	BOOL bRet = SetNVRamVarRaw( szVar, t_bstr ) ;

    return bRet;
}

BOOL CNVRam::SetNVRamVar(LPWSTR szVar, DWORD dwValue)
{
	WCHAR   szTemp[20];
    BOOL    bRet;

	StringCchPrintfW(szTemp,LENGTH_OF(szTemp), L"%u", dwValue);

	bRet = SetNVRamVar(szVar, szTemp);

    return bRet;
}

BOOL CNVRam::SetNVRamVar(LPWSTR szVar, LPWSTR szValue)
{
	return SetNVRamVarRaw(szVar, szValue);
}

#define CP_MAX_ENV   (MAX_PATH * 2)

BOOL CNVRam::GetNVRamVarRaw(LPWSTR szVar, CHString &strValue)
{
	WCHAR           szOut[CP_MAX_ENV] = L"";
    UNICODE_STRING  usName;
    BOOL            bRet = FALSE;

    CNtDllApi* t_pNtDll = (CNtDllApi*) CResourceManager::sm_TheResourceManager.GetResource(g_guidNtDllApi, NULL);
    if(t_pNtDll != NULL)
    {
        t_pNtDll->RtlInitUnicodeString(&usName, szVar);
        bRet = t_pNtDll->NtQuerySystemEnvironmentValue(&usName, szOut, sizeof(szOut),
                NULL) == ERROR_SUCCESS;
        strValue = szOut;
        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidNtDllApi, t_pNtDll);
        t_pNtDll = NULL;
    }
	return bRet;
}

BOOL CNVRam::SetNVRamVarRaw(LPWSTR szVar, LPWSTR szValue)
{
    UNICODE_STRING  usName,
                    usValue;
    BOOL fRet = FALSE;

    CNtDllApi* t_pNtDll = (CNtDllApi*) CResourceManager::sm_TheResourceManager.GetResource(g_guidNtDllApi, NULL);
    if(t_pNtDll != NULL)
    {
        t_pNtDll->RtlInitUnicodeString(&usName, szVar);
        t_pNtDll->RtlInitUnicodeString(&usValue, szValue);
        if(t_pNtDll->NtSetSystemEnvironmentValue(&usName, &usValue) == ERROR_SUCCESS)
        {
            fRet = TRUE;
        }
        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidNtDllApi, t_pNtDll);
        t_pNtDll = NULL;
    }
    return fRet;
}

//#if defined(EFI_NVRAM_ENABLED)
#if defined(_IA64_)

#define ADD_OFFSET(_p,_o) (PVOID)((PUCHAR)(_p) + (_p)->_o)

typedef struct _MY_BOOT_ENTRY {
    LIST_ENTRY ListEntry;
    PWSTR FriendlyName;
    BOOL Show;
    BOOL Ordered;
    PBOOT_ENTRY NtBootEntry;
} MY_BOOT_ENTRY, *PMY_BOOT_ENTRY;

DWORD BuildBootEntryList(CNtDllApi *t_pNtDll, PLIST_ENTRY BootEntries, PBOOT_ENTRY_LIST *BootEntryList)
{
    NTSTATUS status;
    DWORD count;
    DWORD length;
    PULONG order;
    PBOOT_ENTRY_LIST bootEntryList;
    PBOOT_ENTRY bootEntry;
    PMY_BOOT_ENTRY myBootEntry;
    LONG i;
    PLIST_ENTRY listEntry;

    InitializeListHead(BootEntries);
    *BootEntryList = NULL;

    //
    // Get the system boot order list.
    //
    count = 0;
    status = t_pNtDll->NtQueryBootEntryOrder(NULL, &count);

    if (status != STATUS_BUFFER_TOO_SMALL)
    {
        if (NT_SUCCESS(status))
        {

            //
            // There are no entries in the boot order list. Strange but
            // possible. But we can't do anything without it.
            //
            return 0;
        }
        else
        {
            //
            // An unexpected error occurred.
            //
            ASSERT_BREAK(FALSE);
            return 0;
        }
    }

    ASSERT_BREAK(count != 0);

    order = (PULONG)LocalAlloc(LPTR, count * sizeof(ULONG));
    if (order == NULL)
    {
        return 0;
    }

    status = t_pNtDll->NtQueryBootEntryOrder(order, &count);

    if (!NT_SUCCESS(status))
    {
        //
        // An unexpected error occurred.
        //
        ASSERT_BREAK(FALSE);
        LocalFree(order);
        return 0;
    }

    //
    // Get all existing boot entries.
    //
    length = 0;
    status = NtEnumerateBootEntries(NULL, &length);

    if (status != STATUS_BUFFER_TOO_SMALL)
    {
        if (NT_SUCCESS(status))
        {
            //
            // Somehow there are no boot entries in NVRAM.
            //
            LocalFree(order);
            return 0;
        }
        else
        {
            //
            // An unexpected error occurred.
            //
            ASSERT_BREAK(FALSE);
            LocalFree(order);
            return 0;
        }
    }

    ASSERT_BREAK(length != 0);
    
    bootEntryList = (PBOOT_ENTRY_LIST)LocalAlloc(LPTR, length);
    if (BootEntryList == NULL)
    {
        LocalFree(order);
        return 0;
    }
    *BootEntryList = bootEntryList;

    status = NtEnumerateBootEntries(bootEntryList, &length);

    if (!NT_SUCCESS(status))
    {
        ASSERT_BREAK(FALSE);
        LocalFree(order);
        return 0;
    }

    //
    // Convert the boot entries into our internal representation.
    //
    while (TRUE)
    {
        bootEntry = &bootEntryList->BootEntry;

        //
        // Allocate an internal structure for the boot entry.
        //
        myBootEntry = (PMY_BOOT_ENTRY)LocalAlloc(LPTR, sizeof(MY_BOOT_ENTRY));
        if (myBootEntry == NULL)
        {
            LocalFree(order);
            return 0;
        }

        RtlZeroMemory(myBootEntry, sizeof(MY_BOOT_ENTRY));

        //
        // Save the address of the NT boot entry.
        //
        myBootEntry->NtBootEntry = bootEntry;

        //
        // Save the address of the entry's friendly name.
        //
        myBootEntry->FriendlyName = (PWSTR)ADD_OFFSET(bootEntry, FriendlyNameOffset);

        //
        // Link the new entry into the list.
        //
        InsertTailList(BootEntries, &myBootEntry->ListEntry);

        //
        // Move to the next entry in the enumeration list, if any.
        //
        if (bootEntryList->NextEntryOffset == 0)
        {
            break;
        }
        bootEntryList = (PBOOT_ENTRY_LIST)ADD_OFFSET(bootEntryList, NextEntryOffset);
    }

    //
    // Boot entries are returned in an unspecified order. They are currently
    // in the BootEntries list in the order in which they were returned.
    // Sort the boot entry list based on the boot order. Do this by walking
    // the boot order array backwards, reinserting the entry corresponding to
    // each element of the array at the head of the list.
    //

    for (i = (LONG)count - 1; i >= 0; i--)
    {
        for (listEntry = BootEntries->Flink;
             listEntry != BootEntries;
             listEntry = listEntry->Flink)
        {
            myBootEntry = CONTAINING_RECORD(listEntry, MY_BOOT_ENTRY, ListEntry);

            if (myBootEntry->NtBootEntry->Id == order[i] )
            {
                //
                // We found the boot entry with this ID. Move it to the
                // front of the list.
                //

                myBootEntry->Ordered = TRUE;

                RemoveEntryList(&myBootEntry->ListEntry);
                InsertHeadList(BootEntries, &myBootEntry->ListEntry);

                break;
            }
        }
    }

    //
    // Free the boot order list.
    //
    LocalFree(order);

    //
    // We don't want to show entries that are not in the boot order list.
    // We don't want to show removable media entries (for floppy or CD).
    // We do show non-NT entries.
    //
    count = 0;
    for (listEntry = BootEntries->Flink;
         listEntry != BootEntries;
         listEntry = listEntry->Flink)
    {
        myBootEntry = CONTAINING_RECORD(listEntry, MY_BOOT_ENTRY, ListEntry);

        if (myBootEntry->Ordered &&
            ((myBootEntry->NtBootEntry->Attributes & BOOT_ENTRY_ATTRIBUTE_REMOVABLE_MEDIA) == 0))
        {
            myBootEntry->Show = TRUE;
            count++;
        }
    }

    return count;

} // BuildBootEntryList

VOID
FreeBootEntryList(
    PLIST_ENTRY BootEntries,
    PBOOT_ENTRY_LIST BootEntryList
    )
{
    PLIST_ENTRY listEntry;
    PMY_BOOT_ENTRY myBootEntry;

    while (!IsListEmpty(BootEntries))
    {
        listEntry = RemoveHeadList(BootEntries);
        myBootEntry = CONTAINING_RECORD(listEntry, MY_BOOT_ENTRY, ListEntry);
        LocalFree(myBootEntry);
    }
    if (BootEntryList != NULL)
    {
        LocalFree(BootEntryList);
    }

    return;

} // FreeBootEntryList

/*****************************************************************************
*
*  FUNCTION    : CNVRam::GetBootOptions
*
*  DESCRIPTION : Reads EFI NVRAM and returns the list of operating systems and
*                and the timeout
*
*  INPUTS      : pointer to names sa, pointer to timeout
*
*  OUTPUTS     : count of OS names returned
*
*  RETURNS     : BOOL
*
*  COMMENTS    :
*
*****************************************************************************/

BOOL CNVRam::GetBootOptions(SAFEARRAY **ppsaNames, DWORD *pdwTimeout, DWORD *pdwCount)
{
    NTSTATUS status;
    DWORD length;
    DWORD count;
    PBOOT_OPTIONS bootOptions = NULL;
    PBOOT_ENTRY_LIST bootEntryList = NULL;
    LIST_ENTRY bootEntries;
    PLIST_ENTRY listEntry;
    PMY_BOOT_ENTRY myBootEntry;
    BOOL retval = FALSE;

    CNtDllApi *t_pNtDll = (CNtDllApi *)CResourceManager::sm_TheResourceManager.GetResource(g_guidNtDllApi, NULL);
    if(t_pNtDll == NULL)  return FALSE;

    CRelResource RelMe(&CResourceManager::sm_TheResourceManager,g_guidNtDllApi,t_pNtDll);


    *ppsaNames = NULL;
    
    // Get NVRAM information from the kernel.

    InitializeListHead(&bootEntries);

    length = 0;
    status = t_pNtDll->NtQueryBootOptions(NULL, &length);
    
    if (status != STATUS_BUFFER_TOO_SMALL)
    {
        ASSERT_BREAK(FALSE);
        return FALSE;
    }
    
    bootOptions = (PBOOT_OPTIONS)LocalAlloc(LPTR, length);
    if (bootOptions == NULL) return FALSE;

    OnDelete<HLOCAL,HLOCAL(*)(HLOCAL),LocalFree> FreeMe(bootOptions);

    status = t_pNtDll->NtQueryBootOptions(bootOptions, &length);

    if (!NT_SUCCESS(status))
    {
        ASSERT_BREAK(FALSE);
        return FALSE;
    }


    *pdwTimeout = bootOptions->Timeout;

    //
    // Build the boot entry list. If we don't have any entries to show,
    // bail out.
    //

    count = BuildBootEntryList(t_pNtDll, &bootEntries, &bootEntryList);
    if (count == 0)  return FALSE;

    OnDelete2<PLIST_ENTRY,PBOOT_ENTRY_LIST,VOID (*)(PLIST_ENTRY,PBOOT_ENTRY_LIST),
                     FreeBootEntryList> FreeResList(&bootEntries, bootEntryList);

    //
    // Create an array to put the showable entries in.  We'll start with 0
    // elements and add as necessary.
    //

    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].cElements = count;
    rgsabound[0].lLbound = 0;
    

    *ppsaNames = SafeArrayCreate(VT_BSTR, 1, rgsabound);
    if (!*ppsaNames) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
    OnDeleteIf<SAFEARRAY *,HRESULT(*)(SAFEARRAY *),SafeArrayDestroy> DesMe(*ppsaNames );
    
    
    long lIndex = 0;

    for (listEntry = bootEntries.Flink;
         listEntry != &bootEntries;
         listEntry = listEntry->Flink)
    {
        myBootEntry = CONTAINING_RECORD(listEntry, MY_BOOT_ENTRY, ListEntry);
        if (myBootEntry->Show)
        {
            // Put the new element in

            bstr_t bstrTemp = (LPCWSTR)myBootEntry->FriendlyName;
            HRESULT t_Result = SafeArrayPutElement(*ppsaNames, &lIndex, (void *)(wchar_t*)bstrTemp);
            SysFreeString(bstrTemp);
            if (t_Result == E_OUTOFMEMORY)
            {
                throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
            }
            lIndex++;
        }
    }
    
    DesMe.dismiss();
    *pdwCount = rgsabound[0].cElements;

    return TRUE;

} // GetBootOptions

/*****************************************************************************
*
*  FUNCTION    : CNVRam::SetBootTimeout
*
*  DESCRIPTION : Sets boot timeout
*
*  INPUTS      : timeout
*
*  OUTPUTS     : none
*
*  RETURNS     : BOOL
*
*  COMMENTS    :
*
*****************************************************************************/

BOOL CNVRam::SetBootTimeout(DWORD dwTimeout)
{
    NTSTATUS status;
    DWORD length;
    PBOOT_OPTIONS bootOptions = NULL;
    BOOL retval = FALSE;

    CNtDllApi *t_pNtDll = (CNtDllApi *)CResourceManager::sm_TheResourceManager.GetResource(g_guidNtDllApi, NULL);
    if(t_pNtDll == NULL)  return FALSE;

    CRelResource RelMe(&CResourceManager::sm_TheResourceManager,g_guidNtDllApi,t_pNtDll);    

    // Get NVRAM information from the kernel.

    length = 0;
    status = t_pNtDll->NtQueryBootOptions(NULL, &length);
    
    if (status != STATUS_BUFFER_TOO_SMALL)
    {
        ASSERT_BREAK(FALSE);
        goto error;
    }
    else
    {
        bootOptions = (PBOOT_OPTIONS)LocalAlloc(LPTR, length);
        if (bootOptions == NULL)
        {
            goto error;
        }

        status = t_pNtDll->NtQueryBootOptions(bootOptions, &length);

        if (!NT_SUCCESS(status))
        {
            ASSERT_BREAK(FALSE);
            goto error;
        }
    }

    bootOptions->Timeout = dwTimeout;

    //
    // Write the new timeout.
    //

    status = t_pNtDll->NtSetBootOptions(bootOptions, BOOT_OPTIONS_FIELD_TIMEOUT);
    if (NT_SUCCESS(status))
    {
        retval = TRUE;
    }

error:

    //
    // Clean up all allocations.
    //
    if (bootOptions != NULL)
    {
        LocalFree(bootOptions);
    }

    return retval;

} // SetBootTimeout

/*****************************************************************************
*
*  FUNCTION    : CNVRam::SetDefaultBootEntry
*
*  DESCRIPTION : Sets default boot entry
*
*  INPUTS      : default boot entry index
*
*  OUTPUTS     : none
*
*  RETURNS     : BOOL
*
*  COMMENTS    :
*
*****************************************************************************/

BOOL CNVRam::SetDefaultBootEntry(BYTE cIndex)
{
    NTSTATUS status;
    DWORD count;
    PBOOT_ENTRY_LIST bootEntryList = NULL;
    LIST_ENTRY bootEntries;
    PULONG order = NULL;
    BOOL retval = FALSE;

    if (cIndex == 0)
    {
        return TRUE;
    }

    CNtDllApi *t_pNtDll = (CNtDllApi *)CResourceManager::sm_TheResourceManager.GetResource(g_guidNtDllApi, NULL);
    if(t_pNtDll == NULL) return FALSE;

    CRelResource RelMe(&CResourceManager::sm_TheResourceManager,g_guidNtDllApi,t_pNtDll);    

    // Get NVRAM information from the kernel.

    InitializeListHead(&bootEntries);

    //
    // Build the boot entry list. If we don't have any entries to rearrange,
    // bail out.
    //

    count = BuildBootEntryList(t_pNtDll, &bootEntries, &bootEntryList);
    if (count == 0)
    {
        goto error;
    }

    //
    // Walk the boot entry list, looking for (a) the first showable entry
    // (which is the current index 0 entry, from the caller's point of view),
    // and (b) the selected entry. We want to swap these two entries.
    //

    PLIST_ENTRY listEntry;
    PMY_BOOT_ENTRY myBootEntry;
    PMY_BOOT_ENTRY firstEntry = NULL;
    PMY_BOOT_ENTRY selectedEntry = NULL;
    PLIST_ENTRY previousEntry;

    count = 0;

    for (listEntry = bootEntries.Flink;
         listEntry != &bootEntries;
         listEntry = listEntry->Flink)
    {
        myBootEntry = CONTAINING_RECORD(listEntry, MY_BOOT_ENTRY, ListEntry);

        if (myBootEntry->Show)
        {
            if (count == 0)
            {
                firstEntry = myBootEntry;
            }
            else if (count == cIndex)
            {
                selectedEntry = myBootEntry;
            }
            count++;
        }
    }

    if ( (firstEntry == NULL) ||
         (selectedEntry == NULL) ||
         (selectedEntry == firstEntry) )
    {
        goto error;
    }

    //
    // Swap the entries. Capture the address of the entry before the first
    // entry (which might be the list head). Remove the first entry from
    // the list and insert it after the selected entry. Remove the selected
    // entry from the list and insert it after the captured entry.
    //

    previousEntry = firstEntry->ListEntry.Blink;
    RemoveEntryList(&firstEntry->ListEntry);
    InsertHeadList(&selectedEntry->ListEntry, &firstEntry->ListEntry);
    RemoveEntryList(&selectedEntry->ListEntry);
    InsertHeadList(previousEntry, &selectedEntry->ListEntry);

    //
    // Build the new boot order list. Insert all ordered boot entries
    // into the list.
    //
    count = 0;
    for (listEntry = bootEntries.Flink;
         listEntry != &bootEntries;
         listEntry = listEntry->Flink)
    {
        myBootEntry = CONTAINING_RECORD(listEntry, MY_BOOT_ENTRY, ListEntry);
        if (myBootEntry->Ordered)
        {
            count++;
        }
    }
    order = (PULONG)LocalAlloc(LPTR, count * sizeof(ULONG));
    if (order == NULL) {
        goto error;
    }

    count = 0;
    for (listEntry = bootEntries.Flink;
         listEntry != &bootEntries;
         listEntry = listEntry->Flink)
    {
        myBootEntry = CONTAINING_RECORD(listEntry, MY_BOOT_ENTRY, ListEntry);
        if (myBootEntry->Ordered)
        {
            order[count++] = myBootEntry->NtBootEntry->Id;
        }
    }

    //
    // Write the new boot entry order list to NVRAM.
    //
    status = t_pNtDll->NtSetBootEntryOrder(order, count);
    if (NT_SUCCESS(status))
    {
        retval = TRUE;
    }

error:

    //
    // An error occurred. Clean up all allocations.
    //
    if (bootEntryList != NULL)
    {
        FreeBootEntryList(&bootEntries, bootEntryList);
    }
    if (order != NULL)
    {
        LocalFree(order);
    }

    return retval;

} // SetDefaultBootEntry

#endif // defined(EFI_NVRAM_ENABLED)

#else

// Needed to fix warning message.  I believe this is fixed in vc6.
#if ( _MSC_VER <= 1100 )
void nvram_cpp(void) { ; };
#endif

#endif // !defined(_X86_) || defined(EFI_NVRAM_ENABLED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\nvram.h ===
//============================================================

//

// NVRAM.h - SETPUDLL.DLL access class definition

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// 08/05/98     sotteson     created
//
//============================================================

#ifndef __NVRAM__
#define __NVARM__

#include <list>
#include <ntexapi.h>

typedef std::list<CHString> CHSTRINGLIST;
typedef std::list<CHString>::iterator CHSTRINGLIST_ITERATOR;

class CNVRam
{
public:
	CNVRam();
	~CNVRam();
//     privilege in question is SE_SYSTEM_ENVIRONMENT_NAME
    enum InitReturns {Success, LoadLibFailed, PrivilegeNotHeld, ProcNotFound};

	CNVRam::InitReturns Init();

	BOOL GetNVRamVar(LPWSTR szVar, CHSTRINGLIST *pList);
	BOOL GetNVRamVar(LPWSTR szVar, DWORD *pdwValue);
	BOOL GetNVRamVar(LPWSTR szVar, CHString &strValue);

	BOOL SetNVRamVar(LPWSTR szVar, CHSTRINGLIST *pList);
	BOOL SetNVRamVar(LPWSTR szVar, DWORD dwValue);
	BOOL SetNVRamVar(LPWSTR szVar, LPWSTR szValue);

//#if defined(EFI_NVRAM_ENABLED)

#if defined(_IA64_)
    BOOL IsEfi() { return TRUE; }
#else
    BOOL IsEfi() { return FALSE; }
#endif

    BOOL GetBootOptions(SAFEARRAY **ppsaNames, DWORD *pdwTimeout, DWORD *pdwCount);
    BOOL SetBootTimeout(DWORD dwTimeout);
    BOOL SetDefaultBootEntry(BYTE cIndex);

//endif // defined(EFI_NVRAM_ENABLED)

protected:

	BOOL GetNVRamVarRaw(LPWSTR szVar, CHString &strValue);
	BOOL SetNVRamVarRaw(LPWSTR szVar, LPWSTR szValue);
    
};

#endif // File inclusion
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\pagefilesetting.h ===
//=================================================================

//

// PageFileSetting.h -- PageFileSetting property set provider

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    03/01/99    a-peterc	    Created
//
//=================================================================




// Property set identification
//============================

#define  PROPSET_NAME_PageFileSetting L"Win32_PageFileSetting"

#define PAGEFILE_REGISTRY_KEY _T("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management")
#define PAGING_FILES          _T("PagingFiles")



// corresponds to info found in NT registry
class PageFileSettingInstance
{
public:

	CHString name;
	UINT     min;
	UINT     max;

public:

	PageFileSettingInstance() ;
};

// twenty six possible drive letters, twenty six possible page files...
#define PageFileInstanceArray PageFileSettingInstance *

class PageFileSetting : public Provider
{
	private:

		HRESULT GetPageFileData( CInstance *a_pInst, bool a_fValidate ) ;
		HRESULT GetAllPageFileData( MethodContext *a_pMethodContext ) ;

		// NT only
		DWORD	GetPageFileInstances( PageFileInstanceArray a_instArray ) ;
		HRESULT PutPageFileInstances( PageFileInstanceArray a_instArray, DWORD a_dwCount ) ;

		void	NameToSettingID( CHString &a_chsName, CHString &a_chsSettingID ) ;
		void	NameToCaption( CHString &a_chsName, CHString &a_chsCaption ) ;
		void	NameToDescription( CHString &a_chsName, CHString &a_chsDescription ) ;
    
	protected:

    public:
        // Constructor/destructor
        //=======================
        PageFileSetting( LPCWSTR name, LPCWSTR pszNamespace ) ;
       ~PageFileSetting() ;

		// Functions provide properties with current values
        //=================================================
		virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_pInst = 0L ) ;
		virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags = 0L ) ;
        
		// NT ONLY
		virtual HRESULT PutInstance( const CInstance &a_pInst, long a_lFlags = 0L ) ;
        virtual HRESULT DeleteInstance( const CInstance &a_pInst, long a_lFlags = 0L ) ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\pagefile.cpp ===
//=================================================================

//

// PageFile.CPP --PageFile property set provider

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    03/01/99    a-peterc	    Created
//
//=================================================================

#include "precomp.h"
#include <io.h>
#include <WinPerf.h>
#include <cregcls.h>


#include "File.h"
#include "Implement_LogicalFile.h"
#include "CIMDataFile.h"

#include "PageFile.h"
#include <tchar.h>
#include <ProvExce.h>

#include "computersystem.h"
#include "sid.h"
#include "ImpLogonUser.h"
#include "dllutils.h"


// declaration of our static instance
//=========================

PageFile MyPageFileSet(PROPSET_NAME_PageFile, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : PageFile::PageFile
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

PageFile::PageFile(LPCWSTR name, LPCWSTR pszNamespace)
: CCIMDataFile(name, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : PageFile::~PageFile
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

PageFile::~PageFile()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : PageFile::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : CInstance *a_pInst, long a_lFlags
 *
 *  OUTPUTS     : CInstance *a_pInst
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT PageFile::GetObject(CInstance *a_pInst, long a_lFlags, CFrameworkQuery& pQuery)
{
	HRESULT hr = WBEM_E_NOT_FOUND;

    // DEVNOTE: REMOVE FOR QUASAR!!!  Necessary for double hop access.
#ifdef NTONLY
    bool fImp = false;
    CImpersonateLoggedOnUser icu;
    if(icu.Begin())
    {
        fImp = true;
    }
#endif

    // calls the OS specific compiled version
	hr = GetPageFileData( a_pInst, true ) ;


#ifdef NTONLY
    if(fImp)
    {
        icu.End();
        fImp = false;
    }
#endif


    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : PageFile::ExecQuery
 *
 *  DESCRIPTION :
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :  Because the local enumerate is faster than the parent's
 *                 enumerate, and in many types of queries the local enumerate
 *                 is faster than the parents execquery (such as those queries
 *                 that ask for a specific caption, which the parent would process
 *                 as an NtokenAnd query, enumerating all drives in the process),
 *                 we intercept the call and do an enumeration instead, allowing
 *                 CIMOM to post filter the results.
 *
 *****************************************************************************/
HRESULT PageFile::ExecQuery(MethodContext* pMethodContext,
                                  CFrameworkQuery& pQuery,
                                  long lFlags)
{
	HRESULT hr = WBEM_S_NO_ERROR;

    // DEVNOTE: REMOVE FOR QUASAR!!!  Necessary for double hop access.
#ifdef NTONLY
    bool fImp = false;
    CImpersonateLoggedOnUser icu;
    if(icu.Begin())
    {
        fImp = true;
    }
#endif


    hr = EnumerateInstances(pMethodContext, lFlags);


#ifdef NTONLY
    if(fImp)
    {
        icu.End();
        fImp = false;
    }
#endif


    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : PageFile::EnumerateInstances
 *
 *  DESCRIPTION : Creates property set instances
 *
 *  INPUTS      : MethodContext*  a_pMethodContext, long a_lFlags
 *
 *  OUTPUTS     : MethodContext*  a_pMethodContext
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT PageFile::EnumerateInstances(MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/)
{
	HRESULT hr = WBEM_S_NO_ERROR;

    // DEVNOTE: REMOVE FOR QUASAR!!!  Necessary for double hop access.
#ifdef NTONLY
    bool fImp = false;
    CImpersonateLoggedOnUser icu;
    if(icu.Begin())
    {
        fImp = true;
    }
#endif


    // calls the OS specific compiled version
	hr = GetAllPageFileData( a_pMethodContext );

#ifdef NTONLY
    if(fImp)
    {
        icu.End();
        fImp = false;
    }
#endif


    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : PageFile::GetPageFileData
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : CInstance *a_pInst
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :	Win9x and NT compiled version
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT PageFile::GetPageFileData( CInstance *a_pInst, bool a_fValidate )
{
	HRESULT t_hRes = WBEM_E_NOT_FOUND;

    // NT page file name is in registry
    //=================================
	PageFileInstance t_files [ 26 ] ;

   	DWORD t_nInstances = GetPageFileInstances( t_files );
	CHString t_chsTemp ;
	CHString t_name;

	a_pInst->GetCHString( IDS_Name, t_name );

	for ( DWORD t_dw = 0; t_dw < t_nInstances; t_dw++ )
	{
		if ( t_name.CompareNoCase ( t_files[t_dw].name ) == 0 )
		{
      		// pagefile boundaries
			a_pInst->SetDWORD (	IDS_MaximumSize, t_files[t_dw].max ) ;
			a_pInst->SetDWORD (	IDS_InitialSize, t_files[t_dw].min ) ;

			t_hRes = WBEM_S_NO_ERROR;
		}
	}

	return t_hRes;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : PageFile::GetAllPageFileData
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : MethodContext *a_pMethodContext
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :	Win9x and NT compiled version
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT PageFile::GetAllPageFileData( MethodContext *a_pMethodContext )
{
	HRESULT		t_hResult	 = WBEM_S_NO_ERROR;
	DWORD		t_nInstances = 0;
	CInstancePtr t_pInst;
	PageFileInstance t_files [ 26 ] ;
	CHString t_chsTemp ;

	// NT page file name is in registry
	//=================================
	t_nInstances = GetPageFileInstances( t_files );

	for (DWORD t_dw = 0; t_dw < t_nInstances && SUCCEEDED( t_hResult ); t_dw++ )
	{
		t_pInst.Attach(CreateNewInstance( a_pMethodContext ) );

		t_pInst->SetCHString( IDS_Name,		t_files[t_dw].name ) ;
		t_pInst->SetDWORD( IDS_MaximumSize, t_files[t_dw].max ) ;
		t_pInst->SetDWORD( IDS_InitialSize, t_files[t_dw].min ) ;

		t_hResult = t_pInst->Commit(  ) ;
	}

	return t_hResult;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : PageFile::GetPageFileInstances
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : PageFileInstanceArray &a_instArray
 *
 *  OUTPUTS     : PageFileInstanceArray &a_instArray
 *
 *  RETURNS     :
 *
 *  COMMENTS    :	returns actual number found - NT ONLY
 *
 *****************************************************************************/

#ifdef NTONLY
DWORD PageFile::GetPageFileInstances( PageFileInstanceArray a_instArray )
{
    CHString	t_sRegValue;
    DWORD		t_nInstances = 0;
    CRegistry	t_Reg ;

    if( t_Reg.OpenLocalMachineKeyAndReadValue(PAGEFILE_REGISTRY_KEY,
												PAGING_FILES,
												t_sRegValue ) == ERROR_SUCCESS)
    {
        // pattern is name <space> min size [optional<max size>] 0A repeat...
        // I'll use an ASCII smiley face to replace the delimiter...
        int t_iStart = 0, t_iIndex;
        const TCHAR t_smiley = '\x02';
        const TCHAR t_delimiter = '\x0A';
        CHString t_buf;

        while (-1 != ( t_iIndex = t_sRegValue.Find( t_delimiter ) ) )
        {
            // copy to buffer to make life easier
            t_buf = t_sRegValue.Mid( t_iStart, t_iIndex - t_iStart );

			// mash delimiter so we don't find it again.
            t_sRegValue.SetAt( t_iIndex, t_smiley );

			// save start for next time around.
            t_iStart = t_iIndex + 1;

            t_iIndex = t_buf.Find(' ');

            a_instArray[ t_nInstances ].name = t_buf.Left( t_iIndex );

            if ( t_iIndex != -1 )
			{
                t_buf.SetAt( t_iIndex, t_smiley );
			}

            int t_iEnd = t_buf.Find(' ');

            // if no more spaces, there isn't a max size written down
            if ( -1 == t_iEnd )
            {
				CHString t_littleBuf = t_buf.Mid( t_iIndex + 1 );

				a_instArray[ t_nInstances ].min = _ttoi( t_littleBuf );
                a_instArray[ t_nInstances ].max = a_instArray[ t_nInstances ].min + 50;
            }
            else
            {
                CHString t_littleBuf = t_buf.Mid( t_iIndex +1, t_iEnd - t_iIndex );
                a_instArray[ t_nInstances ].min = _ttoi( t_littleBuf );

                t_littleBuf = t_buf.Mid( t_iEnd );
                a_instArray[ t_nInstances ].max = _ttoi( t_littleBuf );
            }

            // Make sure the thing really exists.  It should also be in use.
            DWORD t_dwRet = GetFileAttributes( a_instArray[ t_nInstances ].name );
            //if (-1 == t_dwRet ) // 51169 - a valid pagefile, in use, was returning 26, not -1.  GetLastError() still reported 0x5, so no need
            // for us to restrict to the -1 case... in fact, caused us to miss an otherwise valid instance.
            {
                DWORD t_wErr = GetLastError();

                // Some os's say sharing violation, some just say access denied.
                if ( ( t_wErr == ERROR_SHARING_VIOLATION ) ||
					( t_wErr == ERROR_ACCESS_DENIED ) )
				{
                    t_nInstances++;
				}
            }
        }
    }

    return t_nInstances;
}
#endif


/*****************************************************************************
 *
 *  FUNCTION    : PageFile::PutInstance
 *
 *  DESCRIPTION : Write changed or new instance
 *
 *  INPUTS      : a_pInst to store data from
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :	Separate OS compile versions
					For win95, this won't work at all.  Apparently w95 can only
 *					have one page file.  The min, max, and name are all stored
 *					in system.ini.
 *
 *****************************************************************************/
#ifdef NTONLY
HRESULT PageFile::PutInstance( const CInstance &a_pInst, long a_lFlags /*= 0L*/ )
{
	HRESULT t_hRet = WBEM_S_NO_ERROR;

	DWORD	t_dwCount,
			t_x,
			t_dwTemp;

	PageFileInstance t_instArray [ 26 ] ;
	CHString t_sName;

	bool t_bFoundIt = false;


	// Get the values we are supposed to write in
	a_pInst.GetCHString( IDS_Name, t_sName );

    //name must be letter colon slash name...
    if (t_sName.GetLength() == 0)
    {
        return WBEM_E_NOT_FOUND;
    }

    t_sName.MakeLower();

    // Check if the name is indeeed "pagefile.sys"
    if ( -1 == t_sName.Find( _T("pagefile.sys") ) )
    {
	    return WBEM_E_NOT_FOUND;
    }

    // Read the page file array
    t_dwCount = GetPageFileInstances( t_instArray );

	// Find if it is already there, and update the structure
	for ( t_x = 0; t_x < t_dwCount; t_x++ )
	{
      // Is this the guy?
      if ( 0 == _tcsicmp( t_instArray[t_x].name, t_sName ) )
	  {
         if ( a_lFlags & WBEM_FLAG_CREATE_ONLY )
		 {
            t_hRet = WBEM_E_ALREADY_EXISTS;
         }
		 else
		 {
            // Did they give us a value?
            if ( !a_pInst.IsNull( IDS_InitialSize ) )
			{
				// Check for value in range
				t_dwTemp = 0;
				a_pInst.GetDWORD( IDS_InitialSize, t_dwTemp );

				// minimum of 2 meg
				if( 2 > t_dwTemp )
				{
					t_hRet = WBEM_E_VALUE_OUT_OF_RANGE;
                    t_bFoundIt = true;
					break;
				}
				t_instArray[t_x].min = t_dwTemp;
            }

            // Did they give us a value?
            if ( !a_pInst.IsNull( IDS_MaximumSize ) )
			{
				// Check for value in range
				a_pInst.GetDWORD( IDS_MaximumSize, t_dwTemp );

		        t_instArray[t_x].max = t_dwTemp;
            }

            // Check the basic
            if ( t_instArray[t_x].min > t_instArray[t_x].max )
			{
               t_hRet = WBEM_E_VALUE_OUT_OF_RANGE;
            }

			t_bFoundIt = true;
            break;
         }
      }
   }

   // We didn't find it.  Let's make a new one
   if ( !t_bFoundIt )
   {
      if (a_lFlags & WBEM_FLAG_UPDATE_ONLY)
	  {
         t_hRet = WBEM_E_NOT_FOUND;
      }
	  else
	  {
         t_instArray[ t_dwCount ].name = t_sName;

         // Did they give us a value?
         if ( !a_pInst.IsNull( IDS_InitialSize ) )
		 {
            // Check for value in range
            a_pInst.GetDWORD( IDS_InitialSize, t_dwTemp );

            // minimum of 2 meg
			if( 2 > t_dwTemp )
			{
				return WBEM_E_VALUE_OUT_OF_RANGE;
			}

			t_instArray[t_dwCount].min = t_dwTemp;
         }

         // Did they give us a value?
         if ( !a_pInst.IsNull( IDS_MaximumSize ) )
		 {
            // Check for value in range
            a_pInst.GetDWORD( IDS_MaximumSize, t_dwTemp );

			t_instArray[ t_dwCount ].max = t_dwTemp;
         }

         // Check for basic errors
         if ( t_instArray[ t_dwCount ].min > t_instArray[ t_dwCount ].max )
		 {
            return WBEM_E_VALUE_OUT_OF_RANGE;
         }

         // One more in the array
         t_dwCount++;

         // Iff we are able to create the pagefile,
         // continue to update the registry;
         // otherwise, fail. I will either succeed
         // to create all page files specified,
         // or, if even one fails to create, fail
         // and not update the registry for any.
         LARGE_INTEGER liMin;
         LARGE_INTEGER liMax;

         liMin.QuadPart = t_instArray[t_dwCount-1].min;
         liMax.QuadPart = t_instArray[t_dwCount-1].max;

         t_hRet = CreatePageFile(
            t_sName,
            liMin,
            liMax,
            a_pInst);
      }
   }

   // Update the registry
   if ( WBEM_S_NO_ERROR == t_hRet )
   {
      t_hRet = PutPageFileInstances( t_instArray, t_dwCount );
   }

   return t_hRet;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : PageFile::PutPageFileInstances
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : PageFileInstanceArray &a_instArray, DWORD a_dwCount
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :	returns actual number found - NT ONLY
 *
 *****************************************************************************/
#ifdef NTONLY
HRESULT PageFile::PutPageFileInstances(PageFileInstanceArray a_instArray, DWORD a_dwCount )
{
	CRegistry t_Reg ;
	CHString t_sFiles;
	TCHAR t_szBuff[MAXITOA];
	HRESULT t_hResult = WBEM_E_FAILED;

	HRESULT t_Res = t_Reg.Open( HKEY_LOCAL_MACHINE, PAGEFILE_REGISTRY_KEY, KEY_READ | KEY_WRITE );

	if( ERROR_SUCCESS == t_Res )
	{
	  // Build up the string.  Each entry is \0 terminated.
	  t_sFiles.Empty();

	  for ( int t_x = 0; t_x < a_dwCount; t_x++ )
	  {
		 t_sFiles += a_instArray[ t_x ].name;
		 t_sFiles += _T(' ');
		 t_sFiles += _itot( a_instArray[ t_x ].min, t_szBuff, 10 );
		 t_sFiles += _T(' ');
		 t_sFiles += _itot( a_instArray[ t_x ].max, t_szBuff, 10 );
		 t_sFiles += _T('\0');
	  }

	  // The end is indicated with \0\0.
	  t_sFiles += _T('\0');

		// Write the value
		if ((t_Res = RegSetValueEx( t_Reg.GethKey(),
								  PAGING_FILES,
								  0,
								  REG_MULTI_SZ,
								  (const unsigned char *)(LPCTSTR) t_sFiles,
								  t_sFiles.GetLength() * sizeof(TCHAR) )) == ERROR_SUCCESS )
		{
			t_hResult = WBEM_S_NO_ERROR;
		}
	}

	if (FAILED(t_Res) && (t_Res == ERROR_ACCESS_DENIED))
	{
		t_hResult = WBEM_E_ACCESS_DENIED;
	}

	return t_hResult;
}
#endif

////////////////////////////////////////////////////////////////////////
//
//	Function:	DeleteInstance
//
//	CIMOM wants us to delete this instance.
//
//	Inputs:
//
//	Outputs:
//
//	Return:
//
//	Comments: Separate OS compile versions
//
////////////////////////////////////////////////////////////////////////
#ifdef NTONLY
HRESULT PageFile::DeleteInstance(const CInstance &a_pInst, long a_lFlags /*= 0L*/)
{
   DWORD t_dwCount,
		 t_x;
   CHString t_sName;
   bool t_bFoundIt;
   HRESULT t_hRet;
   PageFileInstance t_instArray [ 26 ] ;

   // Fill the pagefile array
   t_dwCount = GetPageFileInstances( t_instArray );

   // Get the name
   a_pInst.GetCHString( IDS_Name, t_sName );

   t_bFoundIt = false;

   // Walk the array looking for it
   for ( t_x = 0; t_x < t_dwCount; t_x++ )
   {
      // This one?
      if ( _tcsicmp( t_instArray[ t_x ].name, t_sName ) == 0 )
	  {
         // Yup
         t_bFoundIt = true;

         // Move the rest down over this one
         for (int t_y = t_x; t_y < t_dwCount - 1; t_y++ )
		 {
			t_instArray[ t_y ].name	= t_instArray[ t_y + 1].name;
			t_instArray[ t_y ].min	= t_instArray[ t_y + 1].min;
			t_instArray[ t_y ].max	= t_instArray[ t_y + 1].max;
		}

         // The array is now one shorter
         t_dwCount--;
         break;
      }
   }

   if ( t_bFoundIt )
   {
      // If we found it, update the registry
      t_hRet = PutPageFileInstances( t_instArray, t_dwCount );
   }
   else
   {
      t_hRet = WBEM_E_NOT_FOUND;
   }

   return t_hRet;
}
#endif

////////////////////////////////////////////////////////////////////////
//
//	Function:	IsOneOfMe
//
//	Inputs:		LPWIN32_FIND_DATAA	a_pstFindData,
//				LPCSTR				a_szFullPathName
//
//	Outputs:
//
//	Return:		Boolean
//
//	Comments: Win9x and NT compiled version
//
////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
BOOL PageFile::IsOneOfMe( LPWIN32_FIND_DATA a_pstFindData,
		                  LPCTSTR		   a_tstrFullPathName )
{
    BOOL t_bRet = FALSE;
    PageFileInstance t_files [ 26 ] ;
	DWORD t_nInstances = GetPageFileInstances( t_files );

	for (DWORD t_dw = 0; t_dw < t_nInstances; t_dw++ )
	{
        _bstr_t t_bstrtName( (LPCTSTR)t_files[ t_dw ].name );

		if( 0 == _wcsicmp( t_bstrtName, a_tstrFullPathName ) )
        {
            t_bRet = TRUE;
            break;
        }
	}
    return t_bRet;
}
#endif

PageFileInstance::PageFileInstance()
{
	min = max = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\pagefile.h ===
//=================================================================

//

// PageFile.h -- PageFile property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//			     03/01/99    a-peterc	    Cleanup
//
//=================================================================


// Property set identification
//============================

#define  PROPSET_NAME_PageFile L"Win32_PageFile"

#define PAGEFILE_REGISTRY_KEY _T("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management")
#define PAGING_FILES          _T("PagingFiles")



// corresponds to info found in NT registry
class PageFileInstance
{
public:

	CHString name;
	UINT     min;
	UINT     max;

public:

	PageFileInstance(); 
	
};

// twenty six possible drive letters, twenty six possible page files...
#define PageFileInstanceArray PageFileInstance *

class PageFile : public CCIMDataFile
{
	private:

		HRESULT GetPageFileData( CInstance *a_pInst, bool a_fValidate ) ;
		HRESULT GetAllPageFileData( MethodContext *a_pMethodContext ) ;

		// NT only
		DWORD	GetPageFileInstances( PageFileInstanceArray a_instArray ) ;
		HRESULT PutPageFileInstances( PageFileInstanceArray a_instArray, DWORD a_dwCount ) ;
        

	protected:
		// Overridable function inherited from CCIMLogicalFile needs to 
	    // implement this here since this class is derived from CCimDataFile
		// (both C++ and MOF derivation). CCimDataFile calls IsOneOfMe.
	    // The most derived instance will be called.  If not implemented here, 
		// CCimDataFile will be used, which will commit for datafiles.
		// However, If CCimDataFile does not return FALSE from its IsOneOfMe,
		// which it won't do if not implemented here, all data files  
		// will be assigned to this class.
		virtual BOOL IsOneOfMe(LPWIN32_FIND_DATA a_pstFindData,
							   LPCTSTR			 a_tstrFullPathName);

    public:
        // Constructor/destructor
        //=======================
        PageFile( LPCWSTR name, LPCWSTR pszNamespace ) ;
       ~PageFile() ;

		// Functions provide properties with current values
        //=================================================
		virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_pInst = 0L ) ;
		virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags, CFrameworkQuery& pQuery ) ;
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, 
                                  CFrameworkQuery& pQuery, 
                                  long lFlags = 0L);

        
		// NT ONLY
		virtual HRESULT PutInstance( const CInstance &a_pInst, long a_lFlags = 0L ) ;
        virtual HRESULT DeleteInstance( const CInstance &a_pInst, long a_lFlags = 0L ) ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\pagefilesetting.cpp ===
//=================================================================

//

// PageFileSetting.CPP --PageFileSetting property set provider

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    03/01/99    a-peterc	    Created
//
//=================================================================

#include "precomp.h"
#include <io.h>
#include <WinPerf.h>
#include <cregcls.h>


#include "PageFileSetting.h"
#include <tchar.h>
#include <ProvExce.h>

#include "computersystem.h"
#include "dllutils.h"


// constants
// =========
TCHAR szSessionManager[] = TEXT("System\\CurrentControlSet\\Control\\Session Manager");
TCHAR szPendingRename[] = TEXT("PendingFileRenameOperations");

// declaration of our static instance
//=========================

PageFileSetting MyPageFileSettingSet(PROPSET_NAME_PageFileSetting, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : PageFileSetting::PageFileSetting
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

PageFileSetting::PageFileSetting(LPCWSTR name, LPCWSTR pszNamespace)
: Provider(name, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : PageFileSetting::~PageFileSetting
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

PageFileSetting::~PageFileSetting()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : PageFileSetting::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : CInstance *a_pInst, long a_lFlags
 *
 *  OUTPUTS     : CInstance *a_pInst
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT PageFileSetting::GetObject(CInstance *a_pInst, long a_lFlags /*= 0L*/)
{
	// calls the OS specific compiled version
	return GetPageFileData( a_pInst, true ) ;
}

/*****************************************************************************
 *
 *  FUNCTION    : PageFileSetting::EnumerateInstances
 *
 *  DESCRIPTION : Creates property set instances
 *
 *  INPUTS      : MethodContext*  a_pMethodContext, long a_lFlags
 *
 *  OUTPUTS     : MethodContext*  a_pMethodContext
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT PageFileSetting::EnumerateInstances(MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/)
{
	// calls the OS specific compiled version
	return GetAllPageFileData( a_pMethodContext );
}

/*****************************************************************************
 *
 *  FUNCTION    : PageFileSetting::GetPageFileData
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : CInstance *a_pInst
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :	Win9x and NT compiled version
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT PageFileSetting::GetPageFileData( CInstance *a_pInst, bool a_fValidate )
{
	HRESULT t_hRes = WBEM_E_NOT_FOUND;

    // NT page file name is in registry
    //=================================
	PageFileSettingInstance t_files [ 26 ] ;

   	DWORD t_nInstances = GetPageFileInstances( t_files );
	CHString t_chsTemp ;
	CHString t_name;

	a_pInst->GetCHString( IDS_Name, t_name );

	for ( DWORD t_dw = 0; t_dw < t_nInstances; t_dw++ )
	{
		if ( t_name.CompareNoCase ( t_files[t_dw].name ) == 0 )
		{
            // CIM_Setting::SettingID
			NameToSettingID( t_files[t_dw].name,	t_chsTemp ) ;
			a_pInst->SetCHString( _T("SettingID"),  t_chsTemp ) ;

			// CIM_Setting::Caption
			NameToCaption( t_files[t_dw].name,		t_chsTemp ) ;
			a_pInst->SetCHString( IDS_Caption,		t_chsTemp ) ;

			// CIM_Setting::Description
			NameToDescription( t_files[t_dw].name,	t_chsTemp ) ;
			a_pInst->SetCHString( IDS_Description,	t_chsTemp ) ;

			// pagefile boundaries
			a_pInst->SetDWORD (	IDS_MaximumSize, t_files[t_dw].max ) ;
			a_pInst->SetDWORD (	IDS_InitialSize, t_files[t_dw].min ) ;

			t_hRes = WBEM_S_NO_ERROR;
		}
	}

	return t_hRes;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : PageFileSetting::GetAllPageFileData
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : MethodContext *a_pMethodContext
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :	Win9x and NT compiled version
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT PageFileSetting::GetAllPageFileData( MethodContext *a_pMethodContext )
{
	HRESULT		t_hResult	 = WBEM_S_NO_ERROR;
	DWORD		t_nInstances = 0;
	CInstancePtr t_pInst;
	PageFileSettingInstance t_files [ 26 ] ;
	CHString t_chsTemp ;

	// NT page file name is in registry
	//=================================
	t_nInstances = GetPageFileInstances( t_files );

	for (DWORD t_dw = 0; t_dw < t_nInstances && SUCCEEDED( t_hResult ); t_dw++ )
	{
		t_pInst.Attach(CreateNewInstance( a_pMethodContext ) );

		// CIM_Setting::SettingID
		NameToSettingID( t_files[t_dw].name,	t_chsTemp ) ;
		t_pInst->SetCHString( _T("SettingID"),  t_chsTemp ) ;

		// CIM_Setting::Caption
		NameToCaption( t_files[t_dw].name,		t_chsTemp ) ;
		t_pInst->SetCHString( IDS_Caption,		t_chsTemp ) ;

		// CIM_Setting::Description
		NameToDescription( t_files[t_dw].name,	t_chsTemp ) ;
		t_pInst->SetCHString( IDS_Description,	t_chsTemp ) ;

		t_pInst->SetCHString( IDS_Name,		t_files[t_dw].name ) ;
		t_pInst->SetDWORD( IDS_MaximumSize, t_files[t_dw].max ) ;
		t_pInst->SetDWORD( IDS_InitialSize, t_files[t_dw].min ) ;

		t_hResult = t_pInst->Commit(  ) ;
	}

	return t_hResult;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : PageFileSetting::GetPageFileInstances
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : PageFileInstanceArray a_instArray
 *
 *  OUTPUTS     : PageFileInstanceArray a_instArray
 *
 *  RETURNS     :
 *
 *  COMMENTS    :	returns actual number found - NT ONLY
 *
 *****************************************************************************/

#ifdef NTONLY
DWORD PageFileSetting::GetPageFileInstances( PageFileInstanceArray a_instArray )
{
    CHString	t_sRegValue;
    DWORD		t_nInstances = 0;
    CRegistry	t_Reg ;

    if( t_Reg.OpenLocalMachineKeyAndReadValue(PAGEFILE_REGISTRY_KEY,
												PAGING_FILES,
												t_sRegValue ) == ERROR_SUCCESS)
    {
        // pattern is name <space> min size [optional<max size>] 0A repeat...
        // I'll use an ASCII smiley face to replace the delimiter...
        int t_iStart = 0, t_iIndex;
        const TCHAR t_smiley = '\x02';
        const TCHAR t_delimiter = '\x0A';
        CHString t_buf;

        while (-1 != ( t_iIndex = t_sRegValue.Find( t_delimiter ) ) )
        {
            // copy to buffer to make life easier
            t_buf = t_sRegValue.Mid( t_iStart, t_iIndex - t_iStart );

			// mash delimiter so we don't find it again.
            t_sRegValue.SetAt( t_iIndex, t_smiley );

			// save start for next time around.
            t_iStart = t_iIndex + 1;

            t_iIndex = t_buf.Find(' ');

            a_instArray[ t_nInstances ].name = t_buf.Left( t_iIndex );

            if ( t_iIndex != -1 )
			{
                t_buf.SetAt( t_iIndex, t_smiley );
			}

            int t_iEnd = t_buf.Find(' ');

            // if no more spaces, there isn't a max size written down
            if ( -1 == t_iEnd )
            {
				CHString t_littleBuf = t_buf.Mid( t_iIndex + 1 );

				a_instArray[ t_nInstances ].min = _ttoi( t_littleBuf );
                a_instArray[ t_nInstances ].max = a_instArray[ t_nInstances ].min + 50;
            }
            else
            {
                CHString t_littleBuf = t_buf.Mid( t_iIndex +1, t_iEnd - t_iIndex );
                a_instArray[ t_nInstances ].min = _ttoi( t_littleBuf );

                t_littleBuf = t_buf.Mid( t_iEnd );
                a_instArray[ t_nInstances ].max = _ttoi( t_littleBuf );
            }

			t_nInstances++;
		}
    }

    return t_nInstances;
}
#endif


//New consts for Win Server 2003
#define MAX_SWAPSIZE_X86        (4 * 1024)            // 4 Gb (number stored in megabytes)
#define MAX_SWAPSIZE_X86_PAE    (16 * 1024 * 1024)    // 16 Tb
#define MAX_SWAPSIZE_IA64       (32 * 1024 * 1024)    // 32 Tb
#define MAX_SWAPSIZE_AMD64      (16 * 1024 * 1024)    // 16 Tb

//
//  c:\ as the input
//
/////////////

BOOL DriveIsNTFS(WCHAR * szDrive)  
{
    DWORD dwMaxFnameLen;
    DWORD dwFSFlags;
    TCHAR szDriveFormatName[MAX_PATH];
    BOOL fRetVal = FALSE;
    
    if (GetVolumeInformationW(szDrive, NULL,0, NULL, 
                             &dwMaxFnameLen, &dwFSFlags, 
                             szDriveFormatName, LENGTH_OF(szDriveFormatName)))
    {
        if (wcsstr(szDriveFormatName, TEXT("NTFS")))
        {
            fRetVal = TRUE;
        }
    }

    return fRetVal;
}

//
//  in MegaBytes
//

DWORD GetMaxPageFileSize(WCHAR * szDrive)
{
#if defined(_AMD64_)
    return MAX_SWAPSIZE_AMD64;
#elif defined(_X86_)
    if ((USER_SHARED_DATA->ProcessorFeatures[PF_PAE_ENABLED]) && DriveIsNTFS(szDrive))
    {
        return MAX_SWAPSIZE_X86_PAE;
    }
    else
    {
        return MAX_SWAPSIZE_X86;
    }
#elif defined(_IA64_)
    return MAX_SWAPSIZE_IA64;
#else
    return 0;
#endif

}

/*****************************************************************************
 *
 *  FUNCTION    : PageFileSetting::PutInstance
 *
 *  DESCRIPTION : Write changed or new instance
 *
 *  INPUTS      : a_pInst to store data from
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :	Separate OS compile versions
					For win95, this won't work at all.  Apparently w95 can only
 *					have one page file.  The min, max, and name are all stored
 *					in system.ini.
 *
 *****************************************************************************/
#ifdef NTONLY
HRESULT PageFileSetting::PutInstance( const CInstance &a_pInst, long a_lFlags /*= 0L*/ )
{
	HRESULT t_hRet = WBEM_S_NO_ERROR;

	DWORD	t_dwCount = 0;
    DWORD   t_x = 0;
	DWORD	t_dwTemp = 0;

	PageFileSettingInstance t_instArray [26];
	CHString t_sName;

	bool t_bFoundIt = false;

	//  Free space variables
	DWORD t_dwSectorsPerCluster;
	DWORD t_dwBytesPerSector;
	DWORD t_dwFreeClusters;
	DWORD t_dwTotalClusters;
   	unsigned __int64 t_ullTotalFreeBytes = 0;

	// Get the values we are supposed to write in
	a_pInst.GetCHString( IDS_Name, t_sName );

	CHString t_chsRoot = t_sName.Left( 3 );

	// no higher that the amount of free space on this disk
	if( GetDiskFreeSpace(	t_chsRoot,
							&t_dwSectorsPerCluster,
							&t_dwBytesPerSector,
							&t_dwFreeClusters,
							&t_dwTotalClusters ) )
   {
		t_ullTotalFreeBytes = (unsigned __int64)
							t_dwSectorsPerCluster *
							t_dwBytesPerSector *
							t_dwFreeClusters;

		// back to megabytes
		t_ullTotalFreeBytes = t_ullTotalFreeBytes >> 20;
	}


   // Read the page file array
   t_dwCount = GetPageFileInstances( t_instArray );

   // Check if the name is indeeed "pagefile.sys"
   if ( -1 == t_sName.Find( _T("pagefile.sys") ) )
   {
	   return WBEM_E_UNSUPPORTED_PUT_EXTENSION;
   }

   WCHAR szDrive[4];
   szDrive[0] = t_sName[0];
   szDrive[1] = L':';
   szDrive[2] = L'\\';
   szDrive[3] = 0;

	// Find if it is already there, and update the structure
	for ( t_x = 0; t_x < t_dwCount; t_x++ )
	{
      // Is this the guy?
      CHString chstrSingleBackslashes;
      RemoveDoubleBackslashes(t_sName, chstrSingleBackslashes);

      if ( 0 == _tcsicmp( t_instArray[t_x].name, t_sName ) ||
           0 == chstrSingleBackslashes.CompareNoCase(t_instArray[t_x].name))
	  {
         if ( a_lFlags & WBEM_FLAG_CREATE_ONLY )
		 {
            t_hRet = WBEM_E_ALREADY_EXISTS;
         }
		 else
		 {
            // Did they give us a value?
            if ( !a_pInst.IsNull( IDS_MaximumSize ) )
			{
				// Check for value in range
				t_dwTemp = (DWORD) t_ullTotalFreeBytes;

                // BUG 403159: (UI does this as well - see 
                // \\index2\sdnt\shell\cpls\system\virtual.c
                // This code is stolen from there, essentially.
                //
                // Be sure to include the size of any existing pagefile.
                // Because this space can be reused for a new paging file,
                // it is effectively "disk free space" as well.  The
                // FindFirstFile api is safe to use, even if the pagefile
                // is in use, because it does not need to open the file
                // to get its size.
                //

                WIN32_FIND_DATA ffd;
                SmartFindClose hFind;
                DWORD dwSpaceExistingPagefile = 0;
                if((hFind = FindFirstFile(t_sName, &ffd)) !=
                    INVALID_HANDLE_VALUE)
                {
                    dwSpaceExistingPagefile = (INT)ffd.nFileSizeLow;
                    // convert to megs:
                    dwSpaceExistingPagefile = dwSpaceExistingPagefile >> 20;
                }
                t_ullTotalFreeBytes += dwSpaceExistingPagefile;

                // END 403159 fix. 


				a_pInst.GetDWORD( IDS_MaximumSize, t_dwTemp );
               DWORD dwMaxSizeInMegs = GetMaxPageFileSize(szDrive);
			   if( t_ullTotalFreeBytes < t_dwTemp ||
                   t_dwTemp > dwMaxSizeInMegs)  
			   {
					t_hRet = WBEM_E_VALUE_OUT_OF_RANGE;
                    t_bFoundIt = true;
					break;
			   }
               t_instArray[t_x].max = t_dwTemp;
            }

            // Did they give us a value?
            if ( !a_pInst.IsNull( IDS_InitialSize ) )
			{
				// Check for value in range
				t_dwTemp = 0;
				a_pInst.GetDWORD( IDS_InitialSize, t_dwTemp );
				
                if(!(t_instArray[t_x].max == 0 && t_dwTemp == 0))
                {
                    if(t_dwTemp < 2)
                    {
                        t_hRet = WBEM_E_VALUE_OUT_OF_RANGE;
                        t_bFoundIt = true;
					    break;
                    }
                }
                t_instArray[t_x].min = t_dwTemp;
            }

            // Check the basic
            if ( t_instArray[t_x].min > t_instArray[t_x].max )
			{
               t_hRet = WBEM_E_VALUE_OUT_OF_RANGE;
            }

			t_bFoundIt = true;
            break;
         }
      }
   }

   // We didn't find it.  Let's make a new one.
   if ( !t_bFoundIt)
   {
       if (a_lFlags & WBEM_FLAG_UPDATE_ONLY)
       {
           t_hRet = WBEM_E_NOT_FOUND;
       }
       else
       {
           t_instArray[ t_dwCount ].name = t_sName;
        
           // Did they give us a value?
           if ( !a_pInst.IsNull( IDS_InitialSize ) )
	       {
               // Check for value in range
               a_pInst.GetDWORD( IDS_InitialSize, t_dwTemp );
		       t_instArray[t_dwCount].min = t_dwTemp;
           } 

           // Did they give us a value?
           if ( !a_pInst.IsNull( IDS_MaximumSize ) )
	       {
               // Check for value in range
               a_pInst.GetDWORD( IDS_MaximumSize, t_dwTemp );
		       t_instArray[ t_dwCount ].max = t_dwTemp;
           }

           if(!(t_instArray[t_dwCount].min == 0 && 
                t_instArray[t_dwCount].max == 0))
           {
               // Check for basic errors
               if(t_instArray[t_dwCount].min < 2)
               {
                   t_hRet = WBEM_E_VALUE_OUT_OF_RANGE;
               }
               if(t_ullTotalFreeBytes < t_instArray[ t_dwCount ].max &&
                   SUCCEEDED(t_hRet))
		       {
		           t_hRet = WBEM_E_VALUE_OUT_OF_RANGE;
		       }
               if ( t_instArray[ t_dwCount ].min > t_instArray[ t_dwCount ].max &&
                   SUCCEEDED(t_hRet))
	           {
                   t_hRet = WBEM_E_VALUE_OUT_OF_RANGE;
               }
           }

           if(SUCCEEDED(t_hRet))
           {
               t_dwCount++;
           }

           // Note: there is one special case where we
           // can not make a new one on the fly, and
           // have to set the registry only, and let
           // the changes go into effect on bootup:
           // This is when 0 and 0 have been specified
           // for Initialsize and Maximum size, which
           // is a combination used to signal the os to
           // figure out on its own what initial and
           // maximum sizes to use.  The os performs
           // this on reboot.  Therefore, we will skip
           // the call to CreatePageFile, which
           // will result in our going next to the
           // update registry portion below.

           if(!(t_instArray[t_dwCount-1].min == 0 && 
                t_instArray[t_dwCount-1].max == 0))
           {
               if(SUCCEEDED(t_hRet))
               {
                   LARGE_INTEGER liMin;
                   LARGE_INTEGER liMax;

                   liMin.QuadPart = t_instArray[t_dwCount-1].min;
                   liMax.QuadPart = t_instArray[t_dwCount-1].max;

                   t_hRet = CreatePageFile(
                      t_sName,
                      liMin,
                      liMax,
                      a_pInst);
               }
           }
       }
    }

    // Update the registry
    if ( WBEM_S_NO_ERROR == t_hRet )
    {
        t_hRet = PutPageFileInstances( t_instArray, t_dwCount );
    }

    return t_hRet;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : PageFileSetting::PutPageFileInstances
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : PageFileInstanceArray a_instArray, DWORD a_dwCount
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :	returns HRESULT 
 *
 *****************************************************************************/
#ifdef NTONLY
HRESULT PageFileSetting::PutPageFileInstances(PageFileInstanceArray a_instArray, DWORD a_dwCount )
{
	CRegistry t_Reg ;
	CHString t_sFiles;
	TCHAR t_szBuff[MAXITOA];
	HRESULT t_hResult = WBEM_E_FAILED;

	HRESULT t_Res = t_Reg.Open( HKEY_LOCAL_MACHINE, PAGEFILE_REGISTRY_KEY, KEY_READ | KEY_WRITE );

	if( ERROR_SUCCESS == t_Res )
	{
	  // Build up the string.  Each entry is \0 terminated.
	  t_sFiles.Empty();

	  for ( int t_x = 0; t_x < a_dwCount; t_x++ )
	  {
		 t_sFiles += a_instArray[ t_x ].name;
		 t_sFiles += _T(' ');
		 t_sFiles += _itot( a_instArray[ t_x ].min, t_szBuff, 10 );
		 t_sFiles += _T(' ');
		 t_sFiles += _itot( a_instArray[ t_x ].max, t_szBuff, 10 );
		 t_sFiles += _T('\0');
	  }

	  // The end is indicated with \0\0.
	  t_sFiles += _T('\0');

		// Write the value
		if ((t_Res = RegSetValueEx( t_Reg.GethKey(),
								  PAGING_FILES,
								  0,
								  REG_MULTI_SZ,
								  (const unsigned char *)(LPCTSTR) t_sFiles,
								  t_sFiles.GetLength() * sizeof(TCHAR) )) == ERROR_SUCCESS )
		{
			t_hResult = WBEM_S_NO_ERROR;
		}
	}

	if ( t_Res == ERROR_ACCESS_DENIED )
	{
		t_hResult = WBEM_E_ACCESS_DENIED;
	}

	return t_hResult;
}
#endif

/*
 * VirtualMemDeletePagefile
 *
 * Hack workaround -- MoveFileEx() is broken.
 *
 * Copied without remorse from virtual.c, the code behind the pagefile UI.
 */
DWORD
VirtualMemDeletePagefile(
    LPCWSTR szPagefile
)
{
    HKEY hKey;
    BOOL fhKeyOpened = FALSE;
    DWORD dwResult;
    LONG lResult;
    LPTSTR szBuffer = NULL;
    LPTSTR szBufferEnd = NULL;
    DWORD dwValueType;
    DWORD cbRegistry;
    DWORD cbBuffer;
    DWORD cchPagefile;
    DWORD dwRetVal = ERROR_SUCCESS;

    __try {
        cchPagefile = lstrlen(szPagefile) + 1;

        lResult = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            szSessionManager,
            0L,
            KEY_READ | KEY_WRITE,
            &hKey
        );
        if (ERROR_SUCCESS != lResult) {
            dwRetVal = lResult;
            __leave;
        } // if
        
        //
        // Find out of PendingFileRenameOperations exists, and,
        // if it does, how big it is
        //
        lResult = RegQueryValueEx(
            hKey,
            szPendingRename,
            0L,
            &dwValueType,
            (LPBYTE) NULL,
            &cbRegistry
        );
        if (ERROR_SUCCESS != lResult) {
            //
            // If the value doesn't exist, we still need to set
            // it's size to one character so the formulas below (which are
            // written for the "we're appending to an existing string"
            // case) still work.
            //
            cbRegistry = sizeof(TCHAR);
        } // if

        //
        // Buffer needs to hold the existing registry value
        // plus the supplied pagefile path, plus two extra
        // terminating NULL characters.  However, we only have to add
        // room for one extra character, because we'll be overwriting
        // the terminating NULL character in the existing buffer.
        //
        cbBuffer = cbRegistry + ((cchPagefile + 1) * sizeof(TCHAR));

        //szBufferEnd = szBuffer = (LPTSTR) MemAlloc(LPTR, cbBuffer);
        szBufferEnd = szBuffer = (LPTSTR) new WCHAR[cbBuffer];

        if (!szBuffer) {
            dwRetVal = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        } // if

        // 
        // Grab the existing value, if there is one
        //
        if (ERROR_SUCCESS == lResult) {
            lResult = RegQueryValueEx(
                hKey,
                szPendingRename,
                0L,
                &dwValueType,
                (LPBYTE) szBuffer,
                &cbRegistry
            );
            if (ERROR_SUCCESS != lResult) {
                dwRetVal = ERROR_FILE_NOT_FOUND;
                __leave;
            } // if

            //
            // We'll start our scribbling right on the final
            // terminating NULL character of the existing 
            // value.
            //
            szBufferEnd += (cbRegistry / sizeof(TCHAR)) - 1;
        } // if

        //
        // Copy in the supplied pagefile path.
        //
        lstrcpy(szBufferEnd, szPagefile);

        //
        // Add the final two terminating NULL characters
        // required for REG_MULTI_SZ-ness.  Yes, those indeces
        // are correct--when cchPagfile was calculated above,
        // we added one for its own terminating NULL character.
        //
        szBufferEnd[cchPagefile] = TEXT('\0');
        szBufferEnd[cchPagefile + 1] = TEXT('\0');

        dwValueType = REG_MULTI_SZ;

        lResult = RegSetValueEx(
            hKey,
            szPendingRename,
            0L,
            dwValueType,
            (CONST BYTE *) szBuffer,
            cbBuffer
        );

        if (ERROR_SUCCESS != lResult) {
            dwRetVal = lResult;
        } // if

    } // __try
    __finally {
        if (fhKeyOpened) {
            RegCloseKey(hKey);
        } // if
        if (szBuffer) {
            // MemFree((HLOCAL) szBuffer);
            delete[] szBuffer;
        } // if
    } // __finally

    return dwRetVal;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	DeleteInstance
//
//	CIMOM wants us to delete this instance.
//
//	Inputs:
//
//	Outputs:
//
//	Return:
//
//	Comments: Separate OS compile versions
//
////////////////////////////////////////////////////////////////////////
#ifdef NTONLY
HRESULT PageFileSetting::DeleteInstance(const CInstance &a_pInst, long a_lFlags /*= 0L*/)
{
   DWORD t_dwCount,
		 t_x;
   CHString t_sName;
   bool t_bFoundIt;
   HRESULT t_hRet;
   PageFileSettingInstance t_instArray [ 26 ] ;

   // Fill the pagefile array
   t_dwCount = GetPageFileInstances( t_instArray );

   // Get the name
   a_pInst.GetCHString( IDS_Name, t_sName );

   t_bFoundIt = false;

   // Walk the array looking for it
   for ( t_x = 0; t_x < t_dwCount; t_x++ )
   {
      // This one?
      if ( _tcsicmp( t_instArray[ t_x ].name, t_sName ) == 0 )
	  {
         // Yup
         t_bFoundIt = true;

         // Move the rest down over this one
         for (int t_y = t_x; t_y < t_dwCount - 1; t_y++ )
		 {
			t_instArray[ t_y ].name	= t_instArray[ t_y + 1].name;
			t_instArray[ t_y ].min	= t_instArray[ t_y + 1].min;
			t_instArray[ t_y ].max	= t_instArray[ t_y + 1].max;
		}

         // The array is now one shorter
         t_dwCount--;
         break;
      }
   }

   if ( t_bFoundIt )
   {
      // If we found it, update the registry
      t_hRet = PutPageFileInstances( t_instArray, t_dwCount );

      if (SUCCEEDED(t_hRet))
      {
          // MoveFileEx doesn't work all of the time, register it manually...
          // MoveFileEx(t_sName, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);

          CHString deleteName("\\??\\");
          deleteName += t_sName;
          if (ERROR_SUCCESS != VirtualMemDeletePagefile((const WCHAR *)deleteName))
          {
              LogErrorMessage(L"Failed to queue existing page file for deletion");
              t_hRet = WBEM_E_FAILED;
          }
      }
   }
   else
   {
      t_hRet = WBEM_E_NOT_FOUND;
   }

   return t_hRet;
}
#endif

//
void PageFileSetting::NameToSettingID( CHString &a_chsName, CHString &a_chsSettingID )
{
	if ( !a_chsName.IsEmpty() )
	{
		// e.g. "pagefile.sys @ D:"
		a_chsSettingID  = a_chsName.Mid( 3 ) ;
		a_chsSettingID += _T( " @ " ) ;
		a_chsSettingID += a_chsName.Left( 2 ) ;
	}
	else
	{
		a_chsSettingID = _T( "" ) ;
	}
}

//
void PageFileSetting::NameToCaption( CHString &a_chsName, CHString &a_chsCaption )
{
	if ( !a_chsName.IsEmpty() )
	{
		// e.g. "D:\ 'pagefile.sys'"
		a_chsCaption =  a_chsName.Left( 3 ) ;
		a_chsCaption += _T( " '" ) ;
		a_chsCaption += a_chsName.Mid( 3 ) ;
		a_chsCaption += _T( "'" ) ;
	}
	else
	{
		a_chsCaption = _T( "" ) ;
	}
}

//
void PageFileSetting::NameToDescription( CHString &a_chsName, CHString &a_chsDescription )
{
	// e.g. "'pagefile.sys' @  D:\"
	if ( !a_chsName.IsEmpty() )
	{
		a_chsDescription =  _T( "'" ) ;
		a_chsDescription += a_chsName.Mid( 3 ) ;
		a_chsDescription += _T( "' @ " ) ;
		a_chsDescription += a_chsName.Left( 3 ) ;
	}
	else
	{
		a_chsDescription = _T( "" ) ;
	}
}

PageFileSettingInstance :: PageFileSettingInstance(void)
{
	min = max = 0;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\pagefileusage.h ===
//=================================================================

//

// PageFileUsage.h -- PageFile property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//
//=================================================================




// Property set identification
//============================

#define  PROPSET_NAME_PAGEFILE L"Win32_PageFileUsage"

#define PAGEFILE_REGISTRY_KEY L"System\\CurrentControlSet\\Control\\Session Manager\\Memory Management"
#define PAGING_FILES          L"PagingFiles"
#define TEMP_PAGEFILE	      L"TempPageFile"







class CCIMDataFile;


// corresponds to info found in NT registry
class PageFileUsageInstance
{
public:

	CHString chsName;
	UINT     TotalSize;
	UINT     TotalInUse;
	UINT	 PeakInUse;
	BOOL	 bTempFile;

public:

	PageFileUsageInstance() ;
	
};

// twenty six possible drive letters, twenty six possible page files...
#define PageFileInstanceArray PageFileUsageInstance *

class PageFileUsage : public Provider 
{

	private:

		HRESULT GetPageFileData( 
            CInstance *a_pInst, 
            bool a_fValidate, 
            DWORD dwReqProps);

		HRESULT GetAllPageFileData( 
            MethodContext *a_pMethodContext,
            DWORD dwReqProps);

		// NT only
		DWORD	GetPageFileInstances( PageFileInstanceArray a_instArray );
        void SetInstallDate(CInstance *a_pInst);
		BOOL GetTempPageFile ( BOOL &bTempPageFile  );
        DWORD DetermineReqProps(
                CFrameworkQuery& pQuery,
                DWORD* pdwReqProps);

        HRESULT GetFileBasedName(
            CHString& chstrDeviceStyleName,
            CHString& chstrDriveStyleName);



	protected:
		

    public:
        // Constructor/destructor
        //=======================
        PageFileUsage(LPCWSTR name, LPCWSTR pszNamespace ) ;
       ~PageFileUsage() ;

		// Functions provide properties with current values
        //=================================================
		virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_pInst = 0L);
		virtual HRESULT GetObject(CInstance *a_pInst, long a_lFlags, CFrameworkQuery& pQuery);
        HRESULT ExecQuery(
            MethodContext* pMethodContext, 
            CFrameworkQuery& pQuery, 
            long lFlags /*= 0L*/ );

} ;



#if 0 // ndef _SYSTEM_PAGEFILE_INFORMATION	// DEVL currently wraps this struct
	typedef struct _SYSTEM_PAGEFILE_INFORMATION {
		ULONG NextEntryOffset;
		ULONG TotalSize;
		ULONG TotalInUse;
		ULONG PeakUsage;
		UNICODE_STRING PageFileName;
	} SYSTEM_PAGEFILE_INFORMATION, *PSYSTEM_PAGEFILE_INFORMATION;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\parallelport.h ===
//***************************************************************************
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//  parallelport.h
//
//  Purpose: Parallel port interface property set provider
//
//***************************************************************************

// Property set identification
//============================

#define	PROPSET_NAME_PARPORT	L"Win32_ParallelPort"

#define MAX_PARALLEL_PORTS  9           // As per Win32 spec LPT1-9 supported directly

#include "confgmgr.h"

// Property set identification
//============================

class CWin32ParallelPort : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32ParallelPort(LPCWSTR strName, LPCWSTR pszNamespace ) ;
       ~CWin32ParallelPort() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility function(s)
        //====================

        BOOL LoadPropertyValues( DWORD dwIndex, CInstance* pInstance ) ;


} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\parallelport.cpp ===
//***************************************************************************
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//  parallelport.cpp
//
//  Purpose: Parallel port interface property set provider
//
//***************************************************************************

#include "precomp.h"
#include <cregcls.h>
#include "parallelport.h"

// Property set declaration
//=========================

CWin32ParallelPort win32ParallelPort ( PROPSET_NAME_PARPORT , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ParallelPort::CWin32ParallelPort
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32ParallelPort :: CWin32ParallelPort (

    LPCWSTR strName,
    LPCWSTR pszNamespace

) : Provider ( strName , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ParallelPort::~CWin32ParallelPort
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32ParallelPort :: ~CWin32ParallelPort ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ParallelPort::~CWin32ParallelPort
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

HRESULT CWin32ParallelPort::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
    CHString chsDeviceID ;
    pInstance->GetCHString ( IDS_DeviceID , chsDeviceID ) ;
    CHString chsIndex = chsDeviceID.Right ( 1 ) ;
    WCHAR *szIndex = chsIndex.GetBuffer(0);

    DWORD dwIndex = _wtol(szIndex);
    BOOL bRetCode = LoadPropertyValues( dwIndex, pInstance ) ;

    //=====================================================
    //  Make sure we got the one we want
    //=====================================================

    CHString chsNewDeviceID;
	pInstance->GetCHString ( IDS_DeviceID , chsNewDeviceID ) ;

    if ( chsNewDeviceID.CompareNoCase ( chsDeviceID ) != 0 )
    {
        bRetCode = FALSE ;
    }

    return ( bRetCode ? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND );

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ParallelPort::~CWin32ParallelPort
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

HRESULT CWin32ParallelPort :: EnumerateInstances (

    MethodContext *pMethodContext,
    long lFlags /*= 0L*/
)
{
    HRESULT    hr = WBEM_S_NO_ERROR ;

    // Try to create instances for each possible parallel port or
    // until we encounter an error condition.

    for ( DWORD dwIdx = 1; ( dwIdx <= MAX_PARALLEL_PORTS ) && ( WBEM_S_NO_ERROR == hr ) ; dwIdx++ )
    {
        // Get a new instance pointer if we need one.

        CInstancePtr pInstance (CreateNewInstance ( pMethodContext ), false) ;
        if ( NULL != pInstance )
        {
            // If we load the values, something's out there Mulder, so
            // Commit it, invalidating the Instance pointer, in which
            // case if we NULL it out, the above code will get us a
            // new one if it runs again.  Otherwise, we'll just reuse
            // the instance pointer we're holding onto.  This will
            // keep us from allocating and releasing memory each iteration
            // of this for loop.

            if ( LoadPropertyValues ( dwIdx, pInstance ) )
            {
                hr = pInstance->Commit (  );
            }
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    return hr;

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ParallelPort::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties according to passed index
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : TRUE if port was found & properties loaded, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CWin32ParallelPort :: LoadPropertyValues ( DWORD dwIndex, CInstance *pInstance )
{
    WCHAR szTemp[3 + 12] ; // LPTXXXXXXXXX
    StringCchPrintfW(szTemp,LENGTH_OF(szTemp), L"LPT%d", dwIndex) ;

    // Use these to get the PNP Device ID
    CConfigManager cfgmgr;

    BOOL fRet = FALSE ;

            // Good 'ol NT5 just has to be different.  Here is the scenario:
            // Examine HKLM\\HARDWARE\\DEVICEMAP\\PARALLEL PORTS\\ for the key(s) \\Device\\ParallelX,
            // where X is a number.  Scan through all such keys.  One of them should
            // contain a string data value the last part of which match szTemp
            // (e.g., the data will be "\\DosDevices\\LPT1").
            // Now, for whichever value's data yielded a match with szTemp, retain the value
            // of X for that value.
            // Then look at HKLM\\SYSTEM\\CurrentControlSet\\Services\\Parallel\\Enum
            // This key will contain keys with a numeric name, like 0 or 1.  These numeric
            // names correspond with the X value we retained above.  The data for that value
            // is the PNPDeviceID, which is what we are after. The end.

            DWORD dw = -1 ;

            CRegistry reg ;

            if ( reg.Open ( HKEY_LOCAL_MACHINE , _T("HARDWARE\\DEVICEMAP\\PARALLEL PORTS") , KEY_READ ) == ERROR_SUCCESS )
            {
                BOOL fContinue = TRUE;

                for ( dw = 0 ; fContinue; dw ++ )
                {
                    TCHAR *pchValueName = NULL ;
                    unsigned char* puchValueData = NULL ;

                    if ( reg.EnumerateAndGetValues ( dw , pchValueName , puchValueData ) == ERROR_NO_MORE_ITEMS )
                    {
                        fContinue = FALSE;
                    }

                    if ( pchValueName && puchValueData )
                    {
                        wmilib::auto_buffer<TCHAR> delme1(pchValueName);
                        wmilib::auto_buffer<unsigned char> delme2(puchValueData);                        
                            
                        // Want to compare the data of the value with szTemp
                        CHString chstrValueData = (TCHAR *) puchValueData ;
                        if ( chstrValueData.Find ( szTemp ) != -1 )
                        {
                            // OK, this is the one we want. Quit looking.
                            fContinue = FALSE;
                            dw--;  // it's going to get incremented when we break out of the loop
                        }
                    }
                }
            }

            // If dw != -1 here, we found the correct key name for the next step.

            if ( dw != -1 )
            {
                reg.Close () ;

                CHString chstrValueName ;
                chstrValueName.Format ( _T("%d") , dw ) ;

                CHString chstrPNPDeviceID ;
                DWORD dwRet = reg.OpenLocalMachineKeyAndReadValue (

                    _T("SYSTEM\\CurrentControlSet\\Services\\Parport\\Enum") ,
                    chstrValueName,
                    chstrPNPDeviceID
                ) ;

                if ( dwRet == ERROR_SUCCESS )
                {
                    CConfigMgrDevicePtr pDevice;

#ifdef PROVIDER_INSTRUMENTATION

      MethodContext *pMethodContext = pInstance->GetMethodContext();
      pMethodContext->pStopWatch->Start(StopWatch::AtomicTimer);

#endif
                    if ( cfgmgr.LocateDevice ( chstrPNPDeviceID , pDevice ) )
                    {
                        SetConfigMgrProperties ( pDevice , pInstance ) ;

#ifdef PROVIDER_INSTRUMENTATION

                        pMethodContext->pStopWatch->Start(StopWatch::ProviderTimer);

#endif
                        fRet = TRUE ;
                    }
                }
            }

    // Only set these if we got back something good.

    if ( fRet )
    {
        pInstance->SetWBEMINT16 ( IDS_Availability , 3 ) ;

        pInstance->SetCHString ( IDS_Name , szTemp ) ;

        pInstance->SetCHString ( IDS_DeviceID , szTemp ) ;

        pInstance->SetCHString ( IDS_Caption , szTemp ) ;

        pInstance->SetCHString ( IDS_Description , szTemp ) ;

        SetCreationClassName ( pInstance ) ;

        pInstance->Setbool ( IDS_PowerManagementSupported , FALSE ) ;

        pInstance->SetCharSplat ( IDS_SystemCreationClassName , _T("Win32_ComputerSystem") ) ;

        pInstance->SetCHString ( IDS_SystemName , GetLocalComputerName() ) ;

        pInstance->SetWBEMINT16 ( IDS_ProtocolSupported , 17 ) ;

        pInstance->Setbool ( IDS_OSAutoDiscovered , TRUE ) ;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\pagefileusage.cpp ===
//=================================================================

//

// PageFileUsage.CPP --PageFile property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//				 10/23/97    a-hhance       converted to optimized framework
//				 03/01/99    a-peterc       Rewritten with parts split off to PageFileCfg.cpp
//
//=================================================================

// All these nt routines are needed to support the NtQuerySystemInformation
// call.  They must come before FWCommon et all or else it won't compile.
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"
#include <io.h>
#include <WinPerf.h>
#include <cregcls.h>

#include <ProvExce.h>

#include "File.h"
#include "Implement_LogicalFile.h"
#include "CIMDataFile.h"

#include "PageFileUsage.h"
#include <tchar.h>

#include "computersystem.h"

#include "DllWrapperBase.h"
#include "NtDllApi.h"

#include "cfgmgrdevice.h"


const WCHAR *IDS_TempPageFile  = L"TempPageFile";

// declaration of our static instance
//=========================

PageFileUsage MyPageFileSet(PROPSET_NAME_PAGEFILE, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : PageFileUsage::PageFileUsage
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

PageFileUsage::PageFileUsage(LPCWSTR name, LPCWSTR pszNamespace)
: Provider ( name , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : PageFileUsage::~PageFileUsage
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

PageFileUsage::~PageFileUsage()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : PageFileUsage::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : CInstance *a_pInst, long a_lFlags
 *
 *  OUTPUTS     : CInstance *a_pInst
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT PageFileUsage::GetObject(CInstance *a_pInst, long a_lFlags, CFrameworkQuery& pQuery)
{
	// calls the OS specific compiled version
    DWORD dwReqProps = 0L;
    DetermineReqProps(pQuery, &dwReqProps);
	return GetPageFileData( a_pInst, true, dwReqProps ) ;
}

/*****************************************************************************
 *
 *  FUNCTION    : PageFileUsage::EnumerateInstances
 *
 *  DESCRIPTION : Creates property set instances
 *
 *  INPUTS      : MethodContext*  a_pMethodContext, long a_lFlags
 *
 *  OUTPUTS     : MethodContext*  a_pMethodContext
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT PageFileUsage::EnumerateInstances(MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/)
{
	// calls the OS specific compiled version
	return GetAllPageFileData( a_pMethodContext, PROP_ALL_SPECIAL );
}

/*****************************************************************************
 *
 *  FUNCTION    : PageFileUsage::ExecQuery
 *
 *  DESCRIPTION : Creates property set instances
 *
 *  INPUTS      : 
 *
 *  OUTPUTS     : 
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : This implementation of execquery is very basic - it optimizes
 *                only on properties, not on requested instances.  This is 
 *                because there will never be many instances, but some properties
 *                (such as InstallDate) can be fairly expensive to obtain.
 *
 *****************************************************************************/

HRESULT PageFileUsage::ExecQuery(
    MethodContext* pMethodContext, 
    CFrameworkQuery& pQuery, 
    long lFlags /*= 0L*/ )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    DWORD dwReqProps = 0L;
    DetermineReqProps(pQuery, &dwReqProps);

    hr = GetAllPageFileData( pMethodContext, dwReqProps );

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : PageFileUsage::GetPageFileData
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : CInstance *a_pInst
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :	Win9x and NT compiled version
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT PageFileUsage::GetPageFileData( 
    CInstance *a_pInst,  
    bool a_fValidate,
    DWORD dwReqProps)
{
	HRESULT t_hRes = WBEM_E_NOT_FOUND;

    // NT page file name is in registry
    //=================================
	PageFileUsageInstance t_files [ 26 ] ;

   	DWORD t_nInstances = GetPageFileInstances( t_files );

	CHString t_name;
	a_pInst->GetCHString( IDS_Name, t_name );

	for ( DWORD t_i = 0; t_i < t_nInstances; t_i++ )
	{
		if ( 0 == t_name.CompareNoCase ( t_files[t_i].chsName ) )
		{
            a_pInst->SetDWORD ( IDS_AllocatedBaseSize,	(DWORD)t_files[t_i].TotalSize);
		    a_pInst->SetDWORD ( IDS_CurrentUsage,		(DWORD)t_files[t_i].TotalInUse);
			a_pInst->SetDWORD ( IDS_PeakUsage,			(DWORD)t_files[t_i].PeakInUse);
            a_pInst->SetCHString(IDS_Description, t_name);
            a_pInst->SetCHString(IDS_Caption, t_name);

			if ( ( t_files[t_i].bTempFile == 0 ) || ( t_files[t_i].bTempFile == 1 ) )
			{
				a_pInst->Setbool(IDS_TempPageFile, t_files[t_i].bTempFile);
			}

            if(dwReqProps & PROP_INSTALL_DATE)
            {
                SetInstallDate(a_pInst);
            }

			t_hRes = WBEM_S_NO_ERROR;
		}
	}

	return t_hRes;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : PageFileUsage::GetAllPageFileData
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : MethodContext *a_pMethodContext
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :	Win9x and NT compiled version
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT PageFileUsage::GetAllPageFileData( 
    MethodContext *a_pMethodContext,
    DWORD dwReqProps)
{
	HRESULT		t_hResult	 = WBEM_S_NO_ERROR;
	DWORD		t_nInstances = 0;
	CInstancePtr t_pInst;
	PageFileUsageInstance t_files [ 26 ] ;

	// NT page file name is in registry
	//=================================
	t_nInstances = GetPageFileInstances( t_files );

	for (DWORD t_dw = 0; t_dw < t_nInstances && SUCCEEDED( t_hResult ); t_dw++ )
	{
		t_pInst.Attach(CreateNewInstance( a_pMethodContext ) );

		t_pInst->SetCHString( IDS_Name,				t_files[t_dw].chsName );

        
		    t_pInst->SetDWORD(	  IDS_AllocatedBaseSize,t_files[t_dw].TotalSize );
		    t_pInst->SetDWORD(	  IDS_CurrentUsage,		t_files[t_dw].TotalInUse );
		    t_pInst->SetDWORD(	  IDS_PeakUsage,		t_files[t_dw].PeakInUse );

            t_pInst->SetCHString(IDS_Description, t_files[t_dw].chsName);
            t_pInst->SetCHString(IDS_Caption, t_files[t_dw].chsName);
		    if ( ( t_files[t_dw].bTempFile == 0 ) || ( t_files[t_dw].bTempFile == 1 ) )
		    {
			    t_pInst->Setbool(IDS_TempPageFile, t_files[t_dw].bTempFile);
		    }

            if(dwReqProps & PROP_INSTALL_DATE)
            {
                SetInstallDate(t_pInst);
            }

		    t_hResult = t_pInst->Commit(  ) ;
        
	}

	return t_hResult;
}
#endif

// returns actual number found - NT ONLY!
#ifdef NTONLY
DWORD PageFileUsage::GetPageFileInstances( PageFileInstanceArray a_instArray )
{
   	NTSTATUS	t_Status ;
    UCHAR		t_ucGenericBuffer[0x1000] ;
	DWORD		t_nInstances = 0 ;
	CNtDllApi   *t_pNtDll = NULL ;

	BOOL bTempPageFile;

 
	try
	{
		t_pNtDll = (CNtDllApi*) CResourceManager::sm_TheResourceManager.GetResource(g_guidNtDllApi, NULL);
        if(t_pNtDll != NULL)
        {

			ULONG t_uLength = 0L ;
			SYSTEM_PAGEFILE_INFORMATION *t_pSPFI = (SYSTEM_PAGEFILE_INFORMATION*) t_ucGenericBuffer ;

			// Nt system query call
			t_Status = t_pNtDll->NtQuerySystemInformation(	SystemPageFileInformation,
															t_pSPFI,
															sizeof( t_ucGenericBuffer ),
															&t_uLength ) ;

			if ( NT_SUCCESS( t_Status ) && t_uLength )
			{
				SYSTEM_INFO t_SysInfo ;
				GetSystemInfo( &t_SysInfo ) ;

				for( ; ; )
				{
					CHString t_chsName ;

					// copy over the UNICODE_STRING
					LPTSTR  t_pBuffer = t_chsName.GetBuffer( t_pSPFI->PageFileName.Length + 4 ) ;

					memset( t_pBuffer,	'\0', t_pSPFI->PageFileName.Length + 4) ;
					memcpy( t_pBuffer, t_pSPFI->PageFileName.Buffer, t_pSPFI->PageFileName.Length ) ;

					t_chsName.ReleaseBuffer() ;

					// strip off the "\??\"
					if( -1 != t_chsName.Find( _T("\\??\\") ) )
					{
						t_chsName = t_chsName.Mid( 4 ) ;
					}

					if(t_chsName.Find(L":") == -1)
                    {
                        CHString chstrFileBasedName;
                        GetFileBasedName(t_chsName, chstrFileBasedName);
                        t_chsName = chstrFileBasedName;
                    }

                    a_instArray[ t_nInstances ].chsName = t_chsName ;

					// In megabytes, but watch out for the overflow
					unsigned __int64 t_ullTotalSize  = (unsigned __int64)t_pSPFI->TotalSize  * t_SysInfo.dwPageSize ;
					unsigned __int64 t_ullTotalInUse = (unsigned __int64)t_pSPFI->TotalInUse * t_SysInfo.dwPageSize ;
					unsigned __int64 t_ullPeakUsage  = (unsigned __int64)t_pSPFI->PeakUsage  * t_SysInfo.dwPageSize ;

					a_instArray[ t_nInstances ].TotalSize  = (UINT)( t_ullTotalSize  >> 20 ) ;
					a_instArray[ t_nInstances ].TotalInUse = (UINT)( t_ullTotalInUse >> 20 ) ;
					a_instArray[ t_nInstances ].PeakInUse  = (UINT)( t_ullPeakUsage  >> 20 ) ;

					if ( GetTempPageFile ( bTempPageFile  ) )
					{
						a_instArray [ t_nInstances ].bTempFile = bTempPageFile;
					}

					t_nInstances++ ;

					if ( !t_pSPFI->NextEntryOffset )
					{
						break;
					}

					// and bump
					t_pSPFI = (SYSTEM_PAGEFILE_INFORMATION*)((PCHAR) t_pSPFI + t_pSPFI->NextEntryOffset ) ;
				}
			}
  		}

	}
	catch( ... )
	{
		if( t_pNtDll )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidNtDllApi, t_pNtDll);
		}

		throw ;
	}

	if ( t_pNtDll )
	{
		CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidNtDllApi, t_pNtDll);
		t_pNtDll = NULL;
	}

	return t_nInstances;
}
#endif



void PageFileUsage::SetInstallDate(CInstance *a_pInst)
{
    if(a_pInst != NULL)
    {
        CHString chstrFilename;

        a_pInst->GetCHString(IDS_Name, chstrFilename);
        if(chstrFilename.GetLength() > 0)
        {
            MethodContext *pMethodContext = NULL;

            if((pMethodContext = a_pInst->GetMethodContext()) != NULL)
            {
                CInstancePtr clfInst;
                CHString chstrDblBkSlshFN;
                CHString chstrQuery;

                EscapeBackslashes(chstrFilename, chstrDblBkSlshFN);
                TRefPointerCollection<CInstance> pPagefileCollection;

                chstrQuery.Format(
                    L"SELECT InstallDate FROM Cim_Datafile WHERE Name =\"%s\"", 
                    (LPCWSTR)chstrDblBkSlshFN);

                if(SUCCEEDED(CWbemProviderGlue::GetInstancesByQuery(
                    (LPCWSTR)chstrQuery,
                    &pPagefileCollection,
                    pMethodContext,
                    GetNamespace())))
                {
                    REFPTRCOLLECTION_POSITION pos;
                    CInstancePtr pPageFileInst;
                    if(pPagefileCollection.BeginEnum(pos))
                    {
                        pPageFileInst.Attach(pPagefileCollection.GetNext(pos));
                        if(pPageFileInst != NULL)
                        {
                            CHString chstrTimeStr;

                            pPageFileInst->GetCHString(IDS_InstallDate, chstrTimeStr);
                            if(chstrTimeStr.GetLength() > 0)
                            {
                                a_pInst->SetCHString(IDS_InstallDate, chstrTimeStr);
                            }
                        }
                        pPagefileCollection.EndEnum();
                    }
                }
            }
        }
    }
}

#if NTONLY
BOOL PageFileUsage :: GetTempPageFile (
			
	BOOL &bTempPageFile 
)
{
	DWORD dwTemp;
	CRegistry RegInfo;
	BOOL bRetVal = FALSE;

	DWORD t_Status = RegInfo.Open (

		HKEY_LOCAL_MACHINE,
		PAGEFILE_REGISTRY_KEY,
		KEY_READ
	) ;

	if ( t_Status == ERROR_SUCCESS)
	{
		if(RegInfo.GetCurrentKeyValue(TEMP_PAGEFILE, dwTemp) == ERROR_SUCCESS)
		{
			if ( dwTemp )
			{
				bTempPageFile = 1;
			}
			else
			{
				bTempPageFile = 0;
			}

			bRetVal = TRUE;
		}
		else
		{
			// Value is set to 2 if the TempPageFile Doesnt exist in the registry and then this property should remain NULL
			bTempPageFile = 2;
		}
	}


	return bRetVal;
}
#endif



DWORD PageFileUsage::DetermineReqProps(
    CFrameworkQuery& pQuery,
    DWORD* pdwReqProps)
{
    DWORD dwRet = 0L;
    if(pdwReqProps)
    {
        if(pQuery.IsPropertyRequired(IDS_InstallDate))
        {
            dwRet |= PROP_INSTALL_DATE;
        }

        *pdwReqProps = dwRet;
    }
    return dwRet;
}



PageFileUsageInstance::PageFileUsageInstance()
{
	TotalSize = TotalInUse = PeakInUse = 0 ;
	bTempFile = 2;
}


HRESULT PageFileUsage::GetFileBasedName(
    CHString& chstrDeviceStyleName,
    CHString& chstrDriveStyleName)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CHString chstrName;
    CHString chstrDriveBasedName;
    CHString chstrDeviceName;
    LPWSTR wstrDosDeviceNameList = NULL;
    
    chstrDeviceName = chstrDeviceStyleName.Left(
        chstrDeviceStyleName.ReverseFind(L'\\'));

    if(QueryDosDeviceNames(wstrDosDeviceNameList))
	{
        if(FindDosDeviceName(
            wstrDosDeviceNameList, 
            chstrDeviceName, 
            chstrDriveBasedName , 
            TRUE ) )
	    {
		    chstrDriveBasedName += L"\\pagefile.sys";
            chstrDriveStyleName = chstrDriveBasedName;   
	    }
        else
        {
            hr = WBEM_E_FAILED;
        }
    }
    else
    {
        hr = WBEM_E_FAILED;
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\pcmcia.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  PCMCIA.h
//
//  Purpose: PCMCIA Controller property set provider
//
//***************************************************************************

// Property set identification
//============================

#define	PROPSET_NAME_PCMCIA	L"Win32_PCMCIAController"

class CWin32PCMCIA : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32PCMCIA( LPCWSTR strName, LPCWSTR pszNamespace ) ;
       ~CWin32PCMCIA() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

    private:

        // Utility function(s)
        //====================

        HRESULT LoadPropertyValues( CInstance* pInstance, CConfigMgrDevice *pDevice ) ;

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\pcmcia.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  PCMCIA.cpp
//
//  Purpose: PCMCIA Controller property set provider
//
// Note: On nt, it would also be possible to read the ControllerType
//       TupleCrc, Identifier, DeviceFunctionId, CardInSocket, and
//       CardEnabled properties by using DeviceIOCtl on the PCMCIAx
//       device.  An example of this is shown in pcm.cpp (in this
//       same project.
//
//***************************************************************************

#include "precomp.h"

#include "PCMCIA.h"

// Property set declaration
//=========================

CWin32PCMCIA MyPCMCIAController ( PROPSET_NAME_PCMCIA , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PCMCIA::CWin32PCMCIA
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32PCMCIA :: CWin32PCMCIA (

	LPCWSTR strName,
	LPCWSTR pszNamespace

) : Provider ( strName , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PCMCIA::~CWin32PCMCIA
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32PCMCIA::~CWin32PCMCIA()
{
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32PCMCIA::GetObject
//
//  Inputs:     CInstance*      pInstance - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32PCMCIA :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_E_NOT_FOUND ;

    CHString sDeviceID;
    pInstance->GetCHString ( IDS_DeviceID , sDeviceID );

    // Let's see if config manager recognizes this device at all

    CConfigManager cfgmgr ;
    CConfigMgrDevicePtr pDevice;

    if( cfgmgr.LocateDevice ( sDeviceID , pDevice ) )
    {
        // Ok, it knows about it.  Is it a PCMCIA device?

        // On nt4, we key off the service name, for all others, it's the class name.

#ifdef NTONLY

        if ( IsWinNT4 () )
        {
            CHString sService ;

            if ( pDevice->GetService ( sService ) && sService.CompareNoCase ( L"PCMCIA") == 0 )
            {
                hr = LoadPropertyValues ( pInstance , pDevice ) ;
            }
        }
        else
#endif
        {
            if ( pDevice->IsClass ( L"PCMCIA" ) )
            {
                // Yup, it must be one of ours.

                hr = LoadPropertyValues ( pInstance , pDevice ) ;
            }
        }
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32PCMCIA::EnumerateInstances
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32PCMCIA :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_E_FAILED;

    CConfigManager cfgManager;

    CDeviceCollection deviceList;

    BOOL bRet ;

    // On nt4, we key off the service name, for all others, it's the class name.  The class
    // name on nt4 is 'Unknown.'
#ifdef NTONLY
    if ( IsWinNT4 () )
    {
        bRet = cfgManager.GetDeviceListFilterByService ( deviceList, L"PCMCIA" ) ;
    }
    else
#endif
    {
        bRet = cfgManager.GetDeviceListFilterByClass ( deviceList, L"PCMCIA" ) ;
    }

    // While it might be more performant to use FilterByGuid, it appears that at least some
    // 95 boxes will report PCMCIA info if we do it this way.

    if ( bRet )
    {
        REFPTR_POSITION pos;

        if ( deviceList.BeginEnum( pos ) )
        {
            hr = WBEM_S_NO_ERROR;

            // Walk the list

			CConfigMgrDevicePtr pDevice;
            for (pDevice.Attach(deviceList.GetNext ( pos ) );
                 SUCCEEDED( hr ) && (pDevice != NULL);
                 pDevice.Attach(deviceList.GetNext ( pos ) ))
            {
				CInstancePtr pInstance (CreateNewInstance ( pMethodContext ), false) ;
				if ( ( hr = LoadPropertyValues( pInstance, pDevice ) ) == WBEM_S_NO_ERROR )
				{
					hr = pInstance->Commit(  );
				}
            }

            // Always call EndEnum().  For all Beginnings, there must be an End

            deviceList.EndEnum();
        }
    }

    return hr;

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PCMCIA::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance* pInstance - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32PCMCIA::LoadPropertyValues (

	CInstance *pInstance,
	CConfigMgrDevice *pDevice
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    SetConfigMgrProperties ( pDevice, pInstance ) ;

    // Set the status based on the config manager error code

    CHString t_sStatus;
	if ( pDevice->GetStatus ( t_sStatus ) )
	{
		pInstance->SetCHString ( IDS_Status , t_sStatus ) ;
	}

    // Use the PNPDeviceID for the DeviceID (key)

    CHString sTemp ;
    pInstance->GetCHString ( IDS_PNPDeviceID, sTemp ) ;

    pInstance->SetCHString ( IDS_DeviceID , sTemp ) ;

    pInstance->SetWCHARSplat ( IDS_SystemCreationClassName , L"Win32_ComputerSystem" ) ;
    pInstance->SetCHString ( IDS_SystemName , GetLocalComputerName () ) ;

    SetCreationClassName ( pInstance ) ;

	CHString sDesc ;
    if ( pDevice->GetDeviceDesc ( sDesc ) )
    {
        pInstance->SetCHString ( IDS_Description , sDesc ) ;
    }

    // Use the friendly name for caption and name

    if ( pDevice->GetFriendlyName ( sTemp ) )
    {
        pInstance->SetCHString ( IDS_Caption , sTemp ) ;
        pInstance->SetCHString ( IDS_Name , sTemp ) ;
    }
    else
    {
        // If we can't get the name, settle for the description
        pInstance->SetCHString(IDS_Caption, sDesc);
        pInstance->SetCHString(IDS_Name, sDesc);
    }

    if ( pDevice->GetMfg ( sTemp ) )
    {
        pInstance->SetCHString ( IDS_Manufacturer , sTemp ) ;
    }

    // Fixed value from enumerated list
    pInstance->SetWBEMINT16 ( IDS_ProtocolSupported , 15 ) ;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\pnpentity.h ===
//=================================================================

//

// PNPEntity.h -- All PNP devices not reported by other cim classes

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/27/97    Davwoh        Created
//
//=================================================================

#ifndef _PNPEntity_H
#define _PNPEntity_H

// Property set identification
//============================
#define	PROPSET_NAME_PNPEntity	L"Win32_PnPEntity"


#define PNP_ALL_PROPS                    0xFFFFFFFF
#define PNP_KEY_ONLY                     0x00000010
#define PNP_PROP_ConfigManagerErrorCode  0x00000001
#define PNP_PROP_ConfigManagerUserConfig 0x00000002
#define PNP_PROP_Status                  0x00000004
#define PNP_PROP_PNPDeviceID             0x00000008
#define PNP_PROP_DeviceID                0x00000010
#define PNP_PROP_SystemCreationClassName 0x00000020
#define PNP_PROP_SystemName              0x00000040
#define PNP_PROP_Description             0x00000080
#define PNP_PROP_Caption                 0x00000100
#define PNP_PROP_Name                    0x00000200
#define PNP_PROP_Manufacturer            0x00000400
#define PNP_PROP_ClassGuid               0x00000800
#define PNP_PROP_Service                 0x00001000
#define PNP_PROP_CreationClassName       0x00002000
#define PNP_PROP_PurposeDescription      0x00004000


class CWin32PNPEntity : virtual public Provider
{
    private:
        CHPtrArray m_ptrProperties;
        CHString m_GuidLegacy;
        BOOL IsOurs
        (
            CConfigMgrDevice* a_pDevice
        );

    protected:

        virtual bool IsOneOfMe
        (
            void* a_pv
        );

        virtual HRESULT LoadPropertyValues
        (
            void* a_pv
        );

        virtual bool ShouldBaseCommit
        (
            void* a_pvData
        );

        HRESULT Enumerate
        (
            MethodContext* a_pMethodContext, 
            long a_lFlags, 
            DWORD a_dwReqProps
        );

    public:

        // Constructor/destructor
        //=======================

        CWin32PNPEntity
        (
            LPCWSTR a_strName, 
            LPCWSTR a_pszNamespace
        );

        ~CWin32PNPEntity();

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject
        (
            CInstance* a_pInstance, 
            long a_lFlags,
            CFrameworkQuery &pQuery
        );

        virtual HRESULT ExecQuery
        (
            MethodContext* a_pMethodContext, 
            CFrameworkQuery& a_pQuery, 
            long a_Flags = 0L 
        );

        virtual HRESULT EnumerateInstances
        (
            MethodContext* a_pMethodContext, 
            long a_lFlags = 0L
        );
};


// This is the base; it should always commit in the base.
inline bool CWin32PNPEntity::ShouldBaseCommit
(
    void* a_pvData
) 
{ 
    return true; 
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\pnpentity.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  PNPEntity.cpp
//
//  Purpose: PNPEntity Controller property set provider
//
//***************************************************************************

#include "precomp.h"
#include "LPVParams.h"
#include <FRQueryEx.h>
#include <devguid.h>

#include "PNPEntity.h"


// Property set declaration
//=========================

CWin32PNPEntity MyPNPEntityController ( PROPSET_NAME_PNPEntity, IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PNPEntity::CWin32PNPEntity
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32PNPEntity::CWin32PNPEntity
(
    LPCWSTR strName,
    LPCWSTR pszNamespace

) : Provider ( strName , pszNamespace )
{

    m_ptrProperties.SetSize(15);

    m_ptrProperties[0] = ((LPVOID) IDS_ConfigManagerErrorCode);
    m_ptrProperties[1] = ((LPVOID) IDS_ConfigManagerUserConfig);
    m_ptrProperties[2] = ((LPVOID) IDS_Status);
    m_ptrProperties[3] = ((LPVOID) IDS_PNPDeviceID);
    m_ptrProperties[4] = ((LPVOID) IDS_DeviceID);
    m_ptrProperties[5] = ((LPVOID) IDS_SystemCreationClassName);
    m_ptrProperties[6] = ((LPVOID) IDS_SystemName);
    m_ptrProperties[7] = ((LPVOID) IDS_Description);
    m_ptrProperties[8] = ((LPVOID) IDS_Caption);
    m_ptrProperties[9] = ((LPVOID) IDS_Name);
    m_ptrProperties[10] = ((LPVOID) IDS_Manufacturer);
    m_ptrProperties[11] = ((LPVOID) IDS_ClassGuid);
    m_ptrProperties[12] = ((LPVOID) IDS_Service);
    m_ptrProperties[13] = ((LPVOID) IDS_CreationClassName);
    m_ptrProperties[14] = ((LPVOID) IDS_PurposeDescription);

    // This is needed since NT5 doesn't always populate the Class
    // property.  Rather than converting the GUID each call, we do
    // it once and store it.

    WCHAR *pGuid = m_GuidLegacy.GetBuffer(128);
	try
	{
		StringFromGUID2 ( GUID_DEVCLASS_LEGACYDRIVER , pGuid , 128 ) ;
	}
	catch ( ... )
	{
		m_GuidLegacy.ReleaseBuffer ();

		throw ;
	}

	m_GuidLegacy.ReleaseBuffer ();

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PNPEntity::~CWin32PNPEntity
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32PNPEntity :: ~CWin32PNPEntity ()
{
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32PNPEntity::GetObject
//
//  Inputs:     CInstance*      pInstance - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32PNPEntity::GetObject
(
    CInstance* pInstance,
    long lFlags,
    CFrameworkQuery &pQuery
)
{
    HRESULT hr = WBEM_E_NOT_FOUND ;
    CConfigManager cfgmgr;

    // Let's see if config manager recognizes this device at all
    CHString sDeviceID;
    pInstance->GetCHString(IDS_DeviceID, sDeviceID);

    CConfigMgrDevicePtr pDevice;
    if ( cfgmgr.LocateDevice ( sDeviceID , pDevice ) )
    {
		// Ok, it knows about it.  Is it a PNPEntity device?
		if ( IsOneOfMe ( pDevice ) )
		{
			// Yup, it must be one of ours.  See what properties are being requested.
            CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);

            DWORD dwProperties;
            pQuery2->GetPropertyBitMask(m_ptrProperties, &dwProperties);

			hr = LoadPropertyValues ( &CLPVParams ( pInstance , pDevice , dwProperties ) ) ;
		}
    }
	else
	{
		if ( ERROR_ACCESS_DENIED == ::GetLastError() )
		{
			hr = WBEM_E_ACCESS_DENIED;
		}
	}

    return hr;
}


////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32PNPEntity::ExecQuery
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//              CFrameworkQuery& the query object
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32PNPEntity::ExecQuery (

    MethodContext* pMethodContext,
    CFrameworkQuery &pQuery,
    long lFlags
)
{
    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);

    DWORD dwProperties;
    pQuery2->GetPropertyBitMask(m_ptrProperties, &dwProperties);

    return Enumerate ( pMethodContext, lFlags, dwProperties);
}


////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32PNPEntity::EnumerateInstances
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32PNPEntity::EnumerateInstances
(
    MethodContext* pMethodContext,
    long lFlags /*= 0L*/
)
{
    return Enumerate(pMethodContext, lFlags, PNP_ALL_PROPS);
}


////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32IDE::Enumerate
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32PNPEntity::Enumerate
(
    MethodContext* pMethodContext,
    long lFlags, DWORD dwReqProps
)
{
    HRESULT hr = WBEM_E_FAILED;

    CConfigManager cfgManager;
    CDeviceCollection deviceList;
    if ( cfgManager.GetDeviceList ( deviceList ) )
    {
        REFPTR_POSITION pos;

        if ( deviceList.BeginEnum ( pos ) )
        {
            hr = WBEM_S_NO_ERROR;

            // Walk the list

            CConfigMgrDevicePtr pDevice;
            for (pDevice.Attach(deviceList.GetNext ( pos ));
                 SUCCEEDED(hr) && (pDevice != NULL);
                 pDevice.Attach(deviceList.GetNext ( pos )))
            {
				if ( IsOneOfMe ( pDevice ) )
				{
					CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
					if( SUCCEEDED ( hr = LoadPropertyValues ( &CLPVParams( pInstance , pDevice, dwReqProps))))
					{
						if ( ShouldBaseCommit ( NULL ) )
						{
							hr = pInstance->Commit();
						}
					}
				}
            }
            // Always call EndEnum().  For all Beginnings, there must be an End

            deviceList.EndEnum();
        }
    }
	else
	{
		if ( ERROR_ACCESS_DENIED == ::GetLastError() )
		{
			hr = WBEM_E_ACCESS_DENIED;
		}
	}

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PNPEntity::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance* pInstance - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32PNPEntity::LoadPropertyValues
(
    void* a_pv
)
{
    HRESULT t_hr = WBEM_S_NO_ERROR;
    CHString t_chstrDeviceID, t_chstrDesc, t_chstrTemp;

    /*************************************
    * Unpack and confirm our parameters...
    *************************************/

    CLPVParams* t_pData = (CLPVParams*)a_pv;
    CInstance* t_pInstance = (CInstance*)(t_pData->m_pInstance); // This instance released by caller
    CConfigMgrDevice* t_pDevice = (CConfigMgrDevice*)(t_pData->m_pDevice);
    DWORD t_dwReqProps = (DWORD)(t_pData->m_dwReqProps);

    if(t_pInstance == NULL || t_pDevice == NULL)
    {
        return WBEM_E_PROVIDER_FAILURE;
    }


    /***********************
    * Set the key properties
    ***********************/

    t_pDevice->GetDeviceID(t_chstrDeviceID);
    if(t_chstrDeviceID.GetLength() == 0)
    {
        // We need the device id for the key property of this class.  If we can
        // not obtain it, we can't set the key, which is an unacceptable error.
        return WBEM_E_PROVIDER_FAILURE;
    }
    else
    {
        t_pInstance->SetCHString(IDS_DeviceID, t_chstrDeviceID);
    }


    /*************************
    * Set PNPEntity properties
    *************************/

    if(t_dwReqProps & PNP_PROP_Manufacturer)
    {
        if(t_pDevice->GetMfg(t_chstrTemp))
        {
            t_pInstance->SetCHString(IDS_Manufacturer, t_chstrTemp);
        }
    }

    if(t_dwReqProps & PNP_PROP_ClassGuid)
    {
        if(t_pDevice->GetClassGUID(t_chstrTemp))
        {
            t_pInstance->SetCHString(IDS_ClassGuid, t_chstrTemp);
        }
    }

    if(t_dwReqProps & PNP_PROP_Service)
    {
        if(t_pDevice->GetService(t_chstrTemp))
        {
            t_pInstance->SetCHString(IDS_Service, t_chstrTemp);
        }
    }


    /*********************************
    * Set CIM_LogicalDevice properties
    *********************************/

    if(t_dwReqProps & PNP_PROP_PNPDeviceID)
    {
        t_pInstance->SetCHString(IDS_PNPDeviceID, t_chstrDeviceID);
    }
    if(t_dwReqProps & PNP_PROP_SystemCreationClassName)
    {
        t_pInstance->SetCHString(IDS_SystemCreationClassName,
                                 IDS_Win32ComputerSystem);
    }
    if(t_dwReqProps & PNP_PROP_CreationClassName)
    {
        t_pInstance->SetCHString(IDS_CreationClassName,
                                 GetProviderName());
    }
    if(t_dwReqProps & PNP_PROP_SystemName)
    {
        t_pInstance->SetCHString(IDS_SystemName, GetLocalComputerName());
    }
    if ((t_dwReqProps & PNP_PROP_Description) || (t_dwReqProps & PNP_PROP_Caption) || (t_dwReqProps & PNP_PROP_Name))
    {
        if(t_pDevice->GetDeviceDesc(t_chstrDesc))
        {
            t_pInstance->SetCHString(IDS_Description, t_chstrDesc);
        }
    }

    if(t_dwReqProps & PNP_PROP_ConfigManagerErrorCode ||
       t_dwReqProps & PNP_PROP_Status)
    {
        DWORD t_dwStatus = 0L;
        DWORD t_dwProblem = 0L;
        if(t_pDevice->GetStatus(&t_dwStatus, &t_dwProblem))
        {
            if(t_dwReqProps & PNP_PROP_ConfigManagerErrorCode)
            {
                t_pInstance->SetDWORD(IDS_ConfigManagerErrorCode, t_dwProblem);
            }
            if(t_dwReqProps & PNP_PROP_Status)
            {
                CHString t_chsTmp;

				ConfigStatusToCimStatus ( t_dwStatus , t_chsTmp ) ;
                t_pInstance->SetCHString(IDS_Status, t_chsTmp);
            }
        }
    }

    if(t_dwReqProps & PNP_PROP_ConfigManagerUserConfig)
    {
        t_pInstance->SetDWORD(IDS_ConfigManagerUserConfig,
                              t_pDevice->IsUsingForcedConfig());
    }

    // Use the friendly name for caption and name
    if(t_dwReqProps & PNP_PROP_Caption || t_dwReqProps & PNP_PROP_Name)
    {
        if(t_pDevice->GetFriendlyName(t_chstrTemp))
        {
            t_pInstance->SetCHString(IDS_Caption, t_chstrTemp);
            t_pInstance->SetCHString(IDS_Name, t_chstrTemp);
        }
        else
        {
            // If we can't get the name, settle for the description
            if(t_chstrDesc.GetLength() > 0)
            {
                t_pInstance->SetCHString(IDS_Caption, t_chstrDesc);
                t_pInstance->SetCHString(IDS_Name, t_chstrDesc);
            }
        }
    }
    return t_hr;
}

bool CWin32PNPEntity::IsOneOfMe
(
    void* pv
)
{
    DWORD dwStatus;
    CConfigMgrDevice* pDevice = (CConfigMgrDevice*)pv;

    // This logic is what the nt5 device manager uses to
    // hide what it calls 'hidden' devices.  These devices
    // can be viewed by using the View/Show Hidden Devices.

    if (pDevice->GetConfigFlags( dwStatus ) &&          // If we can read the status
        ((dwStatus & DN_NO_SHOW_IN_DM) == 0) &&         // Not marked as hidden

        ( !(pDevice->IsClass(L"Legacy")) )              // Not legacy

        )
    {
        return true;
    }
    else
    {
        // Before we disqualify this device, see if it has any resources.
        CResourceCollection resourceList;

        pDevice->GetResourceList(resourceList);

        return resourceList.GetSize() != 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\port.h ===
//=================================================================

//

// Port.h -- Port property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/27/97    davwoh         Moved to curly
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_PORT L"Win32_PortResource"

class CWin32Port ;

class CWin32Port:public Provider {

    public:

        // Constructor/destructor
        //=======================

        CWin32Port(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CWin32Port() ;

        // Funcitons provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);

    private:

        // Utility function(s)
        //====================

#if NTONLY == 4
        void LoadPropertyValues(LPRESOURCE_DESCRIPTOR pResourceDescriptor, CInstance *pInstance);
#endif
#if NTONLY == 5
        void LoadPropertyValues(
            DWORD64 dwStart, 
            DWORD64 dwEnd, 
            BOOL bAlias, 
            CInstance *pInstance);
        HRESULT GetWin9XIO(MethodContext*  pMethodContext, CInstance *pSpecificInstance );
#endif

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\pointer.cpp ===
//////////////////////////////////////////////////////////////////////

//

//  Pointer.CPP -- Win32 provider for pointing devices, eg, mice.

//

//  Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
//  10/16/95     a-skaja     Prototype for demo
//  9/04/96     jennymc     Updated to current standards
//  10/21/96    jennymc     Documentation/Optimization
//  10/24/97    jennymc     Moved to the new framework
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <cregcls.h>

#include "Pointer.h"

// Property set declaration
//=========================

CWin32PointingDevice MyCWin32PointingDeviceSet ( PROPSET_NAME_MOUSE , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PointingDevice::CWin32PointingDevice
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32PointingDevice :: CWin32PointingDevice (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PointingDevice::~CWin32PointingDevice
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32PointingDevice :: ~CWin32PointingDevice ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32PointingDevice :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

	CHString strDeviceID ;
	pInstance->GetCHString ( IDS_DeviceID, strDeviceID ) ;

#ifdef NTONLY
	if ( IsWinNT351 () )
	{
		// This function will fail if the strDeviceID value is not the
		// service name of the mouse.

		hr = GetNT351Instance ( pInstance , strDeviceID ) ;
	}
	else if ( ! IsWinNT4 () || SUCCEEDED ( NT4ArePointingDevicesAvailable () ) )
#endif
	{
		// In NT 4, if no pointing devices are plugged into the machine, a key
		// and value pair will be missing from the DEVICEMAP portion of the registry
		// If that is the case, then there are no pointing devices in the machine,
		// although ConfigManager will be more than happy to return confusing and
		// redundant information to us (device ids that will pass the test below,
		// since Config Manager believes them to be valid devices).  So with that
		// in mind, we want to ensure that no mouse instances will be returned.

		CConfigManager configMgr;
		CConfigMgrDevicePtr pDevice;
		if ( configMgr.LocateDevice ( strDeviceID, pDevice ) )
		{
			CHString strService ;

			// The device had best be a Mouse device, with either a class
			// name of Mouse, or a class GUID of the MOUSE_CLASS_GUID

			if ( ( pDevice->IsClass ( L"Mouse" ) )
				|| ( pDevice->GetService ( strService ) && strService.CompareNoCase ( L"Mouclass" ) == 0 )
				|| ( IsMouseUSB ( strDeviceID ) ) )
			{
				CHString strTemp ;

				// Now we get platform dependent
#ifdef NTONLY
				hr = GetNTInstance ( pInstance , pDevice ) ;
#endif

				// Set the device Status

				// Set the device id and shove it into PNPDeviceId
				SetConfigMgrStuff(pDevice, pInstance);

				//set DeviceInterface property
				SetDeviceInterface(pInstance);
			}
		}
	}

	return hr ;
}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32PointingDevice :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
	HRESULT hr = WBEM_E_FAILED;

#ifdef NTONLY

	if ( IsWinNT351() )
	{
		// NT 3.51 only supports a single instance

	    CInstancePtr pInstance (CreateNewInstance ( pMethodContext ), false) ;
		if ( NULL != pInstance )
		{
			hr = GetNT351Instance ( pInstance ) ;
			if ( SUCCEEDED(hr) )
			{
				SetDeviceInterface (pInstance); //we will commit anyway
				hr = pInstance->Commit (  ) ;
			}
		}
		else
		{
			hr = WBEM_E_PROVIDER_FAILURE;
		}

	}
	// sorry 'bout this line - time for a rewrite
	else if ( ! IsWinNT4 () || ( SUCCEEDED ( hr = NT4ArePointingDevicesAvailable () ) ) )
#endif
	{
		// On NT4, we have a place we can look in the registry that will not have
		// a value if no pointing devices are plugged into the machine.  If that happens,
		// the config manager suddenly gets confused about the values it returns
		// and begins giving us back redundant/duplicate information.

		BOOL fGotList = FALSE;

		// Get all devices of class mouse.  This will get multiple devices
		// if there are multiple MICE --- DUH!

		// Saw an NT 5 box with no class for Mouse, but still had the class GUID.  Using
		// Class GUID is probably a better search anyway.  Unfortunately because we have
		// to support Win95, I don't see class GUIDs there, so we'll stick with Mouse for
		// non NT platforms.

		CConfigManager cfgMgr;
		CDeviceCollection deviceList;

#ifdef NTONLY
		{
            // HID USB devices are returned this way, but without any bus information, which causes an enumeration
            // of what devices are on a USB bus to fail.  So we do it the following way:
            // 1) Get all the devices where the class is {4D36E96F-E325-11CE-BFC1-08002BE10318} (MOUSE_CLASS_GUID).  Also get all devices where service is "HidUsb".
            // 2) Go through list of devices returned from "HidUsb", and see if the DeviceId for the device
            //    includes the string HID at the beginning.
            // 3) If one is found (format of string is HID\xxxxxxx\yyyyy), compare xxxxxx to the DeviceID of the
            //    devices returned from enumeration of devices where service is "HidUsb" from step 1 (format of these
            //    entries is similarly USB\zzzzzzz\qqqqq)
            //    a. If xxxxxx == zzzzzzz, then add device zzzzzzz to the vector.
            // 4) If we can't find a matching HID entry, use what we got

            cfgMgr.GetDeviceListFilterByClassGUID ( deviceList , MOUSE_CLASS_GUID ) ;

            // Some NT4 boxes report mice this way...
            if ( ! deviceList.GetSize () )
			{
                cfgMgr.GetDeviceListFilterByService ( deviceList , _T("Mouclass") ) ;
			}

            CDeviceCollection HIDDeviceList;
            cfgMgr.GetDeviceListFilterByService ( HIDDeviceList , _T("HidUsb") ) ;

            REFPTR_POSITION pos = 0;
            if ( deviceList.BeginEnum ( pos ) )
            {
                hr = WBEM_S_NO_ERROR;
                CConfigMgrDevicePtr pMouse;
                for (pMouse.Attach(deviceList.GetNext ( pos ));
                     SUCCEEDED(hr) && (pMouse != NULL);
                     pMouse.Attach(deviceList.GetNext ( pos )))
				{
					CHString chstrPNPDevID ;
					if ( pMouse->GetDeviceID ( chstrPNPDevID ) != NULL )
					{
						CHString chstrPrefix = chstrPNPDevID.Left ( 3 ) ;
						BOOL fGotMatchingHID = FALSE ;
						if ( chstrPrefix == _T("HID") )
						{
							REFPTR_POSITION posHID = 0 ;
							if ( chstrPNPDevID.GetLength () > 4 )
							{
								CHString chstrMiddlePart = chstrPNPDevID.Mid ( 4  );
								LONG m = chstrMiddlePart.ReverseFind ( _T('\\') ) ;
								if ( m != -1 )
								{
									chstrMiddlePart = chstrMiddlePart.Left ( m ) ;

									if ( HIDDeviceList.BeginEnum ( posHID ) )
									{
										CConfigMgrDevicePtr pHID;

                                        for (pHID.Attach(HIDDeviceList.GetNext ( posHID ) );
                                             !fGotMatchingHID && (pHID != NULL);
                                             pHID.Attach(HIDDeviceList.GetNext ( posHID ) ))
										{
											CHString chstrPNPHIDDevID ;
											if ( pHID->GetDeviceID ( chstrPNPHIDDevID ) != NULL )
											{
												if ( chstrPNPHIDDevID.GetLength () > 4 )
												{
													CHString chstrHIDMiddlePart = chstrPNPHIDDevID.Mid ( 4 ) ;
													m = chstrHIDMiddlePart.ReverseFind ( _T('\\') ) ;
													if ( m != -1 )
													{
														chstrHIDMiddlePart = chstrHIDMiddlePart.Left ( m ) ;

														if(chstrHIDMiddlePart.CompareNoCase ( chstrMiddlePart ) == 0 )
														{
															fGotMatchingHID = TRUE ;

															// Set various properties and commit:

															CInstancePtr pInstance (CreateNewInstance ( pMethodContext ), false) ;
															if ( pInstance != NULL )
															{
																pInstance->SetCHString ( IDS_DeviceID , chstrPNPHIDDevID ) ;

																SetConfigMgrStuff(pHID, pInstance);

																hr = GetNTInstance ( pInstance , pHID ) ;
																if ( SUCCEEDED ( hr ) )
																{
																	SetDeviceInterface (pInstance); //we will commit anyway
																	hr = pInstance->Commit ( ) ;
																}
															}
														}
													}
												}
											}
										}

										HIDDeviceList.EndEnum();
									}
								}
							}
						}

						if ( ! fGotMatchingHID  ) // Use what we got if couldn't find matching HID entry.
						{
							CInstancePtr pInstance (CreateNewInstance ( pMethodContext ), false) ;
							if ( pInstance != NULL )
							{
								pInstance->SetCHString ( IDS_DeviceID , chstrPNPDevID ) ;

								SetConfigMgrStuff(pMouse, pInstance);

								hr = GetNTInstance ( pInstance , pMouse ) ;

								if ( SUCCEEDED ( hr ) )
								{
									SetDeviceInterface (pInstance); //we will commit anyway
									hr = pInstance->Commit (  ) ;
								}
							}
						}
					}
                }

                deviceList.EndEnum();
            }

		}
#endif
		if ( fGotList )
		{
			CHString strServiceName ;
			CHString strDriverName;

			REFPTR_POSITION	pos = NULL;

			// Enumerate the devices


			if ( deviceList.BeginEnum ( pos ) )
			{
				CConfigMgrDevicePtr pDevice;

				hr = WBEM_S_NO_ERROR;

                for ( pDevice.Attach(deviceList.GetNext( pos ) );
                      SUCCEEDED(hr) && (pDevice != NULL);
                      pDevice.Attach(deviceList.GetNext( pos ) ))
				{
					// We need the Config Mgr device ID, as it will uniquely identify
					// the mouse on this system.

					CHString strDeviceID ;
					if ( pDevice->GetDeviceID ( strDeviceID ) )
					{
						CInstancePtr pInstance (CreateNewInstance( pMethodContext ), false);
						if ( NULL != pInstance )
						{
							pInstance->SetCHString ( IDS_DeviceID , strDeviceID ) ;

							SetConfigMgrStuff(pDevice, pInstance);

						// Now we get platform dependent
#ifdef NTONLY
							hr = GetNTInstance ( pInstance , pDevice ) ;
#endif


							if ( SUCCEEDED ( hr ) )
							{
								SetDeviceInterface (pInstance); //we will commit anyway
								hr = pInstance->Commit (  ) ;
							}
						}
						else
						{
                            hr = WBEM_E_PROVIDER_FAILURE;
						}

					}
				}

				deviceList.EndEnum () ;

			}	// If BeginEnum


		}	// IF GetDeviceList

	}	// IF !NT3.51

    return hr;

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PointingDevice::CWin32PointingDevice
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

void CWin32PointingDevice :: GetCommonMouseInfo (

	CInstance *pInstance
)
{
	DWORD dwNumberOfButtons;
	if ( ( dwNumberOfButtons = GetSystemMetrics (SM_CMOUSEBUTTONS)) == 0 )
	{
        //==================================================
        // Mouse not installed so other properties do not
        // make sense
        //==================================================
    }
    else
	{
        //==================================================
        // Mouse Installed
        //==================================================
        //==================================================
        // Check if buttons are swapped
        //==================================================
		if (GetSystemMetrics (SM_SWAPBUTTON))
		{
			pInstance->SetWBEMINT16(IDS_Handedness, 3);
		}
		else
		{
			pInstance->SetWBEMINT16(IDS_Handedness, 2);
		}

        //==================================================
        // Get mouse threshold and speed
        //==================================================

		int aMouseInfo [ 3 ] ;             // array for mouse info.
		if ( SystemParametersInfo ( SPI_GETMOUSE , NULL, & aMouseInfo , NULL ) )
		{
			pInstance->SetDWORD ( IDS_DoubleSpeedThreshold , (DWORD)aMouseInfo [ 0 ] ) ;
			pInstance->SetDWORD ( IDS_QuadSpeedThreshold , (DWORD)aMouseInfo [ 1 ] ) ;
		}
   }

	pInstance->SetDWORD ( IDS_NumberOfButtons, dwNumberOfButtons ) ;

	SetCreationClassName ( pInstance ) ;

	pInstance->SetWCHARSplat ( IDS_SystemCreationClassName , L"Win32_ComputerSystem" ) ;

  	pInstance->SetCHString ( IDS_SystemName , GetLocalComputerName () ) ;

	pInstance->Setbool ( IDS_PowerManagementSupported , FALSE ) ;

	// 2 is unknown, since we dont' know if it's a mouse, trackball or whatever.
    pInstance->SetDWORD(L"PointingType", 2);
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PointingDevice::CWin32PointingDevice
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/


/*****************************************************************************
 *
 *  FUNCTION    : CWin32PointingDevice::CWin32PointingDevice
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32PointingDevice :: GetNTInstance (

	CInstance *pInstance,
    CConfigMgrDevice *pDevice
)
{
	CHString strServiceName ;
    if ( ! pDevice->GetService ( strServiceName ) )
	{
        return WBEM_E_NOT_FOUND ;
	}

    // It's OK if we don't have a driver.

	CHString strDriver, strName ;

    pDevice->GetDriver ( strDriver ) ;

    pDevice->GetDeviceDesc(strName);

    pInstance->SetCHString ( IDS_Name , strName ) ;

    pInstance->SetCHString ( IDS_Description , strName ) ;

    pInstance->SetCHString ( IDS_Caption , strName ) ;

    pInstance->SetCHString ( IDS_HardwareType , strName ) ;

    GetNTDriverInfo ( pInstance , strServiceName , strDriver ) ;

    return WBEM_S_NO_ERROR;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PointingDevice::CWin32PointingDevice
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32PointingDevice :: GetNTDriverInfo (

	CInstance *pInstance,
    LPCTSTR szService,
	LPCTSTR szDriver
	)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CRegistry Reg ;

	if ( GetSystemParameterSectionForNT ( szService , Reg ) == ERROR_SUCCESS )
	{

	    DWORD dwTmp ;

		if ( Reg.GetCurrentKeyValue ( _T("SampleRate") , dwTmp )  == ERROR_SUCCESS )
		{
			pInstance->SetDWORD (IDS_SampleRate , dwTmp) ;
		}

		if ( Reg.GetCurrentKeyValue(_T("MouseResolution"), dwTmp)  == ERROR_SUCCESS )
		{
			pInstance->SetDWORD ( IDS_Resolution, dwTmp ) ;
		}

		if( Reg.GetCurrentKeyValue(_T("MouseSynchIn100ns"), dwTmp)  == ERROR_SUCCESS )
		{
			pInstance->SetDWORD(IDS_Synch, dwTmp);
		}
	}

    CHString chsMousePortInfo ;
	AssignPortInfoForNT ( chsMousePortInfo, Reg , pInstance ) ;

	if ( szDriver && *szDriver )
    {
        CHString strDriverKey( _T("SYSTEM\\CurrentControlSet\\Control\\Class\\") );
        strDriverKey += szDriver ;

	    if ( Reg.Open ( HKEY_LOCAL_MACHINE , strDriverKey, KEY_READ ) == ERROR_SUCCESS )
        {
			CHString chsTmp ;
		    if ( Reg.GetCurrentKeyValue ( _T("InfPath"), chsTmp) == ERROR_SUCCESS)
		    {
			    pInstance->SetCHString ( IDS_InfFileName, chsTmp ) ;
			    if( Reg.GetCurrentKeyValue ( _T("InfSection") , chsTmp ) == ERROR_SUCCESS )
			    {
			       pInstance->SetCHString ( IDS_InfSection , chsTmp ) ;
			    }
		    }
        }
    }

    GetCommonMouseInfo ( pInstance ) ;

    return hr;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PointingDevice::CWin32PointingDevice
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32PointingDevice :: GetNT351Instance (

	CInstance *pInstance,
	LPCTSTR pszServiceName
)
{
	HRESULT hr = WBEM_E_FAILED ;

	CHString	chsMousePortInfo;
	CRegistry	Reg;

	DWORD dwRet = Reg.OpenLocalMachineKeyAndReadValue (

        _T("HARDWARE\\DEVICEMAP\\PointerPort"),
        _T("\\Device\\PointerPort0"),
		chsMousePortInfo
	) ;

	if ( dwRet == ERROR_SUCCESS )
	{
		// NT 3.51, we only support a single instance

		chsMousePortInfo.MakeUpper();

		if ( NULL == pszServiceName || chsMousePortInfo.CompareNoCase ( pszServiceName ) == 0 )
		{
			CHString strService ;

			if ( AssignDriverNameForNT ( chsMousePortInfo , strService ) )
			{
				// DeviceID for NT 3.51 is the Service Name
				pInstance->SetCHString ( IDS_DeviceID , strService ) ;

				// Driver name is hardcoded, preserving behavior of original code
				hr = GetNTDriverInfo(pInstance, strService, _T("{4D36E96F-E325-11CE-BFC1-08002BE10318}\\0000"));

			}	// IF AssignDriverNameForNT

		}	// If keynames match, or supplied value is NULL
		else
		{
			hr = WBEM_E_NOT_FOUND;
		}

	}	// If got value

	return hr;

}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PointingDevice::CWin32PointingDevice
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

// Helper function that looks in the registry for a \Device\PointerPort0
// value in the HKLM\Hardware\DeviceMap\PointerPort key in the registry.  If the value
// exists, then we have mice connected to the machine.  If not, we don't.
// The Config Manager in NT 4 has this habit of returning confusing/redundant
// information regarding mice on the workstation if no mice are plugged in
// at boot time.  This call will only be helpful for NT 4 and maybe 3.51

#ifdef NTONLY
HRESULT CWin32PointingDevice::NT4ArePointingDevicesAvailable ( void )
{
	CHString strTest;
	CRegistry Reg;

	LONG lRet = Reg.OpenLocalMachineKeyAndReadValue (

		_T("HARDWARE\\DEVICEMAP\\PointerPort") ,
        _T("\\Device\\PointerPort0") ,
		strTest
	) ;

	return ( WinErrorToWBEMhResult ( lRet ) ) ;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PointingDevice::CWin32PointingDevice
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

#ifdef NTONLY

HRESULT CWin32PointingDevice :: GetSystemParameterSectionForNT (

	LPCTSTR pszServiceName,
	CRegistry &reg
)
{
    HRESULT hr = WBEM_E_FAILED;

	CHString strKey(L"System\\CurrentControlSet\\Services\\");
	strKey += pszServiceName;
	strKey += L"\\Parameters";

	// This is the service's Parameter section
    //=========================================================================

    hr = reg.Open ( HKEY_LOCAL_MACHINE , strKey, KEY_READ ) ;

    return hr;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PointingDevice::CWin32PointingDevice
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

#ifdef NTONLY
BOOL CWin32PointingDevice :: AssignPortInfoForNT (

	CHString &chsMousePortInfo,
    CRegistry &Reg,
    CInstance *pInstance
)
{
    BOOL fPortInfoAvailable = FALSE;

	DWORD dwRet = Reg.OpenLocalMachineKeyAndReadValue (

		_T("HARDWARE\\DEVICEMAP\\PointerClass"),
        _T("\\Device\\PointerClass0"),
        chsMousePortInfo
	) ;

	if ( dwRet == ERROR_SUCCESS )
	{
        chsMousePortInfo.MakeUpper() ;
        if ( GetSystemParameterSectionForNT ( chsMousePortInfo , Reg ) )
		{
            fPortInfoAvailable = TRUE;
        }
    }
    else
	{
        fPortInfoAvailable = FALSE;
    }

	return fPortInfoAvailable;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PointingDevice::CWin32PointingDevice
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

#ifdef NTONLY
BOOL CWin32PointingDevice::AssignDriverNameForNT(CHString chsMousePortInfo, CHString &sDriver)
{
    TCHAR    *pTempPtr;

	// get the values from the
	// Get the Port Driver Name value
	//===============================
	pTempPtr = _tcsstr (chsMousePortInfo, _T("\\SERVICES\\"));
	if (pTempPtr)
    {
		pTempPtr += _tcslen (_T("\\SERVICES\\"));
		sDriver = pTempPtr;
        return TRUE;
	}

    return FALSE;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PointingDevice::CWin32PointingDevice
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

bool CWin32PointingDevice :: IsMouseUSB (

	CHString &chstrTest
)
{
    // Have the device id of the candidate hid device.  Is it a mouse?
    // 1) Obtain the middle portion of the device id (format:  "USB\\middleportion\\xxxx")
    // 2) Get list of devices of class MOUSE_CLASS_GUID
    // 3) For each, compare the middle part of its device id with middleportion
    // 4) If obtain a match, done, return true.

    bool fRet = false;

    if ( chstrTest.GetLength () > 4 )
    {
        CHString chstrTemp = chstrTest.Mid (4);

        LONG m = chstrTemp.ReverseFind ( _T('\\') ) ;
        if ( m != -1 )
        {
            CHString chstrTempMid = chstrTemp.Left ( m ) ;

            CConfigManager cfgMgr ;
            CDeviceCollection deviceList ;

            cfgMgr.GetDeviceListFilterByClassGUID ( deviceList , MOUSE_CLASS_GUID ) ;

            REFPTR_POSITION pos = 0;

            if ( deviceList.BeginEnum ( pos ) )
            {
                CConfigMgrDevicePtr pMouse;

                for (pMouse.Attach(deviceList.GetNext ( pos ) );
                     !fRet && (pMouse != NULL);
                     pMouse.Attach(deviceList.GetNext ( pos ) ))
	            {
					CHString chstrPNPDevID ;
					if ( pMouse->GetDeviceID ( chstrPNPDevID ) != NULL )
					{
						BOOL fGotMatchingHID = FALSE;

						CHString chstrPrefix = chstrPNPDevID.Left(3);
						if(chstrPrefix == _T("HID") )
						{
							if ( chstrPNPDevID.GetLength () > 4 )
							{
								CHString chstrMiddlePart = chstrPNPDevID.Mid(4);
								m = chstrMiddlePart.ReverseFind(_T('\\'));
								if ( m != -1 )
								{
									chstrMiddlePart = chstrMiddlePart.Left(m);
									if( chstrMiddlePart.CompareNoCase ( chstrTempMid ) == 0 )
									{
										fRet = true;
									}
								}
							}
						}
					}
				}

                deviceList.EndEnum();
            }
        }
    }
    return fRet;
}
void CWin32PointingDevice::SetDeviceInterface
											(
												CInstance *pInstance
											)
{
	CHString strDeviceID ;
	pInstance->GetCHString (IDS_DeviceID, strDeviceID);
	if(IsMouseUSB (strDeviceID))
	{
		pInstance->SetWBEMINT16(IDS_DeviceInterface, 162);
		return;
	}
	CHString strDeviceName;
	pInstance->GetCHString(IDS_Name, strDeviceName);
	if(strDeviceName.Find(L"PS/2") != -1)
	{
		pInstance->SetWBEMINT16(IDS_DeviceInterface, 4);
		return;
	}
	if(strDeviceName.Find(L"Serial") != -1)
	{
		pInstance->SetWBEMINT16(IDS_DeviceInterface, 3);
		return;
	}
	if(strDeviceName.Find(L"Infrared") != -1)
	{
		pInstance->SetWBEMINT16(IDS_DeviceInterface, 5);
		return;
	}
	if(strDeviceName.Find(L"HP-HIL") != -1)
	{
		pInstance->SetWBEMINT16(IDS_DeviceInterface, 6);
		return;
	}
	if(strDeviceName.Find(L"Bus mouse") != -1)
	{
		pInstance->SetWBEMINT16(IDS_DeviceInterface, 7);
		return;
	}
	if((strDeviceName.Find(L"ADB") != -1) || (strDeviceName.Find(L"Apple") != -1))
	{
		pInstance->SetWBEMINT16(IDS_DeviceInterface, 8);
		return;
	}
	if(strDeviceName.Find(L"DB-9") != -1)
	{
		pInstance->SetWBEMINT16(IDS_DeviceInterface, 160);
		return;
	}
	if(strDeviceName.Find(L"micro-DIN") != -1)
	{
		pInstance->SetWBEMINT16(IDS_DeviceInterface, 161);
		return;
	}
	//else we did not find any of the above so return unknown
	pInstance->SetWBEMINT16(IDS_DeviceInterface, 1);

	return;
}


void CWin32PointingDevice::SetConfigMgrStuff(
    CConfigMgrDevice *pDevice,
    CInstance *pInstance)
{
    CHString strTemp;

    if (pDevice->GetMfg(strTemp))
	{
	    pInstance->SetCHString(IDS_Manufacturer, strTemp);
	}

	if (pDevice->GetStatus(strTemp))
	{
		pInstance->SetCHString(IDS_Status, strTemp);
	}

	SetConfigMgrProperties(pDevice, pInstance);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\port.cpp ===
//=================================================================

//

// Port.CPP --Port property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/27/97    davwoh         Moved to curly
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>

#include "CHWRes.h"
#include "Port.h"
#include "ntdevtosvcsearch.h"
#include "configmgrapi.h"

typedef std::map<DWORD, DWORD> DWORD2DWORD;

// Property set declaration
//=========================
CWin32Port MyPortSet(PROPSET_NAME_PORT, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Port::CWin32Port
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32Port::CWin32Port(

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider(name, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Port::~CWin32Port
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32Port::~CWin32Port()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Port::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32Port::GetObject(

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
    HRESULT hRes;

    // This only has meaning for NT
    //=============================

#if NTONLY == 4

	hRes = WBEM_E_NOT_FOUND;

	// Find the nth instance
	//======================

	unsigned __int64 i64StartingAddress;
	if (pInstance)
	{
		pInstance->GetWBEMINT64(IDS_StartingAddress, i64StartingAddress);
	}


	// Create hardware resource list
	//==============================

	CHWResource HardwareResource;
	HardwareResource.CreateSystemResourceLists();

	LPRESOURCE_DESCRIPTOR pResourceDescriptor = HardwareResource._SystemResourceList.PortHead;
	while(pResourceDescriptor != NULL)
	{
        LARGE_INTEGER liTemp;   // Used to avoid 64bit alignment problems

        liTemp.HighPart = pResourceDescriptor->CmResourceDescriptor.u.Port.Start.HighPart;
        liTemp.LowPart = pResourceDescriptor->CmResourceDescriptor.u.Port.Start.LowPart;

		if (liTemp.QuadPart == i64StartingAddress)
		{
			LoadPropertyValues(pResourceDescriptor, pInstance);
			hRes = WBEM_S_NO_ERROR;
			break;
		}

		pResourceDescriptor = pResourceDescriptor->NextSame;
	}

#endif

  #if (NTONLY == 5)

    hRes = GetWin9XIO(NULL, pInstance);

  #endif
  
    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Port::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each installed client
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32Port::EnumerateInstances(

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    // This only has meaning for NT
    //=============================

#if NTONLY == 4

    // Create hardware resource list

    CHWResource HardwareResource;
    HardwareResource.CreateSystemResourceLists();

    // Count how many ports we're going to find.  We need this so
    // we can build an array to keep the ports found so we don't commit
    // the same port more than once. (This problem seems to happen
    // infrequently on NT4.)

    LPRESOURCE_DESCRIPTOR pResourceDescriptor;

	int nFound = 0;

    int nPorts;

    for (nPorts = 0, pResourceDescriptor = HardwareResource.
		 _SystemResourceList.PortHead;
		 pResourceDescriptor != NULL;
         pResourceDescriptor = pResourceDescriptor->NextSame, nPorts++
	)
    {
    }

    // Allocate an array large enough to hold all ports.

    unsigned __int64 *piPortsFound = new unsigned __int64 [ nPorts ];
    if (piPortsFound)
	{
		try
		{
            CInstancePtr pInstance;

			// Traverse list and create instance for each port.
			for (	pResourceDescriptor = HardwareResource._SystemResourceList.PortHead;
					pResourceDescriptor != NULL && SUCCEEDED(hRes);
					pResourceDescriptor = pResourceDescriptor->NextSame
			)
			{

				// Look to see if we already have this port.

                LARGE_INTEGER liTemp;   // Used to avoid 64bit alignment problems

                liTemp.HighPart = pResourceDescriptor->CmResourceDescriptor.u.Port.Start.HighPart;
                liTemp.LowPart = pResourceDescriptor->CmResourceDescriptor.u.Port.Start.LowPart;

				for (int i = 0; i < nFound && liTemp.QuadPart != piPortsFound [ i ]; i++)
				{
				}

				// Skip this port if we already have it.
				//(If we didn't find it, i == nFound.)
				if (i != nFound)
				{
					continue;
				}

				// Keep track of this port so we don't duplicate it later.
				piPortsFound [ nFound++ ] = liTemp.QuadPart;

				pInstance.Attach(CreateNewInstance(pMethodContext));
				LoadPropertyValues(pResourceDescriptor, pInstance);
				hRes = pInstance->Commit();
			}
		}
		catch(...)
		{
			delete [] piPortsFound;

			throw;
		}

		delete [] piPortsFound;
	}
	else
	{
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

#endif

#if NTONLY == 5

	hRes = GetWin9XIO(pMethodContext,NULL);

#endif

    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Port::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties according to passed struct
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#if NTONLY == 4
void CWin32Port::LoadPropertyValues(LPRESOURCE_DESCRIPTOR pResourceDescriptor, CInstance *pInstance)
{
	pInstance->SetCharSplat(IDS_Status, IDS_OK);

	WCHAR szTemp[_MAX_PATH];

    LARGE_INTEGER liTemp;   // Used to avoid 64bit alignment problems

    liTemp.HighPart = pResourceDescriptor->CmResourceDescriptor.u.Port.Start.HighPart;
    liTemp.LowPart = pResourceDescriptor->CmResourceDescriptor.u.Port.Start.LowPart;

	pInstance->SetWBEMINT64(IDS_StartingAddress, liTemp.QuadPart);

	pInstance->SetWBEMINT64(IDS_EndingAddress,
        liTemp.QuadPart +
        pResourceDescriptor->CmResourceDescriptor.u.Port.Length - 1);

	swprintf(
		szTemp,
		L"0x%4.4I64lX-0x%4.4I64lX",
		liTemp.QuadPart,
		liTemp.QuadPart +
            pResourceDescriptor->CmResourceDescriptor.u.Port.Length - 1);

	pInstance->SetCharSplat(IDS_Caption, szTemp);
	pInstance->SetCharSplat(IDS_Name, szTemp);
	pInstance->SetCharSplat(IDS_Description, szTemp);

	pInstance->Setbool(IDS_Alias, false);

	SetCreationClassName(pInstance);

	pInstance->SetCHString(IDS_CSName, GetLocalComputerName());

	pInstance->SetCHString(IDS_CSCreationClassName, L"Win32_ComputerSystem");

    return;
}
#endif

#if NTONLY == 5
void CWin32Port::LoadPropertyValues(
    DWORD64 dwStart,
    DWORD64 dwEnd,
    BOOL bAlias,
    CInstance *pInstance)
{
    WCHAR szTemp[100];

	pInstance->SetCharSplat(IDS_Status, IDS_OK);

    pInstance->SetWBEMINT64(IDS_StartingAddress, dwStart);
	pInstance->SetWBEMINT64(IDS_EndingAddress, dwEnd);
	pInstance->Setbool(L"Alias", bAlias);

#ifdef NTONLY
	swprintf(szTemp, L"0x%08I64X-0x%08I64X", dwStart, dwEnd);
#endif

	pInstance->SetCharSplat(IDS_Caption, szTemp);
	pInstance->SetCharSplat(IDS_Name, szTemp);
	pInstance->SetCharSplat(IDS_Description, szTemp);

	SetCreationClassName(pInstance);
	pInstance->SetCharSplat(IDS_CSName, GetLocalComputerName());
	pInstance->SetCharSplat(IDS_CSCreationClassName, L"Win32_ComputerSystem");
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Port::GetWin9XIO
 *
 *  DESCRIPTION :
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#if NTONLY == 5
HRESULT CWin32Port::GetWin9XIO(

	MethodContext *pMethodContext,
	CInstance *pInstance
)
{
	HRESULT          hr = WBEM_E_FAILED;
    unsigned __int64 i64StartingAddress;
    BOOL             bDone = FALSE;

    //=================================================================
    // If we are refreshing a specific instance, get which Address we
    // are going for
    //=================================================================

    if (pInstance)
    {
        pInstance->GetWBEMINT64(IDS_StartingAddress, i64StartingAddress);
    }

    //=================================================================
    // Get the latest IO info from the Configuration Manager
    //=================================================================

    CConfigManager CMgr(ResType_IO);


#ifdef NTONLY
// TODO: I don't think aliased ports even exist on NT, in which case this
// flag isn't really used.  If we were to find out it is used, we would
// need to add a larger value for NT64.
#define MAX_PORT_VALUE  0xFFFFFFFF
#endif

    if (CMgr.RefreshList())
	{
        DWORD2DWORD mapPorts;

        // Cfg mgr looks OK, so set no error at this point.
        hr = WBEM_S_NO_ERROR;

        for (int i = 0; i < CMgr.GetTotal() && SUCCEEDED(hr) && !bDone; i++)
		{
            //=========================================================
            //  Get the instance to process
            //=========================================================
            IO_INFO *pIO = CMgr.GetIO(i);

            // I've seen Cfg Mgr mess up on W2K and return a starting
            // address of 1 and ending of 0.  Since Device Mgr skips it,
            // we will too.
            if (pIO->StartingAddress > pIO->EndingAddress)
                continue;


			DWORD   dwBegin,
                    dwEnd,
                    dwAdd;
			BOOL    bAlias = FALSE;

            if (pIO->Alias == 0 || pIO->Alias == 0xFF)
			{
			    // This will make us break out of the for loop after the
                // first instance, since this one has no aliases.
                // source.
                dwAdd = 0;
            }
			else
			{
                dwAdd = pIO->Alias * 0x100;
            }

            for (dwBegin = pIO->StartingAddress, dwEnd = pIO->EndingAddress;
                dwEnd <= MAX_PORT_VALUE && SUCCEEDED(hr);
                dwBegin += dwAdd, dwEnd += dwAdd)
			{
                // If we're doing EnumInstances...
                if (pMethodContext)
				{
                    // If it's not in the map, add it.
                    if (mapPorts.find(dwBegin) == mapPorts.end())
                    {
                        // It wasn't in the map.
                        // Set it so we don't try this port again.
		    		    mapPorts[dwBegin] = 0;

                        CInstancePtr pInstance(
                                        CreateNewInstance(pMethodContext),
                                        false);

                        LoadPropertyValues(dwBegin, dwEnd, bAlias, pInstance);

					    hr = pInstance->Commit();
                    }
			    }
                // else if we're doing GetObject and we found the right one...
                else if (i64StartingAddress == dwBegin)
                {
                    LoadPropertyValues(dwBegin, dwEnd, bAlias, pInstance);

                    // We could just return WBEM_S_NO_ERROR now, but we
                    // won't to avoid having a return in the middle of
                    // the code path.
                    bDone = TRUE;
                    break;
				}

				// See if this is a non-aliased value.  If so, get out.
                if (dwAdd == 0)
                    break;

                bAlias = TRUE;
			}
        }

    }

	if (!pMethodContext && !bDone)
	{
		hr = WBEM_E_NOT_FOUND;
	}

    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\pointer.h ===
///////////////////////////////////////////////////////////////////////

//                                                                   //

// Pointer.h -- System property set description for WBEM MO          //

//                                                                   //

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//                                                                   //
// 10/24/95     a-skaja     Prototype                                //
// 10/25/96     jennymc     Updated
// 10/24/97    jennymc     Moved to the new framework
//                                                                   //
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
// Property set identification
///////////////////////////////////////////////////////////////////////
#define PROPSET_NAME_MOUSE L"Win32_PointingDevice"

///////////////////////////////////////////////////////////////////
class CWin32PointingDevice : public Provider
{
    public:

        // Constructor/destructor
        //=======================

        CWin32PointingDevice(LPCWSTR name, LPCWSTR pszNamespace);
       ~CWin32PointingDevice() ;

        // Funcitons provide properties with current values
        //=================================================
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);


        // Utility
        //========
    private:
#ifdef NTONLY
        HRESULT GetSystemParameterSectionForNT( LPCTSTR pszServiceName, CRegistry & reg );
        BOOL AssignPortInfoForNT(CHString & chsMousePortInfo,
                                               CRegistry & Reg,
                                               CInstance * pInstance);
        BOOL AssignDriverNameForNT(CHString chsMousePortInfo, CHString &sDriver);
        void AssignHardwareTypeForNT(CInstance * pInstance,
                                  CRegistry& Reg, CHString sDriver);
        HRESULT GetNTInstance( CInstance *pInstance, CConfigMgrDevice *pDevice);
        HRESULT GetNTDriverInfo(CInstance *pInstance, LPCTSTR szService, 
            LPCTSTR szDriver);
		HRESULT GetNT351Instance( CInstance * pInstance, LPCTSTR pszServiceName = NULL );
		HRESULT NT4ArePointingDevicesAvailable( void );
#endif
        void GetCommonMouseInfo(CInstance * pInstance);
        bool IsMouseUSB(CHString& chstrTest);
		void SetDeviceInterface(CInstance *pInstance);

        void SetConfigMgrStuff(
            CConfigMgrDevice *pDevice, 
            CInstance *pInstance);
} ;

// Class GUID for Mouse Devices on NT and Win98
#define	MOUSE_CLASS_GUID	L"{4D36E96F-E325-11CE-BFC1-08002BE10318}"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\power.cpp ===
//=================================================================

//

// Power.cpp -- UPS supply property set provider

//

//  Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
// 10/18/95     a-skaja     Prototype for demo
// 10/23/97	    a-hhance	integrated with new framework
//
//============================================================

#include "precomp.h"
#include <cregcls.h>

#include "Power.h"
#include "resource.h"

#define UNKNOWN 0
#define BATTERIES_OK 1
#define BATTERY_NEEDS_REPLACING 2

// Property set declaration
//=========================

PowerSupply MyPowerSet ( PROPSET_NAME_POWERSUPPLY , IDS_CimWin32Namespace  );

/*****************************************************************************
 *
 *  FUNCTION    : PowerSupply::PowerSupply
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

PowerSupply :: PowerSupply (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : PowerSupply::~PowerSupply
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

PowerSupply :: ~PowerSupply ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : PowerSupply::GetObject
 *
 *  DESCRIPTION : Assigns values to properties in our set
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT PowerSupply :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
    HRESULT hRetCode = WBEM_E_FAILED;

	CHString oldKey;
	if ( pInstance->GetCHString ( IDS_DeviceID , oldKey ) )
	{

#ifdef NTONLY

		hRetCode = GetUPSInfoNT ( pInstance ) ;

#endif

		if (SUCCEEDED ( hRetCode ) )
		{
			CHString newKey ;
			pInstance->GetCHString(IDS_DeviceID, newKey);

			if ( newKey.CompareNoCase ( oldKey ) != 0 )
			{
				hRetCode = WBEM_E_NOT_FOUND ;
			}
		}
	}
	else
	{
		hRetCode = WBEM_E_NOT_FOUND ;
	}

    return hRetCode ;
}

/*****************************************************************************
 *
 *  FUNCTION    : PowerSupply::EnumerateInstances
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of power supplies (1 if successful)
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT PowerSupply :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
	HRESULT hRetCode = WBEM_E_FAILED;

	CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;

	pInstance->SetCHString ( IDS_DeviceID , IDS_UPSName ) ;

	hRetCode = GetObject ( pInstance ) ;
	if ( SUCCEEDED ( hRetCode ) )
	{
		hRetCode = pInstance->Commit (  ) ;
	}

    return hRetCode ;
}

/*****************************************************************************
 *
 *  FUNCTION    : PowerSupply::GetUPSInfoNT
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : CInstance* pInstance
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if successful
 *
 *  COMMENTS    : This is specific to NT
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT PowerSupply :: GetUPSInfoNT (CInstance *pInstance)
{
   HRESULT hr = WBEM_E_FAILED;

   // Open the service control manager & query UPS service for
   // 'running' status -- if service isn't running, registry data
   // is stale and possibly unreliable.
   //============================================================

	SmartCloseServiceHandle hSCHandle = OpenSCManager (	NULL ,NULL,	SC_MANAGER_ENUMERATE_SERVICE) ;

	if ( hSCHandle != NULL )
	{
		SmartCloseServiceHandle hUPSHandle = OpenService ( hSCHandle , L"UPS", SERVICE_QUERY_STATUS ) ;
		if ( hUPSHandle != NULL )
		{
			SERVICE_STATUS ServiceInfo ;
			if ( QueryServiceStatus ( hUPSHandle, & ServiceInfo  ) )
			{
				if ( ServiceInfo.dwCurrentState == SERVICE_RUNNING )
				{
					hr =  WBEM_S_NO_ERROR ;
				}
			}
        }
	}

	if ( FAILED ( hr ) )
	{
		return WBEM_E_NOT_FOUND ;
	}

   // Assign hard coded property values
   //=====================================================
 	pInstance->SetCHString ( IDS_SystemName , GetLocalComputerName () ) ;
    pInstance->SetCHString ( IDS_RemainingCapacityStatus,IDS_Unknown)  ;
    pInstance->Setbool     ( IDS_PowerManagementSupported, (bool)FALSE)  ;
	SetCreationClassName   ( pInstance ) ;

	CRegistry RegInfo ;

    //=====================================================
    //  Get stuff out of:
    //  System\\CurrentControlSet\\Services\\UPS
    //=====================================================
	DWORD dwRet = RegInfo.Open (HKEY_LOCAL_MACHINE,	_T("System\\CurrentControlSet\\Services\\UPS"),	KEY_READ) ;
	if ( dwRet == ERROR_SUCCESS )
	{
		CHString sTemp ;
		DWORD dwTemp ;
		if ( RegInfo.GetCurrentKeyValue ( _T("Options") , dwTemp ) == ERROR_SUCCESS )
		{
			pInstance->Setbool ( IDS_PowerFailSignal   ,   (bool)(dwTemp & UPS_POWER_FAIL_SIGNAL))  ;
			pInstance->Setbool ( IDS_LowBatterySignal  ,   (bool)(dwTemp & UPS_LOW_BATTERY_SIGNAL)) ;
			pInstance->Setbool ( IDS_CanTurnOffRemotely,   (bool)(dwTemp & UPS_CAN_TURN_OFF))       ;

			if ( dwTemp & UPS_COMMAND_FILE && RegInfo.GetCurrentKeyValue(_T("CommandFile"), sTemp) == ERROR_SUCCESS)
			{
	            pInstance->SetCHString(IDS_CommandFile, sTemp) ;
			}
		}

		if( RegInfo.GetCurrentKeyValue(_T("DisplayName"), sTemp) == ERROR_SUCCESS)
		{
			pInstance->SetCHString(IDS_Name, sTemp );
		}

		if( RegInfo.GetCurrentKeyValue(_T("Description"), sTemp) == ERROR_SUCCESS)
		{
			pInstance->SetCHString(IDS_Description, sTemp );
			pInstance->SetCHString(IDS_Caption, sTemp );
		}

		if( RegInfo.GetCurrentKeyValue(_T("Port"), sTemp) == ERROR_SUCCESS)
		{
			pInstance->SetCHString(IDS_UPSPort, sTemp );
		}

		if ( RegInfo.GetCurrentKeyValue ( _T("FirstMessageDelay") , dwTemp ) == ERROR_SUCCESS )
		{
			pInstance->SetDWORD ( IDS_FirstMessageDelay , dwTemp ) ;
		}

		if ( RegInfo.GetCurrentKeyValue ( _T("MessageInterval") , dwTemp ) == ERROR_SUCCESS )
		{
			pInstance->SetDWORD ( IDS_MessageInterval , dwTemp ) ;
		}

		RegInfo.Close () ;

        //=====================================================
        //  Get stuff out of:
        //  System\\CurrentControlSet\\Services\\UPS\\Status
        //=====================================================
        dwRet = RegInfo.Open (HKEY_LOCAL_MACHINE,	_T("System\\CurrentControlSet\\Services\\UPS\\Status"),	KEY_READ) ;
	    if ( dwRet == ERROR_SUCCESS )
	    {
//		    if ( RegInfo.GetCurrentKeyValue ( _T("SerialNumber") , sTemp ) == ERROR_SUCCESS )
//		    {
//  			pInstance->SetCHString(IDS_DeviceID, sTemp );
//    	    }
		    if ( RegInfo.GetCurrentKeyValue ( _T("UtilityPowerStatus") , dwTemp ) == ERROR_SUCCESS )
		    {
			    pInstance->SetWBEMINT16( IDS_Availability , (WBEMINT16) dwTemp ) ;
		    }
		    if ( RegInfo.GetCurrentKeyValue ( _T("BatteryStatus") , dwTemp ) == ERROR_SUCCESS )
		    {
                switch( dwTemp )
                {
                    case UNKNOWN:
        			    pInstance->Setbool( IDS_BatteryInstalled, FALSE) ;
           			    pInstance->SetCHString(IDS_Status, IDS_Unknown );
                        break;

                    case BATTERIES_OK:
        			    pInstance->Setbool( IDS_BatteryInstalled, TRUE) ;
           			    pInstance->SetCHString(IDS_Status, IDS_OK );
                        break;

                    case BATTERY_NEEDS_REPLACING:
        			    pInstance->Setbool( IDS_BatteryInstalled, TRUE) ;
           			    pInstance->SetCHString(IDS_Status, IDS_Degraded );
                        break;
                }
		    }
		    if ( RegInfo.GetCurrentKeyValue ( _T("BatteryCapacity") , dwTemp ) == ERROR_SUCCESS )
		    {
			    pInstance->SetWBEMINT16( IDS_EstimatedChargeRemaining , (WBEMINT16) dwTemp ) ;
		    }
		    if ( RegInfo.GetCurrentKeyValue ( _T("EstimatedRunTime") , dwTemp ) == ERROR_SUCCESS )
		    {
			    pInstance->SetDWORD( IDS_EstimatedRunTime, dwTemp ) ;
		    }
            RegInfo.Close();
	    }
    }
	return WBEM_S_NO_ERROR;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\powermanagement.h ===
//=================================================================

//

// PowerManagement.h -- 

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef _WMI_POWER_EVENT_PROVIDER_H
#define _WMI_POWER_EVENT_PROVIDER_H

#include "FactoryRouter.h"
#include "EventProvider.h"
#include "WinMsgEvent.h"
#define POWER_EVENT_CLASS L"Win32_PowerManagementEvent"
//
class CPowerEventFactory :	public CFactoryRouter 
{
	private:
	protected:
	public:

		CPowerEventFactory( REFGUID a_rClsId, LPCWSTR a_pClassName )
			: CFactoryRouter( a_rClsId, a_pClassName ) {} ;

		~CPowerEventFactory() {};

		// implementation of abstract CFactoryRouter
		virtual IUnknown * CreateInstance (

			REFIID a_riid ,
			LPVOID FAR *a_ppvObject
			) ;	
};

//
class CPowerManagementEvent : 
	public CEventProvider, 
	public CWinMsgEvent
{
	private:
		void HandleEvent( DWORD a_dwPowerEvent, DWORD a_dwData ) ;
		BOOL m_bRegistered;
	
	protected:
	public:

		CPowerManagementEvent() : m_bRegistered ( FALSE ) {};
		~CPowerManagementEvent() {};

		// implementation of abstract CWinMsgEvent
		virtual void WinMsgEvent(
			
			IN	HWND a_hWnd,
			IN	UINT a_message,
			IN	WPARAM a_wParam,
			IN	LPARAM	a_lParam,
			OUT E_ReturnAction &a_eRetAction,
			OUT LRESULT &a_lResult
			) ;

		// implementation of abstract CEventProvider
		virtual void ProvideEvents() ;

		// implementation of abstract CEventProvider
        void OnFinalRelease();

		// implementation of class name retrieval for CEventProvider
		virtual BSTR GetClassName() ;
};

#endif // _WMI_POWER_EVENT_PROVIDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\power.h ===
//=================================================================

//

// Power.h -- UPS supply property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//				 10/23/97	 a-hhance		integrated with new framework
//
//=================================================================

// Property set identification
//=============================

#define PROPSET_NAME_POWERSUPPLY L"Win32_UninterruptiblePowerSupply"

// the following are system defined values for UPS options
// they should not be changed
//========================================================

#define UPS_INSTALLED                   0x1
#define UPS_POWER_FAIL_SIGNAL           0x2
#define UPS_LOW_BATTERY_SIGNAL          0x4
#define UPS_CAN_TURN_OFF                0x8
#define UPS_POSITIVE_POWER_FAIL_SIGNAL  0x10
#define UPS_POSITIVE_LOW_BATTERY_SIGNAL 0x20
#define UPS_POSITIVE_SHUT_OFF_SIGNAL    0x40
#define UPS_COMMAND_FILE                0x80


class PowerSupply:public Provider 
{
    public:

        // Constructor/destructor
        //=======================

        PowerSupply(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~PowerSupply() ;

        // Functions provide properties with current values
        //=================================================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);

        // Utility function(s)
        //====================
#ifdef NTONLY
        HRESULT GetUPSInfoNT(CInstance* pInstance);
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\powermanagement.cpp ===
//=================================================================

//

// PowerManagement.cpp -- 

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include "PowerManagement.h"


//=================================================================
//
// CFactoryRouter
//
// provides for registration and instance creation  
//
//
//=================================================================

// Implements a PowerEventProvider
IUnknown * CPowerEventFactory::CreateInstance (

REFIID a_riid ,
LPVOID FAR *a_ppvObject
)
{
	return static_cast<IWbemProviderInit *>(new CPowerManagementEvent) ;
}



//=================================================================
//
// CPowerManagementEvent
//
// provides for eventing of power management events  
//
//
//=================================================================
//

// CWmiProviderInit needs the class name
BSTR CPowerManagementEvent::GetClassName()
{
	return SysAllocString(POWER_EVENT_CLASS);
}


// CWmiEventProvider signals us to begin providing for events
void CPowerManagementEvent::ProvideEvents()
{
	if (!m_bRegistered)
	{
		m_bRegistered = TRUE ;
		CWinMsgEvent::RegisterForMessage( WM_POWERBROADCAST ) ;
	}
}


// CWinMsgEvent signals that a message event has arrived
void CPowerManagementEvent::WinMsgEvent(
			
IN	HWND a_hWnd,
IN	UINT a_message,
IN	WPARAM a_wParam,
IN	LPARAM	a_lParam,
OUT E_ReturnAction &a_eRetAction,
OUT LRESULT &a_lResult
)
{
	switch ( a_message ) 
	{
        case WM_POWERBROADCAST:
		{
			DWORD t_dwPowerEvent = (DWORD) a_wParam ;
			DWORD t_dwData		 = (DWORD) a_lParam ;
				
			switch( t_dwPowerEvent ) 
			{
				case PBT_APMSUSPEND: 
				case PBT_APMRESUMESUSPEND:
				case PBT_APMPOWERSTATUSCHANGE:
				case PBT_APMOEMEVENT:
				case PBT_APMRESUMEAUTOMATIC:			
				{
					HandleEvent( t_dwPowerEvent, t_dwData ) ;
				}	
				break;
				
				case PBT_APMQUERYSUSPEND:
				{
					// indicate we will receive additional messages
					a_eRetAction	= e_ReturnResult ;
					a_lResult		= TRUE ;
					
					break ;
				}

				// default cases			
				case PBT_APMBATTERYLOW:
				case PBT_APMRESUMECRITICAL:
				case PBT_APMQUERYSUSPENDFAILED:
				case PBT_APMQUERYSTANDBYFAILED:
				default:
				{
					break ;
				}
			}
			break ;
		}
	}
}

//
void CPowerManagementEvent::HandleEvent( DWORD a_dwPowerEvent, DWORD a_dwData )
{
	IWbemObjectSinkPtr t_pHandler(CEventProvider::GetHandler(), false);
	IWbemClassObjectPtr t_pClass(CEventProvider::GetClass(), false); 

	if( t_pClass != NULL && t_pHandler != NULL )
	{
    	IWbemClassObjectPtr t_pInst;

		if( SUCCEEDED( t_pClass->SpawnInstance( 0L, &t_pInst ) ) )
		{
			VARIANT t_varEvent ;
			VariantInit( &t_varEvent ) ;

			t_varEvent.vt	= VT_I4 ;
			t_varEvent.lVal = a_dwPowerEvent ;
		
			if ( SUCCEEDED( t_pInst->Put( L"EventType", 0, &t_varEvent, CIM_UINT16 ) ) )
			{
				BOOL t_bCont = TRUE ;

				if ( PBT_APMOEMEVENT == a_dwPowerEvent )
				{
					VARIANT t_varOEMCode ;
					VariantInit( &t_varOEMCode ) ;

					t_varOEMCode.vt	= VT_I4 ;
					t_varOEMCode.lVal = a_dwData ;
				
					if ( !SUCCEEDED( t_pInst->Put( L"OEMEventCode", 0, &t_varEvent, CIM_UINT16 ) ) )
					{
						t_bCont = FALSE ;
					}
					VariantClear ( &t_varOEMCode ) ;
				}

				if ( t_bCont )
				{
                    IWbemClassObject *p2 = t_pInst;
			        t_pHandler->Indicate ( 1, &p2 ) ;
				}
			}
			VariantClear ( &t_varEvent ) ;

		}
	}
}

//
void CPowerManagementEvent::OnFinalRelease()
{
    if (m_bRegistered)
	{
		CWinMsgEvent::UnRegisterMessage( WM_POWERBROADCAST ) ;
	}
	
	delete this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\precomp.h ===
#pragma message("Precompiling header...")
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#define WIN32_NO_STATUS

#include <comdef.h>
#include <helper.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#include <scopeguard.h>
#include <autoptr.h>

#include "fwcommon.h"
#include "brodcast.h"
#include "dllutils.h"
#include "smartptr.h"
#include "strings.h"
#include "ConfgMgr.h"
#define MAXDWORD MAXULONG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\printer.h ===
//////////////////////////////////////////////////////////////////////

//

//  MOPRINT.h  - Enumerate printers

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//
//  09/03/96    jennymc     Updated to meet current standards
//                          Removed custom registry access to use the
//                          standard CRegCls
//  10/17/96    jennymc     Enhanced
//
//////////////////////////////////////////////////////////////////////
// Method Names
#define METHOD_SETDEFAULTPRINTER			L"SetDefaultPrinter"
#define METHOD_GETDEFAULTPRINTER			L"GetDefaultPrinter"
#define METHOD_PAUSEPRINTER					L"Pause"
#define METHOD_RESUME_PRINTER				L"Resume"
#define METHOD_CANCEL_ALLJOBS				L"CancelAllJobs"
#define METHOD_RENAME_PRINTER				L"RenamePrinter"
#define METHOD_TEST_PAGE    				L"PrintTestPage"
#define METHOD_ADD_PRINTER_CONNECTION       L"AddPrinterConnection"

#define	METHOD_RETURN_VALUE					L"ReturnValue"

// Method arguments
#define METHOD_ARG_NAME_SHARENAME			L"ShareName"
#define METHOD_ARG_NAME_SHAREPRINTER		L"SharePrinter"
#define METHOD_ARG_NAME_PRINTER		        L"Name"
#define METHOD_ARG_NAME_NEWPRINTERNAME      L"NewPrinterName"


#define EXTENDEDPRINTERSTATUS				L"ExtendedPrinterStatus"
#define EXTENDEDDETECTEDERRORSTATE			L"ExtendedDetectedErrorState"

 
//==================================
#define	PROPSET_NAME_PRINTER	            L"Win32_Printer"

// Types of information for Printers
// =================================
#define ENUMPRINTERS_WIN95_INFOTYPE 5
#define ENUMPRINTERS_WINNT_INFOTYPE 4
#define GETPRINTER_LEVEL2 (DWORD)2L

class CWin32Printer : public Provider
{
public:

        // Constructor/destructor
        //=======================

    CWin32Printer(LPCWSTR strName, LPCWSTR pszNamespace ) ;
    ~CWin32Printer() ;

        // Functions provide properties with current values
        //=================================================

	virtual HRESULT ExecQuery( MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags = 0L );

	virtual HRESULT GetObject( CInstance* pInstance, long lFlags, CFrameworkQuery& pQuery );

    virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

    virtual HRESULT ExecMethod ( const CInstance& Instance, const BSTR bstrMethodName, CInstance *pInParams, CInstance *pOutParams, long lFlags = 0L ) ;
	
	virtual HRESULT PutInstance  ( const CInstance &Instance,  long lFlags );

	virtual	HRESULT DeleteInstance ( const CInstance &Instance,  long lFlags );


        // Utility function(s)
        //====================

private:

	enum E_CollectionScope { 

		e_CollectAll, 
		e_KeysOnly,
        e_CheapOnly
	} ;
		
	enum PrinterStatuses {

		PSOther =1, 
		PSUnknown, 
		PSIdle, 
		PSPrinting, 
		PSWarmup
	};

	enum ExtendedPrinterStatuses
	{

		EPSOther =1, 
		EPSUnknown, 
		EPSIdle, 
		EPSPrinting, 
		EPSWarmup,
		EPSStoppedPrinting,
		EPSOffline,
		EPSPaused,
		EPSError,
		EPSBusy,
		EPSNotAvailable,
		EPSWaiting,
		EPSProcessing,
		EPSInitialization,
		EPSPowerSave,
		EPSPendingDeletion,
		EPSIOActive,
		EPSManualFeed
	};

    enum DetectedErrorStates {

		DESUnknown, 
		DESOther, 
		DESNoError, 
		DESLowPaper, 
		DESNoPaper, 
		DESLowToner, 
        DESNoToner, 
		DESDoorOpen, 
		DESJammed, 
		DESOffline, 
		DESServiceRequested, 
        DESOutputBinFull
	} ;	

	enum ExtendedDetectedErrorStates {

		EDESUnknown, 
		EDESOther, 
		EDESNoError, 
		EDESLowPaper, 
		EDESNoPaper, 
		EDESLowToner, 
        EDESNoToner, 
		EDESDoorOpen, 
		EDESJammed, 
		EDESServiceRequested, 
        EDESOutputBinFull,
		EDESPaperProblem,
		EDESCanonotPrintPage,
		EDESUserInterventionRequired,
		EDESOutOfMemory,
		EDESServerUnknown
	};

#if NTONLY != 5 

	BOOL GetDefaultPrinter (

		IN LPTSTR pszBuffer,
		IN LPDWORD pcchBuffer
	) ;

#endif

	BOOL GetDefaultPrinter ( CHString &a_Printer ) ;

	HRESULT hCollectInstances ( MethodContext *pMethodContext, E_CollectionScope eCollScope);

	HRESULT	DynInstancePrinters ( MethodContext *pMethodContext, E_CollectionScope eCollScope);

	BOOL GetExpensiveProperties ( LPCTSTR szPrinter, CInstance *pInstance , BOOL a_DefaultPrinter ,E_CollectionScope a_eCollectionScope, PRINTER_INFO_2 *pPrintInfo );

	void SetStati ( CInstance *pInstance, DWORD status, HANDLE hPrinter ) ;

	void GetDeviceCapabilities (

		CInstance *pInstance, 
		LPCTSTR pDevice,    // pointer to a printer-name string																				  
		LPCTSTR pPort,      // pointer to a port-name string
		CONST DEVMODE *pDevMode
	);

	void GetDevModeGoodies ( CInstance *pInstance,CONST DEVMODE *pDevMode);
    WORD MapValue(WORD wPaper);
    void PrinterStatusEx (
		
		HANDLE hPrinter, 
		PrinterStatuses &printerStatus, 
		DetectedErrorStates &detectedErrorState, 
		LPCWSTR &pStatusStr ,
		DWORD &a_Status
	);
    
    HRESULT ExecSetDefaultPrinter ( const CInstance &Instance, CInstance *pInParams, CInstance *pOutParams, long lFlag );
    HRESULT ExecGetDefaultPrinter ( const CInstance &Instance, CInstance *pInParams, CInstance *pOutParams, long lFlag );
	HRESULT ExecSetPrinter ( const CInstance &Instance, CInstance *pInParams, CInstance *pOutParams, long lFlags, DWORD dwState );
	HRESULT ExecRenamePrinter ( const CInstance &Instance, CInstance *pInParams, CInstance *pOutParams );
    HRESULT ExecPrintTestPage ( const CInstance &Instance, CInstance *pInParams, CInstance *pOutParams );
    HRESULT ExecAddPrinterConnection ( const CInstance &Instance, CInstance *pInParams, CInstance *pOutParams );
    
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\printer.cpp ===
//////////////////////////////////////////////////////////////////////

//

//  PRINTER.CPP

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//  09/03/96    jennymc     Updated to meet current standards
//                          Removed custom registry access to use the
//                          standard CRegCls
//  03/01/2000  a-sandja    Added extended detected error codes
//                          Added printer control
//  03/29/2000  amaxa       Added boolean properties
//                          Added PutInstance, DeleteInstance
//                          AddPrinterConnection, RenamePrinter, Test Page
//
//////////////////////////////////////////////////////////////////////

#include <precomp.h>
#include <winspool.h>
#include <lockwrap.h>
#include <DllWrapperBase.h>
#include "printer.h"
#include "prnutil.h"
#include "prninterface.h"

#include <profilestringimpl.h>

//
// For mapping attributes to bools
//
struct PrinterAttributeMap
{
    DWORD   Bit;
    LPCWSTR BoolName;
};

//
// Note that the default bool is missing from the table. That is because
// it is updated in a deifferent way
//
static PrinterAttributeMap AttributeTable[] =
{
    { PRINTER_ATTRIBUTE_QUEUED,            L"Queued"              },
    { PRINTER_ATTRIBUTE_DIRECT,            L"Direct"              },
    { PRINTER_ATTRIBUTE_SHARED,            L"Shared"              },
    { PRINTER_ATTRIBUTE_NETWORK,           L"Network"             },
    { PRINTER_ATTRIBUTE_HIDDEN,            L"Hidden"              },
    { PRINTER_ATTRIBUTE_LOCAL,             L"Local"               },
    { PRINTER_ATTRIBUTE_ENABLE_DEVQ,       L"EnableDevQueryPrint" },
    { PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS,   L"KeepPrintedJobs"     },
    { PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST, L"DoCompleteFirst"     },
    { PRINTER_ATTRIBUTE_WORK_OFFLINE,      L"WorkOffline"         },
    { PRINTER_ATTRIBUTE_ENABLE_BIDI,       L"EnableBIDI"          },
    { PRINTER_ATTRIBUTE_RAW_ONLY,          L"RawOnly"             },
    { PRINTER_ATTRIBUTE_PUBLISHED,         L"Published"           }
};

/*****************************************************************************
 *
 *  FUNCTION    : ConvertCIMTimeToSystemTime
 *
 *  DESCRIPTION : Helper function. Transforms a string that represents a data and time
 *                in CIM format to a systemtime format
 *
 *  RETURNS     : WBEM HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT
ConvertCIMTimeToSystemTime(
    IN     LPCWSTR     pszTime,
    IN OUT SYSTEMTIME *pSysTime
    )
{
    HRESULT hRes = WBEM_E_INVALID_PARAMETER;

    if (pszTime && 
        pSysTime && 
        wcslen(pszTime) >= wcslen(kDateTimeTemplate))
    {
        //
        // Each buffer must hold 2 digits and a NULL
        //
        WCHAR Hour[3]   = {0};
        WCHAR Minute[3] = {0};

        //
        // pszTime is of the form "19990101hhmmss...". The following functions
        // isolate the hour and the time from the string.
        //
        wcsncpy(Hour,   &pszTime[8],  2);
        wcsncpy(Minute, &pszTime[10], 2);

        memset(pSysTime, 0, sizeof(SYSTEMTIME));

        pSysTime->wHour   = static_cast<WORD>(_wtoi(Hour));
        pSysTime->wMinute = static_cast<WORD>(_wtoi(Minute));

        hRes = WBEM_S_NO_ERROR;
    }

    return hRes;
}

//////////////////////////////////////////////////////////////////////

// Property set declaration
//=========================

CWin32Printer win32Printer ( PROPSET_NAME_PRINTER , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Printer::CWin32Printer
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32Printer :: CWin32Printer (

    LPCWSTR strName,
    LPCWSTR pszNamespace

) : Provider ( strName, pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Printer::~CWin32Printer
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32Printer::~CWin32Printer()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Printer::ExecQuery
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32Printer :: ExecQuery (

    MethodContext *pMethodContext,
    CFrameworkQuery& pQuery,
    long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_E_FAILED;

    //
    // If all they want is the name, we'll give it to them, else let them call enum.
    //
    if (pQuery.KeysOnly())
    {
        hr = hCollectInstances(pMethodContext, e_KeysOnly);
    }
    else
    {
        if (pQuery.IsPropertyRequired(IDS_Status) ||
            pQuery.IsPropertyRequired(IDS_PrinterStatus) ||
            pQuery.IsPropertyRequired(IDS_DetectedErrorState) ||
            pQuery.IsPropertyRequired(EXTENDEDPRINTERSTATUS) ||
            pQuery.IsPropertyRequired(EXTENDEDDETECTEDERRORSTATE) ||
            pQuery.IsPropertyRequired(L"PrinterState"))
        {
            hr = WBEM_E_PROVIDER_NOT_CAPABLE ;
        }
        else
        {
            hr = hCollectInstances(pMethodContext, e_CheapOnly);
        }
    }

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Printer::GetObject
 *
 *  DESCRIPTION : Poplulate one WBEM instance for the specific printer
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : op. code
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32Printer :: GetObject (
    CInstance       *pInstance,
    long             lFlags,
    CFrameworkQuery &pQuery)
{
    E_CollectionScope eCollScope;
    HRESULT  hRes            = WBEM_S_NO_ERROR;
    BOOL     bIsLocalCall    = TRUE;
    CHString csPrinter;
    BOOL     bDefault        = FALSE;

    if (pInstance->GetCHString(IDS_DeviceID, csPrinter))
    {
        hRes = WinErrorToWBEMhResult(IsLocalCall(&bIsLocalCall));
    }
    else
    {
        //
        // GetCHString sets the last error to a WBEM HRESULT
        //
        hRes = GetLastError();
    }

    if (SUCCEEDED(hRes)) 
    {
        //
        // Check if the printer is a local printer or a printer connection.
        // We want to disallow the following scenario:
        // User connects remotely to winmgmt on server \\srv
        // User does GetObject on printer \\prnsrv\prn which is not local and
        // the user doesn't have a connection to. Normally this call succeeds,
        // because the spooler goes accros the wire. This means that you can
        // do GetObject on an instance that cannot be returned by EnumInstances.
        // This is inconsistent with WMI.
        //
        BOOL bInstalled;
        
        hRes = WinErrorToWBEMhResult(SplIsPrinterInstalled(csPrinter, &bInstalled));       

        if (SUCCEEDED(hRes) && !bInstalled) 
        {
            //
            // Caller wants to do GetObject on a remote printer
            //
            hRes = WBEM_E_NOT_FOUND;
        }
    }

    if (SUCCEEDED(hRes))
    {
        CHString csDefaultPrinter;

        if (!pQuery.KeysOnly())
        {
            if (pQuery.IsPropertyRequired(IDS_Status) ||
                pQuery.IsPropertyRequired(IDS_PrinterStatus) ||
                pQuery.IsPropertyRequired(IDS_DetectedErrorState) ||
                pQuery.IsPropertyRequired(EXTENDEDPRINTERSTATUS) ||
                pQuery.IsPropertyRequired(EXTENDEDDETECTEDERRORSTATE) ||
                pQuery.IsPropertyRequired(L"PrinterState"))
            {
                eCollScope = e_CollectAll;
            }
            else
            {
                eCollScope = e_CheapOnly;
            }
        }
        else
        {
            eCollScope = e_KeysOnly;
        }

        //
        // The default printer is a per user resource and makes sens only for
        // user logged on the local machine
        //
        if (SUCCEEDED(hRes) && bIsLocalCall)
        {
            DWORD Error;

            if (!GetDefaultPrinter(csDefaultPrinter))
            {
                Error = GetLastError();

                //
                // If there are no printers on a machine or in the case on TS:
                // you delete your default printer, then you have no more default printer
                //
                if (ERROR_FILE_NOT_FOUND == Error)
                {
                    //
                    // We have no default printer, behave like in the case of remote login
                    //
                    bDefault = FALSE;

                    Error  = ERROR_SUCCESS;
                }

                hRes  = WinErrorToWBEMhResult(Error);
            }
            else
            {
                bDefault = !csPrinter.CompareNoCase(csDefaultPrinter);
            }
        }

        //
        // We have the default printer, now get requested properties
        //
        if (SUCCEEDED(hRes))
        {
            SmartClosePrinter  hPrinter;
            BYTE              *pBuffer         = NULL;
            PRINTER_DEFAULTS   PrinterDefaults = {NULL, NULL, PRINTER_READ};
            DWORD              Error;

            //
            // Use of delay loaded functions requires exception handler.
            //
            SetStructuredExceptionHandler seh;
            
            try
            {
                if (::OpenPrinter((LPTSTR)(LPCTSTR)TOBSTRT(csPrinter), (LPHANDLE)&hPrinter, &PrinterDefaults))
                {
                    Error = GetThisPrinter(hPrinter, 2, &pBuffer);

                    if (Error == ERROR_SUCCESS)
                    {
                        PRINTER_INFO_2 *pInfo2 = reinterpret_cast<PRINTER_INFO_2 *>(pBuffer); 
                        
                        if (!bIsLocalCall && pInfo2->Attributes & PRINTER_ATTRIBUTE_NETWORK)
                        {
                            // 
                            // the caller connect from a remote machine to the WMI service on this machine
                            // we do not support getobject on printer connections on a remote machine
                            //
                            hRes = WBEM_E_NOT_FOUND;                                                        
                        }
                        else
                        {                     
                            try
                            {
                                GetExpensiveProperties(TOBSTRT(csPrinter), pInstance, bDefault, eCollScope, pInfo2);
                            }
                            catch(...)
                            {
                                delete [] pBuffer;

                                throw;
                            }

                            hRes = WBEM_S_NO_ERROR;
                        }

                        delete [] pBuffer;
                    }
                    else
                    {
                        hRes = WinErrorToWBEMhResult(Error);
                    }
                }
                else
                {
                    if (FAILED(hRes = WinErrorToWBEMhResult(Error = GetLastError())))
                    {
                        SetErrorObject(*pInstance, Error, pszGetObject);
                    }
                }
            }
            catch(Structured_Exception se)
            {
                DelayLoadDllExceptionFilter(se.GetExtendedInfo());
                hRes = WBEM_E_FAILED;
            }            
        }
    }

    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Printer::EnumerateInstances
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32Printer :: EnumerateInstances (

    MethodContext *pMethodContext,
    long lFlags /*= 0L*/
)
{
    HRESULT hResult = WBEM_E_FAILED ;

    hResult = hCollectInstances(pMethodContext, e_CollectAll);

    return hResult ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Printer::hCollectInstances
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32Printer :: hCollectInstances (

    MethodContext *pMethodContext,
    E_CollectionScope eCollectionScope
)
{
    // Get the proper OS dependent instance

    HRESULT hr = DynInstancePrinters ( pMethodContext, eCollectionScope );

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Printer::DynInstancePrinters
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32Printer :: DynInstancePrinters (

    MethodContext *pMethodContext,
    E_CollectionScope eCollectionScope
)
{
    HRESULT  hRes            = WBEM_S_NO_ERROR;
    BOOL     bIsLocalCall    = FALSE;
    DWORD    cbSize          = 0;
    DWORD    cbNeeded        = 0;
    DWORD    cReturned       = 0;
    DWORD    dwLevel         = 2;
    DWORD    dwFlags         = PRINTER_ENUM_LOCAL;
    DWORD    dwError;
    CHString csDefaultPrinter;
    BYTE    *pBuffer         = NULL;
#if NTONLY >= 5
    dwError = IsLocalCall(&bIsLocalCall);

    hRes    = WinErrorToWBEMhResult(dwError);
#endif
    //
    // The default printer is a per user resource and makes sens only for
    // user logged on the local machine
    //
    if (SUCCEEDED(hRes) && bIsLocalCall)
    {
        dwFlags |= PRINTER_ENUM_CONNECTIONS;
    
        if (!GetDefaultPrinter(csDefaultPrinter))
        {
            dwError = GetLastError();

            //
            // If there are no printers on a machine or in the case on TS:
            // you delete your default printer, then you have no more default printer
            //
            if (ERROR_FILE_NOT_FOUND == dwError)
            {
                //
                // We have no default printer, behave like in the case of remote login
                //
                bIsLocalCall = FALSE;

                dwError      = ERROR_SUCCESS;
            }

            hRes    = WinErrorToWBEMhResult(dwError);
        }
    }

    if (SUCCEEDED(hRes))
    {
        if (!::EnumPrinters(dwFlags,
                                        NULL,
                                        dwLevel,
                                        NULL,
                                        cbSize,
                                        &cbNeeded,
                                        &cReturned))
        {
            dwError = GetLastError();

            if (dwError==ERROR_INSUFFICIENT_BUFFER)
            {
                hRes = WBEM_E_OUT_OF_MEMORY;

                pBuffer = new BYTE [cbSize=cbNeeded];

                if (pBuffer)
                {
                    if (!::EnumPrinters(dwFlags,
                                                    NULL,
                                                    dwLevel,
                                                    pBuffer,
                                                    cbSize,
                                                    &cbNeeded,
                                                    &cReturned))
                    {
                        //
                        // We don't care about the error, if we should fail the second call to EnumPrinters
                        //
                        hRes    = WBEM_E_FAILED;
                    }
                    else
                    {
                        try
                        {
                            //
                            // Create instances of printers
                            //
                            hRes = WBEM_S_NO_ERROR;

                            PRINTER_INFO_2 *pPrnInfo = reinterpret_cast<PRINTER_INFO_2 *>(pBuffer);

                            for (DWORD uIndex = 0; uIndex < cReturned && SUCCEEDED(hRes); uIndex++, pPrnInfo++)
                            {
                                CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

                                pInstance->SetCHString(IDS_DeviceID, pPrnInfo->pPrinterName);

                                if (e_KeysOnly != eCollectionScope)
                                {
                                    BOOL bDefault = bIsLocalCall && !csDefaultPrinter.CompareNoCase(TOBSTRT(pPrnInfo->pPrinterName));

                                    GetExpensiveProperties(pPrnInfo->pPrinterName, pInstance, bDefault, eCollectionScope, pPrnInfo);
                                }

                                hRes = pInstance->Commit();
                            }
                        }
                        catch(...)
                        {
                            delete [] pBuffer;

                            throw;
                        }
                    }

                    delete [] pBuffer;
                }
            }
            else
            {
                hRes = WinErrorToWBEMhResult(dwError);
            }
        }
    }
    
    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Printer::GetExpensiveProperties
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CWin32Printer :: GetExpensiveProperties (

    LPCTSTR            szPrinter,
    CInstance         *pInstance ,
    BOOL               a_Default ,
    E_CollectionScope  a_eCollectionScope,
    PRINTER_INFO_2    *pPrinterInfo
)
{

    if (e_KeysOnly != a_eCollectionScope)
    {
        SetCreationClassName(pInstance);

        pInstance->SetWCHARSplat ( IDS_SystemCreationClassName, L"Win32_ComputerSystem" ) ;

        if ( pPrinterInfo->pPortName && *pPrinterInfo->pPortName )
        {
            pInstance->SetCharSplat( IDS_PortName, pPrinterInfo->pPortName );

        }

        if( pPrinterInfo->pShareName && *pPrinterInfo->pShareName)
        {
            pInstance->SetCharSplat( IDS_ShareName, pPrinterInfo->pShareName );
        }

        if( pPrinterInfo->pServerName && *pPrinterInfo->pServerName)
        {
            pInstance->SetCharSplat( IDS_ServerName, pPrinterInfo->pServerName );
        }

        if( pPrinterInfo->pPrintProcessor && *pPrinterInfo->pPrintProcessor)
        {
            pInstance->SetCharSplat( IDS_PrintProcessor, pPrinterInfo->pPrintProcessor );
        }

        if( pPrinterInfo->pParameters && *pPrinterInfo->pParameters)
        {
            pInstance->SetCharSplat( IDS_Parameters, pPrinterInfo->pParameters );
        }

        if( pPrinterInfo->pDriverName && *pPrinterInfo->pDriverName)
        {
            pInstance->SetCharSplat( IDS_DriverName, pPrinterInfo->pDriverName );
        }

        if( pPrinterInfo->pComment && *pPrinterInfo->pComment)
        {
            pInstance->SetCharSplat( IDS_Comment, pPrinterInfo->pComment );
        }

        if( pPrinterInfo->pLocation && *pPrinterInfo->pLocation)
        {
            pInstance->SetCharSplat( IDS_Location, pPrinterInfo->pLocation );
        }

        if( pPrinterInfo->pSepFile && *pPrinterInfo->pSepFile)
        {
            pInstance->SetCharSplat( IDS_SeparatorFile, pPrinterInfo->pSepFile );
        }

        pInstance->SetDWORD( IDS_JobCountSinceLastReset, pPrinterInfo->cJobs );
        pInstance->SetDWORD( IDS_DefaultPriority, pPrinterInfo->DefaultPriority );
        pInstance->SetDWORD( IDS_Priority, pPrinterInfo->Priority );

        //
        // Special case here
        //
        SYSTEMTIME StartTime = {0};
        SYSTEMTIME UntilTime = {0};
        CHString   csTime;

        PrinterTimeToLocalTime(pPrinterInfo->StartTime, &StartTime);
        PrinterTimeToLocalTime(pPrinterInfo->UntilTime, &UntilTime);

        //
        // If the printer is always available, then we do not set the StartTime
        // and the UntilTime properties
        //
        if (StartTime.wHour!=UntilTime.wHour || StartTime.wMinute!=UntilTime.wMinute)
        {
            csTime.Format(kDateTimeFormat, StartTime.wHour, StartTime.wMinute);

            pInstance->SetCHString(IDS_StartTime, csTime);

            csTime.Format(kDateTimeFormat, UntilTime.wHour, UntilTime.wMinute);

            pInstance->SetCHString(IDS_UntilTime, csTime);
        }

        if( pPrinterInfo->pDatatype && *pPrinterInfo->pDatatype)
        {
            pInstance->SetCharSplat( IDS_PrintJobDataType, pPrinterInfo->pDatatype );
        }

        pInstance->SetDWORD( IDS_AveragePagesPerMinute, pPrinterInfo->AveragePPM );

        pInstance->SetDWORD( IDS_Attributes, pPrinterInfo->Attributes | (a_Default ? PRINTER_ATTRIBUTE_DEFAULT : 0));

        //
        // Update the whole set of booleans
        //
        for (UINT uIndex = 0; uIndex < sizeof(AttributeTable)/sizeof(AttributeTable[0]); uIndex++)
        {
            bool bValue = pPrinterInfo->Attributes & AttributeTable[uIndex].Bit;

            pInstance->Setbool(AttributeTable[uIndex].BoolName, bValue);
        }

        //
        // Update the "Default" boolean
        //
        pInstance->Setbool(kDefaultBoolean, a_Default);

        CHString tmp;
        if( pInstance->GetCHString(IDS_DeviceID, tmp) )
        {
            pInstance->SetCHString(IDS_Caption, tmp );
            pInstance->SetCHString( IDS_Name , tmp ) ;
        }

        // if pservername is null, printer is local
        if (pPrinterInfo->pServerName)
        {
            pInstance->SetCharSplat( IDS_SystemName, pPrinterInfo->pServerName );
        }
        else
        {
            pInstance->SetCHString( IDS_SystemName, GetLocalComputerName() );
        }

        // Spooling
        bool bSpool = !( pPrinterInfo->Attributes & PRINTER_ATTRIBUTE_DIRECT ) ||
                       ( pPrinterInfo->Attributes & PRINTER_ATTRIBUTE_QUEUED );

        pInstance->Setbool(IDS_SpoolEnabled, bSpool);

        GetDeviceCapabilities (

            pInstance,
            szPrinter,
            pPrinterInfo->pPortName,
            pPrinterInfo->pDevMode
            );

        if (e_CheapOnly != a_eCollectionScope)
        {
            SmartClosePrinter hPrinter;

            BOOL t_Status = OpenPrinter (

                (LPTSTR) szPrinter,
                (LPHANDLE) & hPrinter,
                NULL
            ) ;

            if  ( t_Status )
            {
                SetStati (

                    pInstance,
                    pPrinterInfo->Status,
                    hPrinter 
                ) ;
            }
        }
    }

    return TRUE;

}


/*****************************************************************************
 *
 *  FUNCTION    : CWin32Printer::ExecQuery
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

// what's the plural of "status?"
// sets the properties Status, PrinterStatus and DetectedErrorState

void CWin32Printer :: SetStati (

    CInstance *pInstance,
    DWORD a_status,
    HANDLE hPrinter
)
{
    DWORD t_Status = a_status ;

    PrinterStatuses printerStatus = PSIdle;
    DetectedErrorStates detectedErrorState = DESNoError;
    LPCWSTR pStatusStr = IDS_STATUS_OK;
    ExtendedPrinterStatuses eXPrinterStatus = EPSIdle;
    ExtendedDetectedErrorStates eXDetectedErrorState = EDESNoError;

    switch ( t_Status )
    {
        case PRINTER_STATUS_PAUSED:
        {
            printerStatus = PSOther;
            detectedErrorState = DESNoError;
            eXPrinterStatus = EPSPaused;
            eXDetectedErrorState = EDESNoError;
            pStatusStr = IDS_STATUS_OK;
        }
        break;

        case PRINTER_STATUS_PENDING_DELETION:
        {
            printerStatus = PSOther;
            detectedErrorState = DESNoError;
            eXPrinterStatus = EPSPendingDeletion;
            eXDetectedErrorState = EDESNoError;
            pStatusStr = IDS_STATUS_Degraded;
        }
        break;

        case PRINTER_STATUS_BUSY:
        {
            printerStatus = PSPrinting;
            detectedErrorState = DESNoError;
            eXPrinterStatus = EPSBusy;
            eXDetectedErrorState = EDESNoError;
            pStatusStr = IDS_STATUS_OK;
        }
        break;

        case PRINTER_STATUS_DOOR_OPEN:
        {
            printerStatus = PSOther;
            detectedErrorState = DESDoorOpen;
            eXPrinterStatus = EPSOther;
            eXDetectedErrorState = EDESDoorOpen;
            pStatusStr = IDS_STATUS_Error;
        }
        break;

        case PRINTER_STATUS_ERROR:
        {
            printerStatus = PSOther;
            detectedErrorState = DESOther;
            eXPrinterStatus = EPSError;
            eXDetectedErrorState = EDESOther;
            pStatusStr = IDS_STATUS_Error;
        }
        break;

        case PRINTER_STATUS_INITIALIZING:
        {
            printerStatus = PSWarmup;
            detectedErrorState = DESNoError;
            eXPrinterStatus = EPSInitialization;
            eXDetectedErrorState = EDESNoError;
            pStatusStr = IDS_STATUS_OK;
        }
        break;

        case PRINTER_STATUS_IO_ACTIVE:
        {
            printerStatus = PSPrinting;
            detectedErrorState = DESNoError;
            eXPrinterStatus = EPSIOActive;
            eXDetectedErrorState = EDESNoError;
            pStatusStr = IDS_STATUS_OK;
        }
        break;

        case PRINTER_STATUS_MANUAL_FEED:
        {
            printerStatus = PSOther;
            detectedErrorState = DESOther;
            eXPrinterStatus = EPSManualFeed;
            eXDetectedErrorState = EDESOther;
            pStatusStr = IDS_STATUS_Error;
        }
        break;

        case PRINTER_STATUS_NO_TONER:
        {
            printerStatus = PSOther;
            detectedErrorState = DESNoToner;
            eXPrinterStatus = EPSOther;
            eXDetectedErrorState = EDESNoToner;
            pStatusStr = IDS_STATUS_Error;
        }
        break;

        case PRINTER_STATUS_NOT_AVAILABLE:
        {
            printerStatus = PSUnknown;
            detectedErrorState = DESUnknown;
            eXPrinterStatus = EPSNotAvailable;
            eXDetectedErrorState = EDESOther;
            pStatusStr = IDS_STATUS_Unknown;
        }
        break;

        case PRINTER_STATUS_OFFLINE:
        {
            printerStatus = PSOther;
            detectedErrorState = DESOffline;
            eXPrinterStatus = EPSOffline;
            eXDetectedErrorState = EDESOther;
            pStatusStr = IDS_STATUS_Degraded;
        }
        break;

        case PRINTER_STATUS_OUT_OF_MEMORY:
        {
            printerStatus = PSOther;
            detectedErrorState = DESOther;
            eXPrinterStatus = EPSOther;
            eXDetectedErrorState = EDESOutOfMemory;
            pStatusStr = IDS_STATUS_Degraded;
        }
        break;

        case PRINTER_STATUS_OUTPUT_BIN_FULL:
        {
            printerStatus = PSOther;
            detectedErrorState = DESOutputBinFull;
            eXPrinterStatus = EPSOther;
            eXDetectedErrorState = EDESOutputBinFull;
            pStatusStr = IDS_STATUS_Degraded;
        }
        break;

        case PRINTER_STATUS_PAGE_PUNT:
        {
            printerStatus = PSOther;
            detectedErrorState = DESOther;
            eXPrinterStatus = EPSOther;
            eXDetectedErrorState = EDESCanonotPrintPage;
            pStatusStr = IDS_STATUS_Degraded;
        }
        break;

        case PRINTER_STATUS_PAPER_JAM:
        {
            printerStatus = PSOther;
            detectedErrorState = DESJammed;
            eXPrinterStatus = EPSOther;
            eXDetectedErrorState = EDESJammed;
            pStatusStr = IDS_STATUS_Error;
        }
        break;

        case PRINTER_STATUS_PAPER_OUT:
        {
            printerStatus = PSOther;
            detectedErrorState = DESNoPaper;
            eXPrinterStatus = EPSOther;
            eXDetectedErrorState = EDESNoPaper;
            pStatusStr = IDS_STATUS_Error;
        }
        break;

        case PRINTER_STATUS_PAPER_PROBLEM:
        {
            printerStatus = PSOther;
            detectedErrorState = DESOther;
            eXPrinterStatus = EPSOther;
            eXDetectedErrorState = EDESPaperProblem;
            pStatusStr = IDS_STATUS_Error;
        }
        break;

        case PRINTER_STATUS_PRINTING:
        {
            printerStatus = PSPrinting;
            detectedErrorState = DESNoError;
            eXPrinterStatus = EPSPrinting;
            eXDetectedErrorState = EDESNoError;
            pStatusStr = IDS_STATUS_OK;
        }
        break;

        case PRINTER_STATUS_PROCESSING:
        {
            printerStatus = PSPrinting;
            detectedErrorState = DESNoError;
            eXPrinterStatus = EPSProcessing;
            eXDetectedErrorState = EDESNoError;
            pStatusStr = IDS_STATUS_OK;
        }
        break;

        case PRINTER_STATUS_TONER_LOW:
        {
            printerStatus = PSOther;
            detectedErrorState = DESLowToner;
            eXPrinterStatus = EPSOther;
            eXDetectedErrorState = EDESLowToner;
            pStatusStr = IDS_STATUS_Degraded;
        }
        break;

        case PRINTER_STATUS_SERVER_UNKNOWN:
        {
            eXPrinterStatus = EPSOther;
            eXDetectedErrorState = EDESServerUnknown;
        }
        break;

        case PRINTER_STATUS_POWER_SAVE:
        {
            eXPrinterStatus = EPSPowerSave;
            eXDetectedErrorState = EDESOther;
        }
        break;
        
#if 0
        // docs say this is the proper const
        // compiler says it never heard of it...

        case PRINTER_STATUS_UNAVAILABLE:
        {
            err = IDS_PRINTER_STATUS_UNAVAILABLE;
        }
        break;
#endif

        case PRINTER_STATUS_USER_INTERVENTION:
        {
            printerStatus = PSOther;
            detectedErrorState = DESOther;
            eXPrinterStatus = EPSOther;
            eXDetectedErrorState = EDESUserInterventionRequired;
            pStatusStr = IDS_STATUS_Degraded;
        }
        break;

        case PRINTER_STATUS_WAITING:
        {
            printerStatus = PSIdle;
            detectedErrorState = DESNoError;
            eXPrinterStatus = EPSWaiting;
            eXDetectedErrorState = EDESOther;
            pStatusStr = IDS_STATUS_OK;
        }
        break;

        case PRINTER_STATUS_WARMING_UP:
        {
            printerStatus = PSWarmup;
            detectedErrorState = DESNoError;
            eXPrinterStatus = EPSWarmup;
            eXDetectedErrorState = EDESNoError;
            pStatusStr = IDS_STATUS_OK;
        }
        break;
    
        case 0: // o.k.
        {
            printerStatus = PSIdle;
            detectedErrorState = DESNoError;
            eXPrinterStatus = EPSIdle;
            eXDetectedErrorState = EDESNoError;
            pStatusStr = IDS_STATUS_OK;

            // but we better check for the status of an associated print job
            PrinterStatusEx ( hPrinter, printerStatus, detectedErrorState, pStatusStr , t_Status );
        }

        default:
        {
            // dang, got some other unrecognized status value.
            // we'll punt...

            // first, set de faulty values
            printerStatus = PSUnknown;
            detectedErrorState = DESUnknown;
            eXPrinterStatus = EPSUnknown;
            eXDetectedErrorState = EDESUnknown;
            pStatusStr = IDS_STATUS_Unknown;

            // then try to get the info another way.

            PrinterStatusEx ( hPrinter, printerStatus, detectedErrorState, pStatusStr , t_Status );
        }
        break;
    }

    // I know - this makes a ctor fire.  Since we don't have dual interfaces this'll work no matter how we're compiled.

    pInstance->SetCHString ( IDS_Status , pStatusStr ) ;
    pInstance->SetWBEMINT16 ( IDS_PrinterStatus , printerStatus ) ;
    pInstance->SetWBEMINT16 ( IDS_DetectedErrorState , detectedErrorState ) ;
    pInstance->SetWBEMINT16 ( EXTENDEDPRINTERSTATUS, eXPrinterStatus );
    pInstance->SetWBEMINT16 ( EXTENDEDDETECTEDERRORSTATE, eXDetectedErrorState );

    pInstance->SetDWORD ( L"PrinterState" , t_Status ) ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Printer::ExecQuery
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

// second try to get some status.
// we'll use EnumJobs to try to get a little more info.

void CWin32Printer :: PrinterStatusEx (

    HANDLE hPrinter,
    PrinterStatuses &printerStatus,
    DetectedErrorStates &detectedErrorState,
    LPCWSTR &pStatusStr ,
    DWORD &a_Status
)
{
    DWORD dwSpaceNeeded = 0 ;
    DWORD dwReturneddwJobs = 0 ;

    // ASSUMPTION! we only have to pull one job off of the stack to see if it's okay...
    
    // Use of delay loaded functions requires exception handler.
    SetStructuredExceptionHandler seh;

    try
    {
        ::EnumJobs (

            hPrinter,
            0,
            1,
            1,
            NULL,
            0,
            &dwSpaceNeeded,
            &dwReturneddwJobs
        ) ;

        if ( GetLastError () == ERROR_INSUFFICIENT_BUFFER )
        {
            LPBYTE lpBuffer = new BYTE [ dwSpaceNeeded + 2 ] ;

            if ( lpBuffer )
            {
                try
                {
                    JOB_INFO_1 *pJobInfo = (JOB_INFO_1*)lpBuffer;

                    BOOL t_EnumStatus = EnumJobs (

                        hPrinter,
                        0,
                        1,
                        1,
                        lpBuffer,
                        dwSpaceNeeded,
                        &dwSpaceNeeded,
                        &dwReturneddwJobs
                    ) ;

                    if ( t_EnumStatus )
                    {
                        if ( dwReturneddwJobs )
                        {
                            
                            // map the Job to the printer state
                            if( JOB_STATUS_PAUSED & pJobInfo->Status )
                            {
                                a_Status |= PRINTER_STATUS_PAUSED ;
                            }

                            if( JOB_STATUS_ERROR & pJobInfo->Status )
                            {
                                a_Status |= PRINTER_STATUS_ERROR ;
                            }

                            if( JOB_STATUS_DELETING & pJobInfo->Status )
                            {
                                a_Status |= PRINTER_STATUS_PENDING_DELETION ;
                            }

                            if( JOB_STATUS_SPOOLING & pJobInfo->Status )
                            {
                                a_Status |= PRINTER_STATUS_PROCESSING ;
                            }

                            if( JOB_STATUS_PRINTING & pJobInfo->Status )
                            {
                                a_Status |= PRINTER_STATUS_PRINTING ;
                            }

                            if( JOB_STATUS_OFFLINE & pJobInfo->Status )
                            {
                                a_Status |= PRINTER_STATUS_OFFLINE ;
                            }

                            if( JOB_STATUS_PAPEROUT & pJobInfo->Status )
                            {
                                a_Status |= PRINTER_STATUS_PAPER_OUT ;
                            }

                            if( JOB_STATUS_PRINTED & pJobInfo->Status )
                            {
                                a_Status |= PRINTER_STATUS_PRINTING ;
                            }
                            
                            if( JOB_STATUS_DELETED & pJobInfo->Status )
                            {
                                a_Status |= PRINTER_STATUS_PENDING_DELETION ;
                            }

                            if( JOB_STATUS_USER_INTERVENTION & pJobInfo->Status )
                            {
                                a_Status |= PRINTER_STATUS_USER_INTERVENTION ;
                            }

                            // ain't a gonna parse a string
                            // if we got a string status, we'll accept the defaults

                            if ( pJobInfo->pStatus == NULL )
                            {
                                // status
                                if( (   JOB_STATUS_ERROR    | JOB_STATUS_OFFLINE |
                                        JOB_STATUS_DELETING | JOB_STATUS_PAPEROUT |
                                        JOB_STATUS_PAUSED   | JOB_STATUS_PRINTED ) & pJobInfo->Status )
                                {
                                    printerStatus = PSOther ;
                                }
                                else if( ( JOB_STATUS_PRINTING | JOB_STATUS_SPOOLING ) & pJobInfo->Status )
                                {
                                    printerStatus = PSPrinting ;    
                                }
                                else
                                {
                                    // passed default
                                }
                                
                                // error state
                                if( JOB_STATUS_PAPEROUT & pJobInfo->Status )
                                {
                                    detectedErrorState = DESNoPaper ;
                                }
                                else if( JOB_STATUS_OFFLINE & pJobInfo->Status )
                                {
                                    detectedErrorState = DESOffline ;
                                }
                                else if( JOB_STATUS_ERROR & pJobInfo->Status )
                                {
                                    detectedErrorState = DESUnknown ;
                                }
                                else if( (  JOB_STATUS_DELETING | JOB_STATUS_PAUSED |
                                            JOB_STATUS_PRINTED  | JOB_STATUS_PRINTING |
                                            JOB_STATUS_SPOOLING ) & pJobInfo->Status )
                                {
                                    detectedErrorState = DESNoError ;
                                }
                                else
                                {
                                    // passed default
                                }
                                
                                // status string
                                if( ( JOB_STATUS_ERROR | JOB_STATUS_PAPEROUT ) & pJobInfo->Status )
                                {
                                    pStatusStr = IDS_STATUS_Error;
                                }
                                else if( JOB_STATUS_OFFLINE & pJobInfo->Status )
                                {
                                    pStatusStr = IDS_STATUS_Degraded;
                                }
                                else if( JOB_STATUS_DELETING & pJobInfo->Status )
                                {
                                    pStatusStr = IDS_STATUS_Degraded;
                                }
                                else if( (  JOB_STATUS_PAUSED  | JOB_STATUS_PRINTING |
                                            JOB_STATUS_PRINTED | JOB_STATUS_SPOOLING ) & pJobInfo->Status )
                                {
                                    pStatusStr = IDS_STATUS_OK;
                                }
                                else
                                {
                                    // passed default
                                }
                            }
                        }
                        else
                        {

                        // there was a job a second ago, but not now.  Sounds good to me

                            printerStatus = PSIdle;
                            detectedErrorState = DESUnknown;
                            pStatusStr = IDS_STATUS_Unknown;
                        }
                    }
                }
                catch ( ... )
                {
                    delete [] lpBuffer ;

                    throw ;
                }

                delete [] lpBuffer ;

            }
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
        }
        else
        {
            if ( ( GetLastError () == 0 ) && ( dwSpaceNeeded == 0 ) )
            {
                // no error & no jobs - he's (probably) idle, but we can't be sure about errors

                printerStatus = PSIdle;
                detectedErrorState = DESUnknown;
                pStatusStr = IDS_STATUS_Unknown;
            }
        }
    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo());
    }
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Printer::GetDeviceCapabilities
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

// get the device caps
// set Horz & vert resolutions

void CWin32Printer :: GetDeviceCapabilities (

    CInstance *pInstance ,
    LPCTSTR pDevice,    // pointer to a printer-name string                                                                             
    LPCTSTR pPort,      // pointer to a port-name string
    CONST DEVMODE *pDevMode
)
{
#ifdef NTONLY
    // there seems to be a severe error in DeviceCapabilities(DC_PAPERNAMES) for Win98
    // it *intermittently* GPFs when handed perfectly valid arguments, then it tries to
    // convince me that there are 6,144 different papernames available when it does run
    // I DON'T THINK SO! skip over the offensive code & get on with our lives...
    // I note that 6144 is evenly divisible by 64, perhaps that's indiciative of the problem?


    // determine list of available paper
    // call with NULL to find out how many we have

    // Use of delay loaded functions requires exception handler.
    SetStructuredExceptionHandler seh;

    try
    {
        DWORD dwNames = ::DeviceCapabilities (

            pDevice ,
            pPort,
            DC_PAPERNAMES,
            NULL,
            pDevMode
        ) ;

        if ( ( 0 != dwNames ) && ( -1 != dwNames ) )
        {
            TCHAR *pNames = new TCHAR [ ( dwNames + 2 ) * 64 ] ;
            if ( pNames )
            {
                try
                {
                    memset ( pNames, '\0', ( dwNames + 2 ) * 64 * sizeof(TCHAR)) ;

                    dwNames = ::DeviceCapabilities (

                        pDevice ,
                        pPort ,
                        DC_PAPERNAMES ,
                        pNames ,
                        pDevMode
                    ) ;

                    if ( ( 0 != dwNames ) && ( -1 != dwNames )  )
                    {
                        SAFEARRAYBOUND rgsabound[1];
                        rgsabound[0].cElements = dwNames;
                        rgsabound[0].lLbound = 0;

                        variant_t vValue;

                        V_ARRAY(&vValue) = SafeArrayCreate ( VT_BSTR , 1 , rgsabound ) ;
                        if ( V_ARRAY(&vValue) )
                        {
                            V_VT(&vValue) = VT_ARRAY | VT_BSTR;
                            long ix[1];

                            for ( int i = 0 ; i < dwNames; i++ )
                            {
                                TCHAR *pName = pNames + i * 64 ;

                                bstr_t bstrTemp = (pName);
                                ix[0] = i ;

                                HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , (wchar_t*)bstrTemp ) ;
                                if ( t_Result == E_OUTOFMEMORY )
                                {
                                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                                }
                            }

                            pInstance->SetVariant ( L"PrinterPaperNames", vValue ) ;
                        }
                        else
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }
                    }
                }
                catch(Structured_Exception se)
                {
                    DelayLoadDllExceptionFilter(se.GetExtendedInfo());
                }
                catch ( ... )
                {
                    delete [] pNames ;
                    throw;
                }

                delete [] pNames ;
            }
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
        }

        // call with NULL to find out how many we have

        DWORD dwPapers = ::DeviceCapabilities (

            pDevice,
            pPort,
            DC_PAPERS,
            NULL,
            pDevMode
        ) ;

        if ( ( 0 != dwPapers ) && ( -1 != dwPapers ) )
        {
            WORD *pPapers = new WORD [ dwPapers ] ;
            if ( pPapers )
            {
                try
                {
                    memset ( pPapers, '\0', dwPapers * sizeof ( WORD ) ) ;

                    dwPapers = ::DeviceCapabilities (

                        pDevice ,
                        pPort ,
                        DC_PAPERS ,
                        ( LPTSTR ) pPapers ,
                        pDevMode
                    ) ;

                    if ( ( 0 != dwPapers ) && ( -1 != dwPapers ) )
                    {
                        SAFEARRAYBOUND rgsabound [ 1 ] ;
                        rgsabound[0].cElements = dwPapers ;
                        rgsabound[0].lLbound = 0 ;

                        variant_t vValue;

                        V_ARRAY(&vValue) = SafeArrayCreate ( VT_I2 , 1 , rgsabound ) ;
                        if ( V_ARRAY(&vValue) )
                        {
                            V_VT(&vValue) = VT_ARRAY | VT_I2;
                            long ix[1];

                            for ( int i = 0; i < dwPapers ; i++ )
                            {
                                WORD wVal = MapValue ( pPapers [ i ] ) ;
                                ix[0] = i ;

                                HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , & wVal ) ;
                                if ( t_Result == E_OUTOFMEMORY )
                                {
                                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                                }
                            }

                            pInstance->SetVariant ( L"PaperSizesSupported" , vValue ) ;
                        }
                        else
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }
                    }
                }
                catch(Structured_Exception se)
                {
                    DelayLoadDllExceptionFilter(se.GetExtendedInfo());
                }
                catch ( ... )
                {
                    delete [] pPapers ;

                    throw ;
                }

                delete [] pPapers ;
            }
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
        }
    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo());
    }

#endif

    GetDevModeGoodies ( pInstance , pDevMode ) ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Printer::ExecQuery
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void CWin32Printer :: GetDevModeGoodies (

    CInstance *pInstance,
    CONST DEVMODE *pDevMode
)
{
    if ( pDevMode )
    {
        //Get the resolution - it can be in the form of "X x Y" or just "X dpi".
        if ( pDevMode->dmFields & DM_YRESOLUTION )
        {
            pInstance->SetDWORD ( IDS_VerticalResolution , pDevMode->dmYResolution ) ;
            pInstance->SetDWORD ( IDS_HorizontalResolution , pDevMode->dmPrintQuality ) ;
        }
        else if ( pDevMode->dmFields & DM_PRINTQUALITY )
        {
            pInstance->SetDWORD ( IDS_VerticalResolution , pDevMode->dmPrintQuality ) ;
            pInstance->SetDWORD ( IDS_HorizontalResolution , pDevMode->dmPrintQuality ) ;
        }

        // safearry for strings

        SAFEARRAYBOUND rgsabound[1];
        rgsabound[0].cElements = 0;
        rgsabound[0].lLbound = 0;

        variant_t vValueI2, vValueBstr;
        V_VT(&vValueI2) = VT_ARRAY | VT_I2;
        V_VT(&vValueBstr) = VT_ARRAY | VT_BSTR ;

        V_ARRAY(&vValueI2) = SafeArrayCreate ( VT_I2 , 1, rgsabound ) ;
        V_ARRAY(&vValueBstr) = SafeArrayCreate ( VT_BSTR, 1, rgsabound ) ;

        if ( V_ARRAY(&vValueI2) && V_ARRAY(&vValueBstr) )
        {
            long ix[1];

            ix[0] =0;
            int count = 0;

            if (pDevMode->dmFields & DM_COPIES)
            {
                ix[0] = count ++ ;
                rgsabound[0].cElements = count;

                HRESULT t_Result = SafeArrayRedim ( V_ARRAY(&vValueI2) ,rgsabound ) ;
                if ( t_Result == E_OUTOFMEMORY )
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }

                t_Result = SafeArrayRedim ( V_ARRAY(&vValueBstr) ,rgsabound ) ;
                if ( t_Result == E_OUTOFMEMORY )
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }

                DWORD dwVal = 4;
                t_Result = SafeArrayPutElement ( V_ARRAY(&vValueI2) , ix , & dwVal ) ;
                if ( t_Result == E_OUTOFMEMORY )
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }

                bstr_t bstrTemp (IDS_Copies);
                t_Result = SafeArrayPutElement ( V_ARRAY(&vValueBstr) , ix , (wchar_t*)bstrTemp ) ;
                if ( t_Result == E_OUTOFMEMORY )
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }   
            
            if (pDevMode->dmFields & DM_COLOR)
            {
                ix[0] = count++;
                rgsabound[0].cElements = count;

                HRESULT t_Result = SafeArrayRedim ( V_ARRAY(&vValueI2) ,rgsabound ) ;
                if ( t_Result == E_OUTOFMEMORY )
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }

                t_Result = SafeArrayRedim ( V_ARRAY(&vValueBstr) ,rgsabound ) ;
                if ( t_Result == E_OUTOFMEMORY )
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }

                DWORD dwVal = 2;
                t_Result = SafeArrayPutElement ( V_ARRAY(&vValueI2) , ix , & dwVal ) ;
                if ( t_Result == E_OUTOFMEMORY )
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }

                bstr_t bstrTemp (IDS_Color);
                t_Result = SafeArrayPutElement ( V_ARRAY(&vValueBstr) , ix , (wchar_t*)bstrTemp ) ;
                if ( t_Result == E_OUTOFMEMORY )
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }   
            
            if (pDevMode->dmFields & DM_DUPLEX)
            {
                ix[0] = count++;
                rgsabound[0].cElements = count;

                HRESULT t_Result = SafeArrayRedim ( V_ARRAY(&vValueI2) ,rgsabound ) ;
                if ( t_Result == E_OUTOFMEMORY )
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }

                t_Result = SafeArrayRedim ( V_ARRAY(&vValueBstr) ,rgsabound ) ;
                if ( t_Result == E_OUTOFMEMORY )
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }

                DWORD dwVal = 3;
                t_Result = SafeArrayPutElement ( V_ARRAY(&vValueI2) , ix , & dwVal ) ;
                if ( t_Result == E_OUTOFMEMORY )
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }

                bstr_t bstrTemp (IDS_Duplex);
                t_Result = SafeArrayPutElement ( V_ARRAY(&vValueBstr) , ix , (wchar_t*)bstrTemp ) ;
                if ( t_Result == E_OUTOFMEMORY )
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }   
            
            if (pDevMode->dmFields & DM_COLLATE)
            {
                ix[0] = count++;
                rgsabound[0].cElements = count;

                HRESULT t_Result = SafeArrayRedim ( V_ARRAY(&vValueI2) ,rgsabound ) ;
                if ( t_Result == E_OUTOFMEMORY )
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }

                t_Result = SafeArrayRedim ( V_ARRAY(&vValueBstr) ,rgsabound ) ;
                if ( t_Result == E_OUTOFMEMORY )
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }


                DWORD dwVal = 5;
                t_Result = SafeArrayPutElement ( V_ARRAY(&vValueI2) , ix , & dwVal ) ;
                if ( t_Result == E_OUTOFMEMORY )
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }

                bstr_t bstrTemp (IDS_Collate);
                t_Result = SafeArrayPutElement ( V_ARRAY(&vValueBstr) , ix , (wchar_t*)bstrTemp ) ;
                if ( t_Result == E_OUTOFMEMORY )
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }   
            
            pInstance->SetVariant ( IDS_Capabilities , vValueI2 ) ;

            // Now for the strings

            pInstance->SetVariant(L"CapabilityDescriptions", vValueBstr) ;
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Printer::ExecQuery
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

WORD CWin32Printer :: MapValue ( WORD wPaper )
{
    WORD wRetPaper;

    switch ( wPaper )
    {
        case DMPAPER_LETTER:               /* Letter 8 1/2 x 11 in               */
        {
            wRetPaper = 7;
        }
        break;

        case DMPAPER_LETTERSMALL:          /* Letter Small 8 1/2 x 11 in         */
        {
            wRetPaper = 7;
        }
        break;

        case DMPAPER_TABLOID:              /* Tabloid 11 x 17 in                 */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_LEDGER:               /* Ledger 17 x 11 in                  */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_LEGAL:                /* Legal 8 1/2 x 14 in                */
        {
            wRetPaper = 8;
        }
        break;

        case DMPAPER_STATEMENT:            /* Statement 5 1/2 x 8 1/2 in         */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_EXECUTIVE:            /* Executive 7 1/4 x 10 1/2 in        */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_A3:                   /* A3 297 x 420 mm                    */
        {
            wRetPaper = 21;
        }
        break;

        case DMPAPER_A4:                   /* A4 210 x 297 mm                    */
        {
            wRetPaper = 22;
        }
        break;

        case DMPAPER_A4SMALL:              /* A4 Small 210 x 297 mm              */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_A5:                   /* A5 148 x 210 mm                    */
        {
            wRetPaper = 23;
        }
        break;

        case DMPAPER_B4:                   /* B4 (JIS) 250 x 354                 */
        {
            wRetPaper = 54;
        }
        break;

        case DMPAPER_B5:                   /* B5 (JIS) 182 x 257 mm              */
        {
            wRetPaper = 55;
        }
        break;

        case DMPAPER_FOLIO:                /* Folio 8 1/2 x 13 in                */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_QUARTO:               /* Quarto 215 x 275 mm                */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_10X14:                /* 10x14 in                           */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_11X17:                /* 11x17 in                           */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_NOTE:                 /* Note 8 1/2 x 11 in                 */
        {
            wRetPaper = 7;
        }
        break;

        case DMPAPER_ENV_9:                /* Envelope #9 3 7/8 x 8 7/8          */
        {
            wRetPaper = 15;
        }
        break;

        case DMPAPER_ENV_10:               /* Envelope #10 4 1/8 x 9 1/2         */
        {
            wRetPaper = 11;
        }
        break;

        case DMPAPER_ENV_11:               /* Envelope #11 4 1/2 x 10 3/8        */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_ENV_12:               /* Envelope #12 4 \276 x 11           */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_ENV_14:               /* Envelope #14 5 x 11 1/2            */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_CSHEET:               /* C size sheet                       */
        {
            wRetPaper = 4;
        }
        break;

        case DMPAPER_DSHEET:               /* D size sheet                       */
        {
            wRetPaper = 5;
        }
        break;

        case DMPAPER_ESHEET:               /* E size sheet                       */
        {
            wRetPaper = 6;
        }
        break;

        case DMPAPER_ENV_DL:               /* Envelope DL 110 x 220mm            */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_ENV_C5:               /* Envelope C5 162 x 229 mm           */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_ENV_C3:               /* Envelope C3  324 x 458 mm          */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_ENV_C4:               /* Envelope C4  229 x 324 mm          */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_ENV_C6:               /* Envelope C6  114 x 162 mm          */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_ENV_C65:              /* Envelope C65 114 x 229 mm          */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_ENV_B4:               /* Envelope B4  250 x 353 mm          */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_ENV_B5:               /* Envelope B5  176 x 250 mm          */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_ENV_B6:               /* Envelope B6  176 x 125 mm          */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_ENV_ITALY:            /* Envelope 110 x 230 mm              */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_ENV_MONARCH:          /* Envelope Monarch 3.875 x 7.5 in    */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_ENV_PERSONAL:         /* 6 3/4 Envelope 3 5/8 x 6 1/2 in    */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_FANFOLD_US:           /* US Std Fanfold 14 7/8 x 11 in      */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_FANFOLD_STD_GERMAN:   /* German Std Fanfold 8 1/2 x 12 in   */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_FANFOLD_LGL_GERMAN:   /* German Legal Fanfold 8 1/2 x 13 in */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_ISO_B4:               /* B4 (ISO) 250 x 353 mm              */
        {
            wRetPaper = 49;
        }
        break;

        case DMPAPER_JAPANESE_POSTCARD:    /* Japanese Postcard 100 x 148 mm     */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_9X11:                 /* 9 x 11 in                          */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_10X11:                /* 10 x 11 in                         */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_15X11:                /* 15 x 11 in                         */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_ENV_INVITE:           /* Envelope Invite 220 x 220 mm       */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_RESERVED_48:          /* RESERVED--DO NOT USE               */
        {
            wRetPaper = 0;
        }
        break;

        case DMPAPER_RESERVED_49:          /* RESERVED--DO NOT USE               */
        {
            wRetPaper = 0;
        }
        break;

        case DMPAPER_LETTER_EXTRA:         /* Letter Extra 9 \275 x 12 in        */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_LEGAL_EXTRA:          /* Legal Extra 9 \275 x 15 in         */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_TABLOID_EXTRA:        /* Tabloid Extra 11.69 x 18 in        */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_A4_EXTRA:             /* A4 Extra 9.27 x 12.69 in           */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_LETTER_TRANSVERSE:    /* Letter Transverse 8 \275 x 11 in   */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_A4_TRANSVERSE:        /* A4 Transverse 210 x 297 mm         */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_LETTER_EXTRA_TRANSVERSE: /* Letter Extra Transverse 9\275 x 12 in */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_A_PLUS:               /* SuperA/SuperA/A4 227 x 356 mm      */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_B_PLUS:               /* SuperB/SuperB/A3 305 x 487 mm      */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_LETTER_PLUS:          /* Letter Plus 8.5 x 12.69 in         */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_A4_PLUS:              /* A4 Plus 210 x 330 mm               */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_A5_TRANSVERSE:        /* A5 Transverse 148 x 210 mm         */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_B5_TRANSVERSE:        /* B5 (JIS) Transverse 182 x 257 mm   */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_A3_EXTRA:             /* A3 Extra 322 x 445 mm              */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_A5_EXTRA:             /* A5 Extra 174 x 235 mm              */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_B5_EXTRA:             /* B5 (ISO) Extra 201 x 276 mm        */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_A2:                   /* A2 420 x 594 mm                    */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_A3_TRANSVERSE:        /* A3 Transverse 297 x 420 mm         */
        {
            wRetPaper = 1;
        }
        break;

        case DMPAPER_A3_EXTRA_TRANSVERSE:  /* A3 Extra Transverse 322 x 445 mm   */
        {
            wRetPaper = 1;
        }
        break;

        default:
        {
            wRetPaper = 1;
        }
        break;
    }

    return wRetPaper ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Printer::ExecQuery
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CWin32Printer :: GetDefaultPrinter ( CHString &a_Printer )
{

#if NTONLY >= 5

    DWORD cchBufferLength = 0;
    BOOL  bStatus         = ::GetDefaultPrinter(NULL, &cchBufferLength);

    if (!bStatus && GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    {
        CSmartBuffer Buffer(cchBufferLength * sizeof(TCHAR));

        bStatus = ::GetDefaultPrinter(reinterpret_cast<LPTSTR>(static_cast<LPBYTE>(Buffer)), 
                                      &cchBufferLength);

        if (bStatus) 
        {
            //
            // The cast is very important, otherwise a_Printer will be updated only
            // with the first tchar in the buffer. The CSmartBuffer class has a set of 
            // overloaded operator= methods. Without the cast, the compiler will think
            // we are assigning a TCHAR instead of a LPTSTR
            //
            a_Printer = reinterpret_cast<LPCTSTR>(static_cast<LPBYTE>(Buffer));
        }
    }

#else

    BOOL bStatus = FALSE;
    SetLastError(ERROR_FILE_NOT_FOUND);

#endif
    
    return bStatus ;
}

//
// The buffer size needed to hold the maximum printer name.
//

#if NTONLY != 5

#define MAX_UNC_PRINTER_NAME 200

enum { kPrinterBufMax_  = MAX_UNC_PRINTER_NAME + 1 };

#define COUNTOF(x) (sizeof x/sizeof *x)
#define EQ(x) = x

LPCTSTR szNULL                  EQ( TEXT( "" ));
LPCTSTR szWindows               EQ( TEXT( "Windows" ));
LPCTSTR szDevice                EQ( TEXT( "Device" ));

/*++

Name:

    GetDefaultPrinter

Description:

    The GetDefaultPrinter function retrieves the printer
    name of the current default printer.

Arguments:

    pBuffer     - Points to a buffer to receive the null-terminated
                  character string containing the default printer name.
                  This parameter may be null if the caller want the size of
                  default printer name.

    pcchBuffer   - Points to a variable that specifies the maximum size,
                  in characters, of the buffer. This value should be
                  large enough to contain 2 + INTERNET_MAX_HOST_NAME_LENGTH
                  + 1 MAX_PATH + 1 characters.

Return Value:

    If the function succeeds, the return value is nonzero and
    the variable pointed to by the pnSize parameter contains the
    number of characters copied to the destination buffer,
    including the terminating null character.

    If the function fails, the return value is zero. To get extended
    error information, call GetLastError.

Notes:

    If this function fails with a last error of ERROR_INSUFFICIENT_BUFFER
    the variable pointed to by pcchBuffer is returned with the number of
    characters needed to hold the printer name including the
    terminating null character.

--*/
BOOL
CWin32Printer::GetDefaultPrinter(
    IN LPTSTR   pszBuffer,
    IN LPDWORD  pcchBuffer
    )
{
    BOOL    bRetval = FALSE;
    LPTSTR  psz     = NULL;
    UINT    uLen    = 0;
    TCHAR   szDefault[kPrinterBufMax_+MAX_PATH];

    //
    // Validate the size parameter.
    //
    if( !pcchBuffer )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return bRetval;
    }

    //
    // Get the devices key, which is the default device or printer.
    //

    bool fGotProfileString = false;

    try
    {
        fGotProfileString = WMIRegistry_ProfileString(szWindows, szDevice, szNULL, szDefault, COUNTOF(szDefault));
    }
    catch(...)
    {
        throw;
    }
    
    if(fGotProfileString)
    {
        //
        // The string is returned in the form.
        // "printer_name,winspool,Ne00:" now convert it to
        // printer_name
        //
        psz = _tcschr( szDefault, TEXT( ',' ));

        //
        // Set the comma to a null.
        //
        if( psz )
        {
            *psz = 0;

            //
            // Check if the return buffer has enough room for the printer name.
            //
            uLen = _tcslen( szDefault );

            if( uLen < *pcchBuffer && pszBuffer )
            {
                //
                // Copy the default printer name to the prvided buffer.
                //
                _tcscpy( pszBuffer, szDefault );

                bRetval = TRUE;

#if 0
                DBGMSG( DBG_TRACE,( "GetDefaultPrinter: Success " TSTR "\n", pszBuffer ) );
#endif
            }
            else
            {
#if 0
                DBGMSG( DBG_WARN,( "GetDefaultPrinter: buffer too small.\n" ) );
#endif
                SetLastError( ERROR_INSUFFICIENT_BUFFER );
            }

            //
            // Return back the size of the default printer name.
            //
            *pcchBuffer = uLen + 1;
        }
        else
        {
#if 0
            DBGMSG( DBG_WARN,( "GetDefaultPrinter: comma not found in printer name in devices section.\n" ) );
#endif
            SetLastError( ERROR_INVALID_NAME );
        }
    }
    else
    {
#if 0
        DBGMSG( DBG_TRACE,( "GetDefaultPrinter: failed with %d Last error %d.\n", bRetval, GetLastError() ) );
        DBGMSG( DBG_TRACE,( "GetDefaultPrinter: No default printer.\n" ) );
#endif

        SetLastError( ERROR_FILE_NOT_FOUND );
    }

    return bRetval;
}

#endif


/*****************************************************************************
*
*  FUNCTION    :    CWin32Printer::ExecMethod
*
*  DESCRIPTION :    Implementing the Printer Methods for the provider out here
*
*****************************************************************************/

HRESULT CWin32Printer :: ExecMethod (

    const CInstance &Instance,
    const BSTR bstrMethodName,
    CInstance *pInParams,
    CInstance *pOutParams,
    long lFlags
)
{
#if NTONLY >= 5

    HRESULT hRes = WBEM_E_INVALID_PARAMETER;

    if (pOutParams)
    {
        if (!_wcsicmp(bstrMethodName, METHOD_SETDEFAULTPRINTER))
        {
            hRes = ExecSetDefaultPrinter(Instance, pInParams, pOutParams, lFlags);
        }
        else if (!_wcsicmp(bstrMethodName , METHOD_PAUSEPRINTER))
        {
            hRes = ExecSetPrinter(Instance, pInParams, pOutParams, lFlags, PRINTER_CONTROL_PAUSE);
        }
        else if (!_wcsicmp(bstrMethodName , METHOD_RESUME_PRINTER))
        {
            hRes = ExecSetPrinter(Instance, pInParams, pOutParams, lFlags, PRINTER_CONTROL_RESUME);
        }
        else if (!_wcsicmp(bstrMethodName, METHOD_CANCEL_ALLJOBS))
        {
            hRes = ExecSetPrinter(Instance, pInParams, pOutParams, lFlags, PRINTER_CONTROL_PURGE);
        }
        else if (!_wcsicmp(bstrMethodName, METHOD_RENAME_PRINTER))
        {
            hRes = ExecRenamePrinter(Instance, pInParams, pOutParams);
        }
        else if (!_wcsicmp(bstrMethodName, METHOD_TEST_PAGE))
        {
            hRes = ExecPrintTestPage(Instance, pInParams, pOutParams);
        }
        else if (!_wcsicmp(bstrMethodName, METHOD_ADD_PRINTER_CONNECTION))
        {
            hRes = ExecAddPrinterConnection(Instance, pInParams, pOutParams);
        }
        else
        {
            hRes = WBEM_E_PROVIDER_NOT_CAPABLE;
        }
    }

    return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    :    CWin32Printer::ExecSetDefaultPrinter
*
*  DESCRIPTION :    This method sets the default printer, if it is not already
*                   Set as a Default printer
*
*****************************************************************************/
#if NTONLY >= 5

HRESULT CWin32Printer :: ExecSetDefaultPrinter (

    const CInstance &Instance,
    CInstance *pInParams,
    CInstance *pOutParams,
    long lFlags
)
{
    CHString    t_Printer;
    DWORD       dwError;
    HRESULT     hRes       = WBEM_S_NO_ERROR;
    BOOL        bLocalCall = FALSE;

    dwError = IsLocalCall(&bLocalCall);

    hRes    = WinErrorToWBEMhResult(dwError);

    if (SUCCEEDED(hRes))
    {
        hRes = WBEM_E_NOT_SUPPORTED;

        if (bLocalCall)
        {
            hRes = WBEM_S_NO_ERROR;

            if (!Instance.GetCHString(IDS_DeviceID, t_Printer))
            {
            hRes = WBEM_E_PROVIDER_FAILURE;
            }

            if (SUCCEEDED(hRes))
            {
                hRes = WBEM_E_FAILED;

                //
                // We reached to point where we call the method, report success to WMI
                //
                hRes    = WBEM_S_NO_ERROR;

                dwError = ERROR_SUCCESS;

                if (!::SetDefaultPrinter((LPTSTR)(LPCTSTR)t_Printer))
                {
                    dwError = GetLastError();
                }

                SetReturnValue(pOutParams, dwError);

            }
        }
    }

    return hRes;
}

#endif

/*****************************************************************************
*
*  FUNCTION    :    CWin32Printer::ExecSetPrinter
*
*  DESCRIPTION :    The SetPrinter function sets the data for a specified printer
*                   or sets the state of the specified printer by pausing printing,
*                   resuming printing, or clearing all print jobs.
*
*****************************************************************************/
HRESULT CWin32Printer :: ExecSetPrinter (

    const CInstance &Instance,
    CInstance *pInParams,
    CInstance *pOutParams,
    long lFlags,
    DWORD dwState
)
{
#if NTONLY==5
    CHString  t_Printer;
    DWORD     dwError;
    HRESULT   hRes = WBEM_S_NO_ERROR;

    hRes = InstanceGetString(Instance, IDS_DeviceID, &t_Printer, kFailOnEmptyString);

    if (SUCCEEDED(hRes))
    {
        hRes = WBEM_E_FAILED;

        SmartClosePrinter hPrinter;
        PRINTER_DEFAULTS PrinterDefaults = {NULL, NULL, PRINTER_ACCESS_ADMINISTER};

        hRes    = WBEM_S_NO_ERROR;
        dwError = ERROR_SUCCESS;

        // Use of delay loaded functions requires exception handler.
        SetStructuredExceptionHandler seh;
        try
        {
            if (::OpenPrinter(const_cast<LPWSTR>(static_cast<LPCWSTR>(t_Printer)) ,&hPrinter, &PrinterDefaults))
            {
                if (!::SetPrinter(hPrinter, 0, NULL, dwState))
                {
                    dwError = GetLastError();
                }
            }
            else
            {
                dwError = GetLastError();
            }
        }
        catch(Structured_Exception se)
        {
            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
            dwError = ERROR_DLL_NOT_FOUND;
            hRes = WBEM_E_FAILED;
        }

        SetReturnValue(pOutParams, dwError);        

    }

    return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    : CWin32Printer::PutInstance
*
*  DESCRIPTION : Adding a Printer if it doesnt exist
*
*****************************************************************************/

HRESULT CWin32Printer :: PutInstance  (

    const CInstance &Instance,
    long lFlags
)
{
#if NTONLY >= 5

    HRESULT hRes        = WBEM_S_NO_ERROR;
    DWORD   dwError;
    DWORD   dwOperation = WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_CREATE_OR_UPDATE;

    switch(lFlags & dwOperation)
    {
    case WBEM_FLAG_CREATE_OR_UPDATE:
    case WBEM_FLAG_CREATE_ONLY:
    case WBEM_FLAG_UPDATE_ONLY:
        {
            //
            // Get all the necessary parameters
            //
            PRINTER_INFO_2W pPrnInfo = {0};
            CHString        t_Printer;
            CHString        t_Driver;
            CHString        t_Port;
            CHString        t_Share;
            CHString        t_Comment;
            CHString        t_Location;
            CHString        t_SepFile;
            CHString        t_PrintProc;
            CHString        t_DataType;
            CHString        t_Params;
            CHString        t_StartTime;
            CHString        t_UntilTime;
            SYSTEMTIME      st                = {0};
            DWORD           dwPriority        = 0;
            DWORD           dwDefaultPriority = 0;
            DWORD           dwAttributes      = 0;
            BOOL            bValue;

            hRes = InstanceGetString(Instance, IDS_DeviceID, &t_Printer, kFailOnEmptyString);

            //
            // Special case when the flag for PutInstance is CREATE_OR_UPDATE.
            // We need to check if the printer exists, then update it. If it does
            // not exist then create it
            //
            if (SUCCEEDED(hRes) && lFlags==WBEM_FLAG_CREATE_OR_UPDATE)
            {
                hRes = WBEM_E_FAILED;

                SmartClosePrinter  hPrinter;
                PRINTER_DEFAULTS   PrinterDefaults = {NULL, NULL, PRINTER_READ};

                hRes = WBEM_S_NO_ERROR;

                // Use of delay loaded functions requires exception handler.
                SetStructuredExceptionHandler seh;
                try
                {
                    if (::OpenPrinter(const_cast<LPWSTR>(static_cast<LPCWSTR>(t_Printer)),
                                                  reinterpret_cast<LPHANDLE>(&hPrinter),
                                                  &PrinterDefaults))
                    {
                        //
                        // Printer exsits, so we do an update
                        //
                        lFlags = WBEM_FLAG_UPDATE_ONLY;

                        DBGMSG(DBG_TRACE, (L"CWin32_Printer::PutInstance update printer\n"));
                    }
                    else
                    {
                        //
                        // Regardless why OpenPrinter failed, try a create
                        //
                        lFlags = WBEM_FLAG_CREATE_ONLY;

                        DBGMSG(DBG_TRACE, (L"CWin32_Printer::PutInstance create printer\n"));
                    }
                }
                catch(Structured_Exception se)
                {
                    DelayLoadDllExceptionFilter(se.GetExtendedInfo());
                    hRes = WBEM_E_FAILED;
                }

            }

            //
            // Continue getting property values
            //
            if (SUCCEEDED(hRes))
            {
                pPrnInfo.pPrinterName = const_cast<LPWSTR>(static_cast<LPCWSTR>(t_Printer));

                hRes = InstanceGetString(Instance, IDS_DriverName, &t_Driver, kFailOnEmptyString);
            }

            if (SUCCEEDED(hRes))
            {
                pPrnInfo.pDriverName = const_cast<LPWSTR>(static_cast<LPCWSTR>(t_Driver));

                hRes = InstanceGetString(Instance, IDS_ShareName, &t_Share, kAcceptEmptyString);
            }

            if (SUCCEEDED(hRes))
            {
                pPrnInfo.pShareName = const_cast<LPWSTR>(static_cast<LPCWSTR>(t_Share));

                hRes = InstanceGetString(Instance, IDS_PortName, &t_Port, kFailOnEmptyString);
            }

            if (SUCCEEDED(hRes))
            {
                pPrnInfo.pPortName = const_cast<LPWSTR>(static_cast<LPCWSTR>(t_Port));

                hRes = InstanceGetString(Instance, IDS_Comment, &t_Comment, kAcceptEmptyString);
            }

            if (SUCCEEDED(hRes))
            {
                pPrnInfo.pComment = const_cast<LPWSTR>(static_cast<LPCWSTR>(t_Comment));

                hRes = InstanceGetString(Instance, IDS_Location, &t_Location, kAcceptEmptyString);
            }

            if (SUCCEEDED(hRes))
            {
                pPrnInfo.pLocation = const_cast<LPWSTR>(static_cast<LPCWSTR>(t_Location));

                hRes = InstanceGetString(Instance, IDS_SeparatorFile, &t_SepFile, kAcceptEmptyString);
            }

            if (SUCCEEDED(hRes))
            {
                pPrnInfo.pSepFile = const_cast<LPWSTR>(static_cast<LPCWSTR>(t_SepFile));

                //
                // SplPrinterXXX will default the print proc to winprint, but we cannot
                //
                hRes = InstanceGetString(Instance, IDS_PrintProcessor, &t_PrintProc, kAcceptEmptyString);
            }

            if (SUCCEEDED(hRes))
            {
                pPrnInfo.pPrintProcessor = const_cast<LPWSTR>(static_cast<LPCWSTR>(t_PrintProc));

                //
                // SplPrinterXXX will default the data typ to RAW, if not present or empty
                //
                hRes = InstanceGetString(Instance, IDS_PrintJobDataType, &t_DataType, kAcceptEmptyString);
            }

            if (SUCCEEDED(hRes))
            {
                pPrnInfo.pDatatype = const_cast<LPWSTR>(static_cast<LPCWSTR>(t_DataType));

                hRes = InstanceGetString(Instance, IDS_Parameters, &t_Params, kAcceptEmptyString);
            }

            if (SUCCEEDED(hRes))
            {
                pPrnInfo.pParameters = const_cast<LPWSTR>(static_cast<LPCWSTR>(t_Params));

                hRes = InstanceGetDword(Instance, IDS_Priority, &dwPriority);
            }

            if (SUCCEEDED(hRes))
            {
                pPrnInfo.Priority = dwPriority;

                hRes = InstanceGetDword(Instance, IDS_DefaultPriority, &dwDefaultPriority);
            }

            if (SUCCEEDED(hRes))
            {
                pPrnInfo.DefaultPriority = dwDefaultPriority;

                hRes = InstanceGetString(Instance, IDS_StartTime, &t_StartTime, kAcceptEmptyString);
            }

            if (SUCCEEDED(hRes))
            {
                if (t_StartTime.IsEmpty())
                {
                    //
                    // SplPrinterSet will know -1 means not set
                    //
                    pPrnInfo.StartTime = (DWORD)-1;
                }
                else
                {
                    hRes = ConvertCIMTimeToSystemTime(t_StartTime, &st);

                    if (SUCCEEDED(hRes))
                    {
                        pPrnInfo.StartTime = LocalTimeToPrinterTime(st);
                    }
                }
            }

            if (SUCCEEDED(hRes))
            {
                hRes = InstanceGetString(Instance, IDS_UntilTime, &t_UntilTime, kAcceptEmptyString);
            }

            if (SUCCEEDED(hRes))
            {
                if (t_UntilTime.IsEmpty())
                {
                    //
                    // SplPrinterSet will know -1 means not set
                    //
                    pPrnInfo.UntilTime = (DWORD)-1;
                }
                else
                {
                    hRes = ConvertCIMTimeToSystemTime(t_UntilTime, &st);

                    if (SUCCEEDED(hRes))
                    {
                        pPrnInfo.UntilTime = LocalTimeToPrinterTime(st);
                    }
                }
            }

            if (SUCCEEDED(hRes))
            {
                //
                // Get the attributes
                //
                for (UINT uIndex = 0; SUCCEEDED(hRes) && uIndex < sizeof(AttributeTable)/sizeof(AttributeTable[0]); uIndex++)
                {
                    hRes = InstanceGetBool(Instance, AttributeTable[uIndex].BoolName, &bValue);

                    if (SUCCEEDED(hRes) && bValue)
                    {
                        dwAttributes |= AttributeTable[uIndex].Bit;
                    }
                }
            }

            if (SUCCEEDED(hRes))
            {
                pPrnInfo.Attributes = dwAttributes;

                dwError = lFlags & WBEM_FLAG_CREATE_ONLY ? SplPrinterAdd(pPrnInfo) : SplPrinterSet(pPrnInfo);

                hRes = WinErrorToWBEMhResult(dwError);

                if (FAILED(hRes))
                {
                    SetErrorObject(Instance, dwError, pszPutInstance);
                }
            }
        }

        break;

    default:
        hRes = WBEM_E_PROVIDER_NOT_CAPABLE;
    }

    return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    :    CWin32Printer:: DeleteInstance
*
*  DESCRIPTION :    Deleting a Printer
*
*****************************************************************************/

HRESULT CWin32Printer :: DeleteInstance (

    const CInstance &Instance,
    long lFlags
)
{
#if NTONLY == 5
    HRESULT  hRes = WBEM_E_PROVIDER_FAILURE;
    CHString t_Printer;
    DWORD    dwError;
    BOOL     bLocalCall = TRUE;
    DWORD    dwAttributes = 0;

    hRes = InstanceGetString(Instance, IDS_DeviceID, &t_Printer , kFailOnEmptyString);

    if (SUCCEEDED(hRes))
    {
        dwError = SplPrinterGetAttributes(t_Printer, &dwAttributes);

        hRes = WinErrorToWBEMhResult(dwError);
    }

    if (SUCCEEDED(hRes))
    {
        if (dwAttributes & PRINTER_ATTRIBUTE_LOCAL)
        {
            dwError = SplPrinterDel(t_Printer);

            hRes = WinErrorToWBEMhResult(dwError);

            if (FAILED(hRes))
            {
                SetErrorObject(Instance, dwError, pszDeleteInstance);
            }
        }
        else
        {
            //
            // We are dealing with a printer connection
            //
            dwError = IsLocalCall(&bLocalCall);

            hRes    = WinErrorToWBEMhResult(dwError);

            if (SUCCEEDED(hRes))
            {
                if (bLocalCall)
                {
                    hRes = WBEM_E_FAILED;

                    hRes = WBEM_S_NO_ERROR;

                    if (!::DeletePrinterConnection(const_cast<LPWSTR>(static_cast<LPCWSTR>(t_Printer))))
                    {
                        dwError = GetLastError();

                        hRes = WinErrorToWBEMhResult(dwError);

                        SetErrorObject(Instance, dwError, pszDeleteInstance);
                    }

                }
                else
                {
                    //
                    // Deleting connections on remote machine not supported
                    //
                    hRes = WBEM_E_NOT_SUPPORTED;
                }
            }
        }
    }

    return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif

}


/*****************************************************************************
*
*  FUNCTION    :    CWin32Printer::PrintTestPage
*
*  DESCRIPTION :    This method will rename a given printer
*
*****************************************************************************/

HRESULT CWin32Printer :: ExecPrintTestPage (

    const CInstance &Instance,
    CInstance *pInParams,
    CInstance *pOutParams
)
{
#if NTONLY >= 5
    CHString    t_Printer;
    HRESULT     hRes = WBEM_S_NO_ERROR;

    hRes = InstanceGetString(Instance, IDS_DeviceID, &t_Printer, kFailOnEmptyString);

    if (SUCCEEDED(hRes))
    {
        DWORD dwError = SplPrintTestPage(t_Printer);

        SetReturnValue(pOutParams, dwError);
    }

    return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    :    CWin32Printer::AddPrinterConnection
*
*  DESCRIPTION :    This method will rename a given printer
*
*****************************************************************************/

HRESULT CWin32Printer :: ExecAddPrinterConnection (

    const CInstance &Instance,
    CInstance *pInParams,
    CInstance *pOutParams
)
{
#if NTONLY==5
    CHString t_Printer;
    HRESULT  hRes       = WBEM_E_NOT_SUPPORTED;
    BOOL     bLocalCall = TRUE;
    DWORD    dwError    = ERROR_SUCCESS;

    dwError = IsLocalCall(&bLocalCall);

    hRes    = WinErrorToWBEMhResult(dwError);

    if (SUCCEEDED(hRes))
    {
        hRes = WBEM_E_NOT_SUPPORTED;

        if (bLocalCall)
        {
            hRes = WBEM_E_INVALID_PARAMETER;

            if (pInParams)
            {
                hRes = InstanceGetString(*pInParams, METHOD_ARG_NAME_PRINTER, &t_Printer, kFailOnEmptyString);

                if (SUCCEEDED (hRes))
                {
                    hRes = WBEM_E_NOT_FOUND;

                    //
                    // We reached to point where we call the method, report success to WMI
                    //
                    hRes = WBEM_S_NO_ERROR;

                    dwError = ERROR_SUCCESS;

                    // Use of delay loaded functions requires exception handler.
                    SetStructuredExceptionHandler seh;

                    try
                    {
                        if (!::AddPrinterConnection(const_cast<LPWSTR>(static_cast<LPCWSTR>(t_Printer))))
                        {
                            dwError = GetLastError();
                        }
                    }
                    catch(Structured_Exception se)
                    {
                        DelayLoadDllExceptionFilter(se.GetExtendedInfo());
                        dwError = ERROR_DLL_NOT_FOUND;
                        hRes = WBEM_E_FAILED;
                    }

                    SetReturnValue(pOutParams, dwError);
                }
            }
        }
    }

    return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    :    CWin32Printer::RenamePrinter
*
*  DESCRIPTION :    This method will rename a given printer
*
*****************************************************************************/

HRESULT CWin32Printer :: ExecRenamePrinter (

    const CInstance &Instance,
    CInstance *pInParams,
    CInstance *pOutParams
)
{
#if NTONLY >= 5
    CHString    t_NewPrinterName;
    CHString    t_OldPrinterName;
    HRESULT     hRes = WBEM_S_NO_ERROR;

    hRes = InstanceGetString(Instance, IDS_DeviceID, &t_OldPrinterName, kFailOnEmptyString);

    if (SUCCEEDED (hRes))
    {
        hRes = InstanceGetString(*pInParams, METHOD_ARG_NAME_NEWPRINTERNAME, &t_NewPrinterName, kFailOnEmptyString);
    }

    if (SUCCEEDED(hRes))
    {
        DWORD dwError = SplPrinterRename(t_OldPrinterName, t_NewPrinterName);

        SetReturnValue(pOutParams, dwError);
    }

    return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\printercfg.cpp ===
//////////////////////////////////////////////////////////////////////

//

//  printercfg

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//      10/24/97        jennymc     Moved to new framework
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <winspool.h>
#include <lockwrap.h>
#include <DllWrapperBase.h>
#include <WinSpool.h>
#include "prnutil.h"
#include "Printercfg.h"

// Property set declaration
//=========================

CWin32PrinterConfiguration MyCWin32PrinterConfigurationSet ( PROPSET_NAME_PRINTERCFG , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PrinterConfiguration::CWin32PrinterConfiguration
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32PrinterConfiguration :: CWin32PrinterConfiguration (

    LPCWSTR name,
    LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PrinterConfiguration::~CWin32PrinterConfiguration
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32PrinterConfiguration :: ~CWin32PrinterConfiguration ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Printer::ExecQuery
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32PrinterConfiguration :: ExecQuery (

    MethodContext *pMethodContext,
    CFrameworkQuery& pQuery,
    long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_E_FAILED;


    // If all they want is the name, we'll give it to them, else let them call enum.
    if( pQuery.KeysOnly() )
    {
        hr = hCollectInstances ( pMethodContext , e_KeysOnly ) ;
    }
    else
    {
        hr = WBEM_E_PROVIDER_NOT_CAPABLE;
    }

    return hr ;
}

/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32PrinterConfiguration :: GetObject ( CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery )
{
    HRESULT  hRes;
    CHString strPrinterName;
    BOOL     bIsLocalCall;
    
    if (pInstance->GetCHString(IDS_Name, strPrinterName))
    {
        hRes = WinErrorToWBEMhResult(IsLocalCall(&bIsLocalCall));
    }
    else
    {
        //
        // GetCHString sets the last error to a WBEM HRESULT
        //
        hRes = GetLastError();
    }

    if (SUCCEEDED(hRes)) 
    {
        //
        // Check if the printer is a local printer or a printer connection.
        // We want to disallow the following scenario:
        // User connects remotely to winmgmt on server \\srv
        // User does GetObject on printer \\prnsrv\prn which is not local and
        // the user doesn't have a connection to. Normally this call succeeds,
        // because the spooler goes accros the wire. This means that you can
        // do GetObject on an instance that cannot be returned by EnumInstances.
        // This is inconsistent with WMI.
        //
        BOOL bInstalled;
        
        hRes = WinErrorToWBEMhResult(SplIsPrinterInstalled(strPrinterName, &bInstalled));       

        if (SUCCEEDED(hRes) && !bInstalled) 
        {
            //
            // Caller wants to do GetObject on a remote printer
            //
            hRes = WBEM_E_NOT_FOUND;
        }
    }

    if (SUCCEEDED(hRes))
    {
        DWORD Attrib;

        hRes = WinErrorToWBEMhResult(SplPrinterGetAttributes(strPrinterName, &Attrib));

        if (SUCCEEDED(hRes) && !bIsLocalCall && Attrib & PRINTER_ATTRIBUTE_NETWORK)
        {
            hRes = WBEM_E_NOT_FOUND;
        }
    }

    if (SUCCEEDED(hRes))
    {
        //
        // Normaly we shold check the result of this operation, yet in case of failure
        // it will simply not polupate some of the properties - which is not fatal !
        //
        GetExpensiveProperties ( TOBSTRT ( strPrinterName ), pInstance, pQuery.KeysOnly() ) ;
    }

    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32PrinterConfiguration :: EnumerateInstances (

    MethodContext *pMethodContext,
    long lFlags /*= 0L*/
)
{
    HRESULT hResult = WBEM_E_FAILED ;

    hResult = hCollectInstances ( pMethodContext , e_CollectAll ) ;


    return hResult ;
}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32PrinterConfiguration :: hCollectInstances (

    MethodContext *pMethodContext,
    E_CollectionScope eCollectionScope
)
{
    CLockWrapper lockPrinter ( g_csPrinter ) ;

    HRESULT hr = DynInstanceWinNTPrinters ( pMethodContext, eCollectionScope ) ;

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32PrinterConfiguration :: DynInstanceWinNTPrinters (

    MethodContext *pMethodContext,
    E_CollectionScope eCollectionScope
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // First of all call with a zero size to find out just
    // how many bytes it needs
    //====================================================

    DWORD InfoType = ENUMPRINTERS_WINNT_INFOTYPE;
    DWORD PrinterFlags = PRINTER_ENUM_LOCAL;
    DWORD BytesCopied = (DWORD)0L;
    DWORD TotalPrinters = (DWORD)0L;
    BOOL  bIsLocalCall;

    if (SUCCEEDED(hr = WinErrorToWBEMhResult(IsLocalCall(&bIsLocalCall))))
    {
        if (bIsLocalCall)
        {
            PrinterFlags |= PRINTER_ENUM_CONNECTIONS;
        }

        ::EnumPrinters (
    
            PrinterFlags,               // types of printer objects to enumerate
            NULL,                       // name of printer object
            InfoType,                   // specifies type of printer info structure
            NULL ,                      // pointer to buffer to receive printer info structures
            (DWORD)0L,                  // size, in bytes, of array
            (LPDWORD) & BytesCopied,    // addr. of variable with no. of bytes copied (or required)
            (LPDWORD) & TotalPrinters   // addr. of variable with no. of printer info. structures copied
        );
    
        // Now create a buffer big enough for the info
        // ===========================================
        DWORD pPrintInfoSize = BytesCopied ;
        LPBYTE pPrintInfoBase = new BYTE[pPrintInfoSize];
    
        if ( pPrintInfoBase )
        {
            try
            {
                PRINTER_INFO_4 *pPrintInfo = (PRINTER_INFO_4 *)pPrintInfoBase;
    
                // Get the size of the total enumeration printer data
                // ==================================================
    
                int RetVal = ::EnumPrinters (
    
                    PrinterFlags,               // types of printer objects to enumerate
                    NULL,                       // name of printer object
                    InfoType,                   // specifies type of printer info structure
                    (LPBYTE)pPrintInfo,         // pointer to buffer to receive printer info structures
                    pPrintInfoSize,             // size, in bytes, of array
                    (LPDWORD) & BytesCopied,    // addr. of variable with no. of bytes copied (or required)
                    (LPDWORD) & TotalPrinters   // addr. of variable with no. of printer info. structures copied
                ) ;
    
                if ( RetVal )
                {
                    for ( DWORD CurrentPrinterIndex = (DWORD)0L; CurrentPrinterIndex < TotalPrinters && SUCCEEDED(hr); CurrentPrinterIndex++)
                    {
                        // Start building a new instance
                        //==============================
                        CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
    
                        pInstance->SetCHString ( IDS_Name, ((PRINTER_INFO_4 *)(pPrintInfo))->pPrinterName ) ;
    
                        if ( e_CollectAll == eCollectionScope )
                        {
                            GetExpensiveProperties (
    
                                ((PRINTER_INFO_4 *)(pPrintInfo))->pPrinterName ,
                                pInstance ,
                                false
                            ) ;
                        }
    
                        hr = pInstance->Commit (  ) ;
    
                        ++ pPrintInfo ;
                    }
                }
                else
                {
                    DWORD Error = GetLastError();
    
                    if ( Error == ERROR_ACCESS_DENIED )
                    {
                        hr = WBEM_E_ACCESS_DENIED;
                    }
                    else
                    {
                        hr = WBEM_E_FAILED;
                    }
    
                    if (IsErrorLoggingEnabled())
                    {
                        CHString msg;
                        msg.Format(L"%s:Error %lxH (%ld)\n",PROPSET_NAME_PRINTERCFG, Error, Error);
                        LogErrorMessage(msg);
                    }
                }
            }
            catch ( ... )
            {
                delete [] pPrintInfoBase ;
    
                throw ;
            }
    
            delete[] pPrintInfoBase;
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }

    return hr;
}



// Used to convert from dmPaperSize to width and height.
const DWORD g_dwSizes[][2] =
{
    {    0,    0}, // Unused
    { 2159, 2794}, /* Letter 8 1/2 x 11 in               */
    { 2159, 2794}, /* Letter Small 8 1/2 x 11 in         */
    { 2794, 4318}, /* Tabloid 11 x 17 in                 */
    { 4318, 2794}, /* Ledger 17 x 11 in                  */
    { 2159, 3556}, /* Legal 8 1/2 x 14 in                */
    { 1397, 2159}, /* Statement 5 1/2 x 8 1/2 in         */
    { 1842, 2667}, /* Executive 7 1/4 x 10 1/2 in        */
    { 2970, 4200}, /* A3 297 x 420 mm                    */
    { 2100, 2970}, /* A4 210 x 297 mm                    */
    { 2100, 2970}, /* A4 Small 210 x 297 mm              */
    { 1480, 2100}, /* A5 148 x 210 mm                    */
    { 2500, 3540}, /* B4 (JIS) 250 x 354                 */
    { 1820, 2570}, /* B5 (JIS) 182 x 257 mm              */
    { 2159, 3320}, /* Folio 8 1/2 x 13 in                */
    { 2150, 2750}, /* Quarto 215 x 275 mm                */
    { 2540, 3556}, /* 10x14 in                           */
    { 2794, 4318}, /* 11x17 in                           */
    { 2159, 2794}, /* Note 8 1/2 x 11 in                 */
    {  984, 2254}, /* Envelope #9 3 7/8 x 8 7/8          */
    { 1048, 2413}, /* Envelope #10 4 1/8 x 9 1/2         */
    { 1143, 2635}, /* Envelope #11 4 1/2 x 10 3/8        */
    { 1207, 2794}, /* Envelope #12 4 \276 x 11           */
    { 1270, 2921}, /* Envelope #14 5 x 11 1/2            */
    { 4318, 5588}, /* C 17 x 22 size sheet               */
    { 5588, 8636}, /* D 22 x 34 size sheet               */
    { 8636,11176}, /* E 34 x 44 size sheet               */
    { 1100, 2200}, /* Envelope DL 110 x 220mm            */
    { 1620, 2290}, /* Envelope C5 162 x 229 mm           */
    { 3240, 4580}, /* Envelope C3  324 x 458 mm          */
    { 2290, 3240}, /* Envelope C4  229 x 324 mm          */
    { 1140, 1620}, /* Envelope C6  114 x 162 mm          */
    { 1140, 2290}, /* Envelope C65 114 x 229 mm          */
    { 2500, 3530}, /* Envelope B4  250 x 353 mm          */
    { 1760, 2500}, /* Envelope B5  176 x 250 mm          */
    { 1760, 1250}, /* Envelope B6  176 x 125 mm          */
    { 1100, 2300}, /* Envelope 110 x 230 mm              */
    { 9843, 1905}, /* Envelope Monarch 3.875 x 7.5 in    */
    { 9208, 1651}, /* 6 3/4 Envelope 3 5/8 x 6 1/2 in    */
    { 3778, 2794}, /* US Std Fanfold 14 7/8 x 11 in      */
    { 2159, 3048}, /* German Std Fanfold 8 1/2 x 12 in   */
    { 2159, 3302}, /* German Legal Fanfold 8 1/2 x 13 in */
    { 2500, 3530}, /* B4 (ISO) 250 x 353 mm              */
    { 1000, 1480}, /* Japanese Postcard 100 x 148 mm     */
    { 2286, 2794}, /* 9 x 11 in                          */
    { 2540, 2794}, /* 10 x 11 in                         */
    { 3810, 2794}, /* 15 x 11 in                         */
    { 2200, 2200}, /* Envelope Invite 220 x 220 mm       */
    {    0,    0}, /* RESERVED--DO NOT USE               */
    {    0,    0}, /* RESERVED--DO NOT USE               */
    { 2356, 3048}, /* Letter Extra 9 \275 x 12 in        */
    { 2356, 3810}, /* Legal Extra 9 \275 x 15 in         */
    { 2969, 4572}, /* Tabloid Extra 11.69 x 18 in        */
    { 2355, 3223}, /* A4 Extra 9.27 x 12.69 in           */
    { 2102, 2794}, /* Letter Transverse 8 \275 x 11 in   */
    { 2100, 2970}, /* A4 Transverse 210 x 297 mm         */
    { 2356, 3048}, /* Letter Extra Transverse 9\275 x 12 in */
    { 2270, 3560}, /* SuperA/SuperA/A4 227 x 356 mm      */
    { 3050, 4870}, /* SuperB/SuperB/A3 305 x 487 mm      */
    { 2159, 3223}, /* Letter Plus 8.5 x 12.69 in         */
    { 2100, 3330}, /* A4 Plus 210 x 330 mm               */
    { 1480, 2100}, /* A5 Transverse 148 x 210 mm         */
    { 1820, 2570}, /* B5 (JIS) Transverse 182 x 257 mm   */
    { 3220, 4450}, /* A3 Extra 322 x 445 mm              */
    { 1740, 2350}, /* A5 Extra 174 x 235 mm              */
    { 2010, 2760}, /* B5 (ISO) Extra 201 x 276 mm        */
    { 4200, 5940}, /* A2 420 x 594 mm                    */
    { 2970, 4200}, /* A3 Transverse 297 x 420 mm         */
    { 3200, 4450}, /* A3 Extra Transverse 322 x 445 mm   */

#if NTONLY >= 5
    { 2000, 1480}, /* Japanese Double Postcard 200 x 148 mm */
    { 1050, 1480}, /* A6 105 x 148 mm                 */
    {    0,    0}, /* Japanese Envelope Kaku #2       */
    {    0,    0}, /* Japanese Envelope Kaku #3       */
    {    0,    0}, /* Japanese Envelope Chou #3       */
    {    0,    0}, /* Japanese Envelope Chou #4       */
    { 2794, 2159}, /* Letter Rotated 11 x 8 1/2 11 in */
    { 4200, 2970}, /* A3 Rotated 420 x 297 mm         */
    { 2970, 2100}, /* A4 Rotated 297 x 210 mm         */
    { 2100, 1480}, /* A5 Rotated 210 x 148 mm         */
    { 3640, 2570}, /* B4 (JIS) Rotated 364 x 257 mm   */
    { 2570, 1820}, /* B5 (JIS) Rotated 257 x 182 mm   */
    { 1480, 1000}, /* Japanese Postcard Rotated 148 x 100 mm */
    { 1480, 2000}, /* Double Japanese Postcard Rotated 148 x 200 mm */
    { 1480, 1050}, /* A6 Rotated 148 x 105 mm         */
    {    0,    0}, /* Japanese Envelope Kaku #2 Rotated */
    {    0,    0}, /* Japanese Envelope Kaku #3 Rotated */
    {    0,    0}, /* Japanese Envelope Chou #3 Rotated */
    {    0,    0}, /* Japanese Envelope Chou #4 Rotated */
    { 1280, 1820}, /* B6 (JIS) 128 x 182 mm           */
    { 1820, 1280}, /* B6 (JIS) Rotated 182 x 128 mm   */
    { 3048, 2794}, /* 12 x 11 in                      */
    {    0,    0}, /* Japanese Envelope You #4        */
    {    0,    0}, /* Japanese Envelope You #4 Rotated*/
    { 1460, 2150}, /* PRC 16K 146 x 215 mm            */
    {  970, 1510}, /* PRC 32K 97 x 151 mm             */
    {  970, 1510}, /* PRC 32K(Big) 97 x 151 mm        */
    { 1020, 1650}, /* PRC Envelope #1 102 x 165 mm    */
    { 1020, 1760}, /* PRC Envelope #2 102 x 176 mm    */
    { 1250, 1760}, /* PRC Envelope #3 125 x 176 mm    */
    { 1100, 2080}, /* PRC Envelope #4 110 x 208 mm    */
    { 1100, 2200}, /* PRC Envelope #5 110 x 220 mm    */
    { 1200, 2300}, /* PRC Envelope #6 120 x 230 mm    */
    { 1600, 2300}, /* PRC Envelope #7 160 x 230 mm    */
    { 1200, 3090}, /* PRC Envelope #8 120 x 309 mm    */
    { 2290, 3240}, /* PRC Envelope #9 229 x 324 mm    */
    { 3240, 4580}, /* PRC Envelope #10 324 x 458 mm   */
    { 2150, 1460}, /* PRC 16K Rotated                 */
    { 1510,  970}, /* PRC 32K Rotated                 */
    { 1510,  970}, /* PRC 32K(Big) Rotated            */
    { 1650, 1020}, /* PRC Envelope #1 Rotated 165 x 102 mm */
    { 1760, 1020}, /* PRC Envelope #2 Rotated 176 x 102 mm */
    { 1760, 1250}, /* PRC Envelope #3 Rotated 176 x 125 mm */
    { 2080, 1100}, /* PRC Envelope #4 Rotated 208 x 110 mm */
    { 2200, 1100}, /* PRC Envelope #5 Rotated 220 x 110 mm */
    { 2300, 1200}, /* PRC Envelope #6 Rotated 230 x 120 mm */
    { 2300, 1600}, /* PRC Envelope #7 Rotated 230 x 160 mm */
    { 3090, 1200}, /* PRC Envelope #8 Rotated 309 x 120 mm */
    { 3240, 2290}, /* PRC Envelope #9 Rotated 324 x 229 mm */
    { 4580, 3240}, /* PRC Envelope #10 Rotated 458 x 324 mm */
#endif // NTONLY >= 5
};


#define MAX_PAPERSIZE_INDEX  sizeof(g_dwSizes)/sizeof(g_dwSizes[0])

void CWin32PrinterConfiguration :: UpdateSizesViaPaperSize(DEVMODE *pDevMode)
{
    // See if the paper type is one that we can find the size/length for.
    if (pDevMode->dmPaperSize >= 1 &&
        pDevMode->dmPaperSize < MAX_PAPERSIZE_INDEX)
    {
        // Only set the width if it's not already set.
        if (!(pDevMode->dmFields & DM_PAPERWIDTH))
        {
            pDevMode->dmPaperWidth = g_dwSizes[pDevMode->dmPaperSize][0];
            pDevMode->dmFields |= DM_PAPERWIDTH;
        }

        // Only set the length if it's not already set.
        if (!(pDevMode->dmFields & DM_PAPERLENGTH))
        {
            pDevMode->dmPaperLength = g_dwSizes[pDevMode->dmPaperSize][1];
            pDevMode->dmFields |= DM_PAPERLENGTH;
        }
    }
}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32PrinterConfiguration :: GetExpensiveProperties (

    LPCTSTR szPrinter,
    CInstance * pInstance ,
    bool a_KeysOnly
)
{

    HRESULT hr;

    // Instance fill
    CHString t_chsPrinterName( szPrinter ) ;
    pInstance->SetCHString( IDS_Description, t_chsPrinterName );

    //
    SmartClosePrinter hPrinter;

    // Use of delay loaded function requires exception handler.
    SetStructuredExceptionHandler seh;
    try
    {
        BOOL t_Status = ::OpenPrinter (

            (LPTSTR) szPrinter,
            &hPrinter,
            NULL
        ) ;

        if ( t_Status )
        {
            hr = WBEM_S_NO_ERROR;

            if (!a_KeysOnly)
            {
                // Call 1 time to get buffer size
                //===============================

                DWORD dwByteCount = ::DocumentProperties (

                    NULL,
                    hPrinter,
                    NULL,
                    NULL,
                    NULL,
                    0
                ) ;

                if ( dwByteCount )
                {
                    CSmartBuffer buffer(dwByteCount);
                    DEVMODE      *pDevMode = (DEVMODE *) (LPBYTE) buffer;

                    LONG t_DocStatus = ::DocumentProperties (

                        NULL,
                        hPrinter,
                        NULL,
                        pDevMode,
                        NULL,
                        DM_OUT_BUFFER
                        ) ;

                    if ( t_DocStatus == IDOK )
                    {
                        pInstance->SetCharSplat(L"DeviceName", (LPCTSTR) pDevMode->dmDeviceName );

                        pInstance->SetCharSplat(L"SettingID", (LPCTSTR) pDevMode->dmDeviceName );

                        pInstance->SetCHString( IDS_Caption, pDevMode->dmDeviceName );

                        pInstance->SetDWORD(L"DriverVersion", (DWORD) pDevMode->dmDriverVersion );

                        pInstance->SetDWORD(L"SpecificationVersion", (DWORD) pDevMode->dmSpecVersion );

                        // Get the paper width and height, if needed.
                        UpdateSizesViaPaperSize(pDevMode);

                        if (pDevMode->dmFields & DM_BITSPERPEL)
                        {
                            pInstance->SetDWORD(L"BitsPerPel", (DWORD) pDevMode->dmBitsPerPel );
                        }

                        if (pDevMode->dmFields & DM_COLLATE)
                        {
                            pInstance->Setbool(L"Collate",(BOOL)pDevMode->dmCollate);
                        }

                        if (pDevMode->dmFields & DM_COLOR)
                        {
                            pInstance->SetDWORD(L"Color",(DWORD) pDevMode->dmColor);
                        }

                        if (pDevMode->dmFields & DM_COPIES)
                        {
                            pInstance->SetDWORD(L"Copies",(DWORD) pDevMode->dmCopies);
                        }

                        if (pDevMode->dmFields & DM_DISPLAYFLAGS)
                        {
                            pInstance->SetDWORD(L"DisplayFlags",(DWORD) pDevMode->dmDisplayFlags );
                        }

                        if (pDevMode->dmFields & DM_DISPLAYFREQUENCY)
                        {
                            pInstance->SetDWORD(L"DisplayFrequency", (DWORD) pDevMode->dmDisplayFrequency );
                        }

                        if (pDevMode->dmFields & DM_DUPLEX)
                        {
                            pInstance->Setbool(L"Duplex", ((pDevMode->dmDuplex == DMDUP_SIMPLEX) ? 0 : 1) );
                        }

                        if (pDevMode->dmFields & DM_FORMNAME)
                        {
                            pInstance->SetCharSplat(L"FormName", (LPCTSTR) pDevMode->dmFormName );
                        }

                        if (pDevMode->dmFields & DM_LOGPIXELS)
                        {
                            pInstance->SetDWORD(L"LogPixels", (DWORD) pDevMode->dmLogPixels) ;
                        }

                        if (pDevMode->dmFields & DM_ORIENTATION)
                        {
                            pInstance->SetDWORD(L"Orientation",(DWORD) pDevMode->dmOrientation );
                        }

                        if (pDevMode->dmFields & DM_PAPERSIZE)
                        {
                            pInstance->SetDWORD(L"PaperSize",(DWORD) pDevMode->dmPaperSize );
                        }

                        // 0 indicates unknown.
                        if ((pDevMode->dmFields & DM_PAPERWIDTH) && pDevMode->dmPaperWidth)
                        {
                            pInstance->SetDWORD(L"PaperWidth", (DWORD) pDevMode->dmPaperWidth );
                        }

                        // 0 indicates unknown.
                        if ((pDevMode->dmFields & DM_PAPERLENGTH) && pDevMode->dmPaperLength)
                        {
                            pInstance->SetDWORD(L"PaperLength", (DWORD) pDevMode->dmPaperLength );
                        }

                        if (pDevMode->dmFields & DM_PELSHEIGHT)
                        {
                            pInstance->SetDWORD(L"PelsHeight",(DWORD) pDevMode->dmPelsHeight );
                        }

                        if (pDevMode->dmFields & DM_PELSWIDTH)
                        {
                            pInstance->SetDWORD(L"PelsWidth", (DWORD) pDevMode->dmPelsWidth );
                        }

                        if (pDevMode->dmFields & DM_PRINTQUALITY)
                        {
                            pInstance->SetDWORD(L"PrintQuality", (DWORD) pDevMode->dmPrintQuality );
                        }

                        if (pDevMode->dmFields & DM_SCALE)
                        {
                            pInstance->SetDWORD(L"Scale", (DWORD) pDevMode->dmScale );
                        }

                        if (pDevMode->dmFields & DM_TTOPTION)
                        {
                            pInstance->SetDWORD(L"TTOption", (DWORD) pDevMode->dmTTOption );
                        }

                        if (pDevMode->dmFields & DM_YRESOLUTION)
                        {
                            pInstance->SetDWORD ( IDS_VerticalResolution, (DWORD) pDevMode->dmYResolution );
                            pInstance->SetDWORD ( L"YResolution", (DWORD) pDevMode->dmYResolution );

                            // per DEVMODE documentation - if dmYres is populated, then printQuality contains the X res
                            // except that negative values are device independent enums

                            if ( pDevMode->dmPrintQuality > 0)
                            {
                                pInstance->SetDWORD ( IDS_HorizontalResolution , pDevMode->dmPrintQuality ) ;
                                pInstance->SetDWORD ( L"XResolution" , pDevMode->dmPrintQuality ) ;
                            }
                        }

    #ifdef NTONLY
                        if (pDevMode->dmFields & DM_DITHERTYPE)
                        {
                            pInstance->SetDWORD(L"DitherType", (DWORD) pDevMode->dmDitherType) ;
                        }

                        if (pDevMode->dmFields & DM_ICMINTENT)
                        {
                            pInstance->SetDWORD(L"ICMIntent",(DWORD) pDevMode->dmICMIntent) ;
                        }

                        if (pDevMode->dmFields & DM_ICMMETHOD)
                        {
                            pInstance->SetDWORD(L"ICMMethod",(DWORD) pDevMode->dmICMMethod) ;
                        }

                        if (pDevMode->dmFields & DM_MEDIATYPE)
                        {
                            pInstance->SetDWORD(L"MediaType",(DWORD) pDevMode->dmMediaType) ;
                        }
    #endif
                    }
                }
            }
        }
        else
        {
            hr = WBEM_E_NOT_FOUND ;
        }
    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo()); 
        hr = WBEM_E_FAILED;   
    }

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\printercontroller.h ===
//=================================================================

//

// PrinterController.h -- PrinterController association provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/10/98    davwoh        Created
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_PRINTERCONTROLLER L"Win32_PrinterController"

class CWin32PrinterController : public Provider
{
    
public:
    
    // Constructor/destructor
    //=======================
    
    CWin32PrinterController( LPCWSTR strName, LPCWSTR pszNamespace ) ;
    ~CWin32PrinterController() ;
    
    // Functions provide properties with current values
    //=================================================
    
    virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
    virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );
    
    // Utility
    //========
    
private:
    
    void ParsePort( LPCWSTR szPort, CHStringArray &chsaPrinterPortNames );
    HRESULT EnumPortsForPrinter(CInstance*      pPrinter,
        TRefPointerCollection<CInstance>& portList,
        MethodContext* pMethodContext );
    
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\printercfg.h ===
//////////////////////////////////////////////////////////////////////

//

//  printercfg

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//      10/24/97        jennymc     Moved to new framework
//
//////////////////////////////////////////////////////////////////////

//==================================
#define PROPSET_NAME_PRINTERCFG L"Win32_PrinterConfiguration"

// Types of information for Printers
// =================================
#define ENUMPRINTERS_WIN95_INFOTYPE 5
#define ENUMPRINTERS_WINNT_INFOTYPE 4
#define GETPRINTER_LEVEL2 (DWORD)2L

//==================================
class CWin32PrinterConfiguration : public Provider
{
public:

        // Constructor/destructor
        //=======================

    CWin32PrinterConfiguration(LPCWSTR name, LPCWSTR pszNamespace);
   ~CWin32PrinterConfiguration() ;

    // Funcitons provide properties with current values
    //=================================================
	virtual HRESULT ExecQuery( MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags = 0L );
	virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery& pQuery);
	virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);


        // Utility
        //========
private:

	enum E_CollectionScope { e_CollectAll, e_KeysOnly }; 

 	HRESULT hCollectInstances ( MethodContext *pMethodContext, E_CollectionScope eCollScope );
	HRESULT	DynInstanceWin95Printers ( MethodContext *pMethodContext, E_CollectionScope eCollScope );
	HRESULT	DynInstanceWinNTPrinters ( MethodContext *pMethodContext, E_CollectionScope eCollScope );
    HRESULT GetExpensiveProperties ( LPCTSTR szPrinter , CInstance *pInstance , bool a_KeysOnly );
    static void UpdateSizesViaPaperSize(DEVMODE *pDevMode);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\printerdriver.cpp ===
//=================================================================

//

// PrinterDriver.cpp -- PrinterDriver association provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/10/98    davwoh        Created
//
//=================================================================

#include "precomp.h"
#include <objpath.h>
#include <DllWrapperBase.h>
#include <WinSpool.h>
#include "prnutil.h"
#include "PrinterDriver.h"
#include <map>

CWin32PrinterDriver MyPrinterDriver(PROPSET_NAME_PrinterDriver, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PrinterDriver::CWin32PrinterDriver
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *                LPCTSTR pszNamespace - Namespace for provider.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32PrinterDriver::CWin32PrinterDriver(LPCWSTR strName, LPCWSTR pszNamespace )
: Provider( strName, pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PrinterDriver::~CWin32PrinterDriver
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32PrinterDriver::~CWin32PrinterDriver ( void )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32PrinterDriver::EnumerateInstances
//
//	Inputs:		MethodContext*	pMethodContext - Context to enum
//								instance data in.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32PrinterDriver::EnumerateInstances( MethodContext*  pMethodContext, long lFlags /*= 0L*/ )
{
    HRESULT  hr = WBEM_S_NO_ERROR;

    // Perform queries
    //================

    TRefPointerCollection<CInstance> printerList;
    CHString sPrinterPath, sPrinterDriverName, sDriverPath;

    // Load the drivers into a map
    STRING2STRING printerDriverMap;
    STRING2STRING::iterator      mapIter;

    PopulateDriverMap(printerDriverMap);

    CInstancePtr pPrinter;

    REFPTRCOLLECTION_POSITION pos;

    // Get all the printers, their attributes, and Driver names

    CHString sQuery1(_T("SELECT __PATH, __RELPATH, DriverName FROM Win32_Printer"));

    if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(sQuery1, &printerList, pMethodContext, IDS_CimWin32Namespace)))
    {
        if ( printerList.BeginEnum( pos ) )
        {

            for (pPrinter.Attach(printerList.GetNext( pos )) ;
                SUCCEEDED(hr) && (pPrinter != NULL );
                pPrinter.Attach(printerList.GetNext( pos )) )
            {

                pPrinter->GetCHString(IDS_DriverName, sPrinterDriverName);

                // See if this driver is in the map
                if( ( mapIter = printerDriverMap.find( sPrinterDriverName ) ) != printerDriverMap.end() )
                {

                    // Grab the path from the printer
                    pPrinter->GetCHString(IDS___Path, sPrinterPath);

                    CInstancePtr pInstance(CreateNewInstance( pMethodContext ), false);
                    // Construct the path for the other end.

                    // Note, it is possible (in fact easy) to have instances where the driver name
                    // isn't really valid.  Per stevm, we should return the instance anyway.

                    CHString sTemp;
                    EscapeBackslashes((*mapIter).second, sTemp);

                    sDriverPath.Format(L"\\\\%s\\%s:CIM_Datafile.Name=\"%s\"",
                        GetLocalComputerName(), IDS_CimWin32Namespace, sTemp);

                    pInstance->SetCHString( IDS_Antecedent, sDriverPath);
                    pInstance->SetCHString( IDS_Dependent, sPrinterPath);

                    hr = pInstance->Commit(  );
                }
            } // IF GetNext Computer System

            printerList.EndEnum();

        } // IF BeginEnum

    } // IF GetInstancesByQuery

    return hr;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32PrinterDriver::GetObject
//
//	Inputs:		CInstance*		pInstance - Instance into which we
//											retrieve data.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32PrinterDriver::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
    HRESULT  hr;

    CInstancePtr pPrinter;

    CHString sPrinterPath, sDriverName, sDriverClass, sDriverPath;

    // Get the two paths they want verified
    pInstance->GetCHString( IDS_Antecedent, sDriverPath );
    pInstance->GetCHString( IDS_Dependent, sPrinterPath );

    // Since we allow for the fact that the Driver may not really be there, we can't
    // use GetObjectByPath the resolve everything for us.  Instead, we must manually
    // parse the object path.
    ParsedObjectPath*    pParsedPath = 0;
    CObjectPathParser    objpathParser;

    // Parse the object path passed to us by CIMOM
    // ==========================================
    int nStatus = objpathParser.Parse( bstr_t(sDriverPath),  &pParsedPath );

    // One of the biggest if statements I've ever written.
    if ( 0 == nStatus )                                                // Did the parse succeed?
    {
        try
        {
            if ((pParsedPath->IsInstance()) &&                                  // Is the parsed object an instance?
            (_wcsicmp(pParsedPath->m_pClass, L"CIM_Datafile") == 0) &&       // Is this the class we expect (no, cimom didn't check)
            (pParsedPath->m_dwNumKeys == 1) &&                              // Does it have exactly one key
            (pParsedPath->m_paKeys[0]) &&                                   // Is the keys pointer null (shouldn't happen)
            ((pParsedPath->m_paKeys[0]->m_pName == NULL) ||                 // Key name not specified or
            (_wcsicmp(pParsedPath->m_paKeys[0]->m_pName, IDS_Name) == 0)) &&  // key name is the right value
                                                                            // (no, cimom doesn't do this for us).
            (V_VT(&pParsedPath->m_paKeys[0]->m_vValue) == CIM_STRING) &&    // Check the variant type (no, cimom doesn't check this either)
            (V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue) != NULL) )         // And is there a value in it?
            {

                sDriverName = V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue);
            }
        }
        catch ( ... )
        {
            objpathParser.Free( pParsedPath );
            throw ;
        }

        // Clean up the Parsed Path
        objpathParser.Free( pParsedPath );
    }

    // First see if the printer exists
    if ( SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath( sPrinterPath, &pPrinter, pInstance->GetMethodContext() )) )
    {
        CHString sPrinterClass, sPrinterDriverName;

        hr = WBEM_E_NOT_FOUND;

        // Just because the object exists, doesn't mean that it is a printer.  Conceivably, we
        // could have been passed a (valid) path to a win32_bios

        pPrinter->GetCHString(IDS___Class, sPrinterClass);
        if (sPrinterClass.CompareNoCase(L"Win32_Printer") == 0)
        {
            if (pPrinter->GetCHString(IDS_DriverName, sPrinterDriverName))
            {

                // Load the drivers into a map
                STRING2STRING printerDriverMap;
                STRING2STRING::iterator      mapIter;

                PopulateDriverMap(printerDriverMap);

                // See if this driver is in the map
                if( ( mapIter = printerDriverMap.find( sPrinterDriverName ) ) != printerDriverMap.end() )
                {

                    // Do the names match?
                    if (sDriverName.CompareNoCase((*mapIter).second) == 0)
                    {
                        // Got one
                        hr = WBEM_S_NO_ERROR;
                    }
                }
            }
        }
    }

    return ( hr );
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32PrinterDriver::PopulateDriverMap
//
//	Inputs:		STRING2STRING &printerDriverMap - map to fill with driver names
//
//	Outputs:	None.
//
//	Returns:	None.
//
//	Comments:
//
////////////////////////////////////////////////////////////////////////

void CWin32PrinterDriver::PopulateDriverMap(STRING2STRING &printerDriverMap)
{
	DRIVER_INFO_3 *pDriverInfo = NULL;
	DWORD dwNeeded, dwReturned;

	// Get the size

    // Use of delay loaded function requires exception handler.
    SetStructuredExceptionHandler seh;
    try
    {
	    ::EnumPrinterDrivers(NULL, NULL, 3, (BYTE *)pDriverInfo, 0, &dwNeeded, &dwReturned);

	    // Allocate the memory and try again
	    pDriverInfo = (DRIVER_INFO_3 *)new BYTE[dwNeeded];

	    if (pDriverInfo != NULL)
	    {
		    try
		    {
			    if (::EnumPrinterDrivers(NULL, NULL, 3, (BYTE *)pDriverInfo, dwNeeded, &dwNeeded, &dwReturned))
			    {
				    // Put the entries into the map
				    for (DWORD x=0; x < dwReturned; x++)
				    {
					    printerDriverMap[pDriverInfo[x].pName] = pDriverInfo[x].pDriverPath;
				    }
			    }
			    else
			    {
				    LogErrorMessage2(L"Can't EnumPrinterDrivers: %d", GetLastError());
			    }
		    }
            catch(Structured_Exception se)
            {
                DelayLoadDllExceptionFilter(se.GetExtendedInfo());    
            }
		    catch ( ... )
		    {
			    delete []pDriverInfo;
			    throw ;
		    }

		    delete []pDriverInfo;
	    }
	    else
	    {
		    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	    }
    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo());    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\printercontroller.cpp ===
//=================================================================

//

// PrinterController.cpp -- PrinterController association provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/10/98    davwoh        Created
//
//=================================================================

#include "precomp.h"
#include "PrinterController.h"

CWin32PrinterController MyPrinterController(PROPSET_NAME_PRINTERCONTROLLER, IDS_CimWin32Namespace);

CWin32PrinterController::CWin32PrinterController( LPCWSTR strName, LPCWSTR pszNamespace )
:	Provider( strName, pszNamespace )
{
}

CWin32PrinterController::~CWin32PrinterController ( void )
{
}

HRESULT CWin32PrinterController::EnumerateInstances( MethodContext*  pMethodContext, long lFlags /*= 0L*/ )
{
    HRESULT		hr	=	WBEM_S_NO_ERROR;

    // Perform queries
    //================

    TRefPointerCollection<CInstance>	printerList;
    TRefPointerCollection<CInstance>	portList;

    CInstancePtr pPrinter;

    REFPTRCOLLECTION_POSITION	pos;

    // Get all the printers and all the ports.

    // !!! NOTE !!!
    // It is barely possible that some of the items under cim_controller may have some sort of key that look like the entries
    // in the printer port.  This code doesn't check for this.

    CHString sQuery1(_T("SELECT __RELPATH, PortName FROM Win32_Printer"));
    CHString sQuery2(_T("SELECT __RELPATH, DeviceID FROM CIM_Controller"));

    // grab all of both items that could be endpoints
    if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(sQuery1, &printerList, pMethodContext, IDS_CimWin32Namespace))
        &&
        SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(sQuery2, &portList, pMethodContext, IDS_CimWin32Namespace)))

    {
        if ( printerList.BeginEnum( pos ) )
        {

            // For each printer, check the ports list for associations

            for (pPrinter.Attach(printerList.GetNext( pos )) ;
                    SUCCEEDED(hr) && ( pPrinter != NULL ) ;
                    pPrinter.Attach(printerList.GetNext( pos )) )
            {
                hr = EnumPortsForPrinter( pPrinter, portList, pMethodContext );
            }	// IF GetNext Computer System

            printerList.EndEnum();

        }	// IF BeginEnum

    }	// IF GetInstancesByQuery

    return hr;

}

HRESULT CWin32PrinterController::EnumPortsForPrinter(
                                                      CInstance*							pPrinter,
                                                      TRefPointerCollection<CInstance>&	portList,
                                                      MethodContext*						pMethodContext )
{

    HRESULT		hr	=	WBEM_S_NO_ERROR;

    CInstancePtr pPort;
    CInstancePtr pInstance;

    REFPTRCOLLECTION_POSITION	pos;

    CHString	strPrinterPath,
        strPortPath;

    // Pull out the object path of the printer as the various
    // ports object paths will be associated to this value

    if ( GetLocalInstancePath( pPrinter, strPrinterPath ) )
    {

        // The PortName element is actually a comma delimited list that contains all the ports for this printer.
        // So, to do the association, I just walk that list and find the matching item in cim_controller.  If there
        // is no match, I'm assuming that this printer port is not something I can do an association to, and return
        // no instance.
        CHStringArray chsaPrinterPortNames;
        CHString sPrinterPortString, sPrinterPortName;
        CHString sPortPortName;
        pPrinter->GetCHString(IDS_PortName, sPrinterPortString);

        // Parse the comma delimited string into a chstringarray
        ParsePort(sPrinterPortString, chsaPrinterPortNames);

        // Walk the array and find a match
        for (DWORD x = 0; x < chsaPrinterPortNames.GetSize(); x++)
        {
            sPrinterPortName = chsaPrinterPortNames[x];

            if ( portList.BeginEnum( pos ) )
            {

                for (pPort.Attach(portList.GetNext( pos ));
                     SUCCEEDED(hr) && ( pPort != NULL ) ;
                    pPort.Attach(portList.GetNext( pos )))
                {

                    // Check if we have an association
                    pPort->GetCHString(IDS_DeviceID, sPortPortName);
                    if (sPortPortName.CompareNoCase(sPrinterPortName) == 0)
                    {
                        // Get the path to the port object and create us an association.

                        if ( GetLocalInstancePath( pPort, strPortPath ) )
                        {

                            pInstance.Attach(CreateNewInstance( pMethodContext ));

                            if ( NULL != pInstance )
                            {
                                pInstance->SetCHString( IDS_Dependent, strPrinterPath );
                                pInstance->SetCHString( IDS_Antecedent, strPortPath );

                                // Invalidates pointer
                                hr = pInstance->Commit(  );
                            }
                            else
                            {
                                hr = WBEM_E_OUT_OF_MEMORY;
                            }

                        }	// IF GetPath to Port Object

                    }	// IF AreAssociated

                }	// WHILE GetNext

                portList.EndEnum();

            }	// IF BeginEnum
        }

    }	// IF GetLocalInstancePath

    return hr;

}

HRESULT CWin32PrinterController::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
    HRESULT		hr;

    CInstancePtr pPrinter;
    CInstancePtr pPort;

    CHString	strPrinterPath,
        strPortPath;

    pInstance->GetCHString( IDS_Dependent, strPrinterPath );
    pInstance->GetCHString( IDS_Antecedent, strPortPath );

    // First see if both objects exist

    if (	SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath( strPrinterPath, &pPrinter, pInstance->GetMethodContext() ))
        &&	SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath( strPortPath, &pPort, pInstance->GetMethodContext() )) )
    {
        CHString sPrinterClass, sPortClass;

        hr = WBEM_E_NOT_FOUND;

        // Just because the object exists, doesn't mean that it is a printer.  Conceivably, we
        // could have been passed a (valid) path to a win32_bios

        pPrinter->GetCHString(IDS___Class, sPrinterClass);
        pPort->GetCHString(IDS___Class, sPortClass);

        if ((sPrinterClass.CompareNoCase(L"Win32_Printer") == 0) &&
            (CWbemProviderGlue::IsDerivedFrom(L"CIM_Controller", sPortClass, pInstance->GetMethodContext(), IDS_CimWin32Namespace )) )
        {
            // The PortName element is actually a comma delimited list that contains all the ports for this printer.
            // So, to do the association, I just walk that list, and find the matching item in cim_controller.  If there
            // is no match, I'm assuming that this printer port is not something I can do an association to, and return
            // no instance.
            CHStringArray chsaPrinterPortNames;
            CHString sPrinterPortString, sPrinterPortName, sPortPortName;

            if (pPrinter->GetCHString(IDS_PortName, sPrinterPortString))
            {
                ParsePort(sPrinterPortString, chsaPrinterPortNames);
                for (DWORD x = 0; x < chsaPrinterPortNames.GetSize(); x++)
                {
                    sPrinterPortName = chsaPrinterPortNames[x];

                    if (pPort->GetCHString(IDS_DeviceID, sPortPortName))
                    {
                        if (sPortPortName.CompareNoCase(sPrinterPortName) == 0)
                        {
                            // Got one
                            hr = WBEM_S_NO_ERROR;
                            break;
                        }
                    }
                }
            }
        }
    }

    return ( hr );
}

void CWin32PrinterController::ParsePort( LPCWSTR szPortNames, CHStringArray &chsaPrinterPortNames )
{
    // While I trim spaces in this routine, further testing suggests that putting spaces in this registry
    // key causes the printer wizard to not function correctly.  After observing this, I decided that putting even
    // more sophisticated parsing in would not be productive.

    int nFind;
    CHString sTemp(szPortNames), sTemp2;

    sTemp.TrimLeft();

    chsaPrinterPortNames.RemoveAll();

    if (!sTemp.IsEmpty())
    {

        // While there is a comma in the string
        while ((nFind = sTemp.Find(_T(','))) > 0)
        {
            sTemp2 = sTemp.Left(nFind);
            sTemp2.TrimRight();

            // Add it to the array
            chsaPrinterPortNames.Add(sTemp2.Left(sTemp2.GetLength() - 1));

            // Re-adjust the string
            sTemp = sTemp.Mid(nFind + 1);
            sTemp.TrimLeft();
        }

        // Process the remaining (or only) entry
        sTemp.TrimRight();

        if (sTemp[sTemp.GetLength()-1] == _T(':'))
        {
            sTemp = sTemp.Left(sTemp.GetLength()-1);
        }

        chsaPrinterPortNames.Add(sTemp);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\printerdriver.h ===
//=================================================================

//

// PrinterDriver.h -- PrinterDriver association provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/10/98    davwoh        Created
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_PrinterDriver L"Win32_PrinterDriverDLL"

typedef std::map<CHString, CHString> STRING2STRING;

class CWin32PrinterDriver : public Provider
{
    
public:
    
    // Constructor/destructor
    //=======================
    
    CWin32PrinterDriver( LPCWSTR strName, LPCWSTR pszNamespace ) ;
    ~CWin32PrinterDriver() ;
    
    // Functions provide properties with current values
    //=================================================
    
    virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
    virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );
    
private:
    void CWin32PrinterDriver::PopulateDriverMap(STRING2STRING &printerDriverMap);

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\printerdriver2.h ===
/******************************************************************

   PrinterDriver.H -- WMI provider class definition

   Generated by Microsoft WBEM Code Generation Engine
 
   Description: 
   

*******************************************************************/

// Property set identification
//============================

#ifndef  _CPrinterDriver_H_
#define  _CPrinterDriver_H_

//
// Provider Name
//
#define PROVIDER_NAME_PRINTERDRIVER		L"Win32_PrinterDriver"

class CPrinterDriver : public Provider 
{
public:

        CPrinterDriver (LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);

        virtual ~CPrinterDriver () ;

        virtual HRESULT EnumerateInstances ( MethodContext *pMethodContext, long lFlags = 0L ) ;
		virtual HRESULT PutInstance  ( const CInstance &Instance, long lFlags );
		virtual HRESULT DeleteInstance ( const CInstance &Instance,  long lFlags );
        virtual HRESULT GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery &Query);
        
        virtual HRESULT ExecMethod(const CInstance& Instance, const BSTR bstrMethodName, CInstance *pInParams, CInstance *pOutParams, long lFlags = 0L);

private:

		HRESULT LoadInstance        (      CInstance *pInstance, DRIVER_INFO_6 *DriverInfo);
		HRESULT FindAndGetDriver    (      CInstance *pInstance);
		HRESULT GetAllPrinterDrivers(      BYTE*     &a_DriverInfo, DWORD     &dwNoDrivers);
        HRESULT ExecAddPrinterDriver(      CInstance *pInParams,    CInstance *pOutParams);

#ifdef _WMI_DELETE_METHOD_
        HRESULT ExecDelPrinterDriver(      CInstance *pInParams,    CInstance *pOutParams);
#endif

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\printerport.h ===
//////////////////////////////////////////////////////////////////////

//

//  PRINTERPORT.h  - header file for printer ports functionality

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//  03/27/2000    amaxa  Created.
//
//////////////////////////////////////////////////////////////////////


#define PROPSET_NAME_TCPPRINTERPORT L"Win32_TCPIPPrinterPort"

                                                                    
class CWin32TCPPrinterPort : public Provider
{
public:
    
    CWin32TCPPrinterPort(
        LPCWSTR strName, 
        LPCWSTR pszNamespace
        );

    ~CWin32TCPPrinterPort(
        VOID
        );

    virtual 
    HRESULT 
    ExecQuery( 
        MethodContext    *pMethodContext, 
        CFrameworkQuery&  pQuery, 
        long              lFlags = 0L);

    virtual 
    HRESULT 
    GetObject( 
        CInstance       *pInstance, 
        long             lFlags, 
        CFrameworkQuery &pQuery);

    virtual 
    HRESULT 
    EnumerateInstances( 
        MethodContext *pMethodContext, 
        long           lFlags = 0L);
    
    
    virtual 
    HRESULT 
    PutInstance( 
        const CInstance &Instance,  
              long       lFlags);

    virtual 
    HRESULT 
    DeleteInstance( 
        const CInstance &Instance,  
              long       lFlags);
        
private:
    
    enum EScope {
        kComplete,
        kKeys
    };

    HRESULT 
    CollectInstances(
        IN MethodContext *pMethodContext,
        IN EScope         eScope
        );

    static
    HRESULT
    GetExpensiveProperties(
        IN LPCWSTR       pszPort, 
        IN CInstance    &Instance
        );    
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\printershare.h ===
//=================================================================

//

// PrinterShare.h -- PrinterShare association provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/10/98    davwoh        Created
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_PrinterShare L"Win32_PrinterShare"

class CWin32PrinterShare : public Provider
{
    
public:
    
    // Constructor/destructor
    //=======================
    
    CWin32PrinterShare(LPCWSTR strName, LPCWSTR pszNamespace ) ;
    ~CWin32PrinterShare() ;
    
    // Functions provide properties with current values
    //=================================================
    
    virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
    virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );
    
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\printerport.cpp ===
//////////////////////////////////////////////////////////////////////

//

//  PRINTERPORT.CPP

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//  03/27/2000    amaxa  Created
//
//////////////////////////////////////////////////////////////////////

#include <precomp.h>
#include <DllWrapperBase.h>
#include <WinSpool.h>
#include "printerport.h"
#include "prnutil.h"
#include "prninterface.h"

LPCWSTR kStandardTCP   = L"Standard TCP/IP Port";
LPCWSTR kPortName      = L"Name";
LPCWSTR kProtocol      = L"Protocol";
LPCWSTR kHostAddress   = L"HostAddress";
LPCWSTR kSNMPCommunity = L"SNMPCommunity";
LPCWSTR kByteCount     = L"ByteCount";
LPCWSTR kQueue         = L"Queue";
LPCWSTR kPortNumber    = L"PortNumber";
LPCWSTR kSNMPEnabled   = L"SNMPEnabled";
LPCWSTR kSNMPDevIndex  = L"SNMPDevIndex";

//
// Property set declaration
//=========================
//
CWin32TCPPrinterPort win32TCPPrinterPort(PROPSET_NAME_TCPPRINTERPORT, IDS_CimWin32Namespace);

/*++

Routine Name

    CWin32TCPPrinterPort::CWin32TCPPrinterPort

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    None

--*/
CWin32TCPPrinterPort :: CWin32TCPPrinterPort (

    IN LPCWSTR strName,
    IN LPCWSTR pszNamespace

) : Provider ( strName, pszNamespace )
{
}

/*++

Routine Name

    CWin32TCPPrinterPort::~CWin32TCPPrinterPort

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    None

--*/
CWin32TCPPrinterPort::~CWin32TCPPrinterPort()
{
}

/*++

Routine Name

    CWin32TCPPrinterPort::ExecQuery

Routine Description:

    Executes a query on a Win32_TCPIPPrinterPort

Arguments:

    pMethodContext - pointer to method context
    lFlags         - flags
    pQuery         - query object

Return Value:

    WBEM HRESULT

--*/
HRESULT
CWin32TCPPrinterPort::
ExecQuery(
    MethodContext *pMethodContext,
    CFrameworkQuery& pQuery,
    long lFlags /*= 0L*/
    )
{
#if NTONLY >= 5

    HRESULT hRes = WBEM_E_NOT_FOUND;

    EScope eScope = kComplete;
    //
    // Getting only the key, whih is the port name, is cheap and requires no special privileges.
    // Getting the complete configuration of ports requires admin privileges
    //
    if (pQuery.KeysOnly())
    {
        eScope = kKeys;
    }

    hRes = CollectInstances(pMethodContext, eScope);

    return hRes;

#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*++

Routine Name

    CWin32TCPPrinterPort::GetObject

Routine Description:

    Gets an instances of a Win32_TCPIPPrinterPort

Arguments:

    pMethodContext - pointer to method context
    lFlags         - flags
    pQuery         - ?

Return Value:

    WBEM HRESULT

--*/
HRESULT
CWin32TCPPrinterPort::
GetObject(
    CInstance       *pInstance,
    long             lFlags,
    CFrameworkQuery &pQuery
    )
{
#if NTONLY >= 5

    HRESULT  hRes;
    CHString csPort;

    hRes = InstanceGetString(*pInstance, kPortName, &csPort, kFailOnEmptyString);

    if (SUCCEEDED(hRes))
    {
        SetCreationClassName(pInstance);
        pInstance->SetWCHARSplat(IDS_SystemCreationClassName, L"Win32_ComputerSystem");

        hRes = GetExpensiveProperties(csPort, *pInstance);
    }

    return hRes;

#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*++

Routine Name

    CWin32TCPPrinterPort::EnumerateInstances

Routine Description:

    Enumerates all instances of Win32_TCPIPPrinterPort

Arguments:

    pMethodContext - pointer to method context
    lFlags         - flags

Return Value:

    WBEM HRESULT

--*/
HRESULT
CWin32TCPPrinterPort::
EnumerateInstances(
    MethodContext *pMethodContext,
    long lFlags /*= 0L*/
    )
{
#if NTONLY >= 5

    HRESULT hRes = WBEM_E_NOT_FOUND;

    hRes = CollectInstances(pMethodContext, kComplete);

    return hRes;

#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}


/*++

Routine Name

    CWin32TCPPrinterPort::CollectInstances

Routine Description:

    Retrieves all instances of Win32_TCPIPPrinterPorts as partof an enumeration

Arguments:

    pMethodContext - pointer to method context
    eScope         - what to retrieve; key only or complete port config
    CwinSpoolApi   - reference to winspool wrapper object

Return Value:

    WBEM HRESULT

--*/
HRESULT
CWin32TCPPrinterPort ::
CollectInstances(
    IN MethodContext *pMethodContext,
    IN EScope         eScope
    )
{
#if NTONLY >= 5
    HRESULT hRes = WBEM_E_NOT_FOUND;

    DWORD  dwError;
    DWORD  cReturned = 0;
    DWORD  cbNeeded  = 0;
    DWORD  cbSize     = 0;
    BYTE  *pPorts     = NULL;

    hRes = WBEM_S_NO_ERROR;

    // Use of delay loaded function requires exception handler.
    SetStructuredExceptionHandler seh;

    try
    {
        if (!::EnumPorts(NULL, 2, NULL, cbSize, &cbNeeded, &cReturned))
        {
            dwError = GetLastError();

            if (dwError==ERROR_INSUFFICIENT_BUFFER)
            {
                hRes = WBEM_E_OUT_OF_MEMORY;

                pPorts = new BYTE[cbSize=cbNeeded];

                if (pPorts)
                {
                    //
                    // The try is to make sure that if an exception occurs, we free the allocated buffer
                    //
                    try
                    {
                        if (::EnumPorts(NULL, 2, pPorts, cbSize, &cbNeeded, &cReturned))
                        {
                            hRes = WBEM_S_NO_ERROR;

                            PORT_INFO_2 *pPortInfo = reinterpret_cast<PORT_INFO_2 *>(pPorts);

                            for (DWORD uIndex = 0; uIndex < cReturned && SUCCEEDED(hRes); uIndex++, pPortInfo++)
                            {
                                //
                                // Check if the port is Standard TCP/IP
                                //
                                if (pPortInfo->pDescription && !wcscmp(pPortInfo->pDescription, kStandardTCP))
                                {
                                    CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

                                    pInstance->SetCHString(kPortName, pPortInfo->pPortName);

									SetCreationClassName(pInstance);
									pInstance->SetWCHARSplat(IDS_SystemCreationClassName, L"Win32_ComputerSystem");

                                    if (eScope==kComplete)
                                    {
                                        //
                                        // This needs admin privileges.
                                        //
                                        hRes = GetExpensiveProperties(pPortInfo->pPortName, pInstance);
                                    }

                                    if(SUCCEEDED(hRes)){
                                        hRes = pInstance->Commit();
                                    }
                                }
                            }
                        }
                        else
                        {
                            hRes = WinErrorToWBEMhResult(GetLastError());
                        }
                    }
                    catch(Structured_Exception se)
                    {
                        DelayLoadDllExceptionFilter(se.GetExtendedInfo());
                        delete [] pPorts;
                        hRes = WBEM_E_FAILED;    
                    }
                    catch(...)
                    {
                        delete [] pPorts;

                        throw;
                    }

                    delete [] pPorts;
                }
            }
            else
            {
                hRes = WinErrorToWBEMhResult(dwError);
            }
        }
    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo()); 
        hRes = WBEM_E_FAILED;   
    }

    return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*++

Routine Name

    CWin32TCPPrinterPort::PutInstance

Routine Description:

    Adds or updates an instances of Win32_TCPIPPrinterPort

Arguments:

    Instance - reference Instance
    lFlags   - flags

Return Value:

    WBEM HRESULT

--*/
HRESULT
CWin32TCPPrinterPort::
PutInstance(
    const CInstance &Instance,
    long            lFlags
    )
{
#if NTONLY >= 5
    HRESULT hRes        = WBEM_S_NO_ERROR;
    DWORD   dwError;
    DWORD   dwOperation = WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_CREATE_OR_UPDATE;

    switch(lFlags & dwOperation)
    {
        case WBEM_FLAG_CREATE_OR_UPDATE:
        case WBEM_FLAG_CREATE_ONLY:
        case WBEM_FLAG_UPDATE_ONLY:
        {
            //
            // Get all the necessary parameters
            //
            PORT_DATA_1     PortData = {0};
            CHString        t_Port;
            CHString        t_HostAddress;
            CHString        t_SNMPCommunity;
            CHString        t_Queue;
            
            //
            // Get port name. This is a required parameter
            //
            if (SUCCEEDED(hRes = InstanceGetString(Instance, kPortName, &t_Port, kFailOnEmptyString)))
            {
                if (t_Port.GetLength() < MAX_PORTNAME_LEN)
                {
                    wcscpy(PortData.sztPortName, static_cast<LPCWSTR>(t_Port));
                }
                else
                {
                    hRes = WBEM_E_INVALID_PARAMETER;
                }
            }

            //
            // Special case when the flag for PutInstance is CREATE_OR_UPDATE.
            // We need to check if the port exists, then update it. If it does
            // not exist then create it
            //
            if (SUCCEEDED(hRes) && 
                (lFlags == WBEM_FLAG_CREATE_OR_UPDATE || lFlags == WBEM_FLAG_UPDATE_ONLY))
            {
                dwError = SplTCPPortGetConfig(t_Port, &PortData);

                switch(dwError)
                {
                case ERROR_SUCCESS:
                    lFlags = WBEM_FLAG_UPDATE_ONLY;
                    DBGMSG(DBG_TRACE, (L"CWin32TCPPrinterPort::PutInstance update instance\n"));
                    break;

                case ERROR_UNKNOWN_PORT:
                case ERROR_INVALID_PRINTER_NAME:
                    lFlags = WBEM_FLAG_CREATE_ONLY;
                    DBGMSG(DBG_TRACE, (L"CWin32TCPPrinterPort::PutInstance create instance\n"));
                    break;

                default:
                    hRes = WinErrorToWBEMhResult(dwError);
                    DBGMSG(DBG_TRACE, (L"CWin32TCPPrinterPort::PutInstance Error %u\n", dwError));
                }                
            }

            if (SUCCEEDED(hRes))
            {
                //
                // Get host address. This is a required parameter only for create.
                //
                if (SUCCEEDED(hRes = InstanceGetString(Instance, kHostAddress, &t_HostAddress, kFailOnEmptyString)))
                {
                    //
                    // Validate argument
                    //
                    if (t_HostAddress.GetLength() < MAX_NETWORKNAME_LEN)
                    {
                        wcscpy(PortData.sztHostAddress, static_cast<LPCWSTR>(t_HostAddress));
                    }
                    else
                    {
                        hRes = WBEM_E_INVALID_PARAMETER;
                    }
                }
                else if (lFlags == WBEM_FLAG_UPDATE_ONLY) 
                {
                    //
                    // We are in update mode. The user did not specify a host address, so we
                    // keep the host address of the port that we update
                    //
                    hRes = WBEM_S_NO_ERROR;
                }
            }

            //
            // Get protocol.
            //
            if (SUCCEEDED(hRes) &&
                SUCCEEDED(hRes = InstanceGetDword(Instance, kProtocol, &PortData.dwProtocol, PortData.dwProtocol)))
            {
                BOOL bDummy;

                switch (PortData.dwProtocol) 
                {
                case 0:

                    //
                    // No protocol was spcified in input. If we are in the update mode
                    // then we keep the setting of the exisiting port that we are updating 
                    //
                    if (lFlags == WBEM_FLAG_CREATE_ONLY) 
                    {
                        //
                        // Go out on the net and get the device settings
                        //
                        DBGMSG(DBG_TRACE, (L"Trying to default TCP settings\n"));

                        hRes = GetDeviceSettings(PortData) ? WBEM_S_NO_ERROR : WBEM_E_INVALID_PARAMETER;
                    }
                    break;

                case LPR:

                    //
                    // Get arguments specific to LPR port. Queue name
                    //
                    if (SUCCEEDED(hRes = InstanceGetString(Instance, kQueue, &t_Queue, kFailOnEmptyString)))
                    {
                        //
                        // Validate argument
                        //
                        if (t_Queue.GetLength() < MAX_QUEUENAME_LEN)
                        {
                            wcscpy(PortData.sztQueue, static_cast<LPCWSTR>(t_Queue));
                        }
                        else
                        {
                            hRes = WBEM_E_INVALID_PARAMETER;
                        }
                    }
                    else if (lFlags == WBEM_FLAG_UPDATE_ONLY) 
                    {
                        //
                        // No queue specified and we are in update mode
                        // We simply keep the queue name of the existing port
                        //
                        hRes = WBEM_S_NO_ERROR;
                    }

                    //
                    // Check if byte counting is enabled. If the user didn't specify any value for it,
                    // we take the default value of what we have already in the port data structure
                    //
                    if (SUCCEEDED(hRes))
                    {
                        hRes = InstanceGetBool(Instance, 
                                               kByteCount, 
                                               &bDummy,
                                               PortData.dwDoubleSpool);

                        PortData.dwDoubleSpool = bDummy;
                    }
                    
                    //
                    // We do not need a break here. We have common code for lpr and raw
                    //

                case RAWTCP:
                    
                    if (SUCCEEDED(hRes = InstanceGetBool(Instance, 
                                                         kSNMPEnabled, 
                                                         &bDummy, 
                                                         PortData.dwSNMPEnabled)) &&
                        (PortData.dwSNMPEnabled = bDummy))
                    {
                        //
                        // Get community name
                        //
                        if (SUCCEEDED(InstanceGetString(Instance, kSNMPCommunity, &t_SNMPCommunity, kFailOnEmptyString)))
                        {
                            if (t_SNMPCommunity.GetLength() < MAX_SNMP_COMMUNITY_STR_LEN)
                            {
                                wcscpy(PortData.sztSNMPCommunity, t_SNMPCommunity);
                            }
                            else
                            {
                                hRes = WBEM_E_INVALID_PARAMETER;
                            }
                        }
                        else if (lFlags == WBEM_FLAG_UPDATE_ONLY) 
                        {
                            //
                            // For update case, we simply keep the exisiting community name
                            //
                            hRes = WBEM_S_NO_ERROR;
                        }

                        //
                        // Get device index
                        //
                        if (SUCCEEDED(hRes))
                        {
                            hRes = InstanceGetDword(Instance, kSNMPDevIndex, &PortData.dwSNMPDevIndex, PortData.dwSNMPDevIndex);
                        }
                    }

                    if (SUCCEEDED(hRes))
                    {
                        //
                        // Get the port number. If the user did not spcify a port, then we use what we have
                        // in the port data. For create case, we will have a 0, for update case we will
                        // have the port number. 
                        //
                        hRes = InstanceGetDword(Instance, kPortNumber, &PortData.dwPortNumber, PortData.dwPortNumber);
                    }

                    break;

                default:

                    hRes = WBEM_E_INVALID_PARAMETER;
                }
            }

            //
            // Make final call. At thsi stage the PortData contains fields initialized either from
            // the input of the caller or by the function that gets prefeered device settings
            //
            if (SUCCEEDED(hRes))
            {
                dwError = lFlags == WBEM_FLAG_CREATE_ONLY ? SplPortAddTCP(PortData) : SplTCPPortSetConfig(PortData);

                if (FAILED(hRes = WinErrorToWBEMhResult(dwError)))
                {
                    SetErrorObject(Instance, dwError, pszPutInstance);
                }
            }
        }

        break;

    default:
        hRes = WBEM_E_PROVIDER_NOT_CAPABLE;
    }

    return hRes;

#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*++

Routine Name

    CWin32TCPPrinterPort::DeleteInstance

Routine Description:

    Deletes an instances of Win32_TCPIPPrinterPort

Arguments:

    Instance - reference Instance
    lFlags   - flags

Return Value:

    WBEM HRESULT

--*/
HRESULT
CWin32TCPPrinterPort::
DeleteInstance(
    const CInstance &Instance,
    long lFlags
    )
{
#if NTONLY == 5
    HRESULT  hRes = WBEM_E_PROVIDER_FAILURE;
    CHString t_Port;
    DWORD    dwError;

    hRes = InstanceGetString(Instance, kPortName, &t_Port , kFailOnEmptyString);

    if (SUCCEEDED(hRes))
    {
        dwError = SplPortDelTCP(t_Port);

        hRes    = WinErrorToWBEMhResult(dwError);

        if (FAILED(hRes))
        {
            SetErrorObject(Instance, dwError, pszDeleteInstance);

            //
            // When we call DeleteInstance and there is no Standard TCP port with the specified
            // name, XcvData returns ERROR_UNKNOWN_PORT. WinErrorToWBEMhResult translates that 
            // to Generic Failure. We really need WBEM_E_NOT_FOUND in this case.
            // 
            if (dwError == ERROR_UNKNOWN_PORT)
            {
                hRes = WBEM_E_NOT_FOUND;
            } 
        }
    }

    return hRes;

#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*++

Routine Name

    CWin32TCPPrinterPort::GetExpensiveProperties

Routine Description:

    Gets all the properties of a Win32_TCPIPPrinterPort

Arguments:

    pszPort  - port name
    Instance - reference to Instance
    lFlags   - reference to winspool wrapper object

Return Value:

    WBEM HRESULT

--*/
HRESULT
CWin32TCPPrinterPort::
GetExpensiveProperties(
    IN LPCWSTR       pszPort,
    IN CInstance    &Instance)
{
#if NTONLY >= 5

    HRESULT     hRes;
    PORT_DATA_1 PortData = {0};
    DWORD       dwError;

    dwError = SplTCPPortGetConfig(pszPort, &PortData);

    hRes    = WinErrorToWBEMhResult(dwError);

    if (SUCCEEDED(hRes))
    {
        Instance.SetDWORD   (kProtocol,      PortData.dwProtocol);
        Instance.SetCHString(kHostAddress,   PortData.sztHostAddress);
        Instance.Setbool    (kSNMPEnabled,   PortData.dwSNMPEnabled);

        if (PortData.dwSNMPEnabled)
        {
            Instance.SetCHString(kSNMPCommunity, PortData.sztSNMPCommunity);
            Instance.SetDWORD   (kSNMPDevIndex,  PortData.dwSNMPDevIndex);
        }

        if (PortData.dwProtocol==PROTOCOL_LPR_TYPE)
        {
            if (PortData.sztQueue[0])
            {
                Instance.SetCHString(kQueue, PortData.sztQueue);
            }

            Instance.Setbool(kByteCount, PortData.dwDoubleSpool);
        }

        Instance.SetDWORD(kPortNumber, PortData.dwPortNumber);
    }
    else
    {
        //
        // NOTE 
        // Now we do not care for access denied. Before
        // security push we used to get access and used 
        // to go on
        //

        if( WBEM_E_ACCESS_DENIED == hRes )
        {

	        hRes = dwError = WBEM_S_NO_ERROR ;

        } else {

	        SetErrorObject(Instance, dwError);

        }
    }

    return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\printerdriver2.cpp ===
////////////////////////////////////////////////////////////////////////

//

//  PrinterDriver2.CPP -- WMI provider class implementation

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//  03/01/2000  a-sandja    Created
//  03/29/2000  amaxa       Added PutInstance, DeleteInstance
//                          ExecAddPrinterDriver, ExecDelPrinterDriver
//
//////////////////////////////////////////////////////////////////////////

#include <precomp.h>
#include <winspool.h>
#include <lockwrap.h>
#include <DllWrapperBase.h>
#include "prninterface.h"
#include "prnutil.h"
#include "printerDriver2.h"


CONST LPCWSTR kAddDriverMethod = L"AddPrinterDriver";

#ifdef _WMI_DELETE_METHOD_
CONST LPCWSTR kDelDriverMethod = L"DeletePrinterDriver";
#endif //_WMI_DELETE_METHOD_

CONST LPCWSTR kDriverName      = L"Name";
CONST LPCWSTR kVersion         = L"Version";
CONST LPCWSTR kEnvironment     = L"SupportedPlatform";
CONST LPCWSTR kDriverPath      = L"DriverPath";
CONST LPCWSTR kDataFile        = L"DataFile";
CONST LPCWSTR kConfigFile      = L"ConfigFile";
CONST LPCWSTR kHelpFile        = L"HelpFile";
CONST LPCWSTR kDependentFiles  = L"DependentFiles";
CONST LPCWSTR kMonitorName     = L"MonitorName";
CONST LPCWSTR kDefaultDataType = L"DefaultDataType";
CONST LPCWSTR kInfName         = L"InfName";
CONST LPCWSTR kFilePath        = L"FilePath";
CONST LPCWSTR kOemUrl          = L"OEMUrl";

CONST LPCWSTR kArgToMethods    = L"DriverInfo";

CONST LPCWSTR kFormatString    = L"%s,%u,%s";


/*****************************************************************************
 *
 *  FUNCTION    :   ConvertDriverKeyToValues
 *
 *  DESCRIPTION :   Helper function. Takes in a string that has the format:
 *                  "string,number,string" that correspomnd to a driver name,
 *                  driver version and environment and returns those entities
 *
 *****************************************************************************/

HRESULT
ConvertDriverKeyToValues(
    IN     CHString  Key,
    IN OUT CHString &DriverName,
    IN OUT DWORD    &dwVersion,
    IN OUT CHString &Environment,
    IN     WCHAR     cDelimiter = L','
    )
{
    HRESULT hRes = WBEM_E_INVALID_PARAMETER;

    if (!Key.IsEmpty())
    {
        CHString t_Middle;

        int iFirst = Key.Find(cDelimiter);
        int iLast  = Key.ReverseFind(cDelimiter);

        if (iFirst>=1 && iLast>=1 && iLast!=iFirst)
        {
            int iLength = Key.GetLength();

            DriverName  = Key.Left(iFirst);
            Environment = Key.Right(iLength - iLast - 1);
            t_Middle    = Key.Mid(iFirst + 1, iLast - iFirst - 1);

            if (1==swscanf(t_Middle, L"%u", &dwVersion))
            {
                hRes = WBEM_S_NO_ERROR;
            }
        }
    }

    return hRes;
}

CPrinterDriver MyPrinterDriver (

	PROVIDER_NAME_PRINTERDRIVER ,
	IDS_CimWin32Namespace
) ;



/*****************************************************************************
 *
 *  FUNCTION    :   CPrinterDriver::CPrinterDriver
 *
 *  DESCRIPTION :   Constructor
 *
 *****************************************************************************/

CPrinterDriver :: CPrinterDriver (

	LPCWSTR lpwszName,
	LPCWSTR lpwszNameSpace

) : Provider ( lpwszName , lpwszNameSpace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    :   CPrinterDriver::~CPrinterDriver
 *
 *  DESCRIPTION :   Destructor
 *
 *****************************************************************************/

CPrinterDriver :: ~CPrinterDriver ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CPrinterDriver::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*****************************************************************************/

HRESULT CPrinterDriver :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags
)
{
#if NTONLY >= 5
	HRESULT hRes = WBEM_S_NO_ERROR;

    DWORD dwBytesNeeded = 0;
	DWORD dwNoDrivers = 0;
	BYTE *pDriverInfo;


	hRes = GetAllPrinterDrivers ( pDriverInfo, dwNoDrivers );
	
	if ( SUCCEEDED ( hRes ) && (dwNoDrivers > 0) )
	{
		if ( pDriverInfo != NULL )
		{
			try
			{
				DRIVER_INFO_6 *pNewDriverInfo = ( DRIVER_INFO_6 *) pDriverInfo;

				for ( int i = 0; i < dwNoDrivers; i++, pNewDriverInfo++ )
				{
					CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), false );

					hRes = LoadInstance ( pInstance, pNewDriverInfo );
					{
						hRes = pInstance->Commit ();

						if ( FAILED ( hRes ) )
						{
							break;
						}
					}
				}
			}
			catch ( ... )
			{
				delete 	[] pDriverInfo;
				pDriverInfo = NULL;
				throw;
			}
			delete [] pDriverInfo ;
			pDriverInfo = NULL;
		}
		else
		{
			hRes = WBEM_E_FAILED;
		}
	}

	return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    :    CPrinterDriver::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class.
*
*****************************************************************************/

HRESULT CPrinterDriver :: GetObject (

	CInstance *pInstance,
	long lFlags ,
	CFrameworkQuery &Query
)
{
#if NTONLY >= 5
    HRESULT hRes = WBEM_S_NO_ERROR;

	hRes = FindAndGetDriver(pInstance);

	return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    : CPrinterDriver::PutInstance
*
*  DESCRIPTION : Adding a driver if it doesnt exist
*
*****************************************************************************/

HRESULT CPrinterDriver :: PutInstance  (

	const CInstance &Instance,
	long lFlags
)
{
#if NTONLY >= 5
    HRESULT  hRes = WBEM_E_PROVIDER_NOT_CAPABLE;
	CHString t_DriverName;
	CHString t_Environment;
    CHString t_InfName;
    CHString t_FilePath;
    CHString t_Key;
	DWORD    dwVersion = 0;
    DWORD    dwPossibleOperations = 0;
	DWORD    dwError = 0;

	dwPossibleOperations = dwPossibleOperations | WBEM_FLAG_CREATE_ONLY;

	if (lFlags & dwPossibleOperations)
    {	
        //
        // Get driver name
        //
        hRes = InstanceGetString(Instance, kDriverName, &t_Key, kFailOnEmptyString);

        if (SUCCEEDED(hRes))
        {
            hRes = ConvertDriverKeyToValues(t_Key, t_DriverName, dwVersion, t_Environment);
        }

        if (SUCCEEDED (hRes))
		{
            //
			// Get inf name. optional argument
            //
            hRes = InstanceGetString(Instance, kInfName, &t_InfName, kAcceptEmptyString);
        }

        if (SUCCEEDED (hRes))
		{
            //
			// Get file path. optional argument
            //
            hRes = InstanceGetString(Instance, kFilePath, &t_FilePath, kAcceptEmptyString);
        }

        if (SUCCEEDED(hRes))
	    {
            dwError = SplDriverAdd(t_DriverName,
                                   dwVersion,
                                   t_Environment.IsEmpty() ? static_cast<LPCTSTR>(NULL) : t_Environment,
                                   t_InfName.IsEmpty()     ? static_cast<LPCTSTR>(NULL) : t_InfName,
                                   t_FilePath.IsEmpty()    ? static_cast<LPCTSTR>(NULL) : t_FilePath);

			hRes = WinErrorToWBEMhResult(dwError);			

            if (FAILED(hRes))
            {
                SetErrorObject(Instance, dwError, pszPutInstance);
            }            
		}		
	}

   return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    :    CPrinterDriver:: DeleteInstance
*
*  DESCRIPTION :    Deleting a PrinterDriver
*
*****************************************************************************/

HRESULT CPrinterDriver :: DeleteInstance (

	const CInstance &Instance,
	long lFlags
)
{
#if NTONLY >= 5
	HRESULT  hRes          = WBEM_E_PROVIDER_FAILURE;
	DWORD    dwError       = 0;
    DWORD    dwVersion     = 0;
    CHString t_DriverName;
	CHString t_Environment;
    CHString t_Key;

    //
    // Get driver name
    //
    hRes = InstanceGetString(Instance, kDriverName, &t_Key, kFailOnEmptyString);

    if (SUCCEEDED(hRes))
    {
        hRes = ConvertDriverKeyToValues(t_Key, t_DriverName, dwVersion, t_Environment);
    }

    if (SUCCEEDED(hRes))
    {
        dwError = SplDriverDel(t_DriverName, dwVersion, t_Environment);

        hRes    = WinErrorToWBEMhResult(dwError);
		
        if (FAILED(hRes))
        {
            SetErrorObject(Instance, dwError, pszDeleteInstance);

            //
            // When we call DeleteInstance and there is no printer driver with the specified
            // name, DeletePrinterDriver returns ERROR_UNKNOWN_PRINTER_DRIVER. WinErrorToWBEMhResult 
            // translates that to Generic Failure. We really need WBEM_E_NOT_FOUND in this case.
            // 
            if (dwError == ERROR_UNKNOWN_PRINTER_DRIVER)
            {
                hRes = WBEM_E_NOT_FOUND;
            } 
        }	  	
	}

    return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    :    CPrinterDriver::LoadInstance
*
*  DESCRIPTION :    Loads the properties into the instance
*
*****************************************************************************/
HRESULT CPrinterDriver :: LoadInstance (
										
	CInstance *pInstance,
	DRIVER_INFO_6 *pDriverInfo
)
{
	HRESULT  hRes = WBEM_E_PROVIDER_FAILURE;
    CHString t_FullName;

    SetCreationClassName(pInstance);

    pInstance->SetWCHARSplat(IDS_SystemCreationClassName, L"Win32_ComputerSystem");
	
    t_FullName.Format(kFormatString, pDriverInfo->pName, pDriverInfo->cVersion, pDriverInfo->pEnvironment);

    if (                                   pInstance->SetCHString(kDriverName,      t_FullName)             &&
                                           pInstance->SetDWORD   (kVersion,         pDriverInfo->cVersion)          &&
                                           pInstance->SetCHString(kEnvironment,     pDriverInfo->pEnvironment)      &&
        (!pDriverInfo->pDriverPath      || pInstance->SetCHString(kDriverPath,      pDriverInfo->pDriverPath))      &&
        (!pDriverInfo->pDataFile        || pInstance->SetCHString(kDataFile,        pDriverInfo->pDataFile))        &&
    	(!pDriverInfo->pConfigFile      || pInstance->SetCHString(kConfigFile,      pDriverInfo->pConfigFile))      &&
    	(!pDriverInfo->pHelpFile        || pInstance->SetCHString(kHelpFile,        pDriverInfo->pHelpFile))        &&
    	(!pDriverInfo->pMonitorName     || pInstance->SetCHString(kMonitorName,     pDriverInfo->pMonitorName))     &&
        (!pDriverInfo->pDefaultDataType || pInstance->SetCHString(kDefaultDataType, pDriverInfo->pDefaultDataType)) &&
    	(!pDriverInfo->pszOEMUrl        || pInstance->SetCHString(kOemUrl,          pDriverInfo->pszOEMUrl)))
    {
        SAFEARRAY *pArray = NULL;

        hRes = CreateSafeArrayFromMultiSz(pDriverInfo->pDependentFiles, &pArray);

        if (SUCCEEDED(hRes))
        {
            //
            // We succeed in the case when there are no dependent files, too.
            // We need to check that case
            //
            if (pArray)
            {
                if (!pInstance->SetStringArray(kDependentFiles, *pArray))
                {
				    hRes = WBEM_E_PROVIDER_FAILURE;
				}
				
                SafeArrayDestroy(pArray);
            }
        }
    }

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CPrinterDriver::FindPrinterDriver
*
*  DESCRIPTION :    Checks if the Given driver exists, if not it return
*					WBEM_E_NOT_FOUND
*
*****************************************************************************/
HRESULT CPrinterDriver::FindAndGetDriver (
					
	CInstance *pInstance
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

    CHString t_Key;
	CHString t_DriverName;
	DWORD    dwVersion;
	CHString t_Environment;

	if SUCCEEDED ( hRes = InstanceGetString(*pInstance, kDriverName, &t_Key, kFailOnEmptyString) )
	{
		if SUCCEEDED( hRes =ConvertDriverKeyToValues(t_Key, t_DriverName, dwVersion, t_Environment) )
		{
			// enumerate all the drivers and check if the drivers already exist
			BYTE *pDriverInfo = NULL;
			DWORD dwNoOfDrivers;

			hRes = GetAllPrinterDrivers(pDriverInfo, dwNoOfDrivers);

			if (SUCCEEDED(hRes) && pDriverInfo)
			{
				try
				{
					DRIVER_INFO_6 *pNewDriverInfo = reinterpret_cast<DRIVER_INFO_6 *>(pDriverInfo);

					hRes = WBEM_E_NOT_FOUND;

					for ( int i = 0; i < dwNoOfDrivers; i++, pNewDriverInfo++ )
					{
						CHString t_TempDriverName(pNewDriverInfo->pName);
						CHString t_TempEnvironment(pNewDriverInfo->pEnvironment);

						if (t_DriverName.CompareNoCase(t_TempDriverName)   == 0  &&
							t_Environment.CompareNoCase(t_TempEnvironment) == 0  &&
							dwVersion == pNewDriverInfo->cVersion)	
						{
							hRes = LoadInstance(pInstance, pNewDriverInfo);

							break;					
						}
					}
				}
				catch ( ... )
				{
					delete [] pDriverInfo;
					pDriverInfo = NULL;
					throw;
				}
					
				delete [] pDriverInfo;
				pDriverInfo = NULL;			
			}
		}
	}

	if ( hRes == WBEM_E_INVALID_PARAMETER )
	{
		hRes = WBEM_E_NOT_FOUND;
	}

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CPrinterDriver::GetAllPrinterDrivers
*
*  DESCRIPTION :    Reads the instances of All the drivers on a local machine.
*
*****************************************************************************/
HRESULT CPrinterDriver :: GetAllPrinterDrivers (
												
	BYTE* &a_pDriverInfo,
	DWORD &dwNoDrivers
)
{
	HRESULT hRes = WBEM_E_FAILED;
	DWORD dwError;
    DWORD dwBytesNeeded = 0;

    a_pDriverInfo = NULL;

    hRes = WBEM_S_NO_ERROR;

    // Use of delay loaded functions requires exception handler.
    SetStructuredExceptionHandler seh;

    try
    {
        if (!::EnumPrinterDrivers(NULL, TEXT("all"), 6, a_pDriverInfo, 0, &dwBytesNeeded, &dwNoDrivers))
        {
            dwError = GetLastError();

		    if (dwError==ERROR_INSUFFICIENT_BUFFER)
		    {
                a_pDriverInfo = new BYTE [dwBytesNeeded];

			    if (a_pDriverInfo)
			    {
                    if (!::EnumPrinterDrivers(NULL, TEXT("all"), 6, a_pDriverInfo,  dwBytesNeeded, &dwBytesNeeded, &dwNoDrivers))
                    {
                        delete 	[] a_pDriverInfo;
					    
					    dwError = GetLastError();

                        hRes = WinErrorToWBEMhResult(dwError);
				    }
			    }
			    else
			    {
				    hRes = WBEM_E_OUT_OF_MEMORY;
			    }
		    }
            else
            {
                hRes = WinErrorToWBEMhResult(dwError);
            }
	    }
    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        hRes = WBEM_E_FAILED;
    }

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CPrinterDriver::ExecMethod
*
*  DESCRIPTION :    Implementation for the Printer Driver Methods
*
*****************************************************************************/

HRESULT CPrinterDriver :: ExecMethod (

	const CInstance &Instance,
	const BSTR       bstrMethodName,
          CInstance *pInParams,
          CInstance *pOutParams,
          long       lFlags
)
{
#if NTONLY >= 5
	HRESULT hRes = WBEM_E_INVALID_PARAMETER;

    if (pOutParams)
	{
		if (!_wcsicmp(bstrMethodName, kAddDriverMethod))
		{
			hRes = ExecAddPrinterDriver(pInParams, pOutParams);
		}
#ifdef _WMI_DELETE_METHOD_
		else
		if (!_wcsicmp(bstrMethodName, kDelDriverMethod))
		{
			hRes = ExecDelPrinterDriver(pInParams, pOutParams);
		}
#endif //_WMI_DELETE_METHOD_
        else
		{
			hRes = WBEM_E_PROVIDER_NOT_CAPABLE;
		}
	}

	return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    :    CPrinterDriver::ExecAddPrinterDriver
*
*  DESCRIPTION :    Adds a printer driver. VErsion and Environment are optional
*
*****************************************************************************/

HRESULT CPrinterDriver :: ExecAddPrinterDriver (

    CInstance *pInParams,
    CInstance *pOutParams
)
{
#if NTONLY >= 5
    HRESULT				hRes         = WBEM_E_INVALID_PARAMETER;
    CHString			t_DriverName;
    CHString            t_Environment;
    CHString            t_InfName;
    CHString            t_FilePath;
    DWORD               dwVersion;
	bool				t_Exists;
	VARTYPE				t_Type;
    CInstancePtr        t_EmbeddedObject;

	if (pInParams->GetStatus(kArgToMethods, t_Exists, t_Type) &&
        t_Exists &&
        pInParams->GetEmbeddedObject(kArgToMethods, &t_EmbeddedObject, pInParams->GetMethodContext()))
    {
        //
        // Get driver name
        //
        hRes = InstanceGetString(t_EmbeddedObject, kDriverName, &t_DriverName, kFailOnEmptyString);

		if (SUCCEEDED (hRes))
		{
            //
			// Get driver environment
            //
            hRes = InstanceGetString(t_EmbeddedObject, kEnvironment, &t_Environment, kAcceptEmptyString);
        }

        if (SUCCEEDED (hRes))
		{
            //
			// Get inf name. optional argument
            //
            hRes = InstanceGetString(t_EmbeddedObject, kInfName, &t_InfName, kAcceptEmptyString);
        }

        if (SUCCEEDED (hRes))
		{
            //
			// Get file path. optional argument
            //
            hRes = InstanceGetString(t_EmbeddedObject, kFilePath, &t_FilePath, kAcceptEmptyString);
        }

        if (SUCCEEDED (hRes))
		{
            //
			// Get driver version. Will be defaulted to -1
            //
            hRes = InstanceGetDword(t_EmbeddedObject, kVersion, &dwVersion);
        }

        if (SUCCEEDED(hRes))
	    {
            DWORD dwError = SplDriverAdd(t_DriverName,
                                         dwVersion,
                                         t_Environment.IsEmpty() ? static_cast<LPCTSTR>(NULL) : t_Environment,
                                         t_InfName.IsEmpty()     ? static_cast<LPCTSTR>(NULL) : t_InfName,
                                         t_FilePath.IsEmpty()    ? static_cast<LPCTSTR>(NULL) : t_FilePath);

			SetReturnValue(pOutParams, dwError);			            
		}	
	}

	return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

#ifdef _WMI_DELETE_METHOD_
/*****************************************************************************
*
*  FUNCTION    :    CPrinterDriver::ExecDelPrinterDriver
*
*  DESCRIPTION :    This method will delete a given printer driver
*
*****************************************************************************/

HRESULT CPrinterDriver :: ExecDelPrinterDriver (

    CInstance *pInParams,
    CInstance *pOutParams
)
{
#if NTONLY >= 5
    HRESULT				hRes         = WBEM_E_INVALID_PARAMETER;
    CHString			t_DriverName;
    CHString            t_Environment;
    DWORD               dwVersion;
	bool				t_Exists;
	VARTYPE				t_Type;
    CInstancePtr        t_EmbeddedObject;

	if (pInParams->GetStatus(kArgToMethods, t_Exists, t_Type) &&
        t_Exists &&
        pInParams->GetEmbeddedObject(kArgToMethods, &t_EmbeddedObject, pInParams->GetMethodContext()))
    {
        //
        // Get driver name
        //
        hRes = InstanceGetString(t_EmbeddedObject, kDriverName, &t_DriverName, kFailOnEmptyString);

		if (SUCCEEDED (hRes))
		{
            //
			// Get driver environment
            //
            hRes = InstanceGetString(t_EmbeddedObject, kEnvironment, &t_Environment, kAcceptEmptyString);
        }

        if (SUCCEEDED (hRes))
		{
            //
			// Get driver version. Will be defaulted to -1
            //
            hRes = InstanceGetDword(t_EmbeddedObject, kVersion, &dwVersion);
        }

        if (SUCCEEDED(hRes))
	    {
            DWORD dwError = SplDriverDel(t_DriverName,
                                         dwVersion,
                                         t_Environment.IsEmpty() ? static_cast<LPCTSTR>(NULL) : t_Environment);

			SetReturnValue(pOutParams, dwError);			
		}
	}

	return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

#endif //_WMI_DELETE_METHOD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\printershare.cpp ===
//=================================================================

//

// PrinterShare.cpp -- PrinterShare association provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/10/98    davwoh        Created
//
//=================================================================

#include "precomp.h"
#include <objpath.h>
#include <winspool.h>
#include "PrinterShare.h"

CWin32PrinterShare MyPrinterShare(PROPSET_NAME_PrinterShare, IDS_CimWin32Namespace);

CWin32PrinterShare::CWin32PrinterShare(LPCWSTR strName, LPCWSTR pszNamespace )
: Provider( strName, pszNamespace )
{
}

CWin32PrinterShare::~CWin32PrinterShare ( void )
{
}

HRESULT CWin32PrinterShare::EnumerateInstances( MethodContext*  pMethodContext, long lFlags /*= 0L*/ )
{
    HRESULT  hr = WBEM_S_NO_ERROR;

    // Perform queries
    //================

    TRefPointerCollection<CInstance> printerList;
    CHString sPrinterPath, sPrinterShareName, sSharePath;

    CInstancePtr pPrinter;

    REFPTRCOLLECTION_POSITION pos;

    // Get all the printers, their attributes, and share names

    CHString sQuery1(_T("SELECT __PATH, __RELPATH, Attributes, ShareName FROM Win32_Printer"));

    if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(sQuery1, &printerList, pMethodContext, IDS_CimWin32Namespace)))
    {
        if ( printerList.BeginEnum( pos ) )
        {

            // For each printer, see if it is a locally shared printer
            for (pPrinter.Attach(printerList.GetNext( pos )) ;
                SUCCEEDED(hr) && ( pPrinter != NULL ) ;
                pPrinter.Attach(printerList.GetNext( pos )) )
            {

                DWORD dwAttributes;

                pPrinter->GetDWORD(IDS_Attributes, dwAttributes);

                // If it's not a network printer, but is shared, we've got one
                if (((dwAttributes & PRINTER_ATTRIBUTE_NETWORK) == 0) &&
                    ((dwAttributes & PRINTER_ATTRIBUTE_SHARED)  != 0))
                {
                    // Grab the path fromt the printer
                    pPrinter->GetCHString(IDS___Path, sPrinterPath);

                    CInstancePtr pInstance(CreateNewInstance( pMethodContext ), false);
                    // Construct the path for the other end.

                    // Note, it is possible (in fact easy) to have instances where the share name
                    // isn't really valid.  Per stevm, we should return the instance anyway.
                    pPrinter->GetCHString(IDS_ShareName, sPrinterShareName);
                    sSharePath.Format(L"\\\\%s\\%s:Win32_Share.Name=\"%s\"",
                            GetLocalComputerName(), IDS_CimWin32Namespace, sPrinterShareName);

                    pInstance->SetCHString( IDS_Antecedent, sPrinterPath );
                    pInstance->SetCHString( IDS_Dependent, sSharePath );

                    hr = pInstance->Commit(  );
                }

            } // IF GetNext Computer System

            printerList.EndEnum();

        } // IF BeginEnum

    } // IF GetInstancesByQuery

    return hr;

}

HRESULT CWin32PrinterShare::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
    HRESULT  hr;

    CInstancePtr pPrinter;
    CInstancePtr pShare;
    DWORD dwAttributes;

    CHString sPrinterPath, sShareName, sShareClass, sSharePath;

    // Get the two paths they want verified
    pInstance->GetCHString( IDS_Antecedent, sPrinterPath );
    pInstance->GetCHString( IDS_Dependent, sSharePath );

    // Since we allow for the fact that the share may not really be there, we can't
    // use GetObjectByPath the resolve everything for us.  Instead, we must manually
    // parse the object path.
    ParsedObjectPath*    pParsedPath = 0;
    CObjectPathParser    objpathParser;

    // Parse the object path passed to us by CIMOM
    // ==========================================
    int nStatus = objpathParser.Parse( sSharePath,  &pParsedPath );

    // One of the biggest if statements I've ever written.
    if ( 0 == nStatus )                                                 // Did the parse succeed?
    {
        try
        {
            if ((pParsedPath->IsInstance()) &&                                  // Is the parsed object an instance?
                (_wcsicmp(pParsedPath->m_pClass, L"Win32_Share") == 0) &&       // Is this the class we expect (no, cimom didn't check)
                (pParsedPath->m_dwNumKeys == 1) &&                              // Does it have exactly one key
                (pParsedPath->m_paKeys[0]) &&                                   // Is the keys pointer null (shouldn't happen)
                ((pParsedPath->m_paKeys[0]->m_pName == NULL) ||                 // Key name not specified or
                (_wcsicmp(pParsedPath->m_paKeys[0]->m_pName, IDS_Name) == 0)) &&  // key name is the right value
                                                                                // (no, cimom doesn't do this for us).
                (V_VT(&pParsedPath->m_paKeys[0]->m_vValue) == CIM_STRING) &&    // Check the variant type (no, cimom doesn't check this either)
                (V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue) != NULL) )         // And is there a value in it?
            {

                sShareName = V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue);
            }
        }
        catch ( ... )
        {
            objpathParser.Free( pParsedPath );
            throw ;
        }

        // Clean up the Parsed Path
        objpathParser.Free( pParsedPath );
    }

    // First see if the printer exists
    if ( SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath( sPrinterPath, &pPrinter, pInstance->GetMethodContext() )) )
    {
        CHString sPrinterClass, sPrinterShareName;

        hr = WBEM_E_NOT_FOUND;

        // Just because the object exists, doesn't mean that it is a printer.  Conceivably, we
        // could have been passed a (valid) path to a win32_bios

        pPrinter->GetCHString(IDS___Class, sPrinterClass);
        if ((sPrinterClass.CompareNoCase(L"Win32_Printer") == 0) )
        {
            // Note, it is possible (in fact easy) to have instances where the share name
            // isn't really valid.
            //
            // 1) Use printer wizard to add a printer, share it.
            // 2) Use net use <printershare> /d
            //
            // Printer wizard, win32_printer, etc still believe it's shared, but it ain't.
            // Per stevm, we should return the instance anyway.
            if ((pPrinter->GetCHString(IDS_ShareName, sPrinterShareName)) &&
                (pPrinter->GetDWORD(IDS_Attributes, dwAttributes)) )
            {
                // Do the names match?  Is this a local printer?  Is it shared?
                if ((sShareName.CompareNoCase(sPrinterShareName) == 0) &&
                    ((dwAttributes & PRINTER_ATTRIBUTE_NETWORK) == 0) &&
                    ((dwAttributes & PRINTER_ATTRIBUTE_SHARED)  != 0))
                {
                    // Got one
                    hr = WBEM_S_NO_ERROR;
                }
            }
        }
    }

    return ( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\printjob.cpp ===
//////////////////////////////////////////////////////////////////////

//

//  PRINTJOB.CPP  - Implementation of Provider for user print-dwJobs

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//
//  10/17/96    jennymc     Enhanced
//  10/27/97    davwoh      Moved to curly
//  1/12/98     a-brads     Passed off to Moe and Larry.
//  07/24/00    amaxa       Rewrote GetObject and ExecPrinterOp
//
//////////////////////////////////////////////////////////////////////

#include <precomp.h>

#include <lockwrap.h>
#include <DllWrapperBase.h>
#include <winspool.h>

#include "printjob.h"
#include "resource.h"
#include "prnutil.h"

CWin32PrintJob PrintJobs ( PROPSET_NAME_PRINTJOB , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PrintJob::CWin32PrintJob
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32PrintJob :: CWin32PrintJob (

    LPCWSTR name, 
    LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PrintJob::CWin32PrintJob
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32PrintJob :: ~CWin32PrintJob ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PrintJob::GetObject
 *
 *  DESCRIPTION : 
 *
 *  INPUTS      : 
 *
 *  OUTPUTS     : 
 *
 *  RETURNS     : 
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/

HRESULT CWin32PrintJob :: GetObject (

    CInstance *pInstance, 
    long lFlags /*= 0L*/
)
{
    CHString t_String;
    CHString csPrinter;
    DWORD    dwPos;
    HRESULT  hRes = WBEM_S_NO_ERROR;
    
    hRes = InstanceGetString(*pInstance, IDS_Name, &t_String, kFailOnEmptyString);
    
    if (SUCCEEDED(hRes)) 
    {
        //
        // Isolate  a JobId and PrinterName from the PrintJob key
        // The key is of the form "printername, 123"
        //
        dwPos = t_String.Find(L',');

        csPrinter   = t_String.Left(dwPos);

        //
        // Check if the printer is a local printer or a printer connection.
        // We want to disallow the following scenario:
        // User connects remotely to winmgmt on server \\srv
        // User does GetObject on printer \\prnsrv\prn which is not local and
        // the user doesn't have a connection to. Normally this call succeeds,
        // because the spooler goes accross the wire. This means that you can
        // do GetObject on an instance that cannot be returned by EnumInstances.
        // This is inconsistent with WMI.
        //
        BOOL bInstalled = FALSE;

        //
        // Get the error code of the execution of SplIsPrinterInstalled
        //
        hRes = WinErrorToWBEMhResult(SplIsPrinterInstalled(csPrinter, &bInstalled));

        //
        // Check if the printer is installed locally or not
        //
        if (SUCCEEDED(hRes) && !bInstalled) 
        {
            hRes = WBEM_E_NOT_SUPPORTED;
        }
        
        if (SUCCEEDED(hRes)) 
        {
            CHString csJob;
            DWORD    dwJobId = 0;
    
            csJob       = t_String.Mid(dwPos+1);
    
            dwJobId     = _wtoi(csJob);
            
            hRes        = WBEM_E_FAILED;
    
            SmartClosePrinter hPrinter;
            DWORD             dwError  = ERROR_SUCCESS;
            DWORD             cbNeeded = 0;
            
            //
            // The code in the if statement uses dwError and Win32 error codes. Below 
            // we will convert the Win32 error code to a WBEM error code
            //
            BYTE *pBuf = NULL;
            
            // Use of delay loaded functions requires exception handler.
            SetStructuredExceptionHandler seh;

            try
            {
                if (::OpenPrinter((LPTSTR)(LPCTSTR)TOBSTRT(csPrinter), &hPrinter, NULL))
                {
                    if (!::GetJob(hPrinter, dwJobId, ENUM_LEVEL, NULL, 0, &cbNeeded) &&
                        (dwError = GetLastError()) == ERROR_INSUFFICIENT_BUFFER)
                    {
                        //
                        // SetCHString and AssignPrintJobFields can throw
                        //
                        
                        if (pBuf = new BYTE[cbNeeded]) 
                        {
                            if (::GetJob(hPrinter, dwJobId, ENUM_LEVEL, pBuf, cbNeeded, &cbNeeded)) 
                            {
                                pInstance->SetCHString(IDS_Caption, t_String);
                                pInstance->SetCHString(IDS_Description, t_String);
                                
                                AssignPrintJobFields(pBuf, pInstance);
                        
                                dwError = ERROR_SUCCESS;
                            }
                            else
                            {
                                dwError = GetLastError();
                            }
                        }
                        else
                        {
                            dwError = ERROR_NOT_ENOUGH_MEMORY;
                        }
                        
                        
                    }
                    else
                    {
                        dwError = GetLastError();                
                    }
                }
                else
                {
                    dwError = GetLastError();                
                }
            }
            catch(Structured_Exception se)
            {
                DelayLoadDllExceptionFilter(se.GetExtendedInfo());
                if(pBuf)
                {
                    delete [] pBuf;
                    pBuf = NULL;
                }
                hRes = WBEM_E_FAILED;
            }
            catch(...)
            {
                if(pBuf)
                {
                    delete [] pBuf;
                    pBuf = NULL;
                }

                // It was not a delay load related exception...
                throw;
            }

            if (FAILED(hRes = WinErrorToWBEMhResult(dwError)))
            {
                
                // GetJob returns ERROR_INVALID_PARAMETER if it cannot find the job. This 
                // translates to GENERIC_FAILURE in the provider, which is not what we want.
                // The provider needs to return WBEM_E_NOT_FOUND in this case

                if(dwError == ERROR_INVALID_PARAMETER)
                {
                    hRes = WBEM_E_NOT_FOUND;
                }
                
                //
                // Our caller was PutInstance/DeleteInstance. We use 
                // SetStatusObject to set extended error information
                //
                
                SetErrorObject(*pInstance, dwError, pszDeleteInstance);

            }
            
        }
    }
    
    return hRes;

}

/*****************************************************************************
*
*  FUNCTION    :    CWin32PrintJob:: DeleteInstance
*
*  DESCRIPTION :    Deleting a Print Job
*
*****************************************************************************/

HRESULT CWin32PrintJob :: DeleteInstance (

    const CInstance &Instance, 
          long       lFlags
)
{   
    return ExecPrinterOp(Instance, NULL, JOB_CONTROL_DELETE);            
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PrintJob::EnumerateInstances
 *
 *  DESCRIPTION : 
 *
 *  INPUTS      : 
 *
 *  OUTPUTS     : 
 *
 *  RETURNS     : 
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/

HRESULT CWin32PrintJob::EnumerateInstances (

    MethodContext *pMethodContext, 
    long lFlags /*= 0L*/
)
{
    char  buffer[200]; //debug 7/15/1999
    HRESULT hr = WBEM_S_NO_ERROR;

    //==================================================
    //  Get a list of printers and assign the ptr
    //==================================================

    DWORD dwNumberOfPrinters = 0;
    LPBYTE pBuff = NULL;

    hr = AllocateAndInitPrintersList ( &pBuff , dwNumberOfPrinters  ) ;

    PPRINTER_INFO_1 pPrinter = (PPRINTER_INFO_1) pBuff ;

    //==================================================
    //  Now, go thru them one at a time
    //==================================================
    if ( pPrinter )
    {
        // Use of delay loaded functions requires exception handler.
        SetStructuredExceptionHandler seh;

        try
        {
            for ( DWORD i=0; i < dwNumberOfPrinters && SUCCEEDED(hr); i++)
            {
                SmartClosePrinter t_hPrinter ;

                if ( ::OpenPrinter ( pPrinter->pName, &t_hPrinter, NULL ) == TRUE ) 
                {
                    sprintf(buffer,"%S",pPrinter->pName);

                    DWORD dwJobId = NO_SPECIFIC_PRINTJOB ;

                    hr = GetAndCommitPrintJobInfo(t_hPrinter, 
                                                  pPrinter->pName,
                                                  dwJobId, 
                                                  pMethodContext, 
                                                  NULL);

                    pPrinter ++ ;                       
                }
                else
                {
                    DWORD dwErr = GetLastError();
                }
            }
        }
        catch(Structured_Exception se)
        {
            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
            delete [] pBuff ;
            pBuff = NULL;
            hr = WBEM_E_FAILED;
        }
        catch(...)
        {
            delete [] pBuff ;
            pBuff = NULL;
            throw ;
        }

        delete [] pBuff ;
    }

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PrintJob::CWin32PrintJob
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

void CWin32PrintJob :: AssignPrintJobFields (

    LPVOID lpJob, 
    CInstance *pInstance
)
{
    LPJOB_INFO_2 pJobInfo = ( LPJOB_INFO_2 ) lpJob ;


    // Setting the properties for the JOB_INFO_2.
    // ==========================================

    //Note that IDS_Name,IDS_Caption and IDS_Description are set
    //elsewere - in the caller

    /*
    CHString sName ;
    sName = pJobInfo->pPrinterName;
    sName += _T(", ");

    TCHAR szBuff [ MAXITOA ] ;
    sName += _itot ( pJobInfo->JobId , szBuff, 10 ) ;

    pInstance->SetCHString (IDS_Name, sName ) ;

    pInstance->SetCHString ( IDS_Caption , sName ) ;

    pInstance->SetCHString ( IDS_Description , sName ) ;
    */

    pInstance->SetDWORD ( IDS_JobId, pJobInfo->JobId ) ;

    pInstance->SetCharSplat ( IDS_Document , pJobInfo->pDocument ) ;

    CHString t_chsNotifyName( pJobInfo->pNotifyName ) ;
    pInstance->SetCharSplat ( IDS_Notify , t_chsNotifyName ) ;

    pInstance->SetDWORD ( IDS_Priority , pJobInfo->Priority ) ;

    //
    // Special case here. The start and until time are in universal time.
    // we need to convert it to local time
    //
    SYSTEMTIME StartTime = {0};
    SYSTEMTIME UntilTime = {0};
    CHString   csTime;

    PrinterTimeToLocalTime(pJobInfo->StartTime, &StartTime);
    PrinterTimeToLocalTime(pJobInfo->UntilTime, &UntilTime);

    //
    // If the job can be printed any time, then we do not set the StartTime
    // 
    //
    if (StartTime.wHour!=UntilTime.wHour || StartTime.wMinute!=UntilTime.wMinute)
    {
        csTime.Format(kDateTimeFormat, StartTime.wHour, StartTime.wMinute);

        pInstance->SetCHString(IDS_StartTime, csTime);

        csTime.Format(kDateTimeFormat, UntilTime.wHour, UntilTime.wMinute);

        pInstance->SetCHString(IDS_UntilTime, csTime);
    }
    
    if ( pJobInfo->Time == 0 )
    {
        pInstance->SetTimeSpan ( IDS_ElapsedTime , WBEMTimeSpan (0,0,0,pJobInfo->Time) ) ;
    }
        
    pInstance->SetDateTime(IDS_TimeSubmitted, pJobInfo->Submitted);

    pInstance->SetCharSplat ( IDS_Owner , pJobInfo->pUserName ) ;

    pInstance->SetCharSplat ( IDS_HostPrintQueue , pJobInfo->pMachineName ) ;

    pInstance->SetDWORD ( IDS_PagesPrinted, pJobInfo->PagesPrinted ) ;

    pInstance->SetDWORD ( IDS_Size, pJobInfo->Size ) ;

    pInstance->SetDWORD ( IDS_TotalPages, pJobInfo->TotalPages ) ;

    pInstance->SetCharSplat ( IDS_DriverName , pJobInfo->pDriverName ) ;

    pInstance->SetCharSplat ( IDS_Parameters, pJobInfo->pParameters ) ;

    pInstance->SetCharSplat ( IDS_DataType, pJobInfo->pDatatype ) ;

    pInstance->SetCharSplat ( IDS_PrintProcessor , pJobInfo->pPrintProcessor ) ;

    // Job StatusMask
    pInstance->SetDWORD ( L"StatusMask" , pJobInfo->Status ) ;

    // CIM_Job:JobStatus, string version 
    CHString t_chsJobStatus( pJobInfo->pStatus ) ;

    // build the status if pStatus is empty 
    if( t_chsJobStatus.IsEmpty() )
    {
        for( DWORD dw = 0; dw < 32; dw++ )
        {
            DWORD t_dwState = 1 << dw ;

            if( pJobInfo->Status & t_dwState )
            {
                CHString t_chsMaskItem ;

                switch( t_dwState )
                {
                    case JOB_STATUS_PAUSED:
                    {
                        LoadStringW( t_chsMaskItem, IDR_JOB_STATUS_PAUSED ) ;
                        break ;
                    }
                    case JOB_STATUS_ERROR:
                    {
                        LoadStringW( t_chsMaskItem, IDR_JOB_STATUS_ERROR ) ;
                        break ;
                    }
                    case JOB_STATUS_DELETING:
                    {
                        LoadStringW( t_chsMaskItem, IDR_JOB_STATUS_DELETING ) ;
                        break ;
                    }
                    case JOB_STATUS_SPOOLING:
                    {
                        LoadStringW( t_chsMaskItem, IDR_JOB_STATUS_SPOOLING ) ;
                        break ;
                    }
                    case JOB_STATUS_PRINTING:
                    {
                        LoadStringW( t_chsMaskItem, IDR_JOB_STATUS_PRINTING ) ;
                        break ;
                    }
                    case JOB_STATUS_OFFLINE:
                    {
                        LoadStringW( t_chsMaskItem, IDR_JOB_STATUS_OFFLINE ) ;
                        break ;
                    }
                    case JOB_STATUS_PAPEROUT:
                    {
                        LoadStringW( t_chsMaskItem, IDR_JOB_STATUS_PAPEROUT ) ;
                        break ;
                    }
                    case JOB_STATUS_PRINTED:
                    {
                        LoadStringW( t_chsMaskItem, IDR_JOB_STATUS_PRINTED ) ;
                        break ;
                    }
                    case JOB_STATUS_DELETED:
                    {
                        LoadStringW( t_chsMaskItem, IDR_JOB_STATUS_DELETED ) ;
                        break ;
                    }
                    case JOB_STATUS_BLOCKED_DEVQ:
                    {
                        LoadStringW( t_chsMaskItem, IDR_JOB_STATUS_BLOCKED_DEVQ ) ;
                        break ;
                    }
                    case JOB_STATUS_USER_INTERVENTION:
                    {
                        LoadStringW( t_chsMaskItem, IDR_JOB_STATUS_USER_INTERVENTION ) ;
                        break ;
                    }
                    case JOB_STATUS_RESTART:
                    {
                        LoadStringW( t_chsMaskItem, IDR_JOB_STATUS_RESTART ) ;
                        break ;
                    }
                    default:
                    {
                    }
                }
                if( !t_chsMaskItem.IsEmpty() )
                {
                    if( !t_chsJobStatus.IsEmpty() )
                    {
                        t_chsJobStatus += L" | " ;
                    }
                    t_chsJobStatus += t_chsMaskItem;
                }
            }
        }
    }
    
    if( !t_chsJobStatus.IsEmpty() )
    {
        pInstance->SetCHString( IDS_JobStatus, t_chsJobStatus ) ;
    }


    // CIM_ManagedSystemElement::Status 
    if ( pJobInfo->Status & JOB_STATUS_ERROR )  
    {
        pInstance->SetCHString(IDS_Status, IDS_Error) ;
    }
    else if ( ( pJobInfo->Status & JOB_STATUS_OFFLINE ) ||
              ( pJobInfo->Status & JOB_STATUS_PAPEROUT ) ||
              ( pJobInfo->Status & JOB_STATUS_PAUSED ) )
    {
        pInstance->SetCHString(IDS_Status, IDS_Degraded) ;
    }
    else if ( ( pJobInfo->Status & JOB_STATUS_DELETING ) ||
              ( pJobInfo->Status & JOB_STATUS_SPOOLING ) ||
              ( pJobInfo->Status & JOB_STATUS_PRINTING ) ||
              ( pJobInfo->Status & JOB_STATUS_PRINTED ) )
    {
        pInstance->SetCHString(IDS_Status, IDS_OK) ;
    }
    else
    {
        pInstance->SetCHString(IDS_Status, IDS_Unknown);
    }
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PrintJob::CWin32PrintJob
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

HRESULT CWin32PrintJob :: AllocateAndInitPrintersList (

    LPBYTE *ppPrinterList, 
    DWORD &dwInstances
)
{
    DWORD   dwSpaceNeeded = 0, dwLastError = 0, dwReturnedPrinterInfo = 0;
    HANDLE  hPrinter = 0;

    // Set everything to null
    dwInstances = 0;
    *ppPrinterList = NULL;

    // ======================================================================
    // The first call to the enumeration is to find out how many printers
    // there are so that we can allocate buffer to contain all of the printer
    // enumeration.
    // ======================================================================

    // Use of delay loaded functions requires exception handler.
    SetStructuredExceptionHandler seh;
    BOOL  t_Status = FALSE;
    DWORD Flags = PRINTER_ENUM_LOCAL; 
    BOOL  bIsLocalCall;

    if (SUCCEEDED(WinErrorToWBEMhResult(IsLocalCall(&bIsLocalCall))) && bIsLocalCall)
    {
        Flags |= PRINTER_ENUM_CONNECTIONS;
    }

    try
    {
        t_Status = ::EnumPrinters (

            Flags,
            NULL,
            1, 
            NULL,
            NULL,
            &dwSpaceNeeded,
            &dwReturnedPrinterInfo 
        ) ;

        if ( t_Status == FALSE )
        {
            if ( ( dwLastError = GetLastError ()) != ERROR_INSUFFICIENT_BUFFER ) 
            {
                if (IsErrorLoggingEnabled())
                {
                    CHString msg;
                    msg.Format( L"EnumPrinters failed: %d", dwLastError);
                    LogErrorMessage(msg);
                }

                if (dwLastError == ERROR_ACCESS_DENIED)
                {
                    return WBEM_E_ACCESS_DENIED;
                }
                else
                {
                    return WBEM_E_FAILED ;
                }
            }
        }

        // ======================================================================
        // Allocates an array of PRINTER_INFO_1 to contain all of the printer enumerations.
        // ================================================================================

        *ppPrinterList = new BYTE [ dwSpaceNeeded + 2 ] ;
        if ( *ppPrinterList ) 
        {
            // ======================================================================
            // The enumeration of printers is to receive the name of the existed printers in
            // the domain the machine belongs to. With the printer's names the logic can identify
            // the print-dwJobs per printer which transmitted to the Mo-server.
            // ===================================================================================

            t_Status = ::EnumPrinters (

                Flags,
                NULL, 
                1, 
                ( LPBYTE )*ppPrinterList, 
                dwSpaceNeeded, 
                &dwSpaceNeeded,
                &dwReturnedPrinterInfo 
            ) ;

            if ( ! t_Status )
            {
                delete [] *ppPrinterList;

                *ppPrinterList = NULL;
                LogLastError(_T(__FILE__), __LINE__);

                return WBEM_E_FAILED;
            }

            // ======================================================================
            // Sets the properties for print dwJobs per printer when open successfully.
            // ======================================================================
            dwInstances = dwReturnedPrinterInfo ;
        }
        else
        {
            CHString msg;
            msg.Format( L"EnumPrinters failed: %d", ERROR_NOT_ENOUGH_MEMORY);
            LogErrorMessage(msg);

            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        delete[] *ppPrinterList;
        return WBEM_E_FAILED;
    }
    catch(...)
    {
        delete[] *ppPrinterList;
        throw;
    }

    return( WBEM_S_NO_ERROR );
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PrintJob::GetAndCommitPrintJobInfo
 *
 *  DESCRIPTION : 
 *
 *  INPUTS      : 
 *
 *  OUTPUTS     : 
 *
 *  RETURNS     : 
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/

HRESULT CWin32PrintJob::GetAndCommitPrintJobInfo (

    HANDLE         hPrinter, 
    LPCWSTR        pszPrinterName,
    DWORD          dwJobId, 
    MethodContext *pMethodContext, 
    CInstance     *a_pInstance
)
{
    HRESULT         hr = WBEM_E_FAILED;
    PRINTER_INFO_1  *pPrinterInfo = NULL;

    BYTE            *t_pbJobInfoBase    = NULL ;
    JOB_INFO_2      *t_pJobInfo         = NULL ;

    DWORD           dwPBytesNeeded = 0L;    //for printer info
    DWORD           dwJBytesNeeded = 0L;    //for jobs info
    DWORD           dwBytesUsed = 0L;
    DWORD           dwReturnedJobs = 0L;
    BOOL            bStatus = FALSE;
    CInstancePtr    t_pInstance = a_pInstance;


    // Get the total print dwJobs curretnly pending for the given printer handle.
    
    // Use of delay loaded functions requires exception handler.
    SetStructuredExceptionHandler seh;
    try
    {
        bStatus = ::EnumJobs ( hPrinter, 
            FIRST_JOB_IN_QUEUE,NUM_OF_JOBS_TO_ENUM,
            ENUM_LEVEL, 
            (LPBYTE)0,
            NULL,
            &dwJBytesNeeded, 
            &dwReturnedJobs );
        if (!bStatus) 
        {
            DWORD dwLastError = GetLastError();

            if (dwLastError != ERROR_INSUFFICIENT_BUFFER)
            {
                DWORD dwAttributes = 0;

                //
                // Here we need to see if we are dealing with a printer connection.
                // OpenPrinter always succeeds on printer connections, because we
                // used cached information for creating the handle. However, EnumJobs
                // on a printer connection can fail because of various reasons:
                // - remote server machine is down
                // - spooler on remote server is not running
                // - remote printer was deleted, so the connection is broken.
                // In these cases, the print folders will display messages like:
                // "Access denied, unable to connect". We do not want our WMI call
                // to fail because of this. So if we have a printer connection, 
                // and an error other than insufficient buffer occurred, then we 
                // simply return success
                //
                hr = WinErrorToWBEMhResult(SplPrinterGetAttributes(pszPrinterName, &dwAttributes));

                if (SUCCEEDED(hr) &&
                    !(dwAttributes & PRINTER_ATTRIBUTE_LOCAL))
                {
                    //
                    // Printer connection
                    //
                    hr = WBEM_S_NO_ERROR;
                }

                return hr ;
            }
        }
    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        dwJBytesNeeded = 0L;
    }

    // No Job entries
    if ( dwJBytesNeeded == 0L ) 
        return WBEM_S_NO_ERROR ;

    //
    // Print jobs came and go at a fast rate on print server. It is possible that jobs come 
    // in between the EnumJobs and then the buffer we got from the first call to EnumJobs
    // won't be large enough. The extra safe bytes are enough to accommodate 4 more jobs. This
    // is just for improving the odds that the second EnumJobs is successful
    // 
    // Allocates an array of JOB_INFO_2 to contain all of the print job enumerations.
    dwJBytesNeeded += EXTRA_SAFE_BYTES;
    DWORD dwJobsToCopy = dwJBytesNeeded / sizeof(JOB_INFO_2);  

    t_pbJobInfoBase = new BYTE [ dwJBytesNeeded + 2 ] ;
    t_pJobInfo = (JOB_INFO_2 *) t_pbJobInfoBase ;

    if ( ! t_pJobInfo ) 
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR );
        return WBEM_E_OUT_OF_MEMORY;
    }

    // Get the buffer size needed for the printer information (level 1)
    try
    {
        bStatus = ::GetPrinter(hPrinter, 1, NULL, 0, &dwPBytesNeeded);
        pPrinterInfo = (PRINTER_INFO_1 *) new BYTE [ dwPBytesNeeded ];
        if (!(pPrinterInfo))
        {
            delete [] (LPBYTE) t_pbJobInfoBase;
            return WBEM_E_OUT_OF_MEMORY;
        }

        // Get the printer information (level 1). 
        bStatus = ::GetPrinter(hPrinter, 1,(LPBYTE )pPrinterInfo, dwPBytesNeeded, &dwBytesUsed);
        if (!bStatus)
        {
            delete [] (LPBYTE) t_pbJobInfoBase ;
            delete [] (LPBYTE) pPrinterInfo;
            return WBEM_E_ACCESS_DENIED;
        }
    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        return WBEM_E_FAILED;
    }
    catch(...)
    {
        delete [] (LPBYTE) t_pbJobInfoBase ;
        delete [] (LPBYTE) pPrinterInfo;
        return WBEM_E_FAILED;
    }


    try
    {
        // Retrieves all the print dwJobs.
        bStatus = ::EnumJobs (  hPrinter, 
            FIRST_JOB_IN_QUEUE, 
            dwJobsToCopy, 
            ENUM_LEVEL,
            (LPBYTE)t_pJobInfo,
            dwJBytesNeeded, 
            &dwJBytesNeeded, 
            &dwReturnedJobs );
        if ( bStatus )
        {
            hr = WBEM_S_NO_ERROR ;

            for ( DWORD dwJobs = 0; dwJobs < dwReturnedJobs && SUCCEEDED ( hr ); dwJobs ++ )
            {
                if ( ! pMethodContext && dwJobId != t_pJobInfo->JobId )
                        continue ;

                if ( pMethodContext )
                    t_pInstance.Attach( CreateNewInstance ( pMethodContext ) ) ;

                //The instance name has the format 'PrinterName , Job#'
                CHString sName ;
                sName = pPrinterInfo->pName;
                sName += _T(", ");

                TCHAR szBuff [ MAXITOA ] ;
                sName += _itot ( t_pJobInfo->JobId , szBuff, 10 ) ;

                t_pInstance->SetCHString (IDS_Name, sName ) ;

                //Caption and Description are same as the Name
                t_pInstance->SetCHString ( IDS_Caption , sName ) ;
                t_pInstance->SetCHString ( IDS_Description , sName ) ;

                //Polulate the rest of the props
                AssignPrintJobFields ( t_pJobInfo , t_pInstance ) ;

                if ( pMethodContext )
                    hr = t_pInstance->Commit() ;
                
                t_pJobInfo ++ ;
            }
        }
    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        if( t_pbJobInfoBase )
        {
            delete [] (LPBYTE) t_pbJobInfoBase ;
            t_pbJobInfoBase = NULL ;
        }
        if( pPrinterInfo )
        {
            delete [] (LPBYTE) pPrinterInfo;
            pPrinterInfo = NULL ;
        }
        hr = WBEM_E_FAILED;
    }
    catch(...)
    {
        if( t_pbJobInfoBase )
        {
            delete [] (LPBYTE) t_pbJobInfoBase ;
            t_pbJobInfoBase = NULL ;
        }
        if( pPrinterInfo )
        {
            delete [] (LPBYTE) pPrinterInfo;
            pPrinterInfo = NULL ;
        }
                throw;
    }

    if( pPrinterInfo ) 
    {
        delete [] (LPBYTE) pPrinterInfo;
        pPrinterInfo = NULL ;
    }

    if( t_pbJobInfoBase )
    {
        delete [] (LPBYTE) t_pbJobInfoBase ;
        t_pbJobInfoBase = NULL ;
    }

    return( hr );
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PrintJob::ExecPrinterOp
 *
 *  DESCRIPTION : Makes a call to ExecPrinterOp to do a appropriate operation
 *                based on the method called by the user.
 *
 ****************************************************************************/
HRESULT CWin32PrintJob :: ExecMethod (

    const CInstance &Instance ,     
    const BSTR       bstrMethodName,
          CInstance *pInParams,
          CInstance *pOutParams,
          long       lFlags
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
  
    if (!pOutParams)
    {
        hRes = WBEM_E_INVALID_PARAMETER;
    } 
    else if (!_wcsicmp(bstrMethodName, PAUSEJOB))
    {
        hRes = ExecPrinterOp(Instance, pOutParams, PRINTER_CONTROL_PAUSE);
    }
    else if (!_wcsicmp(bstrMethodName, RESUMEJOB))
    {
        hRes = ExecPrinterOp(Instance, pOutParams, PRINTER_CONTROL_RESUME);
    }
    else
    {
        hRes = WBEM_E_PROVIDER_NOT_CAPABLE;
    }

    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PrintJob::ExecPrinterOp
 *
 *  DESCRIPTION : Makes a call to SetJob, to either cancel a job, or Resume or 
 *                Delete a job based on the dwOperation passed
 ****************************************************************************/

HRESULT CWin32PrintJob :: ExecPrinterOp ( 
                                         
    const CInstance &Instance , 
          CInstance *pOutParams, 
          DWORD      dwOperation          
          
)
{
#if NTONLY >= 5
    CHString  t_String;
    HRESULT   hRes = WBEM_S_NO_ERROR;
    
    hRes = InstanceGetString(Instance, IDS_Name, &t_String, kFailOnEmptyString);
    
    if (SUCCEEDED(hRes)) 
    {
        CHString csPrinter;
        CHString csJob;
        DWORD    dwJobId = 0;
        
        //
        // Isolate  a JobId and PrinterName from the PrintJob key
        // The key is of the form "printername, 123"
        //
        DWORD dwPos = t_String.Find(L',');

        csPrinter   = t_String.Left(dwPos);

        csJob       = t_String.Mid(dwPos+1);

        dwJobId     = _wtoi(csJob);
        
        hRes        = WBEM_E_FAILED;

        SmartClosePrinter hPrinter;
        DWORD             dwError = ERROR_SUCCESS;

        //
        // We reached this point, return success to the framework
        //
        hRes = WBEM_S_NO_ERROR;

        // Use of delay loaded functions requires exception handler.
        SetStructuredExceptionHandler seh;
        try
        {
            if (!::OpenPrinter((LPTSTR)(LPCTSTR)TOBSTRT(csPrinter), &hPrinter, NULL) ||
                !::SetJob(hPrinter, dwJobId, 0, NULL, dwOperation)
               )
            {
                dwError = GetLastError();                
            }

            if (pOutParams) 
            {
                //
                // Our caller was invoked via ExecMethod. It passed us pOutParams
                // for returning the status of the operation
                //
                SetReturnValue(pOutParams, dwError);
            }
            else if (FAILED(hRes = WinErrorToWBEMhResult(dwError)))
            {
                //
                // Our caller was PutInstance/DeleteInstance. We use 
                // SetStatusObject to set extended error information
                // 
                SetErrorObject(Instance, dwError, pszDeleteInstance);

                //
                // When we call DeleteInstance and there is no job with the specified ID,
                // SetJob returns ERROR_INVALID_PARAMETER. WinErrorToWBEMhResult translates
                // that to Generic Failure. We really need WBEM_E_NOT_FOUND in this case.
                // 
                if (dwError == ERROR_INVALID_PARAMETER)
                {
                    hRes = WBEM_E_NOT_FOUND;
                } 
            }
        }
        catch(Structured_Exception se)
        {
            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
            hRes = WBEM_E_FAILED;
        }
    }
    
    return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\printjob.h ===
//////////////////////////////////////////////////////////////////////

//

//  PrintJob.h  - Implementation of Provider for user print-jobs

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//
//  10/17/96    jennymc     Enhanced
//  10/27/97    davwoh      Moved to curly
//
//////////////////////////////////////////////////////////////////////

//==================================

#define PJ_STATUS_UNKNOWN     L"Unknown"

#define PJ_JOB_STATUS_PAUSED     L"Paused"
#define PJ_JOB_STATUS_ERROR      L"Error"
#define PJ_JOB_STATUS_DELETING   L"Deleting"
#define PJ_JOB_STATUS_SPOOLING   L"Spooling"
#define PJ_JOB_STATUS_PRINTING   L"Printing"
#define PJ_JOB_STATUS_OFFLINE    L"Offline"
#define PJ_JOB_STATUS_PAPEROUT   L"Paperout"
#define PJ_JOB_STATUS_PRINTED    L"Printed"

// returns required for the ExecMethod Routines
#define PJ_JOB_NO_ERROR                 0
#define PJ_JOB_PAUSED                   1
#define PJ_JOB_STATUS_ACCESS_DENIED     2
#define PJ_JOB_STATUS_ALREADY_RUNNING   3
#define PJ_JOB_STATUS_ALREADY_PRINTED   3
#define PJ_JOB_UNKNOWN                  4

#define PROPSET_NAME_PRINTJOB L"Win32_PrintJob"

// Method Names
#define  PAUSEJOB                        L"Pause"
#define  RESUMEJOB                       L"Resume"
#define  DELETEJOB                       L"Delete"

//==========================================================
#define EXTRA_SAFE_BYTES        5120
#define NUM_OF_JOBS_TO_ENUM 0xFFFFFFFF
#define ENUM_LEVEL 2
#define FIRST_JOB_IN_QUEUE 0
#define NO_SPECIFIC_PRINTJOB 9999999
//==========================================================

class CWin32PrintJob;

class CWin32PrintJob:public Provider
{
    private:
        
        void    
        AssignPrintJobFields(
            LPVOID     lpJob, 
            CInstance *pInstance
            );

        HRESULT 
        AllocateAndInitPrintersList(
            LPBYTE       *ppPrinterList, 
            DWORD        &dwInstances
            );

        HRESULT 
        GetAndCommitPrintJobInfo(
            HANDLE         hPrinter, 
            LPCWSTR        pszPrinterName,
            DWORD          dwJobId, 
            MethodContext *pMethodContext, 
            CInstance     *pInstance
            );

        HRESULT 
        ExecPrinterOp(
            const CInstance &Instance, 
            CInstance       *pOutParams, 
            DWORD            dwOperation
            );

        //============== not used at the moment
        BOOL GetNTInstance()    { return TRUE; }
        BOOL GetWin95Instance() { return TRUE; }
        BOOL RefreshNTInstance(){ return TRUE; }
        BOOL RefreshWin95Instance(){ return TRUE; }
        CHString  StartEndTimeToDMTF(DWORD time);

            

    public:

       virtual  HRESULT DeleteInstance(const CInstance &Instance,  long lFlags);

       // These functions are REQUIRED for the property set
       // ==================================================
       virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);

       // This class has dynamic instances
       // =================================
       virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);

       // a routine to execute the Methods 
       virtual HRESULT ExecMethod ( const CInstance &Instance, const BSTR bstrMethodName, CInstance *pInParams, CInstance *pOutParams, long lFlags );

       // Constructor sets the name and description of the property set
       // and initializes the properties to their startup values
       // ==============================================================
       CWin32PrintJob(LPCWSTR name, LPCWSTR pszNamespace);
       ~CWin32PrintJob();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\prninterface.h ===
/*++



//  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
All rights reserved.

Module Name:

    PrnInterface.h

Abstract:

    Interface for WMI Provider. Used for doing printer object
    management: printers, driver, ports, jobs.
    
Author:

    Felix Maxa (AMaxa)  03-March-2000

--*/

#ifndef _PRNINTERFACE_HXX_
#define _PRNINTERFACE_HXX_

#include <fwcommon.h>
#include "winspool.h"
#include "tcpxcv.h"

//
// Printer functionality
//
DWORD
SplPrinterAdd(
    IN PRINTER_INFO_2W &Printer2
    );

DWORD
SplPrinterDel(
    IN LPCWSTR pszPrinter
    );

DWORD
SplPrinterSet(
    IN PRINTER_INFO_2W &Printer2
    );

DWORD
SplPrinterRename(
    IN LPCWSTR pCurrentPrinterName,
    IN LPCWSTR pNewPrinterName
    );

DWORD
SplPrintTestPage(
    IN LPCWSTR pPrinter
    );

//
// Printer driver functionality
//
DWORD
SplDriverAdd(
    IN LPCWSTR pszDriverName,
    IN DWORD   dwVersion,
    IN LPCWSTR pszEnvironment,
    IN LPCWSTR pszInfName,
    IN LPCWSTR pszFilePath
    );

DWORD
SplDriverDel(
    IN LPCWSTR pszDriverName,
    IN DWORD   pszVersion,
    IN LPCWSTR pszEnvironment
    );

//
// Printer port functionality
//   
DWORD
SplPortAddTCP(
    IN PORT_DATA_1 &Port
    );

DWORD
SplPortDelTCP(
    IN LPCWSTR pszPort
    );

DWORD
SplTCPPortGetConfig(
    IN     LPCWSTR       pszPort,
    IN OUT PORT_DATA_1 *pPortData
    );

DWORD
SplTCPPortSetConfig(
    IN PORT_DATA_1 &PortData
    );

BOOL
GetDeviceSettings(
    IN OUT PORT_DATA_1 &PortData
    );

enum {
    kProtocolRaw      = 1,
    kProtocolLpr      = 2,
    kDefaultRawNumber = 9100,
    kDefaultLprNumber = 515,
    kTCPVersion       = 1,
    kCoreVersion      = 1,
    kDefaultSnmpIndex = 1
};



#endif // _PRNINTERFACE_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\processdll.h ===
//=================================================================

// ProcessDLL.h -- CWin32ProcessDLL 

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//=================================================================
#ifndef __ASSOC_PROCESSDLL
#define __ASSOC_PROCESSDLL

typedef BOOL (CALLBACK *MODULEENUMPROC)(MODULEENTRY32*, LPVOID);

class CWin32ProcessDLL : public Provider
{
public:

	CWin32ProcessDLL();
	~CWin32ProcessDLL();

	virtual HRESULT EnumerateInstances (

		MethodContext *pMethodContext, 
		long lFlags = 0L
	);

	virtual HRESULT GetObject (

		CInstance* pInstance, 
		long lFlags = 0L
	);

protected:
	
	
	HRESULT AreAssociated (

		CInstance *pProcessDLL, 
		CInstance *pProcess, 
		CInstance *pDLL
	);

	void SetInstanceData (

		CInstance *pInstance, 
		MODULEENTRY32 *pModule
	);


	HRESULT EnumModulesWithCallback (

		MODULEENUMPROC fpCallback, 
		LPVOID pUserDefined,
		MethodContext *a_pMethodContext
	);

	static BOOL CALLBACK EnumInstancesCallback (

		MODULEENTRY32 *pModule, 
		LPVOID pUserDefined
	);

	static BOOL CALLBACK IsAssocCallback (

		MODULEENTRY32 *pModule, 
		LPVOID pUserDefined
	);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\prnutil.cpp ===
/*++



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
All rights reserved.

Module Name:

    PrnUtil.cpp

Abstract:

    The implementation of some printing utility functions

Author:

    Felix Maxa (amaxa)  3-Mar-2000

Revision History:

--*/


#include <precomp.h>
#include <DllWrapperBase.h>
#include <winspool.h>
#include "prnutil.h"
#include "WMI_FilePrivateProfile.h"

extern CONST BOOL    kFailOnEmptyString    = TRUE;
extern CONST BOOL    kAcceptEmptyString    = FALSE;
extern CONST LPCWSTR pszPutInstance        = L"PutInstance";
extern CONST LPCWSTR pszDeleteInstance     = L"DeleteInstance";
extern CONST LPCWSTR pszGetObject          = L"GetObject";
extern CONST LPCWSTR kDefaultBoolean       = L"Default";
extern CONST LPCWSTR kDateTimeFormat       = L"********%02d%02d00.000000+000";
extern CONST LPCWSTR kDateTimeTemplate     = L"19990102334411";


CONST LPCWSTR kMethodReturnValue    = L"ReturnValue";
CONST LPCWSTR kErrorClassPath       = L"\\\\.\\root\\cimv2:__ExtendedStatus";
CONST LPCWSTR pszIniPortsSection    = L"Ports";
CONST LPCWSTR g_pszPrintUIDll       = L"printui.dll";
CONST LPCSTR  g_pszPrintUIEntry     = "PrintUIEntryW";

#if NTONLY == 5

#include <winsock.h>
#include "prninterface.h"
#include <lockwrap.h>
#include <smartptr.h>
#include "AdvApi32Api.h"


LPCWSTR TUISymbols::kstrQuiet                   = _T("/q ");
LPCWSTR TUISymbols::kstrAddDriver               = _T("/Gw /ia /K ");
LPCWSTR TUISymbols::kstrAddPrinter              = _T("/if /u /z /Y /f \"\" ");
LPCWSTR TUISymbols::kstrDelDriver               = _T("/dd /K ");
LPCWSTR TUISymbols::kstrDriverPath              = _T("/l \"%s\" ");
LPCWSTR TUISymbols::kstrDriverModelName         = _T("/m \"%s\" ");
LPCWSTR TUISymbols::kstrDriverVersion           = _T("/v \"%u\" ");
LPCWSTR TUISymbols::kstrDriverArchitecture      = _T("/h \"%s\" ");
LPCWSTR TUISymbols::kstrInfFile                 = _T("/f \"%s\" ");
LPCWSTR TUISymbols::kstrMachineName             = _T("/c \"%s\" ");
LPCWSTR TUISymbols::kstrPrinterName             = _T("/n \"%s\" ");
LPCWSTR TUISymbols::kstrBasePrinterName         = _T("/b \"%s\" ");
LPCWSTR TUISymbols::kstrPrinterPortName         = _T("/r \"%s\" ");
LPCWSTR TUISymbols::kstrDelLocalPrinter         = _T("/dl ");
LPCWSTR TUISymbols::kstrPortName                = _T("/r \"%s\" ");
LPCWSTR TUISymbols::kstrPrintTestPage           = _T("/k ");


/*++

Routine Name

     PrintUIEntryW

Routine Description:

    Wrapper around the entry point in printui.dll

Arguments:

    pszCmdLine - String command line for printui

Return Value:

    DWORD Error status of the call

--*/
DWORD WINAPI
PrintUIEntryW(
    IN LPCWSTR pszCmdLine
    )
{
    DWORD     dwError = ERROR_SUCCESS;
    HINSTANCE hLib    = ::LoadLibrary(g_pszPrintUIDll);

    if(hLib)
    {
        typedef   DWORD (*PFNENTRY)(HWND, HINSTANCE, LPCTSTR, UINT);
        PFNENTRY  pfnEntry = NULL;

        pfnEntry = (PFNENTRY)::GetProcAddress(hLib, g_pszPrintUIEntry);

        if (pfnEntry)
        {
            dwError = pfnEntry(NULL, NULL, pszCmdLine, 0);

            DBGMSG(DBG_TRACE, (_T("PrintUIEntry returns %u GLE %u\n"), dwError, GetLastError()));
        }
        else
        {
            dwError = GetLastError();
        }
    }
    else
    {
        dwError = GetLastError();
    }

    if (hLib)
    {
        FreeLibrary(hLib);
    }

    return dwError;
}

/*++

Routine Name

    GetPrinterAttributes

Routine Description:

    Gets a printer's attribute field

Arguments:

    pszPrinter    - printer name
    pdwAttributes - pointer to dword

Return Value:

    Win32 error code

--*/
DWORD
SplPrinterGetAttributes(
    IN     LPCWSTR  pszPrinter,
    IN OUT DWORD   *pdwAttributes
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (pszPrinter && pdwAttributes)
    {
        HANDLE             hPrinter         = NULL;
        PPRINTER_INFO_4    pInfo            = NULL;
        PRINTER_DEFAULTS   PrinterDefaults  = {NULL, NULL, PRINTER_READ};

        dwError = ERROR_DLL_NOT_FOUND;

        //
        // Open the printer.
        //
        
        // Use of delay loaded functions requires exception handler.
        SetStructuredExceptionHandler seh;
	    try  
        {
            if (::OpenPrinter(const_cast<LPWSTR>(pszPrinter), &hPrinter, &PrinterDefaults))
            {
                //
                // Get the printer data. ATTENTION This doesn't work on Win9x because of the
                // mutex in the CWinSpoolApi class
                //
                dwError = GetThisPrinter(hPrinter, 4, reinterpret_cast<BYTE **>(&pInfo));

                if (dwError==ERROR_SUCCESS)
                {
                    *pdwAttributes = pInfo->Attributes;
                
                    //
                    // Release the printer info data.
                    //
                    delete [] pInfo;
                }

                //
                // Close the printer handle
                //
                ::ClosePrinter(hPrinter);
            }
            else
            {
                dwError = GetLastError();
            }
        }
        catch(Structured_Exception se)
        {
            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
            dwError = E_FAIL;
        }
    }

    DBGMSG(DBG_TRACE, (_T("SplPrinterGetAttributes returns %u\n"), dwError));

    return dwError;
}

/*++

Routine Name:

    CallXcvData

Routine Description:

    Calls XcvDataW in winspool.drv. This is designed so to allow the tool to be
    run on NT4.0. If we don't get the procaddress and do eveything through
    the linked winspool.lib, the tool can't be registered with regsvr32.
    So we eliminte the import of XcvDataW from the imagefile.

Arguments:

    See DDK

Return Value:

    Win32 error code

--*/
DWORD
CallXcvDataW(
    HANDLE  hXcv,
    PCWSTR  pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData
    )
{
    HMODULE      hLib = NULL;
    typedef      BOOL (* XCVDATAPARAM)(HANDLE, PCWSTR, PBYTE, DWORD, PBYTE, DWORD, PDWORD, PDWORD);
    XCVDATAPARAM pfnXcvData = NULL;
    DWORD        dwError  = ERROR_DLL_NOT_FOUND;

    DWORD cbOutputNeeded = 0;
    DWORD Status         = NO_ERROR;
    BOOL  bReturn = FALSE;

    // Use of delay loaded functions requires exception handler.
    SetStructuredExceptionHandler seh;
	try  
    {
        bReturn =  XcvData(hXcv,
                                           pszDataName,
                                           pInputData,
                                           cbInputData,
                                           pOutputData,
                                           cbOutputData,
                                           &cbOutputNeeded,
                                           &Status);
    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        dwError = E_FAIL;
    }

    dwError =  bReturn ? Status : GetLastError();

    DBGMSG(DBG_TRACE, (_T("CallXcvData returns %u\n"), dwError));

    return dwError;
}

/*++

Routine Name

     IsLocalCall

Routine Description:

    Helper function. Checks if the caller's thread is local or remote

    DO NOT USE THIS FUNTCION OUTSIDE OF THE PRINTER FILES. The function doesn't
    handle the return value from OpenThreadToken properly in the case when the
    caller is the process, not a thread

Arguments:

    pbOutValue - pointer to bool

Return Value:

    DWORD Error status of the call

--*/
DWORD
IsLocalCall(
    IN OUT BOOL *pbOutValue
    )
{
    HANDLE        hToken         = NULL;
    PSID          pNetworkSid    = NULL;
    CAdvApi32Api *pAdvApi32      = NULL;
    DWORD         dwError        = ERROR_INVALID_PARAMETER;
    BOOL          bNetworkLogon  = FALSE;
    BOOL          bRetVal        = FALSE;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    if (pbOutValue &&
        (dwError = OpenThreadToken(GetCurrentThread(), 
                                   TOKEN_QUERY, 
                                   FALSE, 
                                   &hToken) ? ERROR_SUCCESS : GetLastError()) == ERROR_SUCCESS &&
        (dwError = AllocateAndInitializeSid(&NtAuthority,
                                            1,
                                            SECURITY_NETWORK_RID,
                                            0,
                                            0,
                                            0,
                                            0,
                                            0,
                                            0,
                                            0,
                                            &pNetworkSid) ? ERROR_SUCCESS : GetLastError()) == ERROR_SUCCESS)
    {
        pAdvApi32 = (CAdvApi32Api*)CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL);

        dwError = ERROR_INVALID_FUNCTION;

        if (pAdvApi32)
        {
            if (pAdvApi32->CheckTokenMembership(hToken, pNetworkSid, &bNetworkLogon, &bRetVal) && bRetVal)
            {
                dwError = ERROR_SUCCESS;
                *pbOutValue     = !bNetworkLogon;
            }
            else
            {
               dwError = GetLastError();
            }

            CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, pAdvApi32);
        }
    }

    if (hToken)
    {
        CloseHandle(hToken);
    }

    if (pNetworkSid)
    {
        FreeSid(pNetworkSid);
    }

    DBGMSG(DBG_TRACE, (_T("IsLocalCall returns %u bLocal %u\n"), dwError, *pbOutValue));

    return dwError;
}

/*++

Routine Name:

    SetErrorObject

Routine Description:

    Sets en error object with extended information about an error that occurred.
    The function will format the win32 error code passed in as argument into a
    string description.

Arguments:

    Instace      - instance
    dwError      - Win32 error
    pszOperation - optional, description of what operation failed

Return Value:

    None

--*/
VOID
SetErrorObject(
    IN const CInstance &Instance,
    IN       DWORD      dwError,
    IN       LPCWSTR    pszOperation
    )
{
    CInstancePtr pErrorInstance(NULL);

    //
    // First, get a status object
    //
    CWbemProviderGlue::GetInstanceByPath(kErrorClassPath, &pErrorInstance, Instance.GetMethodContext());

    if (pErrorInstance)
    {
        DWORD       cchReturn         = 0;
        LPWSTR      pszFormatMessage  = NULL;
        HMODULE     hModule           = NULL;
        DWORD       dwFlags           = 0;
        HRESULT     hr                = E_FAIL;

        dwFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER |
                  FORMAT_MESSAGE_IGNORE_INSERTS  |
                  FORMAT_MESSAGE_FROM_SYSTEM     |
                  FORMAT_MESSAGE_MAX_WIDTH_MASK;

        //
        // Format the message with the passed in last error.
        //
        cchReturn = FormatMessage(dwFlags,
                                  hModule,
                                  dwError,
                                  0,
                                  (LPTSTR)&pszFormatMessage,
                                  0,
                                  NULL);

        //
        // If a format string was returned then copy it back to the callers specified string.
        //
        pErrorInstance->SetWCHARSplat(L"Description", cchReturn ? pszFormatMessage : L"Unknown error");

        //
        // Release the format string.
        //
        if (pszFormatMessage)
        {
            LocalFree(pszFormatMessage);
        }

        //
        // Now, populate it
        //
        pErrorInstance->SetWCHARSplat(L"Operation",    pszOperation);
        pErrorInstance->SetWCHARSplat(L"ProviderName", L"Win32 Provider");
        pErrorInstance->SetDWORD     (L"StatusCode",   dwError);

        //
        // Get the actual IWbemClassObject pointer
        //
        IWbemClassObject *pObj = pErrorInstance->GetClassObjectInterface();

        //
        // Note that no Release() is required for this
        //
        MethodContext *pMethodContext = Instance.GetMethodContext();

        //
        // Set the status object
        //
        pMethodContext->SetStatusObject(pObj);

        //
        // Cleanup
        //
        pObj->Release();
    }
}

//
// Debugging utility
//
#ifdef DBG
VOID cdecl
DbgMsg(
    IN LPCTSTR pszFormat, ...
    )
{
    CHString csMsgText;
    va_list  pArgs;

    va_start(pArgs, pszFormat);

    csMsgText.FormatV(pszFormat, pArgs);

    va_end(pArgs);

    OutputDebugString(csMsgText);
}
#endif

/*++

Routine Name:

    StringCompareWildcard

Routine Description:

    Compares two strings where * represents a wild card

Arguments:

    pszString1 - pointer to the first string
    pszString2 - pointer to the second string

Return Value:

    TRUE if the two strings match

--*/
BOOL
StringCompareWildcard(
    IN LPCWSTR pszString1,
    IN LPCWSTR pszString2
    )
{
    if (!pszString1 && !pszString2)
    {
        return TRUE;
    }
    else if (!pszString1 || !pszString2)
    {
        return FALSE;
    }

    while (*pszString1 != '\0' && *pszString2 != '\0')
    {
        if (*pszString2 == '*')
        {
            pszString2 = CharNext(pszString2);

            if (*pszString2 == '\0')
            {
                return TRUE;
            }

            for ( ; *pszString1 != '\0'; pszString1 = CharNext(pszString1))
            {
                if (StringCompareWildcard(pszString1, pszString2) == TRUE)
                {
                    return TRUE;
                }
            }

            break;
        }
        else if (*pszString1 == *pszString2)
        {
            pszString1 = CharNext(pszString1);
            pszString2 = CharNext(pszString2);
        }
        else
        {
            break;
        }
    }

    if (*pszString1 == '\0' && *pszString2 == '*')
    {
        pszString2 = CharNext(pszString2);

        if (*pszString2 == '\0')
        {
            return TRUE;
        }
    }

    return (*pszString1 == '\0' && *pszString2 == '\0');
}

/*++

Routine Name:

    GetIniDword

Routine Description:

    Gets a dword value from the ini file section. We do not validate arguments

Arguments:

    pszIniFileName - pointer to the ini file name
    pszSectionName - pointer to the ini file section name
    pszKeyName     - pointer to the ini file key name
    pdwValue       - pointer to the dword value

Return Value:

    TRUE on success

--*/
BOOL
GetIniDword(
    IN     LPCWSTR  pszIniFileName,
    IN     LPCWSTR  pszSectionName,
    IN     LPCWSTR  pszKeyName,
       OUT LPDWORD  pdwValue
    )
{
    *pdwValue = (DWORD)WMI_FILE_GetPrivateProfileIntW(pszSectionName, pszKeyName, -1, pszIniFileName);

    return *pdwValue != (DWORD)-1;
}

/*++

Routine Name

    GetIniString

Routine Description:

    Gets a string value from the ini file section

Arguments:

    pszIniFileName - pointer to the ini file name
    pszSectionName - pointer to the ini file section name
    pszKeyName     - pointer to the ini file key name
    pszString      - pointer to the string value
    dwStringLen    - size of the string

Return Value:

    TRUE on success

--*/
BOOL
GetIniString(
    IN     LPCWSTR  pszIniFileName,
    IN     LPCWSTR  pszSectionName,
    IN     LPCWSTR  pszKeyName,
    IN OUT LPWSTR   pszString,
    IN     DWORD    dwStringLen
    )
{
    DWORD dwResult = WMI_FILE_GetPrivateProfileStringW(pszSectionName, pszKeyName, NULL, pszString, dwStringLen, pszIniFileName);
    return dwResult > 0 && dwResult < dwStringLen - 1;
}

/*++

Routine Name:

    GetDeviceSectionFromDeviceDescription

Routine Description:

    Gets the appropriate section name from the ini file based on the device description

Arguments:

    pszIniFileName       - pointer to the ini file name
    pszDeviceDescription - pointer to the device description
    pszSectionName       - pointer to the section name
    dwSectionNameLen     - size of the section name

Return Value:

  TRUE on success

--*/
BOOL
GetDeviceSectionFromDeviceDescription(
    IN     LPCWSTR  pszIniFileName,
    IN     LPCWSTR  pszDeviceDescription,
    IN OUT LPWSTR   pszSectionName,
    IN     DWORD    dwSectionNameLen
    )
{
    LPWSTR  pszBuffer, pszTemp;
    DWORD   dwBufferLen = 1024;
    LPWSTR  pszKeyName;
    DWORD   dwKeyNameLen;
    DWORD   dwResult;
    BOOL    bReturn     = FALSE;

    //
    // Get the section strings from the ini file
    //
    pszBuffer = new WCHAR[dwBufferLen];

    while (pszBuffer && !bReturn)
    {
        dwResult = WMI_FILE_GetPrivateProfileStringW(pszIniPortsSection, NULL, NULL, pszBuffer, dwBufferLen, pszIniFileName);

        if (dwResult == 0)
        {
            bReturn = FALSE;
			break;
        }
        else if (dwResult < dwBufferLen - sizeof(WCHAR))
        {
            bReturn = TRUE;
        }
        else
        {
            dwBufferLen += 0x10;

            pszTemp = new WCHAR[dwBufferLen];

            if (pszTemp)
            {
                wcscpy(pszTemp, pszBuffer);

                delete [] pszBuffer;

                pszBuffer = pszTemp;
            }
        }
    }

    if (bReturn)
    {
        bReturn = FALSE;

        for (pszKeyName = pszBuffer; *pszKeyName; pszKeyName = &pszKeyName[dwKeyNameLen + 1])
        {
            //
            // Remove the quotes from the string
            //
            dwKeyNameLen = wcslen(pszKeyName);

            pszKeyName[dwKeyNameLen - 1] = '\0';

            if (StringCompareWildcard(pszDeviceDescription, &pszKeyName[1]))
            {
                //
                // Replace the quotes to the string
                //
                pszKeyName[dwKeyNameLen - 1] = '\"';

                //
                // Get the specific section string from the ini file
                //
                if (GetIniString(pszIniFileName, pszIniPortsSection, pszKeyName, pszSectionName, dwSectionNameLen) == TRUE)
                {
                    bReturn = TRUE;
                }

                break;
            }
        }
    }

    delete [] pszBuffer;

    return bReturn;
}

#endif //NTONLY

/*++

Routine Name

    GetThisPrinter

Routine Description:

    Gets a pointer to a chunk of memory that contains a PRINTER_INFO structure
    as specified by level. Caller must use delte [] to free the returned memory

Arguments:

    hPrinter   - handle to printer
    dwLevel    - level of the call
    ppData     - pointer to allocated printer information. caller needs to do delete []

Return Value:

    Win32 error code

--*/
DWORD
GetThisPrinter(
    IN     HANDLE   hPrinter,
    IN     DWORD    dwLevel,
    IN OUT BYTE   **ppData
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (hPrinter && ppData)
    {
        dwError = ERROR_DLL_NOT_FOUND;

        *ppData = NULL;

        BYTE   *pBuf  = NULL;
        DWORD   cbBuf = 0;

        // Use of delay loaded functions requires exception handler.
        SetStructuredExceptionHandler seh;
	    try
        {
            dwError = ::GetPrinter(hPrinter, dwLevel, pBuf, cbBuf, &cbBuf) ? ERROR_SUCCESS : GetLastError();

            if (dwError == ERROR_INSUFFICIENT_BUFFER)
            {
                pBuf = new BYTE[cbBuf];

                if (pBuf)
                {
                    dwError = ::GetPrinter(hPrinter, dwLevel, pBuf, cbBuf, &cbBuf) ? ERROR_SUCCESS : GetLastError();

                    if (dwError==ERROR_SUCCESS)
                    {
                       *ppData = pBuf;
                    }
                    else
                    {
                        delete [] pBuf;
                    }
                }
                else
                {
                    dwError = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
        }
        catch(Structured_Exception se)
        {
            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
            if(pBuf)
            {
                delete [] pBuf;
                pBuf = NULL;
            }
        }
    }

    return dwError;
}

/*++

Routine Name:

    GetTimeZoneBias

Routine Description:

    Returns the time zone bias.

Arguments:

    Nothing.

Return Value:

    Value of the time zone specific bias.

--*/
LONG
lGetTimeZoneBias(
    VOID
    )
{
    LONG lBias;
    TIME_ZONE_INFORMATION tzi;

    //
    // Get the time zone specific bias.
    //
    switch(GetTimeZoneInformation(&tzi))
    {
    case TIME_ZONE_ID_DAYLIGHT:

        lBias = (tzi.Bias + tzi.DaylightBias);
        break;

    case TIME_ZONE_ID_STANDARD:

        lBias = (tzi.Bias + tzi.StandardBias);
        break;

    case TIME_ZONE_ID_UNKNOWN:			

        lBias = tzi.Bias;
        break;						

    default:
        lBias = 0;
        break;
    }

    return lBias;
}

/*++

Routine Name:

    PrinterTimeToLocalTime

Routine Description:

    Converts the system time in minutes to local time in minutes.

Arguments:

    System time in minutes to convert.

    A system time structure that contains the converted local time in
    minutes if sucessful, otherwize returns the original system time.

--*/
VOID
PrinterTimeToLocalTime(
    IN     DWORD       Minutes,
    IN OUT SYSTEMTIME *pSysTime
    )
{
    //
    // NULL the out parameter
    //
    memset(pSysTime, 0,  sizeof(SYSTEMTIME));

    //
    // Ensure there is no wrap around.  Add a full day to prevent biases
    //
    Minutes += (24*60);

    //
    // Adjust for bias.
    //
    Minutes -= lGetTimeZoneBias();

    //
    // Now discard extra day.
    //
    Minutes = Minutes % (24*60);

    pSysTime->wHour   = static_cast<WORD>(Minutes / 60);
    pSysTime->wMinute = static_cast<WORD>(Minutes % 60);
}


/*++

Routine Name:

    LocalTimeToPrinterTime

Routine Description:

    Converts the local time in minutes to system time in minutes.

Arguments:

    Local time in minutes to convert.

Return Value:

    The converted system time in minutes if sucessful,
    otherwize returns the original local time.

--*/
DWORD
LocalTimeToPrinterTime(
    IN CONST SYSTEMTIME &st
    )
{
    DWORD Minutes = st.wHour * 60 + st.wMinute;
    //
    // Ensure there is no wrap around.  Add a full day to prevent biases
    //
    Minutes += (24*60);

    //
    // Adjust for bias.
    //
    Minutes += lGetTimeZoneBias();

    //
    // Now discard extra day.
    //
    Minutes = Minutes % (24*60);

    return Minutes;
}

/*++

Routine Name:

    MultiSzCount

Routine Description:

    Counts how many strings are in an multi sz

Arguments:

    psz - pointer to multi sz

Return Value:

    count of strings in multi sz

--*/
UINT
MultiSzCount(
    IN LPCWSTR psz
    )
{
    UINT nCount = 0;

    for ( ; psz && *psz; )
    {
        psz += wcslen (psz) + 1;
        nCount++;
    }

    return nCount;
}

/*++

Routine Name:

    CreateSafeArrayFromMultiSz

Routine Description:

    ANSI version not defined

Arguments:

    pszMultiSz - pointer to multi sz
    pArray     - pointer to pointer to safearry

Return Value:

    HRESULT

--*/
HRESULT
CreateSafeArrayFromMultiSz(
    IN  LPCSTR      pszMultiSz,
    OUT SAFEARRAY **pArray
    )
{
    return WBEM_E_NOT_FOUND;
}

/*++

Routine Name:

    CreateSafeArrayFromMultiSz

Routine Description:

    Parses a multi sz and createss a safearray with strings

Arguments:

    pszMultiSz - pointer to multi sz
    pArray     - pointer to pointer to safearry. Caller must use
                 SafeArrayDestroy to free the safe array  

Return Value:

    HRESULT

--*/
HRESULT
CreateSafeArrayFromMultiSz(
    IN  LPCWSTR     pszMultiSz,
    OUT SAFEARRAY **pArray
    )
{
    HRESULT hRes = WBEM_E_INVALID_PARAMETER;

    if (pArray)
    {
        *pArray = NULL;

        hRes = WBEM_S_NO_ERROR;

        SAFEARRAYBOUND rgsabound[1];

        rgsabound[0].lLbound   = 0;
        rgsabound[0].cElements = MultiSzCount(pszMultiSz);

        if (rgsabound[0].cElements)
        {
            *pArray = SafeArrayCreate(VT_BSTR, 1, rgsabound);

            if (*pArray)
            {
                long    Index = 0;
                LPWSTR  psz   = const_cast<LPWSTR>(pszMultiSz);

                for (Index = 0; SUCCEEDED(hRes) && Index < rgsabound[0].cElements; Index++)
                {
                    BSTR bstr = SysAllocString(psz);

                    if (bstr)
                    {
                        hRes = SafeArrayPutElement (*pArray, &Index, bstr);

                        SysFreeString(bstr);
                    }
                    else
                    {
                        hRes = WBEM_E_OUT_OF_MEMORY;
                    }

                     psz += wcslen (psz) + 1;
                }

                if (FAILED(hRes) && *pArray)
                {
                    SafeArrayDestroy(*pArray);
                }
            }
            else
            {
                hRes = WBEM_E_OUT_OF_MEMORY;
            }
        }
    }

    return hRes;
}

/*++

Routine Name

    InstanceGetString

Routine Description:

    Helper function. Stores a property from an Instance into
    a CHString. If the property is NULL, the function fails
    if bFailOnEmtpyString is true, or succeeds and set the
    out parameter to a default value

Arguments:

    Instance           - reference to instance
    pszProperty        - property name for which to retrieve the data
    pcsString          - pointer to string class, will recevie the
                         string stored in pszProperty
    bFailOnEmptyString - if true, the function will fail if the property in the
                         instance contains no value or an empty string
    pszDEfaultValue    - if bAcceptEmptyString is true, and pszProperty has no string
                         in it, this value will be returned in csString

Return Value:

    DWORD Error status of the call

--*/
HRESULT
InstanceGetString(
    IN     CONST CInstance &Instance,
    IN           LPCWSTR    pszProperty,
    IN OUT       CHString  *pcsString,
    IN           BOOL       bFailOnEmptyString,
    IN           LPWSTR     pszDefaultValue
    )
{
    HRESULT hRes      = WBEM_E_INVALID_PARAMETER;
    bool    t_Exists;
	VARTYPE t_Type    = VT_NULL;

    if (pcsString &&
        Instance.GetStatus(pszProperty, t_Exists, t_Type) && 
        t_Exists)
    {
        switch(t_Type)
        {
        case VT_NULL:
            //
            // Property exists and but no value was specified. Check if caller wants
            // the default value to be returned
            //
            if (!bFailOnEmptyString)
            {
                hRes = WBEM_S_NO_ERROR;

                *pcsString = pszDefaultValue;
            }

            break;

        case VT_BSTR:
            //
            // Property exists and is string
            //
            hRes = WBEM_E_PROVIDER_FAILURE;

            if (Instance.GetCHString(pszProperty, *pcsString))
            {
                hRes = bFailOnEmptyString && pcsString->IsEmpty() ? WBEM_E_INVALID_PARAMETER : WBEM_S_NO_ERROR;
            }

            break;

        default:
            hRes = WBEM_E_INVALID_PARAMETER;
        }
    }

    return hRes;
}

/*++

Routine Name

    InstanceGetDword

Routine Description:

    Helper function. Stores a property from an Instance into
    a DWORD. If the property is NULL, the function will set the
    out parameter to a default value

Arguments:

    Instance       - reference to instance
    pszPropert     - property name
    pdwOut         - pointer to dword
    dwDefaultValue - if the property is null, the function will set dwOut to this value

Return Value:

    DWORD Error status of the call

--*/
HRESULT
InstanceGetDword(
    IN     CONST CInstance &Instance,
    IN           LPCWSTR    pszProperty,
    IN OUT       DWORD     *pdwOut,
    IN           DWORD      dwDefaultValue
    )
{
    HRESULT hRes      = WBEM_E_INVALID_PARAMETER;
    bool    t_Exists;
	VARTYPE t_Type    = VT_NULL;

    if (pdwOut &&
        Instance.GetStatus(pszProperty, t_Exists, t_Type) && 
        t_Exists)
    {
        switch(t_Type)
        {
        case VT_NULL:
            //
            // Property exists and but no value was specified. Return the default value
            //
            *pdwOut = dwDefaultValue;

            hRes  = WBEM_S_NO_ERROR;

            break;

        case VT_I4:
            //
            // Property exists and is DWORD
            //
            hRes = Instance.GetDWORD(pszProperty, *pdwOut) ? WBEM_S_NO_ERROR : WBEM_E_PROVIDER_FAILURE;

            break;

        default:
            hRes = WBEM_E_INVALID_PARAMETER;
        }
    }

    return hRes;
}

/*++

Routine Name

    InstanceGetBool

Routine Description:

    Helper function. Stores a property from an Instance into
    a BOOL. If the property is NULL, the function will set the
    out parameter to a default value

Arguments:

    Instance           - reference to instance
    pszProperty        - property name for which to retrieve the data
    pbOut              - pointer to bool, will recevie the bool stored in pszProperty
    pszDEfaultValue    - if pszProperty has no bool in it, this value will be returned in bOut

Return Value:

    DWORD Error status of the call

--*/
HRESULT
InstanceGetBool(
    IN     CONST CInstance &Instance,
    IN           LPCWSTR    pszProperty,
    IN OUT       BOOL      *pbOut,
    IN           BOOL       bDefaultValue
    )
{
    HRESULT hRes      = WBEM_E_INVALID_PARAMETER;
    bool    t_Exists;
	VARTYPE t_Type    = VT_NULL;
    
    if (pbOut &&
        Instance.GetStatus(pszProperty, t_Exists, t_Type) && 
        t_Exists)
    {
        bool bTemp;

        switch(t_Type)
        {
        case VT_NULL:
            //
            // Property exists and but no value was specified. Return the default value
            //
            *pbOut = bDefaultValue;

            hRes  = WBEM_S_NO_ERROR;

            break;

        case VT_BOOL:

            //
            // Property exists and is DWORD
            //
            hRes = Instance.Getbool(pszProperty, bTemp) ? WBEM_S_NO_ERROR : WBEM_E_PROVIDER_FAILURE;

            if (SUCCEEDED(hRes)) 
            {
                *pbOut = bTemp;
            }

            break;

        default:
            hRes = WBEM_E_INVALID_PARAMETER;
        }
    }

    return hRes;
}

/*++

Routine Name

    SetReturnValue

Routine Description:

    Sets the error resulted from ExecMethod in the out parameter

Arguments:

    pOutParams - pointer to Instance representing the out params of a method
    dwError    - error number to be set

Return Value:

    none

--*/
VOID
SetReturnValue(
    IN CInstance *pOutParams,
    IN DWORD      dwError
    )
{
	if (pOutParams)
    {
        pOutParams->SetDWORD(kMethodReturnValue, dwError);
    }
}

/*++

Routine Name

    SplIsPrinterInstalled

Routine Description:

    Checks if a printer is installed locally. This is useful especially 
    for printer connection. Let's say we have "\\ntprint\hp4000". This
    function will determinte if we have a connection to this printer or
    not. GetPrinter will level 4 doesn't help in this case.
    
Arguments:

    pszPrinter  - printer name
    pbInstalled - pointer to bool

Return Value:

    Win32 error code
    
--*/
DWORD
SplIsPrinterInstalled(
    IN  LPCWSTR  pszPrinter,
    OUT BOOL    *pbInstalled
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (pszPrinter && pbInstalled) 
    {
        DWORD  dwFlags   = PRINTER_ENUM_LOCAL|PRINTER_ENUM_CONNECTIONS;
        DWORD  dwLevel   = 4;
        DWORD  cbNeeded  = 0;
        DWORD  cReturned = 0;

        *pbInstalled = FALSE;
        
        dwError = ERROR_MOD_NOT_FOUND;
        
        dwError = ERROR_SUCCESS;

        if (!EnumPrinters(dwFlags,
                                        NULL,
                                        dwLevel,
                                        NULL,
                                        0,
                                        &cbNeeded,
                                        &cReturned) &&
            (dwError = GetLastError()) == ERROR_INSUFFICIENT_BUFFER)            
        {
            BYTE *pBuf = new BYTE[cbNeeded];

            if (pBuf) 
            {
                if (EnumPrinters(dwFlags,
                                               NULL,
                                               dwLevel,
                                               pBuf,
                                               cbNeeded,
                                               &cbNeeded,
                                               &cReturned)) 
                {
                    PRINTER_INFO_4 *pPrn4 = reinterpret_cast<PRINTER_INFO_4 *>(pBuf);

                    for (DWORD i = 0; i < cReturned; i++, pPrn4++)
                    {
                        if (!lstrcmpi(pPrn4->pPrinterName, pszPrinter)) 
                        {
                            *pbInstalled = TRUE;

                            break;
                        }
                    }

                    dwError = ERROR_SUCCESS;
                }
                else
                {
                    dwError = GetLastError();
                }

                delete [] pBuf;
            }
            else
            {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
            }            
        }
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\prninterface.cpp ===
/*++



//  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
All rights reserved.

Module Name:

    PrnInterface.cpp

Abstract:

    Interface for WMI Provider. Used for doing printer object
    management: printers, driver, ports, jobs.

Author:

    Felix Maxa (AMaxa)  03-March-2000

--*/

#include <precomp.h>
#if NTONLY == 5
#include <winspool.h>
#include "tcpxcv.h"
#include "prninterface.h"
#include "prnutil.h"
#include <DllWrapperBase.h>
#include <WSock32api.h>

LPCWSTR kXcvPortConfigOpenPrinter = L",XcvPort ";
LPCWSTR kXcvPortGetConfig         = L"GetConfigInfo";
LPCWSTR kXcvPortSetConfig         = L"ConfigPort";
LPCWSTR kXcvPortDelete            = L"DeletePort";
LPCWSTR kXcvPortAdd               = L"AddPort";
LPWSTR  kXcvPortOpenPrinter       = L",XcvMonitor Standard TCP/IP Port";

LPCWSTR kDefaultCommunity         = L"public";
LPCWSTR kDefaultQueue             = L"lpr";


/*++

Routine Name

    SplPrinterDel

Routine Description:

    Deletes a printer

Arguments:

    pszPrinter - printer name

Return Value:

    Win32 Error code

--*/

DWORD
SplPrinterDel(
    IN LPCWSTR pszPrinter
    )
{
    DWORD             dwError          = ERROR_INVALID_PRINTER_NAME;
    HANDLE            hPrinter         = NULL;
    PRINTER_DEFAULTS  PrinterDefaults  = {NULL, NULL, PRINTER_ALL_ACCESS};

    if (pszPrinter)
    {
        dwError = ERROR_DLL_NOT_FOUND;

        //
        // Open the printer.
        //
        // Use of delay loaded function requires exception handler.
        SetStructuredExceptionHandler seh;

        try
        {
            if (::OpenPrinter(const_cast<LPTSTR>(pszPrinter), &hPrinter, &PrinterDefaults))
            {
                dwError = ::DeletePrinter(hPrinter) ? ERROR_SUCCESS : GetLastError();

                ::ClosePrinter(hPrinter);
            }
            else
            {
                dwError = GetLastError();
            }
        }
        catch(Structured_Exception se)
        {
            DelayLoadDllExceptionFilter(se.GetExtendedInfo());    
        }
    }

    DBGMSG(DBG_TRACE, (_T("SplPrinterDel returns %u\n"), dwError));

    return dwError;
}

/*++

Routine Name

    SplPrintTestPage

Routine Description:

    Prints a test page

Arguments:

    pPrinter - printer name

Return Value:

    Win32 Error code

--*/
DWORD
SplPrintTestPage(
    IN LPCWSTR pPrinter
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (pPrinter && pPrinter)
    {
        //
        // CHString throws exceptions. We start building the
        // command string for calling into printui
        //
        try
        {
            CHString csCommand;
            CHString csTemp;

            csCommand += TUISymbols::kstrQuiet;
            csCommand += TUISymbols::kstrPrintTestPage;

            //
            // Append printer name to the command
            //
            csTemp.Format(TUISymbols::kstrPrinterName, pPrinter);
            csCommand += csTemp;

            DBGMSG(DBG_TRACE, (_T("SplPrintTestPage csCommand \"%s\"\n"), csCommand));

            dwError = PrintUIEntryW(csCommand);
        }
        catch (CHeap_Exception)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    DBGMSG(DBG_TRACE, (_T("SplPrintTestPage returns %u\n"), dwError));

    return dwError;
}

/*++

Routine Name

    SplPrinterAdd

Routine Description:

    Adds a printer queue

Arguments:

    A pointer to PRINTER_INFO_2 structure

Return Value:

    Win32 Error code

--*/
DWORD
SplPrinterAdd(
    IN PRINTER_INFO_2 &Printer2
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (Printer2.pPrinterName && Printer2.pDriverName && Printer2.pPortName)
    {
        //
        // CHString throws exceptions. We start building the
        // command string for calling into printui
        //
        try
        {
            CHString csCommand;
            CHString csTemp;

            csCommand += TUISymbols::kstrQuiet;
            csCommand += TUISymbols::kstrAddPrinter;

            //
            // Append printer name to the command
            //
            csTemp.Format(TUISymbols::kstrBasePrinterName, Printer2.pPrinterName);
            csCommand += csTemp;

            //
            // Append driver name to the command
            //
            csTemp.Format(TUISymbols::kstrDriverModelName, Printer2.pDriverName);
            csCommand += csTemp;

            //
            // Append port name to the command
            //
            csTemp.Format(TUISymbols::kstrPortName, Printer2.pPortName);
            csCommand += csTemp;

            DBGMSG(DBG_TRACE, (_T("SplPrinterAdd csCommand \"%s\"\n"), csCommand));

            dwError = PrintUIEntryW(csCommand);

            //
            // Set all the additional information about the printer
            // (information what cannot be set as part of the add printer)
            //
            if (dwError==ERROR_SUCCESS)
            {
                dwError = SplPrinterSet(Printer2);

                //
                // We need to delete the printer if the set failed
                //
                if (dwError!=ERROR_SUCCESS)
                {
                    DBGMSG(DBG_TRACE, (_T("SplPrinterAdd SetPrinter failed. Deleting printer\n")));

                    //
                    // Disregard error code
                    //
                    SplPrinterDel(Printer2.pPrinterName);
                }
            }
        }
        catch (CHeap_Exception)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    DBGMSG(DBG_TRACE, (_T("SplPrinterAdd returns %u\n"), dwError));

    return dwError;
}

/*++

Routine Name

    SplPrinterSet

Routine Description:

    Sets printer properties using the data set in the object members

Arguments:

    Nothing

Return Value:

    Win32 Error code

--*/
DWORD
SplPrinterSet(
    IN PRINTER_INFO_2 &Printer2
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    //
    // We do not support setting the devmode or the security descriptor
    //
    if (Printer2.pPrinterName && !Printer2.pDevMode && !Printer2.pSecurityDescriptor)
    {
        HANDLE             hPrinter         = NULL;
        PPRINTER_INFO_2    pInfo            = NULL;
        PRINTER_DEFAULTS   PrinterDefaults  = {NULL, NULL, PRINTER_ALL_ACCESS};
        DWORD              dwOldAttributes  = 0;
        DWORD              dwNewAttributes  = 0;

        dwError = ERROR_DLL_NOT_FOUND;

        //
        // Open the printer.
        //

        // Use of delay loaded functions requires exception handler.
        SetStructuredExceptionHandler seh;

        try
        {
            if (::OpenPrinter(Printer2.pPrinterName, &hPrinter, &PrinterDefaults))
            {
                //
                // Get the printer data. ATTENTION This doesn't work on Win9x because of the
                // mutex in the CWinSpoolApi class
                //
                dwError = GetThisPrinter(hPrinter, 2, reinterpret_cast<BYTE **>(&pInfo));

                //
                // Merge in any changed fields.
                //

                if (dwError==ERROR_SUCCESS)
                {
                    //
                    // Publishing and UnPublishing needs to be special cased, since this setting is
                    // not done in the printer info 2 structure.  The published bit is a read only
                    // attribute in the printer info 2, the publish state is changed using set printer
                    // info 7.
                    //
                    dwOldAttributes = pInfo->Attributes;
                    dwNewAttributes = Printer2.Attributes != -1 ? Printer2.Attributes : pInfo->Attributes;

                    //
                    // Copy the changed date into the info sturcture.
                    //
                    pInfo->pPrinterName     = Printer2.pPrinterName ? Printer2.pPrinterName     : pInfo->pPrinterName;
                    pInfo->pShareName       = Printer2.pShareName   ? Printer2.pShareName       : pInfo->pShareName;
                    pInfo->pPortName        = Printer2.pPortName    ? Printer2.pPortName        : pInfo->pPortName;
                    pInfo->pDriverName      = Printer2.pDriverName  ? Printer2.pDriverName      : pInfo->pDriverName;
                    pInfo->pComment         = Printer2.pComment     ? Printer2.pComment         : pInfo->pComment;
                    pInfo->pLocation        = Printer2.pLocation    ? Printer2.pLocation        : pInfo->pLocation;
                    pInfo->pSepFile         = Printer2.pSepFile     ? Printer2.pSepFile         : pInfo->pSepFile;
                    pInfo->pParameters      = Printer2.pParameters  ? Printer2.pParameters      : pInfo->pParameters;
                    pInfo->pDatatype        = Printer2.pDatatype && *Printer2.pDatatype
                                                                    ? Printer2.pDatatype        : pInfo->pDatatype;
                    pInfo->pPrintProcessor  = Printer2.pPrintProcessor && *Printer2.pPrintProcessor
                                                                    ? Printer2.pPrintProcessor  : pInfo->pPrintProcessor;

                    //
                    // We cannot have 0 as attributes. So 0 will mean not initialized
                    //
                    pInfo->Attributes       = Printer2.Attributes             ? Printer2.Attributes       : pInfo->Attributes;
                    pInfo->Priority         = Printer2.Priority         != -1 ? Printer2.Priority         : pInfo->Priority;
                    pInfo->DefaultPriority  = Printer2.DefaultPriority  != -1 ? Printer2.DefaultPriority  : pInfo->DefaultPriority;
                    pInfo->StartTime        = Printer2.StartTime        != -1 ? Printer2.StartTime        : pInfo->StartTime;
                    pInfo->UntilTime        = Printer2.UntilTime        != -1 ? Printer2.UntilTime        : pInfo->UntilTime;

                    if (pInfo->StartTime == pInfo->UntilTime)
                    {
                        //
                        // Printer is always avaiable
                        //
                        pInfo->StartTime = pInfo->UntilTime = 0;
                    }

                    //
                    // Set the changed printer data.
                    //
                    if (::SetPrinter(hPrinter, 2, (PBYTE)pInfo, 0))
                    {
                        dwError = ERROR_SUCCESS;

                        //
                        // Control printer
                        //
                        if (Printer2.Status)
                        {
                            dwError = ::SetPrinter(hPrinter, 0, NULL, Printer2.Status) ? ERROR_SUCCESS : GetLastError();
                        }
                    }
                    else
                    {
                        dwError = GetLastError();
                    }

                    //
                    // Handle the printer publishing case.
                    //
                    if (dwError == ERROR_SUCCESS)
                    {
                        BOOL           bWasPublished = dwOldAttributes & PRINTER_ATTRIBUTE_PUBLISHED;
                        BOOL           bPublishNow   = dwNewAttributes & PRINTER_ATTRIBUTE_PUBLISHED;
                        PRINTER_INFO_7 Info7         = {0};
                        BOOL           bCallSetPrn   = TRUE;

                        if (bWasPublished && !bPublishNow) 
                        {
                            //
                            // unpublish
                            //
                            Info7.dwAction = DSPRINT_UNPUBLISH;                            
                        }
                        else if (!bWasPublished && bPublishNow) 
                        {
                            //
                            // publish
                            //
                            Info7.dwAction = DSPRINT_PUBLISH;                            
                        }
                        else
                        {
                            //
                            // don't do anything
                            //
                            bCallSetPrn = FALSE;                            
                        }

                        if (bCallSetPrn) 
                        {
                            //
                            // The UI will unpublish a printer if the printer becomes unshared. The UI 
                            // allows a printer to be published only if it is shared. The code here
                            // mimics the API set, rather than the UI
                            //
                            dwError = ::SetPrinter(hPrinter, 7, (PBYTE)&Info7, 0) ? ERROR_SUCCESS : GetLastError();
    
                            //
                            // Printer info 7 fails with ERROR_IO_PENDING when the publishing is occurring
                            // in the background. 
                            //
                            dwError = dwError == ERROR_IO_PENDING ? ERROR_SUCCESS : dwError;                            
                        }                        
                    }

                    //
                    // Release the printer info data.
                    //
                    delete [] pInfo;
                }

                //
                // Close the printer handle
                //
                ::ClosePrinter(hPrinter);
            }
            else
            {
                dwError = GetLastError();
            }
        }
        catch(Structured_Exception se)
        {
            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        }
    }

    DBGMSG(DBG_TRACE, (_T("SplPrinterSet returns %u\n"), dwError));

    return dwError;
}

/*++

Routine Name

    SplPrinterRename

Routine Description:

    Changes the name of a printer

Arguments:

    pCurrentPrinterName - old printer name
    pNewPrinterName     - new printer name

Return Value:

    Win32 error code

--*/
DWORD
SplPrinterRename(
    IN LPCWSTR pCurrentPrinterName,
    IN LPCWSTR pNewPrinterName
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (pCurrentPrinterName && pNewPrinterName)
    {
        HANDLE             hPrinter         = NULL;
        PPRINTER_INFO_2    pInfo            = NULL;
        PRINTER_DEFAULTS   PrinterDefaults  = {NULL, NULL, PRINTER_ALL_ACCESS};

        dwError = ERROR_DLL_NOT_FOUND;

        //
        // Open the printer.
        //
        
        // Use of delay loaded functions requires exception handler.
        SetStructuredExceptionHandler seh;
        try
        {
            dwError = ::OpenPrinter(const_cast<LPTSTR>(pCurrentPrinterName), &hPrinter, &PrinterDefaults) ? ERROR_SUCCESS : GetLastError();

            if (dwError==ERROR_SUCCESS)
            {
                //
                // Get the printer data. ATTENTION. This would normally not work on Win9x,
                // because of the MUTEX
                //
                dwError = GetThisPrinter(hPrinter, 2, reinterpret_cast<BYTE **>(&pInfo));

                if (dwError==ERROR_SUCCESS)
                {
                    pInfo->pPrinterName = const_cast<LPWSTR>(pNewPrinterName);

                    dwError = ::SetPrinter(hPrinter, 2, reinterpret_cast<BYTE *>(pInfo), 0) ? ERROR_SUCCESS : GetLastError();

                    delete [] pInfo;
                }

                ::ClosePrinter(hPrinter);
            }
        }
        catch(Structured_Exception se)
        {
            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
            dwError = ERROR_DLL_NOT_FOUND;
        }
    }

    DBGMSG(DBG_TRACE, (_T("SplPrinterRename returns %u\n"), dwError));

    return dwError;
}

/*++

Routine Name

    SplDriverAdd

Routine Description:

    Adds a printer driver.

Arguments:

    pszDriverName  - required name of the driver
    dwVersion      - driver version. optional (pass -1)
    pszEnvironment - driver environment. optional (pass NULL)
    pszInfName     - path to an inf file. optional (pass NULL)
    pszFilePath    - path to the driver binaries. optional (pass NULL)

Return Value:

    Win32 error code

--*/
DWORD
SplDriverAdd(
    IN LPCWSTR pszDriverName,
    IN DWORD   dwVersion,
    IN LPCWSTR pszEnvironment,
    IN LPCWSTR pszInfName,
    IN LPCWSTR pszFilePath)
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (pszDriverName)
    {
        //
        // CHString throws exceptions. We start building the
        // command string for calling into printui
        //
        try
        {
            CHString csCommand;
            CHString csTemp;

            csCommand += TUISymbols::kstrQuiet;
            csCommand += TUISymbols::kstrAddDriver;

            //
            // Append driver name to the command
            //
            csTemp.Format(TUISymbols::kstrDriverModelName, pszDriverName);
            csCommand += csTemp;

            //
            // Append inf file name to the command
            //
            if (pszInfName)
            {
                csTemp.Format(TUISymbols::kstrInfFile, pszInfName);
                csCommand += csTemp;
            }

            //
            // Append the path to the driver binaries to the command
            //
            if (pszFilePath)
            {
                csTemp.Format(TUISymbols::kstrDriverPath, pszFilePath);
                csCommand += csTemp;
            }

            if (pszEnvironment)
            {
                csTemp.Format(TUISymbols::kstrDriverArchitecture, pszEnvironment);
                csCommand += csTemp;
            }

            //
            // Append the driver verion to the command
            //
            if (dwVersion != (DWORD)-1)
            {
                csTemp.Format(TUISymbols::kstrDriverVersion, dwVersion);
                csCommand += csTemp;
            }

            DBGMSG(DBG_TRACE, (_T("SplDriverAdd csCommand \"%s\"\n"), csCommand));

            dwError = PrintUIEntryW(csCommand);
        }
        catch (CHeap_Exception)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    DBGMSG(DBG_TRACE, (_T("SplDriverAdd returns %u\n"), dwError));

    return dwError;
}

/*++

Routine Name

    SplDriverDel

Routine Description:

    Deletes a printer driver.

Arguments:

    pszDriverName  - required name of the driver
    dwVersion      - optional (pass -1)
    pszEnvironment - optional (pass NULL)

Return Value:

    Win32 error code

--*/
DWORD
SplDriverDel(
    IN LPCWSTR pszDriverName,
    IN DWORD   dwVersion,
    IN LPCWSTR pszEnvironment
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (pszDriverName)
    {
        //
        // CHString throws exceptions. We start building the
        // command string for calling into printui
        //
        try
        {
            CHString csCommand;
            CHString csTemp;

            csCommand += TUISymbols::kstrQuiet;
            csCommand += TUISymbols::kstrDelDriver;

            //
            // Append driver name to the command
            //
            csTemp.Format(TUISymbols::kstrDriverModelName, pszDriverName);
            csCommand += csTemp;

            if (pszEnvironment)
            {
                csTemp.Format(TUISymbols::kstrDriverArchitecture, pszEnvironment);
                csCommand += csTemp;
            }

            //
            // Append the driver verion to the command
            //
            if (dwVersion!=(DWORD)-1)
            {
                csTemp.Format(TUISymbols::kstrDriverVersion, dwVersion);
                csCommand += csTemp;
            }

            DBGMSG(DBG_TRACE, (_T("SplDriverDel csCommand \"%s\"\n"), csCommand));

            dwError = PrintUIEntryW(csCommand);
        }
        catch (CHeap_Exception)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    DBGMSG(DBG_TRACE, (_T("SplDriverDel returns %u\n"), dwError));

    return dwError;
}

/*++

Routine Name:

    SplPortAddTCP

Routine Description:

    Add a Standard TCP port

Arguments:

    PORT_DATA_1 structure

Return Value:

    Win32 error code

--*/
DWORD
SplPortAddTCP(
    IN PORT_DATA_1 &Port
    )
{
    DWORD             dwError        = ERROR_INVALID_PARAMETER;
    PRINTER_DEFAULTS  PrinterDefault = {NULL, NULL, SERVER_ACCESS_ADMINISTER};
    HANDLE            hXcvPrinter    = NULL;
    PORT_DATA_1       PortDummy      = {0};

    memcpy(&PortDummy, &Port, sizeof(Port));

    if (PortDummy.sztPortName[0])
    {
        dwError = ERROR_DLL_NOT_FOUND;

        // Use of delay loaded functions requires exception handler.
        SetStructuredExceptionHandler seh;
        try
        {
            dwError = ::OpenPrinter(kXcvPortOpenPrinter, &hXcvPrinter, &PrinterDefault) ? ERROR_SUCCESS : GetLastError();

            if (dwError==ERROR_SUCCESS)
            {
                //
                // Set defaults
                //
                PortDummy.dwCoreUIVersion  = kCoreVersion;
                PortDummy.dwVersion        = kTCPVersion;
                PortDummy.cbSize           = sizeof(PortDummy);
                PortDummy.dwProtocol       = PortDummy.dwProtocol     ? PortDummy.dwProtocol     : kProtocolRaw;
                PortDummy.dwSNMPDevIndex   = PortDummy.dwSNMPDevIndex ? PortDummy.dwSNMPDevIndex : kDefaultSnmpIndex;

                //
                // Set default port number
                //
                if (!PortDummy.dwPortNumber)
                {
                    PortDummy.dwPortNumber = PortDummy.dwProtocol==kProtocolRaw ? kDefaultRawNumber : kDefaultLprNumber;
                }

                if (PortDummy.dwSNMPEnabled && !PortDummy.sztSNMPCommunity[0])
                {
                    wcscpy(PortDummy.sztSNMPCommunity, _T("public"));
                }

                if (PortDummy.dwProtocol==kProtocolLpr && !PortDummy.sztQueue[0])
                {
                    wcscpy(PortDummy.sztQueue, _T("lpr"));
                }

                dwError  = CallXcvDataW(hXcvPrinter,
                                        kXcvPortAdd,
                                        reinterpret_cast<BYTE *>(&PortDummy),
                                        PortDummy.cbSize,
                                        NULL,
                                        0);

                ::ClosePrinter(hXcvPrinter);
            }
        }
        catch(Structured_Exception se)
        {
            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        }

    }

    DBGMSG(DBG_TRACE, (_T("SplPortAddTCP returns %u\n"), dwError));

    return dwError;
}

/*++

Routine Name:

    SplTCPPortSetConfig

Routine Description:

    Set configuration of a Standard TCP port. Note that we do not default any properties.

Arguments:

    PORT_DATA_1 structure

Return Value:

    Win32 error code

--*/
DWORD
SplTCPPortSetConfig(
    IN PORT_DATA_1 &Port
    )
{
    DWORD             dwError        = ERROR_INVALID_PARAMETER;
    PRINTER_DEFAULTS  PrinterDefault = {NULL, NULL, SERVER_ACCESS_ADMINISTER};
    HANDLE            hXcvPrinter    = NULL;
    PORT_DATA_1       PortDummy      = {0};

    memcpy(&PortDummy, &Port, sizeof(Port));

    if (PortDummy.sztPortName[0])
    {
        dwError = ERROR_DLL_NOT_FOUND;

        // Use of delay loaded functions requires exception handler.
        SetStructuredExceptionHandler seh;
        try
        {
            dwError = ::OpenPrinter(kXcvPortOpenPrinter, &hXcvPrinter, &PrinterDefault) ? ERROR_SUCCESS : GetLastError();

            if (dwError == ERROR_SUCCESS)
            {
                //
                // Set defaults
                //
                PortDummy.dwCoreUIVersion  = kCoreVersion;
                PortDummy.dwVersion        = kTCPVersion;
                PortDummy.cbSize           = sizeof(PortDummy);

                //
                // Set default port number
                //
                if (!PortDummy.dwPortNumber)
                {
                    PortDummy.dwPortNumber = PortDummy.dwProtocol==kProtocolRaw ? kDefaultRawNumber : kDefaultLprNumber;
                }

                //
                // Set default queue name 
                //
                if (PortDummy.dwProtocol == LPR && !PortDummy.sztQueue[0])
                {
                    wcscpy(PortDummy.sztQueue, kDefaultQueue);
                }

                //
                // Set default snmp community name 
                //
                if (PortDummy.dwSNMPEnabled && !PortDummy.sztSNMPCommunity[0])
                {
                    wcscpy(PortDummy.sztSNMPCommunity, kDefaultCommunity);
                }

                dwError  = CallXcvDataW(hXcvPrinter,
                                        kXcvPortSetConfig,
                                        reinterpret_cast<BYTE *>(&PortDummy),
                                        PortDummy.cbSize,
                                        NULL,
                                        0);

                ::ClosePrinter(hXcvPrinter);
            }
        }
        catch(Structured_Exception se)
        {
            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        }
    }

    DBGMSG(DBG_TRACE, (_T("SplPortSetTCP returns %u\n"), dwError));

    return dwError;
}

/*++

Routine Name:

    SplPortDelTCP

Routine Description:

    Delete a Standard TCP port

Arguments:

    pszPort - port name

Return Value:

    Win32 error code

--*/
DWORD
SplPortDelTCP(
    IN LPCWSTR pszPort
    )
{
    DWORD              dwError        = ERROR_INVALID_PARAMETER;
    PRINTER_DEFAULTS   PrinterDefault = {NULL, NULL, SERVER_ACCESS_ADMINISTER};
    HANDLE             hXcvPrinter    = NULL;
    DELETE_PORT_DATA_1 PortDummy      = {0};

    if (pszPort && wcslen(pszPort) < MAX_PORTNAME_LEN)
    {
        dwError = ERROR_DLL_NOT_FOUND;

        // Use of delay loaded functions requires exception handler.
        SetStructuredExceptionHandler seh;

        try
        {
            dwError = ::OpenPrinter(kXcvPortOpenPrinter, &hXcvPrinter, &PrinterDefault) ? ERROR_SUCCESS : GetLastError();

            if (dwError==ERROR_SUCCESS)
            {
                PortDummy.dwVersion = kTCPVersion;

                wcscpy(PortDummy.psztPortName, pszPort);

                dwError  = CallXcvDataW(hXcvPrinter,
                                        kXcvPortDelete,
                                        reinterpret_cast<BYTE *>(&PortDummy),
                                        sizeof(PortDummy),
                                        NULL,
                                        0);

                ::ClosePrinter(hXcvPrinter);
            }
        }
        catch(Structured_Exception se)
        {
            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        }
    }

    DBGMSG(DBG_TRACE, (_T("SplPortDelTCP returns %u\n"), dwError));

    return dwError;
}

/*++

Routine Name:

    SplTCPPortGetConfig

Routine Description:

    Gets the configuration of a Standard TCP port

Arguments:

    pszPort - port name
    pData   - pointer to PORT_DATA_1 structure

Return Value:

    Win32 error code

--*/
DWORD
SplTCPPortGetConfig(
    IN     LPCWSTR       pszPort,
    IN OUT PORT_DATA_1 *pPortData
    )
{
    DWORD              dwError        = ERROR_INVALID_PARAMETER;
    PRINTER_DEFAULTS   PrinterDefault = {NULL, NULL, SERVER_ACCESS_ADMINISTER};
    HANDLE             hXcvPrinter    = NULL;
    
    if (pPortData && pszPort && wcslen(pszPort) < MAX_PORTNAME_LEN)
    {
        dwError = ERROR_DLL_NOT_FOUND;

        CHString csPort;

        csPort += kXcvPortConfigOpenPrinter;

        csPort += pszPort;
        // Use of delay loaded functions requires exception handler.
        SetStructuredExceptionHandler seh;

        try
        {
            dwError = ::OpenPrinter(const_cast<LPWSTR>(static_cast<LPCWSTR>(csPort)),
                                                &hXcvPrinter,
                                                &PrinterDefault) ? ERROR_SUCCESS : GetLastError();

            if (dwError==ERROR_SUCCESS)
            {
                CONFIG_INFO_DATA_1 cfgData = {0};
                cfgData.dwVersion          = 1;

                dwError = CallXcvDataW(hXcvPrinter,
                                      kXcvPortGetConfig,
                                      reinterpret_cast<BYTE *>(&cfgData),
                                      sizeof(cfgData),
                                      reinterpret_cast<BYTE *>(pPortData),
                                      sizeof(PORT_DATA_1));

                ::ClosePrinter(hXcvPrinter);
            }

            if (dwError == ERROR_SUCCESS) 
            {
                //
                // XcvData doesn't set port name in the port data structure.
                // We have to set it manually because that field may be used by the caller
                //
                wcscpy(pPortData->sztPortName, pszPort);
            }
        }
        catch(Structured_Exception se)
        {
            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        }
    }

    DBGMSG(DBG_TRACE, (_T("SplTCPPortGetConfig returns %u\n"), dwError));

    return dwError;
}





/*++

   Description:

   The following constants and functions are needed by the CompilePort.
   Thw whole functionality is used in the following context: we have an
   IP address. We find out what kind of device has that IP. Then we retrieve
   the properties of that device,if it is a printing device.

--*/
LPCWSTR pszIniNumPortsKey            = _T("PORTS");
LPCWSTR pszIniPortProtocolKey        = _T("PROTOCOL%d");
LPCWSTR pszIniPortNumberKey          = _T("PORTNUMBER%d");
LPCWSTR pszIniQueueKey               = _T("QUEUE%d");
LPCWSTR pszIniDoubleSpoolKey         = _T("LPRDSPOOL%d");
LPCWSTR pszSnmpCommunityKey          = _T("COMMUNITYNAME%d");
LPCWSTR pszIniSnmpDeviceIndex        = _T("DEVICE%d");
LPCWSTR pszIniSnmpEnabledKey         = _T("SNMP%d");
LPCWSTR pszIniPortDeviceNameKey      = _T("NAME");
LPCWSTR pszIniPortPortNameKey        = _T("NAME%d");
LPCWSTR pszPortProtocolRawString     = _T("RAW");
LPCWSTR pszPortProtocolLprString     = _T("LPR");
LPCWSTR pszSnmpEnabledYesString      = _T("YES");
LPCWSTR pszSnmpEnabledNoString       = _T("NO");
LPCWSTR pszTcpPortNamePrefix         = _T("IP_");
LPCWSTR pszIniFileName               = _T("%SystemRoot%\\system32\\tcpmon.ini");
LPCWSTR pszTcpMibDll                 = _T("tcpmib.dll");
LPCWSTR pszDefaultCommunityW         = _T("public");
LPCSTR  pszDefaultCommunityA         = "public";

enum EConstants
{
    kDefaultSNMPDeviceIndex  = 1,
    kSnmpEnabled             = 1,
    kSnmpDisabled            = 0,
};

class CTcpMib;

typedef CTcpMib* (CALLBACK *RPARAM_1) (VOID);

EXTERN_C CTcpMib* GetTcpMibPtr(VOID);

class __declspec(dllexport) CTcpMib
{
public:
    CTcpMib() { };

    virtual ~CTcpMib() { };

    virtual
    BOOL
    SupportsPrinterMib(LPCSTR lpszIPAddress,
                       LPCSTR lpszSNMPCommunity,
                       DWORD  dwSNMPDeviceIndex,
                       PBOOL  pbSupported) = 0;

    virtual
    DWORD
    GetDeviceDescription(LPCSTR lpszIPAddress,
                         LPCSTR lpszSNMPCommunity,
                         DWORD  dwSNMPDeviceIndex,
                         LPTSTR lpszDeviceDescription,
                         DWORD  dwDeviceDescriptionLen) = 0;
};

/*++

Routine Name:

    GetDeviceSettings

Routine Description:

    Gets the appropriate section name from the ini file based on the device description

Arguments:

    PortData - port data structure

Return Value:

    TRUE is function succeeds and port setting is collected

--*/
BOOL
GetDeviceSettings(
    IN OUT PORT_DATA_1 &PortData
    )
{
    DWORD     dwSelPortOnDevice = 1;
    WSADATA   wsaData;
    HINSTANCE hInstance;
    FARPROC   pGetTcpMibPtr;
    CTcpMib   *pTcpMib;
    WCHAR     szIniFileName[MAX_PATH + 1];
    CHAR      szHostAddressA[256];
    WCHAR     szDeviceSectionName[256];
    WCHAR     szPortProtocol[256];
    WCHAR     szKeyName[256];
    WCHAR     szDeviceName[256];
    DWORD     dwNumPortsOnDevice, TalkError;
    BOOL      bSNMPEnabled = FALSE;
    HRESULT   hRes         = WBEM_E_INVALID_PARAMETER;
    DWORD     dwError;

    //
    // Validate arguments
    //
    if (PortData.sztHostAddress[0])
    {
        hRes = WBEM_S_NO_ERROR;
    }

    if (SUCCEEDED(hRes))
    {
        hRes = WBEM_E_NOT_FOUND;

        CWsock32Api *pWSock32api = (CWsock32Api*)CResourceManager::sm_TheResourceManager.GetResource(g_guidWsock32Api, NULL);
    
        if (pWSock32api)
        {
            dwError = pWSock32api->WsWSAStartup(0x0101, (LPWSADATA) &wsaData);

            hRes    = WinErrorToWBEMhResult(dwError);

            if (SUCCEEDED(hRes))
            {
                if (hInstance = LoadLibrary(pszTcpMibDll))
                {
                    //
                    // Get the class pointer and class object and ini filename
                    //
                    if ( (pGetTcpMibPtr = (FARPROC) GetProcAddress(hInstance, "GetTcpMibPtr"))                             &&
                         (pTcpMib       = (CTcpMib *) pGetTcpMibPtr())                                                     &&
                         ExpandEnvironmentStrings(pszIniFileName, szIniFileName, sizeof(szIniFileName) / sizeof(WCHAR))    &&
                         WideCharToMultiByte(CP_ACP,
                                             0,
                                             PortData.sztHostAddress,
                                             -1,
                                             szHostAddressA,
                                             sizeof(szHostAddressA),
                                             NULL,
                                             NULL)                                                                       &&
                         (TalkError = pTcpMib->GetDeviceDescription(szHostAddressA,
                                                                    pszDefaultCommunityA,
                                                                    kDefaultSNMPDeviceIndex,
                                                                    PortData.sztDeviceType,
                                                                    sizeof(PortData.sztDeviceType))) == NO_ERROR         &&
                         GetDeviceSectionFromDeviceDescription(szIniFileName,
                                                               PortData.sztDeviceType,
                                                               szDeviceSectionName,
                                                               sizeof(szDeviceSectionName) / sizeof(WCHAR))              &&
                         pTcpMib->SupportsPrinterMib(szHostAddressA,
                                                     pszDefaultCommunityA,
                                                     kDefaultSNMPDeviceIndex,
                                                     &bSNMPEnabled))
                    {
                        PortData.dwSNMPEnabled = bSNMPEnabled ? kSnmpEnabled : kSnmpDisabled;

                        if (bSNMPEnabled)
                        {
                            PortData.dwSNMPDevIndex = kDefaultSNMPDeviceIndex;

                            wcscpy(PortData.sztSNMPCommunity, pszDefaultCommunityW);
                        }

                        //
                        // Get the Device name, ex: Hewlett Packard Jet Direct
                        //
                        hRes = GetIniString(szIniFileName,
                                            szDeviceSectionName,
                                            pszIniPortDeviceNameKey,
                                            szDeviceName,
                                            sizeof(szDeviceName) / sizeof(WCHAR)) ? WBEM_S_NO_ERROR : WBEM_E_FAILED;

                        if (SUCCEEDED(hRes))
                        {
                            //
                            // Get the number of ports on the device
                            //
                            hRes = GetIniDword(szIniFileName,
                                               szDeviceSectionName,
                                               pszIniNumPortsKey,
                                               &dwNumPortsOnDevice) ? WBEM_S_NO_ERROR : WBEM_E_FAILED;
                        }

                        if (SUCCEEDED(hRes))
                        {
                            //
                            // Create the string used to query the protocol, ex: PROTOCOL2
                            // refers to the protocol of the second port on the device
                            //
                            wsprintf(szKeyName, pszIniPortProtocolKey, dwSelPortOnDevice);

                            //
                            // Get the port protocol from the ini file
                            //
                            hRes = GetIniString(szIniFileName,
                                                szDeviceSectionName,
                                                szKeyName,
                                                szPortProtocol,
                                                sizeof(szPortProtocol) / sizeof(WCHAR)) ? WBEM_S_NO_ERROR : WBEM_E_FAILED;
                        }

                        if (SUCCEEDED(hRes))
                        {
                            //
                            // Fill in the result of the query
                            //
                            if (!_wcsicmp(szPortProtocol, pszPortProtocolRawString))
                            {
                                PortData.dwProtocol = RAWTCP;
                            }
                            else if (!_wcsicmp(szPortProtocol, pszPortProtocolLprString))
                            {
                                PortData.dwProtocol = LPR;
                            }
                            else
                            {
                                hRes = WBEM_E_FAILED;
                            }
                        }

                        if (SUCCEEDED(hRes))
                        {
                            //
                            // If the protocol is RAW then we need to query for the port number,
                            // if it is LPR then we query for the QUEUE
                            //
                            if (PortData.dwProtocol == RAWTCP)
                            {
                                //
                                // Create the string used to query for the port number, ex: PORTNUMBER2
                                // referrs to the port number of the second port on the device
                                //
                                wsprintf(szKeyName, pszIniPortNumberKey, dwSelPortOnDevice);

                                hRes = GetIniDword(szIniFileName,
                                                   szDeviceSectionName,
                                                   szKeyName,
                                                   &PortData.dwPortNumber) ? WBEM_S_NO_ERROR : WBEM_E_FAILED;
                            }
                            else
                            {
                                //
                                // Create the string used to query for the queue name, ex: QUEUE2
                                // referrs to the queue of the second port on the device
                                //
                                wsprintf(szKeyName, pszIniQueueKey, dwSelPortOnDevice);

                                hRes = GetIniString(szIniFileName,
                                                    szDeviceSectionName,
                                                    szKeyName,
                                                    PortData.sztQueue,
                                                    MAX_QUEUENAME_LEN) ? WBEM_S_NO_ERROR : WBEM_E_FAILED;
                            }
                        }

                        DBGMSG(DBG_TRACE, (_T("GetDeviceSettings szIniFileName %s\n"),       szIniFileName));
                        DBGMSG(DBG_TRACE, (_T("GetDeviceSettings szDeviceDescription %s\n"), PortData.sztDeviceType));
                        DBGMSG(DBG_TRACE, (_T("GetDeviceSettings szDeviceSectionName %s\n"), szDeviceSectionName));
                        DBGMSG(DBG_TRACE, (_T("GetDeviceSettings szDeviceName        %s\n"), szDeviceName));
                        DBGMSG(DBG_TRACE, (_T("GetDeviceSettings dwNumPortsOnDevice  %u\n"), dwNumPortsOnDevice));
                        DBGMSG(DBG_TRACE, (_T("GetDeviceSettings dwPortNumber        %u\n"), PortData.dwPortNumber));
                        DBGMSG(DBG_TRACE, (_T("GetDeviceSettings Queue               %s\n"), PortData.sztQueue));
                        DBGMSG(DBG_TRACE, (_T("GetDeviceSettings szPortProtocol      %s\n"), szPortProtocol));
                    }
                    else
                    {
                        //
                        // Talking to device through sockets failed
                        //
                        DBGMSG(DBG_TRACE, (_T("GetDeviceSettings TalkError  %u \n"), TalkError));

                        hRes = WBEM_E_INVALID_PARAMETER;
                    }

                    FreeLibrary(hInstance);
                }
                else
                {
                    //
                    // LoadLibrary failed
                    //
                    dwError = GetLastError();

                    hRes    = WinErrorToWBEMhResult(dwError);
                }

                pWSock32api->WsWSACleanup();
            }

            CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidWsock32Api, pWSock32api);
        }
    }

    DBGMSG(DBG_TRACE, (_T("GetDeviceSettings returns %x\n"), hRes));

    return SUCCEEDED(hRes);
}


#endif // NTONLY == 5
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\processor.cpp ===
//=================================================================

//

// Processor.CPP --Processor property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>
#include "perfdata.h"

#include "cpuid.h"
#include "processor.h"
#include "computersystem.h"

#include "smbios.h"
#include "smbstruc.h"
#include "resource.h"

// Property set declaration
//=========================

CWin32Processor	win32Processor(PROPSET_NAME_PROCESSOR, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Processor::CWin32Processor
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *                LPCTSTR pszNamespace - Namespace for provider.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32Processor::CWin32Processor(LPCWSTR strName, LPCWSTR pszNamespace)
	:	Provider(strName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Processor::~CWin32Processor
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32Processor::~CWin32Processor()
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32Processor::GetObject
//
//	Inputs:		CInstance*		pInstance - Instance into which we
//											retrieve data.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32Processor::GetObject(
    CInstance* pInstance,
    long lFlags,
    CFrameworkQuery &query)
{
	BOOL		bRetCode = FALSE;
	DWORD		dwIndex;
    CHString    sDevice;
    WCHAR       szTemp[100];
    int         nProcessors = GetProcessorCount();

    // Ok, now let's check the deviceid
	pInstance->GetCHString(IDS_DeviceID, sDevice);
    dwIndex = _wtoi(sDevice.Mid(3));

	swprintf(szTemp, L"CPU%d", dwIndex);

    // Is this REALLY us?
    if (sDevice.CompareNoCase(szTemp) == 0 && dwIndex < nProcessors)
	{
#ifdef NTONLY
	    int nProcessors = GetProcessorCount();

		if (nProcessors > 0)
		{
			// Get the data
			PROCESSOR_POWER_INFORMATION *pProcInfo = new PROCESSOR_POWER_INFORMATION[nProcessors];
			
			try
			{
				memset(pProcInfo, 0, sizeof(PROCESSOR_POWER_INFORMATION) * nProcessors);
				NTSTATUS ntStatus = NtPowerInformation(ProcessorInformation,
														NULL,
														0,
														pProcInfo,
														sizeof(PROCESSOR_POWER_INFORMATION) * nProcessors
														);

				bRetCode = LoadProcessorValues(dwIndex, pInstance, query,
												pProcInfo[dwIndex].MaxMhz,
												pProcInfo[dwIndex].CurrentMhz);
			}
			catch(...)
			{
				if (pProcInfo)
				{
					delete [] pProcInfo;
				}
				
				throw;
			}

			if (pProcInfo)
			{
				delete [] pProcInfo;
			}
		}
#else
		bRetCode = LoadProcessorValues(dwIndex, pInstance, query, 0, 0);
#endif
	}

	return bRetCode ? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32Processor::EnumerateInstances
//
//	Inputs:		MethodContext*	pMethodContext - Context to enum
//								instance data in.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32Processor::EnumerateInstances(MethodContext* pMethodContext, long lFlags)
{
    CFrameworkQuery query;

    return ExecQuery(pMethodContext, query, lFlags);
}

HRESULT CWin32Processor::ExecQuery(
    MethodContext* pMethodContext,
    CFrameworkQuery &query,
    long lFlags)
{
	HRESULT         hr = WBEM_S_NO_ERROR;
	CInstancePtr    pInstance;
    int             nProcessors = GetProcessorCount();

#ifdef NTONLY
	if (nProcessors > 0)
	{
		PROCESSOR_POWER_INFORMATION *pProcInfo = new PROCESSOR_POWER_INFORMATION[nProcessors];
		
		try
		{
			memset(pProcInfo, 0, sizeof(PROCESSOR_POWER_INFORMATION) * nProcessors);
			NTSTATUS ntStatus = NtPowerInformation(ProcessorInformation,
													NULL,
													0,
													pProcInfo,
													sizeof(PROCESSOR_POWER_INFORMATION) * nProcessors
													);

			for (DWORD dwInstanceCount = 0;
				dwInstanceCount < nProcessors && WBEM_S_NO_ERROR == hr;
				dwInstanceCount++)
			{
				pInstance.Attach(CreateNewInstance(pMethodContext));

				// Release the instance if we are unable to obtain values.
				if (LoadProcessorValues(dwInstanceCount, pInstance, query,
										pProcInfo[dwInstanceCount].MaxMhz,
										pProcInfo[dwInstanceCount].CurrentMhz))
				{
					hr = pInstance->Commit();
				}
			}
		}
		catch(...)
		{
			if (pProcInfo)
			{
				delete [] pProcInfo;
			}
			
			throw;
		}

		if (pProcInfo)
		{
			delete [] pProcInfo;
		}
	}
#else
	for (DWORD dwInstanceCount = 0;
		dwInstanceCount < nProcessors && WBEM_S_NO_ERROR == hr;
		dwInstanceCount++)
	{
		pInstance.Attach(CreateNewInstance(pMethodContext));

		// Release the instance if we are unable to obtain values.
		if (LoadProcessorValues(dwInstanceCount, pInstance, query, 0,0))
		{
			hr = pInstance->Commit();
		}
	}
#endif

	return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Processor::LoadProcessorValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    : Assigns values to properties -- NT is the only instance
 *                where we have multiple processors and is symmetrical, so
 *                we can assign duplicate values to both processors
 *
 *****************************************************************************/

BOOL CWin32Processor::LoadProcessorValues(
    DWORD dwProcessorIndex,
    CInstance *pInstance,
    CFrameworkQuery &query,
	DWORD dwMaxSpeed,
	DWORD dwCurrentSpeed)
{
	WCHAR szTemp[100];

	swprintf(szTemp, L"CPU%d", dwProcessorIndex);
	pInstance->SetCharSplat(L"DeviceID", szTemp);

	// We're done if they only wanted the keys.
    if (query.KeysOnly())
        return TRUE;


    SYSTEM_INFO_EX info;

    if (!GetSystemInfoEx(dwProcessorIndex, &info, dwCurrentSpeed))
        return FALSE;

#ifdef NTONLY
	if ((dwMaxSpeed == 0) || (dwCurrentSpeed == 0))
	{
		wchar_t buff[100];
		_snwprintf(buff, 99, L"Zero processor speed returned from kernel: Max: %d, Current %d.", dwMaxSpeed, dwCurrentSpeed);
		LogErrorMessage(buff);
	}
#endif //NTONLY

    // Assign hard coded values
	pInstance->SetCHString(IDS_Role, L"CPU");
	pInstance->SetCharSplat(IDS_Status, L"OK");
	pInstance->SetCharSplat(L"CreationClassName", PROPSET_NAME_PROCESSOR);
	pInstance->Setbool(IDS_PowerManagementSupported, false);
	pInstance->SetCharSplat(L"SystemCreationClassName", PROPSET_NAME_COMPSYS);
	pInstance->SetCHString(L"SystemName", GetLocalComputerName());
	pInstance->SetWBEMINT16(IDS_Availability, 3);
	pInstance->SetWBEMINT16(IDS_StatusInfo, 3);

	// Some of these may get overridden below
    CHString    strTemp;

    Format(strTemp, IDR_CPUFormat, dwProcessorIndex);

	pInstance->SetCharSplat(IDS_Caption, strTemp);
    pInstance->SetCharSplat(IDS_Description, strTemp);

#ifdef _X86_
	pInstance->SetDWORD(L"AddressWidth", 32);
	pInstance->SetDWORD(L"DataWidth", 32);
#else
	pInstance->SetDWORD(L"AddressWidth", 64);
	pInstance->SetDWORD(L"DataWidth", 64);
#endif


#ifdef NTONLY
	if (query.IsPropertyRequired(L"LoadPercentage"))
    {
        // Get NT-only props
        DWORD   dwObjIndex,
                dwCtrIndex;
	    unsigned __int64
			    i64Value1,
			    i64Value2,
			    ilTime1,
			    ilTime2,
			    dwa,
			    dwb;
	    CPerformanceData
			    perfdata;
	    WCHAR   wszBuff[MAXITOA * 2];

	    dwObjIndex = perfdata.GetPerfIndex(L"Processor");
	    dwCtrIndex = perfdata.GetPerfIndex(L"% Processor Time");
	    if (dwObjIndex && dwCtrIndex)
	    {
		    _itow(dwProcessorIndex, wszBuff, 10);

		    perfdata.GetValue(dwObjIndex, dwCtrIndex, wszBuff, (PBYTE) &i64Value1,
			    &ilTime1);
		    Sleep(1000);
		    perfdata.GetValue(dwObjIndex, dwCtrIndex, wszBuff, (PBYTE) &i64Value2,
			    &ilTime2);

		    dwb = (ilTime2 - ilTime1);
		    dwa = (i64Value2 - i64Value1);

            // Just to be safe, we'll make sure dwb is non zero.
            if (dwb != 0)
            {
		        pInstance->SetDWORD(L"LoadPercentage", 100-((100 * dwa)/dwb));
            }
	    }
    }
#endif

    // Get the description needed for system info in Win2K.
    // This also works for Win98.
    CRegistry   reg;
    CHString    strDesc,
                strKey;

    strKey.Format(
        L"HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\%d",
        dwProcessorIndex);

    if (reg.OpenLocalMachineKeyAndReadValue(
        strKey,
        L"Identifier",
        strDesc) == ERROR_SUCCESS)
    {
        pInstance->SetCharSplat(IDS_Description, strDesc);
        pInstance->SetCharSplat(IDS_Caption, strDesc);
    }


	// Do all the stuff we got from GetSystemInfoEx
	pInstance->SetCharSplat(IDS_Name, info.szProcessorName);

	if (wcslen(info.szProcessorStepping))
	{
		pInstance->SetCharSplat(IDS_Stepping, info.szProcessorStepping);
	}

	pInstance->SetCharSplat(IDS_Version, info.szProcessorVersion);
	pInstance->SetCharSplat(IDS_Manufacturer, info.szProcessorVendor);
	pInstance->SetWBEMINT16(IDS_Architecture, info.wProcessorArchitecture);

	if (info.dwProcessorSpeed > 0)
	{
		pInstance->SetDWORD(IDS_CurrentClockSpeed, info.dwProcessorSpeed);
	}

    pInstance->SetWBEMINT16(IDS_Family, info.wWBEMProcessorFamily);
    pInstance->SetWBEMINT16(IDS_UpgradeMethod, info.wWBEMProcessorUpgradeMethod);

	if (info.dwProcessorL2CacheSize != (DWORD) -1)
		pInstance->SetDWORD(IDS_L2CacheSize, info.dwProcessorL2CacheSize);

	if (info.dwProcessorL2CacheSpeed != (DWORD) -1)
		pInstance->SetDWORD(IDS_L2CacheSpeed, info.dwProcessorL2CacheSpeed);

	pInstance->SetWBEMINT16(IDS_Level, info.wProcessorLevel);
	pInstance->SetWBEMINT16(IDS_Revision, info.wProcessorRevision);

    // CPUID Serial number
    if (info.dwSerialNumber[0] != 0)
    {
        WORD    *pwSerialNumber = (WORD *) info.dwSerialNumber;
        WCHAR   szSerialNumber[100];

        swprintf(
            szSerialNumber,
            L"%04X-%04X-%04X-%04X-%04X-%04X",
            (DWORD) pwSerialNumber[1],
            (DWORD) pwSerialNumber[0],
            (DWORD) pwSerialNumber[3],
            (DWORD) pwSerialNumber[2],
            (DWORD) pwSerialNumber[5],
            (DWORD) pwSerialNumber[4]);

        pInstance->SetCharSplat(L"UniqueId", szSerialNumber);
    }


    // Set to unknown in case we don't have SMBIOS or there's not type 4 structure.
    pInstance->SetDWORD(L"CpuStatus", 0);

    if (info.dwProcessorSpeed > dwMaxSpeed)
	{
        dwMaxSpeed = info.dwProcessorSpeed;
	}

	pInstance->SetDWORD(L"MaxClockSpeed", dwMaxSpeed);

	// SMBIOS qualified properties for Win32_Processor class
    CSMBios smbios;

    if (smbios.Init())
    {
        PPROCESSORINFO	ppi = (PPROCESSORINFO) smbios.GetNthStruct(4, dwProcessorIndex);
		WCHAR           tempstr[MIF_STRING_LENGTH+1];

		// Some bad SMP BIOSes only have a struct for the 1st processor.  In
        // this case reuse the first one for all the others.
        if (!ppi && dwProcessorIndex != 0)
            ppi = (PPROCESSORINFO) smbios.GetNthStruct(4, 0);

        if (ppi)
		{
		    pInstance->SetDWORD(L"CpuStatus", ppi->Status & 0x07);

            // Leave it as NULL if we get back a 0 (means unknown).
            if (ppi->External_Clock)
                pInstance->SetDWORD(L"ExtClock", (long) ppi->External_Clock);

            // Some BIOSes mess this up and report a max speed lower than the
            // current speed.  So, use the current speed in this case.
			if (info.dwProcessorSpeed == 0)
			{
				info.dwProcessorSpeed = ppi->Current_Speed;
				pInstance->SetDWORD(IDS_CurrentClockSpeed, info.dwProcessorSpeed);
			}

			if (dwMaxSpeed == 0)
			{
				if (info.dwProcessorSpeed > ppi->Max_Speed)
				{
					ppi->Max_Speed = info.dwProcessorSpeed;
				}

				pInstance->SetDWORD(L"MaxClockSpeed", ppi->Max_Speed);
			}

            USHORT rgTmp[4];
            memcpy(&rgTmp[0], &ppi->Processor_ID[6], sizeof(USHORT));
            memcpy(&rgTmp[1], &ppi->Processor_ID[4], sizeof(USHORT));
            memcpy(&rgTmp[2], &ppi->Processor_ID[2], sizeof(USHORT));
            memcpy(&rgTmp[3], &ppi->Processor_ID[0], sizeof(USHORT));
			swprintf(
                tempstr,
                L"%04X%04X%04X%04X",
				rgTmp[0],		// byte array
				rgTmp[1],		// byte array
				rgTmp[2],		// byte array
				rgTmp[3]		// byte array
				);
		    pInstance->SetCHString(L"ProcessorId", tempstr);
		    pInstance->SetDWORD(L"ProcessorType", ppi->Processor_Type);

			if ( ppi->Voltage & 0x80 )
			{
			    pInstance->SetDWORD(L"CurrentVoltage", ppi->Voltage & 0x7f);
			}
			else
			{
				switch(ppi->Voltage)
                {
                    case 1:
        			    pInstance->SetDWORD( L"CurrentVoltage", 50);
                        break;
                    case 2:
        			    pInstance->SetDWORD( L"CurrentVoltage", 33);
                        break;
                    case 4:
        			    pInstance->SetDWORD( L"CurrentVoltage", 29);
                        break;
                }

                // this is a bitmap of possible voltages.
			    pInstance->SetDWORD(L"VoltageCaps", ppi->Voltage & 0x07);
			}

            smbios.GetStringAtOffset((PSHF) ppi, tempstr, ppi->Socket_Designation);
	    	pInstance->SetCHString(L"SocketDesignation", tempstr);
		}
	}

	return TRUE;
}

int CWin32Processor::GetProcessorCount()
{
    SYSTEM_INFO info;

    GetSystemInfo(&info);

    return info.dwNumberOfProcessors;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\processdll.cpp ===
//=================================================================

//

// ProcessDLL.CPP -- CWin32ProcessDLL

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/16/98    sotteson         Created
//
//=================================================================

#include "precomp.h"
#include <tlhelp32.h>
#include "WBEMPSAPI.h"
#include "Kernel32Api.h"
#include "NtDllApi.h"
#include "processdll.h"
#include "CProcess.h"
#include "strsafe.h"
// Struct used by the EnumInstancesCallback function.

struct ENUM_INST_DATA
{
public:

	MethodContext *pMethodContext;
    CWin32ProcessDLL *pThis;
	HRESULT hres ;

} ;

struct ASSOC_DATA
{
    DWORD dwProcessID ;
    CHString strDLL ;
    HRESULT hres ;
    BOOL bFoundProcessID ;
    CInstance *pInstance ;
    CWin32ProcessDLL *pThis ;
} ;

CWin32ProcessDLL processdll;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProcessDll :: CWin32ProcessDll
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CWin32ProcessDLL :: CWin32ProcessDLL () : Provider ( L"CIM_ProcessExecutable", IDS_CimWin32Namespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProcessDll :: ~CWin32ProcessDll
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CWin32ProcessDLL :: ~CWin32ProcessDLL ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProcessDll :: EnumerateInstances
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32ProcessDLL :: EnumerateInstances (

	MethodContext *pMethodContext,
    long lFlags
)
{
    ENUM_INST_DATA data;
	HRESULT t_hr ;
    data.pMethodContext = pMethodContext;
    data.pThis = this;

    // Enum through process modules.  EnumInstancesCallback will Commit
    // each instance.

    t_hr = EnumModulesWithCallback ( EnumInstancesCallback , &data , pMethodContext ) ;
	if ( FAILED ( data.hres ) )
	{
		return data.hres ;
	}
	else
	{
		return t_hr ;
	}
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProcessDll :: GetObject
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32ProcessDLL :: GetObject (

	CInstance *pInstance,
	long lFlags
)
{
    CInstancePtr pProcess;
    CInstancePtr pDLL;
    CHString strProcessPath ;
	CHString strDLLPath;

    pInstance->GetCHString(IDS_Dependent, strProcessPath);
    pInstance->GetCHString(IDS_Antecedent, strDLLPath);

    // If we can get both objects, test for an association

    HRESULT     hres;

    if (SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(strDLLPath, &pDLL, pInstance->GetMethodContext())) &&
        SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(strProcessPath,
            &pProcess, pInstance->GetMethodContext())))
    {
        hres = AreAssociated(pInstance, pProcess, pDLL);
    }
    else
    {
        hres = WBEM_E_NOT_FOUND;
    }

    return hres;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProcessDll :: AreWeAssociated
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32ProcessDLL :: AreAssociated (

	CInstance *pProcessDLL,
    CInstance *pProcess,
	CInstance *pDLL
)
{
    CHString strHandle;
    pProcess->GetCHString(L"Handle", strHandle);

    ASSOC_DATA  data;

    data.dwProcessID = wcstoul(strHandle, NULL, 10);
    pDLL->GetCHString(L"Name", data.strDLL);
    data.hres = WBEM_E_NOT_FOUND;
    data.bFoundProcessID = FALSE;
    data.pInstance = pProcessDLL;
    data.pThis = this;

    // Enum processes and their DLLs and see if we can find a match.

    HRESULT hres;
    if ( FAILED ( hres = EnumModulesWithCallback ( IsAssocCallback, &data, pDLL->GetMethodContext () ) ) )
	{
        return hres;
	}
    else
	{
        return data.hres;
	}
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProcessDll :: EnumModulesWithCallback
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY

HRESULT CWin32ProcessDLL :: EnumModulesWithCallback (

	MODULEENUMPROC fpCallback,
    LPVOID pUserDefined,
	MethodContext *a_pMethodContext
)
{
    // This will help us find out if the current user didn't have
    // enough rights.
    HRESULT t_hr = WBEM_S_NO_ERROR ;
    BOOL bDone = FALSE;

	CNtDllApi *pNtdll = ( CNtDllApi * ) CResourceManager::sm_TheResourceManager.GetResource ( g_guidNtDllApi, NULL ) ;
	if ( pNtdll )
	{
		SYSTEM_PROCESS_INFORMATION *t_ProcessBlock = NULL ;

		try
		{
			t_ProcessBlock = Process :: RefreshProcessCacheNT (

														*pNtdll ,
														a_pMethodContext ,
														&t_hr /* = NULL */
													) ;

			SYSTEM_PROCESS_INFORMATION *t_CurrentInformation = t_ProcessBlock ;
			while ( t_CurrentInformation )
			{
				SmartCloseHandle hProcess = OpenProcess (

					PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
					FALSE,
					HandleToUlong ( t_CurrentInformation->UniqueProcessId )
				) ;

				// Make sure we can open the process.
				if ( hProcess )
				{
					MODULEENTRY32 module;

					// Fill in the members that won't change.

					module.dwSize = sizeof(module);
					module.GlblcntUsage = (DWORD) -1;

					LIST_ENTRY *t_LdrHead = NULL;

					BOOL t_Status = Process :: GetProcessModuleBlock (

						*pNtdll ,
						hProcess ,
						t_LdrHead
					) ;

					LIST_ENTRY *t_LdrNext = t_LdrHead ;

					while ( t_Status )
					{
						CHString t_ModuleName ;
						t_Status = Process :: NextProcessModule (

							*pNtdll ,
							hProcess ,
							t_LdrHead ,
							t_LdrNext ,
							t_ModuleName,
                            (DWORD_PTR *) &module.hModule,
                            &module.ProccntUsage
						) ;

						if ( t_Status )
						{
							StringCchCopy(module.szExePath, MAX_PATH, t_ModuleName);

							// Set the process ID
							module.th32ProcessID = HandleToUlong ( t_CurrentInformation->UniqueProcessId ) ;

							// Call the callback
							// If the callback function returns 0, break out.

							if (!fpCallback(&module, pUserDefined))
							{
								bDone = TRUE;
								break;
							}
						}
            		}
				}

				t_CurrentInformation = Process :: NextProcessBlock ( *pNtdll , t_CurrentInformation ) ;
			}
		}
		catch ( ... )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidNtDllApi, pNtdll ) ;

			if ( t_ProcessBlock )
			{
				delete [] ( PBYTE )t_ProcessBlock ;
				t_ProcessBlock = NULL ;
			}
			throw ;
		}

		CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidNtDllApi, pNtdll ) ;

		if ( t_ProcessBlock )
		{
			delete [] ( PBYTE )t_ProcessBlock ;
			t_ProcessBlock = NULL ;
		}
	}
	else
	{
		t_hr = WBEM_E_FAILED ;
	}

    return t_hr ;
}

#else

HRESULT CWin32ProcessDLL :: EnumModulesWithCallback (

	MODULEENUMPROC fpCallback,
    LPVOID pUserDefined,
	MethodContext *a_pMethodContext
)
{
    // This will help us find out if the current user didn't have
    // enough rights.
    int nOpened = 0;

    //CToolHelp     toolhelp;
    SmartCloseHandle hProcesses;
    PROCESSENTRY32  proc;

    BOOL            bDone;

    CKernel32Api *pKernel32 = (CKernel32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidKernel32Api, NULL);
    if(pKernel32 == NULL)
    {
        return WBEM_E_FAILED;
    }

    try // pKernel32
    {
        if ( pKernel32->CreateToolhelp32Snapshot ( TH32CS_SNAPPROCESS , 0 , & hProcesses ) )
        {
            proc.dwSize = sizeof(proc);
            if(pKernel32->Process32First(hProcesses, &proc, &bDone))
            {
                bDone = !bDone;
                while (!bDone)
                {
                    SmartCloseHandle hModules ;
                    pKernel32->CreateToolhelp32Snapshot (

						TH32CS_SNAPMODULE,
                        proc.th32ProcessID,
                        &hModules
					);

                    BOOL bModDone;

                    MODULEENTRY32 module;
                    module.dwSize = sizeof(module);

                    if(hModules != NULL)
                    {
                        if(pKernel32->Module32First(hModules, &module, &bModDone))
                        {
                            bModDone = !bModDone;
                            while (!bModDone)
                            {
                                nOpened++;

                                // If the callback function returns 0, break out.
                                if (!fpCallback(&module, pUserDefined))
                                {
                                    bDone = TRUE;
                                    break;
                                }

                                pKernel32->Module32Next(hModules, &module, &bModDone);
                                bModDone = !bModDone;
                            }

                            // May have been changed after the call to fpCallback.
                            if (bDone)
                                break;

                        }
                    }

                    pKernel32->Process32Next(hProcesses, &proc, &bDone);
					bDone = !bDone;
                }
            }
        }
    }
    catch ( ... )
    {
        if(pKernel32 != NULL)
        {
            CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidKernel32Api, pKernel32);
            pKernel32 = NULL;
        }
        throw ;
    }

    if(pKernel32 != NULL)
    {
        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidKernel32Api, pKernel32);
        pKernel32 = NULL;
    }

    if (!nOpened)
	{
        // Assume access was denied if we couldn't open a single process.
        return WBEM_E_ACCESS_DENIED;
	}

    return WBEM_S_NO_ERROR;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProcessDll :: SetInstanceData
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void CWin32ProcessDLL :: SetInstanceData (

	CInstance *pInstance,
    MODULEENTRY32 *pModule
)
{
    if (pModule->GlblcntUsage != (DWORD) -1 && pModule->GlblcntUsage != (WORD) -1)
        pInstance->SetDWORD(L"GlobalProcessCount", pModule->GlblcntUsage);

    if (pModule->ProccntUsage != (DWORD) -1 && pModule->ProccntUsage != (WORD) -1)
        pInstance->SetDWORD(L"ProcessCount", pModule->ProccntUsage);

    if (pModule->hModule != (HINSTANCE) -1)
    {
        // The compiler does funny things without the (DWORD_PTR) cast.
        pInstance->SetWBEMINT64(L"BaseAddress",
            (unsigned __int64) (DWORD_PTR) pModule->hModule);

        // Deprecated, but we'll return it anyway.
        pInstance->SetDWORD(L"ModuleInstance", (DWORD)((DWORD_PTR)pModule->hModule));
    }
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProcessDll :: EnumInstancesCallback
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CALLBACK CWin32ProcessDLL :: EnumInstancesCallback (

	MODULEENTRY32 *pModule,
    LPVOID pUserDefined
)
{
    ENUM_INST_DATA *pData = (ENUM_INST_DATA *) pUserDefined ;

	CHString sTemp ;

    CInstancePtr pInstance(pData->pThis->CreateNewInstance(pData->pMethodContext), false);

    // Get the relative path to the process
    // We used to build this path like for the DLL below, but once
    // Win32_Process moved to cimwin33.dll the CWbemProviderGlue::GetEmptyInstance
    // call quit working.

    sTemp.Format (

        L"\\\\%s\\%s:Win32_Process.Handle=\"%lu\"",
        pData->pThis->GetLocalComputerName(),
        IDS_CimWin32Namespace,
        pModule->th32ProcessID
	);

    pInstance->SetCHString(IDS_Dependent, sTemp);

    // Get the relative path to the DLL

    sTemp = pModule->szExePath;
	CHString strDLLPathAdj ;
    EscapeBackslashes(sTemp, strDLLPathAdj);

    sTemp.Format(

        L"\\\\%s\\%s:CIM_DataFile.Name=\"%s\"",
        pData->pThis->GetLocalComputerName(),
        IDS_CimWin32Namespace,
        (LPCWSTR)strDLLPathAdj
	);

    pInstance->SetCHString(IDS_Antecedent, sTemp);

    pData->pThis->SetInstanceData(pInstance, pModule);

    if ( FAILED ( pData->hres = pInstance->Commit() ) )
	{
		return FALSE ;
	}
    return TRUE;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProcessDll :: IsAssocCallback
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

// Callback used by GetObject to see if a given process\DLL pair are
// associated.
BOOL CALLBACK CWin32ProcessDLL :: IsAssocCallback (

	MODULEENTRY32 *pModule,
    LPVOID pUserDefined
)
{
    ASSOC_DATA *pData = (ASSOC_DATA *) pUserDefined;

    if (pModule->th32ProcessID == pData->dwProcessID)
    {
        if (!pData->strDLL.CompareNoCase(TOBSTRT(pModule->szExePath)))
        {
            pData->hres = WBEM_S_NO_ERROR;

            pData->pThis->SetInstanceData(pData->pInstance, pModule);

            // Because we want to stop enumeration once we've found the requested
            // object.
            return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\prnutil.h ===
/*++



// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 
All rights reserved.

Module Name:

    PrnUtil.h

Abstract:

    Declaration of some utility functions

Author:

    Felix Maxa (amaxa)  3-March-2000

--*/

extern CONST BOOL    kFailOnEmptyString;    
extern CONST BOOL    kAcceptEmptyString;
extern CONST LPCWSTR pszPutInstance;
extern CONST LPCWSTR pszDeleteInstance;
extern CONST LPCWSTR pszGetObject;

extern CONST LPCWSTR kDefaultBoolean;  
extern CONST LPCWSTR kDateTimeFormat;  
extern CONST LPCWSTR kDateTimeTemplate;


#include <..\..\framework\provexpt\include\provexpt.h>



class SmartClosePrinter
{
private:

	HANDLE m_h;

public:

	SmartClosePrinter () : m_h ( INVALID_HANDLE_VALUE ) {}
	SmartClosePrinter ( HANDLE h ) : m_h ( h ) {}

	~SmartClosePrinter()
	{
		// Use of delay loaded functions requires exception handler.
        SetStructuredExceptionHandler seh;
        try
        {
            if (m_h!=INVALID_HANDLE_VALUE) 
		    {
			    ::ClosePrinter(m_h);
		    }
        }
        catch(Structured_Exception se)
        {
            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        }
	}

	HANDLE operator =(HANDLE h) 
	{
		// Use of delay loaded functions requires exception handler.
        SetStructuredExceptionHandler seh;
        try
        {
            if (m_h!=INVALID_HANDLE_VALUE) 
		    {
			    ::ClosePrinter(m_h); 
		    }

		    m_h=h;
        }
        catch(Structured_Exception se)
        {
            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        } 

		return h;
	}

	operator HANDLE() const {return m_h;}
	HANDLE* operator &()
	{
		// Use of delay loaded functions requires exception handler.
        SetStructuredExceptionHandler seh;
        try
        {
            if (m_h!=INVALID_HANDLE_VALUE) 
		    {
		        ::ClosePrinter(m_h); 
		    }
        }
        catch(Structured_Exception se)
        {
            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        }

		m_h = INVALID_HANDLE_VALUE; 

		return &m_h;
	}
};

HRESULT
InstanceGetString(
    IN     CONST CInstance &Instance,
    IN           LPCWSTR    pszProperty,
    IN OUT       CHString  *pcsString,
    IN           BOOL       bFailOnEmptyString,
    IN           LPWSTR     pszDefaultValue = L""
    );

HRESULT
InstanceGetDword(
    IN     CONST CInstance &Instance,
    IN           LPCWSTR    pszProperty,
    IN OUT       DWORD     *pdwOut,
    IN           DWORD      dwDefaultValue = (DWORD)-1
    );

HRESULT
InstanceGetBool(
    IN     CONST CInstance &Instance,
    IN           LPCWSTR    pszProperty,
    IN OUT       BOOL      *pbOut,
    IN           BOOL       bDefaultValue = FALSE
    );

UINT
MultiSzCount(
    IN LPCWSTR psz
    );

HRESULT
CreateSafeArrayFromMultiSz(
    IN  LPCTSTR     pszMultiSz,
    OUT SAFEARRAY **pArray
    );

DWORD
LocalTimeToPrinterTime(
    IN CONST SYSTEMTIME &st
    );

VOID
PrinterTimeToLocalTime(
    IN     DWORD        Minutes,
    IN OUT SYSTEMTIME *pSysTime
    );

DWORD
SplPrinterGetAttributes(
    IN     LPCWSTR   pszPrinter,
    IN OUT DWORD   *pdwAttributes
    );   
 
DWORD
SplIsPrinterInstalled(
    IN  LPCWSTR  pszPrinter,
    OUT BOOL    *pbInstalled
    );

DWORD
GetThisPrinter(
    IN  HANDLE   hPrinter,
    IN  DWORD    dwLevel,
    OUT BYTE   **ppData
    );

#if NTONLY == 5
#ifndef _PRNUTIL_HXX_
#define _PRNUTIL_HXX_

//
// The following lines are for the TABLE
// which makes building command strings for printui easier
//
class TUISymbols
{

public:
    static LPCTSTR kstrQuiet;
    static LPCTSTR kstrAddDriver;
    static LPCTSTR kstrAddPrinter;
    static LPCTSTR kstrDelDriver;
    static LPCTSTR kstrDriverPath;
    static LPCTSTR kstrDriverModelName;
    static LPCTSTR kstrDriverVersion;
    static LPCTSTR kstrDriverArchitecture;
    static LPCTSTR kstrInfFile;
    static LPCTSTR kstrMachineName;
    static LPCTSTR kstrPrinterName;
    static LPCTSTR kstrBasePrinterName;
    static LPCTSTR kstrPrinterPortName;
    static LPCTSTR kstrDelLocalPrinter;
    static LPCTSTR kstrDelPort;
    static LPCTSTR kstrAddPort;
    static LPCTSTR kstrConfigPort;
    static LPCTSTR kstrPortName;
    static LPCTSTR kstrPrintTestPage;    
};

DWORD WINAPI
PrintUIEntryW(
    IN LPCTSTR   pszCmdLine    
    );    

DWORD
CallXcvDataW(
    HANDLE  hXcv,
    PCWSTR  pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData
    );

DWORD
IsLocalCall(
    IN OUT BOOL *pbOutValue
    );   

VOID
SetErrorObject(
    IN CONST CInstance &Instance,
    IN       DWORD      dwError,
    IN       LPCWSTR    pszOperation = L""
    );

VOID
SetReturnValue( 
    IN CInstance *pOutParams,
    IN DWORD      dwError 
    );

BOOL
GetDeviceSectionFromDeviceDescription(
    IN     LPCWSTR  pszIniFileName,
    IN     LPCWSTR  pszDeviceDescription,
    IN OUT LPWSTR   pszSectionName,
    IN     DWORD    dwSectionNameLen
    );

BOOL
GetIniString(
    IN     LPCWSTR  pszIniFileName,
    IN     LPCWSTR  pszSectionName,
    IN     LPCWSTR  pszKeyName,
    IN OUT LPWSTR   pszString,
    IN     DWORD    dwStringLen
    );

BOOL
GetIniDword(
    IN     LPCWSTR  pszIniFileName,
    IN     LPCWSTR  pszSectionName,
    IN     LPCWSTR  pszKeyName,
       OUT LPDWORD  pdwValue
    );

//
// Debug utilities
//
#ifdef DBG
VOID 
DbgMsg(
    IN LPCTSTR MsgFormat, ...
    );

#define DBG_LEVEL               4
#define DBG_NONE                0
#define DBG_TRACE               1
#define DBG_WARNING             2
#define DBG_ERROR               4

#define DBGMSG(Level, MsgAndArgs) {if (Level >= DBG_LEVEL) {DbgMsg MsgAndArgs;}}

#else
#define DBGMSG(x,y)
#endif

#endif
#endif // NTONLY == 5
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\processor.h ===
//=================================================================

//

// Processor.h -- Processor property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               07/09/98    sotteson       Overhauled to work with
//                                          AMD/Cyrix/etc.															
//
//=================================================================

// Property set identification
//============================

// Property set identification
//============================

#define	PROPSET_NAME_PROCESSOR	L"Win32_Processor"

class CWin32Processor : public Provider
{
public:

	// Constructor/destructor
	//=======================
	CWin32Processor(LPCWSTR strName, LPCWSTR pszNamespace);
	~CWin32Processor();

	// Functions provide properties with current values
	//=================================================
	virtual HRESULT GetObject(CInstance *pInstance, long lFlags, 
        CFrameworkQuery &query);
	virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, 
        long lFlags = 0L);
    virtual HRESULT ExecQuery(MethodContext *pMethodContext, 
        CFrameworkQuery &query, long lFags);

protected:

	// Utility function(s)
	//====================
    BOOL LoadProcessorValues(DWORD dwProcessorIndex,
							CInstance *pInstance,
							CFrameworkQuery &query,
							DWORD dwMaxSpeed,
							DWORD dwCurrentSpeed);
    int GetProcessorCount();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\programgroup.cpp ===
//=================================================================

//

// ProgramGroup.CPP -- Program group property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//       10/24/97    jennymc     Moved to new framework
//
//=================================================================


//*****************************************************************
//*****************************************************************
//
//             W   A   R   N   I   N   G  !!!!!!!!!!
//             W   A   R   N   I   N   G  !!!!!!!!!!
//
//
//  This class has been deprecated for Nova M2 and later builds of
//  WBEM.  Do not make alterations to this class.  Make changes to
//  the new class Win32_LogicalProgramFile (LogicalProgramFile.cpp)
//  instead.  The new class (correctly) is derived in CIMOM from
//  LogicalElement, not LogicalSetting.
//
//*****************************************************************
//*****************************************************************



#include "precomp.h"
#include <cregcls.h>

#include "UserHive.h"
#include <io.h>

#include "ProgramGroup.h"
#include "wbemnetapi32.h"
#include "user.h"
#include "strsafe.h"

// Property set declaration
//=========================
CWin32ProgramGroup MyCWin32ProgramGroupSet(PROPSET_NAME_PRGGROUP, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProgramGroup::CWin32ProgramGroup
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32ProgramGroup::CWin32ProgramGroup(LPCWSTR name, LPCWSTR pszNameSpace)
: Provider(name, pszNameSpace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProgramGroup::~CWin32ProgramGroup
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32ProgramGroup::~CWin32ProgramGroup()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32ProgramGroup::GetObject(CInstance* pInstance, long lFlags /*= 0L*/)
{
//    HRESULT hr = WBEM_E_FAILED;
//  int iIndex ;
    CHString Name;
	HRESULT		hr;
	pInstance->GetCHString(IDS_Name, Name);
   CHString chsUserName, chsGroupName;
   TRefPointerCollection<CInstance> Groups;

   if SUCCEEDED(hr = CWbemProviderGlue::GetAllInstances(L"Win32_ProgramGroup", &Groups, IDS_CimWin32Namespace, pInstance->GetMethodContext()))
   {
		REFPTRCOLLECTION_POSITION	pos;

		CInstancePtr pProgramGroupInstance;

		if ( Groups.BeginEnum( pos ) )
		{
            hr = WBEM_E_NOT_FOUND;
			for (	pProgramGroupInstance.Attach ( Groups.GetNext( pos ) );
					pProgramGroupInstance != NULL ;
					pProgramGroupInstance.Attach ( Groups.GetNext( pos ) )
				)
			{
				CHString chsCompName;
				pProgramGroupInstance->GetCHString(IDS_Name, chsCompName);

				// We're done with the pointer
                pProgramGroupInstance.Release();

				if (chsCompName.CompareNoCase(Name) == 0)
				{
                    // Parse out the user name
					chsUserName = chsCompName.SpanExcluding(L":");
			    	pInstance->SetCHString(IDS_UserName, chsUserName);

                    // Parse out the group
					int nUserLength = (chsUserName.GetLength() + 1);
					int nGroupLength = chsCompName.GetLength() - nUserLength;
					chsGroupName = chsCompName.Right(nGroupLength);
					pInstance->SetCHString(IDS_GroupName, chsGroupName);

                    CHString chstrTmp2;
                    chstrTmp2.Format(L"Program group \"%s\"", (LPCWSTR) Name);
                    pInstance->SetCHString(L"Description" , chstrTmp2) ;
                    pInstance->SetCHString(L"Caption" , chstrTmp2) ;

                    hr = WBEM_S_NO_ERROR;
                    break;
				}

			}	// WHILE GetNext

			Groups.EndEnum();

		}	// IF BeginEnum

	}
	return hr;

}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32ProgramGroup::EnumerateInstances(MethodContext*  pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT hr = WBEM_E_FAILED;
    TCHAR szWindowsDir[_MAX_PATH];
    CRegistry RegInfo ;
    CHString sTemp;

    if(GetWindowsDirectory(szWindowsDir, sizeof(szWindowsDir) / sizeof(TCHAR) ))
    {

#ifdef NTONLY
			LONG lRet;
            if(GetPlatformMajorVersion() < 4)
            {
                hr=EnumerateGroupsTheHardWay(pMethodContext) ;
            }
            else
            {
                // Default user doesn't show up under profiles
                if((lRet = RegInfo.Open(HKEY_USERS, _T(".DEFAULT\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"), KEY_READ)) == ERROR_SUCCESS)
                {
                    if(RegInfo.GetCurrentKeyValue(_T("Programs"), sTemp) == ERROR_SUCCESS)
                    {
                        hr=CreateSubDirInstances(_T("Default User"), sTemp, _T("."), pMethodContext);
                    }
                }
				else
				{
					if (lRet == ERROR_ACCESS_DENIED)
						hr = WBEM_E_ACCESS_DENIED;
				}

                // Neither does All Users
                if((lRet = RegInfo.Open(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"), KEY_READ)) == ERROR_SUCCESS)
                {
                    if(RegInfo.GetCurrentKeyValue(_T("Common Programs"), sTemp) == ERROR_SUCCESS)
                    {
                        hr=CreateSubDirInstances(_T("All Users"), sTemp, _T("."), pMethodContext);
                    }
                }
				else
				{
					if (lRet == ERROR_ACCESS_DENIED)
						hr = WBEM_E_ACCESS_DENIED;
				}

                // Now walk the registry looking for the rest
                CRegistry regProfileList;
                if((lRet = regProfileList.OpenAndEnumerateSubKeys( HKEY_LOCAL_MACHINE, IDS_RegNTProfileList, KEY_READ )) == ERROR_SUCCESS )
                {
                    CUserHive UserHive ;
                    CHString strProfile, strUserName, sKeyName2;

		            for (int i=0; regProfileList.GetCurrentSubKeyName( strProfile ) == ERROR_SUCCESS ; i++)
		            {
                        // Try to load the hive.  If the user has been deleted, but the directory
                        // is still there, this will return ERROR_NO_SUCH_USER
						bool t_bUserHiveLoaded = false ;
		                if ( UserHive.LoadProfile( strProfile, strUserName ) == ERROR_SUCCESS  && 
                            strUserName.GetLength() > 0 )
		                {
                            t_bUserHiveLoaded = true ;
							try
							{
								sKeyName2 = strProfile + _T("\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");

								if(RegInfo.Open(HKEY_USERS, sKeyName2, KEY_READ) == ERROR_SUCCESS) {
									if(RegInfo.GetCurrentKeyValue(_T("Programs"), sTemp) == ERROR_SUCCESS) {
										hr=CreateSubDirInstances(strUserName, sTemp, _T("."), pMethodContext) ;
									}
									RegInfo.Close();
								}
							}
							catch ( ... )
							{
								if ( t_bUserHiveLoaded )
								{
									UserHive.Unload( strProfile ) ;
								}
								throw ;
							}
							t_bUserHiveLoaded = false ;
							UserHive.Unload( strProfile ) ;
                        }
			            regProfileList.NextSubKey();
		            }

		            regProfileList.Close();
                }
				else
				{
					if (lRet == ERROR_ACCESS_DENIED)
						hr = WBEM_E_ACCESS_DENIED;
				}
            }
#endif
    }

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProgramGroup::CreateSubDirInstances
 *
 *  DESCRIPTION : Creates instance of property set for each directory
 *                beneath the one passed in
 *
 *  INPUTS      : pszBaseDirectory    : Windows directory + "Profiles\<user>\Start Menu\Programs"
 *                pszParentDirectory  : Parent directory to enumerate
 *
 *  OUTPUTS     : pdwInstanceCount : incremented for each instance created
 *
 *  RETURNS     : Zip
 *
 *  COMMENTS    : Recursive descent thru profile directories
 *
 *****************************************************************************/

HRESULT CWin32ProgramGroup::CreateSubDirInstances(LPCTSTR pszUserName,
                               LPCTSTR pszBaseDirectory,
                               LPCTSTR pszParentDirectory,
                               MethodContext * pMethodContext )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    TCHAR szDirSpec[_MAX_PATH], szTemp[_MAX_PATH], *pszGroupName ;
    Smart_findclose lFindHandle ;
    intptr_t iptrRetCode = -1L;

#if (defined(UNICODE) || defined (_UNICODE))
#if defined(_X86_)
    _wfinddata_t FindData ;
#else
    _wfinddatai64_t FindData ;
#endif
#else
    _finddata_t FindData ;
#endif

    // Put together search spec for this level
    //========================================

    StringCchPrintf(szDirSpec, _MAX_PATH,_T("%s\\%s\\*.*"), pszBaseDirectory, pszParentDirectory) ;

	// Enumerate subdirectories ( == program groups)
	//==============================================
#if defined(_X86_)
	lFindHandle = _tfindfirst(szDirSpec, &FindData) ;
#else
    lFindHandle = _tfindfirsti64(szDirSpec, &FindData) ;
#endif
    
    iptrRetCode = lFindHandle;

	while(iptrRetCode != -1 && SUCCEEDED(hr)) {

		if(FindData.attrib & _A_SUBDIR && _tcscmp(FindData.name, _T(".")) && _tcscmp(FindData.name, _T(".."))) {

			CInstancePtr pInstance ;
			pInstance.Attach ( CreateNewInstance ( pMethodContext ) ) ;
			if ( pInstance != NULL )
			{
				StringCchPrintf(szTemp, _MAX_PATH, _T("%s\\%s"), pszParentDirectory, FindData.name) ;
				pszGroupName = _tcschr(szTemp, '\\') + 1 ;

				pInstance->SetCHString(L"UserName", pszUserName );
				pInstance->SetCHString(L"GroupName", pszGroupName );

                CHString chstrTmp;
                chstrTmp.Format(L"%s:%s",(LPCWSTR)TOBSTRT(pszUserName),(LPCWSTR)TOBSTRT(pszGroupName));

				pInstance->SetCHString(L"Name", chstrTmp );

                CHString chstrTmp2;
                chstrTmp2.Format(L"Program group \"%s\"", (LPCWSTR) chstrTmp);
                pInstance->SetCHString(L"Description" , chstrTmp2) ;
                pInstance->SetCHString(L"Caption" , chstrTmp2) ;

				hr = pInstance->Commit () ;
			}
			// Enumerate directories sub to this one
			//======================================
			StringCchPrintf(szDirSpec, _MAX_PATH,_T("%s\\%s"), pszParentDirectory, FindData.name) ;
			CreateSubDirInstances(pszUserName, pszBaseDirectory, szDirSpec, pMethodContext) ;
		}

#if defined(_X86_)
	    iptrRetCode = _tfindnext(lFindHandle, &FindData) ;
#else
        iptrRetCode = _tfindnexti64(lFindHandle, &FindData) ;
#endif

	}

	return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProgramGroup::EnumerateGroupsTheHardWay
 *
 *  DESCRIPTION : Creates instances for program groups by drilling into
 *                user profiles
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : dwInstanceCount receives the total number of instances created
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32ProgramGroup::EnumerateGroupsTheHardWay(MethodContext * pMethodContext)
{
    HRESULT hr = WBEM_E_FAILED;
    CUserHive UserHive ;
    CRegistry Reg ;
    WCHAR szUserName[_MAX_PATH], szKeyName[_MAX_PATH] ;

    // Get default user first
    //=======================

    InstanceHardWayGroups(L"Default User", L".DEFAULT", pMethodContext) ;

    // Get the users first
    //====================
        // Create instances for each user
    //===============================

	TRefPointerCollection<CInstance> users;

	if (SUCCEEDED(hr = CWbemProviderGlue::GetAllInstances(PROPSET_NAME_USER, &users, IDS_CimWin32Namespace, pMethodContext)))
	{
		REFPTRCOLLECTION_POSITION pos;
		CInstancePtr pUser;
        CHString userName;

		if (users.BeginEnum(pos))
		{
            hr = WBEM_S_NO_ERROR;
			// GetNext() will AddRef() the pointer, so make sure we Release()
			// it when we are done with it.
			for (	pUser.Attach ( users.GetNext( pos ) );
					pUser != NULL ;
					pUser.Attach ( users.GetNext( pos ) )
				)
			{
    			// Look up the user's account info
				//================================
				pUser->GetCHString(IDS_Name, userName) ;
				StringCchCopy(szUserName, _MAX_PATH, userName) ;
				bool t_bUserHiveLoaded = false ;
                if(UserHive.Load(szUserName, szKeyName, _MAX_PATH) == ERROR_SUCCESS)
                {
                    t_bUserHiveLoaded = true ;
					try
					{
						InstanceHardWayGroups(szUserName, szKeyName, pMethodContext) ;
					}
					catch ( ... )
					{
						if ( t_bUserHiveLoaded )
						{
							UserHive.Unload(szKeyName) ;
						}
						throw ;
					}

					t_bUserHiveLoaded = false ;
					UserHive.Unload(szKeyName) ;
                }
			}
			users.EndEnum();
		}
	}
    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProgramGroup::InstanceHardWayGroups
 *
 *  DESCRIPTION : Creates instances of program groups for specified user
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : dwInstanceCount receives the total number of instances created
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

WCHAR szBaseRegKey[] = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Program Manager" ;

HRESULT CWin32ProgramGroup::InstanceHardWayGroups(LPCWSTR  pszUserName,
                                   LPCWSTR  pszRegistryKeyName,
                                   MethodContext * pMethodContext)
{
    HRESULT hr= WBEM_S_NO_ERROR;
    CRegistry Reg ;
    WCHAR szTemp[_MAX_PATH] ;
    CHString sSubKey ;
    DWORD i, j, dwRetCode ;
    WCHAR *pValueName = NULL , *c = NULL ;
    BYTE *pValueData = NULL ;
	LONG lRet;

    // UNICODE groups
    //===============

    StringCchPrintf(szTemp, _MAX_PATH, L"%s\\%s\\UNICODE Groups", pszRegistryKeyName, szBaseRegKey) ;
    if((lRet = Reg.Open(HKEY_USERS, szTemp, KEY_READ)) == ERROR_SUCCESS)
	{

        try
		{
			for(i = 0 ; i < Reg.GetValueCount() && SUCCEEDED(hr); i++)
			{

				dwRetCode = Reg.EnumerateAndGetValues(i, pValueName, pValueData) ;
				if(dwRetCode == ERROR_SUCCESS)
				{
					CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), false ) ;
					if (pInstance != NULL )
					{
						pInstance->SetCHString(L"UserName", pszUserName );
						pInstance->SetCHString(L"GroupName", (LPCSTR) pValueData );
						pInstance->SetCHString(L"Name", CHString(pszUserName) + CHString(L":") + CHString((WCHAR*)pValueData) );

						hr = pInstance->Commit () ;
					}
				}
			}

			Reg.Close() ;
		}
		catch ( ... )
		{
			if ( pValueName )
			{
				delete [] pValueName ;
				pValueName = NULL ;
			}

			if ( pValueData )
			{
				delete [] pValueData ;
				pValueData = NULL ;
			}
			throw ;
		}

		if ( pValueName )
		{
			delete [] pValueName ;
			pValueName = NULL ;
		}

		if ( pValueData )
		{
			delete [] pValueData ;
			pValueData = NULL ;
		}
    }
	//else
	//{
	//	if (lRet == ERROR_ACCESS_DENIED)
	//		hr = WBEM_E_ACCESS_DENIED;
	//}

    // Get the Common Groups
    //======================
	pValueName = NULL ;
	pValueData = NULL ;

	StringCchPrintf(szTemp, _MAX_PATH,L"%s\\%s\\Common Groups", pszRegistryKeyName, szBaseRegKey) ;
    try
	{
		if((lRet = Reg.Open(HKEY_USERS, szTemp, KEY_READ)) == ERROR_SUCCESS)
		{

			for(i = 0 ; i < Reg.GetValueCount() && SUCCEEDED(hr); i++)
			{

				dwRetCode = Reg.EnumerateAndGetValues(i, pValueName, pValueData) ;
				if(dwRetCode == ERROR_SUCCESS)
				{
					// Scan past window coord info (7 decimal #s)
					//===========================================

					c = wcschr((WCHAR*) pValueData, _T(' ')) ;
					for(j = 0 ; j < 6 ; j++) {

						if(c == NULL) {

							break ;
						}

						c = wcschr(c+1, ' ') ; // L10N OK
					}

					// Check conformance to expected format
					//=====================================

					if(c != NULL)
					{

						CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), false ) ;
						if ( pInstance != NULL )
						{
							pInstance->SetCHString(L"UserName", pszUserName );
							pInstance->SetCHString(L"GroupName", c+1);
							pInstance->SetCHString(L"Name", CHString(pszUserName) + CHString(L":") + CHString(c+1));

							hr = pInstance->Commit () ;
						}
					}
				}
			}

			Reg.Close() ;
		}
	}
	catch ( ... )
	{
   		if ( pValueName )
		{
			delete [] pValueName ;
			pValueName = NULL ;
		}

		if ( pValueData )
		{
			delete [] pValueData ;
			pValueData = NULL ;
		}

		throw ;
	}

   	if ( pValueName )
	{
		delete [] pValueName ;
		pValueName = NULL ;
	}

	if ( pValueData )
	{
		delete [] pValueData ;
		pValueData = NULL ;
	}
	//else
	//{
	if (lRet == ERROR_ACCESS_DENIED)
	{
		hr = WBEM_E_ACCESS_DENIED;
	}
	//}

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\programgroup.h ===
//=================================================================

//

// PrgGroup.h -- Program group property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/24/97    jennymc        Updated to meet new framework
//
//=================================================================


//*****************************************************************
//*****************************************************************
//
//             W   A   R   N   I   N   G  !!!!!!!!!!
//             W   A   R   N   I   N   G  !!!!!!!!!!
//
//
//  This class has been deprecated for Nova M2 and later builds of
//  WBEM.  Do not make alterations to this class.  Make changes to
//  the new class Win32_LogicalProgramFile (LogicalProgramFile.cpp)
//  instead.  The new class (correctly) is derived in CIMOM from
//  LogicalElement, not LogicalSetting.
//
//*****************************************************************
//*****************************************************************



// Property set identification
//============================

#define PROPSET_NAME_PRGGROUP   L"Win32_ProgramGroup"


class CWin32ProgramGroup : public Provider
{
    public:

        // Constructor/destructor
        //=======================

        CWin32ProgramGroup(LPCWSTR name, LPCWSTR pszNameSpace);
       ~CWin32ProgramGroup() ;

        // Funcitons provide properties with current values
        //=================================================
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);



    private:
        // Utility function(s)
        //====================

        HRESULT CreateSubDirInstances(LPCTSTR pszUserName,
                                      LPCTSTR pszBaseDirectory,
                                      LPCTSTR pszParentDirectory,
                                      MethodContext*  pMethodContext) ;

        HRESULT EnumerateGroupsTheHardWay(MethodContext*  pMethodContext) ;

        HRESULT InstanceHardWayGroups(LPCWSTR  pszUserName, 
                                   LPCWSTR  pszRegistryKeyName,
                                   MethodContext*  pMethodContext) ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\protocol.cpp ===
//=================================================================

//

// Protocol.CPP -- Network Protocol property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/28/96    a-jmoon        Created
//               10/27/97    davwoh         Moved to curly
//				 1/20/98	 jennymc	Added socket 2.2 support
//
//=================================================================

#include "precomp.h"

#include <iostream.h>

#define INCL_WINSOCK_API_TYPEDEFS	1
#include <winsock2.h>

#include <cregcls.h>
#include "Ws2_32Api.h"
#include "Wsock32Api.h"
#include <nspapi.h>
#include "Protocol.h"
#include "poormansresource.h"
#include "resourcedesc.h"
#include "cfgmgrdevice.h"
#include <typeinfo.h>
#include <ntddndis.h>
#include <traffic.h>
#include <dllutils.h>
#include <..\..\framework\provexpt\include\provexpt.h>


// Property set declaration
//=========================

CWin32Protocol MyProtocolSet(PROPSET_NAME_PROTOCOL, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Protocol::CWin32Protocol
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32Protocol::CWin32Protocol( LPCWSTR a_name, LPCWSTR a_pszNamespace )
:Provider( a_name, a_pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Protocol::~CWin32Protocol
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32Protocol::~CWin32Protocol()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Protocol::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32Protocol::GetObject( CInstance *a_pInst, long a_lFlags /*= 0L*/ )
{
	HRESULT			t_hResult = WBEM_E_NOT_FOUND;
	CProtocolEnum	t_Protocol ;
	CHString		t_sName ;

    //===========================================
	//  Get the correct version of sockets
    //===========================================
	if( !t_Protocol.InitializeSockets() )
	{
		return WBEM_E_FAILED ;
	}

    //===========================================
	//  Go thru the list of protocols
    //===========================================
	a_pInst->GetCHString( IDS_Name, t_sName ) ;

	if( t_Protocol.GetProtocol( a_pInst, t_sName ) )
	{
		// we found it
		t_hResult = WBEM_S_NO_ERROR ;
	}

	return t_hResult ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Protocol::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each logical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32Protocol::EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/)
{
	HRESULT			t_hResult = WBEM_S_NO_ERROR ;
	CProtocolEnum	t_Protocol;
	CHString		t_chsTmp;
					t_chsTmp.Empty();

    // smart ptr
	CInstancePtr	t_pInst ;

	//===========================================
	//  Get the correct version of sockets
    //===========================================
	if( !t_Protocol.InitializeSockets() )
	{
		return WBEM_E_FAILED ;
	}

    //===========================================
	//  Get the list of protocols
    //===========================================

	while( SUCCEEDED( t_hResult ) )
	{
		t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;

		if( t_Protocol.GetProtocol( t_pInst, t_chsTmp ) )
		{
			t_hResult = t_pInst->Commit();
		}
        else
        {
            break;
        }
	}

	return t_hResult ;
}
////////////////////////////////////////////////////////////////////////
//=====================================================================
//  Try to do it using winsock 2.2 for more information, otherwise
//  do it the old way
//=====================================================================
CProtocolEnum::CProtocolEnum()
{
	m_pProtocol = NULL ;
}

//
CProtocolEnum::~CProtocolEnum()
{
	if( m_pProtocol )
	{
        delete m_pProtocol ;
        m_pProtocol = NULL ;
	}
}

//=====================================================================
BOOL CProtocolEnum::InitializeSockets()
{
	BOOL		t_fRc = FALSE ;

	m_pProtocol = new CSockets22();

	if( !m_pProtocol )
	{
		throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
	}

	if( m_pProtocol->BeginEnumeration() )
	{
		t_fRc = TRUE ;
	}
	else
	{
		if( m_pProtocol )
		{
			delete m_pProtocol ;
			m_pProtocol = NULL;
		}
		m_pProtocol = new CSockets11();

		if( !m_pProtocol )
		{
			throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
		}

		if( m_pProtocol->BeginEnumeration() )
		{
			t_fRc = TRUE ;
		}
        else
        {
			delete m_pProtocol ;
            m_pProtocol = NULL;
        }
	}
	return t_fRc ;
}
//=====================================================================
//
//  Yes, I know the proper way is to provide functions to return
//  all of the data values, but I'm lazy....
//
//=====================================================================
BOOL CProtocolEnum::GetProtocol( CInstance *a_pInst,CHString t_chsName )
{
	return( m_pProtocol->GetProtocol( a_pInst, t_chsName ) );
}
//********************************************************************
//  Protocol class
//********************************************************************
CProtocol::CProtocol()
{
	Init();
}

//
void CProtocol::Init()
{
	m_pbBuffer			= NULL ;
	m_nTotalProtocols	= 0 ;
	m_nCurrentProtocol	= 0 ;
}

//
CProtocol::~CProtocol()
{
	if( m_pbBuffer )
	{
		delete [] m_pbBuffer;
		m_pbBuffer = NULL;
	}

	Init();
}

//
BOOL CProtocol::SetDateFromFileName( CHString &a_chsFileName, CInstance *a_pInst )
{
	BOOL		t_fRc = FALSE ;

	_bstr_t		t_bstrFileName ;

	// strip off any trailing switches
	int t_iTokLen = a_chsFileName.Find( L" " ) ;
	if( -1 != t_iTokLen )
	{
		t_bstrFileName = a_chsFileName.Left( t_iTokLen ) ;
	}
	else
	{
		t_bstrFileName = a_chsFileName ;
	}

    WIN32_FILE_ATTRIBUTE_DATA t_FileAttributes;

	if( GetFileAttributesEx(t_bstrFileName, GetFileExInfoStandard, &t_FileAttributes) )
	{

        TCHAR t_Buff[_MAX_PATH];
        CHString t_sDrive = a_chsFileName.Left(3);

        if (!GetVolumeInformation(TOBSTRT(t_sDrive), NULL, 0, NULL, NULL, NULL, t_Buff, _MAX_PATH) ||
            (_tcscmp(t_Buff, _T("NTFS")) != 0) )
        {

            bstr_t t_InstallDate(WBEMTime(t_FileAttributes.ftCreationTime).GetDMTFNonNtfs(), false);

		    a_pInst->SetWCHARSplat( IDS_InstallDate, t_InstallDate) ;
        }
        else
        {
		    a_pInst->SetDateTime( IDS_InstallDate, t_FileAttributes.ftCreationTime) ;
        }

		t_fRc = TRUE ;
	}

	return t_fRc ;
}


//********************************************************************
//    SOCKETS 2.2 implementation
//********************************************************************
CSockets22::CSockets22()
  : m_pws32api( NULL ),
    m_fAlive( FALSE )
{
	m_pws32api = (CWs2_32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidWs2_32Api, NULL);

	// Note a NULL pointer indicates the DLL is not present on the system
	if( m_pws32api != NULL )
    {
        WSADATA t_wsaData;

		m_fAlive = ( m_pws32api->WSAStartUp( 0x202, &t_wsaData) == 0 ) ;
	}
}

CSockets22::~CSockets22()
{
	if( m_fAlive && m_pws32api )
	{
        m_pws32api->WSACleanup();
    }

	if( m_pws32api )
    {
		CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidWs2_32Api, m_pws32api);
        m_pws32api = NULL ;
    }
}

/////////////////////////////////////////////////////////////////////
BOOL CSockets22::BeginEnumeration()
{
	BOOL	t_fRc		= FALSE,
			t_fEnum	= FALSE ;

	if( !m_fAlive )
	{
		return t_fRc ;
	}

	//===========================================================
	//  Now, get a list of protocols
	//===========================================================
	DWORD t_dwSize = 4096 ;

	while( TRUE )
	{
		m_pbBuffer = new byte[ t_dwSize ] ;

		if( !m_pbBuffer )
		{
			throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
		}

		m_pInfo = (LPWSAPROTOCOL_INFO) m_pbBuffer ;

		if ( ( m_nTotalProtocols = m_pws32api->WSAEnumProtocols( NULL, m_pInfo, &t_dwSize ) ) == SOCKET_ERROR )
		{
			if( m_pws32api->WSAGetLastError() == WSAENOBUFS )
			{
				// buffer too small
				delete [] m_pbBuffer ;
				m_pbBuffer = NULL;
			}
			else
			{
			   t_fRc = FALSE ;

			   break ;
			}
		}
		else
		{
		   t_fRc = TRUE ;

		   break ;
		}
	}
	return t_fRc ;
}

//=====================================================================
BOOL CSockets22::GetProtocol( CInstance *a_pInst, CHString a_chsName )
{
	BOOL t_fRc = FALSE ;

	if( m_nCurrentProtocol < m_nTotalProtocols )
	{
		//==============================================
		// If chsName is not empty, then we are looking
		// for a specific protocol, otherwise, we are
		// enumerating them.
		//==============================================

		while( m_nCurrentProtocol < m_nTotalProtocols )
		{
			if( !a_chsName.IsEmpty() )
			{
				if( _tcsicmp( m_pInfo[ m_nCurrentProtocol ].szProtocol, TOBSTRT( a_chsName ) ) == 0 )
				{
					LoadProtocol( a_pInst ) ;

					t_fRc = TRUE ;
				}
			}
			else
			{
				LoadProtocol( a_pInst ) ;

				t_fRc = TRUE ;
			}

			m_nCurrentProtocol++ ;

			if( t_fRc )
			{
				break ;
			}
		}
	}
	return t_fRc ;
}

//====================================================================
void CSockets22::LoadProtocol( CInstance *a_pInst )
{
    a_pInst->SetCHString(	IDS_Name,				(LPCTSTR)	m_pInfo[ m_nCurrentProtocol ].szProtocol);
    a_pInst->SetCHString(	IDS_Caption,			(LPCTSTR)	m_pInfo[ m_nCurrentProtocol ].szProtocol);
    a_pInst->SetCHString(	IDS_Description,		(LPCTSTR)	m_pInfo[ m_nCurrentProtocol ].szProtocol);
	a_pInst->SetDWORD(		L"MaximumMessageSize",				m_pInfo[ m_nCurrentProtocol ].dwMessageSize );
	a_pInst->SetDWORD(		L"MaximumAddressSize",	(DWORD)		m_pInfo[ m_nCurrentProtocol ].iMaxSockAddr );
	a_pInst->SetDWORD(		L"MinimumAddressSize", (DWORD)		m_pInfo[ m_nCurrentProtocol ].iMinSockAddr );
	a_pInst->Setbool(		L"ConnectionlessService",			m_pInfo[ m_nCurrentProtocol ].dwServiceFlags1 & XP1_CONNECTIONLESS        ? TRUE : FALSE );
	a_pInst->Setbool(		L"MessageOriented",					m_pInfo[ m_nCurrentProtocol ].dwServiceFlags1 & XP1_MESSAGE_ORIENTED      ? TRUE : FALSE );
	a_pInst->Setbool(		L"PseudoStreamOriented",			m_pInfo[ m_nCurrentProtocol ].dwServiceFlags1 & XP1_PSEUDO_STREAM         ? TRUE : FALSE );
	a_pInst->Setbool(		L"GuaranteesDelivery",				m_pInfo[ m_nCurrentProtocol ].dwServiceFlags1 & XP1_GUARANTEED_DELIVERY   ? TRUE : FALSE );
	a_pInst->Setbool(		L"GuaranteesSequencing",			m_pInfo[ m_nCurrentProtocol ].dwServiceFlags1 & XP1_GUARANTEED_ORDER      ? TRUE : FALSE );
	a_pInst->Setbool(		L"SupportsGracefulClosing",			m_pInfo[ m_nCurrentProtocol ].dwServiceFlags1 & XP1_GRACEFUL_CLOSE        ? TRUE : FALSE );
	a_pInst->Setbool(		L"SupportsExpeditedData",			m_pInfo[ m_nCurrentProtocol ].dwServiceFlags1 & XP1_EXPEDITED_DATA        ? TRUE : FALSE );
	a_pInst->Setbool(		L"SupportsConnectData",				m_pInfo[ m_nCurrentProtocol ].dwServiceFlags1 & XP1_CONNECT_DATA          ? TRUE : FALSE );
	a_pInst->Setbool(		L"SupportsDisconnectData",			m_pInfo[ m_nCurrentProtocol ].dwServiceFlags1 & XP1_DISCONNECT_DATA       ? TRUE : FALSE );
	a_pInst->Setbool(		L"SupportsBroadcasting",			m_pInfo[ m_nCurrentProtocol ].dwServiceFlags1 & XP1_SUPPORT_BROADCAST     ? TRUE : FALSE );
	a_pInst->Setbool(		L"SupportsMulticasting",			m_pInfo[ m_nCurrentProtocol ].dwServiceFlags1 & XP1_SUPPORT_MULTIPOINT    ? TRUE : FALSE );
	a_pInst->Setbool(		L"SupportsEncryption",				m_pInfo[ m_nCurrentProtocol ].dwServiceFlags1 & XP1_QOS_SUPPORTED         ? TRUE : FALSE );
	a_pInst->Setbool(		IDS_SupportsQualityofService,		m_pInfo[ m_nCurrentProtocol ].dwServiceFlags1 & XP1_QOS_SUPPORTED        ? TRUE : FALSE );


	CHString t_chsStatus ;

    #ifdef NTONLY
    GetTrafficControlInfo(a_pInst);
    #endif

	#ifdef NTONLY
	//===================================================
	//  Now if we can extract the service name, then we
	//  can go out other info out of the registry.  Need
	//  to find a better way to do this.
	//===================================================

	CHString t_chsService;

	_stscanf( m_pInfo[ m_nCurrentProtocol ].szProtocol, _T("%s"), t_chsService.GetBuffer( _MAX_PATH + 2 ) ) ;
	t_chsService.ReleaseBuffer() ;

	// test for RSVP service
	if( t_chsService.CompareNoCase( L"RSVP" ) )
	{
		// else pull out the service name following MSAFD
		t_chsService.Empty() ;

		_stscanf( m_pInfo[ m_nCurrentProtocol ].szProtocol, _T("MSAFD %s"), t_chsService.GetBuffer( _MAX_PATH + 2 ) ) ;
		t_chsService.ReleaseBuffer() ;
	}

	if( !t_chsService.IsEmpty() )
    {
		ExtractNTRegistryInfo( a_pInst, t_chsService.GetBuffer( 0 ) ) ;
	}
	#endif
}

////////////////////////////////////////////////////////////////////////
#ifdef NTONLY
void CSockets22::ExtractNTRegistryInfo(CInstance *a_pInst, LPWSTR a_szService )
{
	CRegistry	t_Reg ;
	CHString	t_chsKey,
				t_chsTmp,
				t_fName ;

	//==========================================================
	//  set the Caption property
	//==========================================================

	a_pInst->SetCHString( IDS_Caption, a_szService ) ;

	t_chsKey = _T("System\\CurrentControlSet\\Services\\") + CHString( a_szService ) ;

	if( ERROR_SUCCESS == t_Reg.Open( HKEY_LOCAL_MACHINE, t_chsKey, KEY_READ ) )
	{
		//======================================================
		//  Set Description and InstallDate properties
		//======================================================
		if( ERROR_SUCCESS == t_Reg.GetCurrentKeyValue( _T("DisplayName"), t_chsTmp ) )
		{
			a_pInst->SetCHString( IDS_Description, t_chsTmp ) ;
		}

		if( ERROR_SUCCESS == t_Reg.GetCurrentKeyValue( _T("ImagePath"), t_fName ) )
		{
			// get a filename out of it - might have SystemRoot in it...
			if ( -1 != t_fName.Find( _T("%SystemRoot%\\") ) )
			{
				t_fName = t_fName.Right( t_fName.GetLength() - 13 ) ;
			}
			else if ( -1 != t_fName.Find( _T("\\SystemRoot\\") ) )
			{
				t_fName = t_fName.Right( t_fName.GetLength() - 12 ) ;
			}

			GetWindowsDirectory( t_chsTmp.GetBuffer( MAX_PATH ), MAX_PATH ) ;

			t_chsTmp.ReleaseBuffer() ;

			t_fName = t_chsTmp + _T("\\") + t_fName ;

			SetDateFromFileName( t_fName, a_pInst ) ;
		}

		//=========================================================
		//  Now, go get the status info
		//=========================================================
#ifdef NTONLY
		if( IsWinNT5() )
		{
			CHString t_chsStatus ;

			if( GetServiceStatus( a_szService,  t_chsStatus ) )
			{
				a_pInst->SetCharSplat(IDS_Status, t_chsStatus ) ;
			}
		}
		else
#endif
		{
			t_chsKey = _T("System\\CurrentControlSet\\Services\\") + CHString( a_szService ) + _T("\\Enum") ;

			if( ERROR_SUCCESS == t_Reg.Open( HKEY_LOCAL_MACHINE, t_chsKey, KEY_READ ) )
			{
				if( ERROR_SUCCESS == t_Reg.GetCurrentKeyValue( _T("0"), t_chsTmp))
				{
					t_chsKey = _T("System\\CurrentControlSet\\Enum\\") + t_chsTmp ;

					if( ERROR_SUCCESS == t_Reg.Open( HKEY_LOCAL_MACHINE, t_chsKey, KEY_READ ) )
					{
						DWORD t_dwTmp ;

						if( ERROR_SUCCESS == t_Reg.GetCurrentKeyValue( _T("StatusFlags"), t_dwTmp ) )
						{
							TranslateNTStatus( t_dwTmp, t_chsTmp ) ;

							a_pInst->SetCHString( IDS_Status, t_chsTmp ) ;
						}
						else
						{
							a_pInst->SetCHString( IDS_Status, IDS_STATUS_Unknown ) ;
						}
					}
				}
			}
		}
	}
}

#endif
//********************************************************************
//    SOCKETS 1.1 implementation
//********************************************************************
CSockets11::CSockets11() : m_pwsock32api( NULL ) , m_pInfo(NULL), m_fAlive( FALSE )
{
	m_pwsock32api = (CWsock32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidWsock32Api, NULL);

	// Note a NULL pointer indicates the DLL is not present on the system
	if( m_pwsock32api != NULL )
    {
        WSADATA t_wsaData;

		m_fAlive = ( m_pwsock32api->WsWSAStartup( 0x0101, &t_wsaData) == 0 ) ;
	}
}

CSockets11::~CSockets11()
{
	if( m_pwsock32api )
    {
		if( m_fAlive )
		{
			m_pwsock32api->WsWSACleanup() ;
		}

		CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidWsock32Api, m_pwsock32api);
        m_pwsock32api = NULL ;
    }
}

void CSockets11::GetStatus( PROTOCOL_INFO *a_ProtoInfo, CHString &a_chsStatus )
{
	if( !a_ProtoInfo || !m_pwsock32api)
	{
		a_chsStatus = IDS_Error ;
		return;
	}

	// Create a socket for this protocol.
	SOCKET t_s = m_pwsock32api->Wssocket(	a_ProtoInfo->iAddressFamily,
											a_ProtoInfo->iSocketType,
											a_ProtoInfo->iProtocol
											);
	if( INVALID_SOCKET != t_s )
	{
		m_pwsock32api->Wsclosesocket( t_s ) ;

		a_chsStatus = IDS_OK ;
	}
	else
	{
		switch ( m_pwsock32api->WsWSAGetLastError() )
		{
			case WSAENETDOWN:
			case WSAEINPROGRESS:
			case WSAENOBUFS:
			case WSAEMFILE:
			{
				a_chsStatus = IDS_Degraded ;
				break;
			}
			case WSANOTINITIALISED:
			case WSAEAFNOSUPPORT:
			case WSAEPROTONOSUPPORT:
			case WSAEPROTOTYPE:
			case WSAESOCKTNOSUPPORT:
			case WSAEINVAL:
			case WSAEFAULT:
			{
				a_chsStatus = IDS_Error ;
				break;
			}

			default:
			{
				a_chsStatus = IDS_Unknown ;
				break;
			}
		}
	}
}

BOOL CSockets11::BeginEnumeration()
{
	DWORD	t_dwByteCount	= 0 ;
	BOOL	t_fRc			= FALSE ;
	m_pInfo = NULL ;

	if ( m_pwsock32api )
	{
		m_pwsock32api->WsEnumProtocols( NULL, m_pInfo, &t_dwByteCount ) ;

		m_pbBuffer = new byte[ t_dwByteCount ] ;

		if( !m_pbBuffer )
		{
			throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
		}

		m_pInfo = (PROTOCOL_INFO *) m_pbBuffer ;

		if( m_pInfo != NULL )
		{
			m_nTotalProtocols = m_pwsock32api->WsEnumProtocols( NULL, m_pInfo, &t_dwByteCount) ;

			if( m_nTotalProtocols != SOCKET_ERROR )
			{
				t_fRc = TRUE ;
			}
		}
	}

	return t_fRc ;
}

//=====================================================================
BOOL CSockets11::GetProtocol( CInstance *a_pInst, CHString a_chsName )
{
	BOOL t_fRc = FALSE ;

	if( m_nCurrentProtocol < m_nTotalProtocols )
	{
		//==============================================
		// If chsName is not empty, then we are looking
		// for a specific protocol, otherwise, we are
		// enumerating them.
		//==============================================
		while( m_nCurrentProtocol < m_nTotalProtocols )
		{
			if( !a_chsName.IsEmpty() )
			{
				if( _tcsicmp( m_pInfo[ m_nCurrentProtocol ].lpProtocol, TOBSTRT( a_chsName ) ) == 0 )
				{
					LoadProtocol( a_pInst ) ;

					t_fRc = TRUE ;
				}
			}
			else
			{
				LoadProtocol( a_pInst ) ;
				t_fRc = TRUE ;
			}
			 m_nCurrentProtocol++ ;

			if( t_fRc )
			{
				break ;
			}
		}
	}
	return t_fRc ;
}

//====================================================================
void CSockets11::LoadProtocol( CInstance *a_pInst )
{
 	a_pInst->SetCHString( IDS_Name,					m_pInfo[ m_nCurrentProtocol ].lpProtocol);
 	a_pInst->SetCHString( IDS_Caption,				m_pInfo[ m_nCurrentProtocol ].lpProtocol);
 	a_pInst->SetCHString( IDS_Description,			m_pInfo[ m_nCurrentProtocol ].lpProtocol);
	a_pInst->SetDWORD( L"MaximumMessageSize",		m_pInfo[ m_nCurrentProtocol ].dwMessageSize );
	a_pInst->SetDWORD( L"MaximumAddressSize", (DWORD) m_pInfo[ m_nCurrentProtocol ].iMaxSockAddr );
	a_pInst->SetDWORD( L"MinimumAddressSize", (DWORD) m_pInfo[ m_nCurrentProtocol ].iMinSockAddr );

	a_pInst->Setbool( L"ConnectionlessService",		m_pInfo[ m_nCurrentProtocol ].dwServiceFlags & XP_CONNECTIONLESS       ? TRUE : FALSE );
	a_pInst->Setbool( L"MessageOriented",			m_pInfo[ m_nCurrentPro