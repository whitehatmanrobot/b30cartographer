urn _T("PROPERTIES");
    case MMC_VERB_RENAME:
                return _T("RENAME");
    case MMC_VERB_REFRESH:
                return _T("REFRESH");
    case MMC_VERB_PRINT:
                return _T("PRINT");
    case MMC_VERB_CUT:
                return _T("CUT");
        default:
                wsprintf(error, _T("Unknown verb id %d"), verb);
                return error;
        }
}

void MMCN_Crack(BOOL bComponentData,
                IDataObject *pDataObject,
                                IComponentData *pCompData,
                                IComponent *pComp,
                MMC_NOTIFY_TYPE event,
                                LPARAM arg,
                                LPARAM param)
{
#ifdef MMC_CRACK_MESSAGES
        TCHAR message[256] = {0};

        if (bComponentData == TRUE)
                OutputDebugString(_T("IComponentData::Notify( "));
        else
                OutputDebugString(_T("IComponent::Notify( "));

        wsprintf(message, _T("DataObject: %08x, CompData: %08x, Comp: %08x ) - "), pDataObject, pCompData, pComp);
        OutputDebugString(message);

    switch (event)      {
                case MMCN_ACTIVATE:
                        wsprintf(message, _T("MMCN_ACTIVATE\n\tActivate: %d\n"), arg);
                        break;

                case MMCN_ADD_IMAGES:
                        wsprintf(message, _T("MMCN_ADD_IMAGES\n\tImage List: %08x\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_BTN_CLICK:
                        wsprintf(message, _T("MMCN_BTN_CLICK\n\tVerb: %ws\n"), MMCN_CrackVerb((MMC_CONSOLE_VERB)param));
                        break;

                case MMCN_COLUMN_CLICK:
                        wsprintf(message, _T("MMCN_COLUMN_CLICK\n\tColumn: %d\n\tSort Option: %d\n"), arg,       param);
                        break;

                case MMCN_COLUMNS_CHANGED:
                        wsprintf(message, _T("MMCN_COLUMNS_CHANGED\n"));
                        break;

                case MMCN_CONTEXTHELP:
                        wsprintf(message, _T("MMCN_CONTEXTHELP\n"));
                        break;

                case MMCN_CONTEXTMENU:
                        wsprintf(message, _T("MMCN_CONTEXTMENU\n"));
                        break;

                case MMCN_CUTORMOVE:
                        wsprintf(message, _T("MMCN_CUTORMOVE\n"));
                        break;

                case MMCN_DBLCLICK:
                        wsprintf(message, _T("MMCN_DBLCLICK\n"));
                        break;

                case MMCN_DELETE:
                        wsprintf(message, _T("MMCN_DELETE\n"));
                        break;

                case MMCN_DESELECT_ALL:
                        wsprintf(message, _T("MMCN_DESELECT_ALL\n"));
                        break;

                case MMCN_EXPAND:
                        wsprintf(message, _T("MMCN_EXPAND\n\tExpand: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_EXPANDSYNC:
                        wsprintf(message, _T("MMCN_EXPANDSYNC\n"));
                        break;

                case MMCN_FILTERBTN_CLICK:
                        wsprintf(message, _T("MMCN_FILTERBTN_CLICK\n\tColumn: %d\n"), arg);
                        break;

                case MMCN_FILTER_CHANGE:
                        wsprintf(message, _T("MMCN_FILTER_CHANGE\n\tColumn: %d\n"), param);
                        break;

                case MMCN_HELP:
                        wsprintf(message, _T("MMCN_HELP\n"));
                        break;

                case MMCN_INITOCX:
                        wsprintf(message, _T("MMCN_INITOCX\n\tIUnknown: %08x\n"), param);
                        break;

                case MMCN_LISTPAD:
                        wsprintf(message, _T("MMCN_LISTPAD\n\tConnect: %d\n"), arg);
                        break;

                case MMCN_MENU_BTNCLICK:
                        wsprintf(message, _T("MMCN_MENU_BTNCLICK\n"));
                        break;

                case MMCN_MINIMIZED:
                        wsprintf(message, _T("MMCN_MINIMIZED\n\tMinimized: %d\n"), arg);
                        break;

                case MMCN_PASTE:
                        wsprintf(message, _T("MMCN_PASTE\n\tCopy: %d\n"), param == NULL);
                        break;

                case MMCN_PRELOAD:
                        wsprintf(message, _T("MMCN_PRELOAD\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_PRINT:
                        wsprintf(message, _T("MMCN_PRINT\n"));
                        break;

                case MMCN_PROPERTY_CHANGE:
                        wsprintf(message, _T("MMCN_PROPERTY_CHANGE\n\tScope: %d\n\tArg: %08x\n"), arg, param);
                        break;

                case MMCN_QUERY_PASTE:
                        wsprintf(message, _T("MMCN_QUERY_PASTE\n"));
                        break;

                case MMCN_REFRESH:
                        wsprintf(message, _T("MMCN_REFRESH\n"));
                        break;

                case MMCN_REMOVE_CHILDREN:
                        wsprintf(message, _T("MMCN_REMOVE_CHILDREN\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_RENAME:
                        wsprintf(message, _T("MMCN_RENAME\n\tNew Name: '%ws'\n"), (LPOLESTR)param);
                        break;

                case MMCN_RESTORE_VIEW:
                        wsprintf(message, _T("MMCN_RESTORE_VIEW\n"));
                        break;

                case MMCN_SELECT:
                        wsprintf(message, _T("MMCN_SELECT\n\tScope: %d\n\tSelect: %08x\n"), LOWORD(arg), HIWORD(arg));
                        break;

                case MMCN_SHOW:
                        wsprintf(message, _T("MMCN_SHOW\n\tShow: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_SNAPINHELP:
                        wsprintf(message, _T("MMCN_SNAPINHELP\n"));
                        break;

                case MMCN_VIEW_CHANGE:
                        wsprintf(message, _T("MMCN_VIEW_CHANGE\n\tData: %08x\n\tHint: %08x\n"), arg, param);
                        break;
        }

        if (message[0] != 0)
                OutputDebugString(message);
        else
                OutputDebugString(_T("unknown event\n"));

#endif
        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\delebase.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DeleBase.h"

const GUID CDelegationBase::thisGuid = { 0x2974380b, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

HBITMAP CDelegationBase::m_pBMapSm = NULL;
HBITMAP CDelegationBase::m_pBMapLg = NULL;


//==============================================================
//
// CDelegationBase implementation
//
//
CDelegationBase::CDelegationBase() 
: bExpanded(FALSE), m_handle(NULL)
{ 
    if (NULL == m_pBMapSm || NULL == m_pBMapLg)
        LoadBitmaps(); 
}

CDelegationBase::~CDelegationBase() 
{ 
}

// CDelegationBase::AddImages sets up the collection of images to be displayed
// by the IComponent in the result pane as a result of its MMCN_SHOW handler
HRESULT CDelegationBase::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi) 
{
    return pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\delebase.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _BRANCHES_H
#define _BRANCHES_H

#include <mmc.h>
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "LocalRes.h"

class CComponentData;

class CDelegationBase {
public:
    CDelegationBase();
    virtual ~CDelegationBase();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) = 0;
    virtual void GetChildColumnInfo(RESULTDATAITEM *rdi) { }
    virtual const GUID & getNodeType() { _ASSERT(FALSE); return IID_NULL; }
    
    virtual const LPARAM GetCookie() { return reinterpret_cast<LPARAM>(this); }
    virtual const int GetBitmapIndex() = 0;

	virtual CDelegationBase *GetChildPtr(int index) { return NULL; }
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions) { return S_FALSE; }

	virtual HRESULT SelectItem(IConsole *pConsole) 
	{
		return pConsole->SelectScopeItem(HSCOPEITEM(m_handle));
	}
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent) { return S_FALSE; }
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem) { return S_FALSE; }
    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect) { return S_FALSE; }
    virtual HRESULT OnRefresh(IConsole *pConsole) { return S_FALSE; }
	virtual HRESULT OnUpdateItem(IConsole *pConsole, long item, ITEM_TYPE itemtype) { return S_FALSE; }
    virtual HRESULT OnRename(LPOLESTR pszNewName) { return S_FALSE; }

	// cut / copy / paste implementation
	virtual HRESULT OnPaste(IConsole *pConsole, CComponentData *pComponentData, CDelegationBase *pPasted) { return S_FALSE; }
	virtual HRESULT OnQueryPaste(CDelegationBase *pPasted) { return S_FALSE; }
	virtual HRESULT OnDelete(IConsole *pConsole) { return S_FALSE; }
	virtual HRESULT OnDeleteScopeItem(IConsoleNameSpace *pConsoleNameSpace) { _ASSERT(FALSE); return S_FALSE; }

public:
    static HBITMAP m_pBMapSm;
    static HBITMAP m_pBMapLg;

	HANDLE GetHandle() { return m_handle; }
	void SetHandle(HANDLE handle) { m_handle = handle; }
    
protected:
    static void LoadBitmaps() {
        m_pBMapSm = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_SMICONS));
        m_pBMapLg = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_LGICONS));
    }
    
    BOOL bExpanded;
    
private:
    // {2974380B-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
	HANDLE m_handle;
};

#endif // _BRANCHES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <mmc.h>
#include <tchar.h>

#ifndef STRINGS_ONLY
		
		enum UPDATE_VIEWS_HINT {UPDATE_SCOPEITEM = 1000, DELETE_SCOPEITEM, UPDATE_RESULTITEM, DELETE_RESULTITEM}; 
		enum ITEM_TYPE {SCOPE = 10, RESULT}; 

        #define IDM_BUTTON1    0x100
        #define IDM_BUTTON2    0x101

        extern HINSTANCE g_hinst;
        extern ULONG g_uObjects;

        #define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
        #define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

        // uncomment the following #define to enable message cracking
        // #define MMC_CRACK_MESSAGES
        void MMCN_Crack(BOOL bComponentData,
                                        IDataObject *pDataObject,
                                        IComponentData *pCompData,
                                        IComponent *pComp,
                                        MMC_NOTIFY_TYPE event,
                                        LPARAM arg,
                                        LPARAM param);
#endif

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(GetProcessHeap(), 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(GetProcessHeap(), 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given a _TCHAR, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszT;
//  pszT = MyGetTStringRoutine();
//  MAKE_WIDEPTR_FROMSTR(pwsz, pszT);
//  MyUseWideStringRoutine(pwsz);
//  ...
#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPWSTR)__TempBuffer##ptrname.GetBuffer(), tstr); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    lstrcpyW((LPWSTR)ptrname, tstr)
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, ptrname, __l##ptrname)
#endif

//
// similarily for MAKE_TSTRPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
// * 2 for DBCS handling in below length computation
//
#ifdef UNICODE
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPTSTR)__TempBuffer##ptrname.GetBuffer(), widestr); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\registry.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions = FALSE);

HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5
#define INDEX_BACKGROUND    6
#define INDEX_STATION       7

#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\guids.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

// {C30C5B42-1913-11d3-9A38-0080C7258072}
DEFINE_GUID(CLSID_CComponentData, 
			0xc30c5b42, 0x1913, 0x11d3, 0x9a, 0x38, 0x0, 0x80, 0xc7, 0x25, 0x80, 0x72);

// {C99D3D80-1913-11d3-9A38-0080C7258072}
DEFINE_GUID(CLSID_CSnapinAbout, 
			0xc99d3d80, 0x1913, 0x11d3, 0x9a, 0x38, 0x0, 0x80, 0xc7, 0x25, 0x80, 0x72);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\land.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _LAND_H
#define _LAND_H

#include "DeleBase.h"

class CLandBasedVehicle : public CDelegationBase {
public:
    CLandBasedVehicle() { }
    
    virtual ~CLandBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Land-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_LANDICON; }
    
private:
    enum { IDM_NEW_LAND = 2 };
    
    // {2974380E-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};


#endif // _LAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\people.cpp ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#include <stdio.h>
#include "People.h"

const GUID CPeoplePoweredVehicle::thisGuid = { 0x2974380d, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

const GUID CBicycleFolder::thisGuid = { 0xef163732, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboardFolder::thisGuid = { 0xef163733, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkateFolder::thisGuid = { 0xf6c660b0, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };

const GUID CBicycle::thisGuid = { 0xef163734, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboard::thisGuid = { 0xef163735, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkate::thisGuid = { 0xf6c660b1, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };


//==============================================================
//
// CPeoplePoweredVehicle implementation
//
//
CPeoplePoweredVehicle::CPeoplePoweredVehicle()
{
    children[0] = new CBicycleFolder;
    children[1] = new CSkateboardFolder;
    children[2] = new CIceSkateFolder;
}

CPeoplePoweredVehicle::~CPeoplePoweredVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        delete children[n];
}

HRESULT CPeoplePoweredVehicle::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;

    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT    |   // relativeID is valid
                SDI_CHILDREN;     // cChildren is valid

            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = 0;

            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );

            _ASSERT( SUCCEEDED(hr) );

                    children[n]->SetHandle((HANDLE)sdi.ID);
        }
    }

    return S_OK;
}

CBicycleFolder::CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CBicycle(n + 1);
    }
}

CBicycleFolder::~CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CBicycleFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );

                            children[n]->SetHandle((HANDLE)rdi.itemID);
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

CIceSkateFolder::CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CIceSkate(n + 1);
    }
}

CIceSkateFolder::~CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CIceSkateFolder::GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions)
{
    *ppViewType = NULL;
    *pViewOptions = MMC_VIEW_OPTIONS_OWNERDATALIST;

    return S_OK;
}

void CIceSkateFolder::GetChildColumnInfo(RESULTDATAITEM *rdi)
{
    if (rdi->mask & RDI_STR)
    {
        LPCTSTR pszT = children[rdi->nIndex]->GetDisplayName(rdi->nCol);
        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
        rdi->str = pszW;
    }

    if (rdi->mask & RDI_IMAGE)
        rdi->nImage = children[rdi->nIndex]->GetBitmapIndex();
}

// CDelegationBase::AddImages sets up the collection of images to be displayed
// by the IComponent in the result pane as a result of its MMCN_SHOW handler
HRESULT CIceSkateFolder::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi)
{
    return pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}

HRESULT CIceSkateFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            hr = pResultData->SetItemCount( NUMBER_OF_CHILDREN, 0 );
            _ASSERT( SUCCEEDED(hr) );
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

CSkateboardFolder::CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CSkateboard(n + 1);
    }
}

CSkateboardFolder::~CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSkateboardFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                      ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );

                            children[n]->SetHandle((HANDLE)rdi.itemID);
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

const _TCHAR *CBicycle::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Bicycle #%d"), id);

    return buf;
}

const _TCHAR *CSkateboard::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Skateboard #%d"), id);

    return buf;
}

const _TCHAR *CIceSkate::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Ice Skate #%d"), id);

    return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Resource.rc
//
#define IDS_HELPFILE                    1
#define IDS_SNAPINDESC                  2
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDI_ICON1                       108
#define IDB_SMOPEN                      111
#define IDB_SMBMP                       112
#define IDB_LGBMP                       113
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDB_ROCKET                      40004
#define IDB_CAR                         40005
#define IDB_PLANE                       40006
#define IDB_BIKE                        40007
#define IDB_ROCKET2                     40008
#define IDB_CAR2                        40009
#define IDB_PLANE2                      40010
#define IDB_BIKE2                       40011
#define IDB_CLOSED2                     40012
#define IDB_OPEN2                       40013
#define IDB_CLOSED                      40014
#define IDB_OPEN                        40015

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        114
#define _APS_NEXT_COMMAND_VALUE         40016
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\people.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _PEOPLE_H
#define _PEOPLE_H

#include "DeleBase.h"

class CBicycle : public CDelegationBase {
public:
    CBicycle(int i) : id(i) { }
    virtual ~CBicycle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CBicycleFolder : public CDelegationBase {
public:
    CBicycleFolder();
    virtual ~CBicycleFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Bicycles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CSkateboard : public CDelegationBase {
public:
    CSkateboard(int i) : id(i) { }
    virtual ~CSkateboard() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CSkateboardFolder : public CDelegationBase {
public:
    CSkateboardFolder();
    virtual ~CSkateboardFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Skateboards"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CIceSkate : public CDelegationBase {
public:
    CIceSkate(int i) : id(i) { }
    virtual ~CIceSkate() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CIceSkateFolder : public CDelegationBase {
public:
    CIceSkateFolder();
    virtual ~CIceSkateFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Ice Skates"); }
    virtual void GetChildColumnInfo(RESULTDATAITEM *rdi);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }

	virtual CDelegationBase *GetChildPtr(int index) { 
		return (index < NUMBER_OF_CHILDREN) ? children[index] : NULL;
	}

    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions);
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 5000 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CPeoplePoweredVehicle : public CDelegationBase {
public:
    CPeoplePoweredVehicle();
    virtual ~CPeoplePoweredVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("People-powered Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { IDM_NEW_PEOPLE = 1 };
    
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 3 };
    CDelegationBase *children[3];
};

#endif // _PEOPLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\sky.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Sky.h"

const GUID CSkyBasedVehicle::thisGuid = { 0x2974380f, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSkyBasedVehicle implementation
//
//
HRESULT CSkyBasedVehicle::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
	HRESULT hr;
	IUnknown *pUnk = NULL;
	IMessageView *pMessageView = NULL;

	hr = pConsole->QueryResultView(&pUnk);

	if (SUCCEEDED(hr)) {
		hr = pUnk->QueryInterface(IID_IMessageView, (void **)&pMessageView);

		if (SUCCEEDED(hr)) {
			pMessageView->SetIcon(Icon_Information);
			pMessageView->SetTitleText(L"Sky-based vehicles");
			pMessageView->SetBodyText(L"Sky-based vehicles have no child nodes.");

			pMessageView->Release();
		}

		pUnk->Release();
	}

	return S_FALSE;
}

HRESULT CSkyBasedVehicle::GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions)
{
    // error message control
	LPOLESTR lpOleStr = NULL;
	HRESULT hr = StringFromCLSID(CLSID_MessageView, &lpOleStr);
    *ppViewType = lpOleStr;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\sky.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SKY_H
#define _SKY_H

#include "DeleBase.h"

class CSkyBasedVehicle : public CDelegationBase {
public:
    CSkyBasedVehicle() { }
    
    virtual ~CSkyBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Sky-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SKYICON; }

public:
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions);

private:
    enum { IDM_NEW_SKY = 3 };
    
    // {2974380F-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};


#endif // _SKY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\registry.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

#define STRINGS_ONLY
#include "globals.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName)       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule,
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;

    assert(dwResult != 0) ;

    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    assert(SUCCEEDED(hr)) ;

        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;
        _tcscat(szKey, pszCLSID) ;

    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;

    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    _tcscat(szKey, _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), _T("Apartment"));

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;


    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;

        MAKE_TSTRPTR_FROMWIDE(pszT, wszCLSID);
        _tcscat(szKey, pszT) ;

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Register the snap-in in the registry.
//
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,         // Class Id for About Class
                       const BOOL fSupportExtensions)
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    LPOLESTR wszAboutCLSID = NULL;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    if (IID_NULL != clsidAbout)
        hr = StringFromCLSID(clsidAbout, &wszAboutCLSID);

        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszAboutCLSID, wszAboutCLSID);


    // Add the CLSID to the registry.
    setSnapInKeyAndValue(pszCLSID, NULL, _T("NameString"), szNameString) ;
    setSnapInKeyAndValue(pszCLSID, _T("StandAlone"), NULL, NULL);
    if (IID_NULL != clsidAbout)
        setSnapInKeyAndValue(pszCLSID, NULL, _T("About"), pszAboutCLSID);

    if (fSupportExtensions) {
        // Build the key NodeType
        setSnapInKeyAndValue(pszCLSID, _T("NodeTypes"), NULL, NULL);

        _TCHAR szKey[64] ;
        _tcscpy(szKey, pszCLSID) ;
        _tcscat(szKey, _T("\\NodeTypes")) ;
        setSnapInKeyAndValue(szKey, pszCLSID, NULL, NULL);
    }

    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    if (IID_NULL != clsidAbout)
        CoTaskMemFree(wszAboutCLSID);

    return S_OK ;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    LPOLESTR wszCLSID = NULL;

    // Get CLSID
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\"));
    _tcscat(szKeyBuf, pszCLSID);

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // free the memory
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }

    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }

    // Close the child.
    RegCloseKey(hKeyChild) ;

    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\")) ;
    _tcscat(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\extens\about.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "About.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

CSnapinAbout::CSnapinAbout()
: m_cref(0)
{
    OBJECT_CREATED
        
        m_hSmallImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    m_hLargeImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_LGBMP), IMAGE_BITMAP, 32, 32, LR_LOADTRANSPARENT);
    
    m_hSmallImageOpen = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMOPEN), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    
    m_hAppIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ICON1));
}

CSnapinAbout::~CSnapinAbout()
{
    if (m_hSmallImage != NULL)
        FreeResource(m_hSmallImage);
    
    if (m_hLargeImage != NULL)
        FreeResource(m_hLargeImage);
    
    if (m_hSmallImageOpen != NULL)
        FreeResource(m_hSmallImageOpen);
    
    if (m_hAppIcon != NULL)
        FreeResource(m_hAppIcon);
    
    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;
    
    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CSnapinAbout::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<ISnapinAbout *>(this);
    else if (IsEqualIID(riid, IID_ISnapinAbout))
        *ppv = static_cast<ISnapinAbout *>(this);
    
    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSnapinAbout::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CSnapinAbout::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    return m_cref;
    
}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription( 
                                                /* [out] */ LPOLESTR *lpDescription)
{
    _TCHAR szDesc[MAX_PATH];
    
    LoadString(g_hinst, IDS_SNAPINDESC, szDesc, sizeof(szDesc));
    
    return AllocOleStr(lpDescription, szDesc);
}


STDMETHODIMP CSnapinAbout::GetProvider( 
                                       /* [out] */ LPOLESTR *lpName)
{
    return AllocOleStr(lpName, _T("Copyright  1998 Microsoft Corporation"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinVersion( 
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return AllocOleStr(lpVersion, _T("1.0"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinImage( 
                                          /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;
    
    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}


STDMETHODIMP CSnapinAbout::GetStaticFolderImage( 
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;
    
    *hSmallImageOpen = m_hSmallImageOpen;
    
    *cMask = RGB(0, 128, 128);
    
    if (*hSmallImage == NULL || *hLargeImage == NULL || *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}

// this allocates a chunk of memory using CoTaskMemAlloc and copies our chars into it
HRESULT CSnapinAbout::AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer)
{
	MAKE_WIDEPTR_FROMTSTR_ALLOC(wszStr, szBuffer);
	*lpDest = wszStr;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\extens\about.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPABOUT_H_
#define _SAMPABOUT_H_

#include <tchar.h>
#include <mmc.h>

class CSnapinAbout : public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;
    
public:
    CSnapinAbout();
    ~CSnapinAbout();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
        /* [out] */ LPOLESTR *lpDescription);
        
        STDMETHODIMP GetProvider( 
        /* [out] */ LPOLESTR *lpName);
        
        STDMETHODIMP GetSnapinVersion( 
        /* [out] */ LPOLESTR *lpVersion);
        
        STDMETHODIMP GetSnapinImage( 
        /* [out] */ HICON *hAppIcon);
        
        STDMETHODIMP GetStaticFolderImage( 
        /* [out] */ HBITMAP *hSmallImage,
        /* [out] */ HBITMAP *hSmallImageOpen,
        /* [out] */ HBITMAP *hLargeImage,
        /* [out] */ COLORREF *cMask);
        
        ///////////////////////////////
        // Private Interface 
        ///////////////////////////////
private:
    HRESULT	CSnapinAbout::AllocOleStr(
        LPOLESTR *lpDest, 
        _TCHAR *szBuffer);
};

#endif _SAMPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\extens\basesnap.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#ifndef _BASESNAP_H_
#define _BASESNAP_H_

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);
STDAPI DllCanUnloadNow(void);

ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    enum FACTORY_TYPE {COMPONENT = 0, ABOUT = 1};
    
    CClassFactory(FACTORY_TYPE factoryType);
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
private:
    FACTORY_TYPE m_factoryType;
};

#endif _BASESNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\space.cpp ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#include <stdio.h>
#include "DataObj.h"
#include "Space.h"
#include "Comp.h"

const GUID CSpaceFolder::thisGuid = { 0x29743810, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };
const GUID CSpaceStation::thisGuid = { 0x62273a12, 0x1914, 0x11d3, { 0x9a, 0x38, 0x0, 0x80, 0xc7, 0x25, 0x80, 0x72 } };
const GUID CRocket::thisGuid = { 0x29743811, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSpaceFolder implementation
//
//
CSpaceFolder::CSpaceFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CSpaceStation();
    }
}

CSpaceFolder::~CSpaceFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSpaceFolder::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;

    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT    |
                SDI_CHILDREN;

            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = 0;

            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );

            _ASSERT( SUCCEEDED(hr) );

                    children[n]->SetHandle((HANDLE)sdi.ID);
        }
    }

    return S_OK;
}

//==============================================================
//
// CSpaceStation implementation
//
//
CSpaceStation::CSpaceStation() : m_cChildSpaceStations(0)
{
    for (int n = 0; n < MAX_CHILDREN; n++) {
        children[n] = NULL;
    }

    for (n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CRocket(this, _T("Rocket"), n, 350115, 320, 52300);
    }
}

CSpaceStation::~CSpaceStation()
{
    for (int n = 0; n < MAX_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSpaceStation::Expand(IConsoleNameSpace *pConsoleNameSpace)
{

        //Expand the CSpaceStation if necessary.
        //This method is called by the object's OnPaste method during paste operations.

        HRESULT hr = S_FALSE;

        //First, need the IConsoleNameSpace2 interface to call Expand.
        IConsoleNameSpace2 *pConsoleNamespace2 = NULL;
        hr = pConsoleNameSpace->QueryInterface(IID_IConsoleNameSpace2, (void **)&pConsoleNamespace2);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsoleNamespace2->Expand((HSCOPEITEM)GetHandle());

        pConsoleNamespace2->Release();

        return hr;
}


HRESULT CSpaceStation::GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions)
{
        return S_FALSE;
}

HRESULT CSpaceStation::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Rocket Class", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 1, L"Rocket Weight", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 2, L"Rocket Height", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 3, L"Rocket Payload", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 4, L"Status", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < MAX_CHILDREN; n++) {

                                if (NULL == children[n])
                                        //No more children to insert, so exit for loop
                                        break;

                                BOOL childDeleteStatus = children[n]->getDeletedStatus();
                                if ( !childDeleteStatus) {
                                                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                                                rdi.mask       = RDI_STR       |   // Displayname is valid
                                                                                                                 RDI_IMAGE     |
                                                                                                                 RDI_PARAM;        // nImage is valid

                                                rdi.nImage      = children[n]->GetBitmapIndex();
                                                rdi.str         = MMC_CALLBACK;
                                                rdi.nCol        = 0;
                                                rdi.lParam      = (LPARAM)children[n];

                                                hr = pResultData->InsertItem( &rdi );

                                                _ASSERT( SUCCEEDED(hr) );

                                                children[n]->SetHandle((HANDLE)rdi.itemID);
                 }
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

HRESULT CSpaceStation::OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect)
{
    IConsoleVerb *pConsoleVerb;

    HRESULT hr = pConsole->QueryConsoleVerb(&pConsoleVerb);
    _ASSERT(SUCCEEDED(hr));

    hr = pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, TRUE);
    hr = pConsoleVerb->SetVerbState(MMC_VERB_CUT, HIDDEN, FALSE);
    hr = pConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, TRUE);
    hr = pConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, FALSE);
    hr = pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);
    hr = pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, FALSE);
    hr = pConsoleVerb->SetVerbState(MMC_VERB_PASTE, ENABLED, TRUE);
    hr = pConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, FALSE);

    pConsoleVerb->Release();

    return S_OK;
}

HRESULT CSpaceStation::OnPaste(IConsole *pConsole, CComponentData *pComponentData, CDelegationBase *pPasted)
{
        CRocket *pRocket = dynamic_cast<CRocket *>(pPasted);

        HRESULT hr = S_OK;

        if (NULL == pRocket)
        {
            // See if this is CSpaceStation, if so paste it into this item.
            // This sample simply creates a new CSpaceStation
            // and inserts it as a child of the destination of the paste.
            // It does not paste the cut/copied CSpaceStation and the
            // current state of its result items.
            CSpaceStation* pSpaceStn = dynamic_cast<CSpaceStation*>(pPasted);
            if ( (NULL != pSpaceStn) &&
                 (pSpaceStn != this) )
            {
                // Regardless of whether this item is expanded or not
                // always try to expand this scopeitem (so that paste can
                // succeed).
                hr = Expand(pComponentData->GetConsoleNameSpace());

                CSpaceStation* pNewStation = new CSpaceStation();

                SCOPEDATAITEM sdi;
                ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
                sdi.mask = SDI_STR|   // Displayname is valid
                    SDI_PARAM     |   // lParam is valid
                    SDI_IMAGE     |   // nImage is valid
                    SDI_OPENIMAGE |   // nOpenImage is valid
                    SDI_PARENT    |
                    SDI_CHILDREN;

                sdi.relativeID  = (HSCOPEITEM)GetHandle();
                sdi.nImage      = pNewStation->GetBitmapIndex();
                sdi.nOpenImage  = INDEX_OPENFOLDER;
                sdi.displayname = MMC_CALLBACK;
                sdi.lParam      = (LPARAM)pNewStation;       // The cookie
                sdi.cChildren   = 0;

                hr = pComponentData->GetConsoleNameSpace()->InsertItem( &sdi );
                _ASSERT( SUCCEEDED(hr) );

                pNewStation->SetHandle((HANDLE)sdi.ID);

            }

                        //increment count of child space stations
                        m_cChildSpaceStations++;

            return hr;
        }

        if (pRocket->m_pSpaceStation == this)
                return S_FALSE;

                //Create a new CRocket for the destination CSpaceStation
                CRocket *myRocket = new CRocket(pRocket->m_pSpaceStation, pRocket->szName, pRocket->nId,
                                                                                pRocket->lWeight, pRocket->lHeight, pRocket->lPayload);

        for (int n = 0; n < MAX_CHILDREN; n++) {
                if (NULL == children[n]) {
                        // put it here

                                                children[n] = myRocket;
                                                children[n]->isDeleted = FALSE;
                                                children[n]->nId = n;
                                                children[n]->m_pSpaceStation = this;

                        return S_OK;
                }
        }

        return S_FALSE;
}

HRESULT CSpaceStation::OnQueryPaste(CDelegationBase *pPasted)
{
        CRocket *pRocket = dynamic_cast<CRocket *>(pPasted);

        if (NULL == pRocket)
        {
            // See if this is CSpaceStation.
            CSpaceStation* pSpaceStn = dynamic_cast<CSpaceStation*>(pPasted);
            if ( (NULL != pSpaceStn) &&
                 (pSpaceStn != this) )
            {
                return S_OK;
            }

            return S_FALSE;
        }

        if (pRocket->m_pSpaceStation != this)
                for (int n = 0; n < MAX_CHILDREN; n++) {
                        if (NULL == children[n]) {
                                return S_OK;
                        }
                }

        return S_FALSE;
}

HRESULT CSpaceStation::OnUpdateItem(IConsole *pConsole, long item, ITEM_TYPE itemtype)

{
        HRESULT hr = S_OK;

        _ASSERT(item);
        _ASSERT(SCOPE == itemtype);

        //refresh all result pane views
        hr = pConsole->SelectScopeItem( (HSCOPEITEM)item );
        _ASSERT( S_OK == hr);

        return hr;
}


HRESULT CSpaceStation::OnDeleteScopeItem (IConsoleNameSpace *pConsoleNameSpace)

{
        HRESULT hr = S_FALSE;

        HSCOPEITEM hCutItem = (HSCOPEITEM)GetHandle();

        //Get handle and cookie of parent scope item. We need these to
        //remove the "+" sign if the parent's m_cChildSpaceStations goes to zero.
        HSCOPEITEM hParentItem;
        MMC_COOKIE cookieParentItem;

        HRESULT hr1 = pConsoleNameSpace->GetParentItem(hCutItem, &hParentItem,
                                                                                                        (long *)&cookieParentItem);

        //Delete the cut item
        hr = pConsoleNameSpace->DeleteItem(hCutItem, TRUE);
        _ASSERT(S_OK == hr);

        if (SUCCEEDED(hr1))
        {
                //Decrement parent's m_cChildSpaceStations count and
                //remove "+" sign if necessary
                CSpaceStation* pParentSpaceStn = reinterpret_cast<CSpaceStation*>(cookieParentItem);
                pParentSpaceStn->DecrementCountChildSpaceStations();

                if ( !pParentSpaceStn->GetCountChildSpaceStations() )
                {
                        SCOPEDATAITEM sdi;

                        ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
                        sdi.mask                = SDI_CHILDREN; //cChildren is valid
                        sdi.ID          = (HSCOPEITEM)hParentItem;
                        sdi.cChildren   = 0;

                        hr = pConsoleNameSpace->SetItem( &sdi );
                        _ASSERT( SUCCEEDED(hr) );
                }

        }

        return hr;
}

//==============================================================
//
// CRocket implementation
//
//
CRocket::CRocket(CSpaceStation *pSpaceStation, _TCHAR *szName, int id, LONG lWeight, LONG lHeight, LONG lPayload)
: m_pSpaceStation(pSpaceStation), szName(NULL), lWeight(0), lHeight(0), lPayload(0), iStatus(STOPPED)
{
    if (szName) {
        this->szName = new _TCHAR[(_tcslen(szName) + 1) * sizeof(_TCHAR)];
        _tcscpy(this->szName, szName);
    }

    this->nId = id;
    this->lWeight = lWeight;
    this->lHeight = lHeight;
    this->lPayload = lPayload;

        isDeleted = FALSE;
}

CRocket::~CRocket()
{
    if (szName)
        delete [] szName;
}

const _TCHAR *CRocket::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    switch (nCol) {
    case 0:
        _stprintf(buf, _T("%s (#%d)"), szName ? szName : _T(""), nId);
        break;

    case 1:
        _stprintf(buf, _T("%ld metric tons"), lWeight);
        break;

    case 2:
        _stprintf(buf, _T("%ld meters"), lHeight);
        break;

    case 3:
        _stprintf(buf, _T("%ld kilos"), lPayload);
        break;

    case 4:
        _stprintf(buf, _T("%s"),
            iStatus == RUNNING ? _T("running") :
        iStatus == PAUSED ? _T("paused") :
        iStatus == STOPPED ? _T("stopped") : _T("unknown"));
        break;

    }

    return buf;
}


HRESULT CRocket::OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect)
{
    IConsoleVerb *pConsoleVerb;

    HRESULT hr = pConsole->QueryConsoleVerb(&pConsoleVerb);
    _ASSERT(SUCCEEDED(hr));

    hr = pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, TRUE);
    hr = pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, TRUE);
    hr = pConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, TRUE);
    hr = pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);

    pConsoleVerb->Release();

    return S_OK;
}

HRESULT CRocket::OnRefresh(IConsole *pConsole)

{
        //Call IConsole::UpdateAllViews to redraw all views
        //owned by the parent scope item

        IDataObject *pDummy = NULL;
        HANDLE handle  = m_pSpaceStation->GetHandle();

        HRESULT hr;

        hr = pConsole->UpdateAllViews(pDummy, (long)handle, UPDATE_SCOPEITEM);
        _ASSERT( S_OK == hr);

        return hr;
}

HRESULT CRocket::OnDelete(IConsole *pConsole)
{

        _ASSERT( NULL != this );

        HRESULT hr = S_OK;

        //Delete the item. The IConsole that is passed into DeleteChild
        //is from the child result item, so we can use it to QI for IResultData
        IResultData *pResultData = NULL;

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        HRESULTITEM childresultitem;

        _ASSERT( NULL != &childresultitem );

        //lparam == this. See CSpaceStation::OnShow
        hr = pResultData->FindItemByLParam( (LPARAM)this, &childresultitem );
        _ASSERT( SUCCEEDED(hr) );

        hr = pResultData->DeleteItem( childresultitem, 0 );
        _ASSERT( SUCCEEDED(hr) );

        pResultData->Release();

        //Now set child's isDeleted member to true so that the parent doesn't try to
        //to insert it again in CSpaceVehicle::OnShow. Admittedly, a hack...
        isDeleted = TRUE;

        return hr;
}

HRESULT CRocket::OnRename(LPOLESTR pszNewName)
{

        HRESULT hr = S_FALSE;

        if (szName) {
        delete [] szName;
        szName = NULL;
    }

    MAKE_TSTRPTR_FROMWIDE(ptrname, pszNewName);
    szName = new _TCHAR[(_tcslen(ptrname) + 1) * sizeof(_TCHAR)];
    _tcscpy(szName, ptrname);

    return hr;
}


HRESULT CRocket::OnUpdateItem(IConsole *pConsole, long item, ITEM_TYPE itemtype)

{
        HRESULT hr = S_FALSE;

        _ASSERT(NULL != this || isDeleted || RESULT == itemtype);

        //redraw the item
        IResultData *pResultData = NULL;

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        HRESULTITEM myhresultitem;
        _ASSERT(NULL != &myhresultitem);

        //lparam == this. See CSpaceStation::OnShow
        hr = pResultData->FindItemByLParam( (LPARAM)this, &myhresultitem );

        if ( FAILED(hr) ) {
                //there is no HRESULTITEM for the item, because
                //the item is not inserted in the current view. Exit gracefully
                hr = S_FALSE;
        } else

        {
                hr = pResultData->UpdateItem( myhresultitem );
                _ASSERT( SUCCEEDED(hr) );
        }

        pResultData->Release();

        return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\extens\compdata.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMPDATA_H_
#define _SAMPCOMPDATA_H_

#include <mmc.h>
#include "DeleBase.h"
#include "StatNode.h"
#include "Comp.h"

class CComponentData : public IComponentData
{
    friend class CComponent;
    
private:
    ULONG				m_cref;
    LPCONSOLE			m_ipConsole;
    LPCONSOLENAMESPACE	m_ipConsoleNameSpace;
    
    CStaticNode     *m_pStaticNode;
    
public:
    CComponentData();
    ~CComponentData();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IComponentData
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
        /* [in] */ LPUNKNOWN pUnknown);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent( 
        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
        /* [in] */ LPDATAOBJECT lpDataObject,
        /* [in] */ MMC_NOTIFY_TYPE event,
        /* [in] */ LPARAM arg,
        /* [in] */ LPARAM param);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
        /* [in] */ MMC_COOKIE cookie,
        /* [in] */ DATA_OBJECT_TYPES type,
        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
        /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
        /* [in] */ LPDATAOBJECT lpDataObjectA,
        /* [in] */ LPDATAOBJECT lpDataObjectB);
};

#endif _SAMPCOMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\space.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SPACE_H
#define _SPACE_H

#include "DeleBase.h"
#include "CompData.h"

class CSpaceStation;
class CComponentData;

class CRocket : public CDelegationBase {
public:
    CRocket(CSpaceStation *pSpaceStation, _TCHAR *szName, int id, LONG lWeight, LONG lHeight, LONG lPayload);
    virtual ~CRocket();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
	BOOL getDeletedStatus() { return isDeleted; }
	void setDeletedStatus(BOOL status) { isDeleted = status; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect);
 	virtual HRESULT OnUpdateItem(IConsole *pConsole, long item, ITEM_TYPE itemtype);
	virtual HRESULT OnDelete(IConsole *pConsole);
	virtual HRESULT OnRefresh(IConsole *pConsole);
    virtual HRESULT OnRename(LPOLESTR pszNewName);
    
private:
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    _TCHAR *szName;
    LONG   lWeight;
    LONG   lHeight;
    LONG   lPayload;
    int    nId;

	friend CSpaceStation;
	CSpaceStation *m_pSpaceStation;

    enum ROCKET_STATUS {RUNNING, PAUSED, STOPPED} iStatus;

	BOOL isDeleted;
};

class CSpaceStation : public CDelegationBase {
public:
    CSpaceStation();
    virtual ~CSpaceStation();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Space Station"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_STATION; }
    
public:
	virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions);
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect);

	virtual HRESULT OnPaste(IConsole *pConsole, CComponentData *pComponentData, CDelegationBase *pPasted);
	virtual HRESULT OnQueryPaste(CDelegationBase *pPasted);
	virtual HRESULT OnUpdateItem(IConsole *pConsole, long item, ITEM_TYPE itemtype);
	virtual HRESULT OnDeleteScopeItem(IConsoleNameSpace *pConsoleNameSpace);


private:
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
	HRESULT Expand(IConsoleNameSpace *pConsoleNameSpace);

    
private:
	enum { NUMBER_OF_CHILDREN = 9, MAX_CHILDREN = 20 };
    CRocket *children[MAX_CHILDREN];
	CComponentData *m_pComponentData;
	int m_cChildSpaceStations;

public:
	int GetCountChildSpaceStations() { return m_cChildSpaceStations; }
	void DecrementCountChildSpaceStations() { m_cChildSpaceStations--; }
};

class CSpaceFolder : public CDelegationBase {
public:
    CSpaceFolder();
    
    virtual ~CSpaceFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Space Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { IDM_NEW_SPACE = 4 };
    
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CSpaceStation *children[NUMBER_OF_CHILDREN];
};

#endif // _SPACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\statnode.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "StatNode.h"

#include "Space.h"
#include "Sky.h"
#include "People.h"
#include "Land.h"
#include "Backgrnd.h"

const GUID CStaticNode::thisGuid = { 0x2974380c, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CStaticNode implementation
//
//
CStaticNode::CStaticNode()
{
    children[0] = new CPeoplePoweredVehicle;
    children[1] = new CLandBasedVehicle;
    children[2] = new CSkyBasedVehicle;
    children[3] = new CSpaceFolder;
    children[4] = new CBackgroundFolder;
}

CStaticNode::~CStaticNode()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }

	if (m_pBMapSm != NULL)
		DeleteObject(m_pBMapSm);

	if (m_pBMapLg != NULL)
		DeleteObject(m_pBMapLg);
}

HRESULT CStaticNode::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;
    
    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT    |
                SDI_CHILDREN;
            
            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];   // The cookie
            sdi.cChildren   = (n == 0 || n == 3);    // Only first and fourth
													 // children have child nodes
             
            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );
            
            _ASSERT( SUCCEEDED(hr) );

		    children[n]->SetHandle((HANDLE)sdi.ID);
        }
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\extens\dataobj.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DataObj.h"
#include "guids.h"
#include "DeleBase.h"

//
// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SZNODETYPE _T("CCF_SZNODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

#define _T_CCF_INTERNAL_SNAPIN _T("{2479DB32-5276-11d2-94F5-00C04FB92EC2}")

    // These are the clipboard formats that we must supply at a minimum.
    // mmc.h actually defined these. We can make up our own to use for
    // other reasons. We don't need any others at this time.
UINT CDataObject::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CDataObject::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CDataObject::s_cfSZNodeType  = RegisterClipboardFormat(_T_CCF_SZNODETYPE);
UINT CDataObject::s_cfSnapinClsid = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);
UINT CDataObject::s_cfInternal    = RegisterClipboardFormat(_T_CCF_INTERNAL_SNAPIN);


CDataObject::CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context)
: m_lCookie(cookie), m_context(context), m_cref(0)
{
}

CDataObject::~CDataObject()
{
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IDataObject *>(this);
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppv = static_cast<IDataObject *>(this);
    
    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CDataObject::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
    
}

/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
// 
HRESULT CDataObject::GetDataHere(
                                 FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure 
                                 STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure  
                                 )
{
    const   CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pStream = NULL;
    
    CDelegationBase *base = GetBaseNodeObject();
    
    HRESULT hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( FAILED(hr) )
        return hr;                       // Minimal error checking
    
    hr = DV_E_FORMATETC;                 // Unknown format

    if (cf == s_cfDisplayName) {
        const _TCHAR *pszName = base->GetDisplayName();

		MAKE_WIDEPTR_FROMTSTR(wszName, pszName);
        
		// get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(pszName);
        ulSizeofName++;                      // Count null character
        ulSizeofName *= sizeof(WCHAR);
        
        hr = pStream->Write(wszName, ulSizeofName, NULL);
    } else if (cf == s_cfNodeType) {
        const GUID *pGUID = (const GUID *)&base->getNodeType();
        
        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfSZNodeType) {
        LPOLESTR szGuid;
        hr = StringFromCLSID(base->getNodeType(), &szGuid);
        
        if (SUCCEEDED(hr)) {
            hr = pStream->Write(szGuid, wcslen(szGuid), NULL);
            CoTaskMemFree(szGuid);
        }
    } else if (cf == s_cfSnapinClsid) {
        const GUID *pGUID = NULL;
        pGUID = &CLSID_CComponentData;
        
        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfInternal) {
        // we are being asked to get our this pointer from the IDataObject interface
        // only our own snap-in objects will know how to do this.
        CDataObject *pThis = this;
        hr = pStream->Write( &pThis, sizeof(CDataObject*), NULL );
    }
    
    pStream->Release();
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Global helper functions to help work with dataobjects and
// clipboard formats


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfInternal clipboard format
// 
CDataObject* GetOurDataObject (
                               LPDATAOBJECT lpDataObject      // [in] IComponent pointer 
                               )
{
    HRESULT       hr      = S_OK;
    CDataObject *pSDO     = NULL;

	// check to see if the data object is a special data object.
	if ( IS_SPECIAL_DATAOBJECT (lpDataObject) )
	{
		//Code for handling a special data object goes here.

		//Note that the MMC SDK samples do not handle
		//special data objects, so we exit if we get one.
		return NULL;
	}
    
    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { CDataObject::s_cfInternal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    
    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(CDataObject *));
    
    if (!stgmedium.hGlobal)	{
        hr = E_OUTOFMEMORY;
    }
    
    if SUCCEEDED(hr)
        // Attempt to get data from the object
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );
    
    // stgmedium now has the data we need 
    if (SUCCEEDED(hr))  {
        pSDO = *(CDataObject **)(stgmedium.hGlobal);
    }
    
    // if we have memory free it
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);
    
    return pSDO;
    
} // end GetOurDataObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\extens\dataobj.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPDATAOBJECT_H_
#define _SAMPDATAOBJECT_H_

#include <mmc.h>
#include "DeleBase.h"

class CDataObject : public IDataObject
{
private:
    ULONG				m_cref;
    MMC_COOKIE			m_lCookie;
    DATA_OBJECT_TYPES   m_context;
    
public:
    CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context);
    ~CDataObject();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // IDataObject methods 
    ///////////////////////////////
    STDMETHODIMP GetDataHere (FORMATETC *pformatetc, STGMEDIUM *pmedium);
    
    // The rest are not implemented
    STDMETHODIMP GetData (LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumFormatEtc (DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };
    
    STDMETHODIMP QueryGetData (LPFORMATETC lpFormatetc) 
    { return E_NOTIMPL; };
    
    STDMETHODIMP GetCanonicalFormatEtc (LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    
    STDMETHODIMP SetData (LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DAdvise (LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DUnadvise (DWORD dwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumDAdvise (LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };
    
    ///////////////////////////////
    // Custom Methods
    ///////////////////////////////
    
    CDelegationBase *GetBaseNodeObject() {
        return (CDelegationBase *)m_lCookie;
    }
    
    DATA_OBJECT_TYPES GetContext() {
        return m_context;
    }
    
public:
    // clipboard formats
    static UINT s_cfSZNodeType;
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
    static UINT s_cfInternal;
    
};

HRESULT ExtractFromDataObject(IDataObject *lpDataObject,UINT cf,ULONG cb,HGLOBAL *phGlobal);
CDataObject* GetOurDataObject(IDataObject *lpDataObject);
BOOL IsMMCMultiSelectDataObject(IDataObject *lpDataObject);

#endif _SAMPDATAOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\statnode.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SNAPINBASE_H
#define _SNAPINBASE_H

#include "DeleBase.h"

class CStaticNode : public CDelegationBase {
public:
    CStaticNode();
    
    virtual ~CStaticNode();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { 
        static _TCHAR szDisplayName[256];
        LoadString(g_hinst, IDS_SNAPINNAME, szDisplayName, sizeof(szDisplayName));
        return szDisplayName; 
    }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_NONE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { NUMBER_OF_CHILDREN = 5 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
    
    // {2974380C-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};



#endif // _SNAPINBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\extens\extend.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _EXTEND_H
#define _EXTEND_H

#include <tchar.h>

struct NODESTRUCT
{
    GUID	GUID;
    _TCHAR	szDescription[256];
};

#endif // _EXTEND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\extens\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>

#ifndef STRINGS_ONLY
	#define IDM_BUTTON1    0x100
	#define IDM_BUTTON2    0x101

	extern HINSTANCE g_hinst;
	extern ULONG g_uObjects;

	#define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
	#define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

	// uncomment the following #define to enable message cracking
	// #define MMC_CRACK_MESSAGES
	void MMCN_Crack(BOOL bComponentData, 
					IDataObject *pDataObject, 
					IComponentData *pCompData,
					IComponent *pComp,
					MMC_NOTIFY_TYPE event, 
					LPARAM arg, 
					LPARAM param);
#endif

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(GetProcessHeap(), 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(GetProcessHeap(), 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given a _TCHAR, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszT;
//  pszT = MyGetTStringRoutine();
//  MAKE_WIDEPTR_FROMSTR(pwsz, pszT);
//  MyUseWideStringRoutine(pwsz);
//  ...
#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPWSTR)__TempBuffer##ptrname.GetBuffer(), tstr); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    lstrcpyW((LPWSTR)ptrname, tstr)
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, ptrname, __l##ptrname)
#endif

//
// similarily for MAKE_TSTRPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
// * 2 for DBCS handling in below length computation
//
#ifdef UNICODE
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPTSTR)__TempBuffer##ptrname.GetBuffer(), widestr); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\extens\land.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Land.h"

const GUID CLandBasedVehicle::thisGuid = { 0x2974380e, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CLandBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\extens\comp.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "DataObj.h"
#include <commctrl.h>        // Needed for button styles...
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "DeleBase.h"
#include "CompData.h"

CComponent::CComponent(CComponentData *parent)
: m_pComponentData(parent), m_cref(0), m_ipConsole(NULL)
{
    OBJECT_CREATED
}

CComponent::~CComponent()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IComponent))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IExtendPropertySheet))
        *ppv = static_cast<IExtendPropertySheet2 *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponent::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponent::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface IComponent
///////////////////////////////
STDMETHODIMP CComponent::Initialize(
                                    /* [in] */ LPCONSOLE lpConsole)
{
    HRESULT hr = S_OK;

    // Save away all the interfaces we'll need.
    // Fail if we can't QI the required interfaces.

    m_ipConsole = lpConsole;
    m_ipConsole->AddRef();

    return hr;
}

STDMETHODIMP CComponent::Notify(
                                /* [in] */ LPDATAOBJECT lpDataObject,
                                /* [in] */ MMC_NOTIFY_TYPE event,
                                /* [in] */ LPARAM arg,
                                /* [in] */ LPARAM param)
{
    MMCN_Crack(FALSE, lpDataObject, NULL, this, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)      {
    case MMCN_SHOW:
        hr = base->OnShow(m_ipConsole, (BOOL)arg, (HSCOPEITEM)param);
        break;

    case MMCN_ADD_IMAGES:
        hr = base->OnAddImages((IImageList *)arg, (HSCOPEITEM)param);
        break;

    case MMCN_SELECT:
        hr = base->OnSelect(m_ipConsole, (BOOL)LOWORD(arg), (BOOL)HIWORD(arg));
        break;

    case MMCN_RENAME:
        hr = base->OnRename((LPOLESTR)param);
        break;
    }

    return hr;
}

STDMETHODIMP CComponent::Destroy(
                                 /* [in] */ MMC_COOKIE cookie)
{
    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}


STDMETHODIMP CComponent::QueryDataObject(
                                         /* [in] */ MMC_COOKIE cookie,
                                         /* [in] */ DATA_OBJECT_TYPES type,
                                         /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pComponentData->m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

STDMETHODIMP CComponent::GetResultViewType(
                                           /* [in] */ MMC_COOKIE cookie,
                                           /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
                                           /* [out] */ long __RPC_FAR *pViewOptions)
{
    CDelegationBase *base = (CDelegationBase *)cookie;

    //
    // Ask for default listview.
    //
    if (base == NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
        *ppViewType = NULL;
    }
    else
        return base->GetResultViewType(ppViewType, pViewOptions);

    return S_OK;
}

STDMETHODIMP CComponent::GetDisplayInfo(
                                        /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem)
{
    HRESULT hr = S_OK;
    CDelegationBase *base = NULL;

    // if they are asking for the RDI_STR we have one of those to give

    if (pResultDataItem->lParam) {
        base = (CDelegationBase *)pResultDataItem->lParam;
        if (pResultDataItem->mask & RDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName(pResultDataItem->nCol);
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pResultDataItem->str = pszW;
        }

        if (pResultDataItem->mask & RDI_IMAGE) {
            pResultDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}


STDMETHODIMP CComponent::CompareObjects(
                                        /* [in] */ LPDATAOBJECT lpDataObjectA,
                                        /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////////
// Interface IExtendPropertySheet2
///////////////////////////////////

//We need to implement IExtendPropertySheet2 methods and
//return S_OK to allow extension snap-ins to extend result item
//by adding their own property pages
HRESULT CComponent::CreatePropertyPages(
                                        /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
                                        /* [in] */ LONG_PTR handle,
                                        /* [in] */ LPDATAOBJECT lpIDataObject)
{
    return S_OK;
}

HRESULT CComponent::QueryPagesFor(
                                  /* [in] */ LPDATAOBJECT lpDataObject)
{
    return S_OK;
}

HRESULT CComponent::GetWatermarks(
                                  /* [in] */ LPDATAOBJECT lpIDataObject,
                                  /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
                                  /* [out] */ HBITMAP __RPC_FAR *lphHeader,
                                  /* [out] */ HPALETTE __RPC_FAR *lphPalette,
                                  /* [out] */ BOOL __RPC_FAR *bStretch)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\extens\comp.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMP_H_
#define _SAMPCOMP_H_

#include <mmc.h>

class CComponent : public IComponent, IExtendPropertySheet2
{
private:
    ULONG				m_cref;
    
    IConsole*		m_ipConsole;
    
    class CComponentData *m_pComponentData;
    
    public:
        CComponent(CComponentData *parent);
        ~CComponent();
        
        ///////////////////////////////
        // Interface IUnknown
        ///////////////////////////////
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        
        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ MMC_COOKIE cookie);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);

            //////////////////////////////////
            // Interface IExtendPropertySheet2
            //////////////////////////////////
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
            /* [in] */ LONG_PTR handle,
            /* [in] */ LPDATAOBJECT lpIDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
            /* [in] */ LPDATAOBJECT lpDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetWatermarks( 
            /* [in] */ LPDATAOBJECT lpIDataObject,
            /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
            /* [out] */ HBITMAP __RPC_FAR *lphHeader,
            /* [out] */ HPALETTE __RPC_FAR *lphPalette,
            /* [out] */ BOOL __RPC_FAR *bStretch);
};

#endif _SAMPCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\extens\basesnap.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <olectl.h>
#include <initguid.h>
#include "guids.h"
#include "basesnap.h"
#include "Comp.h"
#include "CompData.h"
#include "About.h"
#include "Registry.h"
#include "Extend.h"

// our globals
HINSTANCE g_hinst;

// list all nodes that are extendable here
// List the GUID and then the description
// terminate with a NULL, NULL set.
NODESTRUCT g_Nodes[] = {
    { 0x2974380d, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 },
        _T("People-powered Vehicles Node")},
    { 0x29743811, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 },
        _T("Rocket Node")},
    { 0x2974380f, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 },
        _T("Sky-based Vehicle Node")},
    {NULL, NULL}
};


BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    if ((rclsid != CLSID_CComponentData) && (rclsid != CLSID_CSnapinAbout))
        return CLASS_E_CLASSNOTAVAILABLE;
    
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
    // make the factory passing in the creation function for the type of object they want
    if (rclsid == CLSID_CComponentData)
        pFactory = new CClassFactory(CClassFactory::COMPONENT);
    else if (rclsid == CLSID_CSnapinAbout)
        pFactory = new CClassFactory(CClassFactory::ABOUT);
    
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}


CClassFactory::CClassFactory(FACTORY_TYPE factoryType)
: m_cref(0), m_factoryType(factoryType)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    if (COMPONENT == m_factoryType) {
        pObj = new CComponentData();
    } else {
        pObj = new CSnapinAbout();
    }
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    
    if (FAILED(hr))
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{
    HRESULT hr = SELFREG_E_CLASS;
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName));
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, sizeof(szSnapInName));
    
    _TCHAR szAboutName[256];
    
    LoadString(g_hinst, IDS_ABOUTNAME, szAboutName, sizeof(szAboutName));
    
    // register our CoClasses
    hr = RegisterServer(g_hinst, 
        CLSID_CComponentData, 
        szName);
    
    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst, 
        CLSID_CSnapinAbout, 
        szAboutName);
    
    // place the registry information for SnapIns
    if SUCCEEDED(hr)
        hr = RegisterSnapin(CLSID_CComponentData, szSnapInName, CLSID_CSnapinAbout);
    
    return hr;
}


STDAPI DllUnregisterServer()
{
    if (UnregisterServer(CLSID_CComponentData) == S_OK)
        return UnregisterSnapin(CLSID_CComponentData);
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\extens\land.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _LAND_H
#define _LAND_H

#include "DeleBase.h"

class CLandBasedVehicle : public CDelegationBase {
public:
    CLandBasedVehicle() { }
    
    virtual ~CLandBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Land-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_LANDICON; }
    
private:
    enum { IDM_NEW_LAND = 2 };
    
    // {2974380E-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};


#endif // _LAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\extens\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5

#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\extens\mmccrack.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

static TCHAR *MMCN_CrackVerb(MMC_CONSOLE_VERB verb)
{
	static TCHAR error[64];

	switch (verb) {
    case MMC_VERB_NONE:
		return _T("NONE");
    case MMC_VERB_OPEN:
		return _T("OPEN");
    case MMC_VERB_COPY:
		return _T("COPY");
    case MMC_VERB_PASTE:
		return _T("PASTE");
    case MMC_VERB_DELETE:
		return _T("DELETE");
    case MMC_VERB_PROPERTIES:
		return _T("PROPERTIES");
    case MMC_VERB_RENAME:
		return _T("RENAME");
    case MMC_VERB_REFRESH:
		return _T("REFRESH");
    case MMC_VERB_PRINT:
		return _T("PRINT");
    case MMC_VERB_CUT:
		return _T("CUT");
	default:
		wsprintf(error, _T("Unknown verb id %d"), verb);
		return error;
	}
}

void MMCN_Crack(BOOL bComponentData, 
                IDataObject *pDataObject,
				IComponentData *pCompData,
				IComponent *pComp,
                MMC_NOTIFY_TYPE event, 
				LPARAM arg, 
				LPARAM param)
{
#ifdef MMC_CRACK_MESSAGES
	TCHAR message[256] = {0};

	if (bComponentData == TRUE)
		OutputDebugString(_T("IComponentData::Notify( "));
	else
		OutputDebugString(_T("IComponent::Notify( "));

	wsprintf(message, _T("DataObject: %08x, CompData: %08x, Comp: %08x ) - "), pDataObject, pCompData, pComp);
	OutputDebugString(message);

    switch (event)	{
		case MMCN_ACTIVATE:
			wsprintf(message, _T("MMCN_ACTIVATE\n\tActivate: %d\n"), arg);
			break;

		case MMCN_ADD_IMAGES:
			wsprintf(message, _T("MMCN_ADD_IMAGES\n\tImage List: %08x\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_BTN_CLICK:
			wsprintf(message, _T("MMCN_BTN_CLICK\n\tVerb: %ws\n"), MMCN_CrackVerb((MMC_CONSOLE_VERB)param));
			break;

		case MMCN_COLUMN_CLICK:
			wsprintf(message, _T("MMCN_COLUMN_CLICK\n\tColumn: %d\n\tSort Option: %d\n"), arg,	 param);
			break;

		case MMCN_COLUMNS_CHANGED:
			wsprintf(message, _T("MMCN_COLUMNS_CHANGED\n"));
			break;

		case MMCN_CONTEXTHELP:
			wsprintf(message, _T("MMCN_CONTEXTHELP\n"));
			break;

		case MMCN_CONTEXTMENU:
			wsprintf(message, _T("MMCN_CONTEXTMENU\n"));
			break;

		case MMCN_CUTORMOVE:
			wsprintf(message, _T("MMCN_CUTORMOVE\n"));
			break;

		case MMCN_DBLCLICK:
			wsprintf(message, _T("MMCN_DBLCLICK\n"));
			break;

		case MMCN_DELETE:
			wsprintf(message, _T("MMCN_DELETE\n"));
			break;

		case MMCN_DESELECT_ALL:
			wsprintf(message, _T("MMCN_DESELECT_ALL\n"));
			break;

		case MMCN_EXPAND:
			wsprintf(message, _T("MMCN_EXPAND\n\tExpand: %d\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_EXPANDSYNC:
			wsprintf(message, _T("MMCN_EXPANDSYNC\n"));
			break;

		case MMCN_FILTERBTN_CLICK:
			wsprintf(message, _T("MMCN_FILTERBTN_CLICK\n\tColumn: %d\n"), arg);
			break;

		case MMCN_FILTER_CHANGE:
			wsprintf(message, _T("MMCN_FILTER_CHANGE\n\tColumn: %d\n"), param);
			break;

		case MMCN_HELP:
			wsprintf(message, _T("MMCN_HELP\n"));
			break;

		case MMCN_INITOCX:
			wsprintf(message, _T("MMCN_INITOCX\n\tIUnknown: %08x\n"), param);
			break;

		case MMCN_LISTPAD:
			wsprintf(message, _T("MMCN_LISTPAD\n\tConnect: %d\n"), arg);
			break;

		case MMCN_MENU_BTNCLICK:
			wsprintf(message, _T("MMCN_MENU_BTNCLICK\n"));
			break;

		case MMCN_MINIMIZED:
			wsprintf(message, _T("MMCN_MINIMIZED\n\tMinimized: %d\n"), arg);
			break;

		case MMCN_PASTE:
			wsprintf(message, _T("MMCN_PASTE\n\tCopy: %d\n"), param == NULL);
			break;

		case MMCN_PRELOAD:
			wsprintf(message, _T("MMCN_PRELOAD\n\tScope Item: %08x\n"), arg);
			break;

		case MMCN_PRINT:
			wsprintf(message, _T("MMCN_PRINT\n"));
			break;

		case MMCN_PROPERTY_CHANGE:
			wsprintf(message, _T("MMCN_PROPERTY_CHANGE\n\tScope: %d\n\tArg: %08x\n"), arg, param);
			break;

		case MMCN_QUERY_PASTE:
			wsprintf(message, _T("MMCN_QUERY_PASTE\n"));
			break;

		case MMCN_REFRESH:
			wsprintf(message, _T("MMCN_REFRESH\n"));
			break;

		case MMCN_REMOVE_CHILDREN:
			wsprintf(message, _T("MMCN_REMOVE_CHILDREN\n\tScope Item: %08x\n"), arg);
			break;

		case MMCN_RENAME:
			wsprintf(message, _T("MMCN_RENAME\n\tNew Name: '%ws'\n"), (LPOLESTR)param);
			break;

		case MMCN_RESTORE_VIEW:
			wsprintf(message, _T("MMCN_RESTORE_VIEW\n"));
			break;

		case MMCN_SELECT:
			wsprintf(message, _T("MMCN_SELECT\n\tScope: %d\n\tSelect: %08x\n"), LOWORD(arg), HIWORD(arg));
			break;

		case MMCN_SHOW:
			wsprintf(message, _T("MMCN_SHOW\n\tShow: %d\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_SNAPINHELP:
			wsprintf(message, _T("MMCN_SNAPINHELP\n"));
			break;

		case MMCN_VIEW_CHANGE:
			wsprintf(message, _T("MMCN_VIEW_CHANGE\n\tData: %08x\n\tHint: %08x\n"), arg, param);
			break;
	}

	if (message[0] != 0)
		OutputDebugString(message);
	else
		OutputDebugString(_T("unknown event\n"));

#endif
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\extens\delebase.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DeleBase.h"

const GUID CDelegationBase::thisGuid = { 0x2974380b, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

HBITMAP CDelegationBase::m_pBMapSm = NULL;
HBITMAP CDelegationBase::m_pBMapLg = NULL;


//==============================================================
//
// CDelegationBase implementation
//
//
CDelegationBase::CDelegationBase() 
: bExpanded(FALSE) 
{ 
    if (NULL == m_pBMapSm || NULL == m_pBMapLg)
        LoadBitmaps(); 
}

CDelegationBase::~CDelegationBase() 
{ 
}

// CDelegationBase::AddImages sets up the collection of images to be displayed
// by the IComponent in the result pane as a result of its MMCN_SHOW handler
HRESULT CDelegationBase::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi) 
{
    return pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\extens\compdata.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "CompData.h"
#include "DataObj.h"
#include "resource.h"
#include <crtdbg.h>

CComponentData::CComponentData()
: m_cref(0), m_ipConsoleNameSpace(NULL), m_ipConsole(NULL)
{
    OBJECT_CREATED

        m_pStaticNode = new CStaticNode;
}

CComponentData::~CComponentData()
{
    if (m_pStaticNode) {
        delete m_pStaticNode;
    }

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CComponentData::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_IComponentData))
        *ppv = static_cast<IComponentData *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponentData::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponentData::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }

    return m_cref;
}

///////////////////////////////
// Interface IComponentData
///////////////////////////////
HRESULT CComponentData::Initialize(
                                   /* [in] */ LPUNKNOWN pUnknown)
{
    HRESULT      hr;

    //
    // Get pointer to name space interface
    //
    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (void **)&m_ipConsoleNameSpace);
    _ASSERT( S_OK == hr );

    //
    // Get pointer to console interface
    //
    hr = pUnknown->QueryInterface(IID_IConsole, (void **)&m_ipConsole);
    _ASSERT( S_OK == hr );

    IImageList *pImageList;
    m_ipConsole->QueryScopeImageList(&pImageList);
    _ASSERT( S_OK == hr );

    hr = pImageList->ImageListSetStrip( (long *)m_pStaticNode->m_pBMapSm, // pointer to a handle
        (long *)m_pStaticNode->m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );

    pImageList->Release();

    return S_OK;
}

HRESULT CComponentData::CreateComponent(
                                        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent)
{
    *ppComponent = NULL;

    CComponent *pComponent = new CComponent(this);

    if (NULL == pComponent)
        return E_OUTOFMEMORY;

    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent);
}

HRESULT CComponentData::Notify(
                               /* [in] */ LPDATAOBJECT lpDataObject,
                               /* [in] */ MMC_NOTIFY_TYPE event,
                               /* [in] */ LPARAM arg,
                               /* [in] */ LPARAM param)
{
    MMCN_Crack(TRUE, lpDataObject, this, NULL, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)
    {
    case MMCN_EXPAND:
        hr = base->OnExpand(m_ipConsoleNameSpace, m_ipConsole, (HSCOPEITEM)param);
        break;
    }

    return hr;
}

HRESULT CComponentData::Destroy( void)
{
    // Free interfaces
    if (m_ipConsoleNameSpace) {
        m_ipConsoleNameSpace->Release();
        m_ipConsoleNameSpace = NULL;
    }

    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}

HRESULT CComponentData::QueryDataObject(
                                        /* [in] */ MMC_COOKIE cookie,
                                        /* [in] */ DATA_OBJECT_TYPES type,
                                        /* [out] */ LPDATAOBJECT *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

HRESULT CComponentData::GetDisplayInfo(
                                       /* [out][in] */ SCOPEDATAITEM *pScopeDataItem)
{
    HRESULT hr = S_FALSE;

    // if they are asking for the SDI_STR we have one of those to give
    if (pScopeDataItem->lParam) {
        CDelegationBase *base = (CDelegationBase *)pScopeDataItem->lParam;
        if (pScopeDataItem->mask & SDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName();
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pScopeDataItem->displayname = pszW;
        }

        if (pScopeDataItem->mask & SDI_IMAGE) {
            pScopeDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}

HRESULT CComponentData::CompareObjects(
                                       /* [in] */ LPDATAOBJECT lpDataObjectA,
                                       /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\extens\people.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _PEOPLE_H
#define _PEOPLE_H

#include "DeleBase.h"

class CBicycle : public CDelegationBase {
public:
    CBicycle(int i) : id(i) { }
    virtual ~CBicycle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CBicycleFolder : public CDelegationBase {
public:
    CBicycleFolder();
    virtual ~CBicycleFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Bicycles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CSkateboard : public CDelegationBase {
public:
    CSkateboard(int i) : id(i) { }
    virtual ~CSkateboard() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CSkateboardFolder : public CDelegationBase {
public:
    CSkateboardFolder();
    virtual ~CSkateboardFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Skateboards"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CIceSkate : public CDelegationBase {
public:
    CIceSkate(int i) : id(i) { }
    virtual ~CIceSkate() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CIceSkateFolder : public CDelegationBase {
public:
    CIceSkateFolder();
    virtual ~CIceSkateFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Ice Skates"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CPeoplePoweredVehicle : public CDelegationBase {
public:
    CPeoplePoweredVehicle();
    virtual ~CPeoplePoweredVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("People-powered Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { IDM_NEW_PEOPLE = 1 };
    
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 3 };
    CDelegationBase *children[3];
};

#endif // _PEOPLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\extens\registry.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout);		// Class Id for About Class


HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\extens\sky.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Sky.h"

const GUID CSkyBasedVehicle::thisGuid = { 0x2974380f, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSkyBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\extens\delebase.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _BRANCHES_H
#define _BRANCHES_H

#include <mmc.h>
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "LocalRes.h"

class CDelegationBase {
public:
    CDelegationBase();
    virtual ~CDelegationBase();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) = 0;
    virtual const GUID & getNodeType() { _ASSERT(FALSE); return IID_NULL; }
    
    virtual const LPARAM GetCookie() { return reinterpret_cast<LPARAM>(this); }
    virtual const int GetBitmapIndex() = 0;
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions) { return S_FALSE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent) { return S_FALSE; }
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem) { return S_FALSE; }
    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    virtual HRESULT OnRename(LPOLESTR pszNewName) { return S_FALSE; }
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect) { return S_FALSE; }
    
public:
    static HBITMAP m_pBMapSm;
    static HBITMAP m_pBMapLg;
    
protected:
    static void LoadBitmaps() {
        m_pBMapSm = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_SMICONS));
        m_pBMapLg = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_LGICONS));
    }
    
    BOOL bExpanded;
    
private:
    // {2974380B-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _BRANCHES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\extens\guids.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

// {AEA15790-A656-11d2-992F-000000000000}
DEFINE_GUID(CLSID_CComponentData, 
            0xaea15790, 0xa656, 0x11d2, 0x99, 0x2f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);

// {AEA15792-A656-11d2-992F-000000000000}
DEFINE_GUID(CLSID_CSnapinAbout, 
            0xaea15792, 0xa656, 0x11d2, 0x99, 0x2f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\extens\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Resources.rc
//
#define IDS_HELPFILE                    1
#define IDS_SNAPINDESC                  2
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDI_ICON1                       108
#define IDB_SMOPEN                      111
#define IDB_SMBMP                       112
#define IDB_LGBMP                       113
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDB_ROCKET                      40004
#define IDB_CAR                         40005
#define IDB_PLANE                       40006
#define IDB_BIKE                        40007
#define IDB_ROCKET2                     40008
#define IDB_CAR2                        40009
#define IDB_PLANE2                      40010
#define IDB_BIKE2                       40011
#define IDB_CLOSED2                     40012
#define IDB_OPEN2                       40013
#define IDB_CLOSED                      40014
#define IDB_OPEN                        40015

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        115
#define _APS_NEXT_COMMAND_VALUE         40016
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\extens\people.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <stdio.h>
#include "People.h"

const GUID CPeoplePoweredVehicle::thisGuid = { 0x2974380d, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

const GUID CBicycleFolder::thisGuid = { 0xef163732, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboardFolder::thisGuid = { 0xef163733, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkateFolder::thisGuid = { 0xf6c660b0, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };

const GUID CBicycle::thisGuid = { 0xef163734, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboard::thisGuid = { 0xef163735, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkate::thisGuid = { 0xf6c660b1, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };


//==============================================================
//
// CPeoplePoweredVehicle implementation
//
//
CPeoplePoweredVehicle::CPeoplePoweredVehicle() 
{ 
    children[0] = new CBicycleFolder;
    children[1] = new CSkateboardFolder;
    children[2] = new CIceSkateFolder;
}

CPeoplePoweredVehicle::~CPeoplePoweredVehicle() 
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        delete children[n];
}

HRESULT CPeoplePoweredVehicle::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;
    
    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT    |   // relativeID is valid
                SDI_CHILDREN;     // cChildren is valid
            
            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = 0;
            
            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );
            
            _ASSERT( SUCCEEDED(hr) );
        }
    }
    
    return S_OK;
}

CBicycleFolder::CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CBicycle(n + 1);
    }
}

CBicycleFolder::~CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CBicycleFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;
    
    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;
    
    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );
        
        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );
        
        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        
        // insert items here
        RESULTDATAITEM rdi;
        
        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );
        
        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid
                
                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];
                
                hr = pResultData->InsertItem( &rdi );
                
                _ASSERT( SUCCEEDED(hr) );
            }
        }
        
        pHeaderCtrl->Release();
        pResultData->Release();
    }
    
    return hr;
}

CIceSkateFolder::CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CIceSkate(n + 1);
    }
}

CIceSkateFolder::~CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CIceSkateFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;
    
    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;
    
    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );
        
        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );
        
        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        
        // insert items here
        RESULTDATAITEM rdi;
        
        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );
        
        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid
                
                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];
                
                hr = pResultData->InsertItem( &rdi );
                
                _ASSERT( SUCCEEDED(hr) );
            }
        }
        
        pHeaderCtrl->Release();
        pResultData->Release();
    }
    
    return hr;
}

CSkateboardFolder::CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CSkateboard(n + 1);
    }
}

CSkateboardFolder::~CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSkateboardFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;
    
    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;
    
    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );
        
        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );
        
        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                      ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        
        // insert items here
        RESULTDATAITEM rdi;
        
        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );
        
        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid
                
                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];
                
                hr = pResultData->InsertItem( &rdi );
                
                _ASSERT( SUCCEEDED(hr) );
            }
        }
        
        pHeaderCtrl->Release();
        pResultData->Release();
    }
    
    return hr;
}

const _TCHAR *CBicycle::GetDisplayName(int nCol) 
{
    static _TCHAR buf[128];
    
    _stprintf(buf, _T("Bicycle #%d"), id);

    return buf;
}

const _TCHAR *CSkateboard::GetDisplayName(int nCol) 
{
    static _TCHAR buf[128];
    
    _stprintf(buf, _T("Skateboard #%d"), id);

    return buf;
}

const _TCHAR *CIceSkate::GetDisplayName(int nCol) 
{
    static _TCHAR buf[128];
    
    _stprintf(buf, _T("Ice Skate #%d"), id);
    
    return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\extens\sky.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SKY_H
#define _SKY_H

#include "DeleBase.h"

class CSkyBasedVehicle : public CDelegationBase {
public:
    CSkyBasedVehicle() { }
    
    virtual ~CSkyBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Sky-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SKYICON; }
    
private:
    enum { IDM_NEW_SKY = 3 };
    
    // {2974380F-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};


#endif // _SKY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\help\about.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "About.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

CSnapinAbout::CSnapinAbout()
: m_cref(0)
{
    OBJECT_CREATED
        
        m_hSmallImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    m_hLargeImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_LGBMP), IMAGE_BITMAP, 32, 32, LR_LOADTRANSPARENT);
    
    m_hSmallImageOpen = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMOPEN), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    
    m_hAppIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ICON1));
}

CSnapinAbout::~CSnapinAbout()
{
    if (m_hSmallImage != NULL)
        FreeResource(m_hSmallImage);
    
    if (m_hLargeImage != NULL)
        FreeResource(m_hLargeImage);
    
    if (m_hSmallImageOpen != NULL)
        FreeResource(m_hSmallImageOpen);
    
    if (m_hAppIcon != NULL)
        FreeResource(m_hAppIcon);
    
    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;
    
    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CSnapinAbout::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<ISnapinAbout *>(this);
    else if (IsEqualIID(riid, IID_ISnapinAbout))
        *ppv = static_cast<ISnapinAbout *>(this);
    
    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSnapinAbout::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CSnapinAbout::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    return m_cref;
    
}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription( 
                                                /* [out] */ LPOLESTR *lpDescription)
{
    _TCHAR szDesc[MAX_PATH];
    
    LoadString(g_hinst, IDS_SNAPINDESC, szDesc, sizeof(szDesc));
    
    return AllocOleStr(lpDescription, szDesc);
}


STDMETHODIMP CSnapinAbout::GetProvider( 
                                       /* [out] */ LPOLESTR *lpName)
{
    return AllocOleStr(lpName, _T("Copyright  1998 Microsoft Corporation"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinVersion( 
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return AllocOleStr(lpVersion, _T("1.0"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinImage( 
                                          /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;
    
    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}


STDMETHODIMP CSnapinAbout::GetStaticFolderImage( 
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;
    
    *hSmallImageOpen = m_hSmallImageOpen;
    
    *cMask = RGB(0, 128, 128);
    
    if (*hSmallImage == NULL || *hLargeImage == NULL || *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}

// this allocates a chunk of memory using CoTaskMemAlloc and copies our chars into it
HRESULT CSnapinAbout::AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer)
{
	MAKE_WIDEPTR_FROMTSTR_ALLOC(wszStr, szBuffer);
	*lpDest = wszStr;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\extens\registry.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <assert.h>
#include "Extend.h"
#include "Registry.h"

#define STRINGS_ONLY
#include "globals.h"

// we need access to our g_nodes
extern NODESTRUCT g_Nodes[];

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

BOOL setSnapInExtensionNode(const _TCHAR* szSnapID,
                            const _TCHAR* szNodeID,
                            const _TCHAR* szDescription);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName)       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule,
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;

    assert(dwResult != 0) ;

    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    assert(SUCCEEDED(hr)) ;

    MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;
        _tcscat(szKey, pszCLSID) ;

    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;

    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    _tcscat(szKey, _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), _T("Apartment"));

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;


    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;

        MAKE_TSTRPTR_FROMWIDE(pszT, wszCLSID);
        _tcscat(szKey, pszT) ;

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Register the snap-in in the registry.
//
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout)         // Class Id for About Class

{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    LPOLESTR wszAboutCLSID = NULL;
    LPOLESTR wszExtendCLSID = NULL;
    NODESTRUCT *pNode;

    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    if (IID_NULL != clsidAbout)
        hr = StringFromCLSID(clsidAbout, &wszAboutCLSID);

    MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
    MAKE_TSTRPTR_FROMWIDE(pszAboutCLSID, wszAboutCLSID);


    // Add the CLSID to the registry.
    setSnapInKeyAndValue(pszCLSID, NULL, _T("NameString"), szNameString) ;
    setSnapInKeyAndValue(pszCLSID, _T("StandAlone"), NULL, NULL);
    if (IID_NULL != clsidAbout)
        setSnapInKeyAndValue(pszCLSID, NULL, _T("About"), pszAboutCLSID);

    // register each of the node types in g_Nodes as an extendable node
    for (pNode = &(g_Nodes[0]);*pNode->szDescription;pNode++)
    {
        hr = StringFromCLSID(pNode->GUID, &wszExtendCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszExtendCLSID, wszExtendCLSID);
        setSnapInExtensionNode(pszCLSID, pszExtendCLSID, pNode->szDescription);
        CoTaskMemFree(wszExtendCLSID);
    }

    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    if (IID_NULL != clsidAbout)
        CoTaskMemFree(wszAboutCLSID);

    return S_OK ;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    LPOLESTR wszCLSID = NULL;

    // Get CLSID
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\"));
    _tcscat(szKeyBuf, pszCLSID);

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

	//Uncomment following for loop to unregister all extendable node types
	//Note that if a snap-in's extendable node types are unregistered,
	//any extension snap-ins for these node types will have to be re-registered
	//in order to rebuild their entries under the SOFTWARE\Microsoft\MMC\NodeTypes key

/*
    // Unregister each of the node types in g_Nodes as an extendable node

    NODESTRUCT *pNode;
	LPOLESTR wszExtendCLSID = NULL;

    for (pNode = &(g_Nodes[0]);*pNode->szDescription;pNode++)
    {
        hr = StringFromCLSID(pNode->GUID, &wszExtendCLSID);
        // Load the buffer with the Snap-In Location
        MAKE_TSTRPTR_FROMWIDE(pszExtendCLSID, wszExtendCLSID);
        _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\NodeTypes\\"));
        // Copy keyname into buffer.
        _tcscat(szKeyBuf, pszExtendCLSID);
        recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
        CoTaskMemFree(wszExtendCLSID);
    }

*/

    // free the memory
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }

    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }

    // Close the child.
    RegCloseKey(hKeyChild) ;

    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\")) ;
    _tcscat(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

BOOL setSnapInExtensionNode(const _TCHAR* szSnapID,
                            const _TCHAR* szNodeID,
                            const _TCHAR* szDescription)
{
    HKEY hKey;
    _TCHAR szSnapNodeKeyBuf[1024] ;
    _TCHAR szMMCNodeKeyBuf[1024];

    // Load the buffer with the Snap-In Location
    _tcscpy(szSnapNodeKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns\\"));
    // add in the clisid into buffer.
    _tcscat(szSnapNodeKeyBuf, szSnapID) ;
    _tcscat(szSnapNodeKeyBuf, _T("\\NodeTypes\\"));
    _tcscat(szSnapNodeKeyBuf, szNodeID) ;

    // Load the buffer with the NodeTypes Location
    _tcscpy(szMMCNodeKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\NodeTypes\\"));
    _tcscat(szMMCNodeKeyBuf, szNodeID) ;

    // Create and open the Snapin Key.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szSnapNodeKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szDescription != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szDescription,
            (_tcslen(szDescription)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;

    // Create and open the NodeTypes Key.
    lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szMMCNodeKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szDescription != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szDescription,
            (_tcslen(szDescription)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\help\about.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPABOUT_H_
#define _SAMPABOUT_H_

#include <tchar.h>
#include <mmc.h>

class CSnapinAbout : public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;
    
public:
    CSnapinAbout();
    ~CSnapinAbout();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
        /* [out] */ LPOLESTR *lpDescription);
        
        STDMETHODIMP GetProvider( 
        /* [out] */ LPOLESTR *lpName);
        
        STDMETHODIMP GetSnapinVersion( 
        /* [out] */ LPOLESTR *lpVersion);
        
        STDMETHODIMP GetSnapinImage( 
        /* [out] */ HICON *hAppIcon);
        
        STDMETHODIMP GetStaticFolderImage( 
        /* [out] */ HBITMAP *hSmallImage,
        /* [out] */ HBITMAP *hSmallImageOpen,
        /* [out] */ HBITMAP *hLargeImage,
        /* [out] */ COLORREF *cMask);
        
        ///////////////////////////////
        // Private Interface 
        ///////////////////////////////
private:
    HRESULT	CSnapinAbout::AllocOleStr(
        LPOLESTR *lpDest, 
        _TCHAR *szBuffer);
};

#endif _SAMPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\extens\statnode.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "StatNode.h"

#include "Space.h"
#include "Sky.h"
#include "People.h"
#include "Land.h"
#include "Extend.h"

const GUID CStaticNode::thisGuid = { 0x2974380c, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CStaticNode implementation
//
//
CStaticNode::CStaticNode()
{
    children[0] = new CPeoplePoweredVehicle;
    children[1] = new CLandBasedVehicle;
    children[2] = new CSkyBasedVehicle;
    children[3] = new CSpaceVehicle;
}

CStaticNode::~CStaticNode()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CStaticNode::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;
    
    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT	  |
                SDI_CHILDREN;
            
            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];  // The cookie
            sdi.cChildren   = (n == 0 || n == 2);   // Only first and third
													// children have child nodes
            
            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );
            
            _ASSERT( SUCCEEDED(hr) );
        }
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\help\basesnap.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <olectl.h>
#include <initguid.h>
#include "guids.h"
#include "basesnap.h"
#include "Comp.h"
#include "CompData.h"
#include "About.h"
#include "Registry.h"

// our globals
HINSTANCE g_hinst;

BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    if ((rclsid != CLSID_CComponentData) && (rclsid != CLSID_CSnapinAbout))
        return CLASS_E_CLASSNOTAVAILABLE;
    
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
    // make the factory passing in the creation function for the type of object they want
    if (rclsid == CLSID_CComponentData)
        pFactory = new CClassFactory(CClassFactory::COMPONENT);
    else if (rclsid == CLSID_CSnapinAbout)
        pFactory = new CClassFactory(CClassFactory::ABOUT);
    
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}


CClassFactory::CClassFactory(FACTORY_TYPE factoryType)
: m_cref(0), m_factoryType(factoryType)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    if (COMPONENT == m_factoryType) {
        pObj = new CComponentData();
    } else {
        pObj = new CSnapinAbout();
    }
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    
    if (FAILED(hr))
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{
    HRESULT hr = SELFREG_E_CLASS;
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName));
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, sizeof(szSnapInName));
    
    _TCHAR szAboutName[256];
    
    LoadString(g_hinst, IDS_ABOUTNAME, szAboutName, sizeof(szAboutName));
    
    // register our CoClasses
    hr = RegisterServer(g_hinst, 
        CLSID_CComponentData, 
        szName);
    
    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst, 
        CLSID_CSnapinAbout, 
        szAboutName);
    
    // place the registry information for SnapIns
    if SUCCEEDED(hr)
        hr = RegisterSnapin(CLSID_CComponentData, szSnapInName, CLSID_CSnapinAbout, FALSE);
    
    return hr;
}


STDAPI DllUnregisterServer()
{
    if (UnregisterServer(CLSID_CComponentData) == S_OK)
        return UnregisterSnapin(CLSID_CComponentData);
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\help\basesnap.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#ifndef _BASESNAP_H_
#define _BASESNAP_H_

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);
STDAPI DllCanUnloadNow(void);

ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    enum FACTORY_TYPE {COMPONENT = 0, ABOUT = 1};
    
    CClassFactory(FACTORY_TYPE factoryType);
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
private:
    FACTORY_TYPE m_factoryType;
};

#endif _BASESNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\extens\space.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <stdio.h>
#include "Space.h"
#include "Comp.h"

const GUID CSpaceVehicle::thisGuid = { 0x29743810, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };
const GUID CRocket::thisGuid = { 0x29743811, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSpaceVehicle implementation
//
//
CSpaceVehicle::CSpaceVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CRocket(_T("Rocket"), n+1, 500000, 265, 75000);
    }
}

CSpaceVehicle::~CSpaceVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSpaceVehicle::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;
    
    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;
    
    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );
        
        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );
        
        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Rocket Class", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 1, L"Rocket Weight", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 2, L"Rocket Height", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 3, L"Rocket Payload", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 4, L"Status", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        
        // insert items here
        RESULTDATAITEM rdi;
        
        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );
        
        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid
                
                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];
                
                hr = pResultData->InsertItem( &rdi );
                
                _ASSERT( SUCCEEDED(hr) );
            }
        }
        
        pHeaderCtrl->Release();
        pResultData->Release();
    }
    
    return hr;
}

//==============================================================
//
// CRocket implementation
//
//
CRocket::CRocket(_TCHAR *szName, int id, LONG lWeight, LONG lHeight, LONG lPayload) 
: szName(NULL), lWeight(0), lHeight(0), lPayload(0), iStatus(STOPPED)
{ 
    if (szName) {
        this->szName = new _TCHAR[(_tcslen(szName) + 1) * sizeof(_TCHAR)];
        _tcscpy(this->szName, szName);
    }
    
    this->nId = id;
    this->lWeight = lWeight;
    this->lHeight = lHeight;
    this->lPayload = lPayload;
}

CRocket::~CRocket() 
{
    if (szName)
        delete [] szName;
}

const _TCHAR *CRocket::GetDisplayName(int nCol) 
{
    static _TCHAR buf[128];
    
    switch (nCol) {
    case 0:
        _stprintf(buf, _T("%s (#%d)"), szName ? szName : _T(""), nId);
        break;
        
    case 1:
        _stprintf(buf, _T("%ld metric tons"), lWeight);
        break;
        
    case 2:
        _stprintf(buf, _T("%ld meters"), lHeight);
        break;
        
    case 3:
        _stprintf(buf, _T("%ld kilos"), lPayload);
        break;
        
    case 4:
        _stprintf(buf, _T("%s"),
            iStatus == RUNNING ? _T("running") : 
        iStatus == PAUSED ? _T("paused") :
        iStatus == STOPPED ? _T("stopped") : _T("unknown"));
        break;
        
    }
    
    return buf;
}

HRESULT CRocket::OnRename(LPOLESTR pszNewName)
{
    if (szName) {
        delete [] szName;
        szName = NULL;
    }

    
    MAKE_TSTRPTR_FROMWIDE(ptrname, pszNewName);
    szName = new _TCHAR[(_tcslen(ptrname) + 1) * sizeof(_TCHAR)];
    _tcscpy(szName, ptrname);
    
    return S_OK;
}

HRESULT CRocket::OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect)
{
    IConsoleVerb *pConsoleVerb;
    
    HRESULT hr = pConsole->QueryConsoleVerb(&pConsoleVerb);
    _ASSERT(SUCCEEDED(hr));
    
    hr = pConsoleVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, FALSE);
    hr = pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, TRUE);
    
    hr = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, FALSE);
    hr = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
    
    pConsoleVerb->Release();
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\help\dataobj.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DataObj.h"
#include "guids.h"
#include "DeleBase.h"

//
// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SZNODETYPE _T("CCF_SZNODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

#define _T_CCF_INTERNAL_SNAPIN _T("{2479DB32-5276-11d2-94F5-00C04FB92EC2}")

    // These are the clipboard formats that we must supply at a minimum.
    // mmc.h actually defined these. We can make up our own to use for
    // other reasons. We don't need any others at this time.
UINT CDataObject::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CDataObject::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CDataObject::s_cfSZNodeType  = RegisterClipboardFormat(_T_CCF_SZNODETYPE);
UINT CDataObject::s_cfSnapinClsid = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);
UINT CDataObject::s_cfInternal    = RegisterClipboardFormat(_T_CCF_INTERNAL_SNAPIN);


CDataObject::CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context)
: m_lCookie(cookie), m_context(context), m_cref(0)
{
}

CDataObject::~CDataObject()
{
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IDataObject *>(this);
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppv = static_cast<IDataObject *>(this);
    
    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CDataObject::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
    
}

/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
// 
HRESULT CDataObject::GetDataHere(
                                 FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure 
                                 STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure  
                                 )
{
    const   CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pStream = NULL;
    
    CDelegationBase *base = GetBaseNodeObject();
    
    HRESULT hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( FAILED(hr) )
        return hr;                       // Minimal error checking
    
    hr = DV_E_FORMATETC;                 // Unknown format

    if (cf == s_cfDisplayName) {
        const _TCHAR *pszName = base->GetDisplayName();

		MAKE_WIDEPTR_FROMTSTR(wszName, pszName);
        
		// get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(pszName);
        ulSizeofName++;                      // Count null character
        ulSizeofName *= sizeof(WCHAR);
        
        hr = pStream->Write(wszName, ulSizeofName, NULL);
    } else if (cf == s_cfNodeType) {
        const GUID *pGUID = (const GUID *)&base->getNodeType();
        
        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfSZNodeType) {
        LPOLESTR szGuid;
        hr = StringFromCLSID(base->getNodeType(), &szGuid);
        
        if (SUCCEEDED(hr)) {
            hr = pStream->Write(szGuid, wcslen(szGuid), NULL);
            CoTaskMemFree(szGuid);
        }
    } else if (cf == s_cfSnapinClsid) {
        const GUID *pGUID = NULL;
        pGUID = &CLSID_CComponentData;
        
        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfInternal) {
        // we are being asked to get our this pointer from the IDataObject interface
        // only our own snap-in objects will know how to do this.
        CDataObject *pThis = this;
        hr = pStream->Write( &pThis, sizeof(CDataObject*), NULL );
    }
    
    pStream->Release();
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Global helper functions to help work with dataobjects and
// clipboard formats


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfInternal clipboard format
// 
CDataObject* GetOurDataObject (
                               LPDATAOBJECT lpDataObject      // [in] IComponent pointer 
                               )
{
    HRESULT       hr      = S_OK;
    CDataObject *pSDO     = NULL;

	// check to see if the data object is a special data object.
	if ( IS_SPECIAL_DATAOBJECT (lpDataObject) )
	{
		//Code for handling a special data object goes here.

		//Note that the MMC SDK samples do not handle
		//special data objects, so we exit if we get one.
		return NULL;
	}
    
    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { CDataObject::s_cfInternal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    
    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(CDataObject *));
    
    if (!stgmedium.hGlobal)	{
        hr = E_OUTOFMEMORY;
    }
    
    if SUCCEEDED(hr)
        // Attempt to get data from the object
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );
    
    // stgmedium now has the data we need 
    if (SUCCEEDED(hr))  {
        pSDO = *(CDataObject **)(stgmedium.hGlobal);
    }
    
    // if we have memory free it
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);
    
    return pSDO;
    
} // end GetOurDataObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\help\dataobj.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPDATAOBJECT_H_
#define _SAMPDATAOBJECT_H_

#include <mmc.h>
#include "DeleBase.h"

class CDataObject : public IDataObject
{
private:
    ULONG				m_cref;
    MMC_COOKIE			m_lCookie;
    DATA_OBJECT_TYPES   m_context;
    
public:
    CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context);
    ~CDataObject();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // IDataObject methods 
    ///////////////////////////////
    STDMETHODIMP GetDataHere (FORMATETC *pformatetc, STGMEDIUM *pmedium);
    
    // The rest are not implemented
    STDMETHODIMP GetData (LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumFormatEtc (DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };
    
    STDMETHODIMP QueryGetData (LPFORMATETC lpFormatetc) 
    { return E_NOTIMPL; };
    
    STDMETHODIMP GetCanonicalFormatEtc (LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    
    STDMETHODIMP SetData (LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DAdvise (LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DUnadvise (DWORD dwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumDAdvise (LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };
    
    ///////////////////////////////
    // Custom Methods
    ///////////////////////////////
    
    CDelegationBase *GetBaseNodeObject() {
        return (CDelegationBase *)m_lCookie;
    }
    
    DATA_OBJECT_TYPES GetContext() {
        return m_context;
    }
    
public:
    // clipboard formats
    static UINT s_cfSZNodeType;
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
    static UINT s_cfInternal;
    
};

HRESULT ExtractFromDataObject(IDataObject *lpDataObject,UINT cf,ULONG cb,HGLOBAL *phGlobal);
CDataObject* GetOurDataObject(IDataObject *lpDataObject);
BOOL IsMMCMultiSelectDataObject(IDataObject *lpDataObject);

#endif _SAMPDATAOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\help\delebase.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DeleBase.h"

const GUID CDelegationBase::thisGuid = { 0x2974380b, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CDelegationBase implementation
//
//
CDelegationBase::CDelegationBase() 
{ 
    
}

CDelegationBase::~CDelegationBase() 
{ 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\extens\space.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SPACE_H
#define _SPACE_H

#include "DeleBase.h"

class CRocket : public CDelegationBase {
public:
    CRocket(_TCHAR *szName, int id, LONG lWeight, LONG lHeight, LONG lPayload);
    virtual ~CRocket();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnRename(LPOLESTR pszNewName);
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect);
    
private:
    // {29743811-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    _TCHAR *szName;
    LONG   lWeight;
    LONG   lHeight;
    LONG   lPayload;
    int    nId;
    enum {RUNNING, PAUSED, STOPPED} iStatus;
};

class CSpaceVehicle : public CDelegationBase {
public:
    CSpaceVehicle();
    
    virtual ~CSpaceVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Future Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    enum { IDM_NEW_SPACE = 4 };
    
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CRocket *children[NUMBER_OF_CHILDREN];
};

#endif // _SPACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\help\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>

#ifndef STRINGS_ONLY
	#define IDM_BUTTON1    0x100
	#define IDM_BUTTON2    0x101

	extern HINSTANCE g_hinst;
	extern ULONG g_uObjects;

	#define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
	#define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

	// uncomment the following #define to enable message cracking
	// #define MMC_CRACK_MESSAGES
	void MMCN_Crack(BOOL bComponentData, 
					IDataObject *pDataObject, 
					IComponentData *pCompData,
					IComponent *pComp,
					MMC_NOTIFY_TYPE event, 
					LPARAM arg, 
					LPARAM param);
#endif

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(GetProcessHeap(), 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(GetProcessHeap(), 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given a _TCHAR, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszT;
//  pszT = MyGetTStringRoutine();
//  MAKE_WIDEPTR_FROMSTR(pwsz, pszT);
//  MyUseWideStringRoutine(pwsz);
//  ...
#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPWSTR)__TempBuffer##ptrname.GetBuffer(), tstr); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    lstrcpyW((LPWSTR)ptrname, tstr)
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, ptrname, __l##ptrname)
#endif

//
// similarily for MAKE_TSTRPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
// * 2 for DBCS handling in below length computation
//
#ifdef UNICODE
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPTSTR)__TempBuffer##ptrname.GetBuffer(), widestr); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\extens\statnode.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SNAPINBASE_H
#define _SNAPINBASE_H

#include "DeleBase.h"

class CStaticNode : public CDelegationBase {
public:
    CStaticNode();
    
    virtual ~CStaticNode();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { 
        static _TCHAR szDisplayName[256];
        LoadString(g_hinst, IDS_SNAPINNAME, szDisplayName, sizeof(szDisplayName));
        return szDisplayName; 
    }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_NONE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
    
    // {2974380C-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _SNAPINBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\help\mmccrack.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

static TCHAR *MMCN_CrackVerb(MMC_CONSOLE_VERB verb)
{
	static TCHAR error[64];

	switch (verb) {
    case MMC_VERB_NONE:
		return _T("NONE");
    case MMC_VERB_OPEN:
		return _T("OPEN");
    case MMC_VERB_COPY:
		return _T("COPY");
    case MMC_VERB_PASTE:
		return _T("PASTE");
    case MMC_VERB_DELETE:
		return _T("DELETE");
    case MMC_VERB_PROPERTIES:
		return _T("PROPERTIES");
    case MMC_VERB_RENAME:
		return _T("RENAME");
    case MMC_VERB_REFRESH:
		return _T("REFRESH");
    case MMC_VERB_PRINT:
		return _T("PRINT");
    case MMC_VERB_CUT:
		return _T("CUT");
	default:
		wsprintf(error, _T("Unknown verb id %d"), verb);
		return error;
	}
}

void MMCN_Crack(BOOL bComponentData, 
                IDataObject *pDataObject,
				IComponentData *pCompData,
				IComponent *pComp,
                MMC_NOTIFY_TYPE event, 
				LPARAM arg, 
				LPARAM param)
{
#ifdef MMC_CRACK_MESSAGES
	TCHAR message[256] = {0};

	if (bComponentData == TRUE)
		OutputDebugString(_T("IComponentData::Notify( "));
	else
		OutputDebugString(_T("IComponent::Notify( "));

	wsprintf(message, _T("DataObject: %08x, CompData: %08x, Comp: %08x ) - "), pDataObject, pCompData, pComp);
	OutputDebugString(message);

    switch (event)	{
		case MMCN_ACTIVATE:
			wsprintf(message, _T("MMCN_ACTIVATE\n\tActivate: %d\n"), arg);
			break;

		case MMCN_ADD_IMAGES:
			wsprintf(message, _T("MMCN_ADD_IMAGES\n\tImage List: %08x\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_BTN_CLICK:
			wsprintf(message, _T("MMCN_BTN_CLICK\n\tVerb: %ws\n"), MMCN_CrackVerb((MMC_CONSOLE_VERB)param));
			break;

		case MMCN_COLUMN_CLICK:
			wsprintf(message, _T("MMCN_COLUMN_CLICK\n\tColumn: %d\n\tSort Option: %d\n"), arg,	 param);
			break;

		case MMCN_COLUMNS_CHANGED:
			wsprintf(message, _T("MMCN_COLUMNS_CHANGED\n"));
			break;

		case MMCN_CONTEXTHELP:
			wsprintf(message, _T("MMCN_CONTEXTHELP\n"));
			break;

		case MMCN_CONTEXTMENU:
			wsprintf(message, _T("MMCN_CONTEXTMENU\n"));
			break;

		case MMCN_CUTORMOVE:
			wsprintf(message, _T("MMCN_CUTORMOVE\n"));
			break;

		case MMCN_DBLCLICK:
			wsprintf(message, _T("MMCN_DBLCLICK\n"));
			break;

		case MMCN_DELETE:
			wsprintf(message, _T("MMCN_DELETE\n"));
			break;

		case MMCN_DESELECT_ALL:
			wsprintf(message, _T("MMCN_DESELECT_ALL\n"));
			break;

		case MMCN_EXPAND:
			wsprintf(message, _T("MMCN_EXPAND\n\tExpand: %d\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_EXPANDSYNC:
			wsprintf(message, _T("MMCN_EXPANDSYNC\n"));
			break;

		case MMCN_FILTERBTN_CLICK:
			wsprintf(message, _T("MMCN_FILTERBTN_CLICK\n\tColumn: %d\n"), arg);
			break;

		case MMCN_FILTER_CHANGE:
			wsprintf(message, _T("MMCN_FILTER_CHANGE\n\tColumn: %d\n"), param);
			break;

		case MMCN_HELP:
			wsprintf(message, _T("MMCN_HELP\n"));
			break;

		case MMCN_INITOCX:
			wsprintf(message, _T("MMCN_INITOCX\n\tIUnknown: %08x\n"), param);
			break;

		case MMCN_LISTPAD:
			wsprintf(message, _T("MMCN_LISTPAD\n\tConnect: %d\n"), arg);
			break;

		case MMCN_MENU_BTNCLICK:
			wsprintf(message, _T("MMCN_MENU_BTNCLICK\n"));
			break;

		case MMCN_MINIMIZED:
			wsprintf(message, _T("MMCN_MINIMIZED\n\tMinimized: %d\n"), arg);
			break;

		case MMCN_PASTE:
			wsprintf(message, _T("MMCN_PASTE\n\tCopy: %d\n"), param == NULL);
			break;

		case MMCN_PRELOAD:
			wsprintf(message, _T("MMCN_PRELOAD\n\tScope Item: %08x\n"), arg);
			break;

		case MMCN_PRINT:
			wsprintf(message, _T("MMCN_PRINT\n"));
			break;

		case MMCN_PROPERTY_CHANGE:
			wsprintf(message, _T("MMCN_PROPERTY_CHANGE\n\tScope: %d\n\tArg: %08x\n"), arg, param);
			break;

		case MMCN_QUERY_PASTE:
			wsprintf(message, _T("MMCN_QUERY_PASTE\n"));
			break;

		case MMCN_REFRESH:
			wsprintf(message, _T("MMCN_REFRESH\n"));
			break;

		case MMCN_REMOVE_CHILDREN:
			wsprintf(message, _T("MMCN_REMOVE_CHILDREN\n\tScope Item: %08x\n"), arg);
			break;

		case MMCN_RENAME:
			wsprintf(message, _T("MMCN_RENAME\n\tNew Name: '%ws'\n"), (LPOLESTR)param);
			break;

		case MMCN_RESTORE_VIEW:
			wsprintf(message, _T("MMCN_RESTORE_VIEW\n"));
			break;

		case MMCN_SELECT:
			wsprintf(message, _T("MMCN_SELECT\n\tScope: %d\n\tSelect: %08x\n"), LOWORD(arg), HIWORD(arg));
			break;

		case MMCN_SHOW:
			wsprintf(message, _T("MMCN_SHOW\n\tShow: %d\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_SNAPINHELP:
			wsprintf(message, _T("MMCN_SNAPINHELP\n"));
			break;

		case MMCN_VIEW_CHANGE:
			wsprintf(message, _T("MMCN_VIEW_CHANGE\n\tData: %08x\n\tHint: %08x\n"), arg, param);
			break;
	}

	if (message[0] != 0)
		OutputDebugString(message);
	else
		OutputDebugString(_T("unknown event\n"));

#endif
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\help\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5

#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\help\comp.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMP_H_
#define _SAMPCOMP_H_

#include <mmc.h>

class CComponent : public IComponent
{
private:
    ULONG				m_cref;
    
    IConsole*		m_ipConsole;
    IDisplayHelp*	m_ipDisplayHelp;
    
    class CComponentData *m_pComponentData;
    
    public:
        CComponent(CComponentData *parent);
        ~CComponent();
        
        ///////////////////////////////
        // Interface IUnknown
        ///////////////////////////////
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        
        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ MMC_COOKIE cookie);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);
};

#endif _SAMPCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\help\comp.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "DataObj.h"
#include <commctrl.h>        // Needed for button styles...
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "DeleBase.h"
#include "CompData.h"

CComponent::CComponent(CComponentData *parent)
: m_pComponentData(parent), m_cref(0), m_ipConsole(NULL), m_ipDisplayHelp(NULL)
{
    OBJECT_CREATED
}

CComponent::~CComponent()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IComponent))
        *ppv = static_cast<IComponent *>(this);
    
    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponent::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponent::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
    
}

///////////////////////////////
// Interface IComponent
///////////////////////////////
STDMETHODIMP CComponent::Initialize( 
                                    /* [in] */ LPCONSOLE lpConsole)
{
    HRESULT hr = S_OK;
    
    // Save away all the interfaces we'll need.
    // Fail if we can't QI the required interfaces.
    
    m_ipConsole = lpConsole;
    m_ipConsole->AddRef();
    
    hr = m_ipConsole->QueryInterface(IID_IDisplayHelp, (void **)&m_ipDisplayHelp);
    
    return hr;
}

STDMETHODIMP CComponent::Notify( 
                                /* [in] */ LPDATAOBJECT lpDataObject,
                                /* [in] */ MMC_NOTIFY_TYPE event,
                                /* [in] */ LPARAM arg,
                                /* [in] */ LPARAM param)
{
    MMCN_Crack(FALSE, lpDataObject, NULL, this, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();
    
    switch (event)	{
    case MMCN_CONTEXTHELP:
        hr = base->OnShowContextHelp(m_ipDisplayHelp, m_pComponentData->m_HelpFile);
        break;
    }
    
    return hr;
}

STDMETHODIMP CComponent::Destroy( 
                                 /* [in] */ MMC_COOKIE cookie)
{
    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }
    
    if (m_ipDisplayHelp) {
        m_ipDisplayHelp->Release();
        m_ipDisplayHelp = NULL;
    }
    
    return S_OK;
}


STDMETHODIMP CComponent::QueryDataObject( 
                                         /* [in] */ MMC_COOKIE cookie,
                                         /* [in] */ DATA_OBJECT_TYPES type,
                                         /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject)
{
    CDataObject *pObj = NULL;
    
    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pComponentData->m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);
    
    return S_OK;
}

STDMETHODIMP CComponent::GetResultViewType( 
                                           /* [in] */ MMC_COOKIE cookie,
                                           /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
                                           /* [out] */ long __RPC_FAR *pViewOptions)
{
    CDelegationBase *base = (CDelegationBase *)cookie;
    
    //
    // Ask for default listview.
    //
    if (base == NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
        *ppViewType = NULL;
    }
    else
        return base->GetResultViewType(ppViewType, pViewOptions);
    
    return S_OK;
}

STDMETHODIMP CComponent::GetDisplayInfo( 
                                        /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem)
{
    HRESULT hr = S_OK;
    CDelegationBase *base = NULL;

    // if they are asking for the RDI_STR we have one of those to give

    if (pResultDataItem->lParam) {
        base = (CDelegationBase *)pResultDataItem->lParam;
        if (pResultDataItem->mask & RDI_STR) {
			LPCTSTR pszT = base->GetDisplayName(pResultDataItem->nCol);
			MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pResultDataItem->str = pszW;
        }

        if (pResultDataItem->mask & RDI_IMAGE) {
            pResultDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}


STDMETHODIMP CComponent::CompareObjects( 
                                        /* [in] */ LPDATAOBJECT lpDataObjectA,
                                        /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();
    
    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;
    
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\help\compdata.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "CompData.h"
#include "DataObj.h"
#include "resource.h"
#include <crtdbg.h>

CComponentData::CComponentData()
: m_cref(0), m_ipConsoleNameSpace(NULL), m_ipConsole(NULL)
{
    OBJECT_CREATED
        
    m_pStaticNode = new CStaticNode;

    TCHAR tmpHelpFile[MAX_PATH];

    GetWindowsDirectory(tmpHelpFile, sizeof(tmpHelpFile));
    _tcscat(tmpHelpFile, _T("\\HELP\\"));
    LoadString(g_hinst, IDS_HELPFILE, &tmpHelpFile[_tcslen(tmpHelpFile)], MAX_PATH - _tcslen(tmpHelpFile));

	MAKE_WIDEPTR_FROMTSTR(wszHelpFile, tmpHelpFile);
	wcscpy(m_HelpFile, wszHelpFile);
}

CComponentData::~CComponentData()
{
    if (m_pStaticNode) {
        delete m_pStaticNode;
    }
    
    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CComponentData::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_IComponentData))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_ISnapinHelp2))
        *ppv = static_cast<ISnapinHelp2*>(this);
    
    if (*ppv) 
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponentData::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponentData::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    
    return m_cref;
}

///////////////////////////////
// Interface IComponentData
///////////////////////////////
HRESULT CComponentData::Initialize( 
                                   /* [in] */ LPUNKNOWN pUnknown)
{
    HRESULT      hr;
    
    //
    // Get pointer to name space interface
    //
    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (void **)&m_ipConsoleNameSpace);
    _ASSERT( S_OK == hr );
    
    //
    // Get pointer to console interface
    //
    hr = pUnknown->QueryInterface(IID_IConsole, (void **)&m_ipConsole);
    _ASSERT( S_OK == hr );
    
    return S_OK;
}

HRESULT CComponentData::CreateComponent( 
                                        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent) 
{
    *ppComponent = NULL;
    
    CComponent *pComponent = new CComponent(this);
    
    if (NULL == pComponent)
        return E_OUTOFMEMORY;
    
    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent);
}

HRESULT CComponentData::Notify( 
                               /* [in] */ LPDATAOBJECT lpDataObject,
                               /* [in] */ MMC_NOTIFY_TYPE event,
                               /* [in] */ LPARAM arg,
                               /* [in] */ LPARAM param)
{
	MMCN_Crack(TRUE, lpDataObject, this, NULL, event, arg, param);

    return S_FALSE;
}

HRESULT CComponentData::Destroy( void)
{
    // Free interfaces
    if (m_ipConsoleNameSpace) {
        m_ipConsoleNameSpace->Release();
        m_ipConsoleNameSpace = NULL;
    }
    
    if (m_ipConsole) {
        m_ipConsole->Release(); 
        m_ipConsole = NULL;
    }
    
    return S_OK;
}

HRESULT CComponentData::QueryDataObject( 
                                        /* [in] */ MMC_COOKIE cookie,
                                        /* [in] */ DATA_OBJECT_TYPES type,
                                        /* [out] */ LPDATAOBJECT *ppDataObject) 
{
    CDataObject *pObj = NULL;
    
    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);
    
    return S_OK;
}

HRESULT CComponentData::GetDisplayInfo( 
                                       /* [out][in] */ SCOPEDATAITEM *pScopeDataItem)
{
    HRESULT hr = S_FALSE;
    
    // if they are asking for the SDI_STR we have one of those to give
    if (pScopeDataItem->lParam) {
        CDelegationBase *base = (CDelegationBase *)pScopeDataItem->lParam;
        if (pScopeDataItem->mask & SDI_STR) {
			LPCTSTR pszT = base->GetDisplayName();
			MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pScopeDataItem->displayname = pszW;
        }

        if (pScopeDataItem->mask & SDI_IMAGE) {
            pScopeDataItem->nImage = base->GetBitmapIndex();
        }
    }
    
    return hr;
}

HRESULT CComponentData::CompareObjects( 
                                       /* [in] */ LPDATAOBJECT lpDataObjectA,
                                       /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();
    
    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;
    
    return S_FALSE;
}

///////////////////////////////
// Interface ISnapinHelp
///////////////////////////////
HRESULT CComponentData::GetHelpTopic( 
                                     /* [out] */ LPOLESTR *lpCompiledHelpFile)
{
    *lpCompiledHelpFile = static_cast<LPOLESTR>(CoTaskMemAlloc((wcslen(m_HelpFile) + 1) * sizeof(WCHAR)));
    
    wcscpy(*lpCompiledHelpFile, m_HelpFile);
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\help\registry.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions = FALSE);

HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\help\compdata.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMPDATA_H_
#define _SAMPCOMPDATA_H_

#include <mmc.h>
#include "DeleBase.h"
#include "StatNode.h"
#include "Comp.h"

class CComponentData : public IComponentData, ISnapinHelp2
{
    friend class CComponent;
    
private:
    ULONG				m_cref;
    LPCONSOLE			m_ipConsole;
    LPCONSOLENAMESPACE	m_ipConsoleNameSpace;
    
    CStaticNode     *m_pStaticNode;
    
    WCHAR            m_HelpFile[MAX_PATH];
    
public:
    CComponentData();
    ~CComponentData();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IComponentData
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
        /* [in] */ LPUNKNOWN pUnknown);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent( 
        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
        /* [in] */ LPDATAOBJECT lpDataObject,
        /* [in] */ MMC_NOTIFY_TYPE event,
        /* [in] */ LPARAM arg,
        /* [in] */ LPARAM param);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
        /* [in] */ MMC_COOKIE cookie,
        /* [in] */ DATA_OBJECT_TYPES type,
        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
        /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
        /* [in] */ LPDATAOBJECT lpDataObjectA,
        /* [in] */ LPDATAOBJECT lpDataObjectB);
        
        ///////////////////////////////
        // Interface ISnapinHelp2
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetHelpTopic( 
        /* [out] */ LPOLESTR __RPC_FAR *lpCompiledHelpFile);

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetLinkedTopics( 
		/* [out] */ LPOLESTR __RPC_FAR *lpCompiledHelpFiles) { return S_FALSE; }
};

#endif _SAMPCOMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\help\delebase.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _BRANCHES_H
#define _BRANCHES_H

#include <mmc.h>
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "LocalRes.h"

class CDelegationBase {
public:
    CDelegationBase();
    virtual ~CDelegationBase();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) = 0;
    virtual const GUID & getNodeType() { _ASSERT(FALSE); return IID_NULL; }
    
    virtual const LPARAM GetCookie() { return reinterpret_cast<LPARAM>(this); }
    virtual const int GetBitmapIndex() = 0;
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions) { return S_FALSE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShowContextHelp(IDisplayHelp *m_ipDisplayHelp, LPOLESTR helpFile) { return S_FALSE; }
    
private:
    // {2974380B-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _BRANCHES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\menubtn\about.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "About.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

CSnapinAbout::CSnapinAbout()
: m_cref(0)
{
    OBJECT_CREATED
        
        m_hSmallImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    m_hLargeImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_LGBMP), IMAGE_BITMAP, 32, 32, LR_LOADTRANSPARENT);
    
    m_hSmallImageOpen = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMOPEN), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    
    m_hAppIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ICON1));
}

CSnapinAbout::~CSnapinAbout()
{
    if (m_hSmallImage != NULL)
        FreeResource(m_hSmallImage);
    
    if (m_hLargeImage != NULL)
        FreeResource(m_hLargeImage);
    
    if (m_hSmallImageOpen != NULL)
        FreeResource(m_hSmallImageOpen);
    
    if (m_hAppIcon != NULL)
        FreeResource(m_hAppIcon);
    
    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;
    
    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CSnapinAbout::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<ISnapinAbout *>(this);
    else if (IsEqualIID(riid, IID_ISnapinAbout))
        *ppv = static_cast<ISnapinAbout *>(this);
    
    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSnapinAbout::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CSnapinAbout::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    return m_cref;
    
}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription( 
                                                /* [out] */ LPOLESTR *lpDescription)
{
    _TCHAR szDesc[MAX_PATH];
    
    LoadString(g_hinst, IDS_SNAPINDESC, szDesc, sizeof(szDesc));
    
    return AllocOleStr(lpDescription, szDesc);
}


STDMETHODIMP CSnapinAbout::GetProvider( 
                                       /* [out] */ LPOLESTR *lpName)
{
    return AllocOleStr(lpName, _T("Copyright  1998 Microsoft Corporation"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinVersion( 
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return AllocOleStr(lpVersion, _T("1.0"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinImage( 
                                          /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;
    
    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}


STDMETHODIMP CSnapinAbout::GetStaticFolderImage( 
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;
    
    *hSmallImageOpen = m_hSmallImageOpen;
    
    *cMask = RGB(0, 128, 128);
    
    if (*hSmallImage == NULL || *hLargeImage == NULL || *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}

// this allocates a chunk of memory using CoTaskMemAlloc and copies our chars into it
HRESULT CSnapinAbout::AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer)
{
	MAKE_WIDEPTR_FROMTSTR_ALLOC(wszStr, szBuffer);
	*lpDest = wszStr;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\menubtn\basesnap.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <olectl.h>
#include <initguid.h>
#include "guids.h"
#include "basesnap.h"
#include "Comp.h"
#include "CompData.h"
#include "About.h"
#include "Registry.h"

// our globals
HINSTANCE g_hinst;

BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    if ((rclsid != CLSID_CComponentData) && (rclsid != CLSID_CSnapinAbout))
        return CLASS_E_CLASSNOTAVAILABLE;
    
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
    // make the factory passing in the creation function for the type of object they want
    if (rclsid == CLSID_CComponentData)
        pFactory = new CClassFactory(CClassFactory::COMPONENT);
    else if (rclsid == CLSID_CSnapinAbout)
        pFactory = new CClassFactory(CClassFactory::ABOUT);
    
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}


CClassFactory::CClassFactory(FACTORY_TYPE factoryType)
: m_cref(0), m_factoryType(factoryType)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    if (COMPONENT == m_factoryType) {
        pObj = new CComponentData();
    } else {
        pObj = new CSnapinAbout();
    }
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    
    if (FAILED(hr))
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{
    HRESULT hr = SELFREG_E_CLASS;
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName));
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, sizeof(szSnapInName));
    
    _TCHAR szAboutName[256];
    
    LoadString(g_hinst, IDS_ABOUTNAME, szAboutName, sizeof(szAboutName));
    
    // register our CoClasses
    hr = RegisterServer(g_hinst, 
        CLSID_CComponentData, 
        szName);
    
    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst, 
        CLSID_CSnapinAbout, 
        szAboutName);
    
    // place the registry information for SnapIns
    if SUCCEEDED(hr)
        hr = RegisterSnapin(CLSID_CComponentData, szSnapInName, CLSID_CSnapinAbout, FALSE);
    
    return hr;
}


STDAPI DllUnregisterServer()
{
    if (UnregisterServer(CLSID_CComponentData) == S_OK)
        return UnregisterSnapin(CLSID_CComponentData);
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\menubtn\about.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPABOUT_H_
#define _SAMPABOUT_H_

#include <tchar.h>
#include <mmc.h>

class CSnapinAbout : public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;
    
public:
    CSnapinAbout();
    ~CSnapinAbout();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
        /* [out] */ LPOLESTR *lpDescription);
        
        STDMETHODIMP GetProvider( 
        /* [out] */ LPOLESTR *lpName);
        
        STDMETHODIMP GetSnapinVersion( 
        /* [out] */ LPOLESTR *lpVersion);
        
        STDMETHODIMP GetSnapinImage( 
        /* [out] */ HICON *hAppIcon);
        
        STDMETHODIMP GetStaticFolderImage( 
        /* [out] */ HBITMAP *hSmallImage,
        /* [out] */ HBITMAP *hSmallImageOpen,
        /* [out] */ HBITMAP *hLargeImage,
        /* [out] */ COLORREF *cMask);
        
        ///////////////////////////////
        // Private Interface 
        ///////////////////////////////
private:
    HRESULT	CSnapinAbout::AllocOleStr(
        LPOLESTR *lpDest, 
        _TCHAR *szBuffer);
};

#endif _SAMPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\help\guids.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

// {1390C842-88B8-11d2-8A08-000021473128}
DEFINE_GUID(CLSID_CComponentData, 
            0x1390c842, 0x88b8, 0x11d2, 0x8a, 0x8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28);

// {1390C844-88B8-11d2-8A08-000021473128}
DEFINE_GUID(CLSID_CSnapinAbout, 
            0x1390c844, 0x88b8, 0x11d2, 0x8a, 0x8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\menubtn\basesnap.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#ifndef _BASESNAP_H_
#define _BASESNAP_H_

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);
STDAPI DllCanUnloadNow(void);

ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    enum FACTORY_TYPE {COMPONENT = 0, ABOUT = 1};
    
    CClassFactory(FACTORY_TYPE factoryType);
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
private:
    FACTORY_TYPE m_factoryType;
};

#endif _BASESNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\help\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Resources.rc
//
#define IDS_HELPFILE                    1
#define IDS_SNAPINDESC                  2
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDI_ICON1                       108
#define IDB_SMOPEN                      111
#define IDB_SMBMP                       112
#define IDB_LGBMP                       113
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDB_ROCKET                      40004
#define IDB_CAR                         40005
#define IDB_PLANE                       40006
#define IDB_BIKE                        40007
#define IDB_ROCKET2                     40008
#define IDB_CAR2                        40009
#define IDB_PLANE2                      40010
#define IDB_BIKE2                       40011
#define IDB_CLOSED2                     40012
#define IDB_OPEN2                       40013
#define IDB_CLOSED                      40014
#define IDB_OPEN                        40015

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        114
#define _APS_NEXT_COMMAND_VALUE         40016
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\help\statnode.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "StatNode.h"

const GUID CStaticNode::thisGuid = { 0x2974380c, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CStaticNode implementation
//
//
CStaticNode::CStaticNode()
{
}

CStaticNode::~CStaticNode()
{
}

HRESULT CStaticNode::OnShowContextHelp(IDisplayHelp *pDisplayHelp, LPOLESTR helpFile)
{
    WCHAR topicName[MAX_PATH];
    
    wcscpy(topicName, helpFile);
    
    // we should read this from a resource file
    wcscat(topicName, L"::/default.htm");
    
    LPOLESTR pszTopic = static_cast<LPOLESTR>(CoTaskMemAlloc((wcslen(topicName) + 1) * sizeof(WCHAR)));
    
    wcscpy(pszTopic, topicName);
    
    return pDisplayHelp->ShowTopic(pszTopic);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\help\help source\mmcsample.h ===
//
// MMCSample.h
//
//   Contains header information for HTML API calls
//  so that our sample MMC snap-ins can find help information
//
#define HELP_STEPONE    101
#define HELP_STEPTWO    102
#define HELP_STEPTHREE  103
#define HELP_STEPFOUR   104

#define HELP_DEFAULT    0
#define HELP_INTRO      1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\help\statnode.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SNAPINBASE_H
#define _SNAPINBASE_H

#include "DeleBase.h"

class CStaticNode : public CDelegationBase {
public:
    CStaticNode();
    
    virtual ~CStaticNode();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { 
        static _TCHAR szDisplayName[256];
        LoadString(g_hinst, IDS_SNAPINNAME, szDisplayName, sizeof(szDisplayName));
        return szDisplayName; 
    }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_NONE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShowContextHelp(IDisplayHelp *m_ipDisplayHelp, LPOLESTR helpFile);
    
private:
    // {2974380C-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _SNAPINBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\menubtn\dataobj.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DataObj.h"
#include "guids.h"
#include "DeleBase.h"

//
// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SZNODETYPE _T("CCF_SZNODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

#define _T_CCF_INTERNAL_SNAPIN _T("{2479DB32-5276-11d2-94F5-00C04FB92EC2}")

    // These are the clipboard formats that we must supply at a minimum.
    // mmc.h actually defined these. We can make up our own to use for
    // other reasons. We don't need any others at this time.
UINT CDataObject::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CDataObject::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CDataObject::s_cfSZNodeType  = RegisterClipboardFormat(_T_CCF_SZNODETYPE);
UINT CDataObject::s_cfSnapinClsid = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);
UINT CDataObject::s_cfInternal    = RegisterClipboardFormat(_T_CCF_INTERNAL_SNAPIN);


CDataObject::CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context)
: m_lCookie(cookie), m_context(context), m_cref(0)
{
}

CDataObject::~CDataObject()
{
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IDataObject *>(this);
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppv = static_cast<IDataObject *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CDataObject::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
//
HRESULT CDataObject::GetDataHere(
                                 FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure
                                 STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure
                                 )
{
    const   CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pStream = NULL;

    CDelegationBase *base = GetBaseNodeObject();

    HRESULT hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( FAILED(hr) )
        return hr;                       // Minimal error checking

    hr = DV_E_FORMATETC;                 // Unknown format

    if (cf == s_cfDisplayName) {
        const _TCHAR *pszName = base->GetDisplayName();

                MAKE_WIDEPTR_FROMTSTR(wszName, pszName);

                // get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(pszName);
        ulSizeofName++;                      // Count null character
        ulSizeofName *= sizeof(WCHAR);

        hr = pStream->Write(wszName, ulSizeofName, NULL);
    } else if (cf == s_cfNodeType) {
        const GUID *pGUID = (const GUID *)&base->getNodeType();

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfSZNodeType) {
        LPOLESTR szGuid;
        hr = StringFromCLSID(base->getNodeType(), &szGuid);

        if (SUCCEEDED(hr)) {
            hr = pStream->Write(szGuid, wcslen(szGuid), NULL);
            CoTaskMemFree(szGuid);
        }
    } else if (cf == s_cfSnapinClsid) {
        const GUID *pGUID = NULL;
        pGUID = &CLSID_CComponentData;

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfInternal) {
        // we are being asked to get our this pointer from the IDataObject interface
        // only our own snap-in objects will know how to do this.
        CDataObject *pThis = this;
        hr = pStream->Write( &pThis, sizeof(CDataObject*), NULL );
    }

    pStream->Release();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Global helper functions to help work with dataobjects and
// clipboard formats


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfInternal clipboard format
//
CDataObject* GetOurDataObject (
                               LPDATAOBJECT lpDataObject      // [in] IComponent pointer
                               )
{
    HRESULT       hr      = S_OK;
    CDataObject *pSDO     = NULL;

	// check to see if the data object is a special data object.
	if ( IS_SPECIAL_DATAOBJECT (lpDataObject) )
	{
		//Code for handling a special data object goes here.

		//Note that the MMC SDK samples do not handle
		//special data objects, so we exit if we get one.
		return NULL;
	}

    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { CDataObject::s_cfInternal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(CDataObject *));

    if (!stgmedium.hGlobal)     {
        hr = E_OUTOFMEMORY;
    }

    if SUCCEEDED(hr)
        // Attempt to get data from the object
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );

    // stgmedium now has the data we need
    if (SUCCEEDED(hr))  {
        pSDO = *(CDataObject **)(stgmedium.hGlobal);
    }

    // if we have memory free it
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);

    return pSDO;

} // end GetOurDataObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\menubtn\dataobj.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPDATAOBJECT_H_
#define _SAMPDATAOBJECT_H_

#include <mmc.h>
#include "DeleBase.h"

class CDataObject : public IDataObject
{
private:
    ULONG				m_cref;
    MMC_COOKIE			m_lCookie;
    DATA_OBJECT_TYPES   m_context;
    
public:
    CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context);
    ~CDataObject();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // IDataObject methods 
    ///////////////////////////////
    STDMETHODIMP GetDataHere (FORMATETC *pformatetc, STGMEDIUM *pmedium);
    
    // The rest are not implemented
    STDMETHODIMP GetData (LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumFormatEtc (DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };
    
    STDMETHODIMP QueryGetData (LPFORMATETC lpFormatetc) 
    { return E_NOTIMPL; };
    
    STDMETHODIMP GetCanonicalFormatEtc (LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    
    STDMETHODIMP SetData (LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DAdvise (LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DUnadvise (DWORD dwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumDAdvise (LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };
    
    ///////////////////////////////
    // Custom Methods
    ///////////////////////////////
    
    CDelegationBase *GetBaseNodeObject() {
        return (CDelegationBase *)m_lCookie;
    }
    
    DATA_OBJECT_TYPES GetContext() {
        return m_context;
    }
    
public:
    // clipboard formats
    static UINT s_cfSZNodeType;
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
    static UINT s_cfInternal;
    
};

HRESULT ExtractFromDataObject(IDataObject *lpDataObject,UINT cf,ULONG cb,HGLOBAL *phGlobal);
CDataObject* GetOurDataObject(IDataObject *lpDataObject);
BOOL IsMMCMultiSelectDataObject(IDataObject *lpDataObject);

#endif _SAMPDATAOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\help\registry.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

#define STRINGS_ONLY
#include "globals.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName)       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule, 
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;
    
    assert(dwResult != 0) ;
    
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    assert(SUCCEEDED(hr)) ;

	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;
	_tcscat(szKey, pszCLSID) ;
    
    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;
    
    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    _tcscat(szKey, _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), _T("Apartment"));
    
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    
    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    
    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;

	MAKE_TSTRPTR_FROMWIDE(pszT, wszCLSID);
	_tcscat(szKey, pszT) ;
    
    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.
    
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    
    return S_OK ;
}

//
// Register the snap-in in the registry.
//
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions)
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    LPOLESTR wszAboutCLSID = NULL;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    if (IID_NULL != clsidAbout)
        hr = StringFromCLSID(clsidAbout, &wszAboutCLSID);

	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
	MAKE_TSTRPTR_FROMWIDE(pszAboutCLSID, wszAboutCLSID);

   
    // Add the CLSID to the registry.
    setSnapInKeyAndValue(pszCLSID, NULL, _T("NameString"), szNameString) ;
    setSnapInKeyAndValue(pszCLSID, _T("StandAlone"), NULL, NULL);
    if (IID_NULL != clsidAbout)
        setSnapInKeyAndValue(pszCLSID, NULL, _T("About"), pszAboutCLSID);
    
    if (fSupportExtensions) {
        // Build the key NodeType 
        setSnapInKeyAndValue(pszCLSID, _T("NodeTypes"), NULL, NULL);
        
        _TCHAR szKey[64] ;
        _tcscpy(szKey, pszCLSID) ;
        _tcscat(szKey, _T("\\NodeTypes")) ;
        setSnapInKeyAndValue(szKey, pszCLSID, NULL, NULL);
    }
    
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    if (IID_NULL != clsidAbout)
        CoTaskMemFree(wszAboutCLSID);
    
    return S_OK ;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    LPOLESTR wszCLSID = NULL;
    
    // Get CLSID
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
    
    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));
    
    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\"));
    _tcscat(szKeyBuf, pszCLSID);
    
    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.
    
    // free the memory
    CoTaskMemFree(wszCLSID);
    
    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }
    
    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }
    
    // Close the child.
    RegCloseKey(hKeyChild) ;
    
    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;
    
    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));
    
    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\")) ;
    _tcscat(szKeyBuf, szKey) ;
    
    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\menubtn\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>

#ifndef STRINGS_ONLY
	#define IDM_BUTTON1    0x100
	#define IDM_BUTTON2    0x101

	extern HINSTANCE g_hinst;
	extern ULONG g_uObjects;

	#define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
	#define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

	// uncomment the following #define to enable message cracking
	// #define MMC_CRACK_MESSAGES
	void MMCN_Crack(BOOL bComponentData, 
					IDataObject *pDataObject, 
					IComponentData *pCompData,
					IComponent *pComp,
					MMC_NOTIFY_TYPE event, 
					LPARAM arg, 
					LPARAM param);
#endif

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(GetProcessHeap(), 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(GetProcessHeap(), 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given a _TCHAR, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszT;
//  pszT = MyGetTStringRoutine();
//  MAKE_WIDEPTR_FROMSTR(pwsz, pszT);
//  MyUseWideStringRoutine(pwsz);
//  ...
#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPWSTR)__TempBuffer##ptrname.GetBuffer(), tstr); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    lstrcpyW((LPWSTR)ptrname, tstr)
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, ptrname, __l##ptrname)
#endif

//
// similarily for MAKE_TSTRPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
// * 2 for DBCS handling in below length computation
//
#ifdef UNICODE
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPTSTR)__TempBuffer##ptrname.GetBuffer(), widestr); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\menubtn\land.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Land.h"

const GUID CLandBasedVehicle::thisGuid = { 0x2974380e, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CLandBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\menubtn\comp.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "DataObj.h"
#include <commctrl.h>        // Needed for button styles...
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "DeleBase.h"
#include "CompData.h"

CComponent::CComponent(CComponentData *parent)
: m_pComponentData(parent), m_cref(0), m_ipConsole(NULL)
{
    OBJECT_CREATED

        m_ipDisplayHelp = NULL;
    m_ipControlBar  = NULL;
    m_ipMenuButton  = NULL;
}

CComponent::~CComponent()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IComponent))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IExtendControlbar))
        *ppv = static_cast<IExtendControlbar *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponent::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponent::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface IComponent
///////////////////////////////
STDMETHODIMP CComponent::Initialize(
                                    /* [in] */ LPCONSOLE lpConsole)
{
    HRESULT hr = S_OK;

    // Save away all the interfaces we'll need.
    // Fail if we can't QI the required interfaces.

    m_ipConsole = lpConsole;
    m_ipConsole->AddRef();

    hr = m_ipConsole->QueryInterface(IID_IDisplayHelp, (void **)&m_ipDisplayHelp);

    return hr;
}

STDMETHODIMP CComponent::Notify(
                                /* [in] */ LPDATAOBJECT lpDataObject,
                                /* [in] */ MMC_NOTIFY_TYPE event,
                                /* [in] */ LPARAM arg,
                                /* [in] */ LPARAM param)
{
    MMCN_Crack(FALSE, lpDataObject, NULL, this, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)      {
    case MMCN_ADD_IMAGES:
        hr = base->OnAddImages((IImageList *)arg, (HSCOPEITEM)param);
        break;

    case MMCN_SELECT:
        hr = base->OnSelect(m_ipConsole, (BOOL) LOWORD(arg), (BOOL) HIWORD(arg));
        break;

    case MMCN_SHOW:
        hr = base->OnShow(m_ipConsole, (BOOL)arg, (HSCOPEITEM)param);
        break;

    case MMCN_CONTEXTHELP:
        hr = base->OnShowContextHelp(m_ipDisplayHelp, m_pComponentData->m_HelpFile);
        break;
    }

    return hr;
}

STDMETHODIMP CComponent::Destroy(
                                 /* [in] */ MMC_COOKIE cookie)
{
    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    if (m_ipDisplayHelp) {
        m_ipDisplayHelp->Release();
        m_ipDisplayHelp = NULL;
    }

    if (m_ipControlBar) {
        m_ipControlBar->Release();
        m_ipControlBar = NULL;
    }

    if (m_ipMenuButton) {
        m_ipMenuButton->Release();
        m_ipMenuButton = NULL;
    }

    return S_OK;
}


STDMETHODIMP CComponent::QueryDataObject(
                                         /* [in] */ MMC_COOKIE cookie,
                                         /* [in] */ DATA_OBJECT_TYPES type,
                                         /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pComponentData->m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

STDMETHODIMP CComponent::GetResultViewType(
                                           /* [in] */ MMC_COOKIE cookie,
                                           /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
                                           /* [out] */ long __RPC_FAR *pViewOptions)
{
    CDelegationBase *base = (CDelegationBase *)cookie;

    //
    // Ask for default listview.
    //
    if (base == NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
        *ppViewType = NULL;
    }
    else
        return base->GetResultViewType(ppViewType, pViewOptions);

    return S_OK;
}

STDMETHODIMP CComponent::GetDisplayInfo(
                                        /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem)
{
    HRESULT hr = S_OK;
    CDelegationBase *base = NULL;

    // if they are asking for the RDI_STR we have one of those to give

    if (pResultDataItem->lParam) {
        base = (CDelegationBase *)pResultDataItem->lParam;
        if (pResultDataItem->mask & RDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName(pResultDataItem->nCol);
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pResultDataItem->str = pszW;
        }

        if (pResultDataItem->mask & RDI_IMAGE) {
            pResultDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}


STDMETHODIMP CComponent::CompareObjects(
                                        /* [in] */ LPDATAOBJECT lpDataObjectA,
                                        /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////
// Interface IExtendControlBar
///////////////////////////////
HRESULT CComponent::SetControlbar(
                                  /* [in] */ LPCONTROLBAR pControlbar)
{
    HRESULT hr = S_OK;

    //
    //  Clean up
    //

    // if we've got a cached control bar, release it
    if (m_ipControlBar) {
        m_ipControlBar->Release();
        m_ipControlBar = NULL;
    }

    // if we've got a cached menubutton, release it
    if (m_ipMenuButton) {
        m_ipMenuButton->Release();
        m_ipMenuButton = NULL;
    }

    //
    // Install new pieces if necessary
    //

    // if a new one came in, cache and AddRef
    if (pControlbar) {
        m_ipControlBar = pControlbar;
        m_ipControlBar->AddRef();

        // add our menu button
        hr = m_ipControlBar->Create(MENUBUTTON,  // type of control to be created
            dynamic_cast<IExtendControlbar *>(this),
            reinterpret_cast<IUnknown **>(&m_ipMenuButton));
        _ASSERT(SUCCEEDED(hr));

        m_ipMenuButton->AddRef();

        hr = m_ipMenuButton->AddButton(IDR_STATE_MENU, L"Vehicle &Status", L"Change vehicle state");
        _ASSERT(SUCCEEDED(hr));
    }

    return hr;
}

HRESULT CComponent::ControlbarNotify(
                                     /* [in] */ MMC_NOTIFY_TYPE event,
                                     /* [in] */ LPARAM arg,
                                     /* [in] */ LPARAM param)
{
    HRESULT hr = S_OK;

    if (event == MMCN_SELECT) { 
        CDelegationBase *base = GetOurDataObject(reinterpret_cast<IDataObject *>(param))->GetBaseNodeObject();
        hr = base->SetMenuState(m_ipControlBar, m_ipMenuButton, (BOOL) LOWORD(arg), (BOOL) HIWORD(arg));
    } else if (event == MMCN_MENU_BTNCLICK) {
        CDelegationBase *base = GetOurDataObject(reinterpret_cast<IDataObject *>(arg))->GetBaseNodeObject();
        hr = base->OnSetMenuButton(m_ipConsole, (MENUBUTTONDATA *)param);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\menubtn\comp.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMP_H_
#define _SAMPCOMP_H_

#include <mmc.h>

class CComponent : public IComponent,
IExtendControlbar

{
private:
    ULONG				m_cref;
    
    IConsole*		m_ipConsole;
    IDisplayHelp*	m_ipDisplayHelp;
    IControlbar*    m_ipControlBar;
    IMenuButton*    m_ipMenuButton;
    
    class CComponentData *m_pComponentData;
    
    public:
        CComponent(CComponentData *parent);
        ~CComponent();
        
        ///////////////////////////////
        // Interface IUnknown
        ///////////////////////////////
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        
        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ MMC_COOKIE cookie);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);
            
            ///////////////////////////////
            // Interface IExtendControlBar
            ///////////////////////////////
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetControlbar( 
            /* [in] */ LPCONTROLBAR pControlbar);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ControlbarNotify( 
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
};

#endif _SAMPCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\menubtn\compdata.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMPDATA_H_
#define _SAMPCOMPDATA_H_

#include <mmc.h>
#include "DeleBase.h"
#include "StatNode.h"
#include "Comp.h"

class CComponentData : public IComponentData,
ISnapinHelp
{
    friend class CComponent;

private:
    ULONG                               m_cref;
    LPCONSOLE                   m_ipConsole;
    LPCONSOLENAMESPACE  m_ipConsoleNameSpace;

    CStaticNode     *m_pStaticNode;

    WCHAR            m_HelpFile[MAX_PATH];

public:
    CComponentData();
    ~CComponentData();

    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    ///////////////////////////////
    // Interface IComponentData
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize(
        /* [in] */ LPUNKNOWN pUnknown);

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent(
        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify(
        /* [in] */ LPDATAOBJECT lpDataObject,
        /* [in] */ MMC_NOTIFY_TYPE event,
        /* [in] */ LPARAM arg,
        /* [in] */ LPARAM param);

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject(
        /* [in] */ MMC_COOKIE cookie,
        /* [in] */ DATA_OBJECT_TYPES type,
        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo(
        /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects(
        /* [in] */ LPDATAOBJECT lpDataObjectA,
        /* [in] */ LPDATAOBJECT lpDataObjectB);

        ///////////////////////////////
        // Interface ISnapinHelp
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetHelpTopic(
        /* [out] */ LPOLESTR __RPC_FAR *lpCompiledHelpFile);
};

#endif _SAMPCOMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\menubtn\delebase.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DeleBase.h"

const GUID CDelegationBase::thisGuid = { 0x2974380b, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

HBITMAP CDelegationBase::m_pBMapSm = NULL;
HBITMAP CDelegationBase::m_pBMapLg = NULL;

//==============================================================
//
// CDelegationBase implementation
//
//
CDelegationBase::CDelegationBase() 
: bExpanded(FALSE) 
{ 
    if (NULL == m_pBMapSm || NULL == m_pBMapLg)
        LoadBitmaps(); 
}

CDelegationBase::~CDelegationBase() 
{ 
}

// CDelegationBase::AddImages sets up the collection of images to be displayed
// by the IComponent in the result pane as a result of its MMCN_SHOW handler
HRESULT CDelegationBase::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi) 
{
    return pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}

HRESULT CDelegationBase::OnShowContextHelp(IDisplayHelp *m_ipDisplayHelp, LPOLESTR helpFile)
{ 
    WCHAR topicName[MAX_PATH];
    
    wcscpy(topicName, helpFile);
    
    // we should read this from a resource file
    wcscat(topicName, L"::/default.htm");
    
    LPOLESTR pszTopic = static_cast<LPOLESTR>(CoTaskMemAlloc((wcslen(topicName) + 1) * sizeof(WCHAR)));
    
    wcscpy(pszTopic, topicName);
    
    return m_ipDisplayHelp->ShowTopic(pszTopic);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\menubtn\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5

#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\menubtn\mmccrack.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

static TCHAR *MMCN_CrackVerb(MMC_CONSOLE_VERB verb)
{
        static TCHAR error[64];

        switch (verb) {
    case MMC_VERB_NONE:
                return _T("NONE");
    case MMC_VERB_OPEN:
                return _T("OPEN");
    case MMC_VERB_COPY:
                return _T("COPY");
    case MMC_VERB_PASTE:
                return _T("PASTE");
    case MMC_VERB_DELETE:
                return _T("DELETE");
    case MMC_VERB_PROPERTIES:
                return _T("PROPERTIES");
    case MMC_VERB_RENAME:
                return _T("RENAME");
    case MMC_VERB_REFRESH:
                return _T("REFRESH");
    case MMC_VERB_PRINT:
                return _T("PRINT");
    case MMC_VERB_CUT:
                return _T("CUT");
        default:
                wsprintf(error, _T("Unknown verb id %d"), verb);
                return error;
        }
}

void MMCN_Crack(BOOL bComponentData,
                IDataObject *pDataObject,
                                IComponentData *pCompData,
                                IComponent *pComp,
                MMC_NOTIFY_TYPE event,
                                LPARAM arg,
                                LPARAM param)
{
#ifdef MMC_CRACK_MESSAGES
        TCHAR message[256] = {0};

        if (bComponentData == TRUE)
                OutputDebugString(_T("IComponentData::Notify( "));
        else
                OutputDebugString(_T("IComponent::Notify( "));

        wsprintf(message, _T("DataObject: %08x, CompData: %08x, Comp: %08x ) - "), pDataObject, pCompData, pComp);
        OutputDebugString(message);

    switch (event)      {
                case MMCN_ACTIVATE:
                        wsprintf(message, _T("MMCN_ACTIVATE\n\tActivate: %d\n"), arg);
                        break;

                case MMCN_ADD_IMAGES:
                        wsprintf(message, _T("MMCN_ADD_IMAGES\n\tImage List: %08x\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_BTN_CLICK:
                        wsprintf(message, _T("MMCN_BTN_CLICK\n\tVerb: %ws\n"), MMCN_CrackVerb((MMC_CONSOLE_VERB)param));
                        break;

                case MMCN_COLUMN_CLICK:
                        wsprintf(message, _T("MMCN_COLUMN_CLICK\n\tColumn: %d\n\tSort Option: %d\n"), arg,       param);
                        break;

                case MMCN_COLUMNS_CHANGED:
                        wsprintf(message, _T("MMCN_COLUMNS_CHANGED\n"));
                        break;

                case MMCN_CONTEXTHELP:
                        wsprintf(message, _T("MMCN_CONTEXTHELP\n"));
                        break;

                case MMCN_CONTEXTMENU:
                        wsprintf(message, _T("MMCN_CONTEXTMENU\n"));
                        break;

                case MMCN_CUTORMOVE:
                        wsprintf(message, _T("MMCN_CUTORMOVE\n"));
                        break;

                case MMCN_DBLCLICK:
                        wsprintf(message, _T("MMCN_DBLCLICK\n"));
                        break;

                case MMCN_DELETE:
                        wsprintf(message, _T("MMCN_DELETE\n"));
                        break;

                case MMCN_DESELECT_ALL:
                        wsprintf(message, _T("MMCN_DESELECT_ALL\n"));
                        break;

                case MMCN_EXPAND:
                        wsprintf(message, _T("MMCN_EXPAND\n\tExpand: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_EXPANDSYNC:
                        wsprintf(message, _T("MMCN_EXPANDSYNC\n"));
                        break;

                case MMCN_FILTERBTN_CLICK:
                        wsprintf(message, _T("MMCN_FILTERBTN_CLICK\n\tColumn: %d\n"), arg);
                        break;

                case MMCN_FILTER_CHANGE:
                        wsprintf(message, _T("MMCN_FILTER_CHANGE\n\tColumn: %d\n"), param);
                        break;

                case MMCN_HELP:
                        wsprintf(message, _T("MMCN_HELP\n"));
                        break;

                case MMCN_INITOCX:
                        wsprintf(message, _T("MMCN_INITOCX\n\tIUnknown: %08x\n"), param);
                        break;

                case MMCN_LISTPAD:
                        wsprintf(message, _T("MMCN_LISTPAD\n\tConnect: %d\n"), arg);
                        break;

                case MMCN_MENU_BTNCLICK:
                        wsprintf(message, _T("MMCN_MENU_BTNCLICK\n"));
                        break;

                case MMCN_MINIMIZED:
                        wsprintf(message, _T("MMCN_MINIMIZED\n\tMinimized: %d\n"), arg);
                        break;

                case MMCN_PASTE:
                        wsprintf(message, _T("MMCN_PASTE\n\tCopy: %d\n"), param == NULL);
                        break;

                case MMCN_PRELOAD:
                        wsprintf(message, _T("MMCN_PRELOAD\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_PRINT:
                        wsprintf(message, _T("MMCN_PRINT\n"));
                        break;

                case MMCN_PROPERTY_CHANGE:
                        wsprintf(message, _T("MMCN_PROPERTY_CHANGE\n\tScope: %d\n\tArg: %08x\n"), arg, param);
                        break;

                case MMCN_QUERY_PASTE:
                        wsprintf(message, _T("MMCN_QUERY_PASTE\n"));
                        break;

                case MMCN_REFRESH:
                        wsprintf(message, _T("MMCN_REFRESH\n"));
                        break;

                case MMCN_REMOVE_CHILDREN:
                        wsprintf(message, _T("MMCN_REMOVE_CHILDREN\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_RENAME:
                        wsprintf(message, _T("MMCN_RENAME\n\tNew Name: '%ws'\n"), (LPOLESTR)param);
                        break;

                case MMCN_RESTORE_VIEW:
                        wsprintf(message, _T("MMCN_RESTORE_VIEW\n"));
                        break;

                case MMCN_SELECT:
                        wsprintf(message, _T("MMCN_SELECT\n\tScope: %d\n\tSelect: %08x\n"), LOWORD(arg), HIWORD(arg));
                        break;

                case MMCN_SHOW:
                        wsprintf(message, _T("MMCN_SHOW\n\tShow: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_SNAPINHELP:
                        wsprintf(message, _T("MMCN_SNAPINHELP\n"));
                        break;

                case MMCN_VIEW_CHANGE:
                        wsprintf(message, _T("MMCN_VIEW_CHANGE\n\tData: %08x\n\tHint: %08x\n"), arg, param);
                        break;
        }

        if (message[0] != 0)
                OutputDebugString(message);
        else
                OutputDebugString(_T("unknown event\n"));

#endif
        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\menubtn\people.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _PEOPLE_H
#define _PEOPLE_H

#include "DeleBase.h"

class CBicycle : public CDelegationBase {
public:
    CBicycle(int i) : id(i) { }
    virtual ~CBicycle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CBicycleFolder : public CDelegationBase {
public:
    CBicycleFolder();
    virtual ~CBicycleFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Bicycles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CSkateboard : public CDelegationBase {
public:
    CSkateboard(int i) : id(i) { }
    virtual ~CSkateboard() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CSkateboardFolder : public CDelegationBase {
public:
    CSkateboardFolder();
    virtual ~CSkateboardFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Skateboards"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CIceSkate : public CDelegationBase {
public:
    CIceSkate(int i) : id(i) { }
    virtual ~CIceSkate() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CIceSkateFolder : public CDelegationBase {
public:
    CIceSkateFolder();
    virtual ~CIceSkateFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Ice Skates"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CPeoplePoweredVehicle : public CDelegationBase {
public:
    CPeoplePoweredVehicle();
    virtual ~CPeoplePoweredVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("People-powered Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { IDM_NEW_PEOPLE = 1 };
    
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 3 };
    CDelegationBase *children[3];
};

#endif // _PEOPLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\menubtn\delebase.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _BRANCHES_H
#define _BRANCHES_H

#include <mmc.h>
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "LocalRes.h"

class CDelegationBase {
public:
    CDelegationBase();
    virtual ~CDelegationBase();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) = 0;
    virtual const GUID & getNodeType() { _ASSERT(FALSE); return IID_NULL; }
    
    virtual const LPARAM GetCookie() { return reinterpret_cast<LPARAM>(this); }
    virtual const int GetBitmapIndex() = 0;
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions) { return S_FALSE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent) { return S_FALSE; }
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect) { return S_FALSE; }
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem) { return S_FALSE; }
    virtual HRESULT OnShowContextHelp(IDisplayHelp *m_ipDisplayHelp, LPOLESTR helpFile);
    
    virtual HRESULT OnMenuButtonCommand(IConsole *pConsole, int nMenuId, long lCommandID) { return S_FALSE; }
    virtual HRESULT SetMenuState(IControlbar *pControlbar, IMenuButton *pMenuButton, 
        BOOL bScope, BOOL bSelect) { return S_FALSE; }
    virtual HRESULT OnSetMenuButton(IConsole *pConsole, MENUBUTTONDATA *pmbd) { return S_FALSE; }
    
public:
    static HBITMAP m_pBMapSm;
    static HBITMAP m_pBMapLg;
    
protected:
    static void LoadBitmaps() {
        m_pBMapSm = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_SMICONS));
        m_pBMapLg = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_LGICONS));
    }
    
    BOOL bExpanded;
    
private:
    // {2974380B-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _BRANCHES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\menubtn\compdata.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "CompData.h"
#include "DataObj.h"
#include "resource.h"
#include <crtdbg.h>

CComponentData::CComponentData()
: m_cref(0), m_ipConsoleNameSpace(NULL), m_ipConsole(NULL)
{
    OBJECT_CREATED

    m_pStaticNode = new CStaticNode;

    TCHAR tmpHelpFile[MAX_PATH];

    GetWindowsDirectory(tmpHelpFile, sizeof(tmpHelpFile));
    _tcscat(tmpHelpFile, _T("\\HELP\\"));
    LoadString(g_hinst, IDS_HELPFILE, &tmpHelpFile[_tcslen(tmpHelpFile)], MAX_PATH - _tcslen(tmpHelpFile));

	MAKE_WIDEPTR_FROMTSTR(wszHelpFile, tmpHelpFile);
	wcscpy(m_HelpFile, wszHelpFile);
}

CComponentData::~CComponentData()
{
    if (m_pStaticNode) {
        delete m_pStaticNode;
    }

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CComponentData::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_IComponentData))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_ISnapinHelp))
        *ppv = static_cast<ISnapinHelp*>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponentData::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponentData::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }

    return m_cref;
}

///////////////////////////////
// Interface IComponentData
///////////////////////////////
HRESULT CComponentData::Initialize(
                                   /* [in] */ LPUNKNOWN pUnknown)
{
    HRESULT      hr;

    //
    // Get pointer to name space interface
    //
    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (void **)&m_ipConsoleNameSpace);
    _ASSERT( S_OK == hr );

    //
    // Get pointer to console interface
    //
    hr = pUnknown->QueryInterface(IID_IConsole, (void **)&m_ipConsole);
    _ASSERT( S_OK == hr );

    IImageList *pImageList;
    m_ipConsole->QueryScopeImageList(&pImageList);
    _ASSERT( S_OK == hr );

    hr = pImageList->ImageListSetStrip( (long *)m_pStaticNode->m_pBMapSm, // pointer to a handle
        (long *)m_pStaticNode->m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );

    pImageList->Release();

    return S_OK;
}

HRESULT CComponentData::CreateComponent(
                                        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent)
{
    *ppComponent = NULL;

    CComponent *pComponent = new CComponent(this);

    if (NULL == pComponent)
        return E_OUTOFMEMORY;

    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent);
}

HRESULT CComponentData::Notify(
                               /* [in] */ LPDATAOBJECT lpDataObject,
                               /* [in] */ MMC_NOTIFY_TYPE event,
                               /* [in] */ LPARAM arg,
                               /* [in] */ LPARAM param)
{
    MMCN_Crack(TRUE, lpDataObject, this, NULL, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)
    {
    case MMCN_EXPAND:
        hr = base->OnExpand(m_ipConsoleNameSpace, m_ipConsole, (HSCOPEITEM)param);
        break;
    }

    return hr;
}

HRESULT CComponentData::Destroy( void)
{
    // Free interfaces
    if (m_ipConsoleNameSpace) {
        m_ipConsoleNameSpace->Release();
        m_ipConsoleNameSpace = NULL;
    }

    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}

HRESULT CComponentData::QueryDataObject(
                                        /* [in] */ MMC_COOKIE cookie,
                                        /* [in] */ DATA_OBJECT_TYPES type,
                                        /* [out] */ LPDATAOBJECT *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

HRESULT CComponentData::GetDisplayInfo(
                                       /* [out][in] */ SCOPEDATAITEM *pScopeDataItem)
{
    HRESULT hr = S_FALSE;

    // if they are asking for the SDI_STR we have one of those to give
    if (pScopeDataItem->lParam) {
        CDelegationBase *base = (CDelegationBase *)pScopeDataItem->lParam;
        if (pScopeDataItem->mask & SDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName();
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pScopeDataItem->displayname = pszW;
        }

        if (pScopeDataItem->mask & SDI_IMAGE) {
            pScopeDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}

HRESULT CComponentData::CompareObjects(
                                       /* [in] */ LPDATAOBJECT lpDataObjectA,
                                       /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////
// Interface ISnapinHelp
///////////////////////////////
HRESULT CComponentData::GetHelpTopic(
                                     /* [out] */ LPOLESTR *lpCompiledHelpFile)
{
    *lpCompiledHelpFile = static_cast<LPOLESTR>(CoTaskMemAlloc((wcslen(m_HelpFile) + 1) * sizeof(WCHAR)));
    
    wcscpy(*lpCompiledHelpFile, m_HelpFile);
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\menubtn\registry.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions = FALSE);

HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\menubtn\guids.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

// {3684860C-8A36-11d2-8A0A-000021473128}
DEFINE_GUID(CLSID_CComponentData, 
            0x3684860c, 0x8a36, 0x11d2, 0x8a, 0xa, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28);

// {3684860F-8A36-11d2-8A0A-000021473128}
DEFINE_GUID(CLSID_CSnapinAbout, 
            0x3684860f, 0x8a36, 0x11d2, 0x8a, 0xa, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\menubtn\sky.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Sky.h"

const GUID CSkyBasedVehicle::thisGuid = { 0x2974380f, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSkyBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\menubtn\land.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _LAND_H
#define _LAND_H

#include "DeleBase.h"

class CLandBasedVehicle : public CDelegationBase {
public:
    CLandBasedVehicle() { }
    
    virtual ~CLandBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Land-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_LANDICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    
private:
    enum { IDM_NEW_LAND = 2 };
    
    // {2974380E-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _LAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\menubtn\people.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#include <stdio.h>
#include "People.h"

const GUID CPeoplePoweredVehicle::thisGuid = { 0x2974380d, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

const GUID CBicycleFolder::thisGuid = { 0xef163732, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboardFolder::thisGuid = { 0xef163733, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkateFolder::thisGuid = { 0xf6c660b0, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };

const GUID CBicycle::thisGuid = { 0xef163734, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboard::thisGuid = { 0xef163735, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkate::thisGuid = { 0xf6c660b1, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };


//==============================================================
//
// CPeoplePoweredVehicle implementation
//
//
CPeoplePoweredVehicle::CPeoplePoweredVehicle() 
{ 
    children[0] = new CBicycleFolder;
    children[1] = new CSkateboardFolder;
    children[2] = new CIceSkateFolder;
}

CPeoplePoweredVehicle::~CPeoplePoweredVehicle() 
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        delete children[n];
}

HRESULT CPeoplePoweredVehicle::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;
    
    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT    |   // relativeID is valid
                SDI_CHILDREN;     // cChildren is valid
            
            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = 0;
            
            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );
            
            _ASSERT( SUCCEEDED(hr) );
        }
    }
    
    return S_OK;
}

CBicycleFolder::CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CBicycle(n + 1);
    }
}

CBicycleFolder::~CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CBicycleFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;
    
    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;
    
    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );
        
        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );
        
        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        
        // insert items here
        RESULTDATAITEM rdi;
        
        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );
        
        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid
                
                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];
                
                hr = pResultData->InsertItem( &rdi );
                
                _ASSERT( SUCCEEDED(hr) );
            }
        }
        
        pHeaderCtrl->Release();
        pResultData->Release();
    }
    
    return hr;
}

CIceSkateFolder::CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CIceSkate(n + 1);
    }
}

CIceSkateFolder::~CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CIceSkateFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;
    
    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;
    
    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );
        
        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );
        
        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        
        // insert items here
        RESULTDATAITEM rdi;
        
        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );
        
        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid
                
                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];
                
                hr = pResultData->InsertItem( &rdi );
                
                _ASSERT( SUCCEEDED(hr) );
            }
        }
        
        pHeaderCtrl->Release();
        pResultData->Release();
    }
    
    return hr;
}

CSkateboardFolder::CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CSkateboard(n + 1);
    }
}

CSkateboardFolder::~CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSkateboardFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;
    
    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;
    
    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );
        
        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );
        
        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                      ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        
        // insert items here
        RESULTDATAITEM rdi;
        
        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );
        
        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid
                
                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];
                
                hr = pResultData->InsertItem( &rdi );
                
                _ASSERT( SUCCEEDED(hr) );
            }
        }
        
        pHeaderCtrl->Release();
        pResultData->Release();
    }
    
    return hr;
}

const _TCHAR *CBicycle::GetDisplayName(int nCol) 
{
    static _TCHAR buf[128];
    
    _stprintf(buf, _T("Bicycle #%d"), id);
    
    return buf;
}

const _TCHAR *CSkateboard::GetDisplayName(int nCol) 
{
    static _TCHAR buf[128];
    
    _stprintf(buf, _T("Skateboard #%d"), id);
    
    return buf;
}

const _TCHAR *CIceSkate::GetDisplayName(int nCol) 
{
    static _TCHAR buf[128];
    
    _stprintf(buf, _T("Ice Skate #%d"), id);
    
    return buf;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\menubtn\statnode.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SNAPINBASE_H
#define _SNAPINBASE_H

#include "DeleBase.h"

class CStaticNode : public CDelegationBase {
public:
    CStaticNode();
    
    virtual ~CStaticNode();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { 
        static _TCHAR szDisplayName[256];
        LoadString(g_hinst, IDS_SNAPINNAME, szDisplayName, sizeof(szDisplayName));
        return szDisplayName; 
    }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_NONE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
    
    // {2974380C-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _SNAPINBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\menubtn\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Resources.rc
//
#define IDS_HELPFILE                    1
#define IDS_SNAPINDESC                  2
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDI_ICON1                       108
#define IDR_MENUBUTTON                  111
#define IDR_STATE_MENU                  111
#define IDB_SMOPEN                      114
#define IDB_SMBMP                       115
#define IDB_LGBMP                       116
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDB_ROCKET                      40004
#define IDB_CAR                         40005
#define IDB_PLANE                       40006
#define IDB_BIKE                        40007
#define IDB_ROCKET2                     40008
#define IDB_CAR2                        40009
#define IDB_PLANE2                      40010
#define IDB_BIKE2                       40011
#define IDB_CLOSED2                     40012
#define IDB_OPEN2                       40013
#define IDB_CLOSED                      40014
#define IDB_OPEN                        40015
#define ID_COMMAND_START                40016
#define ID_COMMAND_PAUSE                40017
#define ID_COMMAND_STOP                 40018

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        117
#define _APS_NEXT_COMMAND_VALUE         40021
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\menubtn\registry.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

#define STRINGS_ONLY
#include "globals.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName)       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule,
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;

    assert(dwResult != 0) ;

    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    assert(SUCCEEDED(hr)) ;

        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;
        _tcscat(szKey, pszCLSID) ;

    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;

    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    _tcscat(szKey, _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), _T("Apartment"));

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;


    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;

        MAKE_TSTRPTR_FROMWIDE(pszT, wszCLSID);
        _tcscat(szKey, pszT) ;

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Register the snap-in in the registry.
//
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,         // Class Id for About Class
                       const BOOL fSupportExtensions)
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    LPOLESTR wszAboutCLSID = NULL;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    if (IID_NULL != clsidAbout)
        hr = StringFromCLSID(clsidAbout, &wszAboutCLSID);

        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszAboutCLSID, wszAboutCLSID);


    // Add the CLSID to the registry.
    setSnapInKeyAndValue(pszCLSID, NULL, _T("NameString"), szNameString) ;
    setSnapInKeyAndValue(pszCLSID, _T("StandAlone"), NULL, NULL);
    if (IID_NULL != clsidAbout)
        setSnapInKeyAndValue(pszCLSID, NULL, _T("About"), pszAboutCLSID);

    if (fSupportExtensions) {
        // Build the key NodeType
        setSnapInKeyAndValue(pszCLSID, _T("NodeTypes"), NULL, NULL);

        _TCHAR szKey[64] ;
        _tcscpy(szKey, pszCLSID) ;
        _tcscat(szKey, _T("\\NodeTypes")) ;
        setSnapInKeyAndValue(szKey, pszCLSID, NULL, NULL);
    }

    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    if (IID_NULL != clsidAbout)
        CoTaskMemFree(wszAboutCLSID);

    return S_OK ;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    LPOLESTR wszCLSID = NULL;

    // Get CLSID
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\"));
    _tcscat(szKeyBuf, pszCLSID);

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // free the memory
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }

    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }

    // Close the child.
    RegCloseKey(hKeyChild) ;

    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\")) ;
    _tcscat(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\about.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPABOUT_H_
#define _SAMPABOUT_H_

#include <tchar.h>
#include <mmc.h>

class CSnapinAbout : public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;
    
public:
    CSnapinAbout();
    ~CSnapinAbout();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
        /* [out] */ LPOLESTR *lpDescription);
        
        STDMETHODIMP GetProvider( 
        /* [out] */ LPOLESTR *lpName);
        
        STDMETHODIMP GetSnapinVersion( 
        /* [out] */ LPOLESTR *lpVersion);
        
        STDMETHODIMP GetSnapinImage( 
        /* [out] */ HICON *hAppIcon);
        
        STDMETHODIMP GetStaticFolderImage( 
        /* [out] */ HBITMAP *hSmallImage,
        /* [out] */ HBITMAP *hSmallImageOpen,
        /* [out] */ HBITMAP *hLargeImage,
        /* [out] */ COLORREF *cMask);
        
        ///////////////////////////////
        // Private Interface 
        ///////////////////////////////
private:
    HRESULT	CSnapinAbout::AllocOleStr(
        LPOLESTR *lpDest, 
        _TCHAR *szBuffer);
};

#endif _SAMPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\about.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "About.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

CSnapinAbout::CSnapinAbout()
: m_cref(0)
{
    OBJECT_CREATED

        m_hSmallImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    m_hLargeImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_LGBMP), IMAGE_BITMAP, 32, 32, LR_LOADTRANSPARENT);

    m_hSmallImageOpen = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMOPEN), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);

    m_hAppIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ICON1));
}

CSnapinAbout::~CSnapinAbout()
{
    if (m_hSmallImage != NULL)
        FreeResource(m_hSmallImage);

    if (m_hLargeImage != NULL)
        FreeResource(m_hLargeImage);

    if (m_hSmallImageOpen != NULL)
        FreeResource(m_hSmallImageOpen);

    if (m_hAppIcon != NULL)
        FreeResource(m_hAppIcon);

    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CSnapinAbout::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<ISnapinAbout *>(this);
    else if (IsEqualIID(riid, IID_ISnapinAbout))
        *ppv = static_cast<ISnapinAbout *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSnapinAbout::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CSnapinAbout::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription(
                                                /* [out] */ LPOLESTR *lpDescription)
{
    _TCHAR szDesc[MAX_PATH];

    LoadString(g_hinst, IDS_SNAPINDESC, szDesc, sizeof(szDesc));

    return AllocOleStr(lpDescription, szDesc);
}


STDMETHODIMP CSnapinAbout::GetProvider(
                                       /* [out] */ LPOLESTR *lpName)
{
    return AllocOleStr(lpName, _T("Copyright  1998 Microsoft Corporation"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinVersion(
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return AllocOleStr(lpVersion, _T("1.0"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinImage(
                                          /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;

    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}


STDMETHODIMP CSnapinAbout::GetStaticFolderImage(
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;

    *hSmallImageOpen = m_hSmallImageOpen;

    *cMask = RGB(0, 128, 128);

    if (*hSmallImage == NULL || *hLargeImage == NULL || *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}

// this allocates a chunk of memory using CoTaskMemAlloc and copies our chars into it
HRESULT CSnapinAbout::AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer)
{
        MAKE_WIDEPTR_FROMTSTR_ALLOC(wszStr, szBuffer);
        *lpDest = wszStr;


    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\backgrnd.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#include <stdio.h>
#include "Backgrnd.h"

const GUID CBackgroundFolder::thisGuid = { 0x2974380f, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };
const GUID CBackground::thisGuid = { 0x2974380f, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

#define WM_NEWOBJECT WM_APP
#define WM_DISCOVERYCOMPLETE (WM_APP + 1)

//==============================================================
//
// CBackgroundFolder implementation
//
//
CBackgroundFolder::CBackgroundFolder()
: m_pConsoleNameSpace(NULL), m_scopeitem(0), m_threadId(0), m_thread(NULL), 
m_running(false), m_bViewUpdated(false)
{
    ZeroMemory(m_children, sizeof(m_children));

    WNDCLASS wndClass;

    ZeroMemory(&wndClass, sizeof(WNDCLASS));

    wndClass.lpfnWndProc = WindowProc; 
    wndClass.lpszClassName = _T("backgroundthreadwindow"); 
    wndClass.hInstance = g_hinst;

    ATOM atom = RegisterClass(&wndClass);
    m_backgroundHwnd = CreateWindow(
            _T("backgroundthreadwindow"),  // pointer to registered class name
            NULL, // pointer to window name
            0,        // window style
            0,                // horizontal position of window
            0,                // vertical position of window
            0,           // window width
            0,          // window height
            NULL,      // handle to parent or owner window
            NULL,          // handle to menu or child-window identifier
            g_hinst,     // handle to application instance
            (void *)this        // pointer to window-creation data
        );

    if (m_backgroundHwnd)
        SetWindowLong(m_backgroundHwnd, GWL_USERDATA, (LONG)this);

    InitializeCriticalSection(&m_critSect);
}

CBackgroundFolder::~CBackgroundFolder()
{
    StopThread();

    for (int n = 0; n < MAX_CHILDREN; n++)
        if (m_children[n] != NULL)
            delete m_children[n];

    if (m_backgroundHwnd != NULL)
        DestroyWindow(m_backgroundHwnd);

    UnregisterClass(_T("backgroundthreadwindow"), NULL);

    DeleteCriticalSection(&m_critSect);
}

LRESULT CALLBACK CBackgroundFolder::WindowProc(
      HWND hwnd,      // handle to window
      UINT uMsg,      // message identifier
      WPARAM wParam,  // first message parameter
      LPARAM lParam   // second message parameter
    )
{
    CBackgroundFolder *pThis = (CBackgroundFolder *)GetWindowLong(hwnd, GWL_USERDATA);

    switch (uMsg) {
    case WM_NEWOBJECT:
        _ASSERT(pThis != NULL);
        pThis->AddItem(lParam);
        break;

    case WM_DISCOVERYCOMPLETE:
        _ASSERT(pThis != NULL);
        pThis->m_bViewUpdated = true;
        pThis->StopThread();
        break;
   }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

DWORD WINAPI CBackgroundFolder::ThreadProc(
  LPVOID lpParameter   // thread data
)
{
    CBackgroundFolder *pThis = (CBackgroundFolder *)lpParameter;

    EnterCriticalSection(&pThis->m_critSect);
    pThis->m_running = true;
    LeaveCriticalSection(&pThis->m_critSect);

    for (int n = 0; n < MAX_CHILDREN; n++) {
        EnterCriticalSection(&pThis->m_critSect);
        bool running = pThis->m_running;
        LeaveCriticalSection(&pThis->m_critSect);

        if (running == false)
            return 0;

        PostMessage(pThis->m_backgroundHwnd, WM_NEWOBJECT, 0, n);
        Sleep(500);
    }

    PostMessage(pThis->m_backgroundHwnd, WM_DISCOVERYCOMPLETE, 0, 0);

    return 0;
}

void CBackgroundFolder::StartThread()
{
    EnterCriticalSection(&m_critSect);
    m_thread = CreateThread(NULL, 0, ThreadProc, (void *)this, 0, &m_threadId);
    LeaveCriticalSection(&m_critSect);
}

void CBackgroundFolder::StopThread()
{
    EnterCriticalSection(&m_critSect);
    m_running = false;

    if (m_thread != NULL) {
        // this is ugly, wait for 10 seconds, then kill the thread
        DWORD res = WaitForSingleObject(m_thread, 10000);

        if (res == WAIT_TIMEOUT)
            TerminateThread(m_thread, 0);

        CloseHandle(m_thread);

        m_thread = NULL;
    }
    LeaveCriticalSection(&m_critSect);
}

void CBackgroundFolder::AddItem(int id)
{
    HRESULT hr;

    EnterCriticalSection(&m_critSect);

    _ASSERT(m_children[id] == NULL);

    m_children[id] = new CBackground(id);

    SCOPEDATAITEM sdi;

    // insert items here
    ZeroMemory(&sdi, sizeof(SCOPEDATAITEM));

    sdi.mask = SDI_STR       |   // Displayname is valid
        SDI_PARAM     |   // lParam is valid
        SDI_IMAGE     |   // nImage is valid
        SDI_OPENIMAGE |   // nOpenImage is valid
        SDI_PARENT    |
        SDI_CHILDREN;
    
    sdi.relativeID  = (HSCOPEITEM)m_scopeitem;
    sdi.nImage      = m_children[id]->GetBitmapIndex();
    sdi.nOpenImage  = INDEX_OPENFOLDER;
    sdi.displayname = MMC_CALLBACK;
    sdi.lParam      = (LPARAM)m_children[id];       // The cookie
    sdi.cChildren   = 0;

    hr = m_pConsoleNameSpace->InsertItem( &sdi );
    _ASSERT( SUCCEEDED(hr) );

    m_children[id]->SetHandle((HANDLE)sdi.ID);
    
    LeaveCriticalSection(&m_critSect);

    return;
}

HRESULT CBackgroundFolder::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi) 
{
    return pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}

HRESULT CBackgroundFolder::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    // cache the stuff
    m_pConsoleNameSpace = pConsoleNameSpace;
    m_scopeitem = parent;

    if (m_bViewUpdated == false && m_running == false)
        StartThread();

    return S_OK;
}

HRESULT CBackgroundFolder::OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect)
{
    m_bSelected = (bSelect && bScope) ? true : false;

    if (bSelect && !m_running) {
        IConsoleVerb *pConsoleVerb;
    
        HRESULT hr = pConsole->QueryConsoleVerb(&pConsoleVerb);
        _ASSERT(SUCCEEDED(hr));
    
        hr = pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);
    
        pConsoleVerb->Release();
    }
    
    return S_OK;
}

HRESULT CBackgroundFolder::OnRefresh()
{
    HRESULT hr = S_OK;

    StopThread();

    EnterCriticalSection(&m_critSect);
    for (int n = 0; n < MAX_CHILDREN; n++) {
        if (m_children[n] != NULL) {
            HSCOPEITEM hItem = (HSCOPEITEM)m_children[n]->GetHandle();
            hr = m_pConsoleNameSpace->DeleteItem(hItem, TRUE);

            delete m_children[n];
            m_children[n] = NULL;
        }
    }
    LeaveCriticalSection(&m_critSect);

    m_bViewUpdated = false;

    StartThread();

    return S_OK;
}

const _TCHAR *CBackground::GetDisplayName(int nCol) 
{
    static _TCHAR buf[128];
    
    _stprintf(buf, _T("Background object #%d"), m_id);
    
    return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\menubtn\space.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#include <stdio.h>
#include "Space.h"
#include "Comp.h"

const GUID CSpaceVehicle::thisGuid = { 0x29743810, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };
const GUID CRocket::thisGuid = { 0x29743811, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSpaceVehicle implementation
//
//
CSpaceVehicle::CSpaceVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CRocket();
        children[n]->Initialize(_T("Vehicle"), 500000, 265, 75000);
    }
}

CSpaceVehicle::~CSpaceVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSpaceVehicle::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;
    
    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;
    
    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );
        
        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );
        
        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Rocket Class", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 1, L"Rocket Weight", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 2, L"Rocket Height", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 3, L"Rocket Payload", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 4, L"Status", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        
        // insert items here
        RESULTDATAITEM rdi;
        
        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );
        
        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid
                
                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];
                
                hr = pResultData->InsertItem( &rdi );
                
                _ASSERT( SUCCEEDED(hr) );
            }
        }
        
        pHeaderCtrl->Release();
        pResultData->Release();
    }
    
    return hr;
}

//==============================================================
//
// CRocket implementation
//
//
CRocket::CRocket() 
: szName(NULL), lWeight(0), lHeight(0), lPayload(0), iStatus(STOPPED)
{ 
}

CRocket::~CRocket() 
{
    if (szName)
        delete [] szName;
}

void CRocket::Initialize(_TCHAR *szName, LONG lWeight, LONG lHeight, LONG lPayload)
{
    if (szName) {
        this->szName = new _TCHAR[_tcslen(szName) + 1];
        _tcscpy(this->szName, szName);
    }
    
    this->lWeight = lWeight;
    this->lHeight = lHeight;
    this->lPayload = lPayload;
}

const _TCHAR *CRocket::GetDisplayName(int nCol) 
{
    static _TCHAR buf[128];
    
    switch (nCol) {
    case 0:
        _tcscpy(buf, szName ? szName : _T(""));
        break;
        
    case 1:
        _stprintf(buf, _T("%ld metric tons"), lWeight);
        break;
        
    case 2:
        _stprintf(buf, _T("%ld meters"), lHeight);
        break;
        
    case 3:
        _stprintf(buf, _T("%ld kilos"), lPayload);
        break;
        
    case 4:
        _stprintf(buf, _T("%s"),
            iStatus == RUNNING ? _T("running") : 
        iStatus == PAUSED ? _T("paused") :
        iStatus == STOPPED ? _T("stopped") : _T("unknown"));
        break;
        
    }
    
    return buf;
}

HMENU CRocket::GetMenu(int nMenuId)
{
    HMENU hResMenu = LoadMenu(g_hinst, MAKEINTRESOURCE(nMenuId));
    HMENU hMenu = GetSubMenu(hResMenu,0);
    
    if (IDR_STATE_MENU == nMenuId) {
        switch (iStatus)
        {
        case RUNNING:
            EnableMenuItem(hMenu, ID_COMMAND_START, MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem(hMenu, ID_COMMAND_PAUSE, MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_COMMAND_STOP, MF_BYCOMMAND | MF_ENABLED);
            break;
            
        case PAUSED:
            EnableMenuItem(hMenu, ID_COMMAND_START, MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_COMMAND_PAUSE, MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem(hMenu, ID_COMMAND_STOP, MF_BYCOMMAND | MF_ENABLED);
            break;
            
        case STOPPED:
            EnableMenuItem(hMenu, ID_COMMAND_START, MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_COMMAND_START, MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_COMMAND_STOP, MF_BYCOMMAND | MF_GRAYED);
            break;
        }
    } else {
        // some other menu, set state accordingly
    }
    
    return hMenu;
}

HRESULT CRocket::SetMenuState(IControlbar *pControlbar, 
                                         IMenuButton *pMenuButton, 
                                         BOOL bScope, 
                                         BOOL bSelect)
{
    HRESULT hr = S_OK;
    
    if (bSelect) {
        // Always make sure the menuButton is attached
        hr = pControlbar->Attach(MENUBUTTON, pMenuButton);
        
        hr = pMenuButton->SetButtonState(IDR_STATE_MENU, HIDDEN, FALSE);
        hr = pMenuButton->SetButtonState(IDR_STATE_MENU, ENABLED, TRUE);
    } else if (!bSelect) {
        hr = pMenuButton->SetButtonState(IDR_STATE_MENU, ENABLED, FALSE);
        hr = pMenuButton->SetButtonState(IDR_STATE_MENU, HIDDEN, TRUE);
    }
    
    return hr;
}

HRESULT CRocket::OnSetMenuButton(IConsole *pConsole, MENUBUTTONDATA *pmbd) 
{ 
    HMENU hMenu = GetMenu(pmbd->idCommand);
    HRESULT hr = S_FALSE;
    HWND  hWnd;
    
    if (hMenu) {
        hr = pConsole->GetMainWindow(&hWnd);
        
        if (SUCCEEDED(hr)) {
            LONG ret = TrackPopupMenuEx(hMenu, TPM_NONOTIFY | TPM_RETURNCMD,
                pmbd->x, pmbd->y, hWnd, NULL);
            
            if (ret != 0) { // !cancelled
                hr = OnMenuButtonCommand(pConsole, pmbd->idCommand, ret);
            }
        }
        
        DestroyMenu(hMenu);
    }
    
    return hr;
}

HRESULT CRocket::OnMenuButtonCommand(IConsole *pConsole, int nMenuId, long lCommandID)
{
    _TCHAR szVehicle[128];
    
    if (IDR_STATE_MENU == nMenuId) {
        switch (lCommandID) {
        case ID_COMMAND_START:
            iStatus = RUNNING;
            break;
            
        case ID_COMMAND_PAUSE:
            iStatus = PAUSED;
            break;
            
        case ID_COMMAND_STOP:
            iStatus = STOPPED;
            break;
        }
        
        wsprintf(szVehicle, _T("Vehicle %s has been %s"), szName, 
            (long)iStatus == RUNNING ? _T("started") : 
        (long)iStatus == PAUSED ? _T("paused") :
        (long)iStatus == STOPPED ? _T("stopped") : _T("!!!unknown command!!!"));
        
        int ret = 0;
        MAKE_WIDEPTR_FROMTSTR(pszVehicle, szVehicle);
        pConsole->MessageBox(pszVehicle,
            L"Vehicle command", MB_OK | MB_ICONINFORMATION, &ret);
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\menubtn\statnode.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "StatNode.h"

#include "People.h"
#include "Sky.h"
#include "Land.h"
#include "Space.h"

const GUID CStaticNode::thisGuid = { 0x2974380c, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CStaticNode implementation
//
//
CStaticNode::CStaticNode()
{
    children[0] = new CPeoplePoweredVehicle;
    children[1] = new CLandBasedVehicle;
    children[2] = new CSkyBasedVehicle;
    children[3] = new CSpaceVehicle;
}

CStaticNode::~CStaticNode()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CStaticNode::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;
    
    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT	  |
                SDI_CHILDREN;
            
            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = (n == 0); // only the first child has children
            
            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );
            
            _ASSERT( SUCCEEDED(hr) );
        }
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\backgrnd.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _BACKGROUND_H
#define _BACKGROUND_H

#include "DeleBase.h"

class CBackground : public CDelegationBase {
public:
    CBackground(int id) : m_itemId(NULL), m_id(id) { }
    virtual ~CBackground() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_BACKGROUND; }
    
private:
    enum { IDM_NEW_BACKGROUND = 6 };
    
    static const GUID thisGuid;
    int m_id;
    HSCOPEITEM m_itemId;
};

class CBackgroundFolder : public CDelegationBase {
public:
    CBackgroundFolder();
    virtual ~CBackgroundFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Background Objects"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_BACKGROUND; }

public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect);
    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    virtual HRESULT OnRefresh();
   
private:
    enum { MAX_CHILDREN = 30 };

    CBackground *m_children[MAX_CHILDREN];

    HWND m_backgroundHwnd;
    
    static const GUID thisGuid;

    static LRESULT CALLBACK WindowProc(
          HWND hwnd,      // handle to window
          UINT uMsg,      // message identifier
          WPARAM wParam,  // first message parameter
          LPARAM lParam   // second message parameter
        );

    static DWORD WINAPI ThreadProc(
      LPVOID lpParameter   // thread data
    );

    DWORD m_threadId;
    HANDLE m_thread;
    bool m_running;

    IConsoleNameSpace *m_pConsoleNameSpace;
    HSCOPEITEM m_scopeitem;
    void AddItem(int id);

    CRITICAL_SECTION m_critSect;

    void StopThread();
    void StartThread();

    bool m_bSelected;
    bool m_bViewUpdated;
};


#endif // _BACKGROUND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\basesnap.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <olectl.h>
#include <initguid.h>
#include "guids.h"
#include "basesnap.h"
#include "Comp.h"
#include "CompData.h"
#include "About.h"
#include "Registry.h"

// our globals
HINSTANCE g_hinst;

BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    if ((rclsid != CLSID_CComponentData) && (rclsid != CLSID_CSnapinAbout))
        return CLASS_E_CLASSNOTAVAILABLE;
    
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
    // make the factory passing in the creation function for the type of object they want
    if (rclsid == CLSID_CComponentData)
        pFactory = new CClassFactory(CClassFactory::COMPONENT);
    else if (rclsid == CLSID_CSnapinAbout)
        pFactory = new CClassFactory(CClassFactory::ABOUT);
    
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}


CClassFactory::CClassFactory(FACTORY_TYPE factoryType)
: m_cref(0), m_factoryType(factoryType)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    if (COMPONENT == m_factoryType) {
        pObj = new CComponentData();
    } else {
        pObj = new CSnapinAbout();
    }
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    
    if (FAILED(hr))
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{
    HRESULT hr = SELFREG_E_CLASS;
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName));
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, sizeof(szSnapInName));
    
    _TCHAR szAboutName[256];
    
    LoadString(g_hinst, IDS_ABOUTNAME, szAboutName, sizeof(szAboutName));
    
    // register our CoClasses
    hr = RegisterServer(g_hinst, 
        CLSID_CComponentData, 
        szName);
    
    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst, 
        CLSID_CSnapinAbout, 
        szAboutName);
    
    // place the registry information for SnapIns
    if SUCCEEDED(hr)
        hr = RegisterSnapin(CLSID_CComponentData, szSnapInName, CLSID_CSnapinAbout, FALSE);
    
    return hr;
}


STDAPI DllUnregisterServer()
{
    if (UnregisterServer(CLSID_CComponentData) == S_OK)
        return UnregisterSnapin(CLSID_CComponentData);
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\basesnap.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#ifndef _BASESNAP_H_
#define _BASESNAP_H_

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);
STDAPI DllCanUnloadNow(void);

ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    enum FACTORY_TYPE {COMPONENT = 0, ABOUT = 1};
    
    CClassFactory(FACTORY_TYPE factoryType);
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
private:
    FACTORY_TYPE m_factoryType;
};

#endif _BASESNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\menubtn\sky.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SKY_H
#define _SKY_H

#include "DeleBase.h"

class CSkyBasedVehicle : public CDelegationBase {
public:
    CSkyBasedVehicle() { }
    
    virtual ~CSkyBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Sky-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SKYICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    
private:
    enum { IDM_NEW_SKY = 3 };
    
    // {2974380F-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _SKY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\menubtn\space.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SPACE_H
#define _SPACE_H

#include "DeleBase.h"
#include "CompData.h"

class CRocket : public CDelegationBase {
public:
    CRocket();
    
    virtual ~CRocket();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
    void Initialize(_TCHAR *szName, LONG lWeight, LONG lHeight, LONG lPayload);
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnMenuButtonCommand(IConsole *pConsole, int nMenuId, long lCommandID);
    virtual HMENU   GetMenu(int nMenuId);
    virtual HRESULT SetMenuState(IControlbar *pControlbar, IMenuButton *pMenuButton, 
        BOOL bScope, BOOL bSelect);
    virtual HRESULT OnSetMenuButton(IConsole *pConsole, MENUBUTTONDATA *pmbd);
    
private:
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    _TCHAR *szName;
    LONG   lWeight;
    LONG   lHeight;
    LONG   lPayload;
    enum {RUNNING, PAUSED, STOPPED} iStatus;
};

class CSpaceVehicle : public CDelegationBase {
public:
    CSpaceVehicle();
    
    virtual ~CSpaceVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Future Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    enum { IDM_NEW_SPACE = 4 };
    
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CRocket *children[NUMBER_OF_CHILDREN];
};

#endif // _SPACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\compdata.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMPDATA_H_
#define _SAMPCOMPDATA_H_

#include <mmc.h>
#include "DeleBase.h"
#include "StatNode.h"
#include "Comp.h"

class CComponentData : public IComponentData
{
    friend class CComponent;
    
private:
    ULONG				m_cref;
    LPCONSOLE			m_ipConsole;
    LPCONSOLENAMESPACE	m_ipConsoleNameSpace;
    
    CStaticNode     *m_pStaticNode;
    
public:
    CComponentData();
    ~CComponentData();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IComponentData
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
        /* [in] */ LPUNKNOWN pUnknown);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent( 
        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
        /* [in] */ LPDATAOBJECT lpDataObject,
        /* [in] */ MMC_NOTIFY_TYPE event,
        /* [in] */ LPARAM arg,
        /* [in] */ LPARAM param);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
        /* [in] */ MMC_COOKIE cookie,
        /* [in] */ DATA_OBJECT_TYPES type,
        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
        /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
        /* [in] */ LPDATAOBJECT lpDataObjectA,
        /* [in] */ LPDATAOBJECT lpDataObjectB);
};

#endif _SAMPCOMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\delebase.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DeleBase.h"

const GUID CDelegationBase::thisGuid = { 0x2974380b, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

HBITMAP CDelegationBase::m_pBMapSm = NULL;
HBITMAP CDelegationBase::m_pBMapLg = NULL;


//==============================================================
//
// CDelegationBase implementation
//
//
CDelegationBase::CDelegationBase() 
: bExpanded(FALSE), m_handle(NULL)
{ 
    if (NULL == m_pBMapSm || NULL == m_pBMapLg)
        LoadBitmaps(); 
}

CDelegationBase::~CDelegationBase() 
{ 
}

// CDelegationBase::AddImages sets up the collection of images to be displayed
// by the IComponent in the result pane as a result of its MMCN_SHOW handler
HRESULT CDelegationBase::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi) 
{
    return pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <mmc.h>
#include <tchar.h>

#ifndef STRINGS_ONLY
		
		enum UPDATE_VIEWS_HINT {UPDATE_SCOPEITEM = 1000, DELETE_SCOPEITEM, UPDATE_RESULTITEM, DELETE_RESULTITEM}; 
		enum ITEM_TYPE {SCOPE = 10, RESULT}; 

        #define IDM_BUTTON1    0x100
        #define IDM_BUTTON2    0x101

        extern HINSTANCE g_hinst;
        extern ULONG g_uObjects;

        #define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
        #define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

        // uncomment the following #define to enable message cracking
        // #define MMC_CRACK_MESSAGES
        void MMCN_Crack(BOOL bComponentData,
                                        IDataObject *pDataObject,
                                        IComponentData *pCompData,
                                        IComponent *pComp,
                                        MMC_NOTIFY_TYPE event,
                                        LPARAM arg,
                                        LPARAM param);
#endif

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(GetProcessHeap(), 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(GetProcessHeap(), 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given a _TCHAR, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszT;
//  pszT = MyGetTStringRoutine();
//  MAKE_WIDEPTR_FROMSTR(pwsz, pszT);
//  MyUseWideStringRoutine(pwsz);
//  ...
#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPWSTR)__TempBuffer##ptrname.GetBuffer(), tstr); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    lstrcpyW((LPWSTR)ptrname, tstr)
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, ptrname, __l##ptrname)
#endif

//
// similarily for MAKE_TSTRPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
// * 2 for DBCS handling in below length computation
//
#ifdef UNICODE
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPTSTR)__TempBuffer##ptrname.GetBuffer(), widestr); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\land.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Land.h"

const GUID CLandBasedVehicle::thisGuid = { 0x2974380e, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CLandBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\land.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _LAND_H
#define _LAND_H

#include "DeleBase.h"

class CLandBasedVehicle : public CDelegationBase {
public:
    CLandBasedVehicle() { }
    
    virtual ~CLandBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Land-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_LANDICON; }
    
private:
    enum { IDM_NEW_LAND = 2 };
    
    // {2974380E-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};


#endif // _LAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5
#define INDEX_BACKGROUND    6
#define INDEX_STATION       7

#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\comp.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMP_H_
#define _SAMPCOMP_H_

#include <mmc.h>
#include "DataObj.h"

class CComponent : public IComponent, IResultOwnerData
{
private:
    ULONG				m_cref;
    
    IConsole          *m_ipConsole;
    
	class CComponentData *m_pParent;
    class CDelegationBase *m_pLastNode;
    
    public:
        CComponent(CComponentData *pParent);
        ~CComponent();
        
        ///////////////////////////////
        // Interface IUnknown
        ///////////////////////////////
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        
        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ MMC_COOKIE cookie);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);

        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindItem( 
            /* [in] */ LPRESULTFINDINFO pFindInfo,
            /* [out] */ int __RPC_FAR *pnFoundIndex);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CacheHint( 
            /* [in] */ int nStartIndex,
            /* [in] */ int nEndIndex);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SortItems( 
            /* [in] */ int nColumn,
            /* [in] */ DWORD dwSortOptions,
            /* [in] */ LPARAM lUserParam);
		
		///////////////////////////////////////////
        // Special code for handling multiselection
        ///////////////////////////////////////////
	public:
		HRESULT GetCurrentSelections(CDataObject *pMultiSelectDataObject);
		void DisplayMessageBox(CDelegationBase *base);		
};

#endif _SAMPCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\compdata.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "CompData.h"
#include "DataObj.h"
#include "resource.h"
#include <crtdbg.h>

CComponentData::CComponentData()
: m_cref(0), m_ipConsoleNameSpace(NULL), m_ipConsole(NULL)
{
    OBJECT_CREATED

        m_pStaticNode = new CStaticNode;
}

CComponentData::~CComponentData()
{
    if (m_pStaticNode) {
        delete m_pStaticNode;
    }

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CComponentData::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_IComponentData))
        *ppv = static_cast<IComponentData *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponentData::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponentData::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }

    return m_cref;
}

///////////////////////////////
// Interface IComponentData
///////////////////////////////
HRESULT CComponentData::Initialize(
                                   /* [in] */ LPUNKNOWN pUnknown)
{
    HRESULT      hr;

    //
    // Get pointer to name space interface
    //
    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (void **)&m_ipConsoleNameSpace);
    _ASSERT( S_OK == hr );

    //
    // Get pointer to console interface
    //
    hr = pUnknown->QueryInterface(IID_IConsole, (void **)&m_ipConsole);
    _ASSERT( S_OK == hr );

    IImageList *pImageList;
    m_ipConsole->QueryScopeImageList(&pImageList);
    _ASSERT( S_OK == hr );

    hr = pImageList->ImageListSetStrip( (long *)m_pStaticNode->m_pBMapSm, // pointer to a handle
        (long *)m_pStaticNode->m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );

    pImageList->Release();

    return S_OK;
}

HRESULT CComponentData::CreateComponent(
                                        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent)
{
    *ppComponent = NULL;

    CComponent *pComponent = new CComponent(this);

    if (NULL == pComponent)
        return E_OUTOFMEMORY;

    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent);
}

HRESULT CComponentData::Notify(
                               /* [in] */ LPDATAOBJECT lpDataObject,
                               /* [in] */ MMC_NOTIFY_TYPE event,
                               /* [in] */ LPARAM arg,
                               /* [in] */ LPARAM param)
{
    MMCN_Crack(TRUE, lpDataObject, this, NULL, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)
    {
    case MMCN_EXPAND:
        hr = base->OnExpand(m_ipConsoleNameSpace, m_ipConsole, (HSCOPEITEM)param);
        break;

    case MMCN_ADD_IMAGES:
        hr = base->OnAddImages((IImageList *)arg, (HSCOPEITEM)param);
        break;
    }

    return hr;
}

HRESULT CComponentData::Destroy( void)
{
    // Free interfaces
    if (m_ipConsoleNameSpace) {
        m_ipConsoleNameSpace->Release();
        m_ipConsoleNameSpace = NULL;
    }

    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}

HRESULT CComponentData::QueryDataObject(
                                        /* [in] */ MMC_COOKIE cookie,
                                        /* [in] */ DATA_OBJECT_TYPES type,
                                        /* [out] */ LPDATAOBJECT *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

HRESULT CComponentData::GetDisplayInfo(
                                       /* [out][in] */ SCOPEDATAITEM *pScopeDataItem)
{
    HRESULT hr = S_FALSE;

    // if they are asking for the SDI_STR we have one of those to give
    if (pScopeDataItem->lParam) {
        CDelegationBase *base = (CDelegationBase *)pScopeDataItem->lParam;
        if (pScopeDataItem->mask & SDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName();
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pScopeDataItem->displayname = pszW;
        }

        if (pScopeDataItem->mask & SDI_IMAGE) {
            pScopeDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}

HRESULT CComponentData::CompareObjects(
                                       /* [in] */ LPDATAOBJECT lpDataObjectA,
                                       /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\dataobj.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPDATAOBJECT_H_
#define _SAMPDATAOBJECT_H_

#include <mmc.h>
#include "DeleBase.h"

class CDataObject : public IDataObject
{
private:
    ULONG				m_cref;
    MMC_COOKIE			m_lCookie;
    DATA_OBJECT_TYPES   m_context;
    
public:
    CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context);
    ~CDataObject();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // IDataObject methods 
    ///////////////////////////////
    STDMETHODIMP GetDataHere (FORMATETC *pformatetc, STGMEDIUM *pmedium);
    STDMETHODIMP GetData (LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);

    // The rest are not implemented
    //  STDMETHODIMP GetData (LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
	//  { return E_NOTIMPL; };
    
    STDMETHODIMP EnumFormatEtc (DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };
    
    STDMETHODIMP QueryGetData (LPFORMATETC lpFormatetc) 
    { return E_NOTIMPL; };
    
    STDMETHODIMP GetCanonicalFormatEtc (LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    
    STDMETHODIMP SetData (LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DAdvise (LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DUnadvise (DWORD dwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumDAdvise (LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };
    
    ///////////////////////////////
    // Custom Methods and Data
    ///////////////////////////////
    
    CDelegationBase *GetBaseNodeObject() {
        return (CDelegationBase *)m_lCookie;
    }
    
    DATA_OBJECT_TYPES GetContext() {
        return m_context;
    }
    
	MMC_COOKIE GetCookie() { return m_lCookie; }

	void AddMultiSelectCookie(int nIndexCookies, LPARAM lParam ) { pCookies[nIndexCookies] = (MMC_COOKIE)lParam; }
	MMC_COOKIE GetMultiSelectCookie(int n) { return pCookies[n]; }

private:
    enum { MAX_COOKIES = 20 }; // MAX_COOKIES == MAX_CHILDREN declared
							   // in CSpaceStation class
    MMC_COOKIE* pCookies;

public:
    // clipboard formats
    static UINT s_cfSZNodeType;
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
    static UINT s_cfInternal;
	static UINT s_cfMultiSelect;		
    
};

HRESULT ExtractFromDataObject(IDataObject *lpDataObject,UINT cf,ULONG cb,HGLOBAL *phGlobal);
CDataObject* GetOurDataObject(IDataObject *lpDataObject);
BOOL IsMMCMultiSelectDataObject(IDataObject *lpDataObject);

#endif _SAMPDATAOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\comp.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "CompData.h"
#include "Space.h"
#include "DataObj.h"
#include <commctrl.h>       // Needed for button styles...
#include <crtdbg.h>
#include <stdio.h>		   	// needed for _stprintf 
#include "globals.h"
#include "resource.h"
#include "DeleBase.h"
#include "CompData.h"

CComponent::CComponent(CComponentData *pParent)
: m_pParent(pParent), m_cref(0), m_ipConsole(NULL), m_pLastNode(NULL)
{
    OBJECT_CREATED
}

CComponent::~CComponent()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IComponent))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IResultOwnerData))
        *ppv = static_cast<IResultOwnerData *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponent::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponent::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface IComponent
///////////////////////////////
STDMETHODIMP CComponent::Initialize(
                                    /* [in] */ LPCONSOLE lpConsole)
{
    HRESULT hr = S_OK;

    // Save away all the interfaces we'll need.
    // Fail if we can't QI the required interfaces.

    m_ipConsole = lpConsole;
    m_ipConsole->AddRef();

    return hr;
}

STDMETHODIMP CComponent::Notify(
                                /* [in] */ LPDATAOBJECT lpDataObject,
                                /* [in] */ MMC_NOTIFY_TYPE event,
                                /* [in] */ LPARAM arg,
                                /* [in] */ LPARAM param)
{
    MMCN_Crack(FALSE, lpDataObject, NULL, this, event, arg, param);

    HRESULT hr = S_FALSE;

	// MMCN_VIEW_CHANGE

	if (MMCN_VIEW_CHANGE == event) {	
		switch (param) {//arg holds the data. For a scope item, this is the
						//item's HSCOPEITEM. For a result item, this is
						//the item's nId value, but we don't use it

						//param holds the hint passed to IConsole::UpdateAllViews.
						//hint is a value of the UPDATE_VIEWS_HINT enumeration
		
			case UPDATE_SCOPEITEM:
				hr = m_ipConsole->SelectScopeItem( (HSCOPEITEM)arg );
				_ASSERT( S_OK == hr);
				break;
			case UPDATE_RESULTITEM:
				CDelegationBase *base = GetOurDataObject(lpDataObject)->GetBaseNodeObject();
				hr = base->OnUpdateItem(m_ipConsole, (long)arg, RESULT);
				break;
		}

		return S_OK;
	}

	//Remaining notifications

	CDelegationBase *base = GetOurDataObject(lpDataObject)->GetBaseNodeObject();

    switch (event)
	{
    case MMCN_SHOW:
        hr = base->OnShow(m_ipConsole, (BOOL)arg, (HSCOPEITEM)param);
        break;

    case MMCN_ADD_IMAGES:
        hr = base->OnAddImages((IImageList *)arg, (HSCOPEITEM)param);
        break;

    case MMCN_SELECT:
		
		//check for multiselection
		if ( MMC_MULTI_SELECT_COOKIE == GetOurDataObject(lpDataObject)->GetCookie() )	
		{
			if ( (BOOL)LOWORD(arg) == 0 && (BOOL)HIWORD(arg) == 1 ) 
			{
				//We need the cookie of any of the multiselection items
				//to enable the delete verb for all the items.
				MMC_COOKIE ourCookie = GetOurDataObject(lpDataObject)->GetMultiSelectCookie(0);

				base = reinterpret_cast<CDelegationBase *>(ourCookie);
				hr = base->OnSelect(m_ipConsole, (BOOL)LOWORD(arg), (BOOL)HIWORD(arg));		
			}

			return hr;				
		}
        
		else
			hr = base->OnSelect(m_ipConsole, (BOOL)LOWORD(arg), (BOOL)HIWORD(arg));
        break;

    case MMCN_REFRESH:
		hr = base->OnRefresh(m_pParent->m_ipConsole);
        break;

    case MMCN_DELETE:

		//check for multiselection. if true, delete each item
		if ( MMC_MULTI_SELECT_COOKIE == GetOurDataObject(lpDataObject)->GetCookie()	)
		{
			
			int n = 0;
			MMC_COOKIE ourCookie;

			while ( ourCookie = GetOurDataObject(lpDataObject)->GetMultiSelectCookie(n) )
			{
				base = reinterpret_cast<CDelegationBase *>(ourCookie);
				hr = base->OnDelete(m_ipConsole);	
				n++;
				//Uncomment the following line to display a message box
				//for each item deletion.
				//DisplayMessageBox(base);
			}
		}
		
		else
		{	
			//select item deletion
			hr = base->OnDelete(m_ipConsole);
		}

		//Now call IConsole::UpdateAllViews to redraw all views
		//owned by the parent scope item. OnRefresh already does
		//this for us, so use it.
		//Do this for both multiselection and single selection
		hr = base->OnRefresh(m_pParent->m_ipConsole);

		break;

    case MMCN_RENAME:
        hr = base->OnRename((LPOLESTR)param);
		
		//Now call IConsole::UpdateAllViews to redraw the item in all views.
		hr = m_pParent->m_ipConsole->UpdateAllViews(lpDataObject, 0, UPDATE_RESULTITEM);
		_ASSERT( S_OK == hr);
				
		break;

    }//end switch

    return hr;
}

STDMETHODIMP CComponent::Destroy(
                                 /* [in] */ MMC_COOKIE cookie)
{
    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}


STDMETHODIMP CComponent::QueryDataObject(
                                         /* [in] */ MMC_COOKIE cookie,
                                         /* [in] */ DATA_OBJECT_TYPES type,
                                         /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject)
{
    HRESULT hr;

	CDataObject *pObj = NULL;
    CDelegationBase *pBase = NULL;

		//Use The IS_SPECIAL_COOKIE macro to see if cookie is a special cookie
		if ( IS_SPECIAL_COOKIE (cookie) ) {
			if ( MMC_MULTI_SELECT_COOKIE == cookie) {

			pObj = new CDataObject(cookie, type);

			if (!pObj)
				return E_OUTOFMEMORY;

			//create the multiselection data object
			hr = GetCurrentSelections(pObj);
			_ASSERT( SUCCEEDED(hr) ); 

			hr = pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);
			_ASSERT( SUCCEEDED(hr) ); 

			return hr;

			}
		}
		
		//Remaining code for "regular" cookies, and for the next item
		//during a multiselection

        if (IsBadReadPtr((void *)cookie, sizeof(CDelegationBase))) {
                if (NULL == m_pLastNode)
                        return E_FAIL;

                pBase = m_pLastNode->GetChildPtr((int)cookie);
        } else {
                pBase = (cookie == 0) ? m_pParent->m_pStaticNode : (CDelegationBase *)cookie;
        }

        if (pBase == NULL)
                return E_FAIL;

    pObj = new CDataObject((MMC_COOKIE)pBase, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

STDMETHODIMP CComponent::GetResultViewType(
                                           /* [in] */ MMC_COOKIE cookie,
                                           /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
                                           /* [out] */ long __RPC_FAR *pViewOptions)
{
    CDelegationBase *base = m_pLastNode = (CDelegationBase *)cookie;

    //
    // Ask for default listview.
    //
    if (base == NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
        *ppViewType = NULL;
    }
    else
        return base->GetResultViewType(ppViewType, pViewOptions);

    return S_OK;
}

STDMETHODIMP CComponent::GetDisplayInfo(
                                        /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem)
{
    HRESULT hr = S_OK;
    CDelegationBase *base = NULL;

    // if they are asking for the RDI_STR we have one of those to give

    if (pResultDataItem->lParam) {
        base = (CDelegationBase *)pResultDataItem->lParam;
        if (pResultDataItem->mask & RDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName(pResultDataItem->nCol);
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pResultDataItem->str = pszW;
        }

        if (pResultDataItem->mask & RDI_IMAGE) {
            pResultDataItem->nImage = base->GetBitmapIndex();
        }
    } else {
        m_pLastNode->GetChildColumnInfo(pResultDataItem);
    }

    return hr;
}


STDMETHODIMP CComponent::CompareObjects(
                                        /* [in] */ LPDATAOBJECT lpDataObjectA,
                                        /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////
// Interface IComponent
///////////////////////////////
STDMETHODIMP CComponent::FindItem(
/* [in] */ LPRESULTFINDINFO pFindInfo,
/* [out] */ int __RPC_FAR *pnFoundIndex)
{
    return E_NOTIMPL;
}

STDMETHODIMP CComponent::CacheHint(
/* [in] */ int nStartIndex,
/* [in] */ int nEndIndex)
{
    return E_NOTIMPL;
}

STDMETHODIMP CComponent::SortItems(
/* [in] */ int nColumn,
/* [in] */ DWORD dwSortOptions,
/* [in] */ LPARAM lUserParam)
{
    return E_NOTIMPL;
}


///////////////////////////////////////////
// GetCurrentSelections() finds the currently
// selected result items and the data object
// passed to it with their cookie values.
// The multi-select cookie is cached so that
// we don't have to calculate multiselection
// dataobject for other notifications.
// It is destroyed at appropriate time.
///////////////////////////////////////////

HRESULT CComponent::GetCurrentSelections(CDataObject *pMultiSelectDataObject)
{

	HRESULT hr = S_FALSE;

	//GetCurrentSelections only works for multiselection data objects
	if ( !( MMC_MULTI_SELECT_COOKIE == GetOurDataObject(pMultiSelectDataObject)->GetCookie() ) )
		return hr = E_INVALIDARG;
	
	IResultData *pResultData = NULL;

	hr = m_ipConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
	_ASSERT( SUCCEEDED(hr) );	

    RESULTDATAITEM rdi;
	
	BOOL isLastSelected = FALSE;
	int nIndex = -1;
	int nIndexCookies = 0;

	while (!isLastSelected)
	{
		ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
		rdi.mask	= RDI_STATE;		// nState is valid 
		rdi.nCol	= 0;
		rdi.nIndex  = nIndex;			// nIndex == -1 to start at first item
		rdi.nState  = LVIS_SELECTED;	// only interested in selected items


		hr = pResultData->GetNextItem(&rdi);
		_ASSERT( SUCCEEDED(hr) ); 

		if (rdi.nIndex != -1) {

			//rdi is the RESULTDATAITEM of a selected item. add its
			//lParam to the pCookies array of the pMultiSelectDataObject data object
			
			_ASSERT( nIndexCookies < 20 ); // MAX_COOKIES == 20
			pMultiSelectDataObject->AddMultiSelectCookie(nIndexCookies, rdi.lParam);
			nIndexCookies++;
			nIndex = rdi.nIndex;
		}

		else 
			isLastSelected = TRUE;

	}

	pResultData->Release();
	
	return hr;

}

void CComponent::DisplayMessageBox(CDelegationBase* base)
{

   _TCHAR szVehicle[128];
    static _TCHAR buf[128];

	_stprintf(buf, _T("%s"), base->GetDisplayName() );

	wsprintf(szVehicle, _T("%s deleted"), buf);

	int ret = 0;
	MAKE_WIDEPTR_FROMTSTR_ALLOC(wszVehicle, szVehicle);
	m_ipConsole->MessageBox(wszVehicle,
		 L"Vehicle command", MB_OK | MB_ICONINFORMATION, &ret);

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\mmccrack.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

static TCHAR *MMCN_CrackVerb(MMC_CONSOLE_VERB verb)
{
        static TCHAR error[64];

        switch (verb) {
    case MMC_VERB_NONE:
                return _T("NONE");
    case MMC_VERB_OPEN:
                return _T("OPEN");
    case MMC_VERB_COPY:
                return _T("COPY");
    case MMC_VERB_PASTE:
                return _T("PASTE");
    case MMC_VERB_DELETE:
                return _T("DELETE");
    case MMC_VERB_PROPERTIES:
                return _T("PROPERTIES");
    case MMC_VERB_RENAME:
                return _T("RENAME");
    case MMC_VERB_REFRESH:
                return _T("REFRESH");
    case MMC_VERB_PRINT:
                return _T("PRINT");
    case MMC_VERB_CUT:
                return _T("CUT");
        default:
                wsprintf(error, _T("Unknown verb id %d"), verb);
                return error;
        }
}

void MMCN_Crack(BOOL bComponentData,
                IDataObject *pDataObject,
                                IComponentData *pCompData,
                                IComponent *pComp,
                MMC_NOTIFY_TYPE event,
                                LPARAM arg,
                                LPARAM param)
{
#ifdef MMC_CRACK_MESSAGES
        TCHAR message[256] = {0};

        if (bComponentData == TRUE)
                OutputDebugString(_T("IComponentData::Notify( "));
        else
                OutputDebugString(_T("IComponent::Notify( "));

        wsprintf(message, _T("DataObject: %08x, CompData: %08x, Comp: %08x ) - "), pDataObject, pCompData, pComp);
        OutputDebugString(message);

    switch (event)      {
                case MMCN_ACTIVATE:
                        wsprintf(message, _T("MMCN_ACTIVATE\n\tActivate: %d\n"), arg);
                        break;

                case MMCN_ADD_IMAGES:
                        wsprintf(message, _T("MMCN_ADD_IMAGES\n\tImage List: %08x\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_BTN_CLICK:
                        wsprintf(message, _T("MMCN_BTN_CLICK\n\tVerb: %ws\n"), MMCN_CrackVerb((MMC_CONSOLE_VERB)param));
                        break;

                case MMCN_COLUMN_CLICK:
                        wsprintf(message, _T("MMCN_COLUMN_CLICK\n\tColumn: %d\n\tSort Option: %d\n"), arg,       param);
                        break;

                case MMCN_COLUMNS_CHANGED:
                        wsprintf(message, _T("MMCN_COLUMNS_CHANGED\n"));
                        break;

                case MMCN_CONTEXTHELP:
                        wsprintf(message, _T("MMCN_CONTEXTHELP\n"));
                        break;

                case MMCN_CONTEXTMENU:
                        wsprintf(message, _T("MMCN_CONTEXTMENU\n"));
                        break;

                case MMCN_CUTORMOVE:
                        wsprintf(message, _T("MMCN_CUTORMOVE\n"));
                        break;

                case MMCN_DBLCLICK:
                        wsprintf(message, _T("MMCN_DBLCLICK\n"));
                        break;

                case MMCN_DELETE:
                        wsprintf(message, _T("MMCN_DELETE\n"));
                        break;

                case MMCN_DESELECT_ALL:
                        wsprintf(message, _T("MMCN_DESELECT_ALL\n"));
                        break;

                case MMCN_EXPAND:
                        wsprintf(message, _T("MMCN_EXPAND\n\tExpand: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_EXPANDSYNC:
                        wsprintf(message, _T("MMCN_EXPANDSYNC\n"));
                        break;

                case MMCN_FILTERBTN_CLICK:
                        wsprintf(message, _T("MMCN_FILTERBTN_CLICK\n\tColumn: %d\n"), arg);
                        break;

                case MMCN_FILTER_CHANGE:
                        wsprintf(message, _T("MMCN_FILTER_CHANGE\n\tColumn: %d\n"), param);
                        break;

                case MMCN_HELP:
                        wsprintf(message, _T("MMCN_HELP\n"));
                        break;

                case MMCN_INITOCX:
                        wsprintf(message, _T("MMCN_INITOCX\n\tIUnknown: %08x\n"), param);
                        break;

                case MMCN_LISTPAD:
                        wsprintf(message, _T("MMCN_LISTPAD\n\tConnect: %d\n"), arg);
                        break;

                case MMCN_MENU_BTNCLICK:
                        wsprintf(message, _T("MMCN_MENU_BTNCLICK\n"));
                        break;

                case MMCN_MINIMIZED:
                        wsprintf(message, _T("MMCN_MINIMIZED\n\tMinimized: %d\n"), arg);
                        break;

                case MMCN_PASTE:
                        wsprintf(message, _T("MMCN_PASTE\n\tCopy: %d\n"), param == NULL);
                        break;

                case MMCN_PRELOAD:
                        wsprintf(message, _T("MMCN_PRELOAD\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_PRINT:
                        wsprintf(message, _T("MMCN_PRINT\n"));
                        break;

                case MMCN_PROPERTY_CHANGE:
                        wsprintf(message, _T("MMCN_PROPERTY_CHANGE\n\tScope: %d\n\tArg: %08x\n"), arg, param);
                        break;

                case MMCN_QUERY_PASTE:
                        wsprintf(message, _T("MMCN_QUERY_PASTE\n"));
                        break;

                case MMCN_REFRESH:
                        wsprintf(message, _T("MMCN_REFRESH\n"));
                        break;

                case MMCN_REMOVE_CHILDREN:
                        wsprintf(message, _T("MMCN_REMOVE_CHILDREN\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_RENAME:
                        wsprintf(message, _T("MMCN_RENAME\n\tNew Name: '%ws'\n"), (LPOLESTR)param);
                        break;

                case MMCN_RESTORE_VIEW:
                        wsprintf(message, _T("MMCN_RESTORE_VIEW\n"));
                        break;

                case MMCN_SELECT:
                        wsprintf(message, _T("MMCN_SELECT\n\tScope: %d\n\tSelect: %08x\n"), LOWORD(arg), HIWORD(arg));
                        break;

                case MMCN_SHOW:
                        wsprintf(message, _T("MMCN_SHOW\n\tShow: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_SNAPINHELP:
                        wsprintf(message, _T("MMCN_SNAPINHELP\n"));
                        break;

                case MMCN_VIEW_CHANGE:
                        wsprintf(message, _T("MMCN_VIEW_CHANGE\n\tData: %08x\n\tHint: %08x\n"), arg, param);
                        break;
        }

        if (message[0] != 0)
                OutputDebugString(message);
        else
                OutputDebugString(_T("unknown event\n"));

#endif
        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\people.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _PEOPLE_H
#define _PEOPLE_H

#include "DeleBase.h"

class CBicycle : public CDelegationBase {
public:
    CBicycle(int i) : id(i) { }
    virtual ~CBicycle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CBicycleFolder : public CDelegationBase {
public:
    CBicycleFolder();
    virtual ~CBicycleFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Bicycles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CSkateboard : public CDelegationBase {
public:
    CSkateboard(int i) : id(i) { }
    virtual ~CSkateboard() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CSkateboardFolder : public CDelegationBase {
public:
    CSkateboardFolder();
    virtual ~CSkateboardFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Skateboards"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CIceSkate : public CDelegationBase {
public:
    CIceSkate(int i) : id(i) { }
    virtual ~CIceSkate() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CIceSkateFolder : public CDelegationBase {
public:
    CIceSkateFolder();
    virtual ~CIceSkateFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Ice Skates"); }
    virtual void GetChildColumnInfo(RESULTDATAITEM *rdi);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }

	virtual CDelegationBase *GetChildPtr(int index) { 
		return (index < NUMBER_OF_CHILDREN) ? children[index] : NULL;
	}

    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions);
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 5000 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CPeoplePoweredVehicle : public CDelegationBase {
public:
    CPeoplePoweredVehicle();
    virtual ~CPeoplePoweredVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("People-powered Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { IDM_NEW_PEOPLE = 1 };
    
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 3 };
    CDelegationBase *children[3];
};

#endif // _PEOPLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\registry.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions = FALSE);

HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Resource.rc
//
#define IDS_HELPFILE                    1
#define IDS_SNAPINDESC                  2
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDI_ICON1                       108
#define IDB_SMOPEN                      111
#define IDB_SMBMP                       112
#define IDB_LGBMP                       113
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDB_ROCKET                      40004
#define IDB_CAR                         40005
#define IDB_PLANE                       40006
#define IDB_BIKE                        40007
#define IDB_ROCKET2                     40008
#define IDB_CAR2                        40009
#define IDB_PLANE2                      40010
#define IDB_BIKE2                       40011
#define IDB_CLOSED2                     40012
#define IDB_OPEN2                       40013
#define IDB_CLOSED                      40014
#define IDB_OPEN                        40015

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        114
#define _APS_NEXT_COMMAND_VALUE         40016
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\delebase.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _BRANCHES_H
#define _BRANCHES_H

#include <mmc.h>
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "LocalRes.h"

class CComponentData;

class CDelegationBase {
public:
    CDelegationBase();
    virtual ~CDelegationBase();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) = 0;
    virtual void GetChildColumnInfo(RESULTDATAITEM *rdi) { }
    virtual const GUID & getNodeType() { _ASSERT(FALSE); return IID_NULL; }
    
    virtual const LPARAM GetCookie() { return reinterpret_cast<LPARAM>(this); }
    virtual const int GetBitmapIndex() = 0;

	virtual CDelegationBase *GetChildPtr(int index) { return NULL; }
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions) { return S_FALSE; }

	virtual HRESULT SelectItem(IConsole *pConsole) 
	{
		return pConsole->SelectScopeItem(HSCOPEITEM(m_handle));
	}
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent) { return S_FALSE; }
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem) { return S_FALSE; }
    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect) { return S_FALSE; }
    virtual HRESULT OnRefresh(IConsole *pConsole) { return S_FALSE; }
	virtual HRESULT OnUpdateItem(IConsole *pConsole, long item, ITEM_TYPE itemtype) { return S_FALSE; }
    virtual HRESULT OnRename(LPOLESTR pszNewName) { return S_FALSE; }

	virtual HRESULT OnDelete(IConsole *pConsole) { return S_FALSE; }

public:
    static HBITMAP m_pBMapSm;
    static HBITMAP m_pBMapLg;

	HANDLE GetHandle() { return m_handle; }
	void SetHandle(HANDLE handle) { m_handle = handle; }
    
protected:
    static void LoadBitmaps() {
        m_pBMapSm = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_SMICONS));
        m_pBMapLg = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_LGICONS));
    }
    
    BOOL bExpanded;
    
private:
    // {2974380B-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
	HANDLE m_handle;
};

#endif // _BRANCHES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\sky.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Sky.h"

const GUID CSkyBasedVehicle::thisGuid = { 0x2974380f, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSkyBasedVehicle implementation
//
//
HRESULT CSkyBasedVehicle::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
	HRESULT hr;
	IUnknown *pUnk = NULL;
	IMessageView *pMessageView = NULL;

	hr = pConsole->QueryResultView(&pUnk);

	if (SUCCEEDED(hr)) {
		hr = pUnk->QueryInterface(IID_IMessageView, (void **)&pMessageView);

		if (SUCCEEDED(hr)) {
			pMessageView->SetIcon(Icon_Information);
			pMessageView->SetTitleText(L"Sky-based vehicles");
			pMessageView->SetBodyText(L"Sky-based vehicles have no child nodes.");

			pMessageView->Release();
		}

		pUnk->Release();
	}

	return S_FALSE;
}

HRESULT CSkyBasedVehicle::GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions)
{
    // error message control
	LPOLESTR lpOleStr = NULL;
	HRESULT hr = StringFromCLSID(CLSID_MessageView, &lpOleStr);
    *ppViewType = lpOleStr;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\dataobj.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DataObj.h"
#include "guids.h"
#include "DeleBase.h"
#include "Space.h"

//
// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SZNODETYPE _T("CCF_SZNODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")
#define _T_CCF_OBJECT_TYPES_IN_MULTI_SELECT  _T("CCF_OBJECT_TYPES_IN_MULTI_SELECT")

#define _T_CCF_INTERNAL_SNAPIN _T("{2479DB32-5276-11d2-94F5-00C04FB92EC2}")

    // These are the clipboard formats that we must supply at a minimum.
    // mmc.h actually defined these. We can make up our own to use for
    // other reasons. We don't need any others at this time.
UINT CDataObject::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CDataObject::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CDataObject::s_cfSZNodeType  = RegisterClipboardFormat(_T_CCF_SZNODETYPE);
UINT CDataObject::s_cfSnapinClsid = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);
UINT CDataObject::s_cfInternal    = RegisterClipboardFormat(_T_CCF_INTERNAL_SNAPIN);

//We must also supply a data object for CCF_OBJECT_TYPES_IN_MULTI_SELECT 
UINT CDataObject::s_cfMultiSelect = RegisterClipboardFormat(_T_CCF_OBJECT_TYPES_IN_MULTI_SELECT);


CDataObject::CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context)
: m_lCookie(cookie), m_context(context), m_cref(0)
{
	//Do the following if the data object is a multiselection data object

	if ( MMC_MULTI_SELECT_COOKIE == m_lCookie ) {

		pCookies = new MMC_COOKIE[MAX_COOKIES];

		for (int n = 0; n < MAX_COOKIES; n++) {
				pCookies[n] = NULL;
		}
	}
}

CDataObject::~CDataObject()
{
	//Do the following if the data object is a multiselection data object

	if ( MMC_MULTI_SELECT_COOKIE == m_lCookie ) 
		delete [] pCookies;
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IDataObject *>(this);
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppv = static_cast<IDataObject *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CDataObject::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
//
HRESULT CDataObject::GetDataHere(
                                 FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure
                                 STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure
                                 )
{
    const   CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pStream = NULL;

    CDelegationBase *base = GetBaseNodeObject();

    HRESULT hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( FAILED(hr) )
        return hr;                       // Minimal error checking

    hr = DV_E_FORMATETC;                 // Unknown format

    if (cf == s_cfDisplayName) {
        const _TCHAR *pszName = base->GetDisplayName();

                MAKE_WIDEPTR_FROMTSTR(wszName, pszName);

                // get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(pszName);
        ulSizeofName++;                      // Count null character
        ulSizeofName *= sizeof(WCHAR);

        hr = pStream->Write(wszName, ulSizeofName, NULL);
    } else if (cf == s_cfNodeType) {
        const GUID *pGUID = (const GUID *)&base->getNodeType();

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfSZNodeType) {
        LPOLESTR szGuid;
        hr = StringFromCLSID(base->getNodeType(), &szGuid);

        if (SUCCEEDED(hr)) {
            hr = pStream->Write(szGuid, wcslen(szGuid), NULL);
            CoTaskMemFree(szGuid);
        }
    } else if (cf == s_cfSnapinClsid) {
        const GUID *pGUID = NULL;
        pGUID = &CLSID_CComponentData;

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfInternal) {
        // we are being asked to get our this pointer from the IDataObject interface
        // only our own snap-in objects will know how to do this.
        CDataObject *pThis = this;
        hr = pStream->Write( &pThis, sizeof(CDataObject*), NULL );
    }

    pStream->Release();

    return hr;
}

HRESULT CDataObject::GetData (LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)

{
	
	HRESULT hr = S_FALSE;

    const   CLIPFORMAT cf = lpFormatetcIn->cfFormat;

    CDelegationBase *base = GetBaseNodeObject();

    if (cf == s_cfMultiSelect) {
    // MMC requires support for this format to load any extensions
	// that extend the selected result items
		
		BYTE byData[256] = {0};
		SMMCObjectTypes* pData = reinterpret_cast<SMMCObjectTypes*>(byData);

		//We need the node type GUID of the selected items.
		//from CRocket::thisGuid
		GUID guid = { 0x29743811, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };
	
		//Enter data required for the SMMCObjectTypes structure
        //count specifies the number of unique node types in the multiselection
        //Here, all CRocket items are of the same node type, so count == 1.
		pData->count = 1;
		pData->guid[0] = guid;		

		// Calculate the size of SMMCObjectTypes.
		int cb = sizeof(GUID)*(pData->count) + sizeof (SMMCObjectTypes);
		
		//Fill out parameters
		
		lpMedium->tymed = TYMED_HGLOBAL; 
		lpMedium->hGlobal = ::GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE, cb);
		if (lpMedium->hGlobal == NULL)
			return STG_E_MEDIUMFULL;

		BYTE* pb = reinterpret_cast<BYTE*>(::GlobalLock(lpMedium->hGlobal));
		CopyMemory(pb, pData, cb);
		::GlobalUnlock(lpMedium->hGlobal);

		hr = S_OK;		

	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Global helper functions to help work with dataobjects and
// clipboard formats


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfInternal clipboard format
//
CDataObject* GetOurDataObject (
                               LPDATAOBJECT lpDataObject      // [in] IComponent pointer
                               )
{
    HRESULT       hr      = S_OK;
    CDataObject *pSDO     = NULL;

	// check to see if the data object is a special data object.
	if ( IS_SPECIAL_DATAOBJECT (lpDataObject) )
	{
		//Code for handling a special data object goes here.

		//Note that the MMC SDK samples do not handle
		//special data objects, so we exit if we get one.
		return NULL;
	}

    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { CDataObject::s_cfInternal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(CDataObject *));

    if (!stgmedium.hGlobal)     {
        hr = E_OUTOFMEMORY;
    }

    if SUCCEEDED(hr)
        // Attempt to get data from the object
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );

    // stgmedium now has the data we need
    if (SUCCEEDED(hr))  {
        pSDO = *(CDataObject **)(stgmedium.hGlobal);
    }

    // if we have memory free it
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);

    return pSDO;

} // end GetOurDataObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\guids.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;


// {C3D863FF-5135-4cfc-8C11-E7396DA15D03}
DEFINE_GUID(CLSID_CComponentData, 
0xc3d863ff, 0x5135, 0x4cfc, 0x8c, 0x11, 0xe7, 0x39, 0x6d, 0xa1, 0x5d, 0x3);

// {7F5AAE1A-0021-46b7-96E3-FE5D16304BE9}
DEFINE_GUID(CLSID_CSnapinAbout, 
0x7f5aae1a, 0x21, 0x46b7, 0x96, 0xe3, 0xfe, 0x5d, 0x16, 0x30, 0x4b, 0xe9);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\sky.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SKY_H
#define _SKY_H

#include "DeleBase.h"

class CSkyBasedVehicle : public CDelegationBase {
public:
    CSkyBasedVehicle() { }
    
    virtual ~CSkyBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Sky-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SKYICON; }

public:
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions);

private:
    enum { IDM_NEW_SKY = 3 };
    
    // {2974380F-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};


#endif // _SKY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nameext\about.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "About.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

CSnapinAbout::CSnapinAbout()
: m_cref(0)
{
    OBJECT_CREATED
        
        m_hSmallImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    m_hLargeImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_LGBMP), IMAGE_BITMAP, 32, 32, LR_LOADTRANSPARENT);
    
    m_hSmallImageOpen = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMOPEN), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    
    m_hAppIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ICON1));
}

CSnapinAbout::~CSnapinAbout()
{
    if (m_hSmallImage != NULL)
        FreeResource(m_hSmallImage);
    
    if (m_hLargeImage != NULL)
        FreeResource(m_hLargeImage);
    
    if (m_hSmallImageOpen != NULL)
        FreeResource(m_hSmallImageOpen);
    
    if (m_hAppIcon != NULL)
        FreeResource(m_hAppIcon);
    
    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;
    
    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CSnapinAbout::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<ISnapinAbout *>(this);
    else if (IsEqualIID(riid, IID_ISnapinAbout))
        *ppv = static_cast<ISnapinAbout *>(this);
    
    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSnapinAbout::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CSnapinAbout::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    return m_cref;
    
}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription( 
                                                /* [out] */ LPOLESTR *lpDescription)
{
    _TCHAR szDesc[MAX_PATH];
    
    LoadString(g_hinst, IDS_SNAPINDESC, szDesc, sizeof(szDesc));
    
    return AllocOleStr(lpDescription, szDesc);
}


STDMETHODIMP CSnapinAbout::GetProvider( 
                                       /* [out] */ LPOLESTR *lpName)
{
    return AllocOleStr(lpName, _T("Copyright  1998 Microsoft Corporation"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinVersion( 
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return AllocOleStr(lpVersion, _T("1.0"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinImage( 
                                          /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;
    
    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}


STDMETHODIMP CSnapinAbout::GetStaticFolderImage( 
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;
    
    *hSmallImageOpen = m_hSmallImageOpen;
    
    *cMask = RGB(0, 128, 128);
    
    if (*hSmallImage == NULL || *hLargeImage == NULL || *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}

// this allocates a chunk of memory using CoTaskMemAlloc and copies our chars into it
HRESULT CSnapinAbout::AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer)
{
	MAKE_WIDEPTR_FROMTSTR_ALLOC(wszStr, szBuffer);
	*lpDest = wszStr;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\statnode.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SNAPINBASE_H
#define _SNAPINBASE_H

#include "DeleBase.h"

class CStaticNode : public CDelegationBase {
public:
    CStaticNode();
    
    virtual ~CStaticNode();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { 
        static _TCHAR szDisplayName[256];
        LoadString(g_hinst, IDS_SNAPINNAME, szDisplayName, sizeof(szDisplayName));
        return szDisplayName; 
    }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_NONE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { NUMBER_OF_CHILDREN = 5 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
    
    // {2974380C-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};



#endif // _SNAPINBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nameext\about.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPABOUT_H_
#define _SAMPABOUT_H_

#include <tchar.h>
#include <mmc.h>

class CSnapinAbout : public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;
    
public:
    CSnapinAbout();
    ~CSnapinAbout();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
        /* [out] */ LPOLESTR *lpDescription);
        
        STDMETHODIMP GetProvider( 
        /* [out] */ LPOLESTR *lpName);
        
        STDMETHODIMP GetSnapinVersion( 
        /* [out] */ LPOLESTR *lpVersion);
        
        STDMETHODIMP GetSnapinImage( 
        /* [out] */ HICON *hAppIcon);
        
        STDMETHODIMP GetStaticFolderImage( 
        /* [out] */ HBITMAP *hSmallImage,
        /* [out] */ HBITMAP *hSmallImageOpen,
        /* [out] */ HBITMAP *hLargeImage,
        /* [out] */ COLORREF *cMask);
        
        ///////////////////////////////
        // Private Interface 
        ///////////////////////////////
private:
    HRESULT	CSnapinAbout::AllocOleStr(
        LPOLESTR *lpDest, 
        _TCHAR *szBuffer);
};

#endif _SAMPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\people.cpp ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#include <stdio.h>
#include "People.h"

const GUID CPeoplePoweredVehicle::thisGuid = { 0x2974380d, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

const GUID CBicycleFolder::thisGuid = { 0xef163732, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboardFolder::thisGuid = { 0xef163733, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkateFolder::thisGuid = { 0xf6c660b0, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };

const GUID CBicycle::thisGuid = { 0xef163734, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboard::thisGuid = { 0xef163735, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkate::thisGuid = { 0xf6c660b1, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };


//==============================================================
//
// CPeoplePoweredVehicle implementation
//
//
CPeoplePoweredVehicle::CPeoplePoweredVehicle()
{
    children[0] = new CBicycleFolder;
    children[1] = new CSkateboardFolder;
    children[2] = new CIceSkateFolder;
}

CPeoplePoweredVehicle::~CPeoplePoweredVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        delete children[n];
}

HRESULT CPeoplePoweredVehicle::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;

    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT    |   // relativeID is valid
                SDI_CHILDREN;     // cChildren is valid

            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = 0;

            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );

            _ASSERT( SUCCEEDED(hr) );

                    children[n]->SetHandle((HANDLE)sdi.ID);
        }
    }

    return S_OK;
}

CBicycleFolder::CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CBicycle(n + 1);
    }
}

CBicycleFolder::~CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CBicycleFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );

                            children[n]->SetHandle((HANDLE)rdi.itemID);
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

CIceSkateFolder::CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CIceSkate(n + 1);
    }
}

CIceSkateFolder::~CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CIceSkateFolder::GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions)
{
    *ppViewType = NULL;
    *pViewOptions = MMC_VIEW_OPTIONS_OWNERDATALIST;

    return S_OK;
}

void CIceSkateFolder::GetChildColumnInfo(RESULTDATAITEM *rdi)
{
    if (rdi->mask & RDI_STR)
    {
        LPCTSTR pszT = children[rdi->nIndex]->GetDisplayName(rdi->nCol);
        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
        rdi->str = pszW;
    }

    if (rdi->mask & RDI_IMAGE)
        rdi->nImage = children[rdi->nIndex]->GetBitmapIndex();
}

// CDelegationBase::AddImages sets up the collection of images to be displayed
// by the IComponent in the result pane as a result of its MMCN_SHOW handler
HRESULT CIceSkateFolder::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi)
{
    return pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}

HRESULT CIceSkateFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            hr = pResultData->SetItemCount( NUMBER_OF_CHILDREN, 0 );
            _ASSERT( SUCCEEDED(hr) );
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

CSkateboardFolder::CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CSkateboard(n + 1);
    }
}

CSkateboardFolder::~CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSkateboardFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                      ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );

                            children[n]->SetHandle((HANDLE)rdi.itemID);
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

const _TCHAR *CBicycle::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Bicycle #%d"), id);

    return buf;
}

const _TCHAR *CSkateboard::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Skateboard #%d"), id);

    return buf;
}

const _TCHAR *CIceSkate::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Ice Skate #%d"), id);

    return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\registry.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

#define STRINGS_ONLY
#include "globals.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName)       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule,
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;

    assert(dwResult != 0) ;

    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    assert(SUCCEEDED(hr)) ;

        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;
        _tcscat(szKey, pszCLSID) ;

    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;

    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    _tcscat(szKey, _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), _T("Apartment"));

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;


    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;

        MAKE_TSTRPTR_FROMWIDE(pszT, wszCLSID);
        _tcscat(szKey, pszT) ;

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Register the snap-in in the registry.
//
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,         // Class Id for About Class
                       const BOOL fSupportExtensions)
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    LPOLESTR wszAboutCLSID = NULL;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    if (IID_NULL != clsidAbout)
        hr = StringFromCLSID(clsidAbout, &wszAboutCLSID);

        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszAboutCLSID, wszAboutCLSID);


    // Add the CLSID to the registry.
    setSnapInKeyAndValue(pszCLSID, NULL, _T("NameString"), szNameString) ;
    setSnapInKeyAndValue(pszCLSID, _T("StandAlone"), NULL, NULL);
    if (IID_NULL != clsidAbout)
        setSnapInKeyAndValue(pszCLSID, NULL, _T("About"), pszAboutCLSID);

    if (fSupportExtensions) {
        // Build the key NodeType
        setSnapInKeyAndValue(pszCLSID, _T("NodeTypes"), NULL, NULL);

        _TCHAR szKey[64] ;
        _tcscpy(szKey, pszCLSID) ;
        _tcscat(szKey, _T("\\NodeTypes")) ;
        setSnapInKeyAndValue(szKey, pszCLSID, NULL, NULL);
    }

    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    if (IID_NULL != clsidAbout)
        CoTaskMemFree(wszAboutCLSID);

    return S_OK ;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    LPOLESTR wszCLSID = NULL;

    // Get CLSID
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\"));
    _tcscat(szKeyBuf, pszCLSID);

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // free the memory
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }

    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }

    // Close the child.
    RegCloseKey(hKeyChild) ;

    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\")) ;
    _tcscat(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\statnode.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "StatNode.h"

#include "Space.h"
#include "Sky.h"
#include "People.h"
#include "Land.h"
#include "Backgrnd.h"

const GUID CStaticNode::thisGuid = { 0x2974380c, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CStaticNode implementation
//
//
CStaticNode::CStaticNode()
{
    children[0] = new CPeoplePoweredVehicle;
    children[1] = new CLandBasedVehicle;
    children[2] = new CSkyBasedVehicle;
    children[3] = new CSpaceFolder;
    children[4] = new CBackgroundFolder;
}

CStaticNode::~CStaticNode()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }

	if (m_pBMapSm != NULL)
		DeleteObject(m_pBMapSm);

	if (m_pBMapLg != NULL)
		DeleteObject(m_pBMapLg);
}

HRESULT CStaticNode::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;
    
    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT    |
                SDI_CHILDREN;
            
            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];   // The cookie
            sdi.cChildren   = (n == 0 || n == 3);    // Only first and fourth
													 // children have child nodes
            
            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );
            
            _ASSERT( SUCCEEDED(hr) );

		    children[n]->SetHandle((HANDLE)sdi.ID);
        }
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\space.cpp ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#include <stdio.h>
#include "DataObj.h"
#include "Space.h"
#include "Comp.h"

const GUID CSpaceFolder::thisGuid = { 0x29743810, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };
const GUID CSpaceStation::thisGuid = { 0x62273a12, 0x1914, 0x11d3, { 0x9a, 0x38, 0x0, 0x80, 0xc7, 0x25, 0x80, 0x72 } };
const GUID CRocket::thisGuid = { 0x29743811, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSpaceFolder implementation
//
//
CSpaceFolder::CSpaceFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CSpaceStation();
    }
}

CSpaceFolder::~CSpaceFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSpaceFolder::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;

    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT    |
                SDI_CHILDREN;

            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = 0;

            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );

            _ASSERT( SUCCEEDED(hr) );

                    children[n]->SetHandle((HANDLE)sdi.ID);
        }
    }

    return S_OK;
}

//==============================================================
//
// CSpaceStation implementation
//
//
CSpaceStation::CSpaceStation()
{
    for (int n = 0; n < MAX_CHILDREN; n++) {
        children[n] = NULL;
    }

    for (n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CRocket(this, _T("Rocket"), n, 350115, 320, 52300);
    }
}

CSpaceStation::~CSpaceStation()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}


HRESULT CSpaceStation::GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions)
{
    *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;     
	return S_FALSE;
}

HRESULT CSpaceStation::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Rocket Class", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 1, L"Rocket Weight", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 2, L"Rocket Height", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 3, L"Rocket Payload", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 4, L"Status", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; NULL != children[n]; n++) {
				BOOL childDeleteStatus = children[n]->getDeletedStatus();				
				if ( !childDeleteStatus) {
						ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
						rdi.mask       = RDI_STR       |   // Displayname is valid
														 RDI_IMAGE     |
														 RDI_PARAM;        // nImage is valid

						rdi.nImage      = children[n]->GetBitmapIndex();
						rdi.str         = MMC_CALLBACK;
						rdi.nCol        = 0;
						rdi.lParam      = (LPARAM)children[n];

						hr = pResultData->InsertItem( &rdi );

						_ASSERT( SUCCEEDED(hr) );

						children[n]->SetHandle((HANDLE)rdi.itemID);
                 }
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

HRESULT CSpaceStation::OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect)
{
    IConsoleVerb *pConsoleVerb;

    HRESULT hr = pConsole->QueryConsoleVerb(&pConsoleVerb);
    _ASSERT(SUCCEEDED(hr));

    hr = pConsoleVerb->SetVerbState(MMC_VERB_PASTE, ENABLED, TRUE);

    pConsoleVerb->Release();

    return S_OK;
}

HRESULT CSpaceStation::OnUpdateItem(IConsole *pConsole, long item, ITEM_TYPE itemtype)

{
	HRESULT hr = S_OK;
	
	_ASSERT(item);
	_ASSERT(SCOPE == itemtype); 

	//refresh all result pane views
	hr = pConsole->SelectScopeItem( (HSCOPEITEM)item );
	_ASSERT( S_OK == hr);  

	return hr;
}


//==============================================================
//
// CRocket implementation
//
//
CRocket::CRocket(CSpaceStation *pSpaceStation, _TCHAR *szName, int id, LONG lWeight, LONG lHeight, LONG lPayload)
: m_pSpaceStation(pSpaceStation), szName(NULL), lWeight(0), lHeight(0), lPayload(0), iStatus(STOPPED)
{
    if (szName) {
        this->szName = new _TCHAR[(_tcslen(szName) + 1) * sizeof(_TCHAR)];
        _tcscpy(this->szName, szName);
    }

    this->nId = id;
    this->lWeight = lWeight;
    this->lHeight = lHeight;
    this->lPayload = lPayload;

	isDeleted = FALSE;
}

CRocket::~CRocket()
{
    if (szName)
        delete [] szName;
}

const _TCHAR *CRocket::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    switch (nCol) {
    case 0:
        _stprintf(buf, _T("%s (#%d)"), szName ? szName : _T(""), nId);
        break;

    case 1:
        _stprintf(buf, _T("%ld metric tons"), lWeight);
        break;

    case 2:
        _stprintf(buf, _T("%ld meters"), lHeight);
        break;

    case 3:
        _stprintf(buf, _T("%ld kilos"), lPayload);
        break;

    case 4:
        _stprintf(buf, _T("%s"),
            iStatus == RUNNING ? _T("running") :
        iStatus == PAUSED ? _T("paused") :
        iStatus == STOPPED ? _T("stopped") : _T("unknown"));
        break;

    }

    return buf;
}


HRESULT CRocket::OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect)
{
    IConsoleVerb *pConsoleVerb;

    HRESULT hr = pConsole->QueryConsoleVerb(&pConsoleVerb);
    _ASSERT(SUCCEEDED(hr));
	
	//MMC automatically disables rename verb during a multiselection
    hr = pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, TRUE);
    hr = pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);

    pConsoleVerb->Release();

    return S_OK;
}

HRESULT CRocket::OnRefresh(IConsole *pConsole)

{
	//Call IConsole::UpdateAllViews to redraw all views
	//owned by the parent scope item

	IDataObject *pDummy = NULL;
	HANDLE handle  = m_pSpaceStation->GetHandle();

	HRESULT hr;

	hr = pConsole->UpdateAllViews(pDummy, (long)handle, UPDATE_SCOPEITEM);
	_ASSERT( S_OK == hr);

	return hr;
}

HRESULT CRocket::OnDelete(IConsole *pConsole)
{

	_ASSERT( NULL != this );	
	
	HRESULT hr = S_OK;

	//Delete the item. The IConsole that is passed into DeleteChild
	//is from the child result item, so we can use it to QI for IResultData
	IResultData *pResultData = NULL;

	hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
	_ASSERT( SUCCEEDED(hr) );	

	HRESULTITEM childresultitem;
	
	_ASSERT( NULL != &childresultitem );	

    //lparam == this. See CSpaceVehicle::OnShow
    hr = pResultData->FindItemByLParam( (LPARAM)this, &childresultitem );
    if ( FAILED(hr) )
    {
        // Failed : Reason may be that current view does not have this item.
        // So exit gracefully.
        hr = S_FALSE;
    } else

    {
        hr = pResultData->DeleteItem( childresultitem, 0 );
        _ASSERT( SUCCEEDED(hr) );
    }
        
    pResultData->Release();
	

	//Now set child's isDeleted member to true so that the parent doesn't try to
	//to insert it again in CSpaceVehicle::OnShow. Admittedly, a hack...
	isDeleted = TRUE;

	return hr;
}

HRESULT CRocket::OnRename(LPOLESTR pszNewName)
{

	HRESULT hr = S_FALSE;
    
	if (szName) {
        delete [] szName;
        szName = NULL;
    }

    MAKE_TSTRPTR_FROMWIDE(ptrname, pszNewName);
    szName = new _TCHAR[(_tcslen(ptrname) + 1) * sizeof(_TCHAR)];
    _tcscpy(szName, ptrname);

    return hr;
}


HRESULT CRocket::OnUpdateItem(IConsole *pConsole, long item, ITEM_TYPE itemtype)

{
	HRESULT hr = S_FALSE;

	_ASSERT(NULL != this || isDeleted || RESULT == itemtype);		  	

	//redraw the item 
	IResultData *pResultData = NULL;

	hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
	_ASSERT( SUCCEEDED(hr) );	

	HRESULTITEM myhresultitem;
	_ASSERT(NULL != &myhresultitem);	
	
	//lparam == this. See CSpaceStation::OnShow
	hr = pResultData->FindItemByLParam( (LPARAM)this, &myhresultitem );

	if ( FAILED(hr) ) {
		//there is no HRESULTITEM for the item, because
		//the item is not inserted in the current view. Exit gracefully
		hr = S_FALSE;
	} else

	{
		hr = pResultData->UpdateItem( myhresultitem );     
		_ASSERT( SUCCEEDED(hr) );    
	}

	pResultData->Release();
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nameext\dataobj.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPDATAOBJECT_H_
#define _SAMPDATAOBJECT_H_

#include <mmc.h>
#include "DeleBase.h"

class CDataObject : public IDataObject
{
private:
    ULONG				m_cref;
    MMC_COOKIE			m_lCookie;
    DATA_OBJECT_TYPES   m_context;
    
public:
    CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context);
    ~CDataObject();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // IDataObject methods 
    ///////////////////////////////
    STDMETHODIMP GetDataHere (FORMATETC *pformatetc, STGMEDIUM *pmedium);
    
    // The rest are not implemented
    STDMETHODIMP GetData (LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumFormatEtc (DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };
    
    STDMETHODIMP QueryGetData (LPFORMATETC lpFormatetc) 
    { return E_NOTIMPL; };
    
    STDMETHODIMP GetCanonicalFormatEtc (LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    
    STDMETHODIMP SetData (LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DAdvise (LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DUnadvise (DWORD dwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumDAdvise (LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };
    
    ///////////////////////////////
    // Custom Methods
    ///////////////////////////////
    
    CDelegationBase *GetBaseNodeObject() {
        return (CDelegationBase *)m_lCookie;
    }
    
    DATA_OBJECT_TYPES GetContext() {
        return m_context;
    }
    
public:
    // clipboard formats
    static UINT s_cfSZNodeType;
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
    static UINT s_cfInternal;
    
};

HRESULT ExtractFromDataObject(IDataObject *lpDataObject,UINT cf,ULONG cb,HGLOBAL *phGlobal);
CDataObject* GetOurDataObject(IDataObject *lpDataObject);

#endif _SAMPDATAOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\multisel\space.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SPACE_H
#define _SPACE_H

#include "DeleBase.h"
#include "CompData.h"

class CSpaceStation;
class CComponentData;

class CRocket : public CDelegationBase {
public:
    CRocket(CSpaceStation *pSpaceStation, _TCHAR *szName, int id, LONG lWeight, LONG lHeight, LONG lPayload);
    virtual ~CRocket();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
	BOOL getDeletedStatus() { return isDeleted; }
	void setDeletedStatus(BOOL status) { isDeleted = status; }

    CSpaceStation* GetParent() { return  m_pSpaceStation; }
	int GetId() { return nId; }

public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect);
 	virtual HRESULT OnUpdateItem(IConsole *pConsole, long item, ITEM_TYPE itemtype);
	virtual HRESULT OnDelete(IConsole *pConsole);
	virtual HRESULT OnRefresh(IConsole *pConsole);
    virtual HRESULT OnRename(LPOLESTR pszNewName);
    
private:
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    _TCHAR *szName;
    LONG   lWeight;
    LONG   lHeight;
    LONG   lPayload;
    int    nId;

	friend CSpaceStation;
	CSpaceStation *m_pSpaceStation;

    enum ROCKET_STATUS {RUNNING, PAUSED, STOPPED} iStatus;

	BOOL isDeleted;
};

class CSpaceStation : public CDelegationBase {

public:
    CSpaceStation();
    virtual ~CSpaceStation();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Space Station"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_STATION; }
    
public:
	virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions);
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect);

	virtual HRESULT OnUpdateItem(IConsole *pConsole, long item, ITEM_TYPE itemtype);


private:
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
private:
    enum { NUMBER_OF_CHILDREN = 9, MAX_CHILDREN = 20 };
    CRocket *children[MAX_CHILDREN];
	CComponentData *m_pComponentData;
};

class CSpaceFolder : public CDelegationBase {
public:
    CSpaceFolder();
    
    virtual ~CSpaceFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Space Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { IDM_NEW_SPACE = 4 };
    
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
private:
    enum { NUMBER_OF_CHILDREN = 1 };
    CSpaceStation *children[NUMBER_OF_CHILDREN];
};

#endif // _SPACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nameext\basesnap.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#ifndef _BASESNAP_H_
#define _BASESNAP_H_

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);
STDAPI DllCanUnloadNow(void);

ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    enum FACTORY_TYPE {NAMESPACEEXTENSION = 0, ABOUT = 1};
    
    CClassFactory(FACTORY_TYPE factoryType);
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
private:
    FACTORY_TYPE m_factoryType;
};

#endif _BASESNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nameext\extend.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _EXTEND_H
#define _EXTEND_H

struct EXTENSION_NODE
{
    GUID	GUID;
    _TCHAR	szDescription[256];
};

enum EXTENSION_TYPE
{
    NameSpaceExtension,
        ContextMenuExtension, 
        ToolBarExtension,
        PropertySheetExtension,
        TaskExtension,
        DynamicExtension,
	DummyExtension
};

struct EXTENDER_NODE
{
    EXTENSION_TYPE	eType;
    GUID			guidNode;
    GUID			guidExtension;
    _TCHAR			szDescription[256];
};

#endif // _EXTEND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nameext\basesnap.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <olectl.h>
#include <initguid.h>
#include "globals.h"
#include "resource.h"
#include "guids.h"
#include "basesnap.h"
#include "nameext.h"
#include "About.h"
#include "Registry.h"
#include "Extend.h"

// our globals
HINSTANCE g_hinst;


BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    if ((rclsid != CLSID_CNamespaceExtension) && (rclsid != CLSID_CSnapinAbout))
        return CLASS_E_CLASSNOTAVAILABLE;
    
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
    // make the factory passing in the creation function for the type of object they want
    if (rclsid == CLSID_CNamespaceExtension)
        pFactory = new CClassFactory(CClassFactory::NAMESPACEEXTENSION);
    else if (rclsid == CLSID_CSnapinAbout)
        pFactory = new CClassFactory(CClassFactory::ABOUT);
    
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}


CClassFactory::CClassFactory(FACTORY_TYPE factoryType)
: m_cref(0), m_factoryType(factoryType)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    if (NAMESPACEEXTENSION == m_factoryType) {
        pObj = new CComponentData();
    } else {
        pObj = new CSnapinAbout();
    }
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    
    if (FAILED(hr))
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{
    HRESULT hr = SELFREG_E_CLASS;
    
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName));
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, sizeof(szSnapInName));
    
    _TCHAR szAboutName[256];
    
    LoadString(g_hinst, IDS_ABOUTNAME, szAboutName, sizeof(szAboutName));
    
    
    // register our CoClasses
    hr = RegisterServer(g_hinst, 
        CLSID_CNamespaceExtension, 
        szName);
    
    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst, 
        CLSID_CSnapinAbout, 
        szAboutName);
    
    // place the registry information for SnapIns
    if SUCCEEDED(hr)
        hr = RegisterSnapin(CLSID_CNamespaceExtension, szSnapInName, CLSID_CSnapinAbout);
    
    return hr;
}


STDAPI DllUnregisterServer()
{
    if (UnregisterServer(CLSID_CNamespaceExtension) == S_OK)
        return UnregisterSnapin(CLSID_CNamespaceExtension);
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nameext\comp.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "DataObj.h"
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "DeleBase.h"
#include "NameExt.h"

CComponent::CComponent(CComponentData *parent)
: m_pComponentData(parent), m_cref(0), m_ipConsole(NULL), m_ipDisplayHelp(NULL)
{
    OBJECT_CREATED
}

CComponent::~CComponent()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IComponent))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IExtendContextMenu))
        *ppv = static_cast<IExtendContextMenu *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponent::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponent::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface IComponent
///////////////////////////////
STDMETHODIMP CComponent::Initialize(
                                    /* [in] */ LPCONSOLE lpConsole)
{
    HRESULT hr = S_OK;

    // Save away all the interfaces we'll need.
    // Fail if we can't QI the required interfaces.

    m_ipConsole = lpConsole;
    m_ipConsole->AddRef();

    hr = m_ipConsole->QueryInterface(IID_IDisplayHelp, (void **)&m_ipDisplayHelp);

    return hr;
}

STDMETHODIMP CComponent::Notify(
                                /* [in] */ LPDATAOBJECT lpDataObject,
                                /* [in] */ MMC_NOTIFY_TYPE event,
                                /* [in] */ LPARAM arg,
                                /* [in] */ LPARAM param)
{
    MMCN_Crack(FALSE, lpDataObject, NULL, this, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)      {
    case MMCN_ADD_IMAGES:
        hr = base->OnAddImages((IImageList *)arg, (HSCOPEITEM)param);
        break;

    case MMCN_SHOW:
        hr = base->OnShow(m_ipConsole, (BOOL)arg, (HSCOPEITEM)param);
        break;

    }

    return hr;
}

STDMETHODIMP CComponent::Destroy(
                                 /* [in] */ MMC_COOKIE cookie)
{
    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    if (m_ipDisplayHelp) {
        m_ipDisplayHelp->Release();
        m_ipDisplayHelp = NULL;
    }

    return S_OK;
}


STDMETHODIMP CComponent::QueryDataObject(
                                         /* [in] */ MMC_COOKIE cookie,
                                         /* [in] */ DATA_OBJECT_TYPES type,
                                         /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject)
{
    CDataObject *pObj = NULL;

	//cookie == 0 not possible in a namespace extension
//    if (cookie == 0)
//        pObj = new CDataObject((MMC_COOKIE)m_pComponentData->m_pStaticNode, type);
//    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

STDMETHODIMP CComponent::GetResultViewType(
                                           /* [in] */ MMC_COOKIE cookie,
                                           /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
                                           /* [out] */ long __RPC_FAR *pViewOptions)
{
    CDelegationBase *base = (CDelegationBase *)cookie;

    //
    // Ask for default listview.
    //
    if (base == NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
        *ppViewType = NULL;
    }
    else
        return base->GetResultViewType(ppViewType, pViewOptions);

    return S_OK;
}

STDMETHODIMP CComponent::GetDisplayInfo(
                                        /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem)
{
    HRESULT hr = S_OK;
    CDelegationBase *base = NULL;

    // if they are asking for the RDI_STR we have one of those to give

    if (pResultDataItem->lParam) {
        base = (CDelegationBase *)pResultDataItem->lParam;
        if (pResultDataItem->mask & RDI_STR) {
            LPCTSTR pszT = base->GetDisplayName(pResultDataItem->nCol);
            MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pResultDataItem->str = pszW;
        }

        if (pResultDataItem->mask & RDI_IMAGE) {
            pResultDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}


STDMETHODIMP CComponent::CompareObjects(
                                        /* [in] */ LPDATAOBJECT lpDataObjectA,
                                        /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////
// Interface IExtendContextMenu
///////////////////////////////
HRESULT CComponent::AddMenuItems(
                                 /* [in] */ LPDATAOBJECT piDataObject,
                                 /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
                                 /* [out][in] */ long __RPC_FAR *pInsertionAllowed)
{
    CDelegationBase *base = GetOurDataObject(piDataObject)->GetBaseNodeObject();

    return base->OnAddMenuItems(piCallback, pInsertionAllowed);
}

HRESULT CComponent::Command(
                            /* [in] */ long lCommandID,
                            /* [in] */ LPDATAOBJECT piDataObject)
{
    CDelegationBase *base = GetOurDataObject(piDataObject)->GetBaseNodeObject();

    return base->OnMenuCommand(m_ipConsole, lCommandID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nameext\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5

#define INDEX_SUN 6
#define INDEX_SNOW 7
#define INDEX_RAIN 8
#define INDEX_CLOUD 9
#define INDEX_WORLD 10
#define INDEX_THUNDER 11


#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nameext\mmccrack.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

static TCHAR *MMCN_CrackVerb(MMC_CONSOLE_VERB verb)
{
	static TCHAR error[64];

	switch (verb) {
    case MMC_VERB_NONE:
		return _T("NONE");
    case MMC_VERB_OPEN:
		return _T("OPEN");
    case MMC_VERB_COPY:
		return _T("COPY");
    case MMC_VERB_PASTE:
		return _T("PASTE");
    case MMC_VERB_DELETE:
		return _T("DELETE");
    case MMC_VERB_PROPERTIES:
		return _T("PROPERTIES");
    case MMC_VERB_RENAME:
		return _T("RENAME");
    case MMC_VERB_REFRESH:
		return _T("REFRESH");
    case MMC_VERB_PRINT:
		return _T("PRINT");
    case MMC_VERB_CUT:
		return _T("CUT");
	default:
		wsprintf(error, _T("Unknown verb id %d"), verb);
		return error;
	}
}

void MMCN_Crack(BOOL bComponentData, 
                IDataObject *pDataObject,
				IComponentData *pCompData,
				IComponent *pComp,
                MMC_NOTIFY_TYPE event, 
				LPARAM arg, 
				LPARAM param)
{
#ifdef MMC_CRACK_MESSAGES
	TCHAR message[256] = {0};

	if (bComponentData == TRUE)
		OutputDebugString(_T("IComponentData::Notify( "));
	else
		OutputDebugString(_T("IComponent::Notify( "));

	wsprintf(message, _T("DataObject: %08x, CompData: %08x, Comp: %08x ) - "), pDataObject, pCompData, pComp);
	OutputDebugString(message);

    switch (event)	{
		case MMCN_ACTIVATE:
			wsprintf(message, _T("MMCN_ACTIVATE\n\tActivate: %d\n"), arg);
			break;

		case MMCN_ADD_IMAGES:
			wsprintf(message, _T("MMCN_ADD_IMAGES\n\tImage List: %08x\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_BTN_CLICK:
			wsprintf(message, _T("MMCN_BTN_CLICK\n\tVerb: %ws\n"), MMCN_CrackVerb((MMC_CONSOLE_VERB)param));
			break;

		case MMCN_COLUMN_CLICK:
			wsprintf(message, _T("MMCN_COLUMN_CLICK\n\tColumn: %d\n\tSort Option: %d\n"), arg,	 param);
			break;

		case MMCN_COLUMNS_CHANGED:
			wsprintf(message, _T("MMCN_COLUMNS_CHANGED\n"));
			break;

		case MMCN_CONTEXTHELP:
			wsprintf(message, _T("MMCN_CONTEXTHELP\n"));
			break;

		case MMCN_CONTEXTMENU:
			wsprintf(message, _T("MMCN_CONTEXTMENU\n"));
			break;

		case MMCN_CUTORMOVE:
			wsprintf(message, _T("MMCN_CUTORMOVE\n"));
			break;

		case MMCN_DBLCLICK:
			wsprintf(message, _T("MMCN_DBLCLICK\n"));
			break;

		case MMCN_DELETE:
			wsprintf(message, _T("MMCN_DELETE\n"));
			break;

		case MMCN_DESELECT_ALL:
			wsprintf(message, _T("MMCN_DESELECT_ALL\n"));
			break;

		case MMCN_EXPAND:
			wsprintf(message, _T("MMCN_EXPAND\n\tExpand: %d\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_EXPANDSYNC:
			wsprintf(message, _T("MMCN_EXPANDSYNC\n"));
			break;

		case MMCN_FILTERBTN_CLICK:
			wsprintf(message, _T("MMCN_FILTERBTN_CLICK\n\tColumn: %d\n"), arg);
			break;

		case MMCN_FILTER_CHANGE:
			wsprintf(message, _T("MMCN_FILTER_CHANGE\n\tColumn: %d\n"), param);
			break;

		case MMCN_HELP:
			wsprintf(message, _T("MMCN_HELP\n"));
			break;

		case MMCN_INITOCX:
			wsprintf(message, _T("MMCN_INITOCX\n\tIUnknown: %08x\n"), param);
			break;

		case MMCN_LISTPAD:
			wsprintf(message, _T("MMCN_LISTPAD\n\tConnect: %d\n"), arg);
			break;

		case MMCN_MENU_BTNCLICK:
			wsprintf(message, _T("MMCN_MENU_BTNCLICK\n"));
			break;

		case MMCN_MINIMIZED:
			wsprintf(message, _T("MMCN_MINIMIZED\n\tMinimized: %d\n"), arg);
			break;

		case MMCN_PASTE:
			wsprintf(message, _T("MMCN_PASTE\n\tCopy: %d\n"), param == NULL);
			break;

		case MMCN_PRELOAD:
			wsprintf(message, _T("MMCN_PRELOAD\n\tScope Item: %08x\n"), arg);
			break;

		case MMCN_PRINT:
			wsprintf(message, _T("MMCN_PRINT\n"));
			break;

		case MMCN_PROPERTY_CHANGE:
			wsprintf(message, _T("MMCN_PROPERTY_CHANGE\n\tScope: %d\n\tArg: %08x\n"), arg, param);
			break;

		case MMCN_QUERY_PASTE:
			wsprintf(message, _T("MMCN_QUERY_PASTE\n"));
			break;

		case MMCN_REFRESH:
			wsprintf(message, _T("MMCN_REFRESH\n"));
			break;

		case MMCN_REMOVE_CHILDREN:
			wsprintf(message, _T("MMCN_REMOVE_CHILDREN\n\tScope Item: %08x\n"), arg);
			break;

		case MMCN_RENAME:
			wsprintf(message, _T("MMCN_RENAME\n\tNew Name: '%ws'\n"), (LPOLESTR)param);
			break;

		case MMCN_RESTORE_VIEW:
			wsprintf(message, _T("MMCN_RESTORE_VIEW\n"));
			break;

		case MMCN_SELECT:
			wsprintf(message, _T("MMCN_SELECT\n\tScope: %d\n\tSelect: %08x\n"), LOWORD(arg), HIWORD(arg));
			break;

		case MMCN_SHOW:
			wsprintf(message, _T("MMCN_SHOW\n\tShow: %d\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_SNAPINHELP:
			wsprintf(message, _T("MMCN_SNAPINHELP\n"));
			break;

		case MMCN_VIEW_CHANGE:
			wsprintf(message, _T("MMCN_VIEW_CHANGE\n\tData: %08x\n\tHint: %08x\n"), arg, param);
			break;
	}

	if (message[0] != 0)
		OutputDebugString(message);
	else
		OutputDebugString(_T("unknown event\n"));

#endif
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nameext\comp.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMP_H_
#define _SAMPCOMP_H_

#include <mmc.h>

class CComponent : public IComponent, IExtendContextMenu
{
private:
    ULONG				m_cref;
    
    IConsole*		m_ipConsole;
    IDisplayHelp*	m_ipDisplayHelp;
    
    class CComponentData *m_pComponentData;
    
    public:
        CComponent(CComponentData *parent);
        ~CComponent();
        
        ///////////////////////////////
        // Interface IUnknown
        ///////////////////////////////
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        
        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ MMC_COOKIE cookie);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);

            ///////////////////////////////
            // Interface IExtendContextMenu
            ///////////////////////////////
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddMenuItems( 
            /* [in] */ LPDATAOBJECT piDataObject,
            /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
            /* [out][in] */ long __RPC_FAR *pInsertionAllowed);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Command( 
            /* [in] */ long lCommandID,
            /* [in] */ LPDATAOBJECT piDataObject);
            
};

#endif _SAMPCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nameext\dataobj.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DataObj.h"
#include "guids.h"
#include "DeleBase.h"

//
// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SZNODETYPE _T("CCF_SZNODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

#define _T_CCF_INTERNAL_SNAPIN _T("{2479DB32-5276-11d2-94F5-00C04FB92EC2}")

    // These are the clipboard formats that we must supply at a minimum.
    // mmc.h actually defined these. We can make up our own to use for
    // other reasons. We don't need any others at this time.
UINT CDataObject::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CDataObject::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CDataObject::s_cfSZNodeType  = RegisterClipboardFormat(_T_CCF_SZNODETYPE);
UINT CDataObject::s_cfSnapinClsid = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);
UINT CDataObject::s_cfInternal    = RegisterClipboardFormat(_T_CCF_INTERNAL_SNAPIN);


CDataObject::CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context)
: m_lCookie(cookie), m_context(context), m_cref(0)
{
}

CDataObject::~CDataObject()
{
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IDataObject *>(this);
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppv = static_cast<IDataObject *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CDataObject::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
//
HRESULT CDataObject::GetDataHere(
                                 FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure
                                 STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure
                                 )
{
    const   CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pStream = NULL;

    CDelegationBase *base = GetBaseNodeObject();

    HRESULT hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( FAILED(hr) )
        return hr;                       // Minimal error checking

    hr = DV_E_FORMATETC;                 // Unknown format

    if (cf == s_cfDisplayName) {
        const _TCHAR *pszName = base->GetDisplayName();

                MAKE_WIDEPTR_FROMTSTR(wszName, pszName);

                // get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(pszName);
        ulSizeofName++;                      // Count null character
        ulSizeofName *= sizeof(WCHAR);

        hr = pStream->Write(wszName, ulSizeofName, NULL);
    } else if (cf == s_cfNodeType) {
        const GUID *pGUID = (const GUID *)&base->getNodeType();

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfSZNodeType) {
        LPOLESTR szGuid;
        hr = StringFromCLSID(base->getNodeType(), &szGuid);

        if (SUCCEEDED(hr)) {
            hr = pStream->Write(szGuid, wcslen(szGuid), NULL);
            CoTaskMemFree(szGuid);
        }
    } else if (cf == s_cfSnapinClsid) {
        const GUID *pGUID = NULL;
        pGUID = &CLSID_CNamespaceExtension;

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfInternal) {
        // we are being asked to get our this pointer from the IDataObject interface
        // only our own snap-in objects will know how to do this.
        CDataObject *pThis = this;
        hr = pStream->Write( &pThis, sizeof(CDataObject*), NULL );
    }

    pStream->Release();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Global helper functions to help work with dataobjects and
// clipboard formats


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfInternal clipboard format
//
CDataObject* GetOurDataObject (
                               LPDATAOBJECT lpDataObject      // [in] IComponent pointer
                               )
{
    HRESULT       hr      = S_OK;
    CDataObject *pSDO     = NULL;

	// check to see if the data object is a special data object.
	if ( IS_SPECIAL_DATAOBJECT (lpDataObject) )
	{
		//Code for handling a special data object goes here.

		//Note that the MMC SDK samples do not handle
		//special data objects, so we exit if we get one.
		return NULL;
	}

    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { CDataObject::s_cfInternal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(CDataObject *));

    if (!stgmedium.hGlobal)     {
        hr = E_OUTOFMEMORY;
    }

    if SUCCEEDED(hr)
        // Attempt to get data from the object
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );

    // stgmedium now has the data we need
    if (SUCCEEDED(hr))  {
        pSDO = *(CDataObject **)(stgmedium.hGlobal);
    }

    // if we have memory free it
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);

    return pSDO;

} // end GetOurDataObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nameext\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>
#include <mmc.h>

#ifndef STRINGS_ONLY
	#define IDM_BUTTON1    0x100
	#define IDM_BUTTON2    0x101

	extern HINSTANCE g_hinst;
	extern ULONG g_uObjects;

	#define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
	#define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

	// uncomment the following #define to enable message cracking
	// #define MMC_CRACK_MESSAGES
	void MMCN_Crack(BOOL bComponentData, 
					IDataObject *pDataObject, 
					IComponentData *pCompData,
					IComponent *pComp,
					MMC_NOTIFY_TYPE event, 
					LPARAM arg, 
					LPARAM param);
#endif

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(GetProcessHeap(), 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(GetProcessHeap(), 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given a _TCHAR, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszT;
//  pszT = MyGetTStringRoutine();
//  MAKE_WIDEPTR_FROMSTR(pwsz, pszT);
//  MyUseWideStringRoutine(pwsz);
//  ...
#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPWSTR)__TempBuffer##ptrname.GetBuffer(), tstr); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    lstrcpyW((LPWSTR)ptrname, tstr)
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, ptrname, __l##ptrname)
#endif

//
// similarily for MAKE_TSTRPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
// * 2 for DBCS handling in below length computation
//
#ifdef UNICODE
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPTSTR)__TempBuffer##ptrname.GetBuffer(), widestr); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nameext\delebase.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _BRANCHES_H
#define _BRANCHES_H

#include <mmc.h>
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "LocalRes.h"

class CDelegationBase {
public:
    CDelegationBase();
    virtual ~CDelegationBase();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) = 0;
    virtual const GUID & getNodeType() { _ASSERT(FALSE); return IID_NULL; }
    
    virtual const LPARAM GetCookie() { return reinterpret_cast<LPARAM>(this); }
    virtual const int GetBitmapIndex() = 0;
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions) { return S_FALSE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent) { return S_FALSE; }
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem) { return S_FALSE; }
    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    virtual HRESULT OnShowContextHelp(IDisplayHelp *m_ipDisplayHelp, LPOLESTR helpFile) { return S_FALSE; }
    virtual HRESULT OnAddMenuItems(IContextMenuCallback *pContextMenuCallback, long *pInsertionsAllowed) { return S_FALSE; }
    virtual HRESULT OnMenuCommand(IConsole *pConsole, long lCommandID) { return S_FALSE; }
    
public:
    static HBITMAP m_pBMapSm;
    static HBITMAP m_pBMapLg;
    
protected:

    BOOL bExpanded;
	
	static void LoadBitmaps() {
        m_pBMapSm = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_SMICONS));
        m_pBMapLg = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_LGICONS)); }   

private:
    // {98015FF3-6A2D-11d3-9154-00C04F65B3F9}
    static const GUID thisGuid;
};

#endif // _BRANCHES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nameext\delebase.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DeleBase.h"

const GUID CDelegationBase::thisGuid = { 0x98015ff3, 0x6a2d, 0x11d3, {0x91, 0x54, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9} };


HBITMAP CDelegationBase::m_pBMapSm = NULL;
HBITMAP CDelegationBase::m_pBMapLg = NULL;

//==============================================================
//
// CDelegationBase implementation
//
//
CDelegationBase::CDelegationBase() 
: bExpanded(FALSE) 
{
	if (NULL == m_pBMapSm || NULL == m_pBMapLg)
		LoadBitmaps(); 
}

CDelegationBase::~CDelegationBase() 
{
}

// CDelegationBase::AddImages sets up the collection of images to be displayed
// by the IComponent in the result pane as a result of its MMCN_SHOW handler
HRESULT CDelegationBase::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi) 
{
    return pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nameext\registry.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions = FALSE);

HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nameext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Resources.rc
//
#define IDS_HELPFILE                    1
#define IDS_SNAPINDESC                  2
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDI_ICON1                       108
#define IDB_SMOPEN                      111
#define IDB_SMBMP                       112
#define IDB_LGBMP                       113
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDB_ROCKET                      40004
#define IDB_CAR                         40005
#define IDB_PLANE                       40006
#define IDB_BIKE                        40007
#define IDB_ROCKET2                     40008
#define IDB_CAR2                        40009
#define IDB_PLANE2                      40010
#define IDB_BIKE2                       40011
#define IDB_CLOSED2                     40012
#define IDB_OPEN2                       40013
#define IDB_CLOSED                      40014
#define IDB_OPEN                        40015

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        114
#define _APS_NEXT_COMMAND_VALUE         40016
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\about.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "About.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

CSnapinAbout::CSnapinAbout()
: m_cref(0)
{
    OBJECT_CREATED
        
        m_hSmallImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    m_hLargeImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_LGBMP), IMAGE_BITMAP, 32, 32, LR_LOADTRANSPARENT);
    
    m_hSmallImageOpen = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMOPEN), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    
    m_hAppIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ICON1));
}

CSnapinAbout::~CSnapinAbout()
{
    if (m_hSmallImage != NULL)
        FreeResource(m_hSmallImage);
    
    if (m_hLargeImage != NULL)
        FreeResource(m_hLargeImage);
    
    if (m_hSmallImageOpen != NULL)
        FreeResource(m_hSmallImageOpen);
    
    if (m_hAppIcon != NULL)
        FreeResource(m_hAppIcon);
    
    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;
    
    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CSnapinAbout::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<ISnapinAbout *>(this);
    else if (IsEqualIID(riid, IID_ISnapinAbout))
        *ppv = static_cast<ISnapinAbout *>(this);
    
    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSnapinAbout::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CSnapinAbout::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    return m_cref;
    
}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription( 
                                                /* [out] */ LPOLESTR *lpDescription)
{
    _TCHAR szDesc[MAX_PATH];
    
    LoadString(g_hinst, IDS_SNAPINDESC, szDesc, sizeof(szDesc));
    
    return AllocOleStr(lpDescription, szDesc);
}


STDMETHODIMP CSnapinAbout::GetProvider( 
                                       /* [out] */ LPOLESTR *lpName)
{
    return AllocOleStr(lpName, _T("Copyright  1998 Microsoft Corporation"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinVersion( 
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return AllocOleStr(lpVersion, _T("1.0"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinImage( 
                                          /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;
    
    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}


STDMETHODIMP CSnapinAbout::GetStaticFolderImage( 
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;
    
    *hSmallImageOpen = m_hSmallImageOpen;
    
    *cMask = RGB(0, 128, 128);
    
    if (*hSmallImage == NULL || *hLargeImage == NULL || *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}

// this allocates a chunk of memory using CoTaskMemAlloc and copies our chars into it
HRESULT CSnapinAbout::AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer)
{
	MAKE_WIDEPTR_FROMTSTR_ALLOC(wszStr, szBuffer);
	*lpDest = wszStr;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nameext\nameext.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "sky.h"
#include "nameext.h"
#include "DataObj.h"
#include "globals.h"
#include "resource.h"
#include <crtdbg.h>


// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

// These are the clipboard formats that we must supply at a minimum.
// mmc.h actually defined these. We can make up our own to use for
// other reasons. We don't need any others at this time.
UINT CComponentData::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CComponentData::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CComponentData::s_cfSnapInCLSID = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);


const GUID CComponentData::skybasedvehicleGuid = { 0x2974380f, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

HBITMAP CComponentData::m_pBMapSm = NULL;
HBITMAP CComponentData::m_pBMapLg = NULL;												

CComponentData::CComponentData()
: m_cref(0), bExpanded(FALSE), m_ipConsoleNameSpace(NULL), m_ipConsole(NULL)
{ 
    if (NULL == m_pBMapSm || NULL == m_pBMapLg)
        LoadBitmaps();    
	
	OBJECT_CREATED
}

CComponentData::~CComponentData()
{

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CComponentData::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_IComponentData))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_IExtendContextMenu))
        *ppv = static_cast<IExtendContextMenu *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponentData::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponentData::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }

    return m_cref;
}

///////////////////////////////
// Interface IComponentData
///////////////////////////////
HRESULT CComponentData::Initialize(
                                   /* [in] */ LPUNKNOWN pUnknown)
{
    HRESULT      hr;

    //
    // Get pointer to name space interface
    //
    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (void **)&m_ipConsoleNameSpace);
    _ASSERT( S_OK == hr );

    //
    // Get pointer to console interface
    //
    hr = pUnknown->QueryInterface(IID_IConsole, (void **)&m_ipConsole);
    _ASSERT( S_OK == hr );

    IImageList *pImageList;
    m_ipConsole->QueryScopeImageList(&pImageList);
    _ASSERT( S_OK == hr );
    
    hr = pImageList->ImageListSetStrip(	(long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
    
    pImageList->Release();

    return S_OK;
}

HRESULT CComponentData::CreateComponent(
                                        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent)
{
    *ppComponent = NULL;

    CComponent *pComponent = new CComponent(this);

    if (NULL == pComponent)
        return E_OUTOFMEMORY;

    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent);
}

HRESULT CComponentData::Notify(
                               /* [in] */ LPDATAOBJECT lpDataObject,
                               /* [in] */ MMC_NOTIFY_TYPE event,
                               /* [in] */ LPARAM arg,
                               /* [in] */ LPARAM param)
{
    MMCN_Crack(TRUE, lpDataObject, this, NULL, event, arg, param);

	HRESULT hr = S_FALSE;
    
	if (NULL == lpDataObject)
        return hr;

	switch (event)
	{
		case MMCN_EXPAND:

			GUID myGuid;
			GUID* pGUID= &myGuid;
			// extract GUID of the the currently selected node type from the data object
			hr = ExtractObjectTypeGUID(lpDataObject, pGUID);
			_ASSERT( S_OK == hr );    


			// compare node type GUIDs of currently selected node and the node type 
			// we want to extend. If they are are equal, currently selected node
			// is the type we want to extend, so we add our items underneath it
			if (IsEqualGUID(*pGUID, getPrimaryNodeType()))
				OnExpand(m_ipConsoleNameSpace, m_ipConsole, (HSCOPEITEM)param);

			else
			// currently selected node is one of ours instead
			{
				CDelegationBase *base = GetOurDataObject(lpDataObject)->GetBaseNodeObject();					
				hr = base->OnExpand(m_ipConsoleNameSpace, m_ipConsole, (HSCOPEITEM)param);
			}

			break;
	}	
	
    return hr;
}

HRESULT CComponentData::Destroy( void)
{
    // Free interfaces
    if (m_ipConsoleNameSpace) {
        m_ipConsoleNameSpace->Release();
        m_ipConsoleNameSpace = NULL;
    }

    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}

HRESULT CComponentData::QueryDataObject(
                                        /* [in] */ MMC_COOKIE cookie,
                                        /* [in] */ DATA_OBJECT_TYPES type,
                                        /* [out] */ LPDATAOBJECT *ppDataObject)
{
    CDataObject *pObj = NULL;

	//cookie == 0 not possible in a namespace extension
//    if (cookie == 0)
//        pObj = new CDataObject((MMC_COOKIE)m_pComponentData->m_pStaticNode, type);
//    else
		  pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

HRESULT CComponentData::GetDisplayInfo(
                                       /* [out][in] */ SCOPEDATAITEM *pScopeDataItem)
{
    HRESULT hr = S_FALSE;

    // if they are asking for the SDI_STR we have one of those to give
    if (pScopeDataItem->lParam) {
        CDelegationBase *base = (CDelegationBase *)pScopeDataItem->lParam;
        if (pScopeDataItem->mask & SDI_STR) {
            LPCTSTR pszT = base->GetDisplayName();
            MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pScopeDataItem->displayname = pszW;
        }

        if (pScopeDataItem->mask & SDI_IMAGE) {
            pScopeDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}

HRESULT CComponentData::CompareObjects(
                                       /* [in] */ LPDATAOBJECT lpDataObjectA,
                                       /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}


///////////////////////////////
// Interface IExtendContextMenu
///////////////////////////////
HRESULT CComponentData::AddMenuItems(
                                     /* [in] */ LPDATAOBJECT piDataObject,
                                     /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
                                     /* [out][in] */ long __RPC_FAR *pInsertionAllowed)
{
    CDelegationBase *base = GetOurDataObject(piDataObject)->GetBaseNodeObject();

    return base->OnAddMenuItems(piCallback, pInsertionAllowed);
}

HRESULT CComponentData::Command(
                                /* [in] */ long lCommandID,
                                /* [in] */ LPDATAOBJECT piDataObject)
{
    CDelegationBase *base = GetOurDataObject(piDataObject)->GetBaseNodeObject();

    return base->OnMenuCommand(m_ipConsole, lCommandID);
}


///////////////////////////////
// CComponentData::OnExpand
///////////////////////////////

HRESULT CComponentData::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
	//first create the CSkyVehicle objects, one for each inserted item
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CSkyVehicle(n + 1);
    }  	

	//now fill an SCOPEDATAITEM for each item and then insert it
	SCOPEDATAITEM sdi;
    
    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT    |   // relativeID is valid
                SDI_CHILDREN;     // cChildren is valid
            
            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = 0;
            
            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );
            
            _ASSERT( SUCCEEDED(hr) );
        }
    }
    
    return S_OK;
}



///////////////////////////////
// Member functions for extracting
// information from a primary's 
// data object
///////////////////////////////

HRESULT CComponentData::ExtractData( IDataObject* piDataObject,
                                           CLIPFORMAT   cfClipFormat,
                                           BYTE*        pbData,
                                           DWORD        cbData )
{
    HRESULT hr = S_OK;
    
    FORMATETC formatetc = {cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL};
    
    stgmedium.hGlobal = ::GlobalAlloc(GPTR, cbData);
    do // false loop
    {
        if (NULL == stgmedium.hGlobal)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        hr = piDataObject->GetDataHere( &formatetc, &stgmedium );
        if ( FAILED(hr) )
        {
            break;
        }
        
        BYTE* pbNewData = reinterpret_cast<BYTE*>(stgmedium.hGlobal);
        if (NULL == pbNewData)
        {
            hr = E_UNEXPECTED;
            break;
        }
        ::memcpy( pbData, pbNewData, cbData );
    } while (FALSE); // false loop
    
    if (NULL != stgmedium.hGlobal)
    {
        ::GlobalFree(stgmedium.hGlobal);
    }
    return hr;
} // ExtractData()

HRESULT CComponentData::ExtractString( IDataObject *piDataObject,
                                             CLIPFORMAT   cfClipFormat,
                                             _TCHAR       *pstr,
                                             DWORD        cchMaxLength)
{
    return ExtractData( piDataObject, cfClipFormat, (PBYTE)pstr, cchMaxLength );
}

HRESULT CComponentData::ExtractSnapInCLSID( IDataObject* piDataObject, CLSID* pclsidSnapin )
{
    return ExtractData( piDataObject, s_cfSnapInCLSID, (PBYTE)pclsidSnapin, sizeof(CLSID) );
}

HRESULT CComponentData::ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* pguidObjectType )
{
    return ExtractData( piDataObject, s_cfNodeType, (PBYTE)pguidObjectType, sizeof(GUID) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\about.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPABOUT_H_
#define _SAMPABOUT_H_

#include <tchar.h>
#include <mmc.h>

class CSnapinAbout : public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;
    
public:
    CSnapinAbout();
    ~CSnapinAbout();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
        /* [out] */ LPOLESTR *lpDescription);
        
        STDMETHODIMP GetProvider( 
        /* [out] */ LPOLESTR *lpName);
        
        STDMETHODIMP GetSnapinVersion( 
        /* [out] */ LPOLESTR *lpVersion);
        
        STDMETHODIMP GetSnapinImage( 
        /* [out] */ HICON *hAppIcon);
        
        STDMETHODIMP GetStaticFolderImage( 
        /* [out] */ HBITMAP *hSmallImage,
        /* [out] */ HBITMAP *hSmallImageOpen,
        /* [out] */ HBITMAP *hLargeImage,
        /* [out] */ COLORREF *cMask);
        
        ///////////////////////////////
        // Private Interface 
        ///////////////////////////////
private:
    HRESULT	CSnapinAbout::AllocOleStr(
        LPOLESTR *lpDest, 
        _TCHAR *szBuffer);
};

#endif _SAMPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nameext\guids.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;


// {64026453-6A22-11d3-9154-00C04F65B3F9}
DEFINE_GUID(CLSID_CNamespaceExtension, 
0x64026453, 0x6a22, 0x11d3, 0x91, 0x54, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9);


// {AF2039D3-6A26-11d3-9154-00C04F65B3F9}
DEFINE_GUID(CLSID_CSnapinAbout, 
0xaf2039d3, 0x6a26, 0x11d3, 0x91, 0x54, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nameext\nameext.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _CNamespaceExtension_H_
#define _CNamespaceExtension_H_

#include <tchar.h>
#include <mmc.h>
#include <crtdbg.h>
#include "DeleBase.h"
#include "globals.h"
#include "resource.h"
#include "LocalRes.h"

class CComponentData : public IComponentData,
IExtendContextMenu

{
    friend class CComponent;

private:
    ULONG               m_cref;
    LPCONSOLE           m_ipConsole;
    LPCONSOLENAMESPACE  m_ipConsoleNameSpace;
    
    HRESULT ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* pguidObjectType );
    HRESULT ExtractSnapInCLSID( IDataObject* piDataObject, CLSID* pclsidSnapin );
    HRESULT ExtractString( IDataObject *piDataObject, CLIPFORMAT cfClipFormat, _TCHAR *pstr, DWORD cchMaxLength);
    HRESULT ExtractData( IDataObject* piDataObject, CLIPFORMAT cfClipFormat, BYTE* pbData, DWORD cbData );
       
    enum { NUMBER_OF_CHILDREN = 1 };
    CDelegationBase *children[1];
    
	// clipboard format
    static UINT s_cfDisplayName;
    static UINT s_cfSnapInCLSID;
    static UINT s_cfNodeType;

    // {2974380F-4C4B-11d2-89D8-000021473128}
    static const GUID skybasedvehicleGuid;


public:
    CComponentData();
    ~CComponentData();

	const GUID & getPrimaryNodeType() { return skybasedvehicleGuid; }
    HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);


    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    ///////////////////////////////
    // Interface IComponentData
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize(
        /* [in] */ LPUNKNOWN pUnknown);

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent(
        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify(
        /* [in] */ LPDATAOBJECT lpDataObject,
        /* [in] */ MMC_NOTIFY_TYPE event,
        /* [in] */ LPARAM arg,
        /* [in] */ LPARAM param);

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject(
        /* [in] */ MMC_COOKIE cookie,
        /* [in] */ DATA_OBJECT_TYPES type,
        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo(
        /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects(
        /* [in] */ LPDATAOBJECT lpDataObjectA,
        /* [in] */ LPDATAOBJECT lpDataObjectB);

        ///////////////////////////////
        // Interface IExtendContextMenu
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddMenuItems(
        /* [in] */ LPDATAOBJECT piDataObject,
        /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
        /* [out][in] */ long __RPC_FAR *pInsertionAllowed);

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Command(
        /* [in] */ long lCommandID,
        /* [in] */ LPDATAOBJECT piDataObject);


public:
    static HBITMAP m_pBMapSm;
    static HBITMAP m_pBMapLg;
    
protected:
    static void LoadBitmaps() {
        m_pBMapSm = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_SMICONS));
        m_pBMapLg = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_LGICONS));
    }
    
    BOOL bExpanded;
};

#endif _CNamespaceExtension_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\basesnap.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <olectl.h>
#include <initguid.h>
#include "guids.h"
#include "basesnap.h"
#include "Comp.h"
#include "CompData.h"
#include "About.h"
#include "Registry.h"

// our globals
HINSTANCE g_hinst;

BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    if ((rclsid != CLSID_CComponentData) && (rclsid != CLSID_CSnapinAbout))
        return CLASS_E_CLASSNOTAVAILABLE;
    
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
    // make the factory passing in the creation function for the type of object they want
    if (rclsid == CLSID_CComponentData)
        pFactory = new CClassFactory(CClassFactory::COMPONENT);
    else if (rclsid == CLSID_CSnapinAbout)
        pFactory = new CClassFactory(CClassFactory::ABOUT);
    
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}


CClassFactory::CClassFactory(FACTORY_TYPE factoryType)
: m_cref(0), m_factoryType(factoryType)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    if (COMPONENT == m_factoryType) {
        pObj = new CComponentData();
    } else {
        pObj = new CSnapinAbout();
    }
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    
    if (FAILED(hr))
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{
    HRESULT hr = SELFREG_E_CLASS;
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName));
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, sizeof(szSnapInName));
    
    _TCHAR szAboutName[256];
    
    LoadString(g_hinst, IDS_ABOUTNAME, szAboutName, sizeof(szAboutName));
    
    // register our CoClasses
    hr = RegisterServer(g_hinst, 
        CLSID_CComponentData, 
        szName);
    
    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst, 
        CLSID_CSnapinAbout, 
        szAboutName);
    
    // place the registry information for SnapIns
    if SUCCEEDED(hr)
        hr = RegisterSnapin(CLSID_CComponentData, szSnapInName, CLSID_CSnapinAbout, FALSE);
    
    return hr;
}


STDAPI DllUnregisterServer()
{
    if (UnregisterServer(CLSID_CComponentData) == S_OK)
        return UnregisterSnapin(CLSID_CComponentData);
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\basesnap.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#ifndef _BASESNAP_H_
#define _BASESNAP_H_

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);
STDAPI DllCanUnloadNow(void);

ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    enum FACTORY_TYPE {COMPONENT = 0, ABOUT = 1};
    
    CClassFactory(FACTORY_TYPE factoryType);
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
private:
    FACTORY_TYPE m_factoryType;
};

#endif _BASESNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nameext\registry.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

#define STRINGS_ONLY
#include "Extend.h"
#include "globals.h"

// list all of the nodes that we extend
EXTENDER_NODE _NodeExtensions[] = {
    {NameSpaceExtension,
    {0x2974380f, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } },
	{0x64026453, 0x6a22, 0x11d3, {0x91, 0x54, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9} },
    _T("Namespace Extension to the Sky-based Vehicle node")},

    {DummyExtension,
    NULL,
    NULL,
    NULL}
};


////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName)       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule, 
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;
    
    assert(dwResult != 0) ;
    
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    assert(SUCCEEDED(hr)) ;

	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;
	_tcscat(szKey, pszCLSID) ;
    
    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;
    
    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    _tcscat(szKey, _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), _T("Apartment"));
    
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    
    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    
    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;

	MAKE_TSTRPTR_FROMWIDE(pszT, wszCLSID);
	_tcscat(szKey, pszT) ;
    
    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.
    
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    
    return S_OK ;
}

//
// Register the snap-in in the registry.
//

HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions)
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    LPOLESTR wszAboutCLSID = NULL;
    LPOLESTR wszExtendCLSID = NULL;
    LPOLESTR wszNodeCLSID = NULL;
    EXTENDER_NODE *pNodeExtension;
    _TCHAR szKeyBuf[1024] ;
    HKEY hKey;


    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    if (IID_NULL != clsidAbout)
        hr = StringFromCLSID(clsidAbout, &wszAboutCLSID);

	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
	MAKE_TSTRPTR_FROMWIDE(pszAboutCLSID, wszAboutCLSID);

   
    // Add the CLSID to the registry.
    setSnapInKeyAndValue(pszCLSID, NULL, _T("NameString"), szNameString) ;
    if (IID_NULL != clsidAbout)
        setSnapInKeyAndValue(pszCLSID, NULL, _T("About"), pszAboutCLSID);
    
    if (fSupportExtensions) {
        // Build the key NodeType 
        setSnapInKeyAndValue(pszCLSID, _T("NodeTypes"), NULL, NULL);
        
        _TCHAR szKey[64] ;
        _tcscpy(szKey, pszCLSID) ;
        _tcscat(szKey, _T("\\NodeTypes")) ;
        setSnapInKeyAndValue(szKey, pszCLSID, NULL, NULL);
    }

    // register each of the node extensions
    for (pNodeExtension = &(_NodeExtensions[0]);*pNodeExtension->szDescription;pNodeExtension++)
    {
        hr = StringFromCLSID(pNodeExtension->guidNode, &wszExtendCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszExtendCLSID, wszExtendCLSID);
        _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\NodeTypes\\"));
        _tcscat(szKeyBuf, pszExtendCLSID);

        switch (pNodeExtension->eType) {
        case NameSpaceExtension:
            _tcscat(szKeyBuf, _T("\\Extensions\\NameSpace"));
            break;
        default:
            break;
        }

        // Create and open key and subkey.
        long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
            szKeyBuf,
            0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, NULL,
            &hKey, NULL) ;

        if (lResult != ERROR_SUCCESS)
        {
            return FALSE ;
        }

        hr = StringFromCLSID(pNodeExtension->guidExtension, &wszNodeCLSID);
        assert(SUCCEEDED(hr));

        MAKE_TSTRPTR_FROMWIDE(pszNodeCLSID, wszNodeCLSID);
        // Set the Value.
        if (pNodeExtension->szDescription != NULL)
        {
            RegSetValueEx(hKey, pszNodeCLSID, 0, REG_SZ,
                (BYTE *)pNodeExtension->szDescription,
                (_tcslen(pNodeExtension->szDescription)+1)*sizeof(_TCHAR)) ;
        }

        RegCloseKey(hKey) ;

        CoTaskMemFree(wszExtendCLSID);
        CoTaskMemFree(wszNodeCLSID);
    }


    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    if (IID_NULL != clsidAbout)
        CoTaskMemFree(wszAboutCLSID);
    
    return S_OK ;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    LPOLESTR wszCLSID = NULL;
    
    // Get CLSID
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
    
    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));
    
    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\"));
    _tcscat(szKeyBuf, pszCLSID);
    
    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.
    
    // free the memory
    CoTaskMemFree(wszCLSID);
    
    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }
    
    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }
    
    // Close the child.
    RegCloseKey(hKeyChild) ;
    
    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;
    
    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));
    
    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\")) ;
    _tcscat(szKeyBuf, szKey) ;
    
    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\compdata.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMPDATA_H_
#define _SAMPCOMPDATA_H_

#include <mmc.h>
#include "DeleBase.h"
#include "StatNode.h"
#include "Comp.h"

class CComponentData : public IComponentData
{
    friend class CComponent;
    
private:
    ULONG				m_cref;
    LPCONSOLE			m_ipConsole;
    LPCONSOLENAMESPACE	m_ipConsoleNameSpace;
    
    CStaticNode     *m_pStaticNode;
    
public:
    CComponentData();
    ~CComponentData();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IComponentData
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
        /* [in] */ LPUNKNOWN pUnknown);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent( 
        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
        /* [in] */ LPDATAOBJECT lpDataObject,
        /* [in] */ MMC_NOTIFY_TYPE event,
        /* [in] */ LPARAM arg,
        /* [in] */ LPARAM param);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
        /* [in] */ MMC_COOKIE cookie,
        /* [in] */ DATA_OBJECT_TYPES type,
        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
        /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
        /* [in] */ LPDATAOBJECT lpDataObjectA,
        /* [in] */ LPDATAOBJECT lpDataObjectB);
};

#endif _SAMPCOMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nameext\sky.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SKY_H
#define _SKY_H

#include "DeleBase.h"


class CPlane : public CDelegationBase {
public:
    CPlane(_TCHAR *szName, int id, LONG lWeight, LONG lHeight, LONG lPayload);
    
    virtual ~CPlane();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SKYICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnAddMenuItems(IContextMenuCallback *pContextMenuCallback, long *pInsertionsAllowed);
    virtual HRESULT OnMenuCommand(IConsole *pConsole, long lCommandID);
    
private:
    // {2AF5EBCF-6ADC-11d3-9155-00C04F65B3F9}
    static const GUID thisGuid;

    _TCHAR *szName;
    LONG   lWeight;
    LONG   lHeight;
    LONG   lPayload;
    int    nId;
    enum {RUNNING, PAUSED, STOPPED} iStatus;
    enum { IDM_START_SKY = 100, IDM_PAUSE_SKY, IDM_STOP_SKY };
};


class CSkyVehicle : public CDelegationBase {
public:
    CSkyVehicle(int i);
    virtual ~CSkyVehicle() {}
    
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    virtual HRESULT OnAddMenuItems(IContextMenuCallback *pContextMenuCallback, long *pInsertionsAllowed);
    virtual HRESULT OnMenuCommand(IConsole *pConsole, long lCommandID);
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SKYICON; }
    
private:

    enum { IDM_NEW_SKY = 2 };    
	
	// {BD518283-6A2E-11d3-9154-00C04F65B3F9}
    static const GUID thisGuid;

    enum { NUMBER_OF_CHILDREN = 4 };
    CPlane *children[NUMBER_OF_CHILDREN];    

    int id;
};

#endif // _SKY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nameext\sky.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <stdio.h>
#include "sky.h"


const GUID CSkyVehicle::thisGuid = { 0xbd518283, 0x6a2e, 0x11d3, {0x91, 0x54, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9} };
const GUID CPlane::thisGuid = { 0x2af5ebcf, 0x6adc, 0x11d3, {0x91, 0x55, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9} };


//==============================================================
//
// CSkyVehicle implementation
//
//

CSkyVehicle::CSkyVehicle(int i) : id(i)
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CPlane(_T("Extension Space Vehicle"), n+1, 500000, 265, 75000);
    }
}

const _TCHAR *CSkyVehicle::GetDisplayName(int nCol) 
{
    static _TCHAR buf[128];
    
    _stprintf(buf, _T("Extension Planes"));
    
    return buf;
}

HRESULT CSkyVehicle::OnAddMenuItems(IContextMenuCallback *pContextMenuCallback, long *pInsertionsAllowed)
{
    HRESULT hr = S_OK;
    CONTEXTMENUITEM menuItemsNew[] =
    {
        {
            L"Menu item from extension", L"The NameExt sample adds this item",
                IDM_NEW_SKY, CCM_INSERTIONPOINTID_PRIMARY_NEW  , 0, CCM_SPECIAL_DEFAULT_ITEM
        },
        { NULL, NULL, 0, 0, 0 }
    };
    
    // Loop through and add each of the menu items
    if (*pInsertionsAllowed & CCM_INSERTIONALLOWED_NEW)
    {
        for (LPCONTEXTMENUITEM m = menuItemsNew; m->strName; m++)
        {
            hr = pContextMenuCallback->AddItem(m);
            
            if (FAILED(hr))
                break;
        }
    }
    
    return hr;
}

HRESULT CSkyVehicle::OnMenuCommand(IConsole *pConsole, long lCommandID)
{
    switch (lCommandID)
    {
    case IDM_NEW_SKY:
        pConsole->MessageBox(L"Menu item from namespace extension selected", L"Menu Command", MB_YESNO|MB_ICONQUESTION, NULL);
        break;
    }
    
    return S_OK;
}

HRESULT CSkyVehicle::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;
    
    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;
    
    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );
        
        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );
        
        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Plane Class", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 1, L"Plane Weight", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 2, L"Plane Height", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 3, L"Plane Payload", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 4, L"Plane", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        
        // insert items here
        RESULTDATAITEM rdi;
        
        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );
        
        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid
                
                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];
                
                hr = pResultData->InsertItem( &rdi );
                
                _ASSERT( SUCCEEDED(hr) );
            }
        }
        
        pHeaderCtrl->Release();
        pResultData->Release();
    }
    
    return hr;
}



//==============================================================
//
// CPlane implementation
//
//
 
CPlane::CPlane(_TCHAR *szName, int id, LONG lWeight, LONG lHeight, LONG lPayload) 
: szName(NULL), lWeight(0), lHeight(0), lPayload(0), iStatus(STOPPED)
{ 
    if (szName) {
        this->szName = new _TCHAR[(_tcslen(szName) + 1) * sizeof(_TCHAR)];
        _tcscpy(this->szName, szName);
    }
    
    this->nId = id;
    this->lWeight = lWeight;
    this->lHeight = lHeight;
    this->lPayload = lPayload;
}

CPlane::~CPlane() 
{
    if (szName)
        delete [] szName;
}

const _TCHAR *CPlane::GetDisplayName(int nCol) 
{
    static _TCHAR buf[128];
    
    switch (nCol) {
    case 0:
        _stprintf(buf, _T("%s (#%d)"), szName ? szName : _T(""), nId);
        break;
        
    case 1:
        _stprintf(buf, _T("%ld metric tons"), lWeight);
        break;
        
    case 2:
        _stprintf(buf, _T("%ld meters"), lHeight);
        break;
        
    case 3:
        _stprintf(buf, _T("%ld kilos"), lPayload);
        break;
        
    case 4:
        _stprintf(buf, _T("%s"),
            iStatus == RUNNING ? _T("running") : 
        iStatus == PAUSED ? _T("paused") :
        iStatus == STOPPED ? _T("stopped") : _T("unknown"));
        break;
        
    }
    
    return buf;
}

HRESULT CPlane::OnAddMenuItems(IContextMenuCallback *pContextMenuCallback, long *pInsertionsAllowed)
{
    HRESULT hr = S_OK;
    CONTEXTMENUITEM menuItemsTask[] =
    {
        {
            L"Start vehicle", L"Start the extension plane",
                IDM_START_SKY, CCM_INSERTIONPOINTID_PRIMARY_TASK  , 0, CCM_SPECIAL_DEFAULT_ITEM
        },
        {
            L"Pause vehicle", L"Pause the extension plane",
                IDM_PAUSE_SKY, CCM_INSERTIONPOINTID_PRIMARY_TASK, 0, 0
        },
        {
            L"Stop vehicle", L"Stop the extension plane",
                IDM_STOP_SKY, CCM_INSERTIONPOINTID_PRIMARY_TASK, 0, 0
        },
        { NULL, NULL, 0, 0, 0 }
    };
    
    // Loop through and add each of the menu items
    if (*pInsertionsAllowed & CCM_INSERTIONALLOWED_TASK)
    {
        for (LPCONTEXTMENUITEM m = menuItemsTask; m->strName; m++)
        {
            hr = pContextMenuCallback->AddItem(m);
            
            if (FAILED(hr))
                break;
        }
    }
    
    return hr;
}

HRESULT CPlane::OnMenuCommand(IConsole *pConsole, long lCommandID)
{
    _TCHAR szVehicle[128];
    
    switch (lCommandID) {
    case IDM_START_SKY:
        iStatus = RUNNING;
        break;
        
    case IDM_PAUSE_SKY:
        iStatus = PAUSED;
        break;
        
    case IDM_STOP_SKY:
        iStatus = STOPPED;
        break;
    }
    
    _stprintf(szVehicle, _T("%s has been %s"), GetDisplayName(0), 
        (long)iStatus == RUNNING ? _T("started") : 
    (long)iStatus == PAUSED ? _T("paused") :
    (long)iStatus == STOPPED ? _T("stopped") : _T("!!!unknown command!!!"));
    
    MAKE_WIDEPTR_FROMTSTR(ptrname, szVehicle);
    int ret = 0;
    pConsole->MessageBox(ptrname,
        L"Vehicle command", MB_OK | MB_ICONINFORMATION, &ret);
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\backgrnd.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Backgrnd.h"

const GUID CBackgroundFolder::thisGuid = { 0x2974380f, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };
const GUID CBackground::thisGuid = { 0x2974380f, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

#define WM_NEWOBJECT WM_APP
#define WM_DISCOVERYCOMPLETE (WM_APP + 1)

//==============================================================
//
// CBackgroundFolder implementation
//
//
CBackgroundFolder::CBackgroundFolder()
: m_pConsoleNameSpace(NULL), m_scopeitem(0), m_threadId(0), m_thread(NULL), 
m_running(false), m_bViewUpdated(false)
{
    ZeroMemory(m_children, sizeof(m_children));

    WNDCLASS wndClass;

    ZeroMemory(&wndClass, sizeof(WNDCLASS));

    wndClass.lpfnWndProc = WindowProc; 
    wndClass.lpszClassName = _T("backgroundthreadwindow"); 
    wndClass.hInstance = g_hinst;

    ATOM atom = RegisterClass(&wndClass);
    m_backgroundHwnd = CreateWindow(
            _T("backgroundthreadwindow"),  // pointer to registered class name
            NULL, // pointer to window name
            0,        // window style
            0,                // horizontal position of window
            0,                // vertical position of window
            0,           // window width
            0,          // window height
            NULL,      // handle to parent or owner window
            NULL,          // handle to menu or child-window identifier
            g_hinst,     // handle to application instance
            (void *)this        // pointer to window-creation data
        );

    if (m_backgroundHwnd)
        SetWindowLong(m_backgroundHwnd, GWL_USERDATA, (LONG)this);

    InitializeCriticalSection(&m_critSect);
}

CBackgroundFolder::~CBackgroundFolder()
{
    StopThread();

    for (int n = 0; n < MAX_CHILDREN; n++)
        if (m_children[n] != NULL)
            delete m_children[n];

    if (m_backgroundHwnd != NULL)
        DestroyWindow(m_backgroundHwnd);

    UnregisterClass(_T("backgroundthreadwindow"), NULL);

    DeleteCriticalSection(&m_critSect);
}

LRESULT CALLBACK CBackgroundFolder::WindowProc(
      HWND hwnd,      // handle to window
      UINT uMsg,      // message identifier
      WPARAM wParam,  // first message parameter
      LPARAM lParam   // second message parameter
    )
{
    CBackgroundFolder *pThis = (CBackgroundFolder *)GetWindowLong(hwnd, GWL_USERDATA);

    switch (uMsg) {
    case WM_NEWOBJECT:
        _ASSERT(pThis != NULL);
        pThis->AddItem(lParam);
        break;

    case WM_DISCOVERYCOMPLETE:
        _ASSERT(pThis != NULL);
        pThis->m_bViewUpdated = true;
        pThis->StopThread();
        break;
   }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

DWORD WINAPI CBackgroundFolder::ThreadProc(
  LPVOID lpParameter   // thread data
)
{
    CBackgroundFolder *pThis = (CBackgroundFolder *)lpParameter;

    EnterCriticalSection(&pThis->m_critSect);
    pThis->m_running = true;
    LeaveCriticalSection(&pThis->m_critSect);

    for (int n = 0; n < MAX_CHILDREN; n++) {
        EnterCriticalSection(&pThis->m_critSect);
        bool running = pThis->m_running;
        LeaveCriticalSection(&pThis->m_critSect);

        if (running == false)
            return 0;

        PostMessage(pThis->m_backgroundHwnd, WM_NEWOBJECT, 0, n);
        Sleep(500);
    }

    PostMessage(pThis->m_backgroundHwnd, WM_DISCOVERYCOMPLETE, 0, 0);

    return 0;
}

void CBackgroundFolder::StartThread()
{
    EnterCriticalSection(&m_critSect);
    m_thread = CreateThread(NULL, 0, ThreadProc, (void *)this, 0, &m_threadId);
    LeaveCriticalSection(&m_critSect);
}

void CBackgroundFolder::StopThread()
{
    EnterCriticalSection(&m_critSect);
    m_running = false;

    if (m_thread != NULL) {
        // this is ugly, wait for 10 seconds, then kill the thread
        DWORD res = WaitForSingleObject(m_thread, 10000);

        if (res == WAIT_TIMEOUT)
            TerminateThread(m_thread, 0);

        CloseHandle(m_thread);

        m_thread = NULL;
    }
    LeaveCriticalSection(&m_critSect);
}

void CBackgroundFolder::AddItem(int id)
{
    HRESULT hr;

    EnterCriticalSection(&m_critSect);

    _ASSERT(m_children[id] == NULL);

    m_children[id] = new CBackground(id);

    SCOPEDATAITEM sdi;

    // insert items here
    ZeroMemory(&sdi, sizeof(SCOPEDATAITEM));

    sdi.mask = SDI_STR       |   // Displayname is valid
        SDI_PARAM     |   // lParam is valid
        SDI_IMAGE     |   // nImage is valid
        SDI_OPENIMAGE |   // nOpenImage is valid
        SDI_PARENT    |
        SDI_CHILDREN;
    
    sdi.relativeID  = (HSCOPEITEM)m_scopeitem;
    sdi.nImage      = m_children[id]->GetBitmapIndex();
    sdi.nOpenImage  = INDEX_OPENFOLDER;
    sdi.displayname = MMC_CALLBACK;
    sdi.lParam      = (LPARAM)m_children[id];       // The cookie
    sdi.cChildren   = 0;

    hr = m_pConsoleNameSpace->InsertItem( &sdi );
    _ASSERT( SUCCEEDED(hr) );

    m_children[id]->SetHandle(sdi.ID);
    
    LeaveCriticalSection(&m_critSect);

    return;
}

HRESULT CBackgroundFolder::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi) 
{
    return pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}

HRESULT CBackgroundFolder::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    // cache the stuff
    m_pConsoleNameSpace = pConsoleNameSpace;
    m_scopeitem = parent;

    if (m_bViewUpdated == false && m_running == false)
        StartThread();

    return S_OK;
}

HRESULT CBackgroundFolder::OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect)
{
    m_bSelected = (bSelect && bScope) ? true : false;

    if (bSelect && !m_running) {
        IConsoleVerb *pConsoleVerb;
    
        HRESULT hr = pConsole->QueryConsoleVerb(&pConsoleVerb);
        _ASSERT(SUCCEEDED(hr));
    
        hr = pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);
    
        pConsoleVerb->Release();
    }
    
    return S_OK;
}

HRESULT CBackgroundFolder::OnRefresh()
{
    HRESULT hr = S_OK;

    StopThread();

    EnterCriticalSection(&m_critSect);
    for (int n = 0; n < MAX_CHILDREN; n++) {
        if (m_children[n] != NULL) {
            HSCOPEITEM hItem = m_children[n]->GetHandle();
            hr = m_pConsoleNameSpace->DeleteItem(hItem, TRUE);

            delete m_children[n];
            m_children[n] = NULL;
        }
    }
    LeaveCriticalSection(&m_critSect);

    m_bViewUpdated = false;

    StartThread();

    return S_OK;
}

const _TCHAR *CBackground::GetDisplayName(int nCol) 
{
    _TCHAR buf[128];
    
    wsprintf(buf, _T("Background object #%d"), m_id);
    
    _TCHAR *pszCol = 
        static_cast<_TCHAR *>(CoTaskMemAlloc((_tcslen(buf) + 1) * sizeof(_TCHAR)));
    _tcscpy(pszCol, buf);
    
    return pszCol;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\delebase.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DeleBase.h"

const GUID CDelegationBase::thisGuid = { 0x2974380b, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

HBITMAP CDelegationBase::m_pBMapSm = NULL;
HBITMAP CDelegationBase::m_pBMapLg = NULL;


//==============================================================
//
// CDelegationBase implementation
//
//
CDelegationBase::CDelegationBase() 
: bExpanded(FALSE) 
{ 
    if (NULL == m_pBMapSm || NULL == m_pBMapLg)
        LoadBitmaps(); 
}

CDelegationBase::~CDelegationBase() 
{ 
}

// CDelegationBase::AddImages sets up the collection of images to be displayed
// by the IComponent in the result pane as a result of its MMCN_SHOW handler
HRESULT CDelegationBase::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi) 
{
    return pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\backgrnd.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _BACKGROUND_H
#define _BACKGROUND_H

#include "DeleBase.h"

class CBackground : public CDelegationBase {
public:
    CBackground(int id) : m_itemId(NULL), m_id(id) { }
    virtual ~CBackground() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_BACKGROUND; }
    
    void SetHandle(HSCOPEITEM itemId) { m_itemId = itemId; }
    HSCOPEITEM GetHandle() { return m_itemId; }

private:
    enum { IDM_NEW_BACKGROUND = 6 };
    
    static const GUID thisGuid;
    int m_id;
    HSCOPEITEM m_itemId;
};

class CBackgroundFolder : public CDelegationBase {
public:
    CBackgroundFolder();
    virtual ~CBackgroundFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Background Objects"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_BACKGROUND; }

public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect);
    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    virtual HRESULT OnRefresh();
   
private:
    enum { MAX_CHILDREN = 30 };

    CBackground *m_children[MAX_CHILDREN];

    HWND m_backgroundHwnd;
    
    static const GUID thisGuid;

    static LRESULT CALLBACK WindowProc(
          HWND hwnd,      // handle to window
          UINT uMsg,      // message identifier
          WPARAM wParam,  // first message parameter
          LPARAM lParam   // second message parameter
        );

    static DWORD WINAPI ThreadProc(
      LPVOID lpParameter   // thread data
    );

    DWORD m_threadId;
    HANDLE m_thread;
    bool m_running;

    IConsoleNameSpace *m_pConsoleNameSpace;
    HSCOPEITEM m_scopeitem;
    void AddItem(int id);

    CRITICAL_SECTION m_critSect;

    void StopThread();
    void StartThread();

    bool m_bSelected;
    bool m_bViewUpdated;
};


#endif // _BACKGROUND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\dataobj.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPDATAOBJECT_H_
#define _SAMPDATAOBJECT_H_

#include <mmc.h>
#include "DeleBase.h"

class CDataObject : public IDataObject
{
private:
    ULONG				m_cref;
    MMC_COOKIE			m_lCookie;
    DATA_OBJECT_TYPES   m_context;
    
public:
    CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context);
    ~CDataObject();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // IDataObject methods 
    ///////////////////////////////
    STDMETHODIMP GetDataHere (FORMATETC *pformatetc, STGMEDIUM *pmedium);
    
    // The rest are not implemented
    STDMETHODIMP GetData (LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumFormatEtc (DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };
    
    STDMETHODIMP QueryGetData (LPFORMATETC lpFormatetc) 
    { return E_NOTIMPL; };
    
    STDMETHODIMP GetCanonicalFormatEtc (LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    
    STDMETHODIMP SetData (LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DAdvise (LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DUnadvise (DWORD dwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumDAdvise (LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };
    
    ///////////////////////////////
    // Custom Methods
    ///////////////////////////////
    
    CDelegationBase *GetBaseNodeObject() {
        return (CDelegationBase *)m_lCookie;
    }
    
    DATA_OBJECT_TYPES GetContext() {
        return m_context;
    }
    
public:
    // clipboard formats
    static UINT s_cfSZNodeType;
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
    static UINT s_cfInternal;
    
};

HRESULT ExtractFromDataObject(IDataObject *lpDataObject,UINT cf,ULONG cb,HGLOBAL *phGlobal);
CDataObject* GetOurDataObject(IDataObject *lpDataObject);
BOOL IsMMCMultiSelectDataObject(IDataObject *lpDataObject);

#endif _SAMPDATAOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\comp.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "DataObj.h"
#include <commctrl.h>        // Needed for button styles...
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "DeleBase.h"
#include "CompData.h"

CComponent::CComponent(CComponentData *parent)
: m_pComponentData(parent), m_cref(0), m_ipConsole(NULL), m_pLastNode(NULL)
{
    OBJECT_CREATED
}

CComponent::~CComponent()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IComponent))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IResultOwnerData))
        *ppv = static_cast<IResultOwnerData *>(this);
    
    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponent::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponent::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
    
}

///////////////////////////////
// Interface IComponent
///////////////////////////////
STDMETHODIMP CComponent::Initialize( 
                                    /* [in] */ LPCONSOLE lpConsole)
{
    HRESULT hr = S_OK;
    
    // Save away all the interfaces we'll need.
    // Fail if we can't QI the required interfaces.
    
    m_ipConsole = lpConsole;
    m_ipConsole->AddRef();
    
    return hr;
}

STDMETHODIMP CComponent::Notify( 
                                /* [in] */ LPDATAOBJECT lpDataObject,
                                /* [in] */ MMC_NOTIFY_TYPE event,
                                /* [in] */ LPARAM arg,
                                /* [in] */ LPARAM param)
{
    MMCN_Crack(FALSE, lpDataObject, NULL, this, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();
    
    switch (event)	{
    case MMCN_SHOW: 
        hr = base->OnShow(m_ipConsole, (BOOL)arg, (HSCOPEITEM)param);
        break;
        
    case MMCN_ADD_IMAGES:
        hr = base->OnAddImages((IImageList *)arg, (HSCOPEITEM)param);
        break;
        
    case MMCN_SELECT:
        hr = base->OnSelect(m_ipConsole, (BOOL)LOWORD(arg), (BOOL)HIWORD(arg));
        break;
        
    case MMCN_RENAME:
        hr = base->OnRename((LPOLESTR)param);
        break;
        
    case MMCN_REFRESH:
        hr = base->OnRefresh();
        break;
    }
    
    return hr;
}

STDMETHODIMP CComponent::Destroy( 
                                 /* [in] */ MMC_COOKIE cookie)
{
    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }
    
    return S_OK;
}


STDMETHODIMP CComponent::QueryDataObject( 
                                         /* [in] */ MMC_COOKIE cookie,
                                         /* [in] */ DATA_OBJECT_TYPES type,
                                         /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject)
{
    CDataObject *pObj = NULL;
	CDelegationBase *pBase = NULL;

	if (IsBadReadPtr((void *)cookie, sizeof(CDelegationBase))) {
		if (NULL == m_pLastNode)
			return E_FAIL;

		pBase = m_pLastNode->GetChildPtr((int)cookie);
	} else {
		pBase = (cookie == 0) ? m_pComponentData->m_pStaticNode : (CDelegationBase *)cookie;
	}
    
	if (pBase == NULL)
		return E_FAIL;

    pObj = new CDataObject((MMC_COOKIE)pBase, type);

    if (!pObj)
        return E_OUTOFMEMORY;
    
    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);
    
    return S_OK;
}

STDMETHODIMP CComponent::GetResultViewType( 
                                           /* [in] */ MMC_COOKIE cookie,
                                           /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
                                           /* [out] */ long __RPC_FAR *pViewOptions)
{
    CDelegationBase *base = m_pLastNode = (CDelegationBase *)cookie;
    
    //
    // Ask for default listview.
    //
    if (base == NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
        *ppViewType = NULL;
    }
    else
        return base->GetResultViewType(ppViewType, pViewOptions);
    
    return S_OK;
}

STDMETHODIMP CComponent::GetDisplayInfo( 
                                        /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem)
{
    HRESULT hr = S_OK;
    CDelegationBase *base = NULL;

    // if they are asking for the RDI_STR we have one of those to give

    if (pResultDataItem->lParam) {
        base = (CDelegationBase *)pResultDataItem->lParam;
        if (pResultDataItem->mask & RDI_STR) {
			LPCTSTR pszT = base->GetDisplayName(pResultDataItem->nCol);
			MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pResultDataItem->str = pszW;
        }

        if (pResultDataItem->mask & RDI_IMAGE) {
            pResultDataItem->nImage = base->GetBitmapIndex();
        }
    } else {
        m_pLastNode->GetChildColumnInfo(pResultDataItem);
    }

    return hr;
}


STDMETHODIMP CComponent::CompareObjects( 
                                        /* [in] */ LPDATAOBJECT lpDataObjectA,
                                        /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();
    
    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;
    
    return S_FALSE;
}

///////////////////////////////
// Interface IComponent
///////////////////////////////
STDMETHODIMP CComponent::FindItem( 
/* [in] */ LPRESULTFINDINFO pFindInfo,
/* [out] */ int __RPC_FAR *pnFoundIndex)
{
    return E_NOTIMPL;
}

STDMETHODIMP CComponent::CacheHint( 
/* [in] */ int nStartIndex,
/* [in] */ int nEndIndex)
{
    return E_NOTIMPL;
}

STDMETHODIMP CComponent::SortItems( 
/* [in] */ int nColumn,
/* [in] */ DWORD dwSortOptions,
/* [in] */ LPARAM lUserParam)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\comp.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMP_H_
#define _SAMPCOMP_H_

#include <mmc.h>

class CComponent : public IComponent, IResultOwnerData
{
private:
    ULONG				m_cref;
    
    IConsole*		m_ipConsole;
    
    class CComponentData *m_pComponentData;
    class CDelegationBase *m_pLastNode;
    
    public:
        CComponent(CComponentData *parent);
        ~CComponent();
        
        ///////////////////////////////
        // Interface IUnknown
        ///////////////////////////////
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        
        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ MMC_COOKIE cookie);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);

        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindItem( 
            /* [in] */ LPRESULTFINDINFO pFindInfo,
            /* [out] */ int __RPC_FAR *pnFoundIndex);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CacheHint( 
            /* [in] */ int nStartIndex,
            /* [in] */ int nEndIndex);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SortItems( 
            /* [in] */ int nColumn,
            /* [in] */ DWORD dwSortOptions,
            /* [in] */ LPARAM lUserParam);
};

#endif _SAMPCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>

#ifndef STRINGS_ONLY
	#define IDM_BUTTON1    0x100
	#define IDM_BUTTON2    0x101

	extern HINSTANCE g_hinst;
	extern ULONG g_uObjects;

	#define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
	#define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

	// uncomment the following #define to enable message cracking
	// #define MMC_CRACK_MESSAGES
	void MMCN_Crack(BOOL bComponentData, 
					IDataObject *pDataObject, 
					IComponentData *pCompData,
					IComponent *pComp,
					MMC_NOTIFY_TYPE event, 
					LPARAM arg, 
					LPARAM param);
#endif

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(GetProcessHeap(), 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(GetProcessHeap(), 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given a _TCHAR, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszT;
//  pszT = MyGetTStringRoutine();
//  MAKE_WIDEPTR_FROMSTR(pwsz, pszT);
//  MyUseWideStringRoutine(pwsz);
//  ...
#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPWSTR)__TempBuffer##ptrname.GetBuffer(), tstr); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    lstrcpyW((LPWSTR)ptrname, tstr)
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, ptrname, __l##ptrname)
#endif

//
// similarily for MAKE_TSTRPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
// * 2 for DBCS handling in below length computation
//
#ifdef UNICODE
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPTSTR)__TempBuffer##ptrname.GetBuffer(), widestr); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\land.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Land.h"

const GUID CLandBasedVehicle::thisGuid = { 0x2974380e, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CLandBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\land.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _LAND_H
#define _LAND_H

#include "DeleBase.h"

class CLandBasedVehicle : public CDelegationBase {
public:
    CLandBasedVehicle() { }
    
    virtual ~CLandBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Land-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_LANDICON; }
    
private:
    enum { IDM_NEW_LAND = 2 };
    
    // {2974380E-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};


#endif // _LAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\mmccrack.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

static TCHAR *MMCN_CrackVerb(MMC_CONSOLE_VERB verb)
{
	static TCHAR error[64];

	switch (verb) {
    case MMC_VERB_NONE:
		return _T("NONE");
    case MMC_VERB_OPEN:
		return _T("OPEN");
    case MMC_VERB_COPY:
		return _T("COPY");
    case MMC_VERB_PASTE:
		return _T("PASTE");
    case MMC_VERB_DELETE:
		return _T("DELETE");
    case MMC_VERB_PROPERTIES:
		return _T("PROPERTIES");
    case MMC_VERB_RENAME:
		return _T("RENAME");
    case MMC_VERB_REFRESH:
		return _T("REFRESH");
    case MMC_VERB_PRINT:
		return _T("PRINT");
    case MMC_VERB_CUT:
		return _T("CUT");
	default:
		wsprintf(error, _T("Unknown verb id %d"), verb);
		return error;
	}
}

void MMCN_Crack(BOOL bComponentData, 
                IDataObject *pDataObject,
				IComponentData *pCompData,
				IComponent *pComp,
                MMC_NOTIFY_TYPE event, 
				LPARAM arg, 
				LPARAM param)
{
#ifdef MMC_CRACK_MESSAGES
	TCHAR message[256] = {0};

	if (bComponentData == TRUE)
		OutputDebugString(_T("IComponentData::Notify( "));
	else
		OutputDebugString(_T("IComponent::Notify( "));

	wsprintf(message, _T("DataObject: %08x, CompData: %08x, Comp: %08x ) - "), pDataObject, pCompData, pComp);
	OutputDebugString(message);

    switch (event)	{
		case MMCN_ACTIVATE:
			wsprintf(message, _T("MMCN_ACTIVATE\n\tActivate: %d\n"), arg);
			break;

		case MMCN_ADD_IMAGES:
			wsprintf(message, _T("MMCN_ADD_IMAGES\n\tImage List: %08x\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_BTN_CLICK:
			wsprintf(message, _T("MMCN_BTN_CLICK\n\tVerb: %ws\n"), MMCN_CrackVerb((MMC_CONSOLE_VERB)param));
			break;

		case MMCN_COLUMN_CLICK:
			wsprintf(message, _T("MMCN_COLUMN_CLICK\n\tColumn: %d\n\tSort Option: %d\n"), arg,	 param);
			break;

		case MMCN_COLUMNS_CHANGED:
			wsprintf(message, _T("MMCN_COLUMNS_CHANGED\n"));
			break;

		case MMCN_CONTEXTHELP:
			wsprintf(message, _T("MMCN_CONTEXTHELP\n"));
			break;

		case MMCN_CONTEXTMENU:
			wsprintf(message, _T("MMCN_CONTEXTMENU\n"));
			break;

		case MMCN_CUTORMOVE:
			wsprintf(message, _T("MMCN_CUTORMOVE\n"));
			break;

		case MMCN_DBLCLICK:
			wsprintf(message, _T("MMCN_DBLCLICK\n"));
			break;

		case MMCN_DELETE:
			wsprintf(message, _T("MMCN_DELETE\n"));
			break;

		case MMCN_DESELECT_ALL:
			wsprintf(message, _T("MMCN_DESELECT_ALL\n"));
			break;

		case MMCN_EXPAND:
			wsprintf(message, _T("MMCN_EXPAND\n\tExpand: %d\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_EXPANDSYNC:
			wsprintf(message, _T("MMCN_EXPANDSYNC\n"));
			break;

		case MMCN_FILTERBTN_CLICK:
			wsprintf(message, _T("MMCN_FILTERBTN_CLICK\n\tColumn: %d\n"), arg);
			break;

		case MMCN_FILTER_CHANGE:
			wsprintf(message, _T("MMCN_FILTER_CHANGE\n\tColumn: %d\n"), param);
			break;

		case MMCN_HELP:
			wsprintf(message, _T("MMCN_HELP\n"));
			break;

		case MMCN_INITOCX:
			wsprintf(message, _T("MMCN_INITOCX\n\tIUnknown: %08x\n"), param);
			break;

		case MMCN_LISTPAD:
			wsprintf(message, _T("MMCN_LISTPAD\n\tConnect: %d\n"), arg);
			break;

		case MMCN_MENU_BTNCLICK:
			wsprintf(message, _T("MMCN_MENU_BTNCLICK\n"));
			break;

		case MMCN_MINIMIZED:
			wsprintf(message, _T("MMCN_MINIMIZED\n\tMinimized: %d\n"), arg);
			break;

		case MMCN_PASTE:
			wsprintf(message, _T("MMCN_PASTE\n\tCopy: %d\n"), param == NULL);
			break;

		case MMCN_PRELOAD:
			wsprintf(message, _T("MMCN_PRELOAD\n\tScope Item: %08x\n"), arg);
			break;

		case MMCN_PRINT:
			wsprintf(message, _T("MMCN_PRINT\n"));
			break;

		case MMCN_PROPERTY_CHANGE:
			wsprintf(message, _T("MMCN_PROPERTY_CHANGE\n\tScope: %d\n\tArg: %08x\n"), arg, param);
			break;

		case MMCN_QUERY_PASTE:
			wsprintf(message, _T("MMCN_QUERY_PASTE\n"));
			break;

		case MMCN_REFRESH:
			wsprintf(message, _T("MMCN_REFRESH\n"));
			break;

		case MMCN_REMOVE_CHILDREN:
			wsprintf(message, _T("MMCN_REMOVE_CHILDREN\n\tScope Item: %08x\n"), arg);
			break;

		case MMCN_RENAME:
			wsprintf(message, _T("MMCN_RENAME\n\tNew Name: '%ws'\n"), (LPOLESTR)param);
			break;

		case MMCN_RESTORE_VIEW:
			wsprintf(message, _T("MMCN_RESTORE_VIEW\n"));
			break;

		case MMCN_SELECT:
			wsprintf(message, _T("MMCN_SELECT\n\tScope: %d\n\tSelect: %08x\n"), LOWORD(arg), HIWORD(arg));
			break;

		case MMCN_SHOW:
			wsprintf(message, _T("MMCN_SHOW\n\tShow: %d\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_SNAPINHELP:
			wsprintf(message, _T("MMCN_SNAPINHELP\n"));
			break;

		case MMCN_VIEW_CHANGE:
			wsprintf(message, _T("MMCN_VIEW_CHANGE\n\tData: %08x\n\tHint: %08x\n"), arg, param);
			break;
	}

	if (message[0] != 0)
		OutputDebugString(message);
	else
		OutputDebugString(_T("unknown event\n"));

#endif
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\compdata.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "CompData.h"
#include "DataObj.h"
#include "resource.h"
#include <crtdbg.h>

CComponentData::CComponentData()
: m_cref(0), m_ipConsoleNameSpace(NULL), m_ipConsole(NULL)
{
    OBJECT_CREATED
        
        m_pStaticNode = new CStaticNode;
}

CComponentData::~CComponentData()
{
    if (m_pStaticNode) {
        delete m_pStaticNode;
    }
    
    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CComponentData::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_IComponentData))
        *ppv = static_cast<IComponentData *>(this);
    
    if (*ppv) 
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponentData::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponentData::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    
    return m_cref;
}

///////////////////////////////
// Interface IComponentData
///////////////////////////////
HRESULT CComponentData::Initialize( 
                                   /* [in] */ LPUNKNOWN pUnknown)
{
    HRESULT      hr;
    
    //
    // Get pointer to name space interface
    //
    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (void **)&m_ipConsoleNameSpace);
    _ASSERT( S_OK == hr );
    
    //
    // Get pointer to console interface
    //
    hr = pUnknown->QueryInterface(IID_IConsole, (void **)&m_ipConsole);
    _ASSERT( S_OK == hr );
    
    IImageList *pImageList;
    m_ipConsole->QueryScopeImageList(&pImageList);
    _ASSERT( S_OK == hr );
    
    hr = pImageList->ImageListSetStrip(	(long *)m_pStaticNode->m_pBMapSm, // pointer to a handle
        (long *)m_pStaticNode->m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
    
    pImageList->Release();
    
    return S_OK;
}

HRESULT CComponentData::CreateComponent( 
                                        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent) 
{
    *ppComponent = NULL;
    
    CComponent *pComponent = new CComponent(this);
    
    if (NULL == pComponent)
        return E_OUTOFMEMORY;
    
    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent);
}

HRESULT CComponentData::Notify( 
                               /* [in] */ LPDATAOBJECT lpDataObject,
                               /* [in] */ MMC_NOTIFY_TYPE event,
                               /* [in] */ LPARAM arg,
                               /* [in] */ LPARAM param)
{
    MMCN_Crack(TRUE, lpDataObject, this, NULL, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();
    
    switch (event)
    {
    case MMCN_EXPAND: 
        hr = base->OnExpand(m_ipConsoleNameSpace, m_ipConsole, (HSCOPEITEM)param);
        break;

    case MMCN_ADD_IMAGES:
        hr = base->OnAddImages((IImageList *)arg, (HSCOPEITEM)param);
        break;
    }
    
    return hr;
}

HRESULT CComponentData::Destroy( void)
{
    // Free interfaces
    if (m_ipConsoleNameSpace) {
        m_ipConsoleNameSpace->Release();
        m_ipConsoleNameSpace = NULL;
    }
    
    if (m_ipConsole) {
        m_ipConsole->Release(); 
        m_ipConsole = NULL;
    }
    
    return S_OK;
}

HRESULT CComponentData::QueryDataObject( 
                                        /* [in] */ MMC_COOKIE cookie,
                                        /* [in] */ DATA_OBJECT_TYPES type,
                                        /* [out] */ LPDATAOBJECT *ppDataObject) 
{
    CDataObject *pObj = NULL;
    
    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);
    
    return S_OK;
}

HRESULT CComponentData::GetDisplayInfo( 
                                       /* [out][in] */ SCOPEDATAITEM *pScopeDataItem)
{
    HRESULT hr = S_FALSE;
    
    // if they are asking for the SDI_STR we have one of those to give
    if (pScopeDataItem->lParam) {
        CDelegationBase *base = (CDelegationBase *)pScopeDataItem->lParam;
        if (pScopeDataItem->mask & SDI_STR) {
			LPCTSTR pszT = base->GetDisplayName();
			MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pScopeDataItem->displayname = pszW;
        }

        if (pScopeDataItem->mask & SDI_IMAGE) {
            pScopeDataItem->nImage = base->GetBitmapIndex();
        }
    }
    
    return hr;
}

HRESULT CComponentData::CompareObjects( 
                                       /* [in] */ LPDATAOBJECT lpDataObjectA,
                                       /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();
    
    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;
    
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\people.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _PEOPLE_H
#define _PEOPLE_H

#include "DeleBase.h"

class CBicycle : public CDelegationBase {
public:
    CBicycle(int i) : id(i) { }
    virtual ~CBicycle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CBicycleFolder : public CDelegationBase {
public:
    CBicycleFolder();
    virtual ~CBicycleFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Bicycles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CSkateboard : public CDelegationBase {
public:
    CSkateboard(int i) : id(i) { }
    virtual ~CSkateboard() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CSkateboardFolder : public CDelegationBase {
public:
    CSkateboardFolder();
    virtual ~CSkateboardFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Skateboards"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CIceSkate : public CDelegationBase {
public:
    CIceSkate(int i) : id(i) { }
    virtual ~CIceSkate() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CIceSkateFolder : public CDelegationBase {
public:
    CIceSkateFolder();
    virtual ~CIceSkateFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Ice Skates"); }
    virtual void GetChildColumnInfo(RESULTDATAITEM *rdi);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }

	virtual CDelegationBase *GetChildPtr(int index) { 
		return (index < NUMBER_OF_CHILDREN) ? children[index] : NULL;
	}

    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions);
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 5000 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CPeoplePoweredVehicle : public CDelegationBase {
public:
    CPeoplePoweredVehicle();
    virtual ~CPeoplePoweredVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("People-powered Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { IDM_NEW_PEOPLE = 1 };
    
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 3 };
    CDelegationBase *children[3];
};

#endif // _PEOPLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\registry.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions = FALSE);

HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Resources.rc
//
#define IDS_HELPFILE                    1
#define IDS_SNAPINDESC                  2
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDI_ICON1                       108
#define IDB_SMOPEN                      111
#define IDB_SMBMP                       112
#define IDB_LGBMP                       113
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDB_ROCKET                      40004
#define IDB_CAR                         40005
#define IDB_PLANE                       40006
#define IDB_BIKE                        40007
#define IDB_ROCKET2                     40008
#define IDB_CAR2                        40009
#define IDB_PLANE2                      40010
#define IDB_BIKE2                       40011
#define IDB_CLOSED2                     40012
#define IDB_OPEN2                       40013
#define IDB_CLOSED                      40014
#define IDB_OPEN                        40015

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        114
#define _APS_NEXT_COMMAND_VALUE         40016
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\dataobj.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DataObj.h"
#include "guids.h"
#include "DeleBase.h"

//
// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SZNODETYPE _T("CCF_SZNODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

#define _T_CCF_INTERNAL_SNAPIN _T("{2479DB32-5276-11d2-94F5-00C04FB92EC2}")

    // These are the clipboard formats that we must supply at a minimum.
    // mmc.h actually defined these. We can make up our own to use for
    // other reasons. We don't need any others at this time.
UINT CDataObject::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CDataObject::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CDataObject::s_cfSZNodeType  = RegisterClipboardFormat(_T_CCF_SZNODETYPE);
UINT CDataObject::s_cfSnapinClsid = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);
UINT CDataObject::s_cfInternal    = RegisterClipboardFormat(_T_CCF_INTERNAL_SNAPIN);


CDataObject::CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context)
: m_lCookie(cookie), m_context(context), m_cref(0)
{
}

CDataObject::~CDataObject()
{
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IDataObject *>(this);
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppv = static_cast<IDataObject *>(this);
    
    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CDataObject::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
    
}

/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
// 
HRESULT CDataObject::GetDataHere(
                                 FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure 
                                 STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure  
                                 )
{
    const   CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pStream = NULL;
    
    CDelegationBase *base = GetBaseNodeObject();
    
    HRESULT hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( FAILED(hr) )
        return hr;                       // Minimal error checking
    
    hr = DV_E_FORMATETC;                 // Unknown format

    if (cf == s_cfDisplayName) {
        const _TCHAR *pszName = base->GetDisplayName();

		MAKE_WIDEPTR_FROMTSTR(wszName, pszName);
        
		// get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(pszName);
        ulSizeofName++;                      // Count null character
        ulSizeofName *= sizeof(WCHAR);
        
        hr = pStream->Write(wszName, ulSizeofName, NULL);
    } else if (cf == s_cfNodeType) {
        const GUID *pGUID = (const GUID *)&base->getNodeType();
        
        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfSZNodeType) {
        LPOLESTR szGuid;
        hr = StringFromCLSID(base->getNodeType(), &szGuid);
        
        if (SUCCEEDED(hr)) {
            hr = pStream->Write(szGuid, wcslen(szGuid), NULL);
            CoTaskMemFree(szGuid);
        }
    } else if (cf == s_cfSnapinClsid) {
        const GUID *pGUID = NULL;
        pGUID = &CLSID_CComponentData;
        
        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfInternal) {
        // we are being asked to get our this pointer from the IDataObject interface
        // only our own snap-in objects will know how to do this.
        CDataObject *pThis = this;
        hr = pStream->Write( &pThis, sizeof(CDataObject*), NULL );
    }
    
    pStream->Release();
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Global helper functions to help work with dataobjects and
// clipboard formats


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfInternal clipboard format
// 
CDataObject* GetOurDataObject (
                               LPDATAOBJECT lpDataObject      // [in] IComponent pointer 
                               )
{
    HRESULT       hr      = S_OK;
    CDataObject *pSDO     = NULL;

	// check to see if the data object is a special data object.
	if ( IS_SPECIAL_DATAOBJECT (lpDataObject) )
	{
		//Code for handling a special data object goes here.

		//Note that the MMC SDK samples do not handle
		//special data objects, so we exit if we get one.
		return NULL;
	}
   
    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { CDataObject::s_cfInternal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    
    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(CDataObject *));
    
    if (!stgmedium.hGlobal)	{
        hr = E_OUTOFMEMORY;
    }
    
    if SUCCEEDED(hr)
        // Attempt to get data from the object
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );
    
    // stgmedium now has the data we need 
    if (SUCCEEDED(hr))  {
        pSDO = *(CDataObject **)(stgmedium.hGlobal);
    }
    
    // if we have memory free it
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);
    
    return pSDO;
    
} // end GetOurDataObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\sky.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Sky.h"

const GUID CSkyBasedVehicle::thisGuid = { 0x2974380f, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSkyBasedVehicle implementation
//
//
HRESULT CSkyBasedVehicle::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
	HRESULT hr;
	IUnknown *pUnk = NULL;
	IMessageView *pMessageView = NULL;

	hr = pConsole->QueryResultView(&pUnk);

	if (SUCCEEDED(hr)) {
		hr = pUnk->QueryInterface(IID_IMessageView, (void **)&pMessageView);

		if (SUCCEEDED(hr)) {
			pMessageView->SetIcon(Icon_Information);
			pMessageView->SetTitleText(L"Sky-based vehicles");
			pMessageView->SetBodyText(L"Sky-based vehicles have no child nodes.");

			pMessageView->Release();
		}

		pUnk->Release();
	}

	return S_FALSE;
}

HRESULT CSkyBasedVehicle::GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions)
{
    // error message control
	LPOLESTR lpOleStr = NULL;
	HRESULT hr = StringFromCLSID(CLSID_MessageView, &lpOleStr);
    *ppViewType = lpOleStr;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\sky.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SKY_H
#define _SKY_H

#include "DeleBase.h"

class CSkyBasedVehicle : public CDelegationBase {
public:
    CSkyBasedVehicle() { }
    
    virtual ~CSkyBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Sky-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SKYICON; }

public:
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions);

private:
    enum { IDM_NEW_SKY = 3 };
    
    // {2974380F-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};


#endif // _SKY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\delebase.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _BRANCHES_H
#define _BRANCHES_H

#include <mmc.h>
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "LocalRes.h"

class CDelegationBase {
public:
    CDelegationBase();
    virtual ~CDelegationBase();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) = 0;
    virtual void GetChildColumnInfo(RESULTDATAITEM *rdi) { }
    virtual const GUID & getNodeType() { _ASSERT(FALSE); return IID_NULL; }
    
    virtual const LPARAM GetCookie() { return reinterpret_cast<LPARAM>(this); }
    virtual const int GetBitmapIndex() = 0;

	virtual CDelegationBase *GetChildPtr(int index) { return NULL; }
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions) { return S_FALSE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent) { return S_FALSE; }
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem) { return S_FALSE; }
    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    virtual HRESULT OnRename(LPOLESTR pszNewName) { return S_FALSE; }
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect) { return S_FALSE; }
    virtual HRESULT OnRefresh() { return S_FALSE; }

public:
    static HBITMAP m_pBMapSm;
    static HBITMAP m_pBMapLg;
    
protected:
    static void LoadBitmaps() {
        m_pBMapSm = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_SMICONS));
        m_pBMapLg = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_LGICONS));
    }
    
    BOOL bExpanded;
    
private:
    // {2974380B-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _BRANCHES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5
#define INDEX_BACKGROUND    6

#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\statnode.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SNAPINBASE_H
#define _SNAPINBASE_H

#include "DeleBase.h"

class CStaticNode : public CDelegationBase {
public:
    CStaticNode();
    
    virtual ~CStaticNode();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { 
        static _TCHAR szDisplayName[256];
        LoadString(g_hinst, IDS_SNAPINNAME, szDisplayName, sizeof(szDisplayName));
        return szDisplayName; 
    }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_NONE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { NUMBER_OF_CHILDREN = 5 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
    
    // {2974380C-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};



#endif // _SNAPINBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\openserv\about.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "About.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

CSnapinAbout::CSnapinAbout()
: m_cref(0)
{
    OBJECT_CREATED

        m_hSmallImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    m_hLargeImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_LGBMP), IMAGE_BITMAP, 32, 32, LR_LOADTRANSPARENT);

    m_hSmallImageOpen = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMOPEN), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);

    m_hAppIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ICON1));
}

CSnapinAbout::~CSnapinAbout()
{
    if (m_hSmallImage != NULL)
        FreeResource(m_hSmallImage);

    if (m_hLargeImage != NULL)
        FreeResource(m_hLargeImage);

    if (m_hSmallImageOpen != NULL)
        FreeResource(m_hSmallImageOpen);

    if (m_hAppIcon != NULL)
        FreeResource(m_hAppIcon);

    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CSnapinAbout::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<ISnapinAbout *>(this);
    else if (IsEqualIID(riid, IID_ISnapinAbout))
        *ppv = static_cast<ISnapinAbout *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSnapinAbout::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CSnapinAbout::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription(
                                                /* [out] */ LPOLESTR *lpDescription)
{
    _TCHAR szDesc[MAX_PATH];

    LoadString(g_hinst, IDS_SNAPINDESC, szDesc, sizeof(szDesc));

    return AllocOleStr(lpDescription, szDesc);
}


STDMETHODIMP CSnapinAbout::GetProvider(
                                       /* [out] */ LPOLESTR *lpName)
{
    return AllocOleStr(lpName, _T("Copyright  1998 Microsoft Corporation"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinVersion(
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return AllocOleStr(lpVersion, _T("1.0"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinImage(
                                          /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;

    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}


STDMETHODIMP CSnapinAbout::GetStaticFolderImage(
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;

    *hSmallImageOpen = m_hSmallImageOpen;

    *cMask = RGB(0, 128, 128);

    if (*hSmallImage == NULL || *hLargeImage == NULL || *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}

// this allocates a chunk of memory using CoTaskMemAlloc and copies our chars into it
HRESULT CSnapinAbout::AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer)
{
        MAKE_WIDEPTR_FROMTSTR_ALLOC(wszStr, szBuffer);
        *lpDest = wszStr;


    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\guids.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

// {6BB32802-92E6-11d2-9967-0080C7DCB3DC}
DEFINE_GUID(CLSID_CComponentData, 
            0x6bb32802, 0x92e6, 0x11d2, 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc);

// {73A37F60-92E6-11d2-9967-0080C7DCB3DC}
DEFINE_GUID(CLSID_CSnapinAbout, 
            0x73a37f60, 0x92e6, 0x11d2, 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\people.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "People.h"

const GUID CPeoplePoweredVehicle::thisGuid = { 0x2974380d, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

const GUID CBicycleFolder::thisGuid = { 0xef163732, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboardFolder::thisGuid = { 0xef163733, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkateFolder::thisGuid = { 0xf6c660b0, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };

const GUID CBicycle::thisGuid = { 0xef163734, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboard::thisGuid = { 0xef163735, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkate::thisGuid = { 0xf6c660b1, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };


//==============================================================
//
// CPeoplePoweredVehicle implementation
//
//
CPeoplePoweredVehicle::CPeoplePoweredVehicle() 
{ 
    children[0] = new CBicycleFolder;
    children[1] = new CSkateboardFolder;
    children[2] = new CIceSkateFolder;
}

CPeoplePoweredVehicle::~CPeoplePoweredVehicle() 
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        delete children[n];
}

HRESULT CPeoplePoweredVehicle::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;
    
    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT    |   // relativeID is valid
                SDI_CHILDREN;     // cChildren is valid
            
            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = 0;
            
            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );
            
            _ASSERT( SUCCEEDED(hr) );
        }
    }
    
    return S_OK;
}

CBicycleFolder::CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CBicycle(n + 1);
    }
}

CBicycleFolder::~CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CBicycleFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;
    
    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;
    
    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );
        
        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );
        
        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        
        // insert items here
        RESULTDATAITEM rdi;
        
        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );
        
        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid
                
                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];
                
                hr = pResultData->InsertItem( &rdi );
                
                _ASSERT( SUCCEEDED(hr) );
            }
        }
        
        pHeaderCtrl->Release();
        pResultData->Release();
    }
    
    return hr;
}

CIceSkateFolder::CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CIceSkate(n + 1);
    }
}

CIceSkateFolder::~CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CIceSkateFolder::GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions) 
{ 
    *ppViewType = NULL;
    *pViewOptions = MMC_VIEW_OPTIONS_OWNERDATALIST;
    
    return S_OK; 
}

void CIceSkateFolder::GetChildColumnInfo(RESULTDATAITEM *rdi) 
{ 
    if (rdi->mask & RDI_STR) {
		LPCTSTR pszT = children[rdi->nIndex]->GetDisplayName(rdi->nCol);
		MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
		rdi->str = pszW;
	}

    if (rdi->mask & RDI_IMAGE)
        rdi->nImage = children[rdi->nIndex]->GetBitmapIndex(); 
}

// CDelegationBase::AddImages sets up the collection of images to be displayed
// by the IComponent in the result pane as a result of its MMCN_SHOW handler
HRESULT CIceSkateFolder::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi) 
{
    return pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}

HRESULT CIceSkateFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;
    
    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;
    
    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );
        
        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );
        
        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        
        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );
        
        if (!bExpanded) {
            // create the child nodes, then expand them
            hr = pResultData->SetItemCount( NUMBER_OF_CHILDREN, 0 );
            _ASSERT( SUCCEEDED(hr) );
        }
        
        pHeaderCtrl->Release();
        pResultData->Release();
    }
    
    return hr;
}

CSkateboardFolder::CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CSkateboard(n + 1);
    }
}

CSkateboardFolder::~CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSkateboardFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;
    
    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;
    
    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );
        
        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );
        
        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                      ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        
        // insert items here
        RESULTDATAITEM rdi;
        
        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );
        
        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid
                
                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];
                
                hr = pResultData->InsertItem( &rdi );
                
                _ASSERT( SUCCEEDED(hr) );
            }
        }
        
        pHeaderCtrl->Release();
        pResultData->Release();
    }
    
    return hr;
}

const _TCHAR *CBicycle::GetDisplayName(int nCol) 
{
    _TCHAR buf[128];
    
    wsprintf(buf, _T("Bicycle #%d"), id);
    
    _TCHAR *pszCol = 
        static_cast<_TCHAR *>(CoTaskMemAlloc((_tcslen(buf) + 1) * sizeof(WCHAR)));
    _tcscpy(pszCol, buf);
    
    return pszCol;
}

const _TCHAR *CSkateboard::GetDisplayName(int nCol) 
{
    _TCHAR buf[128];
    
    wsprintf(buf, _T("Skateboard #%d"), id);
    
    _TCHAR *pszCol = 
        static_cast<_TCHAR *>(CoTaskMemAlloc((_tcslen(buf) + 1) * sizeof(WCHAR)));
    _tcscpy(pszCol, buf);
    
    return pszCol;
}

const _TCHAR *CIceSkate::GetDisplayName(int nCol) 
{
    _TCHAR buf[128];
    
    wsprintf(buf, _T("Ice Skate #%d"), id);
    
    _TCHAR *pszCol = 
        static_cast<_TCHAR *>(CoTaskMemAlloc((_tcslen(buf) + 1) * sizeof(WCHAR)));
    _tcscpy(pszCol, buf);
    
    return pszCol;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\openserv\about.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPABOUT_H_
#define _SAMPABOUT_H_

#include <tchar.h>
#include <mmc.h>

class CSnapinAbout : public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;
    
public:
    CSnapinAbout();
    ~CSnapinAbout();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
        /* [out] */ LPOLESTR *lpDescription);
        
        STDMETHODIMP GetProvider( 
        /* [out] */ LPOLESTR *lpName);
        
        STDMETHODIMP GetSnapinVersion( 
        /* [out] */ LPOLESTR *lpVersion);
        
        STDMETHODIMP GetSnapinImage( 
        /* [out] */ HICON *hAppIcon);
        
        STDMETHODIMP GetStaticFolderImage( 
        /* [out] */ HBITMAP *hSmallImage,
        /* [out] */ HBITMAP *hSmallImageOpen,
        /* [out] */ HBITMAP *hLargeImage,
        /* [out] */ COLORREF *cMask);
        
        ///////////////////////////////
        // Private Interface 
        ///////////////////////////////
private:
    HRESULT	CSnapinAbout::AllocOleStr(
        LPOLESTR *lpDest, 
        _TCHAR *szBuffer);
};

#endif _SAMPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\openserv\basesnap.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <olectl.h>
#include <initguid.h>
#include "guids.h"
#include "basesnap.h"
#include "Comp.h"
#include "CompData.h"
#include "About.h"
#include "Registry.h"

// our globals
HINSTANCE g_hinst;

BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    if ((rclsid != CLSID_CComponentData) && (rclsid != CLSID_CSnapinAbout))
        return CLASS_E_CLASSNOTAVAILABLE;
    
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
    // make the factory passing in the creation function for the type of object they want
    if (rclsid == CLSID_CComponentData)
        pFactory = new CClassFactory(CClassFactory::COMPONENT);
    else if (rclsid == CLSID_CSnapinAbout)
        pFactory = new CClassFactory(CClassFactory::ABOUT);
    
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}


CClassFactory::CClassFactory(FACTORY_TYPE factoryType)
: m_cref(0), m_factoryType(factoryType)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    if (COMPONENT == m_factoryType) {
        pObj = new CComponentData();
    } else {
        pObj = new CSnapinAbout();
    }
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    
    if (FAILED(hr))
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{
    HRESULT hr = SELFREG_E_CLASS;
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName));
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, sizeof(szSnapInName));
    
    _TCHAR szAboutName[256];
    
    LoadString(g_hinst, IDS_ABOUTNAME, szAboutName, sizeof(szAboutName));
    
    // register our CoClasses
    hr = RegisterServer(g_hinst, 
        CLSID_CComponentData, 
        szName);
    
    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst, 
        CLSID_CSnapinAbout, 
        szAboutName);
    
    // place the registry information for SnapIns
    if SUCCEEDED(hr)
        hr = RegisterSnapin(CLSID_CComponentData, szSnapInName, CLSID_CSnapinAbout, FALSE);
    
    return hr;
}


STDAPI DllUnregisterServer()
{
    if (UnregisterServer(CLSID_CComponentData) == S_OK)
        return UnregisterSnapin(CLSID_CComponentData);
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\openserv\basesnap.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#ifndef _BASESNAP_H_
#define _BASESNAP_H_

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);
STDAPI DllCanUnloadNow(void);

ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    enum FACTORY_TYPE {COMPONENT = 0, ABOUT = 1};
    
    CClassFactory(FACTORY_TYPE factoryType);
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
private:
    FACTORY_TYPE m_factoryType;
};

#endif _BASESNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\registry.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

#define STRINGS_ONLY
#include "globals.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName)       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule, 
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;
    
    assert(dwResult != 0) ;
    
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    assert(SUCCEEDED(hr)) ;

	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;
	_tcscat(szKey, pszCLSID) ;
    
    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;
    
    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    _tcscat(szKey, _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), _T("Apartment"));
    
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    
    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    
    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;

	MAKE_TSTRPTR_FROMWIDE(pszT, wszCLSID);
	_tcscat(szKey, pszT) ;
    
    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.
    
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    
    return S_OK ;
}

//
// Register the snap-in in the registry.
//
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions)
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    LPOLESTR wszAboutCLSID = NULL;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    if (IID_NULL != clsidAbout)
        hr = StringFromCLSID(clsidAbout, &wszAboutCLSID);

	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
	MAKE_TSTRPTR_FROMWIDE(pszAboutCLSID, wszAboutCLSID);

   
    // Add the CLSID to the registry.
    setSnapInKeyAndValue(pszCLSID, NULL, _T("NameString"), szNameString) ;
    setSnapInKeyAndValue(pszCLSID, _T("StandAlone"), NULL, NULL);
    if (IID_NULL != clsidAbout)
        setSnapInKeyAndValue(pszCLSID, NULL, _T("About"), pszAboutCLSID);
    
    if (fSupportExtensions) {
        // Build the key NodeType 
        setSnapInKeyAndValue(pszCLSID, _T("NodeTypes"), NULL, NULL);
        
        _TCHAR szKey[64] ;
        _tcscpy(szKey, pszCLSID) ;
        _tcscat(szKey, _T("\\NodeTypes")) ;
        setSnapInKeyAndValue(szKey, pszCLSID, NULL, NULL);
    }
    
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    if (IID_NULL != clsidAbout)
        CoTaskMemFree(wszAboutCLSID);
    
    return S_OK ;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    LPOLESTR wszCLSID = NULL;
    
    // Get CLSID
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
    
    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));
    
    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\"));
    _tcscat(szKeyBuf, pszCLSID);
    
    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.
    
    // free the memory
    CoTaskMemFree(wszCLSID);
    
    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }
    
    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }
    
    // Close the child.
    RegCloseKey(hKeyChild) ;
    
    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;
    
    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));
    
    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\")) ;
    _tcscat(szKeyBuf, szKey) ;
    
    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\openserv\dataobj.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DataObj.h"
#include "guids.h"
#include "DeleBase.h"

//
// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SZNODETYPE _T("CCF_SZNODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

#define _T_CCF_INTERNAL_SNAPIN _T("{2479DB32-5276-11d2-94F5-00C04FB92EC2}")

    // These are the clipboard formats that we must supply at a minimum.
    // mmc.h actually defined these. We can make up our own to use for
    // other reasons. We don't need any others at this time.
UINT CDataObject::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CDataObject::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CDataObject::s_cfSZNodeType  = RegisterClipboardFormat(_T_CCF_SZNODETYPE);
UINT CDataObject::s_cfSnapinClsid = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);
UINT CDataObject::s_cfInternal    = RegisterClipboardFormat(_T_CCF_INTERNAL_SNAPIN);


CDataObject::CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context)
: m_lCookie(cookie), m_context(context), m_cref(0)
{
}

CDataObject::~CDataObject()
{
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IDataObject *>(this);
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppv = static_cast<IDataObject *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CDataObject::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
//
HRESULT CDataObject::GetDataHere(
                                 FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure
                                 STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure
                                 )
{
    const   CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pStream = NULL;

    CDelegationBase *base = GetBaseNodeObject();

    HRESULT hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( FAILED(hr) )
        return hr;                       // Minimal error checking

    hr = DV_E_FORMATETC;                 // Unknown format

    if (cf == s_cfDisplayName) {
        const _TCHAR *pszName = base->GetDisplayName();

                MAKE_WIDEPTR_FROMTSTR(wszName, pszName);

                // get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(pszName);
        ulSizeofName++;                      // Count null character
        ulSizeofName *= sizeof(WCHAR);

        hr = pStream->Write(wszName, ulSizeofName, NULL);
    } else if (cf == s_cfNodeType) {
        const GUID *pGUID = (const GUID *)&base->getNodeType();

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfSZNodeType) {
        LPOLESTR szGuid;
        hr = StringFromCLSID(base->getNodeType(), &szGuid);

        if (SUCCEEDED(hr)) {
            hr = pStream->Write(szGuid, wcslen(szGuid), NULL);
            CoTaskMemFree(szGuid);
        }
    } else if (cf == s_cfSnapinClsid) {
        const GUID *pGUID = NULL;
        pGUID = &CLSID_CComponentData;

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfInternal) {
        // we are being asked to get our this pointer from the IDataObject interface
        // only our own snap-in objects will know how to do this.
        CDataObject *pThis = this;
        hr = pStream->Write( &pThis, sizeof(CDataObject*), NULL );
    }

    pStream->Release();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Global helper functions to help work with dataobjects and
// clipboard formats


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfInternal clipboard format
//
CDataObject* GetOurDataObject (
                               LPDATAOBJECT lpDataObject      // [in] IComponent pointer
                               )
{
    HRESULT       hr      = S_OK;
    CDataObject *pSDO     = NULL;

	// check to see if the data object is a special data object.
	if ( IS_SPECIAL_DATAOBJECT (lpDataObject) )
	{
		//Code for handling a special data object goes here.

		//Note that the MMC SDK samples do not handle
		//special data objects, so we exit if we get one.
		return NULL;
	}

    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { CDataObject::s_cfInternal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(CDataObject *));

    if (!stgmedium.hGlobal)     {
        hr = E_OUTOFMEMORY;
    }

    if SUCCEEDED(hr)
        // Attempt to get data from the object
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );

    // stgmedium now has the data we need
    if (SUCCEEDED(hr))  {
        pSDO = *(CDataObject **)(stgmedium.hGlobal);
    }

    // if we have memory free it
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);

    return pSDO;

} // end GetOurDataObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\space.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Space.h"
#include "Comp.h"

const GUID CSpaceVehicle::thisGuid = { 0x29743810, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };
const GUID CRocket::thisGuid = { 0x29743811, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSpaceVehicle implementation
//
//
CSpaceVehicle::CSpaceVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CRocket(_T("Rocket"), n+1, 500000, 265, 75000);
    }
}

CSpaceVehicle::~CSpaceVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSpaceVehicle::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;
    
    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;
    
    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );
        
        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );
        
        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Rocket Class", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 1, L"Rocket Weight", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 2, L"Rocket Height", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 3, L"Rocket Payload", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 4, L"Status", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        
        // insert items here
        RESULTDATAITEM rdi;
        
        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );
        
        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid
                
                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];
                
                hr = pResultData->InsertItem( &rdi );
                
                _ASSERT( SUCCEEDED(hr) );
            }
        }
        
        pHeaderCtrl->Release();
        pResultData->Release();
    }
    
    return hr;
}

//==============================================================
//
// CRocket implementation
//
//
CRocket::CRocket(_TCHAR *szName, int id, LONG lWeight, LONG lHeight, LONG lPayload) 
: szName(NULL), lWeight(0), lHeight(0), lPayload(0), iStatus(STOPPED)
{ 
    if (szName) {
        this->szName = new _TCHAR[(_tcslen(szName) + 1) * sizeof(_TCHAR)];
        _tcscpy(this->szName, szName);
    }
    
    this->nId = id;
    this->lWeight = lWeight;
    this->lHeight = lHeight;
    this->lPayload = lPayload;
}

CRocket::~CRocket() 
{
    if (szName)
        delete [] szName;
}

const _TCHAR *CRocket::GetDisplayName(int nCol) 
{
    _TCHAR buf[128];
    
    switch (nCol) {
    case 0:
        wsprintf(buf, _T("%s (#%d)"), szName ? szName : _T(""), nId);
        break;
        
    case 1:
        wsprintf(buf, _T("%ld metric tons"), lWeight);
        break;
        
    case 2:
        wsprintf(buf, _T("%ld meters"), lHeight);
        break;
        
    case 3:
        wsprintf(buf, _T("%ld kilos"), lPayload);
        break;
        
    case 4:
        wsprintf(buf, _T("%s"),
            iStatus == RUNNING ? _T("running") : 
        iStatus == PAUSED ? _T("paused") :
        iStatus == STOPPED ? _T("stopped") : _T("unknown"));
        break;
        
    }
    
    _TCHAR *pszCol = 
        static_cast<_TCHAR *>(CoTaskMemAlloc((_tcslen(buf) + 1) * sizeof(WCHAR)));
    _tcscpy(pszCol, buf);
    
    return pszCol;
}

HRESULT CRocket::OnRename(LPOLESTR pszNewName)
{
    if (szName) {
        delete [] szName;
        szName = NULL;
    }
    
    MAKE_TSTRPTR_FROMWIDE(ptrname, pszNewName);
    szName = new _TCHAR[(_tcslen(ptrname) + 1) * sizeof(_TCHAR)];
    _tcscpy(szName, ptrname);
    
    return S_OK;
}

HRESULT CRocket::OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect)
{
    IConsoleVerb *pConsoleVerb;
    
    HRESULT hr = pConsole->QueryConsoleVerb(&pConsoleVerb);
    _ASSERT(SUCCEEDED(hr));
    
    hr = pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, TRUE);
    
    pConsoleVerb->Release();
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\openserv\dataobj.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPDATAOBJECT_H_
#define _SAMPDATAOBJECT_H_

#include <mmc.h>
#include "DeleBase.h"

class CDataObject : public IDataObject
{
private:
    ULONG				m_cref;
    MMC_COOKIE			m_lCookie;
    DATA_OBJECT_TYPES   m_context;
    
public:
    CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context);
    ~CDataObject();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // IDataObject methods 
    ///////////////////////////////
    STDMETHODIMP GetDataHere (FORMATETC *pformatetc, STGMEDIUM *pmedium);
    
    // The rest are not implemented
    STDMETHODIMP GetData (LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumFormatEtc (DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };
    
    STDMETHODIMP QueryGetData (LPFORMATETC lpFormatetc) 
    { return E_NOTIMPL; };
    
    STDMETHODIMP GetCanonicalFormatEtc (LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    
    STDMETHODIMP SetData (LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DAdvise (LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DUnadvise (DWORD dwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumDAdvise (LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };
    
    ///////////////////////////////
    // Custom Methods
    ///////////////////////////////
    
    CDelegationBase *GetBaseNodeObject() {
        return (CDelegationBase *)m_lCookie;
    }
    
    DATA_OBJECT_TYPES GetContext() {
        return m_context;
    }
    
public:
    // clipboard formats
    static UINT s_cfSZNodeType;
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
    static UINT s_cfInternal;
    
};

HRESULT ExtractFromDataObject(IDataObject *lpDataObject,UINT cf,ULONG cb,HGLOBAL *phGlobal);
CDataObject* GetOurDataObject(IDataObject *lpDataObject);
BOOL IsMMCMultiSelectDataObject(IDataObject *lpDataObject);

#endif _SAMPDATAOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\space.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SPACE_H
#define _SPACE_H

#include "DeleBase.h"

class CRocket : public CDelegationBase {
public:
    CRocket(_TCHAR *szName, int id, LONG lWeight, LONG lHeight, LONG lPayload);
    virtual ~CRocket();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnRename(LPOLESTR pszNewName);
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect);
    
private:
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    _TCHAR *szName;
    LONG   lWeight;
    LONG   lHeight;
    LONG   lPayload;
    int    nId;
    enum ROCKET_STATUS {RUNNING, PAUSED, STOPPED} iStatus;
};

class CSpaceVehicle : public CDelegationBase {
public:
    CSpaceVehicle();
    
    virtual ~CSpaceVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Future Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    enum { IDM_NEW_SPACE = 4 };
    
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CRocket *children[NUMBER_OF_CHILDREN];
};

#endif // _SPACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\nodes\statnode.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "StatNode.h"

#include "Space.h"
#include "Sky.h"
#include "People.h"
#include "Land.h"
#include "Backgrnd.h"

const GUID CStaticNode::thisGuid = { 0x2974380c, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CStaticNode implementation
//
//
CStaticNode::CStaticNode()
{
    children[0] = new CPeoplePoweredVehicle;
    children[1] = new CLandBasedVehicle;
    children[2] = new CSkyBasedVehicle;
    children[3] = new CSpaceVehicle;
    children[4] = new CBackgroundFolder;
}

CStaticNode::~CStaticNode()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }

	if (m_pBMapSm != NULL)
		DeleteObject(m_pBMapSm);

	if (m_pBMapLg != NULL)
		DeleteObject(m_pBMapLg);
}

HRESULT CStaticNode::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;
    
    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT    |
                SDI_CHILDREN;
            
            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = (n == 0); // only the first child has children
            
            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );
            
            _ASSERT( SUCCEEDED(hr) );
        }
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\openserv\comp.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMP_H_
#define _SAMPCOMP_H_

#include <mmc.h>

class CComponent : public IComponent,
IExtendPropertySheet2
{
private:
    ULONG				m_cref;
    
    IConsole*		m_ipConsole;
    
    class CComponentData *m_pComponentData;
    
    public:
        CComponent(CComponentData *parent);
        ~CComponent();
        
        ///////////////////////////////
        // Interface IUnknown
        ///////////////////////////////
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        
        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ MMC_COOKIE cookie);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);
            
            //////////////////////////////////
            // Interface IExtendPropertySheet2
            //////////////////////////////////
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
            /* [in] */ LONG_PTR handle,
            /* [in] */ LPDATAOBJECT lpIDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
            /* [in] */ LPDATAOBJECT lpDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetWatermarks( 
            /* [in] */ LPDATAOBJECT lpIDataObject,
            /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
            /* [out] */ HBITMAP __RPC_FAR *lphHeader,
            /* [out] */ HPALETTE __RPC_FAR *lphPalette,
            /* [out] */ BOOL __RPC_FAR *bStretch);
};

#endif _SAMPCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\openserv\comp.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "DataObj.h"
#include <commctrl.h>        // Needed for button styles...
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "DeleBase.h"
#include "CompData.h"

CComponent::CComponent(CComponentData *parent)
: m_pComponentData(parent), m_cref(0), m_ipConsole(NULL)
{
    OBJECT_CREATED
}

CComponent::~CComponent()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IComponent))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IExtendPropertySheet) ||
        IsEqualIID(riid, IID_IExtendPropertySheet2))
        *ppv = static_cast<IExtendPropertySheet2 *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponent::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponent::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface IComponent
///////////////////////////////
STDMETHODIMP CComponent::Initialize(
                                    /* [in] */ LPCONSOLE lpConsole)
{
    HRESULT hr = S_OK;

    // Save away all the interfaces we'll need.
    // Fail if we can't QI the required interfaces.

    m_ipConsole = lpConsole;
    m_ipConsole->AddRef();

    return hr;
}

STDMETHODIMP CComponent::Notify(
                                /* [in] */ LPDATAOBJECT lpDataObject,
                                /* [in] */ MMC_NOTIFY_TYPE event,
                                /* [in] */ LPARAM arg,
                                /* [in] */ LPARAM param)
{
    MMCN_Crack(FALSE, lpDataObject, NULL, this, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)      {
    case MMCN_SHOW:
        hr = base->OnShow(m_ipConsole, (BOOL)arg, (HSCOPEITEM)param);
        break;

    case MMCN_ADD_IMAGES:
        hr = base->OnAddImages((IImageList *)arg, (HSCOPEITEM)param);
        break;

    case MMCN_SELECT:
        hr = base->OnSelect(m_ipConsole, (BOOL)LOWORD(arg), (BOOL)HIWORD(arg));
        break;

    case MMCN_RENAME:
        hr = base->OnRename((LPOLESTR)param);
        break;
    }

    return hr;
}

STDMETHODIMP CComponent::Destroy(
                                 /* [in] */ MMC_COOKIE cookie)
{
    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}


STDMETHODIMP CComponent::QueryDataObject(
                                         /* [in] */ MMC_COOKIE cookie,
                                         /* [in] */ DATA_OBJECT_TYPES type,
                                         /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pComponentData->m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

STDMETHODIMP CComponent::GetResultViewType(
                                           /* [in] */ MMC_COOKIE cookie,
                                           /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
                                           /* [out] */ long __RPC_FAR *pViewOptions)
{
    CDelegationBase *base = (CDelegationBase *)cookie;

    //
    // Ask for default listview.
    //
    if (base == NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
        *ppViewType = NULL;
    }
    else
        return base->GetResultViewType(ppViewType, pViewOptions);

    return S_OK;
}

STDMETHODIMP CComponent::GetDisplayInfo(
                                        /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem)
{
    HRESULT hr = S_OK;
    CDelegationBase *base = NULL;

    // if they are asking for the RDI_STR we have one of those to give

    if (pResultDataItem->lParam) {
        base = (CDelegationBase *)pResultDataItem->lParam;
        if (pResultDataItem->mask & RDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName(pResultDataItem->nCol);
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pResultDataItem->str = pszW;
        }

        if (pResultDataItem->mask & RDI_IMAGE) {
            pResultDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}


STDMETHODIMP CComponent::CompareObjects(
                                        /* [in] */ LPDATAOBJECT lpDataObjectA,
                                        /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////////
// Interface IExtendPropertySheet2
///////////////////////////////////
HRESULT CComponent::CreatePropertyPages(
                                        /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
                                        /* [in] */ LONG_PTR handle,
                                        /* [in] */ LPDATAOBJECT lpIDataObject)
{
    CDelegationBase *base = GetOurDataObject(lpIDataObject)->GetBaseNodeObject();

    return base->CreatePropertyPages(lpProvider, handle);
}

HRESULT CComponent::QueryPagesFor(
                                  /* [in] */ LPDATAOBJECT lpDataObject)
{
    CDelegationBase *base = GetOurDataObject(lpDataObject)->GetBaseNodeObject();

    return base->HasPropertySheets();
}

HRESULT CComponent::GetWatermarks(
                                  /* [in] */ LPDATAOBJECT lpIDataObject,
                                  /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
                                  /* [out] */ HBITMAP __RPC_FAR *lphHeader,
                                  /* [out] */ HPALETTE __RPC_FAR *lphPalette,
                                  /* [out] */ BOOL __RPC_FAR *bStretch)
{
    CDelegationBase *base = GetOurDataObject(lpIDataObject)->GetBaseNodeObject();

    return base->GetWatermarks(lphWatermark, lphHeader, lphPalette, bStretch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\openserv\compdata.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMPDATA_H_
#define _SAMPCOMPDATA_H_

#include <mmc.h>
#include "DeleBase.h"
#include "StatNode.h"
#include "Comp.h"

class CComponentData : public IComponentData,
IExtendPropertySheet2,  // 2 for wizard 
IPersistStream

{
    friend class CComponent;
    
private:
    ULONG				m_cref;
    LPCONSOLE			m_ipConsole;
    LPCONSOLENAMESPACE	m_ipConsoleNameSpace;
    
    CStaticNode     *m_pStaticNode;
    
public:
    CComponentData();
    ~CComponentData();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IComponentData
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
        /* [in] */ LPUNKNOWN pUnknown);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent( 
        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
        /* [in] */ LPDATAOBJECT lpDataObject,
        /* [in] */ MMC_NOTIFY_TYPE event,
        /* [in] */ LPARAM arg,
        /* [in] */ LPARAM param);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
        /* [in] */ MMC_COOKIE cookie,
        /* [in] */ DATA_OBJECT_TYPES type,
        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
        /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
        /* [in] */ LPDATAOBJECT lpDataObjectA,
        /* [in] */ LPDATAOBJECT lpDataObjectB);
        
        //////////////////////////////////
        // Interface IExtendPropertySheet2
        //////////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
        /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
        /* [in] */ LONG_PTR handle,
        /* [in] */ LPDATAOBJECT lpIDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
        /* [in] */ LPDATAOBJECT lpDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetWatermarks( 
        /* [in] */ LPDATAOBJECT lpIDataObject,
        /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
        /* [out] */ HBITMAP __RPC_FAR *lphHeader,
        /* [out] */ HPALETTE __RPC_FAR *lphPalette,
        /* [out] */ BOOL __RPC_FAR *bStretch);
        
        ///////////////////////////////
        // Interface IPersistStream
        ///////////////////////////////
        virtual HRESULT STDMETHODCALLTYPE GetClassID( 
        /* [out] */ CLSID __RPC_FAR *pClassID);
        
        virtual HRESULT STDMETHODCALLTYPE IsDirty( void);
    
    virtual HRESULT STDMETHODCALLTYPE Load( 
        /* [unique][in] */ IStream __RPC_FAR *pStm);
        
        virtual HRESULT STDMETHODCALLTYPE Save( 
        /* [unique][in] */ IStream __RPC_FAR *pStm,
        /* [in] */ BOOL fClearDirty);
        
        virtual HRESULT STDMETHODCALLTYPE GetSizeMax( 
        /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbSize);
};

#endif _SAMPCOMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\openserv\land.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Land.h"

const GUID CLandBasedVehicle::thisGuid = { 0x2974380e, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CLandBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\openserv\land.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _LAND_H
#define _LAND_H

#include "DeleBase.h"

class CLandBasedVehicle : public CDelegationBase {
public:
    CLandBasedVehicle() { }
    
    virtual ~CLandBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Land-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_LANDICON; }
    
private:
    enum { IDM_NEW_LAND = 2 };
    
    // {2974380E-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};


#endif // _LAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\openserv\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5

#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\openserv\compdata.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "CompData.h"
#include "DataObj.h"
#include "resource.h"
#include <crtdbg.h>

CComponentData::CComponentData()
: m_cref(0), m_ipConsoleNameSpace(NULL), m_ipConsole(NULL)
{
    OBJECT_CREATED

        m_pStaticNode = new CStaticNode;
}

CComponentData::~CComponentData()
{
    if (m_pStaticNode) {
        delete m_pStaticNode;
    }

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CComponentData::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_IComponentData))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_IExtendPropertySheet) ||
        IsEqualIID(riid, IID_IExtendPropertySheet2))
        *ppv = static_cast<IExtendPropertySheet2 *>(this);
    //else if (IsEqualIID(riid, IID_IExtendPropertySheet))
    //    *ppv = static_cast<IExtendPropertySheet *>(this);
    else if (IsEqualIID(riid, IID_IPersistStream))
        *ppv = static_cast<IPersistStream *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponentData::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponentData::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }

    return m_cref;
}

///////////////////////////////
// Interface IComponentData
///////////////////////////////
HRESULT CComponentData::Initialize(
                                   /* [in] */ LPUNKNOWN pUnknown)
{
    HRESULT      hr;

    //
    // Get pointer to name space interface
    //
    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (void **)&m_ipConsoleNameSpace);
    _ASSERT( S_OK == hr );

    //
    // Get pointer to console interface
    //
    hr = pUnknown->QueryInterface(IID_IConsole, (void **)&m_ipConsole);
    _ASSERT( S_OK == hr );

    IImageList *pImageList;
    m_ipConsole->QueryScopeImageList(&pImageList);
    _ASSERT( S_OK == hr );

    hr = pImageList->ImageListSetStrip( (long *)m_pStaticNode->m_pBMapSm, // pointer to a handle
        (long *)m_pStaticNode->m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );

    pImageList->Release();

    return S_OK;
}

HRESULT CComponentData::CreateComponent(
                                        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent)
{
    *ppComponent = NULL;

    CComponent *pComponent = new CComponent(this);

    if (NULL == pComponent)
        return E_OUTOFMEMORY;

    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent);
}

HRESULT CComponentData::Notify(
                               /* [in] */ LPDATAOBJECT lpDataObject,
                               /* [in] */ MMC_NOTIFY_TYPE event,
                               /* [in] */ LPARAM arg,
                               /* [in] */ LPARAM param)
{
    MMCN_Crack(TRUE, lpDataObject, this, NULL, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)
    {
    case MMCN_EXPAND:
        hr = base->OnExpand(m_ipConsoleNameSpace, m_ipConsole, (HSCOPEITEM)param);
        break;
    }

    return hr;
}

HRESULT CComponentData::Destroy( void)
{
    // Free interfaces
    if (m_ipConsoleNameSpace) {
        m_ipConsoleNameSpace->Release();
        m_ipConsoleNameSpace = NULL;
    }

    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}

HRESULT CComponentData::QueryDataObject(
                                        /* [in] */ MMC_COOKIE cookie,
                                        /* [in] */ DATA_OBJECT_TYPES type,
                                        /* [out] */ LPDATAOBJECT *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

HRESULT CComponentData::GetDisplayInfo(
                                       /* [out][in] */ SCOPEDATAITEM *pScopeDataItem)
{
    HRESULT hr = S_FALSE;

    // if they are asking for the SDI_STR we have one of those to give
    if (pScopeDataItem->lParam) {
        CDelegationBase *base = (CDelegationBase *)pScopeDataItem->lParam;
        if (pScopeDataItem->mask & SDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName();
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pScopeDataItem->displayname = pszW;
        }

        if (pScopeDataItem->mask & SDI_IMAGE) {
            pScopeDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}

HRESULT CComponentData::CompareObjects(
                                       /* [in] */ LPDATAOBJECT lpDataObjectA,
                                       /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////////
// Interface IExtendPropertySheet2
///////////////////////////////////
HRESULT CComponentData::CreatePropertyPages(
                                            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
                                            /* [in] */ LONG_PTR handle,
                                            /* [in] */ LPDATAOBJECT lpIDataObject)
{
    return m_pStaticNode->CreatePropertyPages(lpProvider, handle);
}

HRESULT CComponentData::QueryPagesFor(
                                      /* [in] */ LPDATAOBJECT lpDataObject)
{
    return m_pStaticNode->HasPropertySheets();
}

HRESULT CComponentData::GetWatermarks(
                                      /* [in] */ LPDATAOBJECT lpIDataObject,
                                      /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
                                      /* [out] */ HBITMAP __RPC_FAR *lphHeader,
                                      /* [out] */ HPALETTE __RPC_FAR *lphPalette,
                                      /* [out] */ BOOL __RPC_FAR *bStretch)
{
    return m_pStaticNode->GetWatermarks(lphWatermark, lphHeader, lphPalette, bStretch);
}

///////////////////////////////
// Interface IPersistStream
///////////////////////////////
HRESULT CComponentData::GetClassID(
                                   /* [out] */ CLSID __RPC_FAR *pClassID)
{
    *pClassID = m_pStaticNode->getNodeType();

    return S_OK;
}

HRESULT CComponentData::IsDirty( void)
{
    return m_pStaticNode->isDirty() == true ? S_OK : S_FALSE;
}

HRESULT CComponentData::Load(
                             /* [unique][in] */ IStream __RPC_FAR *pStm)
{
    void *snapInData = m_pStaticNode->getData();
    ULONG dataSize = m_pStaticNode->getDataSize();

    return pStm->Read(snapInData, dataSize, NULL);
}

HRESULT CComponentData::Save(
                             /* [unique][in] */ IStream __RPC_FAR *pStm,
                             /* [in] */ BOOL fClearDirty)
{
    void *snapInData = m_pStaticNode->getData();
    ULONG dataSize = m_pStaticNode->getDataSize();

    if (fClearDirty)
        m_pStaticNode->clearDirty();

    return pStm->Write(snapInData, dataSize, NULL);
}

HRESULT CComponentData::GetSizeMax(
                                   /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbSize)
{
    return m_pStaticNode->getDataSize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\openserv\mmccrack.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

static TCHAR *MMCN_CrackVerb(MMC_CONSOLE_VERB verb)
{
        static TCHAR error[64];

        switch (verb) {
    case MMC_VERB_NONE:
                return _T("NONE");
    case MMC_VERB_OPEN:
                return _T("OPEN");
    case MMC_VERB_COPY:
                return _T("COPY");
    case MMC_VERB_PASTE:
                return _T("PASTE");
    case MMC_VERB_DELETE:
                return _T("DELETE");
    case MMC_VERB_PROPERTIES:
                return _T("PROPERTIES");
    case MMC_VERB_RENAME:
                return _T("RENAME");
    case MMC_VERB_REFRESH:
                return _T("REFRESH");
    case MMC_VERB_PRINT:
                return _T("PRINT");
    case MMC_VERB_CUT:
                return _T("CUT");
        default:
                wsprintf(error, _T("Unknown verb id %d"), verb);
                return error;
        }
}

void MMCN_Crack(BOOL bComponentData,
                IDataObject *pDataObject,
                                IComponentData *pCompData,
                                IComponent *pComp,
                MMC_NOTIFY_TYPE event,
                                LPARAM arg,
                                LPARAM param)
{
#ifdef MMC_CRACK_MESSAGES
        TCHAR message[256] = {0};

        if (bComponentData == TRUE)
                OutputDebugString(_T("IComponentData::Notify( "));
        else
                OutputDebugString(_T("IComponent::Notify( "));

        wsprintf(message, _T("DataObject: %08x, CompData: %08x, Comp: %08x ) - "), pDataObject, pCompData, pComp);
        OutputDebugString(message);

    switch (event)      {
                case MMCN_ACTIVATE:
                        wsprintf(message, _T("MMCN_ACTIVATE\n\tActivate: %d\n"), arg);
                        break;

                case MMCN_ADD_IMAGES:
                        wsprintf(message, _T("MMCN_ADD_IMAGES\n\tImage List: %08x\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_BTN_CLICK:
                        wsprintf(message, _T("MMCN_BTN_CLICK\n\tVerb: %ws\n"), MMCN_CrackVerb((MMC_CONSOLE_VERB)param));
                        break;

                case MMCN_COLUMN_CLICK:
                        wsprintf(message, _T("MMCN_COLUMN_CLICK\n\tColumn: %d\n\tSort Option: %d\n"), arg,       param);
                        break;

                case MMCN_COLUMNS_CHANGED:
                        wsprintf(message, _T("MMCN_COLUMNS_CHANGED\n"));
                        break;

                case MMCN_CONTEXTHELP:
                        wsprintf(message, _T("MMCN_CONTEXTHELP\n"));
                        break;

                case MMCN_CONTEXTMENU:
                        wsprintf(message, _T("MMCN_CONTEXTMENU\n"));
                        break;

                case MMCN_CUTORMOVE:
                        wsprintf(message, _T("MMCN_CUTORMOVE\n"));
                        break;

                case MMCN_DBLCLICK:
                        wsprintf(message, _T("MMCN_DBLCLICK\n"));
                        break;

                case MMCN_DELETE:
                        wsprintf(message, _T("MMCN_DELETE\n"));
                        break;

                case MMCN_DESELECT_ALL:
                        wsprintf(message, _T("MMCN_DESELECT_ALL\n"));
                        break;

                case MMCN_EXPAND:
                        wsprintf(message, _T("MMCN_EXPAND\n\tExpand: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_EXPANDSYNC:
                        wsprintf(message, _T("MMCN_EXPANDSYNC\n"));
                        break;

                case MMCN_FILTERBTN_CLICK:
                        wsprintf(message, _T("MMCN_FILTERBTN_CLICK\n\tColumn: %d\n"), arg);
                        break;

                case MMCN_FILTER_CHANGE:
                        wsprintf(message, _T("MMCN_FILTER_CHANGE\n\tColumn: %d\n"), param);
                        break;

                case MMCN_HELP:
                        wsprintf(message, _T("MMCN_HELP\n"));
                        break;

                case MMCN_INITOCX:
                        wsprintf(message, _T("MMCN_INITOCX\n\tIUnknown: %08x\n"), param);
                        break;

                case MMCN_LISTPAD:
                        wsprintf(message, _T("MMCN_LISTPAD\n\tConnect: %d\n"), arg);
                        break;

                case MMCN_MENU_BTNCLICK:
                        wsprintf(message, _T("MMCN_MENU_BTNCLICK\n"));
                        break;

                case MMCN_MINIMIZED:
                        wsprintf(message, _T("MMCN_MINIMIZED\n\tMinimized: %d\n"), arg);
                        break;

                case MMCN_PASTE:
                        wsprintf(message, _T("MMCN_PASTE\n\tCopy: %d\n"), param == NULL);
                        break;

                case MMCN_PRELOAD:
                        wsprintf(message, _T("MMCN_PRELOAD\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_PRINT:
                        wsprintf(message, _T("MMCN_PRINT\n"));
                        break;

                case MMCN_PROPERTY_CHANGE:
                        wsprintf(message, _T("MMCN_PROPERTY_CHANGE\n\tScope: %d\n\tArg: %08x\n"), arg, param);
                        break;

                case MMCN_QUERY_PASTE:
                        wsprintf(message, _T("MMCN_QUERY_PASTE\n"));
                        break;

                case MMCN_REFRESH:
                        wsprintf(message, _T("MMCN_REFRESH\n"));
                        break;

                case MMCN_REMOVE_CHILDREN:
                        wsprintf(message, _T("MMCN_REMOVE_CHILDREN\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_RENAME:
                        wsprintf(message, _T("MMCN_RENAME\n\tNew Name: '%ws'\n"), (LPOLESTR)param);
                        break;

                case MMCN_RESTORE_VIEW:
                        wsprintf(message, _T("MMCN_RESTORE_VIEW\n"));
                        break;

                case MMCN_SELECT:
                        wsprintf(message, _T("MMCN_SELECT\n\tScope: %d\n\tSelect: %08x\n"), LOWORD(arg), HIWORD(arg));
                        break;

                case MMCN_SHOW:
                        wsprintf(message, _T("MMCN_SHOW\n\tShow: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_SNAPINHELP:
                        wsprintf(message, _T("MMCN_SNAPINHELP\n"));
                        break;

                case MMCN_VIEW_CHANGE:
                        wsprintf(message, _T("MMCN_VIEW_CHANGE\n\tData: %08x\n\tHint: %08x\n"), arg, param);
                        break;
        }

        if (message[0] != 0)
                OutputDebugString(message);
        else
                OutputDebugString(_T("unknown event\n"));

#endif
        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\openserv\people.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _PEOPLE_H
#define _PEOPLE_H

#include "DeleBase.h"

class CBicycle : public CDelegationBase {
public:
    CBicycle(int i) : id(i) { }
    virtual ~CBicycle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CBicycleFolder : public CDelegationBase {
public:
    CBicycleFolder();
    virtual ~CBicycleFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Bicycles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CSkateboard : public CDelegationBase {
public:
    CSkateboard(int i) : id(i) { }
    virtual ~CSkateboard() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CSkateboardFolder : public CDelegationBase {
public:
    CSkateboardFolder();
    virtual ~CSkateboardFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Skateboards"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CIceSkate : public CDelegationBase {
public:
    CIceSkate(int i) : id(i) { }
    virtual ~CIceSkate() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CIceSkateFolder : public CDelegationBase {
public:
    CIceSkateFolder();
    virtual ~CIceSkateFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Ice Skates"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CPeoplePoweredVehicle : public CDelegationBase {
public:
    CPeoplePoweredVehicle();
    virtual ~CPeoplePoweredVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("People-powered Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { IDM_NEW_PEOPLE = 1 };
    
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 3 };
    CDelegationBase *children[3];
};

#endif // _PEOPLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\openserv\registry.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions = FALSE);

HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\openserv\delebase.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DeleBase.h"

const GUID CDelegationBase::thisGuid = { 0x2974380b, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

HBITMAP CDelegationBase::m_pBMapSm = NULL;
HBITMAP CDelegationBase::m_pBMapLg = NULL;


//==============================================================
//
// CDelegationBase implementation
//
//
CDelegationBase::CDelegationBase() 
: bExpanded(FALSE), m_handle(NULL) 
{ 
    if (NULL == m_pBMapSm || NULL == m_pBMapLg)
        LoadBitmaps(); 
}

CDelegationBase::~CDelegationBase() 
{ 
}

// CDelegationBase::AddImages sets up the collection of images to be displayed
// by the IComponent in the result pane as a result of its MMCN_SHOW handler
HRESULT CDelegationBase::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi) 
{
    return pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\openserv\delebase.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _BRANCHES_H
#define _BRANCHES_H

#include <mmc.h>
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "LocalRes.h"

class CDelegationBase {
public:
    CDelegationBase();
    virtual ~CDelegationBase();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) = 0;
    virtual const GUID & getNodeType() { _ASSERT(FALSE); return IID_NULL; }
    
    virtual const LPARAM GetCookie() { return reinterpret_cast<LPARAM>(this); }
    virtual const int GetBitmapIndex() = 0;
    virtual const HANDLE GetHandle() { return m_handle; }
    virtual SetHandle(HANDLE handle) { m_handle = handle; }
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions) { return S_FALSE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent) { return S_FALSE; }
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem) { return S_FALSE; }
    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    virtual HRESULT OnRename(LPOLESTR pszNewName) { return S_FALSE; }
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect) { return S_FALSE; }
    
    virtual HRESULT CreatePropertyPages(IPropertySheetCallback *lpProvider,
        LONG_PTR handle) { return S_FALSE; }
    virtual HRESULT HasPropertySheets() { return S_FALSE; }
    virtual HRESULT GetWatermarks(HBITMAP *lphWatermark,
        HBITMAP *lphHeader,
        HPALETTE *lphPalette,
        BOOL *bStretch) { return S_FALSE; }
    
public:
    static HBITMAP m_pBMapSm;
    static HBITMAP m_pBMapLg;
    
protected:
    static void LoadBitmaps() {
        m_pBMapSm = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_SMICONS));
        m_pBMapLg = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_LGICONS));
    }
    
    BOOL bExpanded;
    HANDLE m_handle;
    
private:
    // {2974380B-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _BRANCHES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\openserv\sky.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Sky.h"

const GUID CSkyBasedVehicle::thisGuid = { 0x2974380f, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSkyBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\openserv\sky.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SKY_H
#define _SKY_H

#include "DeleBase.h"

class CSkyBasedVehicle : public CDelegationBase {
public:
    CSkyBasedVehicle() { }
    
    virtual ~CSkyBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Sky-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SKYICON; }
    
private:
    enum { IDM_NEW_SKY = 3 };
    
    // {2974380F-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};


#endif // _SKY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\openserv\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>

#ifndef STRINGS_ONLY
        #define IDM_BUTTON1    0x100
        #define IDM_BUTTON2    0x101

        extern HINSTANCE g_hinst;
        extern ULONG g_uObjects;

        #define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
        #define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

        // uncomment the following #define to enable message cracking
        // #define MMC_CRACK_MESSAGES
        void MMCN_Crack(BOOL bComponentData,
                                        IDataObject *pDataObject,
                                        IComponentData *pCompData,
                                        IComponent *pComp,
                                        MMC_NOTIFY_TYPE event,
                                        LPARAM arg,
                                        LPARAM param);
#endif

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(GetProcessHeap(), 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(GetProcessHeap(), 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given a _TCHAR, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszT;
//  pszT = MyGetTStringRoutine();
//  MAKE_WIDEPTR_FROMSTR(pwsz, pszT);
//  MyUseWideStringRoutine(pwsz);
//  ...
#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPWSTR)__TempBuffer##ptrname.GetBuffer(), tstr); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    lstrcpyW((LPWSTR)ptrname, tstr)
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, ptrname, __l##ptrname)
#endif

//
// similarily for MAKE_TSTRPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
// * 2 for DBCS handling in below length computation
//
#ifdef UNICODE
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPTSTR)__TempBuffer##ptrname.GetBuffer(), widestr); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\openserv\guids.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

// {C3F68021-94F3-11d2-9967-0080C7DCB3DC}
DEFINE_GUID(CLSID_CComponentData, 
            0xc3f68021, 0x94f3, 0x11d2, 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc);

// {CC288C90-94F3-11d2-9967-0080C7DCB3DC}
DEFINE_GUID(CLSID_CSnapinAbout, 
            0xcc288c90, 0x94f3, 0x11d2, 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\ppgeext\about.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "About.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

CSnapinAbout::CSnapinAbout()
: m_cref(0)
{
    OBJECT_CREATED

        m_hSmallImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    m_hLargeImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_LGBMP), IMAGE_BITMAP, 32, 32, LR_LOADTRANSPARENT);

    m_hSmallImageOpen = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMOPEN), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);

    m_hAppIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ICON1));
}

CSnapinAbout::~CSnapinAbout()
{
    if (m_hSmallImage != NULL)
        FreeResource(m_hSmallImage);

    if (m_hLargeImage != NULL)
        FreeResource(m_hLargeImage);

    if (m_hSmallImageOpen != NULL)
        FreeResource(m_hSmallImageOpen);

    if (m_hAppIcon != NULL)
        FreeResource(m_hAppIcon);

    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CSnapinAbout::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<ISnapinAbout *>(this);
    else if (IsEqualIID(riid, IID_ISnapinAbout))
        *ppv = static_cast<ISnapinAbout *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSnapinAbout::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CSnapinAbout::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription(
                                                /* [out] */ LPOLESTR *lpDescription)
{
    _TCHAR szDesc[MAX_PATH];

    LoadString(g_hinst, IDS_SNAPINDESC, szDesc, sizeof(szDesc));

    return AllocOleStr(lpDescription, szDesc);
}


STDMETHODIMP CSnapinAbout::GetProvider(
                                       /* [out] */ LPOLESTR *lpName)
{
    return AllocOleStr(lpName, _T("Copyright  1998 Microsoft Corporation"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinVersion(
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return AllocOleStr(lpVersion, _T("1.0"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinImage(
                                          /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;

    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}


STDMETHODIMP CSnapinAbout::GetStaticFolderImage(
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;

    *hSmallImageOpen = m_hSmallImageOpen;

    *cMask = RGB(0, 128, 128);

    if (*hSmallImage == NULL || *hLargeImage == NULL || *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}

// this allocates a chunk of memory using CoTaskMemAlloc and copies our chars into it
HRESULT CSnapinAbout::AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer)
{
        MAKE_WIDEPTR_FROMTSTR_ALLOC(wszStr, szBuffer);
        *lpDest = wszStr;


    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\ppgeext\about.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPABOUT_H_
#define _SAMPABOUT_H_

#include <tchar.h>
#include <mmc.h>

class CSnapinAbout : public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;
    
public:
    CSnapinAbout();
    ~CSnapinAbout();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
        /* [out] */ LPOLESTR *lpDescription);
        
        STDMETHODIMP GetProvider( 
        /* [out] */ LPOLESTR *lpName);
        
        STDMETHODIMP GetSnapinVersion( 
        /* [out] */ LPOLESTR *lpVersion);
        
        STDMETHODIMP GetSnapinImage( 
        /* [out] */ HICON *hAppIcon);
        
        STDMETHODIMP GetStaticFolderImage( 
        /* [out] */ HBITMAP *hSmallImage,
        /* [out] */ HBITMAP *hSmallImageOpen,
        /* [out] */ HBITMAP *hLargeImage,
        /* [out] */ COLORREF *cMask);
        
        ///////////////////////////////
        // Private Interface 
        ///////////////////////////////
private:
    HRESULT	CSnapinAbout::AllocOleStr(
        LPOLESTR *lpDest, 
        _TCHAR *szBuffer);
};

#endif _SAMPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\openserv\people.cpp ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#include <stdio.h>
#include "People.h"

const GUID CPeoplePoweredVehicle::thisGuid = { 0x2974380d, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

const GUID CBicycleFolder::thisGuid = { 0xef163732, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboardFolder::thisGuid = { 0xef163733, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkateFolder::thisGuid = { 0xf6c660b0, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };

const GUID CBicycle::thisGuid = { 0xef163734, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboard::thisGuid = { 0xef163735, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkate::thisGuid = { 0xf6c660b1, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };


//==============================================================
//
// CPeoplePoweredVehicle implementation
//
//
CPeoplePoweredVehicle::CPeoplePoweredVehicle()
{
    children[0] = new CBicycleFolder;
    children[1] = new CSkateboardFolder;
    children[2] = new CIceSkateFolder;
}

CPeoplePoweredVehicle::~CPeoplePoweredVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        delete children[n];
}

HRESULT CPeoplePoweredVehicle::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;

    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT    |   // relativeID is valid
                SDI_CHILDREN;     // cChildren is valid

            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = 0;

            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );

            children[n]->SetHandle((HANDLE)sdi.ID);

            _ASSERT( SUCCEEDED(hr) );
        }
    }

    return S_OK;
}

CBicycleFolder::CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CBicycle(n + 1);
    }
}

CBicycleFolder::~CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CBicycleFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                children[n]->SetHandle((HANDLE)rdi.itemID);

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

CIceSkateFolder::CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CIceSkate(n + 1);
    }
}

CIceSkateFolder::~CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CIceSkateFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                children[n]->SetHandle((HANDLE)rdi.itemID);

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

CSkateboardFolder::CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CSkateboard(n + 1);
    }
}

CSkateboardFolder::~CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSkateboardFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                      ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                children[n]->SetHandle((HANDLE)rdi.itemID);

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

const _TCHAR *CBicycle::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Bicycle #%d"), id);

    return buf;
}

const _TCHAR *CSkateboard::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Skateboard #%d"), id);

    return buf;
}

const _TCHAR *CIceSkate::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Ice Skate #%d"), id);

    return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\openserv\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Resources.rc
//
#define IDS_HELPFILE                    1
#define IDS_SNAPINDESC                  2
#define IDS_NAME                        3
#define IDB_WATERMARK                   3
#define IDB_HEADER                      4
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDS_PST_ROCKET                  10
#define IDD_PROPPAGE_LARGE              107
#define IDI_ICON1                       108
#define IDB_SMOPEN                      111
#define IDB_SMBMP                       112
#define IDB_LGBMP                       113
#define IDI_PSI_ROCKET                  114
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDC_ROCKET_NAME                 1000
#define IDC_ROCKET_HEIGHT               1001
#define IDC_ROCKET_WEIGHT               1002
#define IDC_ROCKET_PAYLOAD              1003
#define IDC_ROCKET_STATUS               1005
#define IDB_ROCKET                      10004
#define IDB_CAR                         10005
#define IDB_PLANE                       10006
#define IDB_BIKE                        10007
#define IDB_ROCKET2                     10008
#define IDB_CAR2                        10009
#define IDB_PLANE2                      10010
#define IDB_BIKE2                       10011
#define IDB_CLOSED2                     10012
#define IDB_OPEN2                       10013
#define IDB_CLOSED                      10014
#define IDB_OPEN                        10015
#define IDD_CHOOSER_CHOOSE_MACHINE      10016
#define IDC_CHOOSER_STATIC              10017
#define IDC_CHOOSER_GROUP_TARGET_MACHINE 10018
#define IDC_CHOOSER_RADIO_LOCAL_MACHINE 10019
#define IDC_CHOOSER_RADIO_SPECIFIC_MACHINE 10020
#define IDC_CHOOSER_EDIT_MACHINE_NAME   10021
#define IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES 10022
#define IDC_CHOOSER_CHECK_OVERRIDE_MACHINE_NAME 10023
#define IDS_CHOOSER_INVALID_COMPUTERNAME 10024
#define IDS_SELECT_COMPUTER             10025
#define IDS_UNABLE_TO_OPEN_COMPUTER_SELECTOR 10026
#define IDS_COMPUTER_BROWSER_CAPTION    10027
#define ID_FILE_PROPERTYSHEET           10028
#define IDS_PST_LANDBASED               10028
#define ID_FILE_DASH                    10029
#define ID_FILE_EXIT                    10030

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        5
#define _APS_NEXT_COMMAND_VALUE         40031
#define _APS_NEXT_CONTROL_VALUE         40031
#define _APS_NEXT_SYMED_VALUE           40031
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\openserv\registry.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

#define STRINGS_ONLY
#include "globals.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName)       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule,
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;

    assert(dwResult != 0) ;

    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    assert(SUCCEEDED(hr)) ;

        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;
        _tcscat(szKey, pszCLSID) ;

    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;

    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    _tcscat(szKey, _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), _T("Apartment"));

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;


    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;

        MAKE_TSTRPTR_FROMWIDE(pszT, wszCLSID);
        _tcscat(szKey, pszT) ;

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Register the snap-in in the registry.
//
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,         // Class Id for About Class
                       const BOOL fSupportExtensions)
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    LPOLESTR wszAboutCLSID = NULL;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    if (IID_NULL != clsidAbout)
        hr = StringFromCLSID(clsidAbout, &wszAboutCLSID);

        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszAboutCLSID, wszAboutCLSID);


    // Add the CLSID to the registry.
    setSnapInKeyAndValue(pszCLSID, NULL, _T("NameString"), szNameString) ;
    setSnapInKeyAndValue(pszCLSID, _T("StandAlone"), NULL, NULL);
    if (IID_NULL != clsidAbout)
        setSnapInKeyAndValue(pszCLSID, NULL, _T("About"), pszAboutCLSID);

    if (fSupportExtensions) {
        // Build the key NodeType
        setSnapInKeyAndValue(pszCLSID, _T("NodeTypes"), NULL, NULL);

        _TCHAR szKey[64] ;
        _tcscpy(szKey, pszCLSID) ;
        _tcscat(szKey, _T("\\NodeTypes")) ;
        setSnapInKeyAndValue(szKey, pszCLSID, NULL, NULL);
    }

    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    if (IID_NULL != clsidAbout)
        CoTaskMemFree(wszAboutCLSID);

    return S_OK ;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    LPOLESTR wszCLSID = NULL;

    // Get CLSID
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\"));
    _tcscat(szKeyBuf, pszCLSID);

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // free the memory
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }

    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }

    // Close the child.
    RegCloseKey(hKeyChild) ;

    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\")) ;
    _tcscat(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\ppgeext\basesnap.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#ifndef _BASESNAP_H_
#define _BASESNAP_H_

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);
STDAPI DllCanUnloadNow(void);

ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    enum FACTORY_TYPE {CONTEXTEXTENSION = 0, ABOUT = 1};
    
    CClassFactory(FACTORY_TYPE factoryType);
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
private:
    FACTORY_TYPE m_factoryType;
};

#endif _BASESNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\openserv\space.cpp ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#include <stdio.h>
#include <windows.h>
#include "Space.h"
#include "Comp.h"
#include "resource.h"

const GUID CSpaceVehicle::thisGuid = { 0x29743810, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };
const GUID CRocket::thisGuid = { 0x29743811, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSpaceVehicle implementation
//
//
CSpaceVehicle::CSpaceVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CRocket(_T("Rocket"), n+1, 500000, 265, 75000);
    }
}

CSpaceVehicle::~CSpaceVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSpaceVehicle::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Rocket Class", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 1, L"Rocket Weight", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 2, L"Rocket Height", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 3, L"Rocket Payload", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 4, L"Status", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                children[n]->SetHandle((HANDLE)rdi.itemID);

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

//==============================================================
//
// CRocket implementation
//
//
CRocket::CRocket(_TCHAR *szName, int id, LONG lWeight, LONG lHeight, LONG lPayload)
: szName(NULL), lWeight(0), lHeight(0), lPayload(0), iStatus(STOPPED)
{
    if (szName) {
        this->szName = new _TCHAR[(_tcslen(szName) + 1) * sizeof(_TCHAR)];
        _tcscpy(this->szName, szName);
    }

    this->nId = id;
    this->lWeight = lWeight;
    this->lHeight = lHeight;
    this->lPayload = lPayload;
}

CRocket::~CRocket()
{
    if (szName)
        delete [] szName;
}

const _TCHAR *CRocket::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    switch (nCol) {
    case 0:
        _stprintf(buf, _T("%s (#%d)"), szName ? szName : _T(""), nId);
        break;

    case 1:
        _stprintf(buf, _T("%ld metric tons"), lWeight);
        break;

    case 2:
        _stprintf(buf, _T("%ld meters"), lHeight);
        break;

    case 3:
        _stprintf(buf, _T("%ld kilos"), lPayload);
        break;

    case 4:
        _stprintf(buf, _T("%s"),
            iStatus == RUNNING ? _T("running") :
        iStatus == PAUSED ? _T("paused") :
        iStatus == STOPPED ? _T("stopped") : _T("unknown"));
        break;

    }

    return buf;
}

HRESULT CRocket::OnRename(LPOLESTR pszNewName)
{
    if (szName) {
        delete [] szName;
        szName = NULL;
    }

    MAKE_TSTRPTR_FROMWIDE(ptrname, pszNewName);
    szName = new _TCHAR[(_tcslen(ptrname) + 1) * sizeof(_TCHAR)];
    _tcscpy(szName, ptrname);

    return S_OK;
}

HRESULT CRocket::OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect)
{
    IConsoleVerb *pConsoleVerb;

    HRESULT hr = pConsole->QueryConsoleVerb(&pConsoleVerb);
    _ASSERT(SUCCEEDED(hr));

    hr = pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, TRUE);
    hr = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

    pConsoleVerb->Release();

    return S_OK;
}

BOOL CALLBACK CRocket::DialogProc(
                                  HWND hwndDlg,  // handle to dialog box
                                  UINT uMsg,     // message
                                  WPARAM wParam, // first message parameter
                                  LPARAM lParam  // second message parameter
                                  )
{
    static CRocket *pRocket = NULL;

    switch (uMsg) {
    case WM_INITDIALOG:
        pRocket = reinterpret_cast<CRocket *>(reinterpret_cast<PROPSHEETPAGE *>(lParam)->lParam);

        SetDlgItemText(hwndDlg, IDC_ROCKET_NAME, pRocket->szName);
        SetDlgItemInt(hwndDlg, IDC_ROCKET_HEIGHT, pRocket->lHeight, FALSE);
        SetDlgItemInt(hwndDlg, IDC_ROCKET_WEIGHT, pRocket->lWeight, FALSE);
        SetDlgItemInt(hwndDlg, IDC_ROCKET_PAYLOAD, pRocket->lPayload, FALSE);

        _ASSERT( CB_ERR != SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_INSERTSTRING, 0, (LPARAM)_T("Running")) );
        _ASSERT( CB_ERR != SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_INSERTSTRING, 1, (LPARAM)_T("Paused")) );
        _ASSERT( CB_ERR != SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_INSERTSTRING, 2, (LPARAM)_T("Stopped")) );

        SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_SETCURSEL, (WPARAM)pRocket->iStatus, 0);

        break;

    case WM_COMMAND:
        if (HIWORD(wParam) == EN_CHANGE ||
            HIWORD(wParam) == CBN_SELCHANGE)
            SendMessage(GetParent(hwndDlg), PSM_CHANGED, (WPARAM)hwndDlg, 0);
        break;

    case WM_NOTIFY:
        switch (((NMHDR *) lParam)->code) {
        case PSN_APPLY:
            if (pRocket->szName) {
                delete [] pRocket->szName;
                pRocket->szName = NULL;
            }

            {
                int n = SendDlgItemMessage(hwndDlg, IDC_ROCKET_NAME, WM_GETTEXTLENGTH, 0, 0);
                if (n != 0) {
                    pRocket->szName = new _TCHAR[n + 1];
                    GetDlgItemText(hwndDlg, IDC_ROCKET_NAME, pRocket->szName, n + 1);
                }
            }
            pRocket->lHeight = GetDlgItemInt(hwndDlg, IDC_ROCKET_HEIGHT, NULL, FALSE);
            pRocket->lWeight = GetDlgItemInt(hwndDlg, IDC_ROCKET_WEIGHT, NULL, FALSE);
            pRocket->lPayload = GetDlgItemInt(hwndDlg, IDC_ROCKET_PAYLOAD, NULL, FALSE);

            pRocket->iStatus = (ROCKET_STATUS)SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_GETCURSEL, 0, 0);


            return PSNRET_NOERROR;
        }
        break;
    }

    return DefWindowProc(hwndDlg, uMsg, wParam, lParam);
}


HRESULT CRocket::HasPropertySheets()
{
    return S_OK;
}

HRESULT CRocket::CreatePropertyPages(IPropertySheetCallback *lpProvider, LONG_PTR handle)
{
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage = NULL;

    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEICONID;
    psp.hInstance = g_hinst;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROPPAGE_LARGE);
    psp.pfnDlgProc = DialogProc;
    psp.lParam = reinterpret_cast<LPARAM>(this);
    psp.pszTitle = MAKEINTRESOURCE(IDS_PST_ROCKET);
    psp.pszIcon = MAKEINTRESOURCE(IDI_PSI_ROCKET);

    hPage = CreatePropertySheetPage(&psp);
    _ASSERT(hPage);

    return lpProvider->AddPage(hPage);
}

HRESULT CRocket::GetWatermarks(HBITMAP *lphWatermark,
                               HBITMAP *lphHeader,
                               HPALETTE *lphPalette,
                               BOOL *bStretch)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\openserv\space.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SPACE_H
#define _SPACE_H

#include "DeleBase.h"

class CRocket : public CDelegationBase {
public:
    CRocket(_TCHAR *szName, int id, LONG lWeight, LONG lHeight, LONG lPayload);
    virtual ~CRocket();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnRename(LPOLESTR pszNewName);
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect);
    
    virtual HRESULT CreatePropertyPages(IPropertySheetCallback *lpProvider, LONG_PTR handle);
    virtual HRESULT HasPropertySheets();
    virtual HRESULT GetWatermarks(HBITMAP *lphWatermark,
        HBITMAP *lphHeader,
        HPALETTE *lphPalette,
        BOOL *bStretch);
    
private:
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    _TCHAR *szName;
    LONG   lWeight;
    LONG   lHeight;
    LONG   lPayload;
    int    nId;
    enum ROCKET_STATUS {RUNNING, PAUSED, STOPPED} iStatus;
    
    static BOOL CALLBACK CRocket::DialogProc(
        HWND hwndDlg,  // handle to dialog box
        UINT uMsg,     // message
        WPARAM wParam, // first message parameter
        LPARAM lParam  // second message parameter
        );
    
};

class CSpaceVehicle : public CDelegationBase {
public:
    CSpaceVehicle();
    
    virtual ~CSpaceVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Future Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    enum { IDM_NEW_SPACE = 4 };
    
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CRocket *children[NUMBER_OF_CHILDREN];
};

#endif // _SPACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\ppgeext\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5

#define INDEX_SUN 6
#define INDEX_SNOW 7
#define INDEX_RAIN 8
#define INDEX_CLOUD 9
#define INDEX_WORLD 10
#define INDEX_THUNDER 11


#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\openserv\statnode.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SNAPINBASE_H
#define _SNAPINBASE_H

#include "DeleBase.h"

class CStaticNode : public CDelegationBase {
public:
    CStaticNode();
    
    virtual ~CStaticNode();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { 
        static _TCHAR szDisplayName[256] = {0};
        LoadString(g_hinst, IDS_SNAPINNAME, szDisplayName, sizeof(szDisplayName));
        
        if (*snapInData.m_host != 0) {
            _tcscat(szDisplayName, _T(" ("));
            _tcscat(szDisplayName, snapInData.m_host);
            _tcscat(szDisplayName, _T(")"));
        }
        
        return szDisplayName; 
    }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_NONE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
    virtual HRESULT CreatePropertyPages(IPropertySheetCallback *lpProvider, LONG_PTR handle);
    virtual HRESULT HasPropertySheets();
    virtual HRESULT GetWatermarks(HBITMAP *lphWatermark,
        HBITMAP *lphHeader,
        HPALETTE *lphPalette,
        BOOL *bStretch);
private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
    
    // {2974380C-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    struct privateData {
        _TCHAR m_host[MAX_PATH];
        BOOL m_fIsRadioLocalMachine;
        BOOL m_fAllowOverrideMachineNameOut;
        bool m_isDirty;
        
        privateData() : m_isDirty(false) {
            ZeroMemory(m_host, sizeof(m_host));
            m_fIsRadioLocalMachine = TRUE;
            m_fAllowOverrideMachineNameOut = FALSE;
        }
    } snapInData;
    
    static BOOL CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    
    public:
        LONG getDataSize() { return sizeof(privateData); }
        void *getData() { return &snapInData; }
        bool isDirty() { return snapInData.m_isDirty; }
        void clearDirty() { snapInData.m_isDirty = false; };
        
        _TCHAR *getHost() { return *snapInData.m_host == 0 ? NULL : snapInData.m_host; }
};



#endif // _SNAPINBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\openserv\statnode.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <Shlwapi.h>
#include <Shlobj.H>

#include "StatNode.h"

#include "Space.h"
#include "Sky.h"
#include "People.h"
#include "Land.h"

const GUID CStaticNode::thisGuid = { 0x2974380c, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CStaticNode implementation
//
//
CStaticNode::CStaticNode()
{
    children[0] = new CPeoplePoweredVehicle;
    children[1] = new CLandBasedVehicle;
    children[2] = new CSkyBasedVehicle;
    children[3] = new CSpaceVehicle;
}

CStaticNode::~CStaticNode()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CStaticNode::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;
    
    if (GetHandle() == NULL) {
        SetHandle((HANDLE)parent);
    }
    
    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT	  |
                SDI_CHILDREN;
            
            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = (n == 0); // only the first child has children
            
            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );
            
            children[n]->SetHandle((HANDLE)sdi.ID);
            
            _ASSERT( SUCCEEDED(hr) );
        }
    }
    
    return S_OK;
}

HRESULT CStaticNode::CreatePropertyPages(IPropertySheetCallback *lpProvider, LONG_PTR handle)
{
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage = NULL;
    
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_DEFAULT;
    psp.hInstance = g_hinst;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_CHOOSER_CHOOSE_MACHINE);
    psp.pfnDlgProc = DialogProc;
    psp.lParam = reinterpret_cast<LPARAM>(&snapInData);
    psp.pszTitle = MAKEINTRESOURCE(IDS_SELECT_COMPUTER);
    
    hPage = CreatePropertySheetPage(&psp);
    _ASSERT(hPage);
    
    return lpProvider->AddPage(hPage);
}

HRESULT CStaticNode::HasPropertySheets()
{
    return S_OK;
}

HRESULT CStaticNode::GetWatermarks(HBITMAP *lphWatermark,
                                   HBITMAP *lphHeader,
                                   HPALETTE *lphPalette,
                                   BOOL *bStretch)
{
    *lphHeader = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_HEADER), IMAGE_BITMAP, 0, 0, 0);
    *lphWatermark = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_WATERMARK), IMAGE_BITMAP, 0, 0, 0);
    *bStretch = FALSE;
    
    return S_OK;
}

BOOL CALLBACK CStaticNode::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static privateData *pData = NULL;
    static HWND m_hwndCheckboxOverride;
    
    switch (uMsg)
    {
    case WM_INITDIALOG:
        pData = reinterpret_cast<privateData *>(reinterpret_cast<PROPSHEETPAGE *>(lParam)->lParam);
        
        SendDlgItemMessage(hwndDlg, IDC_CHOOSER_RADIO_LOCAL_MACHINE, BM_SETCHECK, pData->m_fIsRadioLocalMachine, 0L);
        SendDlgItemMessage(hwndDlg, IDC_CHOOSER_RADIO_SPECIFIC_MACHINE, BM_SETCHECK, !pData->m_fIsRadioLocalMachine, 0L);
        
        EnableWindow(GetDlgItem(hwndDlg, IDC_CHOOSER_EDIT_MACHINE_NAME), !pData->m_fIsRadioLocalMachine);
        EnableWindow(GetDlgItem(hwndDlg, IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES), !pData->m_fIsRadioLocalMachine);
        
        m_hwndCheckboxOverride = ::GetDlgItem(hwndDlg, IDC_CHOOSER_CHECK_OVERRIDE_MACHINE_NAME);
        
        // fill in the supplied machine name (could be us, need to check here first)
        if (*pData->m_host != '\0') 
        {
            ::SetWindowText(GetDlgItem(hwndDlg, IDC_CHOOSER_EDIT_MACHINE_NAME), pData->m_host);
            ::SendMessage(GetDlgItem(hwndDlg, IDC_CHOOSER_RADIO_SPECIFIC_MACHINE), BM_CLICK, 0, 0);
        }
        
        
        return TRUE;
        
    case WM_COMMAND:
        switch (wParam) 
        {
        case IDC_CHOOSER_RADIO_LOCAL_MACHINE:
            pData->m_fIsRadioLocalMachine = TRUE;
            EnableWindow(GetDlgItem(hwndDlg, IDC_CHOOSER_EDIT_MACHINE_NAME), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES), FALSE);
            break;
            
        case IDC_CHOOSER_RADIO_SPECIFIC_MACHINE:
            pData->m_fIsRadioLocalMachine = FALSE;
            EnableWindow(GetDlgItem(hwndDlg, IDC_CHOOSER_EDIT_MACHINE_NAME), TRUE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES), TRUE);
            break;
            
        case IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES:
            {
                // Fall back to IE-style browser
                BROWSEINFO bi;
                LPITEMIDLIST lpItemIdList;
                LPMALLOC lpMalloc;
                
                if (SUCCEEDED(SHGetSpecialFolderLocation(hwndDlg, CSIDL_NETWORK, &lpItemIdList)))
                {
                    _TCHAR szBrowserCaption[MAX_PATH];
                    LoadString(g_hinst, IDS_COMPUTER_BROWSER_CAPTION, szBrowserCaption, sizeof(szBrowserCaption));
                    
                    bi.hwndOwner = hwndDlg; 
                    bi.pidlRoot = lpItemIdList; 
                    bi.pszDisplayName = pData->m_host; 
                    bi.lpszTitle = szBrowserCaption; 
                    bi.ulFlags = BIF_BROWSEFORCOMPUTER | BIF_EDITBOX; 
                    bi.lpfn = NULL; 
                    bi.lParam = NULL; 
                    bi.iImage = NULL; 
                    
                    if (SHBrowseForFolder(&bi) != NULL) 
                    {
                        if (*pData->m_host != '\0') 
                        {
                            ::SetWindowText(GetDlgItem(hwndDlg, 
                                IDC_CHOOSER_EDIT_MACHINE_NAME), pData->m_host);
                        }
                    }
                    
                    if (SUCCEEDED(SHGetMalloc(&lpMalloc))) 
                    {
                        lpMalloc->Free(lpItemIdList);
                        lpMalloc->Release();
                    }
                }
            }
            break;
            
        case IDC_CHOOSER_CHECK_OVERRIDE_MACHINE_NAME:
            break;
        }
        break;
        
        case WM_NOTIFY:
            switch (((LPNMHDR)lParam)->code) {
            case PSN_SETACTIVE: 
                PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_FINISH);
                break;
                
            case PSN_WIZFINISH: 
                if (pData->m_fIsRadioLocalMachine) {
                    // Return empty string to caller
                    *pData->m_host = '\0';
                } else {
                    // Get the machine name from the edit window
                    GetWindowText(GetDlgItem(hwndDlg, IDC_CHOOSER_EDIT_MACHINE_NAME), 
                        pData->m_host, sizeof(pData->m_host));
                }
                
                // Save the override flag if the caller asked for it
                pData->m_fAllowOverrideMachineNameOut = 
                    SendMessage(m_hwndCheckboxOverride, BM_GETCHECK, 0, 0) == BST_CHECKED ? TRUE : FALSE;
                
                break;
            }
            
            break;
    }
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\ppgeext\registry.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout);		// Class Id for About Class


HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\ppgeext\extend.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _EXTEND_H
#define _EXTEND_H

struct EXTENSION_NODE
{
    GUID	GUID;
    _TCHAR	szDescription[256];
};

enum EXTENSION_TYPE
{
    NameSpaceExtension,
        ContextMenuExtension, 
        ToolBarExtension,
        PropertySheetExtension,
        TaskExtension,
        DynamicExtension,
        DummyExtension
};

struct EXTENDER_NODE
{
    EXTENSION_TYPE	eType;
    GUID			guidNode;
    GUID			guidExtension;
    _TCHAR			szDescription[256];
};

#endif // _EXTEND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\ppgeext\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>

#ifndef STRINGS_ONLY
        #define IDM_BUTTON1    0x100
        #define IDM_BUTTON2    0x101

        extern HINSTANCE g_hinst;
        extern ULONG g_uObjects;

        #define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
        #define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

#endif

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(GetProcessHeap(), 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(GetProcessHeap(), 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given a _TCHAR, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszT;
//  pszT = MyGetTStringRoutine();
//  MAKE_WIDEPTR_FROMSTR(pwsz, pszT);
//  MyUseWideStringRoutine(pwsz);
//  ...
#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPWSTR)__TempBuffer##ptrname.GetBuffer(), tstr); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    lstrcpyW((LPWSTR)ptrname, tstr)
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, ptrname, __l##ptrname)
#endif

//
// similarily for MAKE_TSTRPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
// * 2 for DBCS handling in below length computation
//
#ifdef UNICODE
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPTSTR)__TempBuffer##ptrname.GetBuffer(), widestr); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\proppage\about.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "About.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

CSnapinAbout::CSnapinAbout()
: m_cref(0)
{
    OBJECT_CREATED

        m_hSmallImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    m_hLargeImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_LGBMP), IMAGE_BITMAP, 32, 32, LR_LOADTRANSPARENT);

    m_hSmallImageOpen = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMOPEN), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);

    m_hAppIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ICON1));
}

CSnapinAbout::~CSnapinAbout()
{
    if (m_hSmallImage != NULL)
        FreeResource(m_hSmallImage);

    if (m_hLargeImage != NULL)
        FreeResource(m_hLargeImage);

    if (m_hSmallImageOpen != NULL)
        FreeResource(m_hSmallImageOpen);

    if (m_hAppIcon != NULL)
        FreeResource(m_hAppIcon);

    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CSnapinAbout::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<ISnapinAbout *>(this);
    else if (IsEqualIID(riid, IID_ISnapinAbout))
        *ppv = static_cast<ISnapinAbout *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSnapinAbout::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CSnapinAbout::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription(
                                                /* [out] */ LPOLESTR *lpDescription)
{
    _TCHAR szDesc[MAX_PATH];

    LoadString(g_hinst, IDS_SNAPINDESC, szDesc, sizeof(szDesc));

    return AllocOleStr(lpDescription, szDesc);
}


STDMETHODIMP CSnapinAbout::GetProvider(
                                       /* [out] */ LPOLESTR *lpName)
{
    return AllocOleStr(lpName, _T("Copyright  1998 Microsoft Corporation"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinVersion(
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return AllocOleStr(lpVersion, _T("1.0"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinImage(
                                          /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;

    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}


STDMETHODIMP CSnapinAbout::GetStaticFolderImage(
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;

    *hSmallImageOpen = m_hSmallImageOpen;

    *cMask = RGB(0, 128, 128);

    if (*hSmallImage == NULL || *hLargeImage == NULL || *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}

// this allocates a chunk of memory using CoTaskMemAlloc and copies our chars into it
HRESULT CSnapinAbout::AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer)
{
        MAKE_WIDEPTR_FROMTSTR_ALLOC(wszStr, szBuffer);
        *lpDest = wszStr;


    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\ppgeext\basesnap.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <olectl.h>
#include <initguid.h>
#include "globals.h"
#include "resource.h"
#include "guids.h"
#include "basesnap.h"
#include "PPgeExt.h"
#include "About.h"
#include "Registry.h"
#include "Extend.h"

// our globals
HINSTANCE g_hinst;


BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    if ((rclsid != CLSID_CPropSheetExtension) && (rclsid != CLSID_CSnapinAbout))
        return CLASS_E_CLASSNOTAVAILABLE;
    
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
    // make the factory passing in the creation function for the type of object they want
    if (rclsid == CLSID_CPropSheetExtension)
        pFactory = new CClassFactory(CClassFactory::CONTEXTEXTENSION);
    else if (rclsid == CLSID_CSnapinAbout)
        pFactory = new CClassFactory(CClassFactory::ABOUT);
    
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}


CClassFactory::CClassFactory(FACTORY_TYPE factoryType)
: m_cref(0), m_factoryType(factoryType)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    if (CONTEXTEXTENSION == m_factoryType) {
        pObj = new CPropSheetExtension();
    } else {
        pObj = new CSnapinAbout();
    }
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    
    if (FAILED(hr))
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{
    HRESULT hr = SELFREG_E_CLASS;
    
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName));
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, sizeof(szSnapInName));
    
    _TCHAR szAboutName[256];
    
    LoadString(g_hinst, IDS_ABOUTNAME, szAboutName, sizeof(szAboutName));
    
    
    // register our CoClasses
    hr = RegisterServer(g_hinst, 
        CLSID_CPropSheetExtension, 
        szName);
    
    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst, 
        CLSID_CSnapinAbout, 
        szAboutName);
    
    // place the registry information for SnapIns
    if SUCCEEDED(hr)
        hr = RegisterSnapin(CLSID_CPropSheetExtension, szSnapInName, CLSID_CSnapinAbout);
    
    return hr;
}


STDAPI DllUnregisterServer()
{
    if (UnregisterServer(CLSID_CPropSheetExtension) == S_OK)
        return UnregisterSnapin(CLSID_CPropSheetExtension);
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\proppage\basesnap.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <olectl.h>
#include <initguid.h>
#include "guids.h"
#include "basesnap.h"
#include "Comp.h"
#include "CompData.h"
#include "About.h"
#include "Registry.h"

// our globals
HINSTANCE g_hinst;

BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    if ((rclsid != CLSID_CComponentData) && (rclsid != CLSID_CSnapinAbout))
        return CLASS_E_CLASSNOTAVAILABLE;
    
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
    // make the factory passing in the creation function for the type of object they want
    if (rclsid == CLSID_CComponentData)
        pFactory = new CClassFactory(CClassFactory::COMPONENT);
    else if (rclsid == CLSID_CSnapinAbout)
        pFactory = new CClassFactory(CClassFactory::ABOUT);
    
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}


CClassFactory::CClassFactory(FACTORY_TYPE factoryType)
: m_cref(0), m_factoryType(factoryType)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    if (COMPONENT == m_factoryType) {
        pObj = new CComponentData();
    } else {
        pObj = new CSnapinAbout();
    }
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    
    if (FAILED(hr))
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{
    HRESULT hr = SELFREG_E_CLASS;
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName));
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, sizeof(szSnapInName));
    
    _TCHAR szAboutName[256];
    
    LoadString(g_hinst, IDS_ABOUTNAME, szAboutName, sizeof(szAboutName));
    
    // register our CoClasses
    hr = RegisterServer(g_hinst, 
        CLSID_CComponentData, 
        szName);
    
    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst, 
        CLSID_CSnapinAbout, 
        szAboutName);
    
    // place the registry information for SnapIns
    if SUCCEEDED(hr)
        hr = RegisterSnapin(CLSID_CComponentData, szSnapInName, CLSID_CSnapinAbout, FALSE);
    
    return hr;
}


STDAPI DllUnregisterServer()
{
    if (UnregisterServer(CLSID_CComponentData) == S_OK)
        return UnregisterSnapin(CLSID_CComponentData);
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\proppage\about.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPABOUT_H_
#define _SAMPABOUT_H_

#include <tchar.h>
#include <mmc.h>

class CSnapinAbout : public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;
    
public:
    CSnapinAbout();
    ~CSnapinAbout();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
        /* [out] */ LPOLESTR *lpDescription);
        
        STDMETHODIMP GetProvider( 
        /* [out] */ LPOLESTR *lpName);
        
        STDMETHODIMP GetSnapinVersion( 
        /* [out] */ LPOLESTR *lpVersion);
        
        STDMETHODIMP GetSnapinImage( 
        /* [out] */ HICON *hAppIcon);
        
        STDMETHODIMP GetStaticFolderImage( 
        /* [out] */ HBITMAP *hSmallImage,
        /* [out] */ HBITMAP *hSmallImageOpen,
        /* [out] */ HBITMAP *hLargeImage,
        /* [out] */ COLORREF *cMask);
        
        ///////////////////////////////
        // Private Interface 
        ///////////////////////////////
private:
    HRESULT	CSnapinAbout::AllocOleStr(
        LPOLESTR *lpDest, 
        _TCHAR *szBuffer);
};

#endif _SAMPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\proppage\basesnap.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#ifndef _BASESNAP_H_
#define _BASESNAP_H_

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);
STDAPI DllCanUnloadNow(void);

ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    enum FACTORY_TYPE {COMPONENT = 0, ABOUT = 1};
    
    CClassFactory(FACTORY_TYPE factoryType);
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
private:
    FACTORY_TYPE m_factoryType;
};

#endif _BASESNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\ppgeext\ppgeext.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "PPgeExt.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

    // These are the clipboard formats that we must supply at a minimum.
    // mmc.h actually defined these. We can make up our own to use for
    // other reasons. We don't need any others at this time.
UINT CPropSheetExtension::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CPropSheetExtension::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CPropSheetExtension::s_cfSnapInCLSID = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);

CPropSheetExtension::CPropSheetExtension() : m_cref(0)
{
    OBJECT_CREATED
}

CPropSheetExtension::~CPropSheetExtension()
{
    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CPropSheetExtension::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IExtendPropertySheet *>(this);
    else if (IsEqualIID(riid, IID_IExtendPropertySheet))
        *ppv = static_cast<IExtendPropertySheet *>(this);
    
    if (*ppv) 
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CPropSheetExtension::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CPropSheetExtension::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    
    return m_cref;
}

BOOL CALLBACK CPropSheetExtension::DialogProc(
                                              HWND hwndDlg,  // handle to dialog box
                                              UINT uMsg,     // message
                                              WPARAM wParam, // first message parameter
                                              LPARAM lParam  // second message parameter
                                              )
{
    static CPropSheetExtension *pThis = NULL;
    
    switch (uMsg) {
    case WM_INITDIALOG:
        pThis = reinterpret_cast<CPropSheetExtension *>(reinterpret_cast<PROPSHEETPAGE *>(lParam)->lParam);
        
        break;
        
    case WM_COMMAND:
        if (HIWORD(wParam) == EN_CHANGE ||
            HIWORD(wParam) == CBN_SELCHANGE)
            SendMessage(GetParent(hwndDlg), PSM_CHANGED, (WPARAM)hwndDlg, 0);
        break;
        
    case WM_DESTROY:
        // we don't free the notify handle for property sheets
        // MMCFreeNotifyHandle(pThis->m_ppHandle);
        break;
        
    case WM_NOTIFY:
        switch (((NMHDR *) lParam)->code) {
        case PSN_APPLY:
            // don't notify the primary snap-in that Apply
            // has been hit...
            // MMCPropertyChangeNotify(pThis->m_ppHandle, (long)pThis);
            return PSNRET_NOERROR;
        }
        break;
    }
    
    return DefWindowProc(hwndDlg, uMsg, wParam, lParam);
}

///////////////////////////////
// Interface IExtendPropertySheet
///////////////////////////////
HRESULT CPropSheetExtension::CreatePropertyPages( 
                                                 /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
                                                 /* [in] */ LONG_PTR handle,
                                                 /* [in] */ LPDATAOBJECT lpIDataObject)
{
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage = NULL;
    
    // we don't cache this handle like in a primary snap-in
    // the handle value here is always 0
    // m_ppHandle = handle;
    
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEICONID;
    psp.hInstance = g_hinst;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROPPAGE_LARGE);
    psp.pfnDlgProc = DialogProc;
    psp.lParam = reinterpret_cast<LPARAM>(this);
    psp.pszTitle = MAKEINTRESOURCE(IDS_PST_ROCKET_EXT);
    psp.pszIcon = MAKEINTRESOURCE(IDI_PSI_ROCKET);
    
    hPage = CreatePropertySheetPage(&psp);
    _ASSERT(hPage);
    
    HRESULT hr = lpProvider->AddPage(hPage);
    return hr;
}

HRESULT CPropSheetExtension::QueryPagesFor( 
                                           /* [in] */ LPDATAOBJECT lpDataObject)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\ppgeext\ppgeext.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _CPropSheetExtension_H_
#define _CPropSheetExtension_H_

#include <tchar.h>
#include <mmc.h>

class CPropSheetExtension : public IExtendPropertySheet
{
    
private:
    ULONG				m_cref;
    
    // clipboard format
    static UINT s_cfDisplayName;
    static UINT s_cfSnapInCLSID;
    static UINT s_cfNodeType;
    
public:
    CPropSheetExtension();
    ~CPropSheetExtension();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IExtendPropertySheet
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
        /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
        /* [in] */ LONG_PTR handle,
        /* [in] */ LPDATAOBJECT lpIDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
        /* [in] */ LPDATAOBJECT lpDataObject);
        
private:
    LONG_PTR m_ppHandle;
    
    static BOOL CALLBACK DialogProc(HWND hwndDlg,  // handle to dialog box
        UINT uMsg,     // message
        WPARAM wParam, // first message parameter
        LPARAM lParam  // second message parameter
        );
    
    
    ///////////////////////////////
    // Private IDataObject support bits
    ///////////////////////////////
    HRESULT ExtractData( IDataObject* piDataObject,
        CLIPFORMAT   cfClipFormat,
        BYTE*        pbData,
        DWORD        cbData )
    {
        HRESULT hr = S_OK;
        
        FORMATETC formatetc = {cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL};
        
        stgmedium.hGlobal = ::GlobalAlloc(GPTR, cbData);
        do // false loop
        {
            if (NULL == stgmedium.hGlobal)
            {
                hr = E_OUTOFMEMORY;
                break;
            }
            hr = piDataObject->GetDataHere( &formatetc, &stgmedium );
            if ( FAILED(hr) )
            {
                break;
            }
            
            BYTE* pbNewData = reinterpret_cast<BYTE*>(stgmedium.hGlobal);
            if (NULL == pbNewData)
            {
                hr = E_UNEXPECTED;
                break;
            }
            ::memcpy( pbData, pbNewData, cbData );
        } while (FALSE); // false loop
        
        if (NULL != stgmedium.hGlobal)
        {
            ::GlobalFree(stgmedium.hGlobal);
        }
        return hr;
    } // ExtractData()
    
    HRESULT ExtractString( IDataObject *piDataObject,
        CLIPFORMAT   cfClipFormat,
        _TCHAR       *pstr,
        DWORD        cchMaxLength)
    {
        return ExtractData( piDataObject, cfClipFormat, (PBYTE)pstr, cchMaxLength );
    }
    
    HRESULT ExtractSnapInCLSID( IDataObject* piDataObject, CLSID* pclsidSnapin )
    {
        return ExtractData( piDataObject, s_cfSnapInCLSID, (PBYTE)pclsidSnapin, sizeof(CLSID) );
    }
    
    HRESULT ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* pguidObjectType )
    {
        return ExtractData( piDataObject, s_cfNodeType, (PBYTE)pguidObjectType, sizeof(GUID) );
    }
};

#endif _CPropSheetExtension_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\proppage\comp.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMP_H_
#define _SAMPCOMP_H_

#include <mmc.h>

class CComponent : public IComponent,
IExtendPropertySheet2
{
private:
    ULONG				m_cref;
    
    IConsole*		m_ipConsole;
    
    class CComponentData *m_pComponentData;
    
    public:
        CComponent(CComponentData *parent);
        ~CComponent();
        
        ///////////////////////////////
        // Interface IUnknown
        ///////////////////////////////
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        
        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ MMC_COOKIE cookie);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);
            
            //////////////////////////////////
            // Interface IExtendPropertySheet2
            //////////////////////////////////
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
            /* [in] */ LONG_PTR handle,
            /* [in] */ LPDATAOBJECT lpIDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
            /* [in] */ LPDATAOBJECT lpDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetWatermarks( 
            /* [in] */ LPDATAOBJECT lpIDataObject,
            /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
            /* [out] */ HBITMAP __RPC_FAR *lphHeader,
            /* [out] */ HPALETTE __RPC_FAR *lphPalette,
            /* [out] */ BOOL __RPC_FAR *bStretch);
};

#endif _SAMPCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\proppage\dataobj.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DataObj.h"
#include "guids.h"
#include "DeleBase.h"

//
// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SZNODETYPE _T("CCF_SZNODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

#define _T_CCF_INTERNAL_SNAPIN _T("{2479DB32-5276-11d2-94F5-00C04FB92EC2}")

    // These are the clipboard formats that we must supply at a minimum.
    // mmc.h actually defined these. We can make up our own to use for
    // other reasons. We don't need any others at this time.
UINT CDataObject::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CDataObject::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CDataObject::s_cfSZNodeType  = RegisterClipboardFormat(_T_CCF_SZNODETYPE);
UINT CDataObject::s_cfSnapinClsid = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);
UINT CDataObject::s_cfInternal    = RegisterClipboardFormat(_T_CCF_INTERNAL_SNAPIN);


CDataObject::CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context)
: m_lCookie(cookie), m_context(context), m_cref(0)
{
}

CDataObject::~CDataObject()
{
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IDataObject *>(this);
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppv = static_cast<IDataObject *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CDataObject::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
//
HRESULT CDataObject::GetDataHere(
                                 FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure
                                 STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure
                                 )
{
    const   CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pStream = NULL;

    CDelegationBase *base = GetBaseNodeObject();

    HRESULT hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( FAILED(hr) )
        return hr;                       // Minimal error checking

    hr = DV_E_FORMATETC;                 // Unknown format

    if (cf == s_cfDisplayName) {
        const _TCHAR *pszName = base->GetDisplayName();

                MAKE_WIDEPTR_FROMTSTR(wszName, pszName);

                // get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(pszName);
        ulSizeofName++;                      // Count null character
        ulSizeofName *= sizeof(WCHAR);

        hr = pStream->Write(wszName, ulSizeofName, NULL);
    } else if (cf == s_cfNodeType) {
        const GUID *pGUID = (const GUID *)&base->getNodeType();

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfSZNodeType) {
        LPOLESTR szGuid;
        hr = StringFromCLSID(base->getNodeType(), &szGuid);

        if (SUCCEEDED(hr)) {
            hr = pStream->Write(szGuid, wcslen(szGuid), NULL);
            CoTaskMemFree(szGuid);
        }
    } else if (cf == s_cfSnapinClsid) {
        const GUID *pGUID = NULL;
        pGUID = &CLSID_CComponentData;

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfInternal) {
        // we are being asked to get our this pointer from the IDataObject interface
        // only our own snap-in objects will know how to do this.
        CDataObject *pThis = this;
        hr = pStream->Write( &pThis, sizeof(CDataObject*), NULL );
    }

    pStream->Release();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Global helper functions to help work with dataobjects and
// clipboard formats


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfInternal clipboard format
//
CDataObject* GetOurDataObject (
                               LPDATAOBJECT lpDataObject      // [in] IComponent pointer
                               )
{
    HRESULT       hr      = S_OK;
    CDataObject *pSDO     = NULL;

	// check to see if the data object is a special data object.
	if ( IS_SPECIAL_DATAOBJECT (lpDataObject) )
	{
		//Code for handling a special data object goes here.

		//Note that the MMC SDK samples do not handle
		//special data objects, so we exit if we get one.
		return NULL;
	}

    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { CDataObject::s_cfInternal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(CDataObject *));

    if (!stgmedium.hGlobal)     {
        hr = E_OUTOFMEMORY;
    }

    if SUCCEEDED(hr)
        // Attempt to get data from the object
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );

    // stgmedium now has the data we need
    if (SUCCEEDED(hr))  {
        pSDO = *(CDataObject **)(stgmedium.hGlobal);
    }

    // if we have memory free it
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);

    return pSDO;

} // end GetOurDataObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\proppage\dataobj.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPDATAOBJECT_H_
#define _SAMPDATAOBJECT_H_

#include <mmc.h>
#include "DeleBase.h"

class CDataObject : public IDataObject
{
private:
    ULONG				m_cref;
    MMC_COOKIE			m_lCookie;
    DATA_OBJECT_TYPES   m_context;
    
public:
    CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context);
    ~CDataObject();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // IDataObject methods 
    ///////////////////////////////
    STDMETHODIMP GetDataHere (FORMATETC *pformatetc, STGMEDIUM *pmedium);
    
    // The rest are not implemented
    STDMETHODIMP GetData (LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumFormatEtc (DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };
    
    STDMETHODIMP QueryGetData (LPFORMATETC lpFormatetc) 
    { return E_NOTIMPL; };
    
    STDMETHODIMP GetCanonicalFormatEtc (LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    
    STDMETHODIMP SetData (LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DAdvise (LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DUnadvise (DWORD dwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumDAdvise (LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };
    
    ///////////////////////////////
    // Custom Methods
    ///////////////////////////////
    
    CDelegationBase *GetBaseNodeObject() {
        return (CDelegationBase *)m_lCookie;
    }
    
    DATA_OBJECT_TYPES GetContext() {
        return m_context;
    }
    
public:
    // clipboard formats
    static UINT s_cfSZNodeType;
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
    static UINT s_cfInternal;
    
};

HRESULT ExtractFromDataObject(IDataObject *lpDataObject,UINT cf,ULONG cb,HGLOBAL *phGlobal);
CDataObject* GetOurDataObject(IDataObject *lpDataObject);
BOOL IsMMCMultiSelectDataObject(IDataObject *lpDataObject);

#endif _SAMPDATAOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\ppgeext\guids.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

// {CFCDC9F3-C50E-11d2-952B-00C04FB92EC2}
DEFINE_GUID(CLSID_CPropSheetExtension, 
            0xcfcdc9f3, 0xc50e, 0x11d2, 0x95, 0x2b, 0x0, 0xc0, 0x4f, 0xb9, 0x2e, 0xc2);
// {CFCDC9F7-C50E-11d2-952B-00C04FB92EC2}
DEFINE_GUID(CLSID_CSnapinAbout, 
            0xcfcdc9f7, 0xc50e, 0x11d2, 0x95, 0x2b, 0x0, 0xc0, 0x4f, 0xb9, 0x2e, 0xc2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\ppgeext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Resources.rc
//
#define IDS_HELPFILE                    1
#define IDS_SNAPINDESC                  2
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDD_PROPPAGE_LARGE              10
#define IDS_PST_ROCKET_EXT              10
#define IDI_ICON1                       108
#define IDI_PSI_ROCKET                  114
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDB_SMOPEN                      124
#define IDB_SMBMP                       125
#define IDB_LGBMP                       126
#define IDB_ROCKET                      40004
#define IDB_CAR                         40005
#define IDB_PLANE                       40006
#define IDB_BIKE                        40007
#define IDB_ROCKET2                     40008
#define IDB_CAR2                        40009
#define IDB_PLANE2                      40010
#define IDB_BIKE2                       40011
#define IDB_CLOSED2                     40012
#define IDB_OPEN2                       40013
#define IDB_CLOSED                      40014
#define IDB_OPEN                        40015
#define ID_BUTTON40016                  40016
#define ID_BUTTON40017                  40017
#define ID_BUTTON40018                  40018
#define ID_BUTTON40019                  40019
#define ID_BUTTON40020                  40020
#define ID_BUTTON40021                  40021
#define ID_BUTTON40022                  40022
#define ID_BUTTON40023                  40023
#define ID_BUTTON40024                  40024
#define ID_BUTTON40025                  40025
#define ID_BUTTON40026                  40026
#define EDIT1                           40027
#define EDIT2                           40028
#define EDIT3                           40029
#define EDIT4                           40030
#define COMBO1                          40031

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        127
#define _APS_NEXT_COMMAND_VALUE         40032
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\proppage\delebase.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DeleBase.h"

const GUID CDelegationBase::thisGuid = { 0x2974380b, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

HBITMAP CDelegationBase::m_pBMapSm = NULL;
HBITMAP CDelegationBase::m_pBMapLg = NULL;


//==============================================================
//
// CDelegationBase implementation
//
//
CDelegationBase::CDelegationBase() 
: bExpanded(FALSE) 
{ 
    if (NULL == m_pBMapSm || NULL == m_pBMapLg)
        LoadBitmaps(); 
}

CDelegationBase::~CDelegationBase() 
{ 
}

// CDelegationBase::AddImages sets up the collection of images to be displayed
// by the IComponent in the result pane as a result of its MMCN_SHOW handler
HRESULT CDelegationBase::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi) 
{
    return pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\proppage\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>

#ifndef STRINGS_ONLY
        #define IDM_BUTTON1    0x100
        #define IDM_BUTTON2    0x101

        extern HINSTANCE g_hinst;
        extern ULONG g_uObjects;

        #define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
        #define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

        // uncomment the following #define to enable message cracking
        // #define MMC_CRACK_MESSAGES
        void MMCN_Crack(BOOL bComponentData,
                                        IDataObject *pDataObject,
                                        IComponentData *pCompData,
                                        IComponent *pComp,
                                        MMC_NOTIFY_TYPE event,
                                        LPARAM arg,
                                        LPARAM param);
#endif

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(GetProcessHeap(), 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(GetProcessHeap(), 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given a _TCHAR, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszT;
//  pszT = MyGetTStringRoutine();
//  MAKE_WIDEPTR_FROMSTR(pwsz, pszT);
//  MyUseWideStringRoutine(pwsz);
//  ...
#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPWSTR)__TempBuffer##ptrname.GetBuffer(), tstr); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    lstrcpyW((LPWSTR)ptrname, tstr)
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, ptrname, __l##ptrname)
#endif

//
// similarily for MAKE_TSTRPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
// * 2 for DBCS handling in below length computation
//
#ifdef UNICODE
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPTSTR)__TempBuffer##ptrname.GetBuffer(), widestr); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\proppage\land.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Land.h"

const GUID CLandBasedVehicle::thisGuid = { 0x2974380e, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CLandBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\proppage\land.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _LAND_H
#define _LAND_H

#include "DeleBase.h"

class CLandBasedVehicle : public CDelegationBase {
public:
    CLandBasedVehicle() { }
    
    virtual ~CLandBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Land-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_LANDICON; }
    
private:
    enum { IDM_NEW_LAND = 2 };
    
    // {2974380E-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};


#endif // _LAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\proppage\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5

#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\proppage\mmccrack.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

static TCHAR *MMCN_CrackVerb(MMC_CONSOLE_VERB verb)
{
        static TCHAR error[64];

        switch (verb) {
    case MMC_VERB_NONE:
                return _T("NONE");
    case MMC_VERB_OPEN:
                return _T("OPEN");
    case MMC_VERB_COPY:
                return _T("COPY");
    case MMC_VERB_PASTE:
                return _T("PASTE");
    case MMC_VERB_DELETE:
                return _T("DELETE");
    case MMC_VERB_PROPERTIES:
                return _T("PROPERTIES");
    case MMC_VERB_RENAME:
                return _T("RENAME");
    case MMC_VERB_REFRESH:
                return _T("REFRESH");
    case MMC_VERB_PRINT:
                return _T("PRINT");
    case MMC_VERB_CUT:
                return _T("CUT");
        default:
                wsprintf(error, _T("Unknown verb id %d"), verb);
                return error;
        }
}

void MMCN_Crack(BOOL bComponentData,
                IDataObject *pDataObject,
                                IComponentData *pCompData,
                                IComponent *pComp,
                MMC_NOTIFY_TYPE event,
                                LPARAM arg,
                                LPARAM param)
{
#ifdef MMC_CRACK_MESSAGES
        TCHAR message[256] = {0};

        if (bComponentData == TRUE)
                OutputDebugString(_T("IComponentData::Notify( "));
        else
                OutputDebugString(_T("IComponent::Notify( "));

        wsprintf(message, _T("DataObject: %08x, CompData: %08x, Comp: %08x ) - "), pDataObject, pCompData, pComp);
        OutputDebugString(message);

    switch (event)      {
                case MMCN_ACTIVATE:
                        wsprintf(message, _T("MMCN_ACTIVATE\n\tActivate: %d\n"), arg);
                        break;

                case MMCN_ADD_IMAGES:
                        wsprintf(message, _T("MMCN_ADD_IMAGES\n\tImage List: %08x\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_BTN_CLICK:
                        wsprintf(message, _T("MMCN_BTN_CLICK\n\tVerb: %ws\n"), MMCN_CrackVerb((MMC_CONSOLE_VERB)param));
                        break;

                case MMCN_COLUMN_CLICK:
                        wsprintf(message, _T("MMCN_COLUMN_CLICK\n\tColumn: %d\n\tSort Option: %d\n"), arg,       param);
                        break;

                case MMCN_COLUMNS_CHANGED:
                        wsprintf(message, _T("MMCN_COLUMNS_CHANGED\n"));
                        break;

                case MMCN_CONTEXTHELP:
                        wsprintf(message, _T("MMCN_CONTEXTHELP\n"));
                        break;

                case MMCN_CONTEXTMENU:
                        wsprintf(message, _T("MMCN_CONTEXTMENU\n"));
                        break;

                case MMCN_CUTORMOVE:
                        wsprintf(message, _T("MMCN_CUTORMOVE\n"));
                        break;

                case MMCN_DBLCLICK:
                        wsprintf(message, _T("MMCN_DBLCLICK\n"));
                        break;

                case MMCN_DELETE:
                        wsprintf(message, _T("MMCN_DELETE\n"));
                        break;

                case MMCN_DESELECT_ALL:
                        wsprintf(message, _T("MMCN_DESELECT_ALL\n"));
                        break;

                case MMCN_EXPAND:
                        wsprintf(message, _T("MMCN_EXPAND\n\tExpand: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_EXPANDSYNC:
                        wsprintf(message, _T("MMCN_EXPANDSYNC\n"));
                        break;

                case MMCN_FILTERBTN_CLICK:
                        wsprintf(message, _T("MMCN_FILTERBTN_CLICK\n\tColumn: %d\n"), arg);
                        break;

                case MMCN_FILTER_CHANGE:
                        wsprintf(message, _T("MMCN_FILTER_CHANGE\n\tColumn: %d\n"), param);
                        break;

                case MMCN_HELP:
                        wsprintf(message, _T("MMCN_HELP\n"));
                        break;

                case MMCN_INITOCX:
                        wsprintf(message, _T("MMCN_INITOCX\n\tIUnknown: %08x\n"), param);
                        break;

                case MMCN_LISTPAD:
                        wsprintf(message, _T("MMCN_LISTPAD\n\tConnect: %d\n"), arg);
                        break;

                case MMCN_MENU_BTNCLICK:
                        wsprintf(message, _T("MMCN_MENU_BTNCLICK\n"));
                        break;

                case MMCN_MINIMIZED:
                        wsprintf(message, _T("MMCN_MINIMIZED\n\tMinimized: %d\n"), arg);
                        break;

                case MMCN_PASTE:
                        wsprintf(message, _T("MMCN_PASTE\n\tCopy: %d\n"), param == NULL);
                        break;

                case MMCN_PRELOAD:
                        wsprintf(message, _T("MMCN_PRELOAD\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_PRINT:
                        wsprintf(message, _T("MMCN_PRINT\n"));
                        break;

                case MMCN_PROPERTY_CHANGE:
                        wsprintf(message, _T("MMCN_PROPERTY_CHANGE\n\tScope: %d\n\tArg: %08x\n"), arg, param);
                        break;

                case MMCN_QUERY_PASTE:
                        wsprintf(message, _T("MMCN_QUERY_PASTE\n"));
                        break;

                case MMCN_REFRESH:
                        wsprintf(message, _T("MMCN_REFRESH\n"));
                        break;

                case MMCN_REMOVE_CHILDREN:
                        wsprintf(message, _T("MMCN_REMOVE_CHILDREN\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_RENAME:
                        wsprintf(message, _T("MMCN_RENAME\n\tNew Name: '%ws'\n"), (LPOLESTR)param);
                        break;

                case MMCN_RESTORE_VIEW:
                        wsprintf(message, _T("MMCN_RESTORE_VIEW\n"));
                        break;

                case MMCN_SELECT:
                        wsprintf(message, _T("MMCN_SELECT\n\tScope: %d\n\tSelect: %08x\n"), LOWORD(arg), HIWORD(arg));
                        break;

                case MMCN_SHOW:
                        wsprintf(message, _T("MMCN_SHOW\n\tShow: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_SNAPINHELP:
                        wsprintf(message, _T("MMCN_SNAPINHELP\n"));
                        break;

                case MMCN_VIEW_CHANGE:
                        wsprintf(message, _T("MMCN_VIEW_CHANGE\n\tData: %08x\n\tHint: %08x\n"), arg, param);
                        break;
        }

        if (message[0] != 0)
                OutputDebugString(message);
        else
                OutputDebugString(_T("unknown event\n"));

#endif
        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\ppgeext\registry.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <assert.h>
#include "Registry.h"
#include "Extend.h"
#include "GUIDs.h"
#include "globals.h"

// if not standalone comment out next line
//#define STANDALONE

// list all nodes that are extendable here
// List the GUID and then the description
// terminate with a NULL, NULL set.
EXTENSION_NODE _ExtendableNodes[] = {
    {NULL, NULL}
};

// list all of the nodes that we extend
EXTENDER_NODE _NodeExtensions[] = {
    {PropertySheetExtension,
    {0x29743811, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28}},
    {0xcfcdc9f3, 0xc50e, 0x11d2, {0x95, 0x2b, 0x0, 0xc0, 0x4f, 0xb9, 0x2e, 0xc2}},
    _T("Extension to the Rocket Node")},

    {DummyExtension,
    NULL,
    NULL,
    NULL}
};

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

BOOL setSnapInExtensionNode(const _TCHAR* szSnapID,
                            const _TCHAR* szNodeID,
                            const _TCHAR* szDescription);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName)       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule,
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;

    assert(dwResult != 0) ;

    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    assert(SUCCEEDED(hr)) ;

    MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;
        _tcscat(szKey, pszCLSID) ;

    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;

    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    _tcscat(szKey, _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), _T("Apartment"));

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;


    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;

    MAKE_TSTRPTR_FROMWIDE(pszT, wszCLSID);
    _tcscat(szKey, pszT) ;

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Register the snap-in in the registry.
//
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout)         // Class Id for About Class

{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    LPOLESTR wszAboutCLSID = NULL;
    LPOLESTR wszExtendCLSID = NULL;
    LPOLESTR wszNodeCLSID = NULL;
    EXTENSION_NODE *pExtensionNode;
    EXTENDER_NODE *pNodeExtension;
    _TCHAR szKeyBuf[1024] ;
    HKEY hKey;

    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    if (IID_NULL != clsidAbout)
        hr = StringFromCLSID(clsidAbout, &wszAboutCLSID);

    MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
    MAKE_TSTRPTR_FROMWIDE(pszAboutCLSID, wszAboutCLSID);


    // Add the CLSID to the registry.
    setSnapInKeyAndValue(pszCLSID, NULL, _T("NameString"), szNameString) ;

#ifdef STANDALONE
    setSnapInKeyAndValue(pszCLSID, _T("StandAlone"), NULL, NULL);
#endif

    if (IID_NULL != clsidAbout)
        setSnapInKeyAndValue(pszCLSID, NULL, _T("About"), pszAboutCLSID);

    // register each of the node types in _ExtendableNodes as an extendable node
    for (pExtensionNode = &(_ExtendableNodes[0]);*pExtensionNode->szDescription;pExtensionNode++)
    {
        hr = StringFromCLSID(pExtensionNode->GUID, &wszExtendCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszExtendCLSID, wszExtendCLSID);
        setSnapInExtensionNode(pszCLSID, pszExtendCLSID, pExtensionNode->szDescription);
        CoTaskMemFree(wszExtendCLSID);
    }

    // register each of the node extensions
    for (pNodeExtension = &(_NodeExtensions[0]);*pNodeExtension->szDescription;pNodeExtension++)
    {
        hr = StringFromCLSID(pNodeExtension->guidNode, &wszExtendCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszExtendCLSID, wszExtendCLSID);
        _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\NodeTypes\\"));
        _tcscat(szKeyBuf, pszExtendCLSID);

        switch (pNodeExtension->eType) {
        case NameSpaceExtension:
            _tcscat(szKeyBuf, _T("\\Extensions\\NameSpace"));
            break;
        case ContextMenuExtension:
            _tcscat(szKeyBuf, _T("\\Extensions\\ContextMenu"));
            break;
        case ToolBarExtension:
            _tcscat(szKeyBuf, _T("\\Extensions\\ToolBar"));
            break;
        case PropertySheetExtension:
            _tcscat(szKeyBuf, _T("\\Extensions\\PropertySheet"));
            break;
        case TaskExtension:
            _tcscat(szKeyBuf, _T("\\Extensions\\Task"));
            break;
        case DynamicExtension:
            _tcscat(szKeyBuf, _T("\\Dynamic Extensions"));
        default:
            break;
        }

        // Create and open key and subkey.
        long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
            szKeyBuf,
            0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, NULL,
            &hKey, NULL) ;

        if (lResult != ERROR_SUCCESS)
        {
            return FALSE ;
        }

        hr = StringFromCLSID(pNodeExtension->guidExtension, &wszNodeCLSID);
        assert(SUCCEEDED(hr));

        MAKE_TSTRPTR_FROMWIDE(pszNodeCLSID, wszNodeCLSID);
        // Set the Value.
        if (pNodeExtension->szDescription != NULL)
        {
            RegSetValueEx(hKey, pszNodeCLSID, 0, REG_SZ,
                (BYTE *)pNodeExtension->szDescription,
                (_tcslen(pNodeExtension->szDescription)+1)*sizeof(_TCHAR)) ;
        }

        RegCloseKey(hKey) ;

        CoTaskMemFree(wszExtendCLSID);
        CoTaskMemFree(wszNodeCLSID);
    }


    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    if (IID_NULL != clsidAbout)
        CoTaskMemFree(wszAboutCLSID);

    return S_OK ;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    LPOLESTR wszCLSID = NULL;

    // Get CLSID
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\"));
    _tcscat(szKeyBuf, pszCLSID);

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

	//Uncomment following for loop to unregister all extendable node types
	//Note that if a snap-in's extendable node types are unregistered,
	//any extension snap-ins for these node types will have to be re-registered
	//in order to rebuild their entries under the SOFTWARE\Microsoft\MMC\NodeTypes key

/*
    // Unregister each of the node types in _ExtendableNodes as an extendable node
	// Note that this snap-in does not register any extendable node types

    EXTENSION_NODE *pNode;
	LPOLESTR wszExtendCLSID = NULL;

    for (pNode = &(_ExtendableNodes[0]);*pNode->szDescription;pNode++)
    {
        hr = StringFromCLSID(pNode->GUID, &wszExtendCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszExtendCLSID, wszExtendCLSID);

        // Load the buffer with the Snap-In Location
        _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\NodeTypes\\"));
        // Copy keyname into buffer.
        _tcscat(szKeyBuf, pszExtendCLSID);
        recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
        CoTaskMemFree(wszExtendCLSID);
    }

*/

    // free the memory
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }

    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }

    // Close the child.
    RegCloseKey(hKeyChild) ;

    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\")) ;
    _tcscat(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

BOOL setSnapInExtensionNode(const _TCHAR* szSnapID,
                            const _TCHAR* szNodeID,
                            const _TCHAR* szDescription)
{
    HKEY hKey;
    _TCHAR szSnapNodeKeyBuf[1024] ;
    _TCHAR szMMCNodeKeyBuf[1024];

    // Load the buffer with the Snap-In Location
    _tcscpy(szSnapNodeKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns\\"));
    // add in the clisid into buffer.
    _tcscat(szSnapNodeKeyBuf, szSnapID) ;
    _tcscat(szSnapNodeKeyBuf, _T("\\NodeTypes\\"));
    _tcscat(szSnapNodeKeyBuf, szNodeID) ;

    // Load the buffer with the NodeTypes Location
    _tcscpy(szMMCNodeKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\NodeTypes\\"));
    _tcscat(szMMCNodeKeyBuf, szNodeID) ;

    // Create and open the Snapin Key.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szSnapNodeKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szDescription != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szDescription,
            (_tcslen(szDescription)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;

    // Create and open the NodeTypes Key.
    lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szMMCNodeKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szDescription != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szDescription,
            (_tcslen(szDescription)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\proppage\people.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _PEOPLE_H
#define _PEOPLE_H

#include "DeleBase.h"

class CBicycle : public CDelegationBase {
public:
    CBicycle(int i) : id(i) { }
    virtual ~CBicycle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CBicycleFolder : public CDelegationBase {
public:
    CBicycleFolder();
    virtual ~CBicycleFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Bicycles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CSkateboard : public CDelegationBase {
public:
    CSkateboard(int i) : id(i) { }
    virtual ~CSkateboard() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CSkateboardFolder : public CDelegationBase {
public:
    CSkateboardFolder();
    virtual ~CSkateboardFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Skateboards"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CIceSkate : public CDelegationBase {
public:
    CIceSkate(int i) : id(i) { }
    virtual ~CIceSkate() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CIceSkateFolder : public CDelegationBase {
public:
    CIceSkateFolder();
    virtual ~CIceSkateFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Ice Skates"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CPeoplePoweredVehicle : public CDelegationBase {
public:
    CPeoplePoweredVehicle();
    virtual ~CPeoplePoweredVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("People-powered Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { IDM_NEW_PEOPLE = 1 };
    
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 3 };
    CDelegationBase *children[3];
};

#endif // _PEOPLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\proppage\comp.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "DataObj.h"
#include <commctrl.h>        // Needed for button styles...
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "DeleBase.h"
#include "CompData.h"

CComponent::CComponent(CComponentData *parent)
: m_pComponentData(parent), m_cref(0), m_ipConsole(NULL)
{
    OBJECT_CREATED
}

CComponent::~CComponent()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IComponent))
        *ppv = static_cast<IComponent *>(this);

    // first things first, make sure that when MMC
    // asks if we do property sheets, that we actually
    // say "yes"
    else if (IsEqualIID(riid, IID_IExtendPropertySheet))
        *ppv = static_cast<IExtendPropertySheet2 *>(this);
    else if (IsEqualIID(riid, IID_IExtendPropertySheet2))
        *ppv = static_cast<IExtendPropertySheet2 *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponent::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponent::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface IComponent
///////////////////////////////
STDMETHODIMP CComponent::Initialize(
                                    /* [in] */ LPCONSOLE lpConsole)
{
    HRESULT hr = S_OK;

    // Save away all the interfaces we'll need.
    // Fail if we can't QI the required interfaces.

    m_ipConsole = lpConsole;
    m_ipConsole->AddRef();

    return hr;
}

STDMETHODIMP CComponent::Notify(
                                /* [in] */ LPDATAOBJECT lpDataObject,
                                /* [in] */ MMC_NOTIFY_TYPE event,
                                /* [in] */ LPARAM arg,
                                /* [in] */ LPARAM param)
{
        MMCN_Crack(FALSE, lpDataObject, NULL, this, event, arg, param);

    HRESULT hr = S_FALSE;
    CDelegationBase *base = NULL;

    // we need to watch for property change and delegate it
    // a little differently, we're actually going to send
    // the CDelegationBase object pointer in the property page
    // PSN_APPLY handler via MMCPropPageNotify()
    if (MMCN_PROPERTY_CHANGE != event) {
        if (NULL == lpDataObject)
            return S_FALSE;

        base = GetOurDataObject(lpDataObject)->GetBaseNodeObject();
    } else {
        base = (CDelegationBase *)param;
    }

    switch (event)      {
    case MMCN_SHOW:
        hr = base->OnShow(m_ipConsole, (BOOL)arg, (HSCOPEITEM)param);
        break;

    case MMCN_ADD_IMAGES:
        hr = base->OnAddImages((IImageList *)arg, (HSCOPEITEM)param);
        break;

    case MMCN_SELECT:
        hr = base->OnSelect(m_ipConsole, (BOOL)LOWORD(arg), (BOOL)HIWORD(arg));
        break;

    case MMCN_RENAME:
        hr = base->OnRename((LPOLESTR)param);
        break;

    // handle the property change notification if we need to do anything
    // special with it
    case MMCN_PROPERTY_CHANGE:
        hr = base->OnPropertyChange(m_ipConsole);
        break;
    }

    return hr;
}

STDMETHODIMP CComponent::Destroy(
                                 /* [in] */ MMC_COOKIE cookie)
{
    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}


STDMETHODIMP CComponent::QueryDataObject(
                                         /* [in] */ MMC_COOKIE cookie,
                                         /* [in] */ DATA_OBJECT_TYPES type,
                                         /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pComponentData->m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

STDMETHODIMP CComponent::GetResultViewType(
                                           /* [in] */ MMC_COOKIE cookie,
                                           /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
                                           /* [out] */ long __RPC_FAR *pViewOptions)
{
    CDelegationBase *base = (CDelegationBase *)cookie;

    //
    // Ask for default listview.
    //
    if (base == NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
        *ppViewType = NULL;
    }
    else
        return base->GetResultViewType(ppViewType, pViewOptions);

    return S_OK;
}

STDMETHODIMP CComponent::GetDisplayInfo(
                                        /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem)
{
    HRESULT hr = S_OK;
    CDelegationBase *base = NULL;

    // if they are asking for the RDI_STR we have one of those to give

    if (pResultDataItem->lParam) {
        base = (CDelegationBase *)pResultDataItem->lParam;
        if (pResultDataItem->mask & RDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName(pResultDataItem->nCol);
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pResultDataItem->str = pszW;
        }

        if (pResultDataItem->mask & RDI_IMAGE) {
            pResultDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}


STDMETHODIMP CComponent::CompareObjects(
                                        /* [in] */ LPDATAOBJECT lpDataObjectA,
                                        /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////////
// Interface IExtendPropertySheet2
///////////////////////////////////
HRESULT CComponent::CreatePropertyPages(
                                        /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
                                        /* [in] */ LONG_PTR handle,
                                        /* [in] */ LPDATAOBJECT lpIDataObject)
{
    CDelegationBase *base = GetOurDataObject(lpIDataObject)->GetBaseNodeObject();

    return base->CreatePropertyPages(lpProvider, handle);
}

HRESULT CComponent::QueryPagesFor(
                                  /* [in] */ LPDATAOBJECT lpDataObject)
{
    CDelegationBase *base = GetOurDataObject(lpDataObject)->GetBaseNodeObject();

    return base->HasPropertySheets();
}

HRESULT CComponent::GetWatermarks(
                                  /* [in] */ LPDATAOBJECT lpIDataObject,
                                  /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
                                  /* [out] */ HBITMAP __RPC_FAR *lphHeader,
                                  /* [out] */ HPALETTE __RPC_FAR *lphPalette,
                                  /* [out] */ BOOL __RPC_FAR *bStretch)
{
    CDelegationBase *base = GetOurDataObject(lpIDataObject)->GetBaseNodeObject();

    return base->GetWatermarks(lphWatermark, lphHeader, lphPalette, bStretch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\proppage\compdata.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "CompData.h"
#include "DataObj.h"
#include "resource.h"
#include <crtdbg.h>

CComponentData::CComponentData()
: m_cref(0), m_ipConsoleNameSpace(NULL), m_ipConsole(NULL)
{
    OBJECT_CREATED

        m_pStaticNode = new CStaticNode;
}

CComponentData::~CComponentData()
{
    if (m_pStaticNode) {
        delete m_pStaticNode;
    }

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CComponentData::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_IComponentData))
        *ppv = static_cast<IComponentData *>(this);

    // first things first, make sure that when MMC
    // asks if we do property sheets, that we actually
    // say "yes"
    else if (IsEqualIID(riid, IID_IExtendPropertySheet) ||
        IsEqualIID(riid, IID_IExtendPropertySheet2))
        *ppv = static_cast<IExtendPropertySheet2 *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponentData::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponentData::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }

    return m_cref;
}

///////////////////////////////
// Interface IComponentData
///////////////////////////////
HRESULT CComponentData::Initialize(
                                   /* [in] */ LPUNKNOWN pUnknown)
{
    HRESULT      hr;

    //
    // Get pointer to name space interface
    //
    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (void **)&m_ipConsoleNameSpace);
    _ASSERT( S_OK == hr );

    //
    // Get pointer to console interface
    //
    hr = pUnknown->QueryInterface(IID_IConsole, (void **)&m_ipConsole);
    _ASSERT( S_OK == hr );

    IImageList *pImageList;
    m_ipConsole->QueryScopeImageList(&pImageList);
    _ASSERT( S_OK == hr );

    hr = pImageList->ImageListSetStrip( (long *)m_pStaticNode->m_pBMapSm, // pointer to a handle
        (long *)m_pStaticNode->m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );

    pImageList->Release();

    return S_OK;
}

HRESULT CComponentData::CreateComponent(
                                        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent)
{
    *ppComponent = NULL;

    CComponent *pComponent = new CComponent(this);

    if (NULL == pComponent)
        return E_OUTOFMEMORY;

    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent);
}

HRESULT CComponentData::Notify(
                               /* [in] */ LPDATAOBJECT lpDataObject,
                               /* [in] */ MMC_NOTIFY_TYPE event,
                               /* [in] */ LPARAM arg,
                               /* [in] */ LPARAM param)
{
    MMCN_Crack(TRUE, lpDataObject, this, NULL, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)
    {
    case MMCN_EXPAND:
        hr = base->OnExpand(m_ipConsoleNameSpace, m_ipConsole, (HSCOPEITEM)param);
        break;
    }

    return hr;
}

HRESULT CComponentData::Destroy( void)
{
    // Free interfaces
    if (m_ipConsoleNameSpace) {
        m_ipConsoleNameSpace->Release();
        m_ipConsoleNameSpace = NULL;
    }

    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}

HRESULT CComponentData::QueryDataObject(
                                        /* [in] */ MMC_COOKIE cookie,
                                        /* [in] */ DATA_OBJECT_TYPES type,
                                        /* [out] */ LPDATAOBJECT *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

HRESULT CComponentData::GetDisplayInfo(
                                       /* [out][in] */ SCOPEDATAITEM *pScopeDataItem)
{
    HRESULT hr = S_FALSE;

    // if they are asking for the SDI_STR we have one of those to give
    if (pScopeDataItem->lParam) {
        CDelegationBase *base = (CDelegationBase *)pScopeDataItem->lParam;
        if (pScopeDataItem->mask & SDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName();
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pScopeDataItem->displayname = pszW;
        }

        if (pScopeDataItem->mask & SDI_IMAGE) {
            pScopeDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}

HRESULT CComponentData::CompareObjects(
                                       /* [in] */ LPDATAOBJECT lpDataObjectA,
                                       /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////////
// Interface IExtendPropertySheet2
///////////////////////////////////
HRESULT CComponentData::CreatePropertyPages(
                                            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
                                            /* [in] */ LONG_PTR handle,
                                            /* [in] */ LPDATAOBJECT lpIDataObject)
{
    CDelegationBase *base = GetOurDataObject(lpIDataObject)->GetBaseNodeObject();

    return base->CreatePropertyPages(lpProvider, handle);
}

HRESULT CComponentData::QueryPagesFor(
                                      /* [in] */ LPDATAOBJECT lpDataObject)
{
    CDelegationBase *base = GetOurDataObject(lpDataObject)->GetBaseNodeObject();

    return base->HasPropertySheets();
}

HRESULT CComponentData::GetWatermarks(
                                      /* [in] */ LPDATAOBJECT lpIDataObject,
                                      /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
                                      /* [out] */ HBITMAP __RPC_FAR *lphHeader,
                                      /* [out] */ HPALETTE __RPC_FAR *lphPalette,
                                      /* [out] */ BOOL __RPC_FAR *bStretch)
{
    CDelegationBase *base = GetOurDataObject(lpIDataObject)->GetBaseNodeObject();

    return base->GetWatermarks(lphWatermark, lphHeader, lphPalette, bStretch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\proppage\registry.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions = FALSE);

HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\proppage\sky.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Sky.h"

const GUID CSkyBasedVehicle::thisGuid = { 0x2974380f, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSkyBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\proppage\compdata.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMPDATA_H_
#define _SAMPCOMPDATA_H_

#include <mmc.h>
#include "DeleBase.h"
#include "StatNode.h"
#include "Comp.h"

class CComponentData : public IComponentData, IExtendPropertySheet2
{
    friend class CComponent;
    
private:
    ULONG				m_cref;
    LPCONSOLE			m_ipConsole;
    LPCONSOLENAMESPACE	m_ipConsoleNameSpace;
    
    CStaticNode     *m_pStaticNode;
    
public:
    CComponentData();
    ~CComponentData();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IComponentData
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
        /* [in] */ LPUNKNOWN pUnknown);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent( 
        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
        /* [in] */ LPDATAOBJECT lpDataObject,
        /* [in] */ MMC_NOTIFY_TYPE event,
        /* [in] */ LPARAM arg,
        /* [in] */ LPARAM param);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
        /* [in] */ MMC_COOKIE cookie,
        /* [in] */ DATA_OBJECT_TYPES type,
        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
        /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
        /* [in] */ LPDATAOBJECT lpDataObjectA,
        /* [in] */ LPDATAOBJECT lpDataObjectB);
        
        //////////////////////////////////
        // Interface IExtendPropertySheet2
        //////////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
        /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
        /* [in] */ LONG_PTR handle,
        /* [in] */ LPDATAOBJECT lpIDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
        /* [in] */ LPDATAOBJECT lpDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetWatermarks( 
        /* [in] */ LPDATAOBJECT lpIDataObject,
        /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
        /* [out] */ HBITMAP __RPC_FAR *lphHeader,
        /* [out] */ HPALETTE __RPC_FAR *lphPalette,
        /* [out] */ BOOL __RPC_FAR *bStretch);
};

#endif _SAMPCOMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\proppage\sky.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SKY_H
#define _SKY_H

#include "DeleBase.h"

class CSkyBasedVehicle : public CDelegationBase {
public:
    CSkyBasedVehicle() { }
    
    virtual ~CSkyBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Sky-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SKYICON; }
    
private:
    enum { IDM_NEW_SKY = 3 };
    
    // {2974380F-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};


#endif // _SKY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\proppage\guids.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;


// {6C26B387-E3F7-4a7c-BD2A-DD4D596CDE86}
DEFINE_GUID(CLSID_CComponentData, 
0x6c26b387, 0xe3f7, 0x4a7c, 0xbd, 0x2a, 0xdd, 0x4d, 0x59, 0x6c, 0xde, 0x86);


// {9E6D45FD-C65D-4d1e-89A5-81E3A842F3AA}
DEFINE_GUID(CLSID_CSnapinAbout, 
0x9e6d45fd, 0xc65d, 0x4d1e, 0x89, 0xa5, 0x81, 0xe3, 0xa8, 0x42, 0xf3, 0xaa);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\proppage\delebase.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _BRANCHES_H
#define _BRANCHES_H

#include <mmc.h>
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "LocalRes.h"

class CDelegationBase {
public:
    CDelegationBase();
    virtual ~CDelegationBase();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) = 0;
    virtual const GUID & getNodeType() { _ASSERT(FALSE); return IID_NULL; }
    
    virtual const LPARAM GetCookie() { return reinterpret_cast<LPARAM>(this); }
    virtual const int GetBitmapIndex() = 0;
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions) { return S_FALSE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent) { return S_FALSE; }
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem) { return S_FALSE; }
    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    virtual HRESULT OnRename(LPOLESTR pszNewName) { return S_FALSE; }
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect) { return S_FALSE; }
    
    virtual HRESULT CreatePropertyPages(IPropertySheetCallback *lpProvider,
        LONG_PTR handle) { return S_FALSE; }
    virtual HRESULT HasPropertySheets() { return S_FALSE; }
    virtual HRESULT GetWatermarks(HBITMAP *lphWatermark,
        HBITMAP *lphHeader,
        HPALETTE *lphPalette,
        BOOL *bStretch) { return S_FALSE; }
    
    virtual HRESULT OnPropertyChange(IConsole *pConsole) { return S_OK; }
    
public:
    static HBITMAP m_pBMapSm;
    static HBITMAP m_pBMapLg;
    
protected:
    static void LoadBitmaps() {
        m_pBMapSm = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_SMICONS));
        m_pBMapLg = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_LGICONS));
    }
    
    BOOL bExpanded;
    
private:
    // {2974380B-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _BRANCHES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\proppage\people.cpp ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#include <stdio.h>
#include "People.h"

const GUID CPeoplePoweredVehicle::thisGuid = { 0x2974380d, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

const GUID CBicycleFolder::thisGuid = { 0xef163732, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboardFolder::thisGuid = { 0xef163733, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkateFolder::thisGuid = { 0xf6c660b0, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };

const GUID CBicycle::thisGuid = { 0xef163734, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboard::thisGuid = { 0xef163735, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkate::thisGuid = { 0xf6c660b1, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };


//==============================================================
//
// CPeoplePoweredVehicle implementation
//
//
CPeoplePoweredVehicle::CPeoplePoweredVehicle()
{
    children[0] = new CBicycleFolder;
    children[1] = new CSkateboardFolder;
    children[2] = new CIceSkateFolder;
}

CPeoplePoweredVehicle::~CPeoplePoweredVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        delete children[n];
}

HRESULT CPeoplePoweredVehicle::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;

    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT    |   // relativeID is valid
                SDI_CHILDREN;     // cChildren is valid

            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = 0;

            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );

            _ASSERT( SUCCEEDED(hr) );
        }
    }

    return S_OK;
}

CBicycleFolder::CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CBicycle(n + 1);
    }
}

CBicycleFolder::~CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CBicycleFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

CIceSkateFolder::CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CIceSkate(n + 1);
    }
}

CIceSkateFolder::~CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CIceSkateFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

CSkateboardFolder::CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CSkateboard(n + 1);
    }
}

CSkateboardFolder::~CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSkateboardFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                      ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

const _TCHAR *CBicycle::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Bicycle #%d"), id);

    return buf;
}

const _TCHAR *CSkateboard::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Skateboard #%d"), id);

    return buf;
}

const _TCHAR *CIceSkate::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Ice Skate #%d"), id);

    return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\proppage\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Resources.rc
//
#define IDS_HELPFILE                    1
#define IDS_SNAPINDESC                  2
#define IDI_PSI_LANDBASED               2
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDS_PST_ROCKET                  10
#define IDS_PST_LANDBASED               11
#define IDD_PROPPAGE_LARGE              107
#define IDI_ICON1                       108
#define IDB_SMOPEN                      111
#define IDB_SMBMP                       112
#define IDB_LGBMP                       113
#define IDI_PSI_ROCKET                  114
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDC_ROCKET_NAME                 1000
#define IDC_ROCKET_HEIGHT               1001
#define IDC_ROCKET_WEIGHT               1002
#define IDC_ROCKET_PAYLOAD              1003
#define IDC_ROCKET_STATUS               1005
#define IDB_ROCKET                      40004
#define IDB_CAR                         40005
#define IDB_PLANE                       40006
#define IDB_BIKE                        40007
#define IDB_ROCKET2                     40008
#define IDB_CAR2                        40009
#define IDB_PLANE2                      40010
#define IDB_BIKE2                       40011
#define IDB_CLOSED2                     40012
#define IDB_OPEN2                       40013
#define IDB_CLOSED                      40014
#define IDB_OPEN                        40015

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        116
#define _APS_NEXT_COMMAND_VALUE         40016
#define _APS_NEXT_CONTROL_VALUE         1008
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\proppage\registry.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

#define STRINGS_ONLY
#include "globals.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName)       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule,
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;

    assert(dwResult != 0) ;

    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    assert(SUCCEEDED(hr)) ;

        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;
        _tcscat(szKey, pszCLSID) ;

    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;

    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    _tcscat(szKey, _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), _T("Apartment"));

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;


    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;

        MAKE_TSTRPTR_FROMWIDE(pszT, wszCLSID);
        _tcscat(szKey, pszT) ;

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Register the snap-in in the registry.
//
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,         // Class Id for About Class
                       const BOOL fSupportExtensions)
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    LPOLESTR wszAboutCLSID = NULL;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    if (IID_NULL != clsidAbout)
        hr = StringFromCLSID(clsidAbout, &wszAboutCLSID);

        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszAboutCLSID, wszAboutCLSID);


    // Add the CLSID to the registry.
    setSnapInKeyAndValue(pszCLSID, NULL, _T("NameString"), szNameString) ;
    setSnapInKeyAndValue(pszCLSID, _T("StandAlone"), NULL, NULL);
    if (IID_NULL != clsidAbout)
        setSnapInKeyAndValue(pszCLSID, NULL, _T("About"), pszAboutCLSID);

    if (fSupportExtensions) {
        // Build the key NodeType
        setSnapInKeyAndValue(pszCLSID, _T("NodeTypes"), NULL, NULL);

        _TCHAR szKey[64] ;
        _tcscpy(szKey, pszCLSID) ;
        _tcscat(szKey, _T("\\NodeTypes")) ;
        setSnapInKeyAndValue(szKey, pszCLSID, NULL, NULL);
    }

    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    if (IID_NULL != clsidAbout)
        CoTaskMemFree(wszAboutCLSID);

    return S_OK ;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    LPOLESTR wszCLSID = NULL;

    // Get CLSID
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\"));
    _tcscat(szKeyBuf, pszCLSID);

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // free the memory
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }

    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }

    // Close the child.
    RegCloseKey(hKeyChild) ;

    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\")) ;
    _tcscat(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\proppage\statnode.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SNAPINBASE_H
#define _SNAPINBASE_H

#include "DeleBase.h"

class CStaticNode : public CDelegationBase {
public:
    CStaticNode();
    
    virtual ~CStaticNode();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { 
        static _TCHAR szDisplayName[256];
        LoadString(g_hinst, IDS_SNAPINNAME, szDisplayName, sizeof(szDisplayName));
        return szDisplayName; 
    }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_NONE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
    
    // {2974380C-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};



#endif // _SNAPINBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\proppage\space.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SPACE_H
#define _SPACE_H

#include "DeleBase.h"

class CRocket : public CDelegationBase {
public:
    CRocket(_TCHAR *szName, int id, LONG lWeight, LONG lHeight, LONG lPayload);
    virtual ~CRocket();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnRename(LPOLESTR pszNewName);
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect);
    
    virtual HRESULT CreatePropertyPages(IPropertySheetCallback *lpProvider, LONG_PTR handle);
    virtual HRESULT HasPropertySheets();
    virtual HRESULT GetWatermarks(HBITMAP *lphWatermark,
        HBITMAP *lphHeader,
        HPALETTE *lphPalette,
        BOOL *bStretch);
    
    virtual HRESULT OnPropertyChange(IConsole *pConsole);
    
private:
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    _TCHAR *szName;
    LONG   lWeight;
    LONG   lHeight;
    LONG   lPayload;
    int    nId;
    enum ROCKET_STATUS {RUNNING, PAUSED, STOPPED} iStatus;
    
    LONG_PTR m_ppHandle;
    
    static BOOL CALLBACK DialogProc(
        HWND hwndDlg,  // handle to dialog box
        UINT uMsg,     // message
        WPARAM wParam, // first message parameter
        LPARAM lParam  // second message parameter
        );
    
};

class CSpaceVehicle : public CDelegationBase {
public:
    CSpaceVehicle();
    
    virtual ~CSpaceVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Future Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    enum { IDM_NEW_SPACE = 4 };
    
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CRocket *children[NUMBER_OF_CHILDREN];
};

#endif // _SPACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\proppage\statnode.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "StatNode.h"

#include "Space.h"
#include "Sky.h"
#include "People.h"
#include "Land.h"

const GUID CStaticNode::thisGuid = { 0x2974380c, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CStaticNode implementation
//
//
CStaticNode::CStaticNode()
{
    children[0] = new CPeoplePoweredVehicle;
    children[1] = new CLandBasedVehicle;
    children[2] = new CSkyBasedVehicle;
    children[3] = new CSpaceVehicle;
}

CStaticNode::~CStaticNode()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CStaticNode::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;
    
    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT	  |
                SDI_CHILDREN;
            
            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = (n == 0); // only the first child has children
            
            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );
            
            _ASSERT( SUCCEEDED(hr) );
        }
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\proppage\space.cpp ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#include <stdio.h>
#include <windows.h>
#include "Space.h"
#include "Comp.h"
#include "resource.h"

const GUID CSpaceVehicle::thisGuid = { 0x29743810, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };
const GUID CRocket::thisGuid = { 0x29743811, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSpaceVehicle implementation
//
//
CSpaceVehicle::CSpaceVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CRocket(_T("Rocket"), n+1, 500000, 265, 75000);
    }
}

CSpaceVehicle::~CSpaceVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSpaceVehicle::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Rocket Class", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 1, L"Rocket Weight", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 2, L"Rocket Height", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 3, L"Rocket Payload", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 4, L"Status", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

//==============================================================
//
// CRocket implementation
//
//
CRocket::CRocket(_TCHAR *szName, int id, LONG lWeight, LONG lHeight, LONG lPayload)
: szName(NULL), lWeight(0), lHeight(0), lPayload(0), iStatus(STOPPED)
{
    if (szName) {
        this->szName = new _TCHAR[(_tcslen(szName) + 1) * sizeof(_TCHAR)];
        _tcscpy(this->szName, szName);
    }

    this->nId = id;
    this->lWeight = lWeight;
    this->lHeight = lHeight;
    this->lPayload = lPayload;

    m_ppHandle = 0;
}

CRocket::~CRocket()
{
    if (szName)
        delete [] szName;
}

const _TCHAR *CRocket::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    switch (nCol) {
    case 0:
        _stprintf(buf, _T("%s (#%d)"), szName ? szName : _T(""), nId);
        break;

    case 1:
        _stprintf(buf, _T("%ld metric tons"), lWeight);
        break;

    case 2:
        _stprintf(buf, _T("%ld meters"), lHeight);
        break;

    case 3:
        _stprintf(buf, _T("%ld kilos"), lPayload);
        break;

    case 4:
        _stprintf(buf, _T("%s"),
            iStatus == RUNNING ? _T("running") :
        iStatus == PAUSED ? _T("paused") :
        iStatus == STOPPED ? _T("stopped") : _T("unknown"));
        break;

    }

    return buf;
}

HRESULT CRocket::OnRename(LPOLESTR pszNewName)
{
    if (szName) {
        delete [] szName;
        szName = NULL;
    }

    MAKE_TSTRPTR_FROMWIDE(ptrname, pszNewName);
    szName = new _TCHAR[(_tcslen(ptrname) + 1) * sizeof(_TCHAR)];
    _tcscpy(szName, ptrname);

    return S_OK;
}

// handle anything special when the user clicks Apply or Ok
// on the property sheet.  This sample directly accesses the
// operated-on object, so there's nothing special to do when the user presses Ok.
// when the user presses Apply, we update the currently selected result item
HRESULT CRocket::OnPropertyChange(IConsole *pConsole)
{

    //redraw the item 
    IResultData *pResultData = NULL;

	HRESULT hr;

	hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
	_ASSERT( SUCCEEDED(hr) );	

	HRESULTITEM myhresultitem;	
	
	//lparam == this. See CSpaceVehicle::OnShow
	hr = pResultData->FindItemByLParam( (LPARAM)this, &myhresultitem );
	_ASSERT( SUCCEEDED(hr) ); 

	hr = pResultData->UpdateItem( myhresultitem );     
	_ASSERT( SUCCEEDED(hr) );    
	
    pResultData->Release();
	
	
	return S_OK;
}

HRESULT CRocket::OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect)
{
    IConsoleVerb *pConsoleVerb;

    HRESULT hr = pConsole->QueryConsoleVerb(&pConsoleVerb);
    _ASSERT(SUCCEEDED(hr));

    hr = pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, TRUE);

    // can't get to properties (via the standard methods) unless
    // we tell MMC to display the Properties menu item and
    // toolbar button, this wil give the user a visual cue that
    // there's "something" to do
    hr = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

    pConsoleVerb->Release();

    return S_OK;
}

// Implement the dialog proc
BOOL CALLBACK CRocket::DialogProc(
                                  HWND hwndDlg,  // handle to dialog box
                                  UINT uMsg,     // message
                                  WPARAM wParam, // first message parameter
                                  LPARAM lParam  // second message parameter
                                  )
{
    static CRocket *pRocket = NULL;

    switch (uMsg) {
    case WM_INITDIALOG:
        // catch the "this" pointer so we can actually operate on the object
        pRocket = reinterpret_cast<CRocket *>(reinterpret_cast<PROPSHEETPAGE *>(lParam)->lParam);

        SetDlgItemText(hwndDlg, IDC_ROCKET_NAME, pRocket->szName);
        SetDlgItemInt(hwndDlg, IDC_ROCKET_HEIGHT, pRocket->lHeight, FALSE);
        SetDlgItemInt(hwndDlg, IDC_ROCKET_WEIGHT, pRocket->lWeight, FALSE);
        SetDlgItemInt(hwndDlg, IDC_ROCKET_PAYLOAD, pRocket->lPayload, FALSE);

        _ASSERT( CB_ERR != SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_INSERTSTRING, 0, (LPARAM)_T("Running")) );
        _ASSERT( CB_ERR != SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_INSERTSTRING, 1, (LPARAM)_T("Paused")) );
        _ASSERT( CB_ERR != SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_INSERTSTRING, 2, (LPARAM)_T("Stopped")) );

        SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_SETCURSEL, (WPARAM)pRocket->iStatus, 0);

        break;

    case WM_COMMAND:
        // turn the Apply button on
        if (HIWORD(wParam) == EN_CHANGE ||
            HIWORD(wParam) == CBN_SELCHANGE)
            SendMessage(GetParent(hwndDlg), PSM_CHANGED, (WPARAM)hwndDlg, 0);
        break;

    case WM_DESTROY:
        // tell MMC that we're done with the property sheet (we got this
        // handle in CreatePropertyPages
        MMCFreeNotifyHandle(pRocket->m_ppHandle);
        break;

    case WM_NOTIFY:
        switch (((NMHDR *) lParam)->code) {
        case PSN_APPLY:
            // update the information
            if (pRocket->szName) {
                delete [] pRocket->szName;
                pRocket->szName = NULL;
            }

            {
                int n = SendDlgItemMessage(hwndDlg, IDC_ROCKET_NAME, WM_GETTEXTLENGTH, 0, 0);
                if (n != 0) {
                    pRocket->szName = new _TCHAR[n + 1];
                    GetDlgItemText(hwndDlg, IDC_ROCKET_NAME, pRocket->szName, n + 1);
                }
            }
            pRocket->lHeight = GetDlgItemInt(hwndDlg, IDC_ROCKET_HEIGHT, NULL, FALSE);
            pRocket->lWeight = GetDlgItemInt(hwndDlg, IDC_ROCKET_WEIGHT, NULL, FALSE);
            pRocket->lPayload = GetDlgItemInt(hwndDlg, IDC_ROCKET_PAYLOAD, NULL, FALSE);

            pRocket->iStatus = (ROCKET_STATUS)SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_GETCURSEL, 0, 0);

            // ask MMC to send us a message (on the main thread) so
            // we know the Apply button was clicked.
            HRESULT hr = MMCPropertyChangeNotify(pRocket->m_ppHandle, (long)pRocket);

            _ASSERT(SUCCEEDED(hr));

            return PSNRET_NOERROR;
        }
        break;
    }

    return DefWindowProc(hwndDlg, uMsg, wParam, lParam);
}


HRESULT CRocket::HasPropertySheets()
{
    // say "yes" when MMC asks if we have pages
    return S_OK;
}

HRESULT CRocket::CreatePropertyPages(IPropertySheetCallback *lpProvider, LONG_PTR handle)
{
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage = NULL;

    // cache this handle so we can call MMCPropertyChangeNotify
    m_ppHandle = handle;

    // create the property page for this node.
    // NOTE: if your node has multiple pages, put the following
    // in a loop and create multiple pages calling
    // lpProvider->AddPage() for each page.
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEICONID;
    psp.hInstance = g_hinst;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROPPAGE_LARGE);
    psp.pfnDlgProc = DialogProc;
    psp.lParam = reinterpret_cast<LPARAM>(this);
    psp.pszTitle = MAKEINTRESOURCE(IDS_PST_ROCKET);
    psp.pszIcon = MAKEINTRESOURCE(IDI_PSI_ROCKET);


    hPage = CreatePropertySheetPage(&psp);
    _ASSERT(hPage);

    return lpProvider->AddPage(hPage);
}

HRESULT CRocket::GetWatermarks(HBITMAP *lphWatermark,
                               HBITMAP *lphHeader,
                               HPALETTE *lphPalette,
                               BOOL *bStretch)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\simple\dataobj.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPDATAOBJECT_H_
#define _SAMPDATAOBJECT_H_

#include <mmc.h>
#include "DeleBase.h"

class CDataObject : public IDataObject
{
private:
    ULONG				m_cref;
    MMC_COOKIE			m_lCookie;
    DATA_OBJECT_TYPES   m_context;
    
public:
    CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context);
    ~CDataObject();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // IDataObject methods 
    ///////////////////////////////
    STDMETHODIMP GetDataHere (FORMATETC *pformatetc, STGMEDIUM *pmedium);
    
    // The rest are not implemented
    STDMETHODIMP GetData (LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumFormatEtc (DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };
    
    STDMETHODIMP QueryGetData (LPFORMATETC lpFormatetc) 
    { return E_NOTIMPL; };
    
    STDMETHODIMP GetCanonicalFormatEtc (LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    
    STDMETHODIMP SetData (LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DAdvise (LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DUnadvise (DWORD dwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumDAdvise (LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };
    
    ///////////////////////////////
    // Custom Methods
    ///////////////////////////////
    
    CDelegationBase *GetBaseNodeObject() {
        return (CDelegationBase *)m_lCookie;
    }
    
    DATA_OBJECT_TYPES GetContext() {
        return m_context;
    }
    
public:
    // clipboard formats
    static UINT s_cfSZNodeType;
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
    static UINT s_cfInternal;
    
};

HRESULT ExtractFromDataObject(IDataObject *lpDataObject,UINT cf,ULONG cb,HGLOBAL *phGlobal);
CDataObject* GetOurDataObject(IDataObject *lpDataObject);
BOOL IsMMCMultiSelectDataObject(IDataObject *lpDataObject);

#endif _SAMPDATAOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\simple\dataobj.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DataObj.h"
#include "guids.h"
#include "DeleBase.h"

//
// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SZNODETYPE _T("CCF_SZNODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

#define _T_CCF_INTERNAL_SNAPIN _T("{2479DB32-5276-11d2-94F5-00C04FB92EC2}")

    // These are the clipboard formats that we must supply at a minimum.
    // mmc.h actually defined these. We can make up our own to use for
    // other reasons. We don't need any others at this time.
UINT CDataObject::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CDataObject::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CDataObject::s_cfSZNodeType  = RegisterClipboardFormat(_T_CCF_SZNODETYPE);
UINT CDataObject::s_cfSnapinClsid = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);
UINT CDataObject::s_cfInternal    = RegisterClipboardFormat(_T_CCF_INTERNAL_SNAPIN);


CDataObject::CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context)
: m_lCookie(cookie), m_context(context), m_cref(0)
{
}

CDataObject::~CDataObject()
{
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IDataObject *>(this);
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppv = static_cast<IDataObject *>(this);
    
    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CDataObject::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
    
}

/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
// 
HRESULT CDataObject::GetDataHere(
                                 FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure 
                                 STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure  
                                 )
{
    const   CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pStream = NULL;
    
    CDelegationBase *base = GetBaseNodeObject();
    
    HRESULT hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( FAILED(hr) )
        return hr;                       // Minimal error checking
    
    hr = DV_E_FORMATETC;                 // Unknown format

    if (cf == s_cfDisplayName) {
        const _TCHAR *pszName = base->GetDisplayName();

		MAKE_WIDEPTR_FROMTSTR(wszName, pszName);
        
		// get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(pszName);
        ulSizeofName++;                      // Count null character
        ulSizeofName *= sizeof(WCHAR);
        
        hr = pStream->Write(wszName, ulSizeofName, NULL);
    } else if (cf == s_cfNodeType) {
        const GUID *pGUID = (const GUID *)&base->getNodeType();
        
        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfSZNodeType) {
        LPOLESTR szGuid;
        hr = StringFromCLSID(base->getNodeType(), &szGuid);
        
        if (SUCCEEDED(hr)) {
            hr = pStream->Write(szGuid, wcslen(szGuid), NULL);
            CoTaskMemFree(szGuid);
        }
    } else if (cf == s_cfSnapinClsid) {
        const GUID *pGUID = NULL;
        pGUID = &CLSID_CComponentData;
        
        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfInternal) {
        // we are being asked to get our this pointer from the IDataObject interface
        // only our own snap-in objects will know how to do this.
        CDataObject *pThis = this;
        hr = pStream->Write( &pThis, sizeof(CDataObject*), NULL );
    }
    
    pStream->Release();
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Global helper functions to help work with dataobjects and
// clipboard formats


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfInternal clipboard format
// 
CDataObject* GetOurDataObject (
                               LPDATAOBJECT lpDataObject      // [in] IComponent pointer 
                               )
{
    HRESULT       hr      = S_OK;
    CDataObject *pSDO     = NULL;

	// check to see if the data object is a special data object.
	if ( IS_SPECIAL_DATAOBJECT (lpDataObject) )
	{
		//Code for handling a special data object goes here.

		//Note that the MMC SDK samples do not handle
		//special data objects, so we exit if we get one.
		return NULL;
	}
    
    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { CDataObject::s_cfInternal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    
    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(CDataObject *));
    
    if (!stgmedium.hGlobal)	{
        hr = E_OUTOFMEMORY;
    }
    
    if SUCCEEDED(hr)
        // Attempt to get data from the object
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );
    
    // stgmedium now has the data we need 
    if (SUCCEEDED(hr))  {
        pSDO = *(CDataObject **)(stgmedium.hGlobal);
    }
    
    // if we have memory free it
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);
    
    return pSDO;
    
} // end GetOurDataObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\simple\basesnap.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <initguid.h>
#include "guids.h"
#include "basesnap.h"
#include "Comp.h"
#include "CompData.h"
#include "Registry.h"

// our globals
HINSTANCE g_hinst;

BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    if (rclsid != CLSID_CComponentData)
        return CLASS_E_CLASSNOTAVAILABLE;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = new CClassFactory();
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}

CClassFactory::CClassFactory()
: m_cref(0)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    pObj = new CComponentData();
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    
    if (FAILED(hr))
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName));
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, sizeof(szSnapInName));
    
    if (RegisterServer(g_hinst, 
        CLSID_CComponentData, 
        szName) == S_OK)
        return RegisterSnapin(CLSID_CComponentData, szSnapInName, IID_NULL, FALSE);
    else
        return E_FAIL;
}


STDAPI DllUnregisterServer()
{
    if (UnregisterServer(CLSID_CComponentData) == S_OK)
        return UnregisterSnapin(CLSID_CComponentData);
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\simple\basesnap.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#ifndef _BASESNAP_H_
#define _BASESNAP_H_

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);
STDAPI DllCanUnloadNow(void);

ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    CClassFactory();
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
};

#endif _BASESNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\simple\delebase.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _BRANCHES_H
#define _BRANCHES_H

#include <mmc.h>
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "LocalRes.h"

class CDelegationBase {
public:
    CDelegationBase();
    virtual ~CDelegationBase();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) = 0;
    virtual const GUID & getNodeType() { _ASSERT(FALSE); return IID_NULL; }
    
    virtual const LPARAM GetCookie() { return reinterpret_cast<LPARAM>(this); }
    virtual const int GetBitmapIndex() = 0;
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions) { return S_FALSE; }
    
public:
    // virtual functions go here (for MMCN_*)
    
private:
    // {2974380B-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _BRANCHES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\simple\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>

#ifndef STRINGS_ONLY
	#define IDM_BUTTON1    0x100
	#define IDM_BUTTON2    0x101

	extern HINSTANCE g_hinst;
	extern ULONG g_uObjects;

	#define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
	#define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

	// uncomment the following #define to enable message cracking
	// #define MMC_CRACK_MESSAGES
	void MMCN_Crack(BOOL bComponentData, 
					IDataObject *pDataObject, 
					IComponentData *pCompData,
					IComponent *pComp,
					MMC_NOTIFY_TYPE event, 
					LPARAM arg, 
					LPARAM param);
#endif

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(GetProcessHeap(), 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(GetProcessHeap(), 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given a _TCHAR, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszT;
//  pszT = MyGetTStringRoutine();
//  MAKE_WIDEPTR_FROMSTR(pwsz, pszT);
//  MyUseWideStringRoutine(pwsz);
//  ...
#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPWSTR)__TempBuffer##ptrname.GetBuffer(), tstr); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    lstrcpyW((LPWSTR)ptrname, tstr)
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, ptrname, __l##ptrname)
#endif

//
// similarily for MAKE_TSTRPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
// * 2 for DBCS handling in below length computation
//
#ifdef UNICODE
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPTSTR)__TempBuffer##ptrname.GetBuffer(), widestr); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\simple\comp.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "DataObj.h"
#include <commctrl.h>        // Needed for button styles...
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "DeleBase.h"
#include "CompData.h"

CComponent::CComponent(CComponentData *parent)
: m_pComponentData(parent), m_cref(0), m_ipConsole(NULL)
{
    OBJECT_CREATED
}

CComponent::~CComponent()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IComponent))
        *ppv = static_cast<IComponent *>(this);
    
    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponent::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponent::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
    
}

///////////////////////////////
// Interface IComponent
///////////////////////////////
STDMETHODIMP CComponent::Initialize( 
                                    /* [in] */ LPCONSOLE lpConsole)
{
    HRESULT hr = S_OK;
    
    m_ipConsole = lpConsole;
    m_ipConsole->AddRef();
    
    return hr;
}

STDMETHODIMP CComponent::Notify( 
                                /* [in] */ LPDATAOBJECT lpDataObject,
                                /* [in] */ MMC_NOTIFY_TYPE event,
                                /* [in] */ LPARAM arg,
                                /* [in] */ LPARAM param)
{
	MMCN_Crack(FALSE, lpDataObject, NULL, this, event, arg, param);

    return S_FALSE;
}

STDMETHODIMP CComponent::Destroy( 
                                 /* [in] */ MMC_COOKIE cookie)
{
    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }
    
    return S_OK;
}

STDMETHODIMP CComponent::QueryDataObject( 
                                         /* [in] */ MMC_COOKIE cookie,
                                         /* [in] */ DATA_OBJECT_TYPES type,
                                         /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject)
{
    CDataObject *pObj = NULL;
    
    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pComponentData->m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);
    
    return S_OK;
}

STDMETHODIMP CComponent::GetResultViewType( 
                                           /* [in] */ MMC_COOKIE cookie,
                                           /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
                                           /* [out] */ long __RPC_FAR *pViewOptions)
{
    CDelegationBase *base = (CDelegationBase *)cookie;
    
    //
    // Ask for default listview.
    //
    if (base == NULL) {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
        *ppViewType = NULL;
    }
    else
        return base->GetResultViewType(ppViewType, pViewOptions);
    
    return S_OK;
}

STDMETHODIMP CComponent::GetDisplayInfo( 
                                        /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem)
{
    HRESULT hr = S_OK;
    CDelegationBase *base = NULL;

    // if they are asking for the RDI_STR we have one of those to give

    if (pResultDataItem->lParam) {
        base = (CDelegationBase *)pResultDataItem->lParam;
        if (pResultDataItem->mask & RDI_STR) {
			LPCTSTR pszT = base->GetDisplayName(pResultDataItem->nCol);
			MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pResultDataItem->str = pszW;
        }

        if (pResultDataItem->mask & RDI_IMAGE) {
            pResultDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}

STDMETHODIMP CComponent::CompareObjects( 
                                        /* [in] */ LPDATAOBJECT lpDataObjectA,
                                        /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();
    
    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;
    
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\simple\mmccrack.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

static TCHAR *MMCN_CrackVerb(MMC_CONSOLE_VERB verb)
{
	static TCHAR error[64];

	switch (verb) {
    case MMC_VERB_NONE:
		return _T("NONE");
    case MMC_VERB_OPEN:
		return _T("OPEN");
    case MMC_VERB_COPY:
		return _T("COPY");
    case MMC_VERB_PASTE:
		return _T("PASTE");
    case MMC_VERB_DELETE:
		return _T("DELETE");
    case MMC_VERB_PROPERTIES:
		return _T("PROPERTIES");
    case MMC_VERB_RENAME:
		return _T("RENAME");
    case MMC_VERB_REFRESH:
		return _T("REFRESH");
    case MMC_VERB_PRINT:
		return _T("PRINT");
    case MMC_VERB_CUT:
		return _T("CUT");
	default:
		wsprintf(error, _T("Unknown verb id %d"), verb);
		return error;
	}
}

void MMCN_Crack(BOOL bComponentData, 
                IDataObject *pDataObject,
				IComponentData *pCompData,
				IComponent *pComp,
                MMC_NOTIFY_TYPE event, 
				LPARAM arg, 
				LPARAM param)
{
#ifdef MMC_CRACK_MESSAGES
	TCHAR message[256] = {0};

	if (bComponentData == TRUE)
		OutputDebugString(_T("IComponentData::Notify( "));
	else
		OutputDebugString(_T("IComponent::Notify( "));

	wsprintf(message, _T("DataObject: %08x, CompData: %08x, Comp: %08x ) - "), pDataObject, pCompData, pComp);
	OutputDebugString(message);

    switch (event)	{
		case MMCN_ACTIVATE:
			wsprintf(message, _T("MMCN_ACTIVATE\n\tActivate: %d\n"), arg);
			break;

		case MMCN_ADD_IMAGES:
			wsprintf(message, _T("MMCN_ADD_IMAGES\n\tImage List: %08x\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_BTN_CLICK:
			wsprintf(message, _T("MMCN_BTN_CLICK\n\tVerb: %ws\n"), MMCN_CrackVerb((MMC_CONSOLE_VERB)param));
			break;

		case MMCN_COLUMN_CLICK:
			wsprintf(message, _T("MMCN_COLUMN_CLICK\n\tColumn: %d\n\tSort Option: %d\n"), arg,	 param);
			break;

		case MMCN_COLUMNS_CHANGED:
			wsprintf(message, _T("MMCN_COLUMNS_CHANGED\n"));
			break;

		case MMCN_CONTEXTHELP:
			wsprintf(message, _T("MMCN_CONTEXTHELP\n"));
			break;

		case MMCN_CONTEXTMENU:
			wsprintf(message, _T("MMCN_CONTEXTMENU\n"));
			break;

		case MMCN_CUTORMOVE:
			wsprintf(message, _T("MMCN_CUTORMOVE\n"));
			break;

		case MMCN_DBLCLICK:
			wsprintf(message, _T("MMCN_DBLCLICK\n"));
			break;

		case MMCN_DELETE:
			wsprintf(message, _T("MMCN_DELETE\n"));
			break;

		case MMCN_DESELECT_ALL:
			wsprintf(message, _T("MMCN_DESELECT_ALL\n"));
			break;

		case MMCN_EXPAND:
			wsprintf(message, _T("MMCN_EXPAND\n\tExpand: %d\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_EXPANDSYNC:
			wsprintf(message, _T("MMCN_EXPANDSYNC\n"));
			break;

		case MMCN_FILTERBTN_CLICK:
			wsprintf(message, _T("MMCN_FILTERBTN_CLICK\n\tColumn: %d\n"), arg);
			break;

		case MMCN_FILTER_CHANGE:
			wsprintf(message, _T("MMCN_FILTER_CHANGE\n\tColumn: %d\n"), param);
			break;

		case MMCN_HELP:
			wsprintf(message, _T("MMCN_HELP\n"));
			break;

		case MMCN_INITOCX:
			wsprintf(message, _T("MMCN_INITOCX\n\tIUnknown: %08x\n"), param);
			break;

		case MMCN_LISTPAD:
			wsprintf(message, _T("MMCN_LISTPAD\n\tConnect: %d\n"), arg);
			break;

		case MMCN_MENU_BTNCLICK:
			wsprintf(message, _T("MMCN_MENU_BTNCLICK\n"));
			break;

		case MMCN_MINIMIZED:
			wsprintf(message, _T("MMCN_MINIMIZED\n\tMinimized: %d\n"), arg);
			break;

		case MMCN_PASTE:
			wsprintf(message, _T("MMCN_PASTE\n\tCopy: %d\n"), param == NULL);
			break;

		case MMCN_PRELOAD:
			wsprintf(message, _T("MMCN_PRELOAD\n\tScope Item: %08x\n"), arg);
			break;

		case MMCN_PRINT:
			wsprintf(message, _T("MMCN_PRINT\n"));
			break;

		case MMCN_PROPERTY_CHANGE:
			wsprintf(message, _T("MMCN_PROPERTY_CHANGE\n\tScope: %d\n\tArg: %08x\n"), arg, param);
			break;

		case MMCN_QUERY_PASTE:
			wsprintf(message, _T("MMCN_QUERY_PASTE\n"));
			break;

		case MMCN_REFRESH:
			wsprintf(message, _T("MMCN_REFRESH\n"));
			break;

		case MMCN_REMOVE_CHILDREN:
			wsprintf(message, _T("MMCN_REMOVE_CHILDREN\n\tScope Item: %08x\n"), arg);
			break;

		case MMCN_RENAME:
			wsprintf(message, _T("MMCN_RENAME\n\tNew Name: '%ws'\n"), (LPOLESTR)param);
			break;

		case MMCN_RESTORE_VIEW:
			wsprintf(message, _T("MMCN_RESTORE_VIEW\n"));
			break;

		case MMCN_SELECT:
			wsprintf(message, _T("MMCN_SELECT\n\tScope: %d\n\tSelect: %08x\n"), LOWORD(arg), HIWORD(arg));
			break;

		case MMCN_SHOW:
			wsprintf(message, _T("MMCN_SHOW\n\tShow: %d\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_SNAPINHELP:
			wsprintf(message, _T("MMCN_SNAPINHELP\n"));
			break;

		case MMCN_VIEW_CHANGE:
			wsprintf(message, _T("MMCN_VIEW_CHANGE\n\tData: %08x\n\tHint: %08x\n"), arg, param);
			break;
	}

	if (message[0] != 0)
		OutputDebugString(message);
	else
		OutputDebugString(_T("unknown event\n"));

#endif
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\simple\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5

#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\simple\comp.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMP_H_
#define _SAMPCOMP_H_

#include <mmc.h>

class CComponent : public IComponent
{
private:
    ULONG				m_cref;
    
    IConsole*			m_ipConsole;
    
    class CComponentData *m_pComponentData;
    
    public:
        CComponent(CComponentData *parent);
        ~CComponent();
        
        ///////////////////////////////
        // Interface IUnknown
        ///////////////////////////////
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        
        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ MMC_COOKIE cookie);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);
};

#endif _SAMPCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\simple\registry.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions = FALSE);

HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\simple\delebase.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DeleBase.h"

const GUID CDelegationBase::thisGuid = { 0x2974380b, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CDelegationBase implementation
//
//
CDelegationBase::CDelegationBase() 
{ 
}

CDelegationBase::~CDelegationBase() 
{ 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\simple\compdata.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMPDATA_H_
#define _SAMPCOMPDATA_H_

#include <mmc.h>
#include <objidl.h>
#include "DeleBase.h"
#include "StatNode.h"
#include "Comp.h"

class CComponentData : public IComponentData,
IPersistStream
{
    friend class CComponent;
    
private:
    ULONG				m_cref;
    LPCONSOLE			m_ipConsole;
    LPCONSOLENAMESPACE	m_ipConsoleNameSpace;
    
    CStaticNode     *m_pStaticNode;
    
public:
    CComponentData();
    ~CComponentData();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IComponentData
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
        /* [in] */ LPUNKNOWN pUnknown);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent( 
        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
        /* [in] */ LPDATAOBJECT lpDataObject,
        /* [in] */ MMC_NOTIFY_TYPE event,
        /* [in] */ LPARAM arg,
        /* [in] */ LPARAM param);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
        /* [in] */ MMC_COOKIE cookie,
        /* [in] */ DATA_OBJECT_TYPES type,
        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
        /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
        /* [in] */ LPDATAOBJECT lpDataObjectA,
        /* [in] */ LPDATAOBJECT lpDataObjectB);
        
        
        ///////////////////////////////
        // Interface IPersistStream
        ///////////////////////////////
        virtual HRESULT STDMETHODCALLTYPE GetClassID( 
        /* [out] */ CLSID __RPC_FAR *pClassID);
        
        virtual HRESULT STDMETHODCALLTYPE IsDirty( void);
    
    virtual HRESULT STDMETHODCALLTYPE Load( 
        /* [unique][in] */ IStream __RPC_FAR *pStm);
        
        virtual HRESULT STDMETHODCALLTYPE Save( 
        /* [unique][in] */ IStream __RPC_FAR *pStm,
        /* [in] */ BOOL fClearDirty);
        
        virtual HRESULT STDMETHODCALLTYPE GetSizeMax( 
        /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbSize);
};

#endif _SAMPCOMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\simple\compdata.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "CompData.h"
#include "DataObj.h"
#include "resource.h"
#include <crtdbg.h>

CComponentData::CComponentData()
: m_cref(0), m_ipConsoleNameSpace(NULL), m_ipConsole(NULL)
{
    OBJECT_CREATED
        
        m_pStaticNode = new CStaticNode;
}

CComponentData::~CComponentData()
{
    if (m_pStaticNode) {
        delete m_pStaticNode;
    }
    
    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CComponentData::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_IComponentData))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_IPersistStream))
        *ppv = static_cast<IPersistStream *>(this);
    
    if (*ppv) 
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponentData::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponentData::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    
    return m_cref;
}

///////////////////////////////
// Interface IComponentData
///////////////////////////////
HRESULT CComponentData::Initialize( 
                                   /* [in] */ LPUNKNOWN pUnknown)
{
    HRESULT hr = S_FALSE;
    
    //
    // Get pointer to namespace interface
    // First try to get pointer to IConsoleNameSpace2. If that fails, we are in
    // MMC1.0, so get pointer to IConsoleNameSpace instead
    //

    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace2, (void **)&m_ipConsoleNameSpace);

    if (S_OK == hr)
    {
        //We are in MMC 1.1 or higher. QI for IConsole2
        hr = pUnknown->QueryInterface(IID_IConsole2, (void **)&m_ipConsole);
    }
    else //We are in MMC 1.0
    {
        hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (void **)&m_ipConsoleNameSpace);
        if (FAILED(hr))
            return hr;

        hr = pUnknown->QueryInterface(IID_IConsole, (void **)&m_ipConsole);
    }

    return hr;
}

HRESULT CComponentData::CreateComponent( 
                                        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent) 
{
    *ppComponent = NULL;
    
    CComponent *pComponent = new CComponent(this);
    
    if (NULL == pComponent)
        return E_OUTOFMEMORY;
    
    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent);
}

HRESULT CComponentData::Notify( 
                               /* [in] */ LPDATAOBJECT lpDataObject,
                               /* [in] */ MMC_NOTIFY_TYPE event,
                               /* [in] */ LPARAM arg,
                               /* [in] */ LPARAM param)
{
	MMCN_Crack(TRUE, lpDataObject, this, NULL, event, arg, param);

    //Notify doesn't handle any notifications from MMC, so return E_NOTIMPL
    return E_NOTIMPL;
}

HRESULT CComponentData::Destroy( void)
{
    // Free interfaces
    if (m_ipConsoleNameSpace) {
        m_ipConsoleNameSpace->Release();
        m_ipConsoleNameSpace = NULL;
    }
    
    if (m_ipConsole) {
        m_ipConsole->Release(); 
        m_ipConsole = NULL;
    }
    
    return S_OK;
}

HRESULT CComponentData::QueryDataObject( 
                                        /* [in] */ MMC_COOKIE cookie,
                                        /* [in] */ DATA_OBJECT_TYPES type,
                                        /* [out] */ LPDATAOBJECT *ppDataObject) 
{
    CDataObject *pObj = NULL;
    
    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);
    
    return S_OK;
}

HRESULT CComponentData::GetDisplayInfo( 
                                       /* [out][in] */ SCOPEDATAITEM *pScopeDataItem)
{
    HRESULT hr = S_FALSE;
    
    // if they are asking for the SDI_STR we have one of those to give
    if (pScopeDataItem->lParam) {
        CDelegationBase *base = (CDelegationBase *)pScopeDataItem->lParam;
        if (pScopeDataItem->mask & SDI_STR) {
			LPCTSTR pszT = base->GetDisplayName();
			MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pScopeDataItem->displayname = pszW;
        }

        if (pScopeDataItem->mask & SDI_IMAGE) {
            pScopeDataItem->nImage = base->GetBitmapIndex();
        }
    }
    
    return hr;
}

HRESULT CComponentData::CompareObjects( 
                                       /* [in] */ LPDATAOBJECT lpDataObjectA,
                                       /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();
    
    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;
    
    return S_FALSE;
}

///////////////////////////////
// Interface IPersistStream
///////////////////////////////
HRESULT CComponentData::GetClassID( 
                                   /* [out] */ CLSID __RPC_FAR *pClassID)
{
    *pClassID = m_pStaticNode->getNodeType();
    
    return S_OK;
}

HRESULT CComponentData::IsDirty( void)
{
    return m_pStaticNode->isDirty() == true ? S_OK : S_FALSE;
}

HRESULT CComponentData::Load( 
                             /* [unique][in] */ IStream __RPC_FAR *pStm)
{
    void *snapInData = m_pStaticNode->getData();
    ULONG dataSize = m_pStaticNode->getDataSize();
    
    return pStm->Read(snapInData, dataSize, NULL);
}

HRESULT CComponentData::Save( 
                             /* [unique][in] */ IStream __RPC_FAR *pStm,
                             /* [in] */ BOOL fClearDirty)
{
    void *snapInData = m_pStaticNode->getData();
    ULONG dataSize = m_pStaticNode->getDataSize();
    
    if (fClearDirty)
        m_pStaticNode->clearDirty();
    
    return pStm->Write(snapInData, dataSize, NULL);
}

HRESULT CComponentData::GetSizeMax( 
                                   /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbSize)
{
    return m_pStaticNode->getDataSize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\about.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPABOUT_H_
#define _SAMPABOUT_H_

#include <tchar.h>
#include <mmc.h>

class CSnapinAbout : public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;
    
public:
    CSnapinAbout();
    ~CSnapinAbout();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
        /* [out] */ LPOLESTR *lpDescription);
        
        STDMETHODIMP GetProvider( 
        /* [out] */ LPOLESTR *lpName);
        
        STDMETHODIMP GetSnapinVersion( 
        /* [out] */ LPOLESTR *lpVersion);
        
        STDMETHODIMP GetSnapinImage( 
        /* [out] */ HICON *hAppIcon);
        
        STDMETHODIMP GetStaticFolderImage( 
        /* [out] */ HBITMAP *hSmallImage,
        /* [out] */ HBITMAP *hSmallImageOpen,
        /* [out] */ HBITMAP *hLargeImage,
        /* [out] */ COLORREF *cMask);
        
        ///////////////////////////////
        // Private Interface 
        ///////////////////////////////
private:
    HRESULT	CSnapinAbout::AllocOleStr(
        LPOLESTR *lpDest, 
        _TCHAR *szBuffer);
};

#endif _SAMPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\basesnap.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <olectl.h>
#include <initguid.h>
#include "guids.h"
#include "basesnap.h"
#include "Comp.h"
#include "CompData.h"
#include "About.h"
#include "Registry.h"

// our globals
HINSTANCE g_hinst;

BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    if ((rclsid != CLSID_CComponentData) && (rclsid != CLSID_CSnapinAbout))
        return CLASS_E_CLASSNOTAVAILABLE;
    
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
    // make the factory passing in the creation function for the type of object they want
    if (rclsid == CLSID_CComponentData)
        pFactory = new CClassFactory(CClassFactory::COMPONENT);
    else if (rclsid == CLSID_CSnapinAbout)
        pFactory = new CClassFactory(CClassFactory::ABOUT);
    
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}


CClassFactory::CClassFactory(FACTORY_TYPE factoryType)
: m_cref(0), m_factoryType(factoryType)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    if (COMPONENT == m_factoryType) {
        pObj = new CComponentData();
    } else {
        pObj = new CSnapinAbout();
    }
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    
    if (FAILED(hr))
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{
    HRESULT hr = SELFREG_E_CLASS;
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName));
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, sizeof(szSnapInName));
    
    _TCHAR szAboutName[256];
    
    LoadString(g_hinst, IDS_ABOUTNAME, szAboutName, sizeof(szAboutName));
    
    // register our CoClasses
    hr = RegisterServer(g_hinst, 
        CLSID_CComponentData, 
        szName);
    
    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst, 
        CLSID_CSnapinAbout, 
        szAboutName);
    
    // place the registry information for SnapIns
    if SUCCEEDED(hr)
        hr = RegisterSnapin(CLSID_CComponentData, szSnapInName, CLSID_CSnapinAbout, FALSE);
    
    return hr;
}


STDAPI DllUnregisterServer()
{
    if (UnregisterServer(CLSID_CComponentData) == S_OK)
        return UnregisterSnapin(CLSID_CComponentData);
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\about.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "About.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

CSnapinAbout::CSnapinAbout()
: m_cref(0)
{
    OBJECT_CREATED

        m_hSmallImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    m_hLargeImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_LGBMP), IMAGE_BITMAP, 32, 32, LR_LOADTRANSPARENT);

    m_hSmallImageOpen = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMOPEN), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);

    m_hAppIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ICON1));
}

CSnapinAbout::~CSnapinAbout()
{
    if (m_hSmallImage != NULL)
        FreeResource(m_hSmallImage);

    if (m_hLargeImage != NULL)
        FreeResource(m_hLargeImage);

    if (m_hSmallImageOpen != NULL)
        FreeResource(m_hSmallImageOpen);

    if (m_hAppIcon != NULL)
        FreeResource(m_hAppIcon);

    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CSnapinAbout::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<ISnapinAbout *>(this);
    else if (IsEqualIID(riid, IID_ISnapinAbout))
        *ppv = static_cast<ISnapinAbout *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSnapinAbout::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CSnapinAbout::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription(
                                                /* [out] */ LPOLESTR *lpDescription)
{
    _TCHAR szDesc[MAX_PATH];

    LoadString(g_hinst, IDS_SNAPINDESC, szDesc, sizeof(szDesc));

    return AllocOleStr(lpDescription, szDesc);
}


STDMETHODIMP CSnapinAbout::GetProvider(
                                       /* [out] */ LPOLESTR *lpName)
{
    return AllocOleStr(lpName, _T("Copyright  1998 Microsoft Corporation"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinVersion(
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return AllocOleStr(lpVersion, _T("1.0"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinImage(
                                          /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;

    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}


STDMETHODIMP CSnapinAbout::GetStaticFolderImage(
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;

    *hSmallImageOpen = m_hSmallImageOpen;

    *cMask = RGB(0, 128, 128);

    if (*hSmallImage == NULL || *hLargeImage == NULL || *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}

// this allocates a chunk of memory using CoTaskMemAlloc and copies our chars into it
HRESULT CSnapinAbout::AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer)
{
        MAKE_WIDEPTR_FROMTSTR_ALLOC(wszStr, szBuffer);
        *lpDest = wszStr;


    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\basesnap.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#ifndef _BASESNAP_H_
#define _BASESNAP_H_

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);
STDAPI DllCanUnloadNow(void);

ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    enum FACTORY_TYPE {COMPONENT = 0, ABOUT = 1};
    
    CClassFactory(FACTORY_TYPE factoryType);
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
private:
    FACTORY_TYPE m_factoryType;
};

#endif _BASESNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\simple\guids.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

// {1BA53C00-232F-11d2-9007-00C04F98BC0B}
DEFINE_GUID(CLSID_CComponentData, 
            0x1ba53c00, 0x232f, 0x11d2, 0x90, 0x7, 0x0, 0xc0, 0x4f, 0x98, 0xbc, 0xb);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\simple\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Resources.rc
//
#define IDS_HELPFILE                    1
#define IDS_SNAPINDESC                  2
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDI_ICON1                       108
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDB_ROCKET                      40004
#define IDB_CAR                         40005
#define IDB_PLANE                       40006
#define IDB_BIKE                        40007
#define IDB_ROCKET2                     40008
#define IDB_CAR2                        40009
#define IDB_PLANE2                      40010
#define IDB_BIKE2                       40011
#define IDB_CLOSED2                     40012
#define IDB_OPEN2                       40013
#define IDB_CLOSED                      40014
#define IDB_OPEN                        40015

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        108
#define _APS_NEXT_COMMAND_VALUE         40016
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\compdata.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "CompData.h"
#include "DataObj.h"
#include "resource.h"
#include <crtdbg.h>

CComponentData::CComponentData()
: m_cref(0), m_ipConsoleNameSpace(NULL), m_ipConsole(NULL)
{
    OBJECT_CREATED

        m_pStaticNode = new CStaticNode;
}

CComponentData::~CComponentData()
{
    if (m_pStaticNode) {
        delete m_pStaticNode;
    }

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CComponentData::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_IComponentData))
        *ppv = static_cast<IComponentData *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponentData::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponentData::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }

    return m_cref;
}

///////////////////////////////
// Interface IComponentData
///////////////////////////////
HRESULT CComponentData::Initialize(
                                   /* [in] */ LPUNKNOWN pUnknown)
{
    HRESULT      hr;

    //
    // Get pointer to name space interface
    //
    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (void **)&m_ipConsoleNameSpace);
    _ASSERT( S_OK == hr );

    //
    // Get pointer to console interface
    //
    hr = pUnknown->QueryInterface(IID_IConsole, (void **)&m_ipConsole);
    _ASSERT( S_OK == hr );

    IImageList *pImageList;
    m_ipConsole->QueryScopeImageList(&pImageList);
    _ASSERT( S_OK == hr );

    hr = pImageList->ImageListSetStrip( (long *)m_pStaticNode->m_pBMapSm, // pointer to a handle
        (long *)m_pStaticNode->m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );

    pImageList->Release();

    return S_OK;
}

HRESULT CComponentData::CreateComponent(
                                        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent)
{
    *ppComponent = NULL;

    CComponent *pComponent = new CComponent(this);

    if (NULL == pComponent)
        return E_OUTOFMEMORY;

    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent);
}

HRESULT CComponentData::Notify(
                               /* [in] */ LPDATAOBJECT lpDataObject,
                               /* [in] */ MMC_NOTIFY_TYPE event,
                               /* [in] */ LPARAM arg,
                               /* [in] */ LPARAM param)
{
    MMCN_Crack(TRUE, lpDataObject, this, NULL, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)
    {
    case MMCN_EXPAND:
        hr = base->OnExpand(m_ipConsoleNameSpace, m_ipConsole, (HSCOPEITEM)param);
        break;
    }

    return hr;
}

HRESULT CComponentData::Destroy( void)
{
    // Free interfaces
    if (m_ipConsoleNameSpace) {
        m_ipConsoleNameSpace->Release();
        m_ipConsoleNameSpace = NULL;
    }

    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}

HRESULT CComponentData::QueryDataObject(
                                        /* [in] */ MMC_COOKIE cookie,
                                        /* [in] */ DATA_OBJECT_TYPES type,
                                        /* [out] */ LPDATAOBJECT *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

HRESULT CComponentData::GetDisplayInfo(
                                       /* [out][in] */ SCOPEDATAITEM *pScopeDataItem)
{
    HRESULT hr = S_FALSE;

    // if they are asking for the SDI_STR we have one of those to give
    if (pScopeDataItem->lParam) {
        CDelegationBase *base = (CDelegationBase *)pScopeDataItem->lParam;
        if (pScopeDataItem->mask & SDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName();
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pScopeDataItem->displayname = pszW;
        }

        if (pScopeDataItem->mask & SDI_IMAGE) {
            pScopeDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}

HRESULT CComponentData::CompareObjects(
                                       /* [in] */ LPDATAOBJECT lpDataObjectA,
                                       /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\simple\statnode.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "StatNode.h"

const GUID CStaticNode::thisGuid = { 0x2974380c, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CStaticNode implementation
//
//
CStaticNode::CStaticNode()
{
}

CStaticNode::~CStaticNode()
{
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\compdata.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMPDATA_H_
#define _SAMPCOMPDATA_H_

#include <mmc.h>
#include "DeleBase.h"
#include "StatNode.h"
#include "Comp.h"

class CComponentData : public IComponentData
{
    friend class CComponent;
    
private:
    ULONG				m_cref;
    LPCONSOLE			m_ipConsole;
    LPCONSOLENAMESPACE	m_ipConsoleNameSpace;
    
    CStaticNode     *m_pStaticNode;
    
public:
    CComponentData();
    ~CComponentData();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IComponentData
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
        /* [in] */ LPUNKNOWN pUnknown);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent( 
        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
        /* [in] */ LPDATAOBJECT lpDataObject,
        /* [in] */ MMC_NOTIFY_TYPE event,
        /* [in] */ LPARAM arg,
        /* [in] */ LPARAM param);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
        /* [in] */ MMC_COOKIE cookie,
        /* [in] */ DATA_OBJECT_TYPES type,
        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
        /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
        /* [in] */ LPDATAOBJECT lpDataObjectA,
        /* [in] */ LPDATAOBJECT lpDataObjectB);
};

#endif _SAMPCOMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\dataobj.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DataObj.h"
#include "guids.h"
#include "DeleBase.h"

//
// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SZNODETYPE _T("CCF_SZNODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

#define _T_CCF_INTERNAL_SNAPIN _T("{2479DB32-5276-11d2-94F5-00C04FB92EC2}")

    // These are the clipboard formats that we must supply at a minimum.
    // mmc.h actually defined these. We can make up our own to use for
    // other reasons. We don't need any others at this time.
UINT CDataObject::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CDataObject::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CDataObject::s_cfSZNodeType  = RegisterClipboardFormat(_T_CCF_SZNODETYPE);
UINT CDataObject::s_cfSnapinClsid = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);
UINT CDataObject::s_cfInternal    = RegisterClipboardFormat(_T_CCF_INTERNAL_SNAPIN);


CDataObject::CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context)
: m_lCookie(cookie), m_context(context), m_cref(0)
{
}

CDataObject::~CDataObject()
{
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IDataObject *>(this);
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppv = static_cast<IDataObject *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CDataObject::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
//
HRESULT CDataObject::GetDataHere(
                                 FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure
                                 STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure
                                 )
{
    const   CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pStream = NULL;

    CDelegationBase *base = GetBaseNodeObject();

    HRESULT hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( FAILED(hr) )
        return hr;                       // Minimal error checking

    hr = DV_E_FORMATETC;                 // Unknown format

    if (cf == s_cfDisplayName) {
        const _TCHAR *pszName = base->GetDisplayName();

                MAKE_WIDEPTR_FROMTSTR(wszName, pszName);

                // get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(pszName);
        ulSizeofName++;                      // Count null character
        ulSizeofName *= sizeof(WCHAR);

        hr = pStream->Write(wszName, ulSizeofName, NULL);
    } else if (cf == s_cfNodeType) {
        const GUID *pGUID = (const GUID *)&base->getNodeType();

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfSZNodeType) {
        LPOLESTR szGuid;
        hr = StringFromCLSID(base->getNodeType(), &szGuid);

        if (SUCCEEDED(hr)) {
            hr = pStream->Write(szGuid, wcslen(szGuid), NULL);
            CoTaskMemFree(szGuid);
        }
    } else if (cf == s_cfSnapinClsid) {
        const GUID *pGUID = NULL;
        pGUID = &CLSID_CComponentData;

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfInternal) {
        // we are being asked to get our this pointer from the IDataObject interface
        // only our own snap-in objects will know how to do this.
        CDataObject *pThis = this;
        hr = pStream->Write( &pThis, sizeof(CDataObject*), NULL );
    }

    pStream->Release();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Global helper functions to help work with dataobjects and
// clipboard formats


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfInternal clipboard format
//
CDataObject* GetOurDataObject (
                               LPDATAOBJECT lpDataObject      // [in] IComponent pointer
                               )
{
    HRESULT       hr      = S_OK;
    CDataObject *pSDO     = NULL;

	// check to see if the data object is a special data object.
	if ( IS_SPECIAL_DATAOBJECT (lpDataObject) )
	{
		//Code for handling a special data object goes here.

		//Note that the MMC SDK samples do not handle
		//special data objects, so we exit if we get one.
		return NULL;
	}

    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { CDataObject::s_cfInternal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(CDataObject *));

    if (!stgmedium.hGlobal)     {
        hr = E_OUTOFMEMORY;
    }

    if SUCCEEDED(hr)
        // Attempt to get data from the object
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );

    // stgmedium now has the data we need
    if (SUCCEEDED(hr))  {
        pSDO = *(CDataObject **)(stgmedium.hGlobal);
    }

    // if we have memory free it
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);

    return pSDO;

} // end GetOurDataObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\simple\statnode.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SNAPINBASE_H
#define _SNAPINBASE_H

#include "DeleBase.h"

class CStaticNode : public CDelegationBase {
public:
    CStaticNode();
    virtual ~CStaticNode();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { 
        static _TCHAR szDisplayName[256];
        LoadString(g_hinst, IDS_SNAPINNAME, szDisplayName, sizeof(szDisplayName));
        return szDisplayName; 
    }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_NONE; }
    
public:
    // virtual functions for MMCN_* go here
    
private:
    // {2974380C-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    struct privateData {
        _TCHAR host[MAX_PATH];
        bool isDirty;
        
        privateData() : isDirty(false) {
            ZeroMemory(host, sizeof(host));
        }
    } snapInData;
    
    public:
        LONG getDataSize() { return sizeof(privateData); }
        void *getData() { return &snapInData; }
        bool isDirty() { return snapInData.isDirty; }
        void clearDirty() { snapInData.isDirty = false; };
};

#endif // _SNAPINBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\dataobj.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPDATAOBJECT_H_
#define _SAMPDATAOBJECT_H_

#include <mmc.h>
#include "DeleBase.h"

class CDataObject : public IDataObject
{
private:
    ULONG				m_cref;
    MMC_COOKIE			m_lCookie;
    DATA_OBJECT_TYPES   m_context;
    
public:
    CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context);
    ~CDataObject();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // IDataObject methods 
    ///////////////////////////////
    STDMETHODIMP GetDataHere (FORMATETC *pformatetc, STGMEDIUM *pmedium);
    
    // The rest are not implemented
    STDMETHODIMP GetData (LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumFormatEtc (DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };
    
    STDMETHODIMP QueryGetData (LPFORMATETC lpFormatetc) 
    { return E_NOTIMPL; };
    
    STDMETHODIMP GetCanonicalFormatEtc (LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    
    STDMETHODIMP SetData (LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DAdvise (LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DUnadvise (DWORD dwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumDAdvise (LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };
    
    ///////////////////////////////
    // Custom Methods
    ///////////////////////////////
    
    CDelegationBase *GetBaseNodeObject() {
        return (CDelegationBase *)m_lCookie;
    }
    
    DATA_OBJECT_TYPES GetContext() {
        return m_context;
    }
    
public:
    // clipboard formats
    static UINT s_cfSZNodeType;
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
    static UINT s_cfInternal;
    
};

HRESULT ExtractFromDataObject(IDataObject *lpDataObject,UINT cf,ULONG cb,HGLOBAL *phGlobal);
CDataObject* GetOurDataObject(IDataObject *lpDataObject);
BOOL IsMMCMultiSelectDataObject(IDataObject *lpDataObject);

#endif _SAMPDATAOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\simple\registry.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

#define STRINGS_ONLY
#include "globals.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName)       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule, 
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;
    
    assert(dwResult != 0) ;
    
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    assert(SUCCEEDED(hr)) ;

	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;
	_tcscat(szKey, pszCLSID) ;
    
    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;
    
    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    _tcscat(szKey, _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), _T("Apartment"));
    
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    
    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    
    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;

	MAKE_TSTRPTR_FROMWIDE(pszT, wszCLSID);
	_tcscat(szKey, pszT) ;
    
    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.
    
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    
    return S_OK ;
}

//
// Register the snap-in in the registry.
//
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions)
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    LPOLESTR wszAboutCLSID = NULL;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

   
    // Add the CLSID to the registry.
    setSnapInKeyAndValue(pszCLSID, NULL, _T("NameString"), szNameString) ;
    setSnapInKeyAndValue(pszCLSID, _T("StandAlone"), NULL, NULL);

    if (IID_NULL != clsidAbout) {
        hr = StringFromCLSID(clsidAbout, &wszAboutCLSID);
		MAKE_TSTRPTR_FROMWIDE(pszAboutCLSID, wszAboutCLSID);
        setSnapInKeyAndValue(pszCLSID, NULL, _T("About"), pszAboutCLSID);
	}
    
    if (fSupportExtensions) {
        // Build the key NodeType 
        setSnapInKeyAndValue(pszCLSID, _T("NodeTypes"), NULL, NULL);
        
        _TCHAR szKey[64] ;
        _tcscpy(szKey, pszCLSID) ;
        _tcscat(szKey, _T("\\NodeTypes")) ;
        setSnapInKeyAndValue(szKey, pszCLSID, NULL, NULL);
    }
    
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    if (IID_NULL != clsidAbout)
        CoTaskMemFree(wszAboutCLSID);
    
    return S_OK ;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    LPOLESTR wszCLSID = NULL;
    
    // Get CLSID
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
    
    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));
    
    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\"));
    _tcscat(szKeyBuf, pszCLSID);
    
    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.
    
    // free the memory
    CoTaskMemFree(wszCLSID);
    
    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }
    
    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }
    
    // Close the child.
    RegCloseKey(hKeyChild) ;
    
    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;
    
    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));
    
    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\")) ;
    _tcscat(szKeyBuf, szKey) ;
    
    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\comp.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "DataObj.h"
#include <commctrl.h>        // Needed for button styles...
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "DeleBase.h"
#include "CompData.h"

CComponent::CComponent(CComponentData *parent)
: m_pComponentData(parent), m_cref(0), m_ipConsole(NULL), m_ipConsole2(NULL),
m_bTaskpadView(FALSE), m_bIsTaskpadPreferred(FALSE)
{
    OBJECT_CREATED
}

CComponent::~CComponent()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IComponent))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IExtendTaskPad))
        *ppv = static_cast<IExtendTaskPad *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponent::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponent::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface IComponent
///////////////////////////////
STDMETHODIMP CComponent::Initialize(
                                    /* [in] */ LPCONSOLE lpConsole)
{
    HRESULT hr = S_OK;

    // Save away all the interfaces we'll need.
    // Fail if we can't QI the required interfaces.

    m_ipConsole = lpConsole;
    m_ipConsole->AddRef();

    hr = m_ipConsole->QueryInterface(IID_IConsole2,
        reinterpret_cast<void**>(&m_ipConsole2));

    _ASSERT( NULL != m_ipConsole2 );

    hr = m_ipConsole2->IsTaskpadViewPreferred();
    m_bIsTaskpadPreferred = (hr == S_OK) ? TRUE : FALSE;

    return hr;
}

STDMETHODIMP CComponent::Notify(
                                /* [in] */ LPDATAOBJECT lpDataObject,
                                /* [in] */ MMC_NOTIFY_TYPE event,
                                /* [in] */ LPARAM arg,
                                /* [in] */ LPARAM param)
{
    MMCN_Crack(FALSE, lpDataObject, NULL, this, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)
	{
    case MMCN_SHOW:
        hr = base->OnShow(m_ipConsole, (BOOL)arg, (HSCOPEITEM)param);
        break;

    case MMCN_ADD_IMAGES:
        hr = base->OnAddImages((IImageList *)arg, (HSCOPEITEM)param);
        break;

    case MMCN_SELECT:
        hr = base->OnSelect(m_ipConsole, (BOOL)LOWORD(arg), (BOOL)HIWORD(arg));
        break;

    case MMCN_RENAME:
        hr = base->OnRename((LPOLESTR)param);
        break;

    case MMCN_LISTPAD:
        hr = base->OnListpad(m_ipConsole, (BOOL)arg);
        break;
    }

    return hr;
}

STDMETHODIMP CComponent::Destroy(
                                 /* [in] */ MMC_COOKIE cookie)
{
    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}


STDMETHODIMP CComponent::QueryDataObject(
                                         /* [in] */ MMC_COOKIE cookie,
                                         /* [in] */ DATA_OBJECT_TYPES type,
                                         /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pComponentData->m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

STDMETHODIMP CComponent::GetResultViewType(
                                           /* [in] */ MMC_COOKIE cookie,
                                           /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
                                           /* [out] */ long __RPC_FAR *pViewOptions)
{
    CDelegationBase *base = (CDelegationBase *)cookie;

    //
    // Ask for default listview.
    //
    if (base == NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
        *ppViewType = NULL;
    }
    else
        return base->GetResultViewType(ppViewType, pViewOptions);

    return S_OK;
}

STDMETHODIMP CComponent::GetDisplayInfo(
                                        /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem)
{
    HRESULT hr = S_OK;
    CDelegationBase *base = NULL;

    // if they are asking for the RDI_STR we have one of those to give

    if (pResultDataItem->lParam) {
        base = (CDelegationBase *)pResultDataItem->lParam;
        if (pResultDataItem->mask & RDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName(pResultDataItem->nCol);
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pResultDataItem->str = pszW;
        }

        if (pResultDataItem->mask & RDI_IMAGE) {
            pResultDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}


STDMETHODIMP CComponent::CompareObjects(
                                        /* [in] */ LPDATAOBJECT lpDataObjectA,
                                        /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////
// Interface IComponent
///////////////////////////////
HRESULT CComponent::TaskNotify(
                               /* [in] */ IDataObject __RPC_FAR *pdo,
                               /* [in] */ VARIANT __RPC_FAR *arg,
                               /* [in] */ VARIANT __RPC_FAR *param)
{
    CDelegationBase *base = GetOurDataObject(pdo)->GetBaseNodeObject();

    return base->TaskNotify(m_ipConsole, arg, param);
}

HRESULT CComponent::EnumTasks(
                              /* [in] */ IDataObject __RPC_FAR *pdo,
                              /* [string][in] */ LPOLESTR szTaskGroup,
                              /* [out] */ IEnumTASK __RPC_FAR *__RPC_FAR *ppEnumTASK)
{
    CDelegationBase *base = GetOurDataObject(pdo)->GetBaseNodeObject();

    // GetTaskList will allocate the entire task structure, it's
    // up to the enumerator to free the list when destroyed
    LONG nCount;
    MMC_TASK *tasks = base->GetTaskList(szTaskGroup, &nCount);

    if (tasks != NULL) {
        CEnumTASK *pTask = new CEnumTASK(tasks, nCount);

        if (pTask) {
            reinterpret_cast<IUnknown *>(pTask)->AddRef();
            HRESULT hr = pTask->QueryInterface (IID_IEnumTASK, (void **)ppEnumTASK);
            reinterpret_cast<IUnknown *>(pTask)->Release();

            return hr;
        }
    }

    return S_OK;
}


HRESULT CComponent::GetTitle(
                             /* [string][in] */ LPOLESTR pszGroup,
                             /* [string][out] */ LPOLESTR __RPC_FAR *pszTitle)
{
    CDelegationBase *base = (CDelegationBase *)wcstoul(pszGroup, NULL, 16);

    if (NULL == base)
            return S_FALSE;

    return base->GetTaskpadTitle(pszTitle);
}

HRESULT CComponent::GetDescriptiveText(
                                       /* [string][in] */ LPOLESTR pszGroup,
                                       /* [string][out] */ LPOLESTR __RPC_FAR *pszDescriptiveText)
{
        CDelegationBase *base = (CDelegationBase *)wcstoul(pszGroup, NULL, 16);

        if (NULL == base)
                return S_FALSE;

    return base->GetTaskpadDescription(pszDescriptiveText);
}

HRESULT CComponent::GetBackground(
                                  /* [string][in] */ LPOLESTR pszGroup,
                                  /* [out] */ MMC_TASK_DISPLAY_OBJECT __RPC_FAR *pTDO)
{
        CDelegationBase *base = (CDelegationBase *)wcstoul(pszGroup, NULL, 16);

        if (NULL == base)
                return S_FALSE;

    return base->GetTaskpadBackground(pTDO);
}

HRESULT CComponent::GetListPadInfo(
                                   /* [string][in] */ LPOLESTR pszGroup,
                                   /* [out] */ MMC_LISTPAD_INFO __RPC_FAR *lpListPadInfo)
{
        CDelegationBase *base = (CDelegationBase *)wcstoul(pszGroup, NULL, 16);

        if (NULL == base)
                return S_FALSE;

    return base->GetListpadInfo(lpListPadInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\comp.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMP_H_
#define _SAMPCOMP_H_

#include <mmc.h>
#include <tchar.h>
#include "EnumTASK.h"
#include "globals.h"

class CComponent : public IComponent,
IExtendTaskPad
{
private:
    ULONG				m_cref;
    
    IConsole*		m_ipConsole;
    IConsole2*		m_ipConsole2;
    
    //store the view type: standard or taskpad
    BOOL m_bTaskpadView;
    //store the user's view type preference.
    BOOL m_bIsTaskpadPreferred;
    
    class CComponentData *m_pComponentData;
    
    public:
        CComponent(CComponentData *parent);
        ~CComponent();
        
        ///////////////////////////////
        // Interface IUnknown
        ///////////////////////////////
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        
        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ MMC_COOKIE cookie);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);
            
            ///////////////////////////////
            // Interface IComponent
            ///////////////////////////////
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TaskNotify( 
            /* [in] */ IDataObject __RPC_FAR *pdo,
            /* [in] */ VARIANT __RPC_FAR *arg,
            /* [in] */ VARIANT __RPC_FAR *param);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumTasks( 
            /* [in] */ IDataObject __RPC_FAR *pdo,
            /* [string][in] */ LPOLESTR szTaskGroup,
            /* [out] */ IEnumTASK __RPC_FAR *__RPC_FAR *ppEnumTASK);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTitle( 
            /* [string][in] */ LPOLESTR pszGroup,
            /* [string][out] */ LPOLESTR __RPC_FAR *pszTitle);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDescriptiveText( 
            /* [string][in] */ LPOLESTR pszGroup,
            /* [string][out] */ LPOLESTR __RPC_FAR *pszDescriptiveText);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetBackground( 
            /* [string][in] */ LPOLESTR pszGroup,
            /* [out] */ MMC_TASK_DISPLAY_OBJECT __RPC_FAR *pTDO);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetListPadInfo( 
            /* [string][in] */ LPOLESTR pszGroup,
            /* [out] */ MMC_LISTPAD_INFO __RPC_FAR *lpListPadInfo);
            
    private:
        LPOLESTR OleDuplicateString(LPOLESTR lpStr) {
            LPOLESTR tmp = static_cast<LPOLESTR>(CoTaskMemAlloc((wcslen(lpStr) + 1)  * sizeof(WCHAR)));
            wcscpy(tmp, lpStr);
            
            return tmp;
        }
};

#endif _SAMPCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\enumtask.cpp ===
// EnumTASK.cpp: implementation of the CEnumTASK class.
//
//////////////////////////////////////////////////////////////////////

#include "EnumTASK.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CEnumTASK::CEnumTASK(MMC_TASK *pTaskList, ULONG nTasks)
    : m_pTaskList(pTaskList), m_TaskCount(nTasks), m_CurrTask(0)
{
}

CEnumTASK::~CEnumTASK()
{
    if (m_pTaskList)
        delete [] m_pTaskList;
}

STDMETHODIMP CEnumTASK::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IEnumTASK *>(this);
    else if (IsEqualIID(riid, IID_IEnumTASK))
        *ppv = static_cast<IEnumTASK *>(this);
    
    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CEnumTASK::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CEnumTASK::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
    
}

HRESULT CEnumTASK::Next( 
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ MMC_TASK __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched)
{
    *pceltFetched = 0;

	if (m_CurrTask < m_TaskCount) {
		if (rgelt != NULL) {
			CopyMemory(rgelt, &m_pTaskList[m_CurrTask++], sizeof(MMC_TASK));
			*pceltFetched = 1;
		}
	}

    return (*pceltFetched != 0) ? S_OK : S_FALSE;
}

HRESULT CEnumTASK::Skip( 
    /* [in] */ ULONG celt)
{
    return E_NOTIMPL;
}

HRESULT CEnumTASK::Reset( void)
{
    m_CurrTask = 0;

    return S_OK;
}

HRESULT CEnumTASK::Clone( 
    /* [out] */ IEnumTASK __RPC_FAR *__RPC_FAR *ppenum)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\enumtask.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _ENUMTASK_H
#define _ENUMTASK_H

#include <mmc.h>

class CEnumTASK : public IEnumTASK
{
public:
    CEnumTASK(MMC_TASK *pTaskList, ULONG nTasks);
    virtual ~CEnumTASK();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IEnumTASK
    ///////////////////////////////
    virtual HRESULT STDMETHODCALLTYPE Next( 
        /* [in] */ ULONG celt,
        /* [length_is][size_is][out] */ MMC_TASK __RPC_FAR *rgelt,
        /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
        /* [in] */ ULONG celt);
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void);
    
    virtual HRESULT STDMETHODCALLTYPE Clone( 
        /* [out] */ IEnumTASK __RPC_FAR *__RPC_FAR *ppenum);
        
private:
    MMC_TASK *m_pTaskList;
    ULONG m_TaskCount;
    ULONG m_CurrTask;
    
    ULONG m_cref;
};

#endif // _ENUMTASK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\delebase.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DeleBase.h"

const GUID CDelegationBase::thisGuid = { 0x2974380b, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

HBITMAP CDelegationBase::m_pBMapSm = NULL;
HBITMAP CDelegationBase::m_pBMapLg = NULL;


//==============================================================
//
// CDelegationBase implementation
//
//
CDelegationBase::CDelegationBase() 
: bExpanded(FALSE)

{ 
    if (NULL == m_pBMapSm || NULL == m_pBMapLg)
        LoadBitmaps(); 
}

CDelegationBase::~CDelegationBase() 
{ 
}

// CDelegationBase::AddImages sets up the collection of images to be displayed
// by the IComponent in the result pane as a result of its MMCN_SHOW handler
HRESULT CDelegationBase::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi) 
{
    return pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\land.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _LAND_H
#define _LAND_H

#include "DeleBase.h"

class CLandBasedVehicle : public CDelegationBase {
public:
    CLandBasedVehicle() { }
    
    virtual ~CLandBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Land-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_LANDICON; }
    
private:
    enum { IDM_NEW_LAND = 2 };
    
    // {2974380E-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};


#endif // _LAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\delebase.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _BRANCHES_H
#define _BRANCHES_H

#include <mmc.h>
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "LocalRes.h"

class CDelegationBase {
public:
    CDelegationBase();
    virtual ~CDelegationBase();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) = 0;
    virtual const GUID & getNodeType() { _ASSERT(FALSE); return IID_NULL; }
    
    virtual const LPARAM GetCookie() { return reinterpret_cast<LPARAM>(this); }
    virtual const int GetBitmapIndex() = 0;
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions) { return S_FALSE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent) { return S_FALSE; }
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem) { return S_FALSE; }
    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    virtual HRESULT OnRename(LPOLESTR pszNewName) { return S_FALSE; }
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect) { return S_FALSE; }
    virtual HRESULT OnListpad(IConsole *pConsole, BOOL bAttaching) { return S_FALSE; }

	// taskpad support
    virtual HRESULT TaskNotify(IConsole *pConsole, VARIANT *v1, VARIANT *v2) { return S_FALSE; }
    virtual MMC_TASK *GetTaskList(LPOLESTR szTaskGroup, LONG *nCount) { return NULL; }
	virtual HRESULT GetTaskpadTitle(LPOLESTR *pszTitle) { return S_FALSE; }
	virtual HRESULT GetTaskpadDescription(LPOLESTR *pszDescription) { return S_FALSE; }
	virtual HRESULT GetTaskpadBackground(MMC_TASK_DISPLAY_OBJECT *pTDO) { return S_FALSE; }
	virtual HRESULT GetListpadInfo(MMC_LISTPAD_INFO *lpListPadInfo) { return S_FALSE; }
    
public:
    static HBITMAP m_pBMapSm;
    static HBITMAP m_pBMapLg;
    
protected:
    static void LoadBitmaps() {
        m_pBMapSm = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_SMICONS));
        m_pBMapLg = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_LGICONS));
    }
    
    BOOL bExpanded;
    
private:
    // {2974380B-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _BRANCHES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\land.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Land.h"

const GUID CLandBasedVehicle::thisGuid = { 0x2974380e, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CLandBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>

#ifndef STRINGS_ONLY
        #define IDM_BUTTON1    0x100
        #define IDM_BUTTON2    0x101

        extern HINSTANCE g_hinst;
        extern ULONG g_uObjects;

        #define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
        #define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

        // uncomment the following #define to enable message cracking
        // #define MMC_CRACK_MESSAGES
        void MMCN_Crack(BOOL bComponentData,
                                        IDataObject *pDataObject,
                                        IComponentData *pCompData,
                                        IComponent *pComp,
                                        MMC_NOTIFY_TYPE event,
                                        LPARAM arg,
                                        LPARAM param);

		LPOLESTR CreateResourcePath(HINSTANCE hInst, LPOLESTR szResource);      
#endif

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(GetProcessHeap(), 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(GetProcessHeap(), 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given a _TCHAR, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszT;
//  pszT = MyGetTStringRoutine();
//  MAKE_WIDEPTR_FROMSTR(pwsz, pszT);
//  MyUseWideStringRoutine(pwsz);
//  ...
#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPWSTR)__TempBuffer##ptrname.GetBuffer(), tstr); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    lstrcpyW((LPWSTR)ptrname, tstr)
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, ptrname, __l##ptrname)
#endif

//
// similarily for MAKE_TSTRPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
// * 2 for DBCS handling in below length computation
//
#ifdef UNICODE
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPTSTR)__TempBuffer##ptrname.GetBuffer(), widestr); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5

#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\mmccrack.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

static TCHAR *MMCN_CrackVerb(MMC_CONSOLE_VERB verb)
{
        static TCHAR error[64];

        switch (verb) {
    case MMC_VERB_NONE:
                return _T("NONE");
    case MMC_VERB_OPEN:
                return _T("OPEN");
    case MMC_VERB_COPY:
                return _T("COPY");
    case MMC_VERB_PASTE:
                return _T("PASTE");
    case MMC_VERB_DELETE:
                return _T("DELETE");
    case MMC_VERB_PROPERTIES:
                return _T("PROPERTIES");
    case MMC_VERB_RENAME:
                return _T("RENAME");
    case MMC_VERB_REFRESH:
                return _T("REFRESH");
    case MMC_VERB_PRINT:
                return _T("PRINT");
    case MMC_VERB_CUT:
                return _T("CUT");
        default:
                wsprintf(error, _T("Unknown verb id %d"), verb);
                return error;
        }
}

void MMCN_Crack(BOOL bComponentData,
                IDataObject *pDataObject,
                                IComponentData *pCompData,
                                IComponent *pComp,
                MMC_NOTIFY_TYPE event,
                                LPARAM arg,
                                LPARAM param)
{
#ifdef MMC_CRACK_MESSAGES
        TCHAR message[256] = {0};

        if (bComponentData == TRUE)
                OutputDebugString(_T("IComponentData::Notify( "));
        else
                OutputDebugString(_T("IComponent::Notify( "));

        wsprintf(message, _T("DataObject: %08x, CompData: %08x, Comp: %08x ) - "), pDataObject, pCompData, pComp);
        OutputDebugString(message);

    switch (event)      {
                case MMCN_ACTIVATE:
                        wsprintf(message, _T("MMCN_ACTIVATE\n\tActivate: %d\n"), arg);
                        break;

                case MMCN_ADD_IMAGES:
                        wsprintf(message, _T("MMCN_ADD_IMAGES\n\tImage List: %08x\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_BTN_CLICK:
                        wsprintf(message, _T("MMCN_BTN_CLICK\n\tVerb: %ws\n"), MMCN_CrackVerb((MMC_CONSOLE_VERB)param));
                        break;

                case MMCN_COLUMN_CLICK:
                        wsprintf(message, _T("MMCN_COLUMN_CLICK\n\tColumn: %d\n\tSort Option: %d\n"), arg,       param);
                        break;

                case MMCN_COLUMNS_CHANGED:
                        wsprintf(message, _T("MMCN_COLUMNS_CHANGED\n"));
                        break;

                case MMCN_CONTEXTHELP:
                        wsprintf(message, _T("MMCN_CONTEXTHELP\n"));
                        break;

                case MMCN_CONTEXTMENU:
                        wsprintf(message, _T("MMCN_CONTEXTMENU\n"));
                        break;

                case MMCN_CUTORMOVE:
                        wsprintf(message, _T("MMCN_CUTORMOVE\n"));
                        break;

                case MMCN_DBLCLICK:
                        wsprintf(message, _T("MMCN_DBLCLICK\n"));
                        break;

                case MMCN_DELETE:
                        wsprintf(message, _T("MMCN_DELETE\n"));
                        break;

                case MMCN_DESELECT_ALL:
                        wsprintf(message, _T("MMCN_DESELECT_ALL\n"));
                        break;

                case MMCN_EXPAND:
                        wsprintf(message, _T("MMCN_EXPAND\n\tExpand: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_EXPANDSYNC:
                        wsprintf(message, _T("MMCN_EXPANDSYNC\n"));
                        break;

                case MMCN_FILTERBTN_CLICK:
                        wsprintf(message, _T("MMCN_FILTERBTN_CLICK\n\tColumn: %d\n"), arg);
                        break;

                case MMCN_FILTER_CHANGE:
                        wsprintf(message, _T("MMCN_FILTER_CHANGE\n\tColumn: %d\n"), param);
                        break;

                case MMCN_HELP:
                        wsprintf(message, _T("MMCN_HELP\n"));
                        break;

                case MMCN_INITOCX:
                        wsprintf(message, _T("MMCN_INITOCX\n\tIUnknown: %08x\n"), param);
                        break;

                case MMCN_LISTPAD:
                        wsprintf(message, _T("MMCN_LISTPAD\n\tConnect: %d\n"), arg);
                        break;

                case MMCN_MENU_BTNCLICK:
                        wsprintf(message, _T("MMCN_MENU_BTNCLICK\n"));
                        break;

                case MMCN_MINIMIZED:
                        wsprintf(message, _T("MMCN_MINIMIZED\n\tMinimized: %d\n"), arg);
                        break;

                case MMCN_PASTE:
                        wsprintf(message, _T("MMCN_PASTE\n\tCopy: %d\n"), param == NULL);
                        break;

                case MMCN_PRELOAD:
                        wsprintf(message, _T("MMCN_PRELOAD\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_PRINT:
                        wsprintf(message, _T("MMCN_PRINT\n"));
                        break;

                case MMCN_PROPERTY_CHANGE:
                        wsprintf(message, _T("MMCN_PROPERTY_CHANGE\n\tScope: %d\n\tArg: %08x\n"), arg, param);
                        break;

                case MMCN_QUERY_PASTE:
                        wsprintf(message, _T("MMCN_QUERY_PASTE\n"));
                        break;

                case MMCN_REFRESH:
                        wsprintf(message, _T("MMCN_REFRESH\n"));
                        break;

                case MMCN_REMOVE_CHILDREN:
                        wsprintf(message, _T("MMCN_REMOVE_CHILDREN\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_RENAME:
                        wsprintf(message, _T("MMCN_RENAME\n\tNew Name: '%ws'\n"), (LPOLESTR)param);
                        break;

                case MMCN_RESTORE_VIEW:
                        wsprintf(message, _T("MMCN_RESTORE_VIEW\n"));
                        break;

                case MMCN_SELECT:
                        wsprintf(message, _T("MMCN_SELECT\n\tScope: %d\n\tSelect: %08x\n"), LOWORD(arg), HIWORD(arg));
                        break;

                case MMCN_SHOW:
                        wsprintf(message, _T("MMCN_SHOW\n\tShow: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_SNAPINHELP:
                        wsprintf(message, _T("MMCN_SNAPINHELP\n"));
                        break;

                case MMCN_VIEW_CHANGE:
                        wsprintf(message, _T("MMCN_VIEW_CHANGE\n\tData: %08x\n\tHint: %08x\n"), arg, param);
                        break;
        }

        if (message[0] != 0)
                OutputDebugString(message);
        else
                OutputDebugString(_T("unknown event\n"));

#endif
        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\registry.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions = FALSE);

HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\sky.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Sky.h"

const GUID CSkyBasedVehicle::thisGuid = { 0x2974380f, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSkyBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\sky.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SKY_H
#define _SKY_H

#include "DeleBase.h"

class CSkyBasedVehicle : public CDelegationBase {
public:
    CSkyBasedVehicle() { }
    
    virtual ~CSkyBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Sky-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SKYICON; }
    
private:
    enum { IDM_NEW_SKY = 3 };
    
    // {2974380F-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};


#endif // _SKY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\guids.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

// {C83216B2-A4E5-11d2-970B-0080C7DCB3DC}
DEFINE_GUID(CLSID_CComponentData, 
            0xc83216b2, 0xa4e5, 0x11d2, 0x97, 0xb, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc);

// {CED3C801-A4E5-11d2-970B-0080C7DCB3DC}
DEFINE_GUID(CLSID_CSnapinAbout, 
            0xced3c801, 0xa4e5, 0x11d2, 0x97, 0xb, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\statnode.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "StatNode.h"

#include "Space.h"
#include "Sky.h"
#include "People.h"
#include "Land.h"

const GUID CStaticNode::thisGuid = { 0x2974380c, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CStaticNode implementation
//
//
CStaticNode::CStaticNode()
{
    children[0] = new CPeoplePoweredVehicle;
    children[1] = new CLandBasedVehicle;
    children[2] = new CSkyBasedVehicle;
    children[3] = new CSpaceVehicle;
}

CStaticNode::~CStaticNode()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CStaticNode::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;
    
    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT	  |
                SDI_CHILDREN;
            
            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = (n == 0); // only the first child has children
            
            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );
            
            _ASSERT( SUCCEEDED(hr) );
        }
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\statnode.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SNAPINBASE_H
#define _SNAPINBASE_H

#include "DeleBase.h"

class CStaticNode : public CDelegationBase {
public:
    CStaticNode();
    
    virtual ~CStaticNode();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { 
        static _TCHAR szDisplayName[256];
        LoadString(g_hinst, IDS_SNAPINNAME, szDisplayName, sizeof(szDisplayName));
        return szDisplayName; 
    }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_NONE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
    
    // {2974380C-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};



#endif // _SNAPINBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Resources.rc
//
#define IDS_HELPFILE                    1
#define IDS_SNAPINDESC                  2
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDI_ICON1                       108
#define IDB_SMOPEN                      111
#define IDB_SMBMP                       112
#define IDB_LGBMP                       113
#define IDB_BITMAP1                     114
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDB_ROCKET                      40004
#define IDB_CAR                         40005
#define IDB_PLANE                       40006
#define IDB_BIKE                        40007
#define IDB_ROCKET2                     40008
#define IDB_CAR2                        40009
#define IDB_PLANE2                      40010
#define IDB_BIKE2                       40011
#define IDB_CLOSED2                     40012
#define IDB_OPEN2                       40013
#define IDB_CLOSED                      40014
#define IDB_OPEN                        40015

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        116
#define _APS_NEXT_COMMAND_VALUE         40016
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\people.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _PEOPLE_H
#define _PEOPLE_H

#include "DeleBase.h"

class CBicycle : public CDelegationBase {
public:
    CBicycle(int i) : id(i) { }
    virtual ~CBicycle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CBicycleFolder : public CDelegationBase {
public:
    CBicycleFolder();
    virtual ~CBicycleFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Bicycles (horizontal listpad)"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions);
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnListpad(IConsole *pConsole, BOOL bAttaching);

	// taskpad support
    virtual HRESULT TaskNotify(IConsole *pConsole, VARIANT *v1, VARIANT *v2);
    virtual MMC_TASK *GetTaskList(LPOLESTR szTaskGroup, LONG *nCount);
	virtual HRESULT GetTaskpadTitle(LPOLESTR *pszTitle);
	virtual HRESULT GetTaskpadDescription(LPOLESTR *pszDescription);
	virtual HRESULT GetTaskpadBackground(MMC_TASK_DISPLAY_OBJECT *pTDO);
	virtual HRESULT GetListpadInfo(MMC_LISTPAD_INFO *lpListPadInfo);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CSkateboard : public CDelegationBase {
public:
    CSkateboard(int i) : id(i) { }
    virtual ~CSkateboard() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CSkateboardFolder : public CDelegationBase {
public:
    CSkateboardFolder();
    virtual ~CSkateboardFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Skateboards (taskpad)"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions);
    
public:
	// taskpad support
    virtual HRESULT TaskNotify(IConsole *pConsole, VARIANT *v1, VARIANT *v2);
    virtual MMC_TASK *GetTaskList(LPOLESTR szTaskGroup, LONG *nCount);
	virtual HRESULT GetTaskpadTitle(LPOLESTR *pszTitle);
	virtual HRESULT GetTaskpadDescription(LPOLESTR *pszDescription);
	virtual HRESULT GetTaskpadBackground(MMC_TASK_DISPLAY_OBJECT *pTDO);
	virtual HRESULT GetListpadInfo(MMC_LISTPAD_INFO *lpListPadInfo);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CIceSkate : public CDelegationBase {
public:
    CIceSkate(int i) : id(i), bSelected(false) { }
    virtual ~CIceSkate() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
    bool bSelected;
    
public:
    bool IsSelected() const { return bSelected; }
};

class CIceSkateFolder : public CDelegationBase {
public:
    CIceSkateFolder();
    virtual ~CIceSkateFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Ice Skates (listpad)"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions);
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnListpad(IConsole *pConsole, BOOL bAttaching);
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect);

	// taskpad support
    virtual HRESULT TaskNotify(IConsole *pConsole, VARIANT *v1, VARIANT *v2);
    virtual MMC_TASK *GetTaskList(LPOLESTR szTaskGroup, LONG *nCount);
	virtual HRESULT GetTaskpadTitle(LPOLESTR *pszTitle);
	virtual HRESULT GetTaskpadDescription(LPOLESTR *pszDescription);
	virtual HRESULT GetTaskpadBackground(MMC_TASK_DISPLAY_OBJECT *pTDO);
	virtual HRESULT GetListpadInfo(MMC_LISTPAD_INFO *lpListPadInfo);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CIceSkate *children[NUMBER_OF_CHILDREN];
};

class CPeoplePoweredVehicle : public CDelegationBase {
public:
    CPeoplePoweredVehicle();
    virtual ~CPeoplePoweredVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("People-powered Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { IDM_NEW_PEOPLE = 1 };
    
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 3 };
    CDelegationBase *children[3];
};

#endif // _PEOPLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\people.cpp ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <windows.h>
#include <commctrl.h>
#include <stdio.h>
#include "People.h"

const GUID CPeoplePoweredVehicle::thisGuid = { 0x2974380d, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

const GUID CBicycleFolder::thisGuid = { 0xef163732, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboardFolder::thisGuid = { 0xef163733, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkateFolder::thisGuid = { 0xf6c660b0, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };

const GUID CBicycle::thisGuid = { 0xef163734, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboard::thisGuid = { 0xef163735, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkate::thisGuid = { 0xf6c660b1, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };


//---------------------------------------------------------------------------
//  Creates a string with the format  
//    "res://<Path to this object>/<path to resource>
//
//  It is up to the caller to make sure the memory allocated with 
//  CoTaskMemAlloc for the string is freed.
//  If null is passed in the first parameter, the path to MMC.EXE will be
//  returned, if the instance handle is passed the returned path will point
//  the Snap-in dll.
//
LPOLESTR CreateResourcePath
( 
  HINSTANCE hInst,         //[in] Global instance handle
  LPOLESTR szResource      //[in] Path to stored resource
)
{ 
   _TCHAR szBuffer[MAX_PATH];
            
   ZeroMemory(szBuffer, sizeof(szBuffer));
            
   _tcscpy(szBuffer, _T("res://"));
            
   _TCHAR *szTemp = szBuffer + _tcslen(szBuffer);
   GetModuleFileName(hInst, szTemp, sizeof(szBuffer) - _tcslen(szBuffer));
            
   _tcscat(szBuffer, _T("/"));
   MAKE_TSTRPTR_FROMWIDE(szname, szResource);
   _tcscat(szBuffer, szname);
            
   MAKE_WIDEPTR_FROMTSTR(wszname, szBuffer);
   LPOLESTR szOutBuffer = static_cast<LPOLESTR>(CoTaskMemAlloc((wcslen(wszname) + 1)  * sizeof(WCHAR)));

   wcscpy(szOutBuffer, wszname);
            
   return szOutBuffer;

} //end CreateResoucePath()


static LPOLESTR OleDuplicateString(LPOLESTR lpStr) {
    LPOLESTR tmp = static_cast<LPOLESTR>(CoTaskMemAlloc((wcslen(lpStr) + 1)  * sizeof(WCHAR)));
    wcscpy(tmp, lpStr);

    return tmp;
}


//==============================================================
//
// CPeoplePoweredVehicle implementation
//
//
CPeoplePoweredVehicle::CPeoplePoweredVehicle()
{
    children[0] = new CBicycleFolder;
    children[1] = new CSkateboardFolder;
    children[2] = new CIceSkateFolder;
}

CPeoplePoweredVehicle::~CPeoplePoweredVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        delete children[n];
}

HRESULT CPeoplePoweredVehicle::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;

    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT    |   // relativeID is valid
                SDI_CHILDREN;     // cChildren is valid

            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = 0;

            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );

            _ASSERT( SUCCEEDED(hr) );
        }
    }

    return S_OK;
}

CBicycleFolder::CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CBicycle(n + 1);
    }
}

CBicycleFolder::~CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CBicycleFolder::GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions)
{
	TCHAR taskpad[1024];
    TCHAR szThis[16];

    _ultot((unsigned long)this, szThis, 16);
	_tcscpy(taskpad, _T("horizontal.htm#"));
    _tcscat(taskpad, szThis);
    MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, taskpad);

	*ppViewType = CreateResourcePath( NULL, pszW );

    *pViewOptions = MMC_VIEW_OPTIONS_NONE;
    return S_OK;
}

MMC_TASK *CBicycleFolder::GetTaskList(LPOLESTR szTaskGroup, LONG *nCount)
{
    *nCount = 5;

    MMC_TASK *tasks = new MMC_TASK[*nCount];

    for (int t = 0; t < *nCount; t++) {
        tasks[t].sDisplayObject.eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;
        tasks[t].sDisplayObject.uBitmap.szMouseOverBitmap = CreateResourcePath(g_hinst, L"buttonover.bmp");
        tasks[t].sDisplayObject.uBitmap.szMouseOffBitmap = CreateResourcePath(g_hinst, L"buttonoff.bmp");

        switch (t) {
        case 0:
            tasks[t].szText = OleDuplicateString(L"Tune bicycle");
            tasks[t].szHelpString = OleDuplicateString(L"Click here to Tune bicycle");

            break;
        case 1:
            tasks[t].szText = OleDuplicateString(L"Ride bicycle");
            tasks[t].szHelpString = OleDuplicateString(L"Click here to ride bicycle");

            break;
        case 2:
            tasks[t].szText = OleDuplicateString(L"Stop riding bicycle");
            tasks[t].szHelpString = OleDuplicateString(L"Click here to stop riding bicycle");

            break;
        case 3:
            tasks[t].szText = OleDuplicateString(L"Purchase bicycle");
            tasks[t].szHelpString = OleDuplicateString(L"Click here to purchase bicycle");

        case 4:
            tasks[t].szText = OleDuplicateString(L"Sell bicycle");
            tasks[t].szHelpString = OleDuplicateString(L"Click here to sell bicycle");

            break;
        }

        tasks[t].eActionType = MMC_ACTION_ID;
        tasks[t].nCommandID = t;
    }

    return tasks;
}

HRESULT CBicycleFolder::TaskNotify(IConsole *pConsole, VARIANT *v1, VARIANT *v2)
{
    RESULTDATAITEM rdi;
    IResultData *pResultData;

    ZeroMemory(&rdi, sizeof(RESULTDATAITEM));

    HRESULT hr = S_OK;

    hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);

    if (SUCCEEDED(hr)) {

        rdi.mask = RDI_STATE | RDI_PARAM;  // Use selected state to get param.
        rdi.nState = LVIS_SELECTED | LVIS_FOCUSED;
        rdi.nIndex = -1;  // Start looking for selected item from top of list view

        hr = pResultData->GetNextItem(&rdi);

        pResultData->Release();
    }

    if (SUCCEEDED(hr)) {
        _TCHAR buf[256];

        switch (v1->lVal) {
        case 0:
            wsprintf(buf, _T("Bicycle %d tuned."), rdi.nIndex);

            break;
        case 1:
            wsprintf(buf, _T("Riding bicycle %d."), rdi.nIndex);

            break;
        case 2:
            wsprintf(buf, _T("Not riding bicycle %d."), rdi.nIndex);

            break;
        case 3:
            wsprintf(buf, _T("Bicycle %d purchased."), rdi.nIndex);

            break;
        case 4:
            wsprintf(buf, _T("Bicycle %d sold."), rdi.nIndex);

            break;
        case 102:
            wsprintf(buf, _T("Special bicycle task choosen (%d)."), rdi.nIndex);

            break;
        }

        MessageBox(NULL, buf, _T("Task Notification"), MB_OK | MB_ICONINFORMATION);
    }

    return hr;
}

HRESULT CBicycleFolder::GetTaskpadTitle(LPOLESTR *pszTitle)
{
        *pszTitle = OleDuplicateString(L"Bicycle Tasks");
        return S_OK;
}

HRESULT CBicycleFolder::GetTaskpadDescription(LPOLESTR *pszDescription)
{
        *pszDescription = OleDuplicateString(L"This is a sample task pad for bicycle nodes");
        return S_OK;
}

HRESULT CBicycleFolder::GetTaskpadBackground(MMC_TASK_DISPLAY_OBJECT *pTDO)
{
        pTDO->eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;
        pTDO->uBitmap.szMouseOverBitmap = CreateResourcePath(g_hinst, L"bicycle.bmp");
        return S_OK;
}

HRESULT CBicycleFolder::GetListpadInfo(MMC_LISTPAD_INFO *lpListPadInfo)
{
        lpListPadInfo->szTitle = OleDuplicateString(L"Bicycle");
        lpListPadInfo->szButtonText = OleDuplicateString(L"Special");
        lpListPadInfo->nCommandID = 102;
        return S_OK;
}

HRESULT CBicycleFolder::OnListpad(IConsole *pConsole, BOOL bAttaching)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;
    IImageList  *pImageList  = NULL;

    if (bAttaching) {
        hr = pConsole->QueryResultImageList(&pImageList);
        _ASSERT( SUCCEEDED(hr) );

        hr = pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
                                           (long *)m_pBMapLg, // pointer to a handle
                                           0, // index of the first image in the strip
                                           RGB(0, 128, 128)  // color of the icon mask
            );
        _ASSERT( SUCCEEDED(hr) );

        pImageList->Release();

        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 1, L"Bicycle License      ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

CIceSkateFolder::CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CIceSkate(n + 1);
    }
}

CIceSkateFolder::~CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CIceSkateFolder::GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions)
{
	
	TCHAR taskpad[1024];
    TCHAR szThis[16];

    _ultot((unsigned long)this, szThis, 16);
	_tcscpy(taskpad, _T("listpad.htm#"));
    _tcscat(taskpad, szThis);
    MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, taskpad);

	*ppViewType = CreateResourcePath( NULL, pszW );

    *pViewOptions = MMC_VIEW_OPTIONS_NONE;
    return S_OK;
}

MMC_TASK *CIceSkateFolder::GetTaskList(LPOLESTR szTaskGroup, LONG *nCount)
{
    *nCount = 4;

    MMC_TASK *tasks = new MMC_TASK[*nCount];

    for (int t = 0; t < *nCount; t++) {
        tasks[t].sDisplayObject.eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;
        tasks[t].sDisplayObject.uBitmap.szMouseOverBitmap = CreateResourcePath(g_hinst, L"buttonover.bmp");
        tasks[t].sDisplayObject.uBitmap.szMouseOffBitmap = CreateResourcePath(g_hinst, L"buttonoff.bmp");

        switch (t) {
        case 0:
            tasks[t].szText = OleDuplicateString(L"Sharpen Skate");
            tasks[t].szHelpString = OleDuplicateString(L"Click here to Sharpen skate");

            break;
        case 1:
            tasks[t].szText = OleDuplicateString(L"Tighten skate laces");
            tasks[t].szHelpString = OleDuplicateString(L"Click here to Tighten skate");

            break;
        case 2:
            tasks[t].szText = OleDuplicateString(L"Wear skate");
            tasks[t].szHelpString = OleDuplicateString(L"Click here to Wear skate");

            break;
        case 3:
            tasks[t].szText = OleDuplicateString(L"Remove skate");
            tasks[t].szHelpString = OleDuplicateString(L"Click here to Remove skate");

            break;
        }

        tasks[t].eActionType = MMC_ACTION_ID;
        tasks[t].nCommandID = t;
    }

    return tasks;
}

HRESULT CIceSkateFolder::TaskNotify(IConsole *pConsole, VARIANT *v1, VARIANT *v2)
{
    RESULTDATAITEM rdi;
    IResultData *pResultData;

    ZeroMemory(&rdi, sizeof(RESULTDATAITEM));

    HRESULT hr = S_OK;

    hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);

    if (SUCCEEDED(hr)) {

        rdi.mask = RDI_STATE | RDI_PARAM;  // Use selected state to get param.
        rdi.nState = LVIS_SELECTED | LVIS_FOCUSED;
        rdi.nIndex = -1;  // Start looking for selected item from top of list view

        hr = pResultData->GetNextItem(&rdi);

        pResultData->Release();
    }

    if (SUCCEEDED(hr)) {
        _TCHAR buf[256];

        switch (v1->lVal) {
        case 0:
            wsprintf(buf, _T("Skate %d sharpened."), rdi.nIndex);

            break;
        case 1:
            wsprintf(buf, _T("Skate %d tightened."), rdi.nIndex);

            break;
        case 2:
            wsprintf(buf, _T("Wearing skate %d."), rdi.nIndex);

            break;
        case 3:
            wsprintf(buf, _T("Skate %d removed."), rdi.nIndex);

            break;
        case 101:
            wsprintf(buf, _T("Special skate task choosen (%d)."), rdi.nIndex);

            break;
        }

        MessageBox(NULL, buf, _T("Task Notification"), MB_OK | MB_ICONINFORMATION);
    }

    return hr;
}

HRESULT CIceSkateFolder::GetTaskpadTitle(LPOLESTR *pszTitle)
{
        *pszTitle = OleDuplicateString(L"Iceskate Tasks");
        return S_OK;
}

HRESULT CIceSkateFolder::GetTaskpadDescription(LPOLESTR *pszDescription)
{
        *pszDescription = OleDuplicateString(L"This is a sample task pad for ice skate nodes");
        return S_OK;
}

HRESULT CIceSkateFolder::GetTaskpadBackground(MMC_TASK_DISPLAY_OBJECT *pTDO)
{
        pTDO->eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;
        pTDO->uBitmap.szMouseOverBitmap = CreateResourcePath(g_hinst, L"iceskate.bmp");
        return S_OK;
}

HRESULT CIceSkateFolder::GetListpadInfo(MMC_LISTPAD_INFO *lpListPadInfo)
{
        lpListPadInfo->szTitle = OleDuplicateString(L"Ice Skates");
        lpListPadInfo->szButtonText = OleDuplicateString(L"Special");
        lpListPadInfo->nCommandID = 101;
        return S_OK;
}

HRESULT CIceSkateFolder::OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect)
{
    IConsole2 *pConsole2;
    HRESULT hr = S_OK;

    if (TRUE == bSelect) {
        hr = pConsole->QueryInterface(IID_IConsole2, (void **)&pConsole2);

        if (SUCCEEDED(hr)) {
            hr = pConsole2->SetStatusText(L"Hello, you've selected the ice skate folder");
            pConsole2->Release();
        }
    }

    return hr;
}

HRESULT CIceSkateFolder::OnListpad(IConsole *pConsole, BOOL bAttaching)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;
    IImageList  *pImageList  = NULL;

    if (bAttaching) {
        hr = pConsole->QueryResultImageList(&pImageList);
        _ASSERT( SUCCEEDED(hr) );

        hr = pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
                                           (long *)m_pBMapLg, // pointer to a handle
                                           0, // index of the first image in the strip
                                           RGB(0, 128, 128)  // color of the icon mask
            );
        _ASSERT( SUCCEEDED(hr) );

        pImageList->Release();

        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 1, L"Sharpness           ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

HRESULT CIceSkate::OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect)
{
    bSelected = bSelect ? true : false;

    return S_FALSE;
}

CSkateboardFolder::CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CSkateboard(n + 1);
    }
}

CSkateboardFolder::~CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSkateboardFolder::GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions)
{
	TCHAR taskpad[1024];
    TCHAR szThis[16];

    _ultot((unsigned long)this, szThis, 16);
	_tcscpy(taskpad, _T("default.htm#"));
    _tcscat(taskpad, szThis);
    MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, taskpad);

	*ppViewType = CreateResourcePath( NULL, pszW );

    *pViewOptions = MMC_VIEW_OPTIONS_NONE;
    return S_OK; 
}

MMC_TASK *CSkateboardFolder::GetTaskList(LPOLESTR szTaskGroup, LONG *nCount)
{
    *nCount = 4;

    _TCHAR buf[256];
    MMC_TASK *tasks = new MMC_TASK[*nCount];

    for (int t = 0; t < *nCount; t++) {
        tasks[t].sDisplayObject.eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;
        tasks[t].sDisplayObject.uBitmap.szMouseOverBitmap = CreateResourcePath(g_hinst, L"buttonover.bmp");
        tasks[t].sDisplayObject.uBitmap.szMouseOffBitmap = CreateResourcePath(g_hinst, L"buttonoff.bmp");

        _stprintf(buf, _T("Task #%d"), t);
        MAKE_WIDEPTR_FROMTSTR(wszText, buf);
        tasks[t].szText = OleDuplicateString(wszText);

        _stprintf(buf, _T("Click here to start task #%d"), t);
        MAKE_WIDEPTR_FROMTSTR(wszHelpString, buf);
        tasks[t].szHelpString = OleDuplicateString(wszHelpString);

        tasks[t].eActionType = MMC_ACTION_ID;
        tasks[t].nCommandID = t;
    }

    return tasks;
}

HRESULT CSkateboardFolder::TaskNotify(IConsole *pConsole, VARIANT *v1, VARIANT *v2)
{
    _TCHAR buf[256];

    wsprintf(buf, _T("Skateboard task %ld has been selected."), v1->lVal);

    MessageBox(NULL, buf, _T("Task Notification"), MB_OK | MB_ICONINFORMATION);

    return S_OK;
}

HRESULT CSkateboardFolder::GetTaskpadTitle(LPOLESTR *pszTitle)
{
        *pszTitle = OleDuplicateString(L"Skateboard Tasks");
        return S_OK;
}

HRESULT CSkateboardFolder::GetTaskpadDescription(LPOLESTR *pszDescription)
{
        *pszDescription = OleDuplicateString(L"This is a sample task pad for skateboard nodes");
        return S_OK;
}

HRESULT CSkateboardFolder::GetTaskpadBackground(MMC_TASK_DISPLAY_OBJECT *pTDO)
{
        pTDO->eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;
        pTDO->uBitmap.szMouseOverBitmap = CreateResourcePath(g_hinst, L"skateboard.bmp");
        return S_OK;
}

HRESULT CSkateboardFolder::GetListpadInfo(MMC_LISTPAD_INFO *lpListPadInfo)
{
        return S_FALSE;
}

const _TCHAR *CBicycle::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    if (nCol == 0) {
        _stprintf(buf, _T("Bicycle #%d"), id);
    } else if (nCol == 1) {
        _stprintf(buf, _T("%ld"), (long)this);
    }

    return buf;
}

const _TCHAR *CSkateboard::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Skateboard #%d"), id);

    return buf;
}

const _TCHAR *CIceSkate::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    if (nCol == 0) {
        _stprintf(buf, _T("Ice Skate #%d"), id);
    } else if (nCol == 1) {
        _stprintf(buf, _T("Sharpness %ld"), (long)this);
    }

    return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\registry.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

#define STRINGS_ONLY
#include "globals.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName)       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule,
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;

    assert(dwResult != 0) ;

    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    assert(SUCCEEDED(hr)) ;

        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;
        _tcscat(szKey, pszCLSID) ;

    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;

    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    _tcscat(szKey, _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), _T("Apartment"));

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;


    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;

        MAKE_TSTRPTR_FROMWIDE(pszT, wszCLSID);
        _tcscat(szKey, pszT) ;

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Register the snap-in in the registry.
//
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,         // Class Id for About Class
                       const BOOL fSupportExtensions)
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    LPOLESTR wszAboutCLSID = NULL;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    if (IID_NULL != clsidAbout)
        hr = StringFromCLSID(clsidAbout, &wszAboutCLSID);

        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszAboutCLSID, wszAboutCLSID);


    // Add the CLSID to the registry.
    setSnapInKeyAndValue(pszCLSID, NULL, _T("NameString"), szNameString) ;
    setSnapInKeyAndValue(pszCLSID, _T("StandAlone"), NULL, NULL);
    if (IID_NULL != clsidAbout)
        setSnapInKeyAndValue(pszCLSID, NULL, _T("About"), pszAboutCLSID);

    if (fSupportExtensions) {
        // Build the key NodeType
        setSnapInKeyAndValue(pszCLSID, _T("NodeTypes"), NULL, NULL);

        _TCHAR szKey[64] ;
        _tcscpy(szKey, pszCLSID) ;
        _tcscat(szKey, _T("\\NodeTypes")) ;
        setSnapInKeyAndValue(szKey, pszCLSID, NULL, NULL);
    }

    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    if (IID_NULL != clsidAbout)
        CoTaskMemFree(wszAboutCLSID);

    return S_OK ;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    LPOLESTR wszCLSID = NULL;

    // Get CLSID
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\"));
    _tcscat(szKeyBuf, pszCLSID);

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // free the memory
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }

    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }

    // Close the child.
    RegCloseKey(hKeyChild) ;

    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\")) ;
    _tcscat(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\space.cpp ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#include <stdio.h>
#include "Space.h"
#include "Comp.h"

const GUID CSpaceVehicle::thisGuid = { 0x29743810, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };
const GUID CRocket::thisGuid = { 0x29743811, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSpaceVehicle implementation
//
//
CSpaceVehicle::CSpaceVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CRocket(_T("Rocket"), n+1, 500000, 265, 75000);
    }
}

CSpaceVehicle::~CSpaceVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSpaceVehicle::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Rocket Class", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 1, L"Rocket Weight", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 2, L"Rocket Height", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 3, L"Rocket Payload", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 4, L"Status", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

//==============================================================
//
// CRocket implementation
//
//
CRocket::CRocket(_TCHAR *szName, int id, LONG lWeight, LONG lHeight, LONG lPayload)
: szName(NULL), lWeight(0), lHeight(0), lPayload(0), iStatus(STOPPED)
{
    if (szName) {
        this->szName = new _TCHAR[(_tcslen(szName) + 1) * sizeof(_TCHAR)];
        _tcscpy(this->szName, szName);
    }

    this->nId = id;
    this->lWeight = lWeight;
    this->lHeight = lHeight;
    this->lPayload = lPayload;
}

CRocket::~CRocket()
{
    if (szName)
        delete [] szName;
}

const _TCHAR *CRocket::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    switch (nCol) {
    case 0:
        _stprintf(buf, _T("%s (#%d)"), szName ? szName : _T(""), nId);
        break;

    case 1:
        _stprintf(buf, _T("%ld metric tons"), lWeight);
        break;

    case 2:
        _stprintf(buf, _T("%ld meters"), lHeight);
        break;

    case 3:
        _stprintf(buf, _T("%ld kilos"), lPayload);
        break;

    case 4:
        _stprintf(buf, _T("%s"),
            iStatus == RUNNING ? _T("running") :
        iStatus == PAUSED ? _T("paused") :
        iStatus == STOPPED ? _T("stopped") : _T("unknown"));
        break;

    }

    return buf;
}

HRESULT CRocket::OnRename(LPOLESTR pszNewName)
{
    if (szName) {
        delete [] szName;
        szName = NULL;
    }

    MAKE_TSTRPTR_FROMWIDE(ptrname, pszNewName);
    szName = new _TCHAR[(_tcslen(ptrname) + 1) * sizeof(_TCHAR)];
    _tcscpy(szName, ptrname);

    return S_OK;
}

HRESULT CRocket::OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect)
{
    IConsoleVerb *pConsoleVerb;

    HRESULT hr = pConsole->QueryConsoleVerb(&pConsoleVerb);
    _ASSERT(SUCCEEDED(hr));

    hr = pConsoleVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, FALSE);
    hr = pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, TRUE);

    pConsoleVerb->Release();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\tbarext\about.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPABOUT_H_
#define _SAMPABOUT_H_

#include <tchar.h>
#include <mmc.h>

class CSnapinAbout : public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;
    
public:
    CSnapinAbout();
    ~CSnapinAbout();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
        /* [out] */ LPOLESTR *lpDescription);
        
        STDMETHODIMP GetProvider( 
        /* [out] */ LPOLESTR *lpName);
        
        STDMETHODIMP GetSnapinVersion( 
        /* [out] */ LPOLESTR *lpVersion);
        
        STDMETHODIMP GetSnapinImage( 
        /* [out] */ HICON *hAppIcon);
        
        STDMETHODIMP GetStaticFolderImage( 
        /* [out] */ HBITMAP *hSmallImage,
        /* [out] */ HBITMAP *hSmallImageOpen,
        /* [out] */ HBITMAP *hLargeImage,
        /* [out] */ COLORREF *cMask);
        
        ///////////////////////////////
        // Private Interface 
        ///////////////////////////////
private:
    HRESULT	CSnapinAbout::AllocOleStr(
        LPOLESTR *lpDest, 
        _TCHAR *szBuffer);
};

#endif _SAMPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\tbarext\about.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "About.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

CSnapinAbout::CSnapinAbout()
: m_cref(0)
{
    OBJECT_CREATED
        
        m_hSmallImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    m_hLargeImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_LGBMP), IMAGE_BITMAP, 32, 32, LR_LOADTRANSPARENT);
    
    m_hSmallImageOpen = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMOPEN), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    
    m_hAppIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ICON1));
}

CSnapinAbout::~CSnapinAbout()
{
    if (m_hSmallImage != NULL)
        FreeResource(m_hSmallImage);
    
    if (m_hLargeImage != NULL)
        FreeResource(m_hLargeImage);
    
    if (m_hSmallImageOpen != NULL)
        FreeResource(m_hSmallImageOpen);
    
    if (m_hAppIcon != NULL)
        FreeResource(m_hAppIcon);
    
    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;
    
    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CSnapinAbout::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<ISnapinAbout *>(this);
    else if (IsEqualIID(riid, IID_ISnapinAbout))
        *ppv = static_cast<ISnapinAbout *>(this);
    
    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSnapinAbout::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CSnapinAbout::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    return m_cref;
    
}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription( 
                                                /* [out] */ LPOLESTR *lpDescription)
{
    _TCHAR szDesc[MAX_PATH];
    
    LoadString(g_hinst, IDS_SNAPINDESC, szDesc, sizeof(szDesc));
    
    return AllocOleStr(lpDescription, szDesc);
}


STDMETHODIMP CSnapinAbout::GetProvider( 
                                       /* [out] */ LPOLESTR *lpName)
{
    return AllocOleStr(lpName, _T("Copyright  1998 Microsoft Corporation"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinVersion( 
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return AllocOleStr(lpVersion, _T("1.0"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinImage( 
                                          /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;
    
    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}


STDMETHODIMP CSnapinAbout::GetStaticFolderImage( 
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;
    
    *hSmallImageOpen = m_hSmallImageOpen;
    
    *cMask = RGB(0, 128, 128);
    
    if (*hSmallImage == NULL || *hLargeImage == NULL || *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}

// this allocates a chunk of memory using CoTaskMemAlloc and copies our chars into it
HRESULT CSnapinAbout::AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer)
{
	MAKE_WIDEPTR_FROMTSTR_ALLOC(wszStr, szBuffer);
	*lpDest = wszStr;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\taskpads\space.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SPACE_H
#define _SPACE_H

#include "DeleBase.h"

class CRocket : public CDelegationBase {
public:
    CRocket(_TCHAR *szName, int id, LONG lWeight, LONG lHeight, LONG lPayload);
    virtual ~CRocket();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnRename(LPOLESTR pszNewName);
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect);
    
private:
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    _TCHAR *szName;
    LONG   lWeight;
    LONG   lHeight;
    LONG   lPayload;
    int    nId;
    enum {RUNNING, PAUSED, STOPPED} iStatus;
};

class CSpaceVehicle : public CDelegationBase {
public:
    CSpaceVehicle();
    
    virtual ~CSpaceVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Future Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    enum { IDM_NEW_SPACE = 4 };
    
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CRocket *children[NUMBER_OF_CHILDREN];
};

#endif // _SPACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\tbarext\basesnap.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#ifndef _BASESNAP_H_
#define _BASESNAP_H_

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);
STDAPI DllCanUnloadNow(void);

ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    enum FACTORY_TYPE {TOOLBAREXTENSION = 0, ABOUT = 1};
    
    CClassFactory(FACTORY_TYPE factoryType);
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
private:
    FACTORY_TYPE m_factoryType;
};

#endif _BASESNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\tbarext\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5

#define INDEX_SUN 6
#define INDEX_SNOW 7
#define INDEX_RAIN 8
#define INDEX_CLOUD 9
#define INDEX_WORLD 10
#define INDEX_THUNDER 11


#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\tbarext\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>

#ifndef STRINGS_ONLY
	#define IDM_BUTTON1    0x100
	#define IDM_BUTTON2    0x101

	extern HINSTANCE g_hinst;
	extern ULONG g_uObjects;

	#define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
	#define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

#endif

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(GetProcessHeap(), 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(GetProcessHeap(), 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given a _TCHAR, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszT;
//  pszT = MyGetTStringRoutine();
//  MAKE_WIDEPTR_FROMSTR(pwsz, pszT);
//  MyUseWideStringRoutine(pwsz);
//  ...
#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPWSTR)__TempBuffer##ptrname.GetBuffer(), tstr); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    lstrcpyW((LPWSTR)ptrname, tstr)
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, ptrname, __l##ptrname)
#endif

//
// similarily for MAKE_TSTRPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
// * 2 for DBCS handling in below length computation
//
#ifdef UNICODE
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPTSTR)__TempBuffer##ptrname.GetBuffer(), widestr); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\tbarext\basesnap.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <olectl.h>
#include <initguid.h>
#include "globals.h"
#include "resource.h"
#include "guids.h"
#include "basesnap.h"
#include "tbarExt.h"
#include "About.h"
#include "Registry.h"
#include "Extend.h"

// our globals
HINSTANCE g_hinst;


BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    if ((rclsid != CLSID_CToolBarExtension) && (rclsid != CLSID_CSnapinAbout))
        return CLASS_E_CLASSNOTAVAILABLE;
    
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
    // make the factory passing in the creation function for the type of object they want
    if (rclsid == CLSID_CToolBarExtension)
        pFactory = new CClassFactory(CClassFactory::TOOLBAREXTENSION);
    else if (rclsid == CLSID_CSnapinAbout)
        pFactory = new CClassFactory(CClassFactory::ABOUT);
    
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}


CClassFactory::CClassFactory(FACTORY_TYPE factoryType)
: m_cref(0), m_factoryType(factoryType)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    if (TOOLBAREXTENSION == m_factoryType) {
        pObj = new CToolBarExtension();
    } else {
        pObj = new CSnapinAbout();
    }
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    
    if (FAILED(hr))
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{
    HRESULT hr = SELFREG_E_CLASS;
    
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName));
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, sizeof(szSnapInName));
    
    _TCHAR szAboutName[256];
    
    LoadString(g_hinst, IDS_ABOUTNAME, szAboutName, sizeof(szAboutName));
    
    
    // register our CoClasses
    hr = RegisterServer(g_hinst, 
        CLSID_CToolBarExtension, 
        szName);
    
    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst, 
        CLSID_CSnapinAbout, 
        szAboutName);
    
    // place the registry information for SnapIns
    if SUCCEEDED(hr)
        hr = RegisterSnapin(CLSID_CToolBarExtension, szSnapInName, CLSID_CSnapinAbout);
    
    return hr;
}


STDAPI DllUnregisterServer()
{
    if (UnregisterServer(CLSID_CToolBarExtension) == S_OK)
        return UnregisterSnapin(CLSID_CToolBarExtension);
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\tbarext\extend.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _EXTEND_H
#define _EXTEND_H

struct EXTENSION_NODE
{
    GUID	GUID;
    _TCHAR	szDescription[256];
};

enum EXTENSION_TYPE
{
    NameSpaceExtension,
        ContextMenuExtension, 
        ToolBarExtension,
        PropertySheetExtension,
        TaskExtension,
        DynamicExtension,
		DummyExtension
};

struct EXTENDER_NODE
{
    EXTENSION_TYPE	eType;
    GUID			guidNode;
    GUID			guidExtension;
    _TCHAR			szDescription[256];
};

#endif // _EXTEND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\tbarext\guids.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;


// {20E42DD2-5CCF-11d3-9147-00C04F65B3F9}
DEFINE_GUID(CLSID_CToolBarExtension, 
0x20e42dd2, 0x5ccf, 0x11d3, 0x91, 0x47, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9);


// {3E66FCD0-5CCF-11d3-9147-00C04F65B3F9}
DEFINE_GUID(CLSID_CSnapinAbout, 
0x3e66fcd0, 0x5ccf, 0x11d3, 0x91, 0x47, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\toolbar\about.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "About.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

CSnapinAbout::CSnapinAbout()
: m_cref(0)
{
    OBJECT_CREATED

        m_hSmallImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    m_hLargeImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_LGBMP), IMAGE_BITMAP, 32, 32, LR_LOADTRANSPARENT);

    m_hSmallImageOpen = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMOPEN), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);

    m_hAppIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ICON1));
}

CSnapinAbout::~CSnapinAbout()
{
    if (m_hSmallImage != NULL)
        FreeResource(m_hSmallImage);

    if (m_hLargeImage != NULL)
        FreeResource(m_hLargeImage);

    if (m_hSmallImageOpen != NULL)
        FreeResource(m_hSmallImageOpen);

    if (m_hAppIcon != NULL)
        FreeResource(m_hAppIcon);

    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CSnapinAbout::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<ISnapinAbout *>(this);
    else if (IsEqualIID(riid, IID_ISnapinAbout))
        *ppv = static_cast<ISnapinAbout *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSnapinAbout::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CSnapinAbout::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription(
                                                /* [out] */ LPOLESTR *lpDescription)
{
    _TCHAR szDesc[MAX_PATH];

    LoadString(g_hinst, IDS_SNAPINDESC, szDesc, sizeof(szDesc));

    return AllocOleStr(lpDescription, szDesc);
}


STDMETHODIMP CSnapinAbout::GetProvider(
                                       /* [out] */ LPOLESTR *lpName)
{
    return AllocOleStr(lpName, _T("Copyright  1998 Microsoft Corporation"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinVersion(
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return AllocOleStr(lpVersion, _T("1.0"));
}


STDMETHODIMP CSnapinAbout::GetSnapinImage(
                                          /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;

    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}


STDMETHODIMP CSnapinAbout::GetStaticFolderImage(
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;

    *hSmallImageOpen = m_hSmallImageOpen;

    *cMask = RGB(0, 128, 128);

    if (*hSmallImage == NULL || *hLargeImage == NULL || *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}

// this allocates a chunk of memory using CoTaskMemAlloc and copies our chars into it
HRESULT CSnapinAbout::AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer)
{
        MAKE_WIDEPTR_FROMTSTR_ALLOC(wszStr, szBuffer);
        *lpDest = wszStr;


    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\tbarext\registry.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

#define STRINGS_ONLY
#include "Extend.h"
#include "globals.h"

// list all of the nodes that we extend

EXTENDER_NODE _NodeExtensions[] = {
    {ToolBarExtension,
    {0x29743811, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28}},
    {0x20e42dd2, 0x5ccf, 0x11d3, {0x91, 0x47, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9}},
    _T("Extension to the Vehicle Node Toolbar")},

    {DummyExtension,
    NULL,
    NULL,
    NULL}
};

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName)       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule, 
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;
    
    assert(dwResult != 0) ;
    
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    assert(SUCCEEDED(hr)) ;

	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;
	_tcscat(szKey, pszCLSID) ;
    
    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;
    
    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    _tcscat(szKey, _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), _T("Apartment"));
    
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    
    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    
    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;

	MAKE_TSTRPTR_FROMWIDE(pszT, wszCLSID);
	_tcscat(szKey, pszT) ;
    
    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.
    
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    
    return S_OK ;
}

//
// Register the snap-in in the registry.
//

HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions)
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    LPOLESTR wszAboutCLSID = NULL;
    LPOLESTR wszExtendCLSID = NULL;
    LPOLESTR wszNodeCLSID = NULL;
    EXTENDER_NODE *pNodeExtension;
    _TCHAR szKeyBuf[1024] ;
    HKEY hKey;


    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    if (IID_NULL != clsidAbout)
        hr = StringFromCLSID(clsidAbout, &wszAboutCLSID);

	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
	MAKE_TSTRPTR_FROMWIDE(pszAboutCLSID, wszAboutCLSID);

   
    // Add the CLSID to the registry.
    setSnapInKeyAndValue(pszCLSID, NULL, _T("NameString"), szNameString) ;
    if (IID_NULL != clsidAbout)
        setSnapInKeyAndValue(pszCLSID, NULL, _T("About"), pszAboutCLSID);
    
    if (fSupportExtensions) {
        // Build the key NodeType 
        setSnapInKeyAndValue(pszCLSID, _T("NodeTypes"), NULL, NULL);
        
        _TCHAR szKey[64] ;
        _tcscpy(szKey, pszCLSID) ;
        _tcscat(szKey, _T("\\NodeTypes")) ;
        setSnapInKeyAndValue(szKey, pszCLSID, NULL, NULL);
    }

    // register each of the node extensions
    for (pNodeExtension = &(_NodeExtensions[0]);*pNodeExtension->szDescription;pNodeExtension++)
    {
        hr = StringFromCLSID(pNodeExtension->guidNode, &wszExtendCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszExtendCLSID, wszExtendCLSID);
        _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\NodeTypes\\"));
        _tcscat(szKeyBuf, pszExtendCLSID);

        switch (pNodeExtension->eType) {
        case ToolBarExtension:
            _tcscat(szKeyBuf, _T("\\Extensions\\ToolBar"));
            break;
        default:
            break;
        }

        // Create and open key and subkey.
        long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
            szKeyBuf,
            0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, NULL,
            &hKey, NULL) ;

        if (lResult != ERROR_SUCCESS)
        {
            return FALSE ;
        }

        hr = StringFromCLSID(pNodeExtension->guidExtension, &wszNodeCLSID);
        assert(SUCCEEDED(hr));

        MAKE_TSTRPTR_FROMWIDE(pszNodeCLSID, wszNodeCLSID);
        // Set the Value.
        if (pNodeExtension->szDescription != NULL)
        {
            RegSetValueEx(hKey, pszNodeCLSID, 0, REG_SZ,
                (BYTE *)pNodeExtension->szDescription,
                (_tcslen(pNodeExtension->szDescription)+1)*sizeof(_TCHAR)) ;
        }

        RegCloseKey(hKey) ;

        CoTaskMemFree(wszExtendCLSID);
        CoTaskMemFree(wszNodeCLSID);
    }


    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    if (IID_NULL != clsidAbout)
        CoTaskMemFree(wszAboutCLSID);
    
    return S_OK ;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    LPOLESTR wszCLSID = NULL;
    
    // Get CLSID
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
    
    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));
    
    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\"));
    _tcscat(szKeyBuf, pszCLSID);
    
    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.
    
    // free the memory
    CoTaskMemFree(wszCLSID);
    
    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }
    
    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }
    
    // Close the child.
    RegCloseKey(hKeyChild) ;
    
    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;
    
    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));
    
    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\")) ;
    _tcscat(szKeyBuf, szKey) ;
    
    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\toolbar\basesnap.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <olectl.h>
#include <initguid.h>
#include "guids.h"
#include "basesnap.h"
#include "Comp.h"
#include "CompData.h"
#include "About.h"
#include "Registry.h"

// our globals
HINSTANCE g_hinst;

BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    if ((rclsid != CLSID_CComponentData) && (rclsid != CLSID_CSnapinAbout))
        return CLASS_E_CLASSNOTAVAILABLE;
    
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
    // make the factory passing in the creation function for the type of object they want
    if (rclsid == CLSID_CComponentData)
        pFactory = new CClassFactory(CClassFactory::COMPONENT);
    else if (rclsid == CLSID_CSnapinAbout)
        pFactory = new CClassFactory(CClassFactory::ABOUT);
    
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}


CClassFactory::CClassFactory(FACTORY_TYPE factoryType)
: m_cref(0), m_factoryType(factoryType)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    if (COMPONENT == m_factoryType) {
        pObj = new CComponentData();
    } else {
        pObj = new CSnapinAbout();
    }
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    
    if (FAILED(hr))
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{
    HRESULT hr = SELFREG_E_CLASS;
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName));
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, sizeof(szSnapInName));
    
    _TCHAR szAboutName[256];
    
    LoadString(g_hinst, IDS_ABOUTNAME, szAboutName, sizeof(szAboutName));
    
    // register our CoClasses
    hr = RegisterServer(g_hinst, 
        CLSID_CComponentData, 
        szName);
    
    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst, 
        CLSID_CSnapinAbout, 
        szAboutName);
    
    // place the registry information for SnapIns
    if SUCCEEDED(hr)
        hr = RegisterSnapin(CLSID_CComponentData, szSnapInName, CLSID_CSnapinAbout, FALSE);
    
    return hr;
}


STDAPI DllUnregisterServer()
{
    if (UnregisterServer(CLSID_CComponentData) == S_OK)
        return UnregisterSnapin(CLSID_CComponentData);
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\toolbar\about.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPABOUT_H_
#define _SAMPABOUT_H_

#include <tchar.h>
#include <mmc.h>

class CSnapinAbout : public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;
    
public:
    CSnapinAbout();
    ~CSnapinAbout();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
        /* [out] */ LPOLESTR *lpDescription);
        
        STDMETHODIMP GetProvider( 
        /* [out] */ LPOLESTR *lpName);
        
        STDMETHODIMP GetSnapinVersion( 
        /* [out] */ LPOLESTR *lpVersion);
        
        STDMETHODIMP GetSnapinImage( 
        /* [out] */ HICON *hAppIcon);
        
        STDMETHODIMP GetStaticFolderImage( 
        /* [out] */ HBITMAP *hSmallImage,
        /* [out] */ HBITMAP *hSmallImageOpen,
        /* [out] */ HBITMAP *hLargeImage,
        /* [out] */ COLORREF *cMask);
        
        ///////////////////////////////
        // Private Interface 
        ///////////////////////////////
private:
    HRESULT	CSnapinAbout::AllocOleStr(
        LPOLESTR *lpDest, 
        _TCHAR *szBuffer);
};

#endif _SAMPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\toolbar\basesnap.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#ifndef _BASESNAP_H_
#define _BASESNAP_H_

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);
STDAPI DllCanUnloadNow(void);

ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    enum FACTORY_TYPE {COMPONENT = 0, ABOUT = 1};
    
    CClassFactory(FACTORY_TYPE factoryType);
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
private:
    FACTORY_TYPE m_factoryType;
};

#endif _BASESNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\tbarext\registry.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions = FALSE);

HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\toolbar\dataobj.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DataObj.h"
#include "guids.h"
#include "DeleBase.h"

//
// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SZNODETYPE _T("CCF_SZNODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

#define _T_CCF_INTERNAL_SNAPIN _T("{2479DB32-5276-11d2-94F5-00C04FB92EC2}")

    // These are the clipboard formats that we must supply at a minimum.
    // mmc.h actually defined these. We can make up our own to use for
    // other reasons. We don't need any others at this time.
UINT CDataObject::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CDataObject::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CDataObject::s_cfSZNodeType  = RegisterClipboardFormat(_T_CCF_SZNODETYPE);
UINT CDataObject::s_cfSnapinClsid = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);
UINT CDataObject::s_cfInternal    = RegisterClipboardFormat(_T_CCF_INTERNAL_SNAPIN);


CDataObject::CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context)
: m_lCookie(cookie), m_context(context), m_cref(0)
{
}

CDataObject::~CDataObject()
{
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IDataObject *>(this);
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppv = static_cast<IDataObject *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CDataObject::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
//
HRESULT CDataObject::GetDataHere(
                                 FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure
                                 STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure
                                 )
{
    const   CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pStream = NULL;

    CDelegationBase *base = GetBaseNodeObject();

    HRESULT hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( FAILED(hr) )
        return hr;                       // Minimal error checking

    hr = DV_E_FORMATETC;                 // Unknown format

    if (cf == s_cfDisplayName) {
        const _TCHAR *pszName = base->GetDisplayName();

                MAKE_WIDEPTR_FROMTSTR(wszName, pszName);

                // get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(pszName);
        ulSizeofName++;                      // Count null character
        ulSizeofName *= sizeof(WCHAR);

        hr = pStream->Write(wszName, ulSizeofName, NULL);
    } else if (cf == s_cfNodeType) {
        const GUID *pGUID = (const GUID *)&base->getNodeType();

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfSZNodeType) {
        LPOLESTR szGuid;
        hr = StringFromCLSID(base->getNodeType(), &szGuid);

        if (SUCCEEDED(hr)) {
            hr = pStream->Write(szGuid, wcslen(szGuid), NULL);
            CoTaskMemFree(szGuid);
        }
    } else if (cf == s_cfSnapinClsid) {
        const GUID *pGUID = NULL;
        pGUID = &CLSID_CComponentData;

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfInternal) {
        // we are being asked to get our this pointer from the IDataObject interface
        // only our own snap-in objects will know how to do this.
        CDataObject *pThis = this;
        hr = pStream->Write( &pThis, sizeof(CDataObject*), NULL );
    }

    pStream->Release();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Global helper functions to help work with dataobjects and
// clipboard formats


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfInternal clipboard format
//
CDataObject* GetOurDataObject (
                               LPDATAOBJECT lpDataObject      // [in] IComponent pointer
                               )
{
    HRESULT       hr      = S_OK;
    CDataObject *pSDO     = NULL;

	// check to see if the data object is a special data object.
	if ( IS_SPECIAL_DATAOBJECT (lpDataObject) )
	{
		//Code for handling a special data object goes here.

		//Note that the MMC SDK samples do not handle
		//special data objects, so we exit if we get one.
		return NULL;
	}

    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { CDataObject::s_cfInternal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(CDataObject *));

    if (!stgmedium.hGlobal)     {
        hr = E_OUTOFMEMORY;
    }

    if SUCCEEDED(hr)
        // Attempt to get data from the object
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );

    // stgmedium now has the data we need
    if (SUCCEEDED(hr))  {
        pSDO = *(CDataObject **)(stgmedium.hGlobal);
    }

    // if we have memory free it
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);

    return pSDO;

} // end GetOurDataObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\tbarext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_HELPFILE                    1
#define IDS_SNAPINDESC                  2
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDI_ICON1                       108
#define IDR_TOOLBAR1                    112
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDB_SMOPEN                      124
#define IDB_SMBMP                       125
#define IDB_LGBMP                       126
#define IDB_ROCKET                      40004
#define IDB_CAR                         40005
#define IDB_PLANE                       40006
#define IDB_BIKE                        40007
#define IDB_ROCKET2                     40008
#define IDB_CAR2                        40009
#define IDB_PLANE2                      40010
#define IDB_BIKE2                       40011
#define IDB_CLOSED2                     40012
#define IDB_OPEN2                       40013
#define IDB_CLOSED                      40014
#define IDB_OPEN                        40015
#define ID_BUTTON40016                  40016
#define ID_BUTTON40017                  40017
#define ID_BUTTON40018                  40018
#define ID_BUTTON40019                  40019
#define ID_BUTTON40020                  40020
#define ID_BUTTON40021                  40021
#define ID_BUTTONSTART                  40021
#define ID_BUTTON40022                  40022
#define ID_BUTTONPAUSE                  40022
#define ID_BUTTON40023                  40023
#define ID_BUTTONSTOP                   40023
#define ID_BUTTON40024                  40024
#define ID_BUTTON40025                  40025
#define ID_BUTTON40026                  40026

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        127
#define _APS_NEXT_COMMAND_VALUE         40027
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\tbarext\tbarext.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "tbarExt.h"
#include "globals.h"
#include "resource.h"
#include <commctrl.h>        // Needed for button styles...
#include <crtdbg.h>
#include "resource.h"
#include <stdio.h>

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))


// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

// These are the clipboard formats that we must supply at a minimum.
// mmc.h actually defined these. We can make up our own to use for
// other reasons. We don't need any others at this time.
UINT CToolBarExtension::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CToolBarExtension::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CToolBarExtension::s_cfSnapInCLSID = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);


CToolBarExtension::CToolBarExtension() : m_cref(0), m_ipControlBar(NULL), 
										 m_ipToolbar(NULL) 
{
    OBJECT_CREATED
}

CToolBarExtension::~CToolBarExtension()
{
    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CToolBarExtension::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IExtendControlbar *>(this);
    else if (IsEqualIID(riid, IID_IExtendControlbar))
        *ppv = static_cast<IExtendControlbar *>(this);
    
    if (*ppv) 
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CToolBarExtension::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CToolBarExtension::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    
    return m_cref;
}

HRESULT CToolBarExtension::ExtractData( IDataObject* piDataObject,
                                           CLIPFORMAT   cfClipFormat,
                                           BYTE*        pbData,
                                           DWORD        cbData )
{
    HRESULT hr = S_OK;
    
    FORMATETC formatetc = {cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL};
    
    stgmedium.hGlobal = ::GlobalAlloc(GPTR, cbData);
    do // false loop
    {
        if (NULL == stgmedium.hGlobal)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        hr = piDataObject->GetDataHere( &formatetc, &stgmedium );
        if ( FAILED(hr) )
        {
            break;
        }
        
        BYTE* pbNewData = reinterpret_cast<BYTE*>(stgmedium.hGlobal);
        if (NULL == pbNewData)
        {
            hr = E_UNEXPECTED;
            break;
        }
        ::memcpy( pbData, pbNewData, cbData );
    } while (FALSE); // false loop
    
    if (NULL != stgmedium.hGlobal)
    {
        ::GlobalFree(stgmedium.hGlobal);
    }
    return hr;
} // ExtractData()

HRESULT CToolBarExtension::ExtractString( IDataObject *piDataObject,
                                             CLIPFORMAT   cfClipFormat,
                                             WCHAR       *pstr,
                                             DWORD        cchMaxLength)
{
    return ExtractData( piDataObject, cfClipFormat, (PBYTE)pstr, cchMaxLength );
}

HRESULT CToolBarExtension::ExtractSnapInCLSID( IDataObject* piDataObject, CLSID* pclsidSnapin )
{
    return ExtractData( piDataObject, s_cfSnapInCLSID, (PBYTE)pclsidSnapin, sizeof(CLSID) );
}

HRESULT CToolBarExtension::ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* pguidObjectType )
{
    return ExtractData( piDataObject, s_cfNodeType, (PBYTE)pguidObjectType, sizeof(GUID) );
}

///////////////////////////////
// Interface IExtendControlBar
///////////////////////////////
static MMCBUTTON SnapinButtons1[] =
{
    { 0, ID_BUTTONSTART, TBSTATE_ENABLED, TBSTYLE_GROUP, L"Extension - Start Vehicle", L"Extension - Start Vehicle" },
    { 1, ID_BUTTONPAUSE, TBSTATE_ENABLED, TBSTYLE_GROUP, L"Extension - Pause Vehicle", L"Extension - Pause Vehicle"},
    { 2, ID_BUTTONSTOP,  TBSTATE_ENABLED, TBSTYLE_GROUP, L"Extension - Stop Vehicle",  L"Extension - Stop Vehicle" },
};

HRESULT CToolBarExtension::SetControlbar(
                                  /* [in] */ LPCONTROLBAR pControlbar)
{
    HRESULT hr = S_OK;

	//
    //  Clean up
    //

    // if we've got a cached toolbar, release it
    if (m_ipToolbar) {
        m_ipToolbar->Release();
        m_ipToolbar = NULL;
    }

    // if we've got a cached control bar, release it
    if (m_ipControlBar) {
        m_ipControlBar->Release();
        m_ipControlBar = NULL;
    }

    //
    // Install new pieces if necessary
    //

    // if a new one came in, cache and AddRef
    if (pControlbar) {
        m_ipControlBar = pControlbar;
        m_ipControlBar->AddRef();

        hr = m_ipControlBar->Create(TOOLBAR,  // type of control to be created
            dynamic_cast<IExtendControlbar *>(this),
            reinterpret_cast<IUnknown **>(&m_ipToolbar));
        _ASSERT(SUCCEEDED(hr));

        // add the bitmap to the toolbar
        HBITMAP hbmp = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_TOOLBAR1));
        hr = m_ipToolbar->AddBitmap(3, hbmp, 16, 16, RGB(0, 128, 128)); // NOTE, hardcoded value 3
        _ASSERT(SUCCEEDED(hr));

        // Add the buttons to the toolbar
        hr = m_ipToolbar->AddButtons(ARRAYLEN(SnapinButtons1), SnapinButtons1);
        _ASSERT(SUCCEEDED(hr));
    }

    return hr;
}

HRESULT CToolBarExtension::ControlbarNotify(
                                     /* [in] */ MMC_NOTIFY_TYPE event,
                                     /* [in] */ LPARAM arg,
                                     /* [in] */ LPARAM param)
{

    _TCHAR pszMsg[255];

	BYTE *pbVehicleStatus = NULL;
    
	HRESULT hr = S_OK;
 
    if (event == MMCN_SELECT) {

		BOOL bScope = (BOOL) LOWORD(arg);
        BOOL bSelect = (BOOL) HIWORD(arg);

		if (bSelect) {

			// Always make sure the toolbar is attached
			hr = m_ipControlBar->Attach(TOOLBAR, m_ipToolbar);

			// Set button states

			//fake value to set toolbar button states
			iStatus = RUNNING;
			SetToolbarButtons(iStatus);

		} else {
			// Always make sure the toolbar is detached
			hr = m_ipControlBar->Detach(m_ipToolbar);
		}

    } else if (event == MMCN_BTN_CLICK) {
		//the arg parameter contains the data object from the primary
		//snap-in. Use it to get the display name of the currently selected item
        WCHAR pszName[255];
		HRESULT hr = ExtractString(reinterpret_cast<IDataObject *>(arg), s_cfDisplayName, pszName, sizeof(pszName));
        MAKE_TSTRPTR_FROMWIDE(ptrname, pszName);

		switch ((int)param)
		{
		case ID_BUTTONSTART:
			iStatus = RUNNING;
			break;

		case ID_BUTTONPAUSE:
			iStatus = PAUSED;
			break;

		case ID_BUTTONSTOP:
			iStatus = STOPPED;
			break;
		}
			

		_stprintf(pszMsg, _T("%s selected and extension button %s pressed"), ptrname, 
			(long)param == ID_BUTTONSTART ? _T("1") :
		(long)param == ID_BUTTONPAUSE ? _T("2") :
		(long)param == ID_BUTTONSTOP ? _T("3") : _T("!!!unknown command!!!"));

		
        ::MessageBox(NULL, pszMsg, _T("Messagebox from Toolbar Extension"), MB_OK|MB_ICONEXCLAMATION);

		//Reset toolbar button states
		SetToolbarButtons(iStatus);

    }

    return hr;
}

HRESULT CToolBarExtension::SetToolbarButtons(STATUS iVehicleStatus)
{

	HRESULT hr = S_OK;
	
	switch (iVehicleStatus)
	{
	case RUNNING:
		m_ipToolbar->SetButtonState(ID_BUTTONSTART, BUTTONPRESSED, TRUE);
		m_ipToolbar->SetButtonState(ID_BUTTONSTART, ENABLED, FALSE);
		m_ipToolbar->SetButtonState(ID_BUTTONPAUSE, BUTTONPRESSED, FALSE);
		m_ipToolbar->SetButtonState(ID_BUTTONPAUSE, ENABLED, TRUE);
		m_ipToolbar->SetButtonState(ID_BUTTONSTOP, BUTTONPRESSED, FALSE);
		m_ipToolbar->SetButtonState(ID_BUTTONSTOP, ENABLED, TRUE);
		break;

	case PAUSED:
		m_ipToolbar->SetButtonState(ID_BUTTONSTART, BUTTONPRESSED, FALSE);
		m_ipToolbar->SetButtonState(ID_BUTTONSTART, ENABLED, TRUE);
		m_ipToolbar->SetButtonState(ID_BUTTONPAUSE, BUTTONPRESSED, TRUE);
		m_ipToolbar->SetButtonState(ID_BUTTONPAUSE, ENABLED, FALSE);
		m_ipToolbar->SetButtonState(ID_BUTTONSTOP, BUTTONPRESSED, FALSE);
		m_ipToolbar->SetButtonState(ID_BUTTONSTOP, ENABLED, TRUE);
		break;

	case STOPPED:
		m_ipToolbar->SetButtonState(ID_BUTTONSTART, BUTTONPRESSED, FALSE);
		m_ipToolbar->SetButtonState(ID_BUTTONSTART, ENABLED, TRUE);
		m_ipToolbar->SetButtonState(ID_BUTTONPAUSE, BUTTONPRESSED, FALSE);
		m_ipToolbar->SetButtonState(ID_BUTTONPAUSE, ENABLED, TRUE);
		m_ipToolbar->SetButtonState(ID_BUTTONSTOP, BUTTONPRESSED, TRUE);
		m_ipToolbar->SetButtonState(ID_BUTTONSTOP, ENABLED, FALSE);
		break;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\toolbar\dataobj.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPDATAOBJECT_H_
#define _SAMPDATAOBJECT_H_

#include <mmc.h>
#include "DeleBase.h"

class CDataObject : public IDataObject
{
private:
    ULONG				m_cref;
    MMC_COOKIE			m_lCookie;
    DATA_OBJECT_TYPES   m_context;
    
public:
    CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context);
    ~CDataObject();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // IDataObject methods 
    ///////////////////////////////
    STDMETHODIMP GetDataHere (FORMATETC *pformatetc, STGMEDIUM *pmedium);
    
    // The rest are not implemented
    STDMETHODIMP GetData (LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumFormatEtc (DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };
    
    STDMETHODIMP QueryGetData (LPFORMATETC lpFormatetc) 
    { return E_NOTIMPL; };
    
    STDMETHODIMP GetCanonicalFormatEtc (LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    
    STDMETHODIMP SetData (LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DAdvise (LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DUnadvise (DWORD dwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumDAdvise (LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };
    
    ///////////////////////////////
    // Custom Methods
    ///////////////////////////////
    
    CDelegationBase *GetBaseNodeObject() {
        return (CDelegationBase *)m_lCookie;
    }
    
    DATA_OBJECT_TYPES GetContext() {
        return m_context;
    }
    
public:
    // clipboard formats
    static UINT s_cfSZNodeType;
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
    static UINT s_cfInternal;
    
};

HRESULT ExtractFromDataObject(IDataObject *lpDataObject,UINT cf,ULONG cb,HGLOBAL *phGlobal);
CDataObject* GetOurDataObject(IDataObject *lpDataObject);
BOOL IsMMCMultiSelectDataObject(IDataObject *lpDataObject);

#endif _SAMPDATAOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\tbarext\tbarext.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _CToolBarExtension_H_
#define _CToolBarExtension_H_

#include <tchar.h>
#include <mmc.h>

class CToolBarExtension : public IExtendControlbar
{
    
private:
    ULONG			m_cref;

    IControlbar*    m_ipControlBar;
    IToolbar*       m_ipToolbar;

    enum STATUS {RUNNING, PAUSED, STOPPED} iStatus;

    HRESULT ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* pguidObjectType );
    HRESULT ExtractSnapInCLSID( IDataObject* piDataObject, CLSID* pclsidSnapin );
    HRESULT ExtractString( IDataObject *piDataObject,CLIPFORMAT cfClipFormat, WCHAR *pstr, DWORD cchMaxLength);
    HRESULT ExtractData( IDataObject *piDataObject,CLIPFORMAT cfClipFormat, BYTE *pbData, DWORD cbData );

	HRESULT SetToolbarButtons(STATUS iVehicleStatus);
    
    // clipboard format
    static UINT s_cfDisplayName;
    static UINT s_cfSnapInCLSID;
    static UINT s_cfNodeType;
    
public:
    CToolBarExtension();
    ~CToolBarExtension();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IExtendControlBar
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetControlbar( 
    /* [in] */ LPCONTROLBAR pControlbar);
            
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ControlbarNotify( 
    /* [in] */ MMC_NOTIFY_TYPE event,
    /* [in] */ LPARAM arg,
    /* [in] */ LPARAM param);

	public:
    IToolbar *getToolbar() { return m_ipToolbar; }
};


#endif _CToolBarExtension_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\toolbar\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>

#ifndef STRINGS_ONLY
        #define IDM_BUTTON1    0x100
        #define IDM_BUTTON2    0x101

        extern HINSTANCE g_hinst;
        extern ULONG g_uObjects;

        #define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
        #define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

        // uncomment the following #define to enable message cracking
        // #define MMC_CRACK_MESSAGES
        void MMCN_Crack(BOOL bComponentData,
                                        IDataObject *pDataObject,
                                        IComponentData *pCompData,
                                        IComponent *pComp,
                                        MMC_NOTIFY_TYPE event,
                                        LPARAM arg,
                                        LPARAM param);
#endif

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(GetProcessHeap(), 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(GetProcessHeap(), 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given a _TCHAR, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszT;
//  pszT = MyGetTStringRoutine();
//  MAKE_WIDEPTR_FROMSTR(pwsz, pszT);
//  MyUseWideStringRoutine(pwsz);
//  ...
#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPWSTR)__TempBuffer##ptrname.GetBuffer(), tstr); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    lstrcpyW((LPWSTR)ptrname, tstr)
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, ptrname, __l##ptrname)
#endif

//
// similarily for MAKE_TSTRPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
// * 2 for DBCS handling in below length computation
//
#ifdef UNICODE
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPTSTR)__TempBuffer##ptrname.GetBuffer(), widestr); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\toolbar\comp.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMP_H_
#define _SAMPCOMP_H_

#include <mmc.h>

class CComponent : public IComponent,
IExtendControlbar

{
private:
    ULONG				m_cref;
    
    IConsole*		m_ipConsole;
    IDisplayHelp*	m_ipDisplayHelp;
    IControlbar*    m_ipControlBar;
    IToolbar*       m_ipToolbar;
    
    class CComponentData *m_pComponentData;
    
    public:
        CComponent(CComponentData *parent);
        ~CComponent();
        
        ///////////////////////////////
        // Interface IUnknown
        ///////////////////////////////
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        
        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ MMC_COOKIE cookie);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);
            
            ///////////////////////////////
            // Interface IExtendControlBar
            ///////////////////////////////
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetControlbar( 
            /* [in] */ LPCONTROLBAR pControlbar);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ControlbarNotify( 
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
            
    public:
        IToolbar *getToolbar() { return m_ipToolbar; }
};

#endif _SAMPCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\toolbar\compdata.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMPDATA_H_
#define _SAMPCOMPDATA_H_

#include <mmc.h>
#include "DeleBase.h"
#include "StatNode.h"
#include "Comp.h"

class CComponentData : public IComponentData,
ISnapinHelp
{
    friend class CComponent;
    
private:
    ULONG				m_cref;
    LPCONSOLE			m_ipConsole;
    LPCONSOLENAMESPACE	m_ipConsoleNameSpace;
    
    CStaticNode     *m_pStaticNode;
    
    WCHAR            m_HelpFile[MAX_PATH];
    
public:
    CComponentData();
    ~CComponentData();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IComponentData
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
        /* [in] */ LPUNKNOWN pUnknown);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent( 
        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
        /* [in] */ LPDATAOBJECT lpDataObject,
        /* [in] */ MMC_NOTIFY_TYPE event,
        /* [in] */ LPARAM arg,
        /* [in] */ LPARAM param);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
        /* [in] */ MMC_COOKIE cookie,
        /* [in] */ DATA_OBJECT_TYPES type,
        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
        /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
        /* [in] */ LPDATAOBJECT lpDataObjectA,
        /* [in] */ LPDATAOBJECT lpDataObjectB);
        
        ///////////////////////////////
        // Interface ISnapinHelp
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetHelpTopic( 
        /* [out] */ LPOLESTR __RPC_FAR *lpCompiledHelpFile);
        
public:
    // CComponent *getComponent() { return m_pComponent; }
};

#endif _SAMPCOMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\toolbar\comp.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "DataObj.h"
#include <commctrl.h>        // Needed for button styles...
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "DeleBase.h"
#include "CompData.h"

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

CComponent::CComponent(CComponentData *parent)
: m_pComponentData(parent), m_cref(0), m_ipConsole(NULL)
{
    OBJECT_CREATED

        m_ipDisplayHelp = NULL;
    m_ipControlBar  = NULL;
    m_ipToolbar     = NULL;
}

CComponent::~CComponent()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IComponent))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IExtendControlbar))
        *ppv = static_cast<IExtendControlbar *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponent::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponent::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface IComponent
///////////////////////////////
STDMETHODIMP CComponent::Initialize(
                                    /* [in] */ LPCONSOLE lpConsole)
{
    HRESULT hr = S_OK;

    // Save away all the interfaces we'll need.
    // Fail if we can't QI the required interfaces.

    m_ipConsole = lpConsole;
    m_ipConsole->AddRef();

    hr = m_ipConsole->QueryInterface(IID_IDisplayHelp, (void **)&m_ipDisplayHelp);

    return hr;
}

STDMETHODIMP CComponent::Notify(
                                /* [in] */ LPDATAOBJECT lpDataObject,
                                /* [in] */ MMC_NOTIFY_TYPE event,
                                /* [in] */ LPARAM arg,
                                /* [in] */ LPARAM param)
{
    MMCN_Crack(FALSE, lpDataObject, NULL, this, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)      {
    case MMCN_ADD_IMAGES:
        hr = base->OnAddImages((IImageList *)arg, (HSCOPEITEM)param);
        break;

    case MMCN_SELECT:
        // We do not set any standard verbs now.
        break;

    case MMCN_SHOW:
        hr = base->OnShow(m_ipConsole, (BOOL)arg, (HSCOPEITEM)param);
        break;

    case MMCN_CONTEXTHELP:
        hr = base->OnShowContextHelp(m_ipDisplayHelp, m_pComponentData->m_HelpFile);
        break;
    }

    return hr;
}

STDMETHODIMP CComponent::Destroy(
                                 /* [in] */ MMC_COOKIE cookie)
{
    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    if (m_ipDisplayHelp) {
        m_ipDisplayHelp->Release();
        m_ipDisplayHelp = NULL;
    }

    if (m_ipToolbar) {
        m_ipToolbar->Release();
        m_ipToolbar = NULL;
    }

    if (m_ipControlBar) {
        m_ipControlBar->Release();
        m_ipControlBar = NULL;
    }

    return S_OK;
}


STDMETHODIMP CComponent::QueryDataObject(
                                         /* [in] */ MMC_COOKIE cookie,
                                         /* [in] */ DATA_OBJECT_TYPES type,
                                         /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pComponentData->m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

STDMETHODIMP CComponent::GetResultViewType(
                                           /* [in] */ MMC_COOKIE cookie,
                                           /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
                                           /* [out] */ long __RPC_FAR *pViewOptions)
{
    CDelegationBase *base = (CDelegationBase *)cookie;

    //
    // Ask for default listview.
    //
    if (base == NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
        *ppViewType = NULL;
    }
    else
        return base->GetResultViewType(ppViewType, pViewOptions);

    return S_OK;
}

STDMETHODIMP CComponent::GetDisplayInfo(
                                        /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem)
{
    HRESULT hr = S_OK;
    CDelegationBase *base = NULL;

    // if they are asking for the RDI_STR we have one of those to give

    if (pResultDataItem->lParam) {
        base = (CDelegationBase *)pResultDataItem->lParam;
        if (pResultDataItem->mask & RDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName(pResultDataItem->nCol);
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pResultDataItem->str = pszW;
        }

        if (pResultDataItem->mask & RDI_IMAGE) {
            pResultDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}


STDMETHODIMP CComponent::CompareObjects(
                                        /* [in] */ LPDATAOBJECT lpDataObjectA,
                                        /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////
// Interface IExtendControlBar
///////////////////////////////
static MMCBUTTON SnapinButtons1[] =
{
    { 0, ID_BUTTONSTART, TBSTATE_ENABLED, TBSTYLE_GROUP, L"Start Vehicle", L"Start Vehicle" },
    { 1, ID_BUTTONPAUSE, TBSTATE_ENABLED, TBSTYLE_GROUP, L"Pause Vehicle", L"Pause Vehicle"},
    { 2, ID_BUTTONSTOP,  TBSTATE_ENABLED, TBSTYLE_GROUP, L"Stop Vehicle",  L"Stop Vehicle" },
};

HRESULT CComponent::SetControlbar(
                                  /* [in] */ LPCONTROLBAR pControlbar)
{
    HRESULT hr = S_OK;

    //
    //  Clean up
    //

    // if we've got a cached toolbar, release it
    if (m_ipToolbar) {
        m_ipToolbar->Release();
        m_ipToolbar = NULL;
    }

    // if we've got a cached control bar, release it
    if (m_ipControlBar) {
        m_ipControlBar->Release();
        m_ipControlBar = NULL;
    }


    //
    // Install new pieces if necessary
    //

    // if a new one came in, cache and AddRef
    if (pControlbar) {
        m_ipControlBar = pControlbar;
        m_ipControlBar->AddRef();

        hr = m_ipControlBar->Create(TOOLBAR,  // type of control to be created
            dynamic_cast<IExtendControlbar *>(this),
            reinterpret_cast<IUnknown **>(&m_ipToolbar));
        _ASSERT(SUCCEEDED(hr));

        // The IControlbar::Create AddRefs the toolbar object it created
        // so no need to do any addref on the interface.

        // add the bitmap to the toolbar
        HBITMAP hbmp = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_TOOLBAR1));
        hr = m_ipToolbar->AddBitmap(3, hbmp, 16, 16, RGB(0, 128, 128)); // NOTE, hardcoded value 3
        _ASSERT(SUCCEEDED(hr));

        // Add the buttons to the toolbar
        hr = m_ipToolbar->AddButtons(ARRAYLEN(SnapinButtons1), SnapinButtons1);
        _ASSERT(SUCCEEDED(hr));
    }

    return hr;
}

HRESULT CComponent::ControlbarNotify(
                                     /* [in] */ MMC_NOTIFY_TYPE event,
                                     /* [in] */ LPARAM arg,
                                     /* [in] */ LPARAM param)
{
    HRESULT hr = S_OK;

    if (event == MMCN_SELECT) {
        BOOL bScope = (BOOL) LOWORD(arg);
        BOOL bSelect = (BOOL) HIWORD(arg);

        CDelegationBase *base = GetOurDataObject(reinterpret_cast<IDataObject *>(param))->GetBaseNodeObject();
        hr = base->OnSetToolbar(this, m_ipControlBar, m_ipToolbar, bScope, bSelect);
    } else if (event == MMCN_BTN_CLICK) {
        CDelegationBase *base = GetOurDataObject(reinterpret_cast<IDataObject *>(arg))->GetBaseNodeObject();
        hr = base->OnToolbarCommand(this, m_ipConsole, (MMC_CONSOLE_VERB)param);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\toolbar\land.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Land.h"

const GUID CLandBasedVehicle::thisGuid = { 0x2974380e, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CLandBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\toolbar\compdata.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "CompData.h"
#include "DataObj.h"
#include "resource.h"
#include <crtdbg.h>

CComponentData::CComponentData()
: m_cref(0), m_ipConsoleNameSpace(NULL), m_ipConsole(NULL)
{
    OBJECT_CREATED

        m_pStaticNode = new CStaticNode;

    TCHAR tmpHelpFile[MAX_PATH];

    GetWindowsDirectory(tmpHelpFile, sizeof(tmpHelpFile));
    _tcscat(tmpHelpFile, _T("\\HELP\\"));
    LoadString(g_hinst, IDS_HELPFILE, &tmpHelpFile[_tcslen(tmpHelpFile)], MAX_PATH - _tcslen(tmpHelpFile));

	MAKE_WIDEPTR_FROMTSTR(wszHelpFile, tmpHelpFile);
	wcscpy(m_HelpFile, wszHelpFile);
}

CComponentData::~CComponentData()
{
    if (m_pStaticNode) {
        delete m_pStaticNode;
    }

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CComponentData::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_IComponentData))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_ISnapinHelp))
        *ppv = static_cast<ISnapinHelp*>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponentData::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponentData::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }

    return m_cref;
}

///////////////////////////////
// Interface IComponentData
///////////////////////////////
HRESULT CComponentData::Initialize(
                                   /* [in] */ LPUNKNOWN pUnknown)
{
    HRESULT      hr;

    //
    // Get pointer to name space interface
    //
    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (void **)&m_ipConsoleNameSpace);
    _ASSERT( S_OK == hr );

    //
    // Get pointer to console interface
    //
    hr = pUnknown->QueryInterface(IID_IConsole, (void **)&m_ipConsole);
    _ASSERT( S_OK == hr );

    IImageList *pImageList;
    m_ipConsole->QueryScopeImageList(&pImageList);
    _ASSERT( S_OK == hr );

    hr = pImageList->ImageListSetStrip( (long *)m_pStaticNode->m_pBMapSm, // pointer to a handle
        (long *)m_pStaticNode->m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );

    pImageList->Release();

    return S_OK;
}

HRESULT CComponentData::CreateComponent(
                                        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent)
{
    *ppComponent = NULL;

    CComponent *pComponent = new CComponent(this);

    if (NULL == pComponent)
        return E_OUTOFMEMORY;

    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent);
}

HRESULT CComponentData::Notify(
                               /* [in] */ LPDATAOBJECT lpDataObject,
                               /* [in] */ MMC_NOTIFY_TYPE event,
                               /* [in] */ LPARAM arg,
                               /* [in] */ LPARAM param)
{
    MMCN_Crack(TRUE, lpDataObject, this, NULL, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)
    {
    case MMCN_EXPAND:
        hr = base->OnExpand(m_ipConsoleNameSpace, m_ipConsole, (HSCOPEITEM)param);
        break;
    }

    return hr;
}

HRESULT CComponentData::Destroy( void)
{
    // Free interfaces
    if (m_ipConsoleNameSpace) {
        m_ipConsoleNameSpace->Release();
        m_ipConsoleNameSpace = NULL;
    }

    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}

HRESULT CComponentData::QueryDataObject(
                                        /* [in] */ MMC_COOKIE cookie,
                                        /* [in] */ DATA_OBJECT_TYPES type,
                                        /* [out] */ LPDATAOBJECT *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

HRESULT CComponentData::GetDisplayInfo(
                                       /* [out][in] */ SCOPEDATAITEM *pScopeDataItem)
{
    HRESULT hr = S_FALSE;

    // if they are asking for the SDI_STR we have one of those to give
    if (pScopeDataItem->lParam) {
        CDelegationBase *base = (CDelegationBase *)pScopeDataItem->lParam;
        if (pScopeDataItem->mask & SDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName();
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pScopeDataItem->displayname = pszW;
        }

        if (pScopeDataItem->mask & SDI_IMAGE) {
            pScopeDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}

HRESULT CComponentData::CompareObjects(
                                       /* [in] */ LPDATAOBJECT lpDataObjectA,
                                       /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////
// Interface ISnapinHelp
///////////////////////////////
HRESULT CComponentData::GetHelpTopic(
                                     /* [out] */ LPOLESTR *lpCompiledHelpFile)
{
    *lpCompiledHelpFile = static_cast<LPOLESTR>(CoTaskMemAlloc((wcslen(m_HelpFile) + 1) * sizeof(WCHAR)));
    
    wcscpy(*lpCompiledHelpFile, m_HelpFile);
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\toolbar\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5

#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\toolbar\mmccrack.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

static TCHAR *MMCN_CrackVerb(MMC_CONSOLE_VERB verb)
{
        static TCHAR error[64];

        switch (verb) {
    case MMC_VERB_NONE:
                return _T("NONE");
    case MMC_VERB_OPEN:
                return _T("OPEN");
    case MMC_VERB_COPY:
                return _T("COPY");
    case MMC_VERB_PASTE:
                return _T("PASTE");
    case MMC_VERB_DELETE:
                return _T("DELETE");
    case MMC_VERB_PROPERTIES:
                return _T("PROPERTIES");
    case MMC_VERB_RENAME:
                return _T("RENAME");
    case MMC_VERB_REFRESH:
                return _T("REFRESH");
    case MMC_VERB_PRINT:
                return _T("PRINT");
    case MMC_VERB_CUT:
                return _T("CUT");
        default:
                wsprintf(error, _T("Unknown verb id %d"), verb);
                return error;
        }
}

void MMCN_Crack(BOOL bComponentData,
                IDataObject *pDataObject,
                                IComponentData *pCompData,
                                IComponent *pComp,
                MMC_NOTIFY_TYPE event,
                                LPARAM arg,
                                LPARAM param)
{
#ifdef MMC_CRACK_MESSAGES
        TCHAR message[256] = {0};

        if (bComponentData == TRUE)
                OutputDebugString(_T("IComponentData::Notify( "));
        else
                OutputDebugString(_T("IComponent::Notify( "));

        wsprintf(message, _T("DataObject: %08x, CompData: %08x, Comp: %08x ) - "), pDataObject, pCompData, pComp);
        OutputDebugString(message);

    switch (event)      {
                case MMCN_ACTIVATE:
                        wsprintf(message, _T("MMCN_ACTIVATE\n\tActivate: %d\n"), arg);
                        break;

                case MMCN_ADD_IMAGES:
                        wsprintf(message, _T("MMCN_ADD_IMAGES\n\tImage List: %08x\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_BTN_CLICK:
                        wsprintf(message, _T("MMCN_BTN_CLICK\n\tVerb: %ws\n"), MMCN_CrackVerb((MMC_CONSOLE_VERB)param));
                        break;

                case MMCN_COLUMN_CLICK:
                        wsprintf(message, _T("MMCN_COLUMN_CLICK\n\tColumn: %d\n\tSort Option: %d\n"), arg,       param);
                        break;

                case MMCN_COLUMNS_CHANGED:
                        wsprintf(message, _T("MMCN_COLUMNS_CHANGED\n"));
                        break;

                case MMCN_CONTEXTHELP:
                        wsprintf(message, _T("MMCN_CONTEXTHELP\n"));
                        break;

                case MMCN_CONTEXTMENU:
                        wsprintf(message, _T("MMCN_CONTEXTMENU\n"));
                        break;

                case MMCN_CUTORMOVE:
                        wsprintf(message, _T("MMCN_CUTORMOVE\n"));
                        break;

                case MMCN_DBLCLICK:
                        wsprintf(message, _T("MMCN_DBLCLICK\n"));
                        break;

                case MMCN_DELETE:
                        wsprintf(message, _T("MMCN_DELETE\n"));
                        break;

                case MMCN_DESELECT_ALL:
                        wsprintf(message, _T("MMCN_DESELECT_ALL\n"));
                        break;

                case MMCN_EXPAND:
                        wsprintf(message, _T("MMCN_EXPAND\n\tExpand: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_EXPANDSYNC:
                        wsprintf(message, _T("MMCN_EXPANDSYNC\n"));
                        break;

                case MMCN_FILTERBTN_CLICK:
                        wsprintf(message, _T("MMCN_FILTERBTN_CLICK\n\tColumn: %d\n"), arg);
                        break;

                case MMCN_FILTER_CHANGE:
                        wsprintf(message, _T("MMCN_FILTER_CHANGE\n\tColumn: %d\n"), param);
                        break;

                case MMCN_HELP:
                        wsprintf(message, _T("MMCN_HELP\n"));
                        break;

                case MMCN_INITOCX:
                        wsprintf(message, _T("MMCN_INITOCX\n\tIUnknown: %08x\n"), param);
                        break;

                case MMCN_LISTPAD:
                        wsprintf(message, _T("MMCN_LISTPAD\n\tConnect: %d\n"), arg);
                        break;

                case MMCN_MENU_BTNCLICK:
                        wsprintf(message, _T("MMCN_MENU_BTNCLICK\n"));
                        break;

                case MMCN_MINIMIZED:
                        wsprintf(message, _T("MMCN_MINIMIZED\n\tMinimized: %d\n"), arg);
                        break;

                case MMCN_PASTE:
                        wsprintf(message, _T("MMCN_PASTE\n\tCopy: %d\n"), param == NULL);
                        break;

                case MMCN_PRELOAD:
                        wsprintf(message, _T("MMCN_PRELOAD\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_PRINT:
                        wsprintf(message, _T("MMCN_PRINT\n"));
                        break;

                case MMCN_PROPERTY_CHANGE:
                        wsprintf(message, _T("MMCN_PROPERTY_CHANGE\n\tScope: %d\n\tArg: %08x\n"), arg, param);
                        break;

                case MMCN_QUERY_PASTE:
                        wsprintf(message, _T("MMCN_QUERY_PASTE\n"));
                        break;

                case MMCN_REFRESH:
                        wsprintf(message, _T("MMCN_REFRESH\n"));
                        break;

                case MMCN_REMOVE_CHILDREN:
                        wsprintf(message, _T("MMCN_REMOVE_CHILDREN\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_RENAME:
                        wsprintf(message, _T("MMCN_RENAME\n\tNew Name: '%ws'\n"), (LPOLESTR)param);
                        break;

                case MMCN_RESTORE_VIEW:
                        wsprintf(message, _T("MMCN_RESTORE_VIEW\n"));
                        break;

                case MMCN_SELECT:
                        wsprintf(message, _T("MMCN_SELECT\n\tScope: %d\n\tSelect: %08x\n"), LOWORD(arg), HIWORD(arg));
                        break;

                case MMCN_SHOW:
                        wsprintf(message, _T("MMCN_SHOW\n\tShow: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_SNAPINHELP:
                        wsprintf(message, _T("MMCN_SNAPINHELP\n"));
                        break;

                case MMCN_VIEW_CHANGE:
                        wsprintf(message, _T("MMCN_VIEW_CHANGE\n\tData: %08x\n\tHint: %08x\n"), arg, param);
                        break;
        }

        if (message[0] != 0)
                OutputDebugString(message);
        else
                OutputDebugString(_T("unknown event\n"));

#endif
        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\toolbar\registry.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions = FALSE);

HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\toolbar\delebase.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DeleBase.h"
#include "Comp.h"
#include "CompData.h"

const GUID CDelegationBase::thisGuid = { 0x2974380b, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

HBITMAP CDelegationBase::m_pBMapSm = NULL;
HBITMAP CDelegationBase::m_pBMapLg = NULL;

//==============================================================
//
// CDelegationBase implementation
//
//
CDelegationBase::CDelegationBase() 
: bExpanded(FALSE) 
{ 
    if (NULL == m_pBMapSm || NULL == m_pBMapLg)
        LoadBitmaps(); 
}

CDelegationBase::~CDelegationBase() 
{ 
}

// CDelegationBase::AddImages sets up the collection of images to be displayed
// by the IComponent in the result pane as a result of its MMCN_SHOW handler
HRESULT CDelegationBase::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi) 
{
    return pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}

HRESULT CDelegationBase::OnShowContextHelp(IDisplayHelp *m_ipDisplayHelp, LPOLESTR helpFile)
{ 
    WCHAR topicName[MAX_PATH];
    
    wcscpy(topicName, helpFile);
    
    // we should read this from a resource file
    wcscat(topicName, L"::/default.htm");
    
    LPOLESTR pszTopic = static_cast<LPOLESTR>(CoTaskMemAlloc((wcslen(topicName) + 1) * sizeof(WCHAR)));
    
    wcscpy(pszTopic, topicName);
    
    return m_ipDisplayHelp->ShowTopic(pszTopic);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\toolbar\delebase.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _BRANCHES_H
#define _BRANCHES_H

#include <mmc.h>
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "LocalRes.h"

class CComponent;
class CComponentData;

class CDelegationBase {
public:
    CDelegationBase();
    virtual ~CDelegationBase();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) = 0;
    virtual const GUID & getNodeType() { _ASSERT(FALSE); return IID_NULL; }
    
    virtual const LPARAM GetCookie() { return reinterpret_cast<LPARAM>(this); }
    virtual const int GetBitmapIndex() = 0;
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions) { return S_FALSE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent) { return S_FALSE; }
    virtual HRESULT OnSelect(CComponent *pComponent, BOOL bScope, BOOL bSelect) { return S_FALSE; }
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem) { return S_FALSE; }
    virtual HRESULT OnShowContextHelp(IDisplayHelp *m_ipDisplayHelp, LPOLESTR helpFile);
    virtual HRESULT OnToolbarCommand(CComponent *pComponent, IConsole *pConsole, MMC_CONSOLE_VERB verb) { return S_FALSE; }
    virtual HRESULT OnSetToolbar(CComponent *pComponent, IControlbar *pControlbar, IToolbar *pToolbar, BOOL bScope, BOOL bSelect) { return S_FALSE; }
    virtual HRESULT OnButtonClicked(CComponent *pComponent) { return S_FALSE;}
    
public:
    void SetComponentData(CComponentData *pComponentData) { m_pComponentData = pComponentData; }
    
public:
    static HBITMAP m_pBMapSm;
    static HBITMAP m_pBMapLg;
    
protected:
    static void LoadBitmaps() {
        m_pBMapSm = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_SMICONS));
        m_pBMapLg = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_LGICONS));
    }
    
    BOOL bExpanded;
    
private:
    // {2974380B-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
public:
    CComponentData *m_pComponentData;
};

#endif // _BRANCHES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\toolbar\sky.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Sky.h"

const GUID CSkyBasedVehicle::thisGuid = { 0x2974380f, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSkyBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\toolbar\guids.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

// {88249524-8AD1-11d2-8A0B-000021473128}
DEFINE_GUID(CLSID_CComponentData, 
            0x88249524, 0x8ad1, 0x11d2, 0x8a, 0xb, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28);

// {88249526-8AD1-11d2-8A0B-000021473128}
DEFINE_GUID(CLSID_CSnapinAbout, 
            0x88249526, 0x8ad1, 0x11d2, 0x8a, 0xb, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\toolbar\land.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _LAND_H
#define _LAND_H

#include "DeleBase.h"

class CLandBasedVehicle : public CDelegationBase {
public:
    CLandBasedVehicle(CComponentData *pComponentData = NULL)
    { m_pComponentData = pComponentData; }
    
    virtual ~CLandBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Land-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_LANDICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    
private:
    enum { IDM_NEW_LAND = 2 };
    
    // {2974380E-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _LAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\toolbar\people.cpp ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#include <stdio.h>
#include "People.h"

const GUID CPeoplePoweredVehicle::thisGuid = { 0x2974380d, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

const GUID CBicycleFolder::thisGuid = { 0xef163732, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboardFolder::thisGuid = { 0xef163733, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkateFolder::thisGuid = { 0xf6c660b0, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };

const GUID CBicycle::thisGuid = { 0xef163734, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboard::thisGuid = { 0xef163735, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkate::thisGuid = { 0xf6c660b1, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };


//==============================================================
//
// CPeoplePoweredVehicle implementation
//
//
CPeoplePoweredVehicle::CPeoplePoweredVehicle(CComponentData *pComponentData)
{
    m_pComponentData = pComponentData;

    children[0] = new CBicycleFolder;
    children[1] = new CSkateboardFolder;
    children[2] = new CIceSkateFolder;
}

CPeoplePoweredVehicle::~CPeoplePoweredVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        delete children[n];
}

HRESULT CPeoplePoweredVehicle::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;

    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT    |   // relativeID is valid
                SDI_CHILDREN;     // cChildren is valid

            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = 0;

            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );

            _ASSERT( SUCCEEDED(hr) );
        }
    }

    return S_OK;
}

CBicycleFolder::CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CBicycle(n + 1);
    }
}

CBicycleFolder::~CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CBicycleFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

CIceSkateFolder::CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CIceSkate(n + 1);
    }
}

CIceSkateFolder::~CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CIceSkateFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

CSkateboardFolder::CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CSkateboard(n + 1);
    }
}

CSkateboardFolder::~CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSkateboardFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                      ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

const _TCHAR *CBicycle::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Bicycle #%d"), id);

    return buf;
}

const _TCHAR *CSkateboard::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Skateboard #%d"), id);

    return buf;
}

const _TCHAR *CIceSkate::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Ice Skate #%d"), id);

    return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\toolbar\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Resources.rc
//
#define IDS_HELPFILE                    1
#define IDS_SNAPINDESC                  2
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDI_ICON1                       108
#define IDR_TOOLBAR1                    112
#define IDB_SMOPEN                      116
#define IDB_SMBMP                       117
#define IDB_LGBMP                       118
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDB_ROCKET                      40004
#define IDB_CAR                         40005
#define IDB_PLANE                       40006
#define IDB_BIKE                        40007
#define IDB_ROCKET2                     40008
#define IDB_CAR2                        40009
#define IDB_PLANE2                      40010
#define IDB_BIKE2                       40011
#define IDB_CLOSED2                     40012
#define IDB_OPEN2                       40013
#define IDB_CLOSED                      40014
#define IDB_OPEN                        40015
#define ID_COMMAND_COMMAND1             40016
#define ID_COMMAND_COMMAND2             40017
#define ID_COMMAND_COMMAND3             40018
#define ID_COMMAND_COMMAND4             40020
#define ID_BUTTONSTART                  40021
#define ID_BUTTONPAUSE                  40022
#define ID_BUTTONSTOP                   40023


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        119
#define _APS_NEXT_COMMAND_VALUE         40024
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\toolbar\people.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _PEOPLE_H
#define _PEOPLE_H

#include "DeleBase.h"

class CBicycle : public CDelegationBase {
public:
    CBicycle(int i) : id(i) { }
    virtual ~CBicycle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CBicycleFolder : public CDelegationBase {
public:
    CBicycleFolder();
    virtual ~CBicycleFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Bicycles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CSkateboard : public CDelegationBase {
public:
    CSkateboard(int i) : id(i) { }
    virtual ~CSkateboard() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CSkateboardFolder : public CDelegationBase {
public:
    CSkateboardFolder();
    virtual ~CSkateboardFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Skateboards"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CIceSkate : public CDelegationBase {
public:
    CIceSkate(int i) : id(i) { }
    virtual ~CIceSkate() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CIceSkateFolder : public CDelegationBase {
public:
    CIceSkateFolder();
    virtual ~CIceSkateFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Ice Skates"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CPeoplePoweredVehicle : public CDelegationBase {
public:
    CPeoplePoweredVehicle(CComponentData *pComponentData = NULL);
    virtual ~CPeoplePoweredVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("People-powered Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { IDM_NEW_PEOPLE = 1 };
    
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 3 };
    CDelegationBase *children[3];
};

#endif // _PEOPLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\toolbar\help source\mmcsample.h ===
//
// MMCSample.h
//
//   Contains header information for HTML API calls
//  so that our sample MMC snap-ins can find help information
//
#define HELP_STEPONE    101
#define HELP_STEPTWO    102
#define HELP_STEPTHREE  103
#define HELP_STEPFOUR   104

#define HELP_DEFAULT    0
#define HELP_INTRO      1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\toolbar\registry.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

#define STRINGS_ONLY
#include "globals.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName)       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule,
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;

    assert(dwResult != 0) ;

    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    assert(SUCCEEDED(hr)) ;

        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;
        _tcscat(szKey, pszCLSID) ;

    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;

    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    _tcscat(szKey, _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), _T("Apartment"));

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;


    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;

        MAKE_TSTRPTR_FROMWIDE(pszT, wszCLSID);
        _tcscat(szKey, pszT) ;

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Register the snap-in in the registry.
//
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,         // Class Id for About Class
                       const BOOL fSupportExtensions)
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    LPOLESTR wszAboutCLSID = NULL;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    if (IID_NULL != clsidAbout)
        hr = StringFromCLSID(clsidAbout, &wszAboutCLSID);

        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszAboutCLSID, wszAboutCLSID);


    // Add the CLSID to the registry.
    setSnapInKeyAndValue(pszCLSID, NULL, _T("NameString"), szNameString) ;
    setSnapInKeyAndValue(pszCLSID, _T("StandAlone"), NULL, NULL);
    if (IID_NULL != clsidAbout)
        setSnapInKeyAndValue(pszCLSID, NULL, _T("About"), pszAboutCLSID);

    if (fSupportExtensions) {
        // Build the key NodeType
        setSnapInKeyAndValue(pszCLSID, _T("NodeTypes"), NULL, NULL);

        _TCHAR szKey[64] ;
        _tcscpy(szKey, pszCLSID) ;
        _tcscat(szKey, _T("\\NodeTypes")) ;
        setSnapInKeyAndValue(szKey, pszCLSID, NULL, NULL);
    }

    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    if (IID_NULL != clsidAbout)
        CoTaskMemFree(wszAboutCLSID);

    return S_OK ;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    LPOLESTR wszCLSID = NULL;

    // Get CLSID
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\"));
    _tcscat(szKeyBuf, pszCLSID);

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // free the memory
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }

    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }

    // Close the child.
    RegCloseKey(hKeyChild) ;

    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\")) ;
    _tcscat(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\wmi\about.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "About.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

CSnapinAbout::CSnapinAbout()
: m_cref(0)
{
    OBJECT_CREATED

        m_hSmallImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    m_hLargeImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_LGBMP), IMAGE_BITMAP, 32, 32, LR_LOADTRANSPARENT);

    m_hSmallImageOpen = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMOPEN), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);

    m_hAppIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ICON1));
}

CSnapinAbout::~CSnapinAbout()
{
    if (m_hSmallImage != NULL)
        FreeResource(m_hSmallImage);

    if (m_hLargeImage != NULL)
        FreeResource(m_hLargeImage);

    if (m_hSmallImageOpen != NULL)
        FreeResource(m_hSmallImageOpen);

    if (m_hAppIcon != NULL)
        FreeResource(m_hAppIcon);

    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CSnapinAbout::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<ISnapinAbout *>(this);
    else if (IsEqualIID(riid, IID_ISnapinAbout))
        *ppv = static_cast<ISnapinAbout *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSnapinAbout::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CSnapinAbout::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription(
                                                /* [out] */ LPOLESTR *lpDescription)
{
    _TCHAR szDesc[MAX_PATH];

    LoadString(g_hinst, IDS_SNAPINDESC, szDesc, sizeof(szDesc));

    return AllocOleStr(lpDescription, szDesc);
}


STDMETHODIMP CSnapinAbout::GetProvider(
                                       /* [out] */ LPOLESTR *lpName)
{
    return AllocOleStr(lpName, _T("Copyright  1998 Microsoft Corporation"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinVersion(
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return AllocOleStr(lpVersion, _T("1.0"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinImage(
                                          /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;

    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}


STDMETHODIMP CSnapinAbout::GetStaticFolderImage(
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;

    *hSmallImageOpen = m_hSmallImageOpen;

    *cMask = RGB(0, 128, 128);

    if (*hSmallImage == NULL || *hLargeImage == NULL || *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}

// this allocates a chunk of memory using CoTaskMemAlloc and copies our chars into it
HRESULT CSnapinAbout::AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer)
{
        MAKE_WIDEPTR_FROMTSTR_ALLOC(wszStr, szBuffer);
        *lpDest = wszStr;


    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\wmi\about.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPABOUT_H_
#define _SAMPABOUT_H_

#include <tchar.h>
#include <mmc.h>

class CSnapinAbout : public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;
    
public:
    CSnapinAbout();
    ~CSnapinAbout();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
        /* [out] */ LPOLESTR *lpDescription);
        
        STDMETHODIMP GetProvider( 
        /* [out] */ LPOLESTR *lpName);
        
        STDMETHODIMP GetSnapinVersion( 
        /* [out] */ LPOLESTR *lpVersion);
        
        STDMETHODIMP GetSnapinImage( 
        /* [out] */ HICON *hAppIcon);
        
        STDMETHODIMP GetStaticFolderImage( 
        /* [out] */ HBITMAP *hSmallImage,
        /* [out] */ HBITMAP *hSmallImageOpen,
        /* [out] */ HBITMAP *hLargeImage,
        /* [out] */ COLORREF *cMask);
        
        ///////////////////////////////
        // Private Interface 
        ///////////////////////////////
private:
    HRESULT	CSnapinAbout::AllocOleStr(
        LPOLESTR *lpDest, 
        _TCHAR *szBuffer);
};

#endif _SAMPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\wmi\basesnap.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <olectl.h>
#include <initguid.h>
#include "guids.h"
#include "basesnap.h"
#include "Comp.h"
#include "CompData.h"
#include "About.h"
#include "Registry.h"

// our globals
HINSTANCE g_hinst;

BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    if ((rclsid != CLSID_CComponentData) && (rclsid != CLSID_CSnapinAbout))
        return CLASS_E_CLASSNOTAVAILABLE;
    
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
    // make the factory passing in the creation function for the type of object they want
    if (rclsid == CLSID_CComponentData)
        pFactory = new CClassFactory(CClassFactory::COMPONENT);
    else if (rclsid == CLSID_CSnapinAbout)
        pFactory = new CClassFactory(CClassFactory::ABOUT);
    
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}


CClassFactory::CClassFactory(FACTORY_TYPE factoryType)
: m_cref(0), m_factoryType(factoryType)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    if (COMPONENT == m_factoryType) {
        pObj = new CComponentData();
    } else {
        pObj = new CSnapinAbout();
    }
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    
    if (FAILED(hr))
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{
    HRESULT hr = SELFREG_E_CLASS;
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName));
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, sizeof(szSnapInName));
    
    _TCHAR szAboutName[256];
    
    LoadString(g_hinst, IDS_ABOUTNAME, szAboutName, sizeof(szAboutName));
    
    // register our CoClasses
    hr = RegisterServer(g_hinst, 
        CLSID_CComponentData, 
        szName);
    
    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst, 
        CLSID_CSnapinAbout, 
        szAboutName);
    
    // place the registry information for SnapIns
    if SUCCEEDED(hr)
        hr = RegisterSnapin(CLSID_CComponentData, szSnapInName, CLSID_CSnapinAbout, FALSE);
    
    return hr;
}


STDAPI DllUnregisterServer()
{
    if (UnregisterServer(CLSID_CComponentData) == S_OK)
        return UnregisterSnapin(CLSID_CComponentData);
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\wmi\basesnap.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#ifndef _BASESNAP_H_
#define _BASESNAP_H_

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);
STDAPI DllCanUnloadNow(void);

ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    enum FACTORY_TYPE {COMPONENT = 0, ABOUT = 1};
    
    CClassFactory(FACTORY_TYPE factoryType);
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
private:
    FACTORY_TYPE m_factoryType;
};

#endif _BASESNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\wmi\compdata.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "CompData.h"
#include "DataObj.h"
#include "resource.h"
#include <crtdbg.h>

CComponentData::CComponentData()
: m_cref(0), m_ipConsoleNameSpace(NULL), m_ipConsole(NULL)
{
    OBJECT_CREATED

        m_pStaticNode = new CStaticNode;
}

CComponentData::~CComponentData()
{
    if (m_pStaticNode) {
        delete m_pStaticNode;
    }

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CComponentData::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_IComponentData))
        *ppv = static_cast<IComponentData *>(this);

    // first things first, make sure that when MMC
    // asks if we do property sheets, that we actually
    // say "yes"
    else if (IsEqualIID(riid, IID_IExtendPropertySheet) ||
        IsEqualIID(riid, IID_IExtendPropertySheet2))
        *ppv = static_cast<IExtendPropertySheet2 *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponentData::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponentData::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }

    return m_cref;
}

///////////////////////////////
// Interface IComponentData
///////////////////////////////
HRESULT CComponentData::Initialize(
                                   /* [in] */ LPUNKNOWN pUnknown)
{
    HRESULT      hr;

    //
    // Get pointer to name space interface
    //
    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (void **)&m_ipConsoleNameSpace);
    _ASSERT( S_OK == hr );

    //
    // Get pointer to console interface
    //
    hr = pUnknown->QueryInterface(IID_IConsole, (void **)&m_ipConsole);
    _ASSERT( S_OK == hr );

    IImageList *pImageList;
    m_ipConsole->QueryScopeImageList(&pImageList);
    _ASSERT( S_OK == hr );

    hr = pImageList->ImageListSetStrip( (long *)m_pStaticNode->m_pBMapSm, // pointer to a handle
        (long *)m_pStaticNode->m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );

    pImageList->Release();

    return S_OK;
}

HRESULT CComponentData::CreateComponent(
                                        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent)
{
    *ppComponent = NULL;

    CComponent *pComponent = new CComponent(this);

    if (NULL == pComponent)
        return E_OUTOFMEMORY;

    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent);
}

HRESULT CComponentData::Notify(
                               /* [in] */ LPDATAOBJECT lpDataObject,
                               /* [in] */ MMC_NOTIFY_TYPE event,
                               /* [in] */ LPARAM arg,
                               /* [in] */ LPARAM param)
{
    MMCN_Crack(TRUE, lpDataObject, this, NULL, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)
    {
    case MMCN_EXPAND:
        hr = base->OnExpand(m_ipConsoleNameSpace, m_ipConsole, (HSCOPEITEM)param);
        break;
    }

    return hr;
}

HRESULT CComponentData::Destroy( void)
{
    // Free interfaces
    if (m_ipConsoleNameSpace) {
        m_ipConsoleNameSpace->Release();
        m_ipConsoleNameSpace = NULL;
    }

    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}

HRESULT CComponentData::QueryDataObject(
                                        /* [in] */ MMC_COOKIE cookie,
                                        /* [in] */ DATA_OBJECT_TYPES type,
                                        /* [out] */ LPDATAOBJECT *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

HRESULT CComponentData::GetDisplayInfo(
                                       /* [out][in] */ SCOPEDATAITEM *pScopeDataItem)
{
    HRESULT hr = S_FALSE;

    // if they are asking for the SDI_STR we have one of those to give
    if (pScopeDataItem->lParam) {
        CDelegationBase *base = (CDelegationBase *)pScopeDataItem->lParam;
        if (pScopeDataItem->mask & SDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName();
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pScopeDataItem->displayname = pszW;
        }

        if (pScopeDataItem->mask & SDI_IMAGE) {
            pScopeDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}

HRESULT CComponentData::CompareObjects(
                                       /* [in] */ LPDATAOBJECT lpDataObjectA,
                                       /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////////
// Interface IExtendPropertySheet2
///////////////////////////////////
HRESULT CComponentData::CreatePropertyPages(
                                            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
                                            /* [in] */ LONG_PTR handle,
                                            /* [in] */ LPDATAOBJECT lpIDataObject)
{
    CDelegationBase *base = GetOurDataObject(lpIDataObject)->GetBaseNodeObject();

    return base->CreatePropertyPages(lpProvider, handle);
}

HRESULT CComponentData::QueryPagesFor(
                                      /* [in] */ LPDATAOBJECT lpDataObject)
{
    CDelegationBase *base = GetOurDataObject(lpDataObject)->GetBaseNodeObject();

    return base->HasPropertySheets();
}

HRESULT CComponentData::GetWatermarks(
                                      /* [in] */ LPDATAOBJECT lpIDataObject,
                                      /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
                                      /* [out] */ HBITMAP __RPC_FAR *lphHeader,
                                      /* [out] */ HPALETTE __RPC_FAR *lphPalette,
                                      /* [out] */ BOOL __RPC_FAR *bStretch)
{
    CDelegationBase *base = GetOurDataObject(lpIDataObject)->GetBaseNodeObject();

    return base->GetWatermarks(lphWatermark, lphHeader, lphPalette, bStretch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\wmi\comp.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMP_H_
#define _SAMPCOMP_H_

#include <mmc.h>

class CComponent : public IComponent,
IExtendPropertySheet2
{
private:
    ULONG				m_cref;
    
    IConsole*		m_ipConsole;
    
    class CComponentData *m_pComponentData;
    
    public:
        CComponent(CComponentData *parent);
        ~CComponent();
        
        ///////////////////////////////
        // Interface IUnknown
        ///////////////////////////////
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        
        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ MMC_COOKIE cookie);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);
            
            //////////////////////////////////
            // Interface IExtendPropertySheet2
            //////////////////////////////////
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
            /* [in] */ LONG_PTR handle,
            /* [in] */ LPDATAOBJECT lpIDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
            /* [in] */ LPDATAOBJECT lpDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetWatermarks( 
            /* [in] */ LPDATAOBJECT lpIDataObject,
            /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
            /* [out] */ HBITMAP __RPC_FAR *lphHeader,
            /* [out] */ HPALETTE __RPC_FAR *lphPalette,
            /* [out] */ BOOL __RPC_FAR *bStretch);
};

#endif _SAMPCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\toolbar\space.cpp ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#include <stdio.h>
#include "Space.h"
#include "Comp.h"

const GUID CSpaceVehicle::thisGuid = { 0x29743810, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };
const GUID CRocket::thisGuid = { 0x29743811, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSpaceVehicle implementation
//
//
CSpaceVehicle::CSpaceVehicle(CComponentData *pComponentData)
{
    m_pComponentData = pComponentData;

    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CRocket(pComponentData);
        children[n]->Initialize(_T("Vehicle"), 500000, 265, 75000);
    }
}

CSpaceVehicle::~CSpaceVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSpaceVehicle::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Rocket Class", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 1, L"Rocket Weight", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 2, L"Rocket Height", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 3, L"Rocket Payload", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 4, L"Status", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

//==============================================================
//
// CRocket implementation
//
//
CRocket::CRocket(CComponentData *pComponentData)
: szName(NULL), lWeight(0), lHeight(0), lPayload(0), iStatus(STOPPED)
{
    m_pComponentData = pComponentData;
}

CRocket::~CRocket()
{
    if (szName)
        delete [] szName;
}

void CRocket::Initialize(_TCHAR *szName, LONG lWeight, LONG lHeight, LONG lPayload)
{
    if (szName) {
        this->szName = new _TCHAR[_tcslen(szName) + 1];
        _tcscpy(this->szName, szName);
    }

    this->lWeight = lWeight;
    this->lHeight = lHeight;
    this->lPayload = lPayload;
}

const _TCHAR *CRocket::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    switch (nCol) {
    case 0:
        _tcscpy(buf, szName ? szName : _T(""));
        break;

    case 1:
        _stprintf(buf, _T("%ld metric tons"), lWeight);
        break;

    case 2:
        _stprintf(buf, _T("%ld meters"), lHeight);
        break;

    case 3:
        _stprintf(buf, _T("%ld kilos"), lPayload);
        break;

    case 4:
        _stprintf(buf, _T("%s"),
            iStatus == RUNNING ? _T("running") :
        iStatus == PAUSED ? _T("paused") :
        iStatus == STOPPED ? _T("stopped") : _T("unknown"));
        break;

    }

    return buf;
}

HRESULT CRocket::OnSelect(CComponent *pComponent, BOOL bScope, BOOL bSelect)
{
    if (bSelect) {
        switch (iStatus)
        {
        case RUNNING:
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTART, BUTTONPRESSED, TRUE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTART, ENABLED, FALSE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONPAUSE, BUTTONPRESSED, FALSE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONPAUSE, ENABLED, TRUE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTOP, BUTTONPRESSED, FALSE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTOP, ENABLED, TRUE);
            break;

        case PAUSED:
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTART, BUTTONPRESSED, FALSE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTART, ENABLED, TRUE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONPAUSE, BUTTONPRESSED, TRUE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONPAUSE, ENABLED, FALSE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTOP, BUTTONPRESSED, FALSE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTOP, ENABLED, TRUE);
            break;

        case STOPPED:
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTART, BUTTONPRESSED, FALSE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTART, ENABLED, TRUE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONPAUSE, BUTTONPRESSED, FALSE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONPAUSE, ENABLED, TRUE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTOP, BUTTONPRESSED, TRUE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTOP, ENABLED, FALSE);
            break;
        }
    }

    return S_OK;
}

HRESULT CRocket::OnButtonClicked(CComponent *pComponent)
{
    switch (iStatus)
    {
    case RUNNING:
        pComponent->getToolbar()->SetButtonState(ID_BUTTONSTART, BUTTONPRESSED, TRUE);
        pComponent->getToolbar()->SetButtonState(ID_BUTTONSTART, ENABLED, FALSE);
        pComponent->getToolbar()->SetButtonState(ID_BUTTONPAUSE, BUTTONPRESSED, FALSE);
        pComponent->getToolbar()->SetButtonState(ID_BUTTONPAUSE, ENABLED, TRUE);
        pComponent->getToolbar()->SetButtonState(ID_BUTTONSTOP, BUTTONPRESSED, FALSE);
        pComponent->getToolbar()->SetButtonState(ID_BUTTONSTOP, ENABLED, TRUE);
        break;

    case PAUSED:
        pComponent->getToolbar()->SetButtonState(ID_BUTTONSTART, BUTTONPRESSED, FALSE);
        pComponent->getToolbar()->SetButtonState(ID_BUTTONSTART, ENABLED, TRUE);
        pComponent->getToolbar()->SetButtonState(ID_BUTTONPAUSE, BUTTONPRESSED, TRUE);
        pComponent->getToolbar()->SetButtonState(ID_BUTTONPAUSE, ENABLED, FALSE);
        pComponent->getToolbar()->SetButtonState(ID_BUTTONSTOP, BUTTONPRESSED, FALSE);
        pComponent->getToolbar()->SetButtonState(ID_BUTTONSTOP, ENABLED, TRUE);
        break;

    case STOPPED:
        pComponent->getToolbar()->SetButtonState(ID_BUTTONSTART, BUTTONPRESSED, FALSE);
        pComponent->getToolbar()->SetButtonState(ID_BUTTONSTART, ENABLED, TRUE);
        pComponent->getToolbar()->SetButtonState(ID_BUTTONPAUSE, BUTTONPRESSED, FALSE);
        pComponent->getToolbar()->SetButtonState(ID_BUTTONPAUSE, ENABLED, TRUE);
        pComponent->getToolbar()->SetButtonState(ID_BUTTONSTOP, BUTTONPRESSED, TRUE);
        pComponent->getToolbar()->SetButtonState(ID_BUTTONSTOP, ENABLED, FALSE);
        break;
    }

    return S_OK;
}

HRESULT CRocket::OnSetToolbar(CComponent *pComponent, IControlbar *pControlbar, IToolbar *pToolbar, BOOL bScope, BOOL bSelect)
{
    HRESULT hr = S_OK;

    if (bSelect) {
        // Always make sure the menuButton is attached
        hr = pControlbar->Attach(TOOLBAR, pToolbar);
        hr = OnSelect(pComponent, bScope, bSelect);
    } else {
        // Always make sure the toolbar is detached
        hr = pControlbar->Detach(pToolbar);
    }

    return hr;
}

HRESULT CRocket::OnToolbarCommand(CComponent *pComponent, IConsole *pConsole, MMC_CONSOLE_VERB verb)
{
    _TCHAR szVehicle[128];

    switch (verb)
    {
    case ID_BUTTONSTART:
            iStatus = RUNNING;
        break;

    case ID_BUTTONPAUSE:
        iStatus = PAUSED;
        break;

    case ID_BUTTONSTOP:
        iStatus = STOPPED;
        break;
    }

    wsprintf(szVehicle, _T("Vehicle %s has been %s"), szName,
        (long)verb == ID_BUTTONSTART ? _T("started") :
    (long)verb == ID_BUTTONPAUSE ? _T("paused") :
    (long)verb == ID_BUTTONSTOP ? _T("stopped") : _T("!!!unknown command!!!"));

    int ret = 0;
    MAKE_WIDEPTR_FROMTSTR_ALLOC(wszVehicle, szVehicle);
    pConsole->MessageBox(wszVehicle,
        L"Vehicle command", MB_OK | MB_ICONINFORMATION, &ret);

    OnButtonClicked(pComponent);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\toolbar\sky.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SKY_H
#define _SKY_H

#include "DeleBase.h"

class CSkyBasedVehicle : public CDelegationBase {
public:
    CSkyBasedVehicle(CComponentData *pComponentData = NULL)
    { m_pComponentData = pComponentData;  }
    
    virtual ~CSkyBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Sky-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SKYICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    
private:
    enum { IDM_NEW_SKY = 3 };
    
    // {2974380F-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _SKY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\toolbar\space.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SPACE_H
#define _SPACE_H

#include "DeleBase.h"
#include "CompData.h"

class CRocket : public CDelegationBase {
public:
    CRocket(CComponentData *pComponentData = NULL);
    
    virtual ~CRocket();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
    void Initialize(_TCHAR *szName, LONG lWeight, LONG lHeight, LONG lPayload);
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnSelect(CComponent *pComponent, BOOL bScope, BOOL bSelect);
    virtual HRESULT OnToolbarCommand(CComponent *pComponent, IConsole *pConsole, MMC_CONSOLE_VERB verb);
    virtual HRESULT OnSetToolbar(CComponent *pComponent, IControlbar *pControlbar, IToolbar *pToolbar, BOOL bScope, BOOL bSelect);
    virtual HRESULT OnButtonClicked(CComponent *pComponent);
    
private:
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    _TCHAR *szName;
    LONG   lWeight;
    LONG   lHeight;
    LONG   lPayload;
    enum {RUNNING, PAUSED, STOPPED} iStatus;
};

class CSpaceVehicle : public CDelegationBase {
public:
    CSpaceVehicle(CComponentData *pComponentData = NULL);
    
    virtual ~CSpaceVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Future Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    enum { IDM_NEW_SPACE = 4 };
    
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CRocket *children[NUMBER_OF_CHILDREN];
};

#endif // _SPACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\toolbar\statnode.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "StatNode.h"

#include "People.h"
#include "Sky.h"
#include "Land.h"
#include "Space.h"

const GUID CStaticNode::thisGuid = { 0x2974380c, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CStaticNode implementation
//
//
CStaticNode::CStaticNode(CComponentData *pComponentData)
{
    m_pComponentData = pComponentData;
    
    children[0] = new CPeoplePoweredVehicle(pComponentData);
    children[1] = new CLandBasedVehicle(pComponentData);
    children[2] = new CSkyBasedVehicle(pComponentData);
    children[3] = new CSpaceVehicle(pComponentData);
}

CStaticNode::~CStaticNode()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CStaticNode::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;
    
    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT    |
                SDI_CHILDREN;
            
            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = (n == 0); // only the first child has children
            // in this sample
            
            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );
            
            _ASSERT( SUCCEEDED(hr) );
        }
        
        bExpanded = TRUE;
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\toolbar\statnode.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SNAPINBASE_H
#define _SNAPINBASE_H

#include "DeleBase.h"

class CStaticNode : public CDelegationBase {
public:
    CStaticNode(CComponentData *pComponentData = NULL);
    
    virtual ~CStaticNode();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { 
        static _TCHAR szDisplayName[256];
        LoadString(g_hinst, IDS_SNAPINNAME, szDisplayName, sizeof(szDisplayName));
        return szDisplayName; 
    }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_NONE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
    
    // {2974380C-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _SNAPINBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\wmi\compdata.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMPDATA_H_
#define _SAMPCOMPDATA_H_

#include <mmc.h>
#include "DeleBase.h"
#include "StatNode.h"
#include "Comp.h"

class CComponentData : public IComponentData, IExtendPropertySheet2
{
    friend class CComponent;
    
private:
    ULONG				m_cref;
    LPCONSOLE			m_ipConsole;
    LPCONSOLENAMESPACE	m_ipConsoleNameSpace;
    
    CStaticNode     *m_pStaticNode;
    
public:
    CComponentData();
    ~CComponentData();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IComponentData
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
        /* [in] */ LPUNKNOWN pUnknown);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent( 
        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
        /* [in] */ LPDATAOBJECT lpDataObject,
        /* [in] */ MMC_NOTIFY_TYPE event,
        /* [in] */ LPARAM arg,
        /* [in] */ LPARAM param);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
        /* [in] */ MMC_COOKIE cookie,
        /* [in] */ DATA_OBJECT_TYPES type,
        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
        /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
        /* [in] */ LPDATAOBJECT lpDataObjectA,
        /* [in] */ LPDATAOBJECT lpDataObjectB);
        
        //////////////////////////////////
        // Interface IExtendPropertySheet2
        //////////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
        /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
        /* [in] */ LONG_PTR handle,
        /* [in] */ LPDATAOBJECT lpIDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
        /* [in] */ LPDATAOBJECT lpDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetWatermarks( 
        /* [in] */ LPDATAOBJECT lpIDataObject,
        /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
        /* [out] */ HBITMAP __RPC_FAR *lphHeader,
        /* [out] */ HPALETTE __RPC_FAR *lphPalette,
        /* [out] */ BOOL __RPC_FAR *bStretch);
};

#endif _SAMPCOMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\wmi\delebase.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DeleBase.h"

const GUID CDelegationBase::thisGuid = { 0x2974380b, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

HBITMAP CDelegationBase::m_pBMapSm = NULL;
HBITMAP CDelegationBase::m_pBMapLg = NULL;


//==============================================================
//
// CDelegationBase implementation
//
//
CDelegationBase::CDelegationBase() 
: bExpanded(FALSE) 
{ 
    if (NULL == m_pBMapSm || NULL == m_pBMapLg)
        LoadBitmaps(); 
}

CDelegationBase::~CDelegationBase() 
{ 
}

// CDelegationBase::AddImages sets up the collection of images to be displayed
// by the IComponent in the result pane as a result of its MMCN_SHOW handler
HRESULT CDelegationBase::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi) 
{
    return pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\wmi\dataobj.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPDATAOBJECT_H_
#define _SAMPDATAOBJECT_H_

#include <mmc.h>
#include "DeleBase.h"

class CDataObject : public IDataObject
{
private:
    ULONG				m_cref;
    MMC_COOKIE			m_lCookie;
    DATA_OBJECT_TYPES   m_context;
    
public:
    CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context);
    ~CDataObject();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // IDataObject methods 
    ///////////////////////////////
    STDMETHODIMP GetDataHere (FORMATETC *pformatetc, STGMEDIUM *pmedium);
    
    // The rest are not implemented
    STDMETHODIMP GetData (LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumFormatEtc (DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };
    
    STDMETHODIMP QueryGetData (LPFORMATETC lpFormatetc) 
    { return E_NOTIMPL; };
    
    STDMETHODIMP GetCanonicalFormatEtc (LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    
    STDMETHODIMP SetData (LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DAdvise (LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DUnadvise (DWORD dwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumDAdvise (LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };
    
    ///////////////////////////////
    // Custom Methods
    ///////////////////////////////
    
    CDelegationBase *GetBaseNodeObject() {
        return (CDelegationBase *)m_lCookie;
    }
    
    DATA_OBJECT_TYPES GetContext() {
        return m_context;
    }
    
public:
    // clipboard formats
    static UINT s_cfSZNodeType;
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
    static UINT s_cfInternal;
    
};

HRESULT ExtractFromDataObject(IDataObject *lpDataObject,UINT cf,ULONG cb,HGLOBAL *phGlobal);
CDataObject* GetOurDataObject(IDataObject *lpDataObject);
BOOL IsMMCMultiSelectDataObject(IDataObject *lpDataObject);

#endif _SAMPDATAOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\wmi\dataobj.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DataObj.h"
#include "guids.h"
#include "DeleBase.h"

//
// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SZNODETYPE _T("CCF_SZNODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

#define _T_CCF_INTERNAL_SNAPIN _T("{2479DB32-5276-11d2-94F5-00C04FB92EC2}")

    // These are the clipboard formats that we must supply at a minimum.
    // mmc.h actually defined these. We can make up our own to use for
    // other reasons. We don't need any others at this time.
UINT CDataObject::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CDataObject::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CDataObject::s_cfSZNodeType  = RegisterClipboardFormat(_T_CCF_SZNODETYPE);
UINT CDataObject::s_cfSnapinClsid = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);
UINT CDataObject::s_cfInternal    = RegisterClipboardFormat(_T_CCF_INTERNAL_SNAPIN);


CDataObject::CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context)
: m_lCookie(cookie), m_context(context), m_cref(0)
{
}

CDataObject::~CDataObject()
{
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IDataObject *>(this);
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppv = static_cast<IDataObject *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CDataObject::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
//
HRESULT CDataObject::GetDataHere(
                                 FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure
                                 STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure
                                 )
{
    const   CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pStream = NULL;

    CDelegationBase *base = GetBaseNodeObject();

    HRESULT hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( FAILED(hr) )
        return hr;                       // Minimal error checking

    hr = DV_E_FORMATETC;                 // Unknown format

    if (cf == s_cfDisplayName) {
        const _TCHAR *pszName = base->GetDisplayName();

                MAKE_WIDEPTR_FROMTSTR(wszName, pszName);

                // get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(pszName);
        ulSizeofName++;                      // Count null character
        ulSizeofName *= sizeof(WCHAR);

        hr = pStream->Write(wszName, ulSizeofName, NULL);
    } else if (cf == s_cfNodeType) {
        const GUID *pGUID = (const GUID *)&base->getNodeType();

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfSZNodeType) {
        LPOLESTR szGuid;
        hr = StringFromCLSID(base->getNodeType(), &szGuid);

        if (SUCCEEDED(hr)) {
            hr = pStream->Write(szGuid, wcslen(szGuid), NULL);
            CoTaskMemFree(szGuid);
        }
    } else if (cf == s_cfSnapinClsid) {
        const GUID *pGUID = NULL;
        pGUID = &CLSID_CComponentData;

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfInternal) {
        // we are being asked to get our this pointer from the IDataObject interface
        // only our own snap-in objects will know how to do this.
        CDataObject *pThis = this;
        hr = pStream->Write( &pThis, sizeof(CDataObject*), NULL );
    }

    pStream->Release();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Global helper functions to help work with dataobjects and
// clipboard formats


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfInternal clipboard format
//
CDataObject* GetOurDataObject (
                               LPDATAOBJECT lpDataObject      // [in] IComponent pointer
                               )
{
    HRESULT       hr      = S_OK;
    CDataObject *pSDO     = NULL;

	// check to see if the data object is a special data object.
	if ( IS_SPECIAL_DATAOBJECT (lpDataObject) )
	{
		//Code for handling a special data object goes here.

		//Note that the MMC SDK samples do not handle
		//special data objects, so we exit if we get one.
		return NULL;
	}

    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { CDataObject::s_cfInternal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(CDataObject *));

    if (!stgmedium.hGlobal)     {
        hr = E_OUTOFMEMORY;
    }

    if SUCCEEDED(hr)
        // Attempt to get data from the object
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );

    // stgmedium now has the data we need
    if (SUCCEEDED(hr))  {
        pSDO = *(CDataObject **)(stgmedium.hGlobal);
    }

    // if we have memory free it
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);

    return pSDO;

} // end GetOurDataObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\wmi\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>

#ifndef STRINGS_ONLY
        #define IDM_BUTTON1    0x100
        #define IDM_BUTTON2    0x101

        extern HINSTANCE g_hinst;
        extern ULONG g_uObjects;

        #define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
        #define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

        // uncomment the following #define to enable message cracking
        // #define MMC_CRACK_MESSAGES
        void MMCN_Crack(BOOL bComponentData,
                                        IDataObject *pDataObject,
                                        IComponentData *pCompData,
                                        IComponent *pComp,
                                        MMC_NOTIFY_TYPE event,
                                        LPARAM arg,
                                        LPARAM param);
#endif

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(GetProcessHeap(), 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(GetProcessHeap(), 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given a _TCHAR, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszT;
//  pszT = MyGetTStringRoutine();
//  MAKE_WIDEPTR_FROMSTR(pwsz, pszT);
//  MyUseWideStringRoutine(pwsz);
//  ...
#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPWSTR)__TempBuffer##ptrname.GetBuffer(), tstr); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    lstrcpyW((LPWSTR)ptrname, tstr)
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, ptrname, __l##ptrname)
#endif

//
// similarily for MAKE_TSTRPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
// * 2 for DBCS handling in below length computation
//
#ifdef UNICODE
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPTSTR)__TempBuffer##ptrname.GetBuffer(), widestr); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\wmi\delebase.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _BRANCHES_H
#define _BRANCHES_H

#include <mmc.h>
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "LocalRes.h"

class CDelegationBase {
public:
    CDelegationBase();
    virtual ~CDelegationBase();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) = 0;
    virtual const GUID & getNodeType() { _ASSERT(FALSE); return IID_NULL; }
    
    virtual const LPARAM GetCookie() { return reinterpret_cast<LPARAM>(this); }
    virtual const int GetBitmapIndex() = 0;
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions) { return S_FALSE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent) { return S_FALSE; }
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem) { return S_FALSE; }
    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    virtual HRESULT OnRename(LPOLESTR pszNewName) { return S_FALSE; }
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect) { return S_FALSE; }
    
    virtual HRESULT CreatePropertyPages(IPropertySheetCallback *lpProvider,
        LONG_PTR handle) { return S_FALSE; }
    virtual HRESULT HasPropertySheets() { return S_FALSE; }
    virtual HRESULT GetWatermarks(HBITMAP *lphWatermark,
        HBITMAP *lphHeader,
        HPALETTE *lphPalette,
        BOOL *bStretch) { return S_FALSE; }
    
    virtual HRESULT OnPropertyChange(IConsole *pConsole) { return S_OK; }
    
public:
    static HBITMAP m_pBMapSm;
    static HBITMAP m_pBMapLg;
    
protected:
    static void LoadBitmaps() {
        m_pBMapSm = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_SMICONS));
        m_pBMapLg = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_LGICONS));
    }
    
    BOOL bExpanded;
    
private:
    // {2974380B-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _BRANCHES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\wmi\land.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Land.h"

const GUID CLandBasedVehicle::thisGuid = { 0x2974380e, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CLandBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\wmi\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5

#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\wmi\land.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _LAND_H
#define _LAND_H

#include "DeleBase.h"

class CLandBasedVehicle : public CDelegationBase {
public:
    CLandBasedVehicle() { }
    
    virtual ~CLandBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Land-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_LANDICON; }
    
private:
    enum { IDM_NEW_LAND = 2 };
    
    // {2974380E-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};


#endif // _LAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\wmi\mmccrack.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

static TCHAR *MMCN_CrackVerb(MMC_CONSOLE_VERB verb)
{
        static TCHAR error[64];

        switch (verb) {
    case MMC_VERB_NONE:
                return _T("NONE");
    case MMC_VERB_OPEN:
                return _T("OPEN");
    case MMC_VERB_COPY:
                return _T("COPY");
    case MMC_VERB_PASTE:
                return _T("PASTE");
    case MMC_VERB_DELETE:
                return _T("DELETE");
    case MMC_VERB_PROPERTIES:
                return _T("PROPERTIES");
    case MMC_VERB_RENAME:
                return _T("RENAME");
    case MMC_VERB_REFRESH:
                return _T("REFRESH");
    case MMC_VERB_PRINT:
                return _T("PRINT");
    case MMC_VERB_CUT:
                return _T("CUT");
        default:
                wsprintf(error, _T("Unknown verb id %d"), verb);
                return error;
        }
}

void MMCN_Crack(BOOL bComponentData,
                IDataObject *pDataObject,
                                IComponentData *pCompData,
                                IComponent *pComp,
                MMC_NOTIFY_TYPE event,
                                LPARAM arg,
                                LPARAM param)
{
#ifdef MMC_CRACK_MESSAGES
        TCHAR message[256] = {0};

        if (bComponentData == TRUE)
                OutputDebugString(_T("IComponentData::Notify( "));
        else
                OutputDebugString(_T("IComponent::Notify( "));

        wsprintf(message, _T("DataObject: %08x, CompData: %08x, Comp: %08x ) - "), pDataObject, pCompData, pComp);
        OutputDebugString(message);

    switch (event)      {
                case MMCN_ACTIVATE:
                        wsprintf(message, _T("MMCN_ACTIVATE\n\tActivate: %d\n"), arg);
                        break;

                case MMCN_ADD_IMAGES:
                        wsprintf(message, _T("MMCN_ADD_IMAGES\n\tImage List: %08x\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_BTN_CLICK:
                        wsprintf(message, _T("MMCN_BTN_CLICK\n\tVerb: %ws\n"), MMCN_CrackVerb((MMC_CONSOLE_VERB)param));
                        break;

                case MMCN_COLUMN_CLICK:
                        wsprintf(message, _T("MMCN_COLUMN_CLICK\n\tColumn: %d\n\tSort Option: %d\n"), arg,       param);
                        break;

                case MMCN_COLUMNS_CHANGED:
                        wsprintf(message, _T("MMCN_COLUMNS_CHANGED\n"));
                        break;

                case MMCN_CONTEXTHELP:
                        wsprintf(message, _T("MMCN_CONTEXTHELP\n"));
                        break;

                case MMCN_CONTEXTMENU:
                        wsprintf(message, _T("MMCN_CONTEXTMENU\n"));
                        break;

                case MMCN_CUTORMOVE:
                        wsprintf(message, _T("MMCN_CUTORMOVE\n"));
                        break;

                case MMCN_DBLCLICK:
                        wsprintf(message, _T("MMCN_DBLCLICK\n"));
                        break;

                case MMCN_DELETE:
                        wsprintf(message, _T("MMCN_DELETE\n"));
                        break;

                case MMCN_DESELECT_ALL:
                        wsprintf(message, _T("MMCN_DESELECT_ALL\n"));
                        break;

                case MMCN_EXPAND:
                        wsprintf(message, _T("MMCN_EXPAND\n\tExpand: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_EXPANDSYNC:
                        wsprintf(message, _T("MMCN_EXPANDSYNC\n"));
                        break;

                case MMCN_FILTERBTN_CLICK:
                        wsprintf(message, _T("MMCN_FILTERBTN_CLICK\n\tColumn: %d\n"), arg);
                        break;

                case MMCN_FILTER_CHANGE:
                        wsprintf(message, _T("MMCN_FILTER_CHANGE\n\tColumn: %d\n"), param);
                        break;

                case MMCN_HELP:
                        wsprintf(message, _T("MMCN_HELP\n"));
                        break;

                case MMCN_INITOCX:
                        wsprintf(message, _T("MMCN_INITOCX\n\tIUnknown: %08x\n"), param);
                        break;

                case MMCN_LISTPAD:
                        wsprintf(message, _T("MMCN_LISTPAD\n\tConnect: %d\n"), arg);
                        break;

                case MMCN_MENU_BTNCLICK:
                        wsprintf(message, _T("MMCN_MENU_BTNCLICK\n"));
                        break;

                case MMCN_MINIMIZED:
                        wsprintf(message, _T("MMCN_MINIMIZED\n\tMinimized: %d\n"), arg);
                        break;

                case MMCN_PASTE:
                        wsprintf(message, _T("MMCN_PASTE\n\tCopy: %d\n"), param == NULL);
                        break;

                case MMCN_PRELOAD:
                        wsprintf(message, _T("MMCN_PRELOAD\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_PRINT:
                        wsprintf(message, _T("MMCN_PRINT\n"));
                        break;

                case MMCN_PROPERTY_CHANGE:
                        wsprintf(message, _T("MMCN_PROPERTY_CHANGE\n\tScope: %d\n\tArg: %08x\n"), arg, param);
                        break;

                case MMCN_QUERY_PASTE:
                        wsprintf(message, _T("MMCN_QUERY_PASTE\n"));
                        break;

                case MMCN_REFRESH:
                        wsprintf(message, _T("MMCN_REFRESH\n"));
                        break;

                case MMCN_REMOVE_CHILDREN:
                        wsprintf(message, _T("MMCN_REMOVE_CHILDREN\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_RENAME:
                        wsprintf(message, _T("MMCN_RENAME\n\tNew Name: '%ws'\n"), (LPOLESTR)param);
                        break;

                case MMCN_RESTORE_VIEW:
                        wsprintf(message, _T("MMCN_RESTORE_VIEW\n"));
                        break;

                case MMCN_SELECT:
                        wsprintf(message, _T("MMCN_SELECT\n\tScope: %d\n\tSelect: %08x\n"), LOWORD(arg), HIWORD(arg));
                        break;

                case MMCN_SHOW:
                        wsprintf(message, _T("MMCN_SHOW\n\tShow: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_SNAPINHELP:
                        wsprintf(message, _T("MMCN_SNAPINHELP\n"));
                        break;

                case MMCN_VIEW_CHANGE:
                        wsprintf(message, _T("MMCN_VIEW_CHANGE\n\tData: %08x\n\tHint: %08x\n"), arg, param);
                        break;
        }

        if (message[0] != 0)
                OutputDebugString(message);
        else
                OutputDebugString(_T("unknown event\n"));

#endif
        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\wmi\registry.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions = FALSE);

HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\wmi\sky.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Sky.h"

const GUID CSkyBasedVehicle::thisGuid = { 0x2974380f, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSkyBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\wmi\comp.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "DataObj.h"
#include <commctrl.h>        // Needed for button styles...
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "DeleBase.h"
#include "CompData.h"

CComponent::CComponent(CComponentData *parent)
: m_pComponentData(parent), m_cref(0), m_ipConsole(NULL)
{
    OBJECT_CREATED
}

CComponent::~CComponent()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IComponent))
        *ppv = static_cast<IComponent *>(this);

    // first things first, make sure that when MMC
    // asks if we do property sheets, that we actually
    // say "yes"
    else if (IsEqualIID(riid, IID_IExtendPropertySheet))
        *ppv = static_cast<IExtendPropertySheet2 *>(this);
    else if (IsEqualIID(riid, IID_IExtendPropertySheet2))
        *ppv = static_cast<IExtendPropertySheet2 *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponent::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponent::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface IComponent
///////////////////////////////
STDMETHODIMP CComponent::Initialize(
                                    /* [in] */ LPCONSOLE lpConsole)
{
    HRESULT hr = S_OK;

    // Save away all the interfaces we'll need.
    // Fail if we can't QI the required interfaces.

    m_ipConsole = lpConsole;
    m_ipConsole->AddRef();

    return hr;
}

STDMETHODIMP CComponent::Notify(
                                /* [in] */ LPDATAOBJECT lpDataObject,
                                /* [in] */ MMC_NOTIFY_TYPE event,
                                /* [in] */ LPARAM arg,
                                /* [in] */ LPARAM param)
{
        MMCN_Crack(FALSE, lpDataObject, NULL, this, event, arg, param);

    HRESULT hr = S_FALSE;
    CDelegationBase *base = NULL;

    // we need to watch for property change and delegate it
    // a little differently, we're actually going to send
    // the CDelegationBase object pointer in the property page
    // PSN_APPLY handler via MMCPropPageNotify()
    if (MMCN_PROPERTY_CHANGE != event) {
        if (NULL == lpDataObject)
            return S_FALSE;

        base = GetOurDataObject(lpDataObject)->GetBaseNodeObject();
    } else {
        base = (CDelegationBase *)param;
    }

    switch (event)      {
    case MMCN_SHOW:
        hr = base->OnShow(m_ipConsole, (BOOL)arg, (HSCOPEITEM)param);
        break;

    case MMCN_ADD_IMAGES:
        hr = base->OnAddImages((IImageList *)arg, (HSCOPEITEM)param);
        break;

    case MMCN_SELECT:
        hr = base->OnSelect(m_ipConsole, (BOOL)LOWORD(arg), (BOOL)HIWORD(arg));
        break;

    case MMCN_RENAME:
        hr = base->OnRename((LPOLESTR)param);
        break;

    // handle the property change notification if we need to do anything
    // special with it
    case MMCN_PROPERTY_CHANGE:
        hr = base->OnPropertyChange(m_ipConsole);
        break;
    }

    return hr;
}

STDMETHODIMP CComponent::Destroy(
                                 /* [in] */ MMC_COOKIE cookie)
{
    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}


STDMETHODIMP CComponent::QueryDataObject(
                                         /* [in] */ MMC_COOKIE cookie,
                                         /* [in] */ DATA_OBJECT_TYPES type,
                                         /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pComponentData->m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

STDMETHODIMP CComponent::GetResultViewType(
                                           /* [in] */ MMC_COOKIE cookie,
                                           /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
                                           /* [out] */ long __RPC_FAR *pViewOptions)
{
    CDelegationBase *base = (CDelegationBase *)cookie;

    //
    // Ask for default listview.
    //
    if (base == NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
        *ppViewType = NULL;
    }
    else
        return base->GetResultViewType(ppViewType, pViewOptions);

    return S_OK;
}

STDMETHODIMP CComponent::GetDisplayInfo(
                                        /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem)
{
    HRESULT hr = S_OK;
    CDelegationBase *base = NULL;

    // if they are asking for the RDI_STR we have one of those to give

    if (pResultDataItem->lParam) {
        base = (CDelegationBase *)pResultDataItem->lParam;
        if (pResultDataItem->mask & RDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName(pResultDataItem->nCol);
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pResultDataItem->str = pszW;
        }

        if (pResultDataItem->mask & RDI_IMAGE) {
            pResultDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}


STDMETHODIMP CComponent::CompareObjects(
                                        /* [in] */ LPDATAOBJECT lpDataObjectA,
                                        /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////////
// Interface IExtendPropertySheet2
///////////////////////////////////
HRESULT CComponent::CreatePropertyPages(
                                        /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
                                        /* [in] */ LONG_PTR handle,
                                        /* [in] */ LPDATAOBJECT lpIDataObject)
{
    CDelegationBase *base = GetOurDataObject(lpIDataObject)->GetBaseNodeObject();

    return base->CreatePropertyPages(lpProvider, handle);
}

HRESULT CComponent::QueryPagesFor(
                                  /* [in] */ LPDATAOBJECT lpDataObject)
{
    CDelegationBase *base = GetOurDataObject(lpDataObject)->GetBaseNodeObject();

    return base->HasPropertySheets();
}

HRESULT CComponent::GetWatermarks(
                                  /* [in] */ LPDATAOBJECT lpIDataObject,
                                  /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
                                  /* [out] */ HBITMAP __RPC_FAR *lphHeader,
                                  /* [out] */ HPALETTE __RPC_FAR *lphPalette,
                                  /* [out] */ BOOL __RPC_FAR *bStretch)
{
    CDelegationBase *base = GetOurDataObject(lpIDataObject)->GetBaseNodeObject();

    return base->GetWatermarks(lphWatermark, lphHeader, lphPalette, bStretch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\wmi\sky.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SKY_H
#define _SKY_H

#include "DeleBase.h"

class CSkyBasedVehicle : public CDelegationBase {
public:
    CSkyBasedVehicle() { }
    
    virtual ~CSkyBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Sky-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SKYICON; }
    
private:
    enum { IDM_NEW_SKY = 3 };
    
    // {2974380F-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};


#endif // _SKY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\wmi\space.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SPACE_H
#define _SPACE_H

#include "DeleBase.h"

class CRocket : public CDelegationBase {
public:
    CRocket(_TCHAR *szName, int id, LONG lWeight, LONG lHeight, LONG lPayload);
    virtual ~CRocket();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnRename(LPOLESTR pszNewName);
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect);
    
    virtual HRESULT CreatePropertyPages(IPropertySheetCallback *lpProvider, LONG_PTR handle);
    virtual HRESULT HasPropertySheets();
    virtual HRESULT GetWatermarks(HBITMAP *lphWatermark,
        HBITMAP *lphHeader,
        HPALETTE *lphPalette,
        BOOL *bStretch);
    
    virtual HRESULT OnPropertyChange(IConsole *pConsole);
    
private:
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    _TCHAR *szName;
    LONG   lWeight;
    LONG   lHeight;
    LONG   lPayload;
    int    nId;
    enum ROCKET_STATUS {RUNNING, PAUSED, STOPPED} iStatus;
    
    LONG_PTR m_ppHandle;
    
    static BOOL CALLBACK DialogProc(
        HWND hwndDlg,  // handle to dialog box
        UINT uMsg,     // message
        WPARAM wParam, // first message parameter
        LPARAM lParam  // second message parameter
        );
    
};

class CSpaceVehicle : public CDelegationBase {
public:
    CSpaceVehicle();
    
    virtual ~CSpaceVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Future Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    enum { IDM_NEW_SPACE = 4 };
    
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CRocket *children[NUMBER_OF_CHILDREN];
};

#endif // _SPACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\wmi\statnode.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "StatNode.h"

#include "Space.h"
#include "Sky.h"
#include "People.h"
#include "Land.h"

const GUID CStaticNode::thisGuid = { 0x2974380c, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CStaticNode implementation
//
//
CStaticNode::CStaticNode()
{
    children[0] = new CPeoplePoweredVehicle;
    children[1] = new CLandBasedVehicle;
    children[2] = new CSkyBasedVehicle;
    children[3] = new CSpaceVehicle;
}

CStaticNode::~CStaticNode()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CStaticNode::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;
    
    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT	  |
                SDI_CHILDREN;
            
            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = (n == 0); // only the first child has children
            
            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );
            
            _ASSERT( SUCCEEDED(hr) );
        }
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\wmi\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Resource.rc
//
#define IDS_HELPFILE                    1
#define IDS_SNAPINDESC                  2
#define IDI_PSI_LANDBASED               2
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDS_PST_ROCKET                  10
#define IDS_PST_LANDBASED               11
#define IDS_BIKE_TITLE                  12
#define IDD_PROPPAGE_LARGE              107
#define IDI_ICON1                       108
#define IDD_PROPPAGE_PEOPLE             108
#define IDB_SMOPEN                      111
#define IDB_SMBMP                       112
#define IDB_LGBMP                       113
#define IDI_PSI_ROCKET                  114
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDC_ROCKET_NAME                 1000
#define IDC_ROCKET_HEIGHT               1001
#define IDC_ROCKET_WEIGHT               1002
#define IDC_ROCKET_PAYLOAD              1003
#define IDC_ROCKET_STATUS               1005
#define IDC_PEOPLE_NAME                 1008
#define IDC_PEOPLE_COLOR                1009
#define IDC_PEOPLE_MATERIAL             1010
#define IDC_PEOPLE_OWNER                1011
#define IDC_PEOPLE_SURFACE              1012
#define IDC_GIRLS                       1013
#define IDC_PEOPLE_GIRLS                1013
#define IDB_ROCKET                      40004
#define IDB_CAR                         40005
#define IDB_PLANE                       40006
#define IDB_BIKE                        40007
#define IDB_ROCKET2                     40008
#define IDB_CAR2                        40009
#define IDB_PLANE2                      40010
#define IDB_BIKE2                       40011
#define IDB_CLOSED2                     40012
#define IDB_OPEN2                       40013
#define IDB_CLOSED                      40014
#define IDB_OPEN                        40015

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        116
#define _APS_NEXT_COMMAND_VALUE         40016
#define _APS_NEXT_CONTROL_VALUE         1014
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\wmi\people.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//==============================================================;
#include <stdio.h>
#include "People.h"
#include <commctrl.h>
#include <comdef.h>
#include <windowsx.h>

const GUID CPeoplePoweredVehicle::thisGuid = { 0x2974380d, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

const GUID CBicycleFolder::thisGuid =    { 0xef163732, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboardFolder::thisGuid = { 0xef163733, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkateFolder::thisGuid =   { 0xf6c660b0, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };

const GUID CBicycle::thisGuid =    { 0xef163734, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboard::thisGuid = { 0xef163735, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkate::thisGuid =   { 0xf6c660b1, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };


#define WM_WMI_CONNECTED WM_APP		// only sent to CBicycleFolder::m_connectHwnd
#define WM_REFRESH_EVENT WM_APP+1   // only sent to CBicycleFolder::m_connectHwnd

//==============================================================
//
// CEventSink implementation
//
class CEventSink : public IWbemObjectSink
{
public:
    CEventSink(HWND hwnd) : m_hwnd(hwnd){}
    ~CEventSink(){};

    STDMETHOD_(SCODE, Indicate)(long lObjectCount,
								IWbemClassObject **pObjArray)
	{
		// Not actually using the pObjArray. Just need a trigger for the 
		// refresh.
		::SendMessage(m_hwnd, WM_REFRESH_EVENT, 0, 0);
		return S_OK;
	}

    STDMETHOD_(SCODE, SetStatus)(long lFlags,
									HRESULT hResult,
									BSTR strParam,
									IWbemClassObject *pObjParam)
	{
		// SetStatus() may be called to indicate that your query becomes
		// invalid or valid again  ussually caused by multithreading 'situations'.
		return S_OK;
	}

    // IUnknown members
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID* ppv)
	{
		if(riid == IID_IUnknown || riid == IID_IWbemObjectSink)
		{
			*ppv = this;

			// you're handing out a copy of yourself so account for it.
			AddRef();
			return S_OK;
		}
		else 
		{
			return E_NOINTERFACE;
		}
	}
    STDMETHODIMP_(ULONG) AddRef(void)
	{
	    return InterlockedIncrement(&m_lRef);
	}
    STDMETHODIMP_(ULONG) Release(void)
	{
		// InterlockedDecrement() helps with thread safety.
		int lNewRef = InterlockedDecrement(&m_lRef);
		// when all the copies are released...
		if(lNewRef == 0)
		{
			// kill thyself.
			delete this;
		}

		return lNewRef;
	}

private:
    long m_lRef;
	HWND m_hwnd;
};

//==============================================================
//
// CPeoplePoweredVehicle implementation
//
//
//----------------------------------------------------------
#define TEMP_BUF 255

bool CBicycleFolder::ErrorString(HRESULT hr, 
								   TCHAR *errMsg, UINT errSize)
{
    TCHAR szError[TEMP_BUF] = {0};
	TCHAR szFacility[TEMP_BUF] = {0};
	IWbemStatusCodeText * pStatus = NULL;

    // initialize buffers.
	memset(errMsg, 0, errSize * sizeof(TCHAR));

	HRESULT hr1 = CoInitialize(NULL);
	SCODE sc1 = CoCreateInstance(CLSID_WbemStatusCodeText, 
								0, CLSCTX_INPROC_SERVER,
								IID_IWbemStatusCodeText, 
								(LPVOID *) &pStatus);

	// loaded OK?
	if(sc1 == S_OK)
	{
		BSTR bstr;
		sc1 = pStatus->GetErrorCodeText(hr, 0, 0, &bstr);
		if(sc1 == S_OK)
		{
#ifdef UNICODE
			wcsncpy(szError, bstr, TEMP_BUF-1);
#else
			wcstombs(szError, bstr, TEMP_BUF-1);
#endif UNICODE
			SysFreeString(bstr);
			bstr = 0;
		}

		sc1 = pStatus->GetFacilityCodeText(hr, 0, 0, &bstr);
		if(sc1 == S_OK)
		{
#ifdef UNICODE
			wcsncpy(szFacility, bstr, TEMP_BUF-1);
#else
			wcstombs(szFacility, bstr, TEMP_BUF-1);
#endif UNICODE
			SysFreeString(bstr);
			bstr = 0;
		}

		// RELEASE
		pStatus->Release();
		pStatus = NULL;
	}
	else
	{
		::MessageBox(NULL, _T("WBEM error features not available. Upgrade WMI to a newer build."),
					 _T("Internal Error"), MB_ICONSTOP|MB_OK);
	}

	// if not msgs returned....
	if(_tcslen(szFacility) == 0 || _tcslen(szError) == 0)
	{
		// format the error nbr as a reasonable default.
		_stprintf(errMsg, _T("Error code: 0x%08X"), hr);
	}
	else
	{
		// format a readable msg.
		_stprintf(errMsg, _T("%s: %s"), szFacility, szError);
	}

	if(hr1 == S_OK)
		CoUninitialize();

	return (SUCCEEDED(sc1) && SUCCEEDED(hr1));
}

CPeoplePoweredVehicle::CPeoplePoweredVehicle()
{
    children[0] = new CBicycleFolder;
    children[1] = new CSkateboardFolder;
    children[2] = new CIceSkateFolder;
}

CPeoplePoweredVehicle::~CPeoplePoweredVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        delete children[n];
}

HRESULT CPeoplePoweredVehicle::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;

    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask =	SDI_STR       |   // Displayname is valid
						SDI_PARAM     |   // lParam is valid
						SDI_IMAGE     |   // nImage is valid
						SDI_OPENIMAGE |   // nOpenImage is valid
						SDI_PARENT    |   // relativeID is valid
						SDI_CHILDREN;     // cChildren is valid

            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = 0;

            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );

            _ASSERT( SUCCEEDED(hr) );
        }
    }

    return S_OK;
}

CBicycleFolder::CBicycleFolder() :
					m_connectHwnd(0),
					m_threadId(0), m_thread(0), 
					m_doWork(0), m_threadCmd(CT_CONNECT),
					m_running(false), m_ptrReady(0), 
					m_pStream(0), m_realWMI(0),
					m_pResultData(0), m_pStubSink(0),
					m_pUnsecApp(0)
{
    WNDCLASS wndClass;

    ZeroMemory(&wndClass, sizeof(WNDCLASS));

    wndClass.lpfnWndProc = WindowProc; 
    wndClass.lpszClassName = _T("connectthreadwindow"); 
    wndClass.hInstance = g_hinst;

    ATOM atom = RegisterClass(&wndClass);
    m_connectHwnd = CreateWindow(
						_T("connectthreadwindow"),  // pointer to registered class name
						NULL,		 // pointer to window name
						0,			 // window style
						0,           // horizontal position of window
						0,           // vertical position of window
						0,           // window width
						0,           // window height
						NULL,		 // handle to parent or owner window
						NULL,        // handle to menu or child-window identifier
						g_hinst,     // handle to application instance
						(void *)this); // pointer to window-creation data
					
    if (m_connectHwnd)
        SetWindowLong(m_connectHwnd, GWL_USERDATA, (LONG)this);

    InitializeCriticalSection(&m_critSect);
	m_doWork = CreateEvent(NULL, FALSE, FALSE, NULL);
	m_ptrReady = CreateEvent(NULL, FALSE, FALSE, NULL);

    EnterCriticalSection(&m_critSect);
	
	// NOTE: I'm connecting real early. You may want to connect from some other place.
	m_threadCmd = CT_CONNECT;
	SetEvent(m_doWork);
    m_thread = CreateThread(NULL, 0, ThreadProc, (void *)this, 0, &m_threadId);

    LeaveCriticalSection(&m_critSect);
}

CBicycleFolder::~CBicycleFolder()
{
	EmptyChildren();
	if(m_pResultData)
	{
		m_pResultData->Release();
		m_pResultData = 0;
	}

	if(m_pStubSink)
	{
		IWbemServices *service = 0;
		HRESULT hr = GetPtr(&service);
		if(SUCCEEDED(hr))
		{
			service->CancelAsyncCall(m_pStubSink);
			service->Release();
			service = 0;
		}
		m_pStubSink->Release();
		m_pStubSink = NULL;
	}

	if(m_pUnsecApp)
	{
		m_pUnsecApp->Release();
		m_pUnsecApp = 0;
	}

    StopThread();

    if(m_connectHwnd != NULL)
        DestroyWindow(m_connectHwnd);

    UnregisterClass(_T("connectthreadwindow"), NULL);
    DeleteCriticalSection(&m_critSect);
}

void CBicycleFolder::StopThread()
{
    EnterCriticalSection(&m_critSect);
    m_running = false;

    if (m_thread != NULL) 
	{
		m_threadCmd = CT_EXIT;
		SetEvent(m_doWork);
		WaitForSingleObject(m_ptrReady, 10000);

        CloseHandle(m_thread);

        m_thread = NULL;
    }
    LeaveCriticalSection(&m_critSect);
}

LRESULT CALLBACK CBicycleFolder::WindowProc(
								  HWND hwnd,      // handle to window
								  UINT uMsg,      // message identifier
								  WPARAM wParam,  // first message parameter
								  LPARAM lParam)  // second message parameter
{
    CBicycleFolder *pThis = (CBicycleFolder *)GetWindowLong(hwnd, GWL_USERDATA);

    switch (uMsg) 
	{
    case WM_WMI_CONNECTED:
        if(pThis != NULL)
		{
			IWbemServices *service = 0;
			HRESULT hr = pThis->GetPtr(&service);
			if(SUCCEEDED(hr))
			{
				pThis->RegisterEventSink(service);
				pThis->EnumChildren(service);

				// m_pResultData gets set when an onShow has happened. If set, the user already wants
				// to see equipment but the connection was slower than the UI. Catchup now.
				if(pThis->m_pResultData)
					pThis->DisplayChildren();

				// done with the marshaled service ptr.
				service->Release();
				service = 0;
			}
		}
		else
		{
			TCHAR errMsg[255] = {0};
			pThis->ErrorString((HRESULT)wParam, errMsg, 255);

			MessageBox(hwnd, errMsg, _T("WMI Snapin Sample"), MB_OK|MB_ICONSTOP);
		}

        break;

    case WM_REFRESH_EVENT:
        if(pThis != NULL)
		{
			IWbemServices *service = 0;
			HRESULT hr = pThis->GetPtr(&service);
			if(SUCCEEDED(hr))
			{
				pThis->EmptyChildren();
				pThis->EnumChildren(service);
				pThis->DisplayChildren();

				// done with the marshaled service ptr.
				service->Release();
				service = 0;
			}
		}
        break;

	} //endswitch

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

void CBicycleFolder::RegisterEventSink(IWbemServices *service)
{
	//NOTE: this logic is from the Wmi documentation,
	// "Security Considerations with Asynchronous Calls" so you can
	// follow along.

	// allocate the sink if its not already allocated.
	if(m_pStubSink == 0)
	{
		CEventSink *pEventSink = 0;
		IUnknown* pStubUnk = 0;

		// create the 'real' sink.
		pEventSink = new CEventSink(m_connectHwnd);
		pEventSink->AddRef();

		// create an unsecapp object.
		CoCreateInstance(CLSID_UnsecuredApartment, NULL, 
						  CLSCTX_LOCAL_SERVER, IID_IUnsecuredApartment, 
						  (void**)&m_pUnsecApp);

		// give the 'real' sink to the unsecapp to manage. Get a 'pStubUnk' in return.
		m_pUnsecApp->CreateObjectStub(pEventSink, &pStubUnk);

		// from that pUnk, get a wrapper to your original sink.
		pStubUnk->QueryInterface(IID_IWbemObjectSink, (void **)&m_pStubSink);
		pStubUnk->Release();

		// release the 'real' sink cuz m_pStubSink "owns" it now.
		long ref = pEventSink->Release();
	}

	HRESULT hRes = S_OK;
	BSTR qLang = SysAllocString(L"WQL");
	BSTR query = SysAllocString(L"select * from __InstanceCreationEvent where TargetInstance isa \"Bicycle\"");

	// execute the query. For *Async, the last parm is a sink object
	// that will be sent the resultset instead of returning the normal
	// enumerator object.
	if(SUCCEEDED(hRes = service->ExecNotificationQueryAsync(qLang, query,
															0L, NULL,              
															m_pStubSink)))
	{
		OutputDebugString(_T("Executed filter query\n"));
	}
	else
	{
		OutputDebugString(_T("ExecQuery() failed\n"));

	} //endif ExecQuery()

	SysFreeString(qLang);
	SysFreeString(query);
}

void CBicycleFolder::EmptyChildren(void)
{
	if(m_pResultData)
	{
		HRESULT hr = m_pResultData->DeleteAllRsltItems();

		int last = m_children.GetSize();
		for (int n = 0; n < last; n++)
		{
			if (m_children[n] != NULL)
				delete m_children[n];
		}
		m_children.RemoveAll();
	}
}

bool CBicycleFolder::EnumChildren(IWbemServices *service)
{
	IEnumWbemClassObject *pEnumBikes = NULL;
	HRESULT hr = S_OK;

	// get the list of bicycles...
	if(SUCCEEDED(hr = service->CreateInstanceEnum((bstr_t)L"Bicycle",
											WBEM_FLAG_SHALLOW, 
											NULL, &pEnumBikes))) 
	{
		// NOTE: pBike MUST be set to NULL for Next().
		IWbemClassObject *pBike = NULL;
		CBicycle *pBikeInst = 0;

		ULONG uReturned = 1;

		while((SUCCEEDED(hr = pEnumBikes->Next(-1, 1, &pBike, &uReturned))) && 
				(uReturned != 0))
		{
			// Add the bike...
			pBikeInst = new CBicycle(this, pBike);

			m_children.Add(pBikeInst);

			// Done with this object. pBikeInst "owns" it now.
			if(pBike)
			{ 
				pBike->Release();

				// NOTE: pBike MUST be reset to NULL for Next().
				pBike = NULL;
			} 

		} // endwhile

		// Done with this enumerator.
		if (pEnumBikes)
		{ 
			pEnumBikes->Release(); 
			pEnumBikes = NULL;
		}
	} // endif CreateInstanceEnum()

	return SUCCEEDED(hr);
}

HRESULT CBicycleFolder::GetPtr(IWbemServices **ptr)
{
	HRESULT hr = E_FAIL;
	m_threadCmd = CT_GET_PTR;
	SetEvent(m_doWork);
	WaitForSingleObject(m_ptrReady, 10000);
	
	if(ptr && m_pStream)
	{
		*ptr = 0;
		hr = CoGetInterfaceAndReleaseStream(m_pStream,
											IID_IWbemServices,
											(void**)ptr);
	}
	return hr;
}

DWORD WINAPI CBicycleFolder::ThreadProc(LPVOID lpParameter)
{
    CBicycleFolder *pThis = (CBicycleFolder *)lpParameter;
	HRESULT hr = S_OK;

	CoInitialize(NULL);

	while(true)
	{
		WaitForSingleObject(pThis->m_doWork, -1);

		switch(pThis->m_threadCmd)
		{
		case CT_CONNECT:
			{
				IWbemLocator *pLocator = 0;
				HRESULT hr;

				// Create an instance of the WbemLocator interface.
				hr = CoCreateInstance(CLSID_WbemLocator,
									  NULL, CLSCTX_INPROC_SERVER,
									  IID_IWbemLocator, (LPVOID *)&pLocator);

				if(SUCCEEDED(hr))
				{    
					hr = pLocator->ConnectServer(L"root\\Vehicles",// Network
													NULL,         // User
													NULL,         // Password
													NULL,         // Locale
													0,            // Security Flags
													NULL,         // Authority
													NULL,         // Context
													&pThis->m_realWMI);  // Namespace

					// tell the callback the result of the connection.
					if(pThis->m_connectHwnd)
						PostMessage(pThis->m_connectHwnd, WM_WMI_CONNECTED, hr, 0);
				}
			}
			break;

		case CT_GET_PTR:
			if(pThis->m_realWMI != NULL)
			{
				hr = CoMarshalInterThreadInterfaceInStream(IID_IWbemServices,
															pThis->m_realWMI, 
															&(pThis->m_pStream));
			}

			SetEvent(pThis->m_ptrReady);
			break;

		case CT_EXIT:
			if(pThis->m_realWMI != NULL)
			{
				pThis->m_realWMI->Release();
				pThis->m_realWMI = 0;
			}
			SetEvent(pThis->m_ptrReady);
			return 0;
			break;

		} //endswitch

	} //endwhile(true)

    return 0;
}

HRESULT CBicycleFolder::DisplayChildren(void)
{
    // insert items here
    RESULTDATAITEM rdi;
	HRESULT hr = S_OK;
	int last = m_children.GetSize();
	CBicycle *pBike = 0;

    // create the child nodes, then expand them
    for (int n = 0; n < last; n++) 
	{
		pBike = (CBicycle *)m_children[n];

        ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
        rdi.mask       =	RDI_STR       |   // Displayname is valid
							RDI_IMAGE     |	  // nImage is valid
							RDI_PARAM;        

        rdi.nImage      = pBike->GetBitmapIndex();
        rdi.str         = MMC_CALLBACK;
        rdi.nCol        = 0;
        rdi.lParam      = (LPARAM)pBike;

		if(m_pResultData)
			hr = m_pResultData->InsertItem( &rdi );

        _ASSERT( SUCCEEDED(hr) );
    }
	return hr;
}

HRESULT CBicycleFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;

    if (bShow) 
	{
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&m_pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn(0, L"Name", LVCFMT_LEFT, 150);
        _ASSERT( S_OK == hr );

        hr = pHeaderCtrl->InsertColumn(1, L"Owner", LVCFMT_LEFT, 200);
        _ASSERT( S_OK == hr );

		if(m_pResultData)
		{
			hr = m_pResultData->DeleteAllRsltItems();
			_ASSERT( SUCCEEDED(hr) );

			if(!bExpanded) 
			{
				hr = DisplayChildren();
			}

			pHeaderCtrl->Release();
		}
    }

    return hr;
}

CIceSkateFolder::CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CIceSkate(n + 1);
    }
}

CIceSkateFolder::~CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CIceSkateFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) 
		{
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) 
			{
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |    // Displayname is valid
								 RDI_IMAGE     |	// nImage is valid
								 RDI_PARAM;        

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

//================================================
CSkateboardFolder::CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CSkateboard(n + 1);
    }
}

CSkateboardFolder::~CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSkateboardFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                      ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |    // Displayname is valid
								 RDI_IMAGE     |	// nImage is valid
								 RDI_PARAM;        

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

//=====================================================
const _TCHAR *CSkateboard::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Skateboard #%d"), id);

    return buf;
}

//=====================================================
const _TCHAR *CIceSkate::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Ice Skate #%d"), id);

    return buf;
}

//========================================
CBicycle::CBicycle(CBicycleFolder *parent, IWbemClassObject *inst) :
					m_parent(parent),
					m_inst(inst)
{
	if(m_inst)
		m_inst->AddRef();
}

// helper values for calling GetDisplayName().
#define NAME_COL 0
#define OWNER_COL 1
#define COLOR_COL 2
#define MATERIAL_COL 3

const _TCHAR *CBicycle::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

	// Get the corresponding property for nCol. This is in-proc local copy 
	//	  so its pretty fast even if IWbemServices is a remote connection.
	if(m_inst)
	{
		VARIANT pVal;
		WCHAR propName[10] = {0};

		VariantInit(&pVal);

		switch(nCol) 
		{
		case 0:
			wcscpy(propName, L"Name");
			break;

		case 1:
			wcscpy(propName, L"Owner");
			break;

		// these wont be needed by MMC but its makes this routine more useful
		// internal to the class.
		case 2:
			wcscpy(propName, L"Color");
			break;

		case 3:
			wcscpy(propName, L"Material");
			break;

		} //endswitch

		if(m_inst->Get(propName, 0L, &pVal, NULL, NULL) == S_OK) 
		{
			bstr_t temp(pVal);
			_tcscpy(buf, (LPTSTR)temp);
		} 

		VariantClear(&pVal);
	} //endif (m_inst)

    return buf;
}

bool CBicycle::GetGirls(void)
{
	VARIANT_BOOL retval = VARIANT_FALSE;
	// Here's how to get/interpret a VT_BOOL property.
	if(m_inst)
	{
		VARIANT pVal;
		if(m_inst->Get(L"Girls", 0L, &pVal, NULL, NULL) == S_OK) 
		{
			retval = V_BOOL(&pVal);
		} 

		VariantClear(&pVal);
	} //endif (m_inst)

    return (retval == VARIANT_TRUE);
}

void CBicycle::LoadSurfaces(HWND hwndDlg, BYTE iSurface)
{
	HWND hCombo = GetDlgItem(hwndDlg, IDC_PEOPLE_SURFACE);
	HRESULT hr = E_FAIL;
	IWbemQualifierSet *qualSet = 0;
	int selected = 0;

	// qualifiers only exist on the class definition. m_inst is a instance.
	IWbemClassObject *pClass = 0;
	IWbemServices *service = 0;

	if(SUCCEEDED(m_parent->GetPtr(&service)))
	{
		hr = service->GetObject((bstr_t)L"Bicycle", 0,0, &pClass, 0);

		if(SUCCEEDED(hr = pClass->GetPropertyQualifierSet((bstr_t)L"Surface", 
															&qualSet)))
		{
			VARIANT vList;
			VariantInit(&vList);
			if(SUCCEEDED(hr = qualSet->Get((bstr_t)L"Values", 0, &vList, 0)))
			{
				SAFEARRAY *pma = V_ARRAY(&vList);
				long lLowerBound = 0, lUpperBound = 0 ;
				UINT idx = 0;

				SafeArrayGetLBound(pma, 1, &lLowerBound);
				SafeArrayGetUBound(pma, 1, &lUpperBound);

				for(long x = lLowerBound; x <= lUpperBound; x++)
				{
					BSTR vSurface;

					SafeArrayGetElement(pma, &x, &vSurface);
					
					// NOTE: taking advantage of the bstr_t's conversion operators.
					// really cleans up the code.
					bstr_t temp(vSurface);

					UINT idx = ComboBox_AddString(hCombo, (LPTSTR)temp);
					ComboBox_SetItemData(hCombo, idx, x);

					// is this the one we want to select?
					if(iSurface == x)
					{
						selected = x;
					}

				} //endfor
				VariantClear(&vList);
				ComboBox_SetCurSel(hCombo, selected);
			}

			qualSet->Release();
			qualSet = 0;
		} //endif GetPropertyQualifierSet()

		service->Release();

	} //endif GetPtr()

}

const TCHAR *CBicycle::ConvertSurfaceValue(BYTE val)
{
	// Convert a enum to a string using the Value{} array.
	static TCHAR temp[128] = {0};

	return temp;
}

HRESULT CBicycle::PutProperty(LPWSTR propName, LPTSTR str)
{
	HRESULT hr = E_FAIL;
	if(m_inst)
	{
		VARIANT pVal;
		bstr_t temp(str);

		VariantInit(&pVal);
		V_BSTR(&pVal) = temp;
		V_VT(&pVal) = VT_BSTR;

		hr = m_inst->Put(propName, 0L, &pVal, 0); 

		VariantClear(&pVal);
	} //endif (m_inst)

    return hr;
}

HRESULT CBicycle::PutProperty(LPWSTR propName, BYTE val)
{
	HRESULT hr = E_FAIL;
	if(m_inst)
	{
		VARIANT pVal;

		VariantInit(&pVal);
		V_UI1(&pVal) = val;
		V_VT(&pVal) = VT_UI1;

		hr = m_inst->Put(propName, 0L, &pVal, 0);

		VariantClear(&pVal);
	} //endif (m_inst)

    return hr;
}

HRESULT CBicycle::PutProperty(LPWSTR propName, bool val)
{
	HRESULT hr = E_FAIL;
	if(m_inst)
	{
		VARIANT pVal;

		VariantInit(&pVal);
		V_BOOL(&pVal) = (val?VARIANT_TRUE: VARIANT_FALSE);
		V_VT(&pVal) = VT_BOOL;

		hr = m_inst->Put(propName, 0L, &pVal, 0);

		VariantClear(&pVal);

	} //endif (m_inst)

    return hr;
}

// handle anything special when the user clicks Apply or Ok
// on the property sheet.  This sample directly accesses the
// operated-on object, so there's nothing special do to...
HRESULT CBicycle::OnPropertyChange()
{
    return S_OK;
}

HRESULT CBicycle::OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect)
{
    IConsoleVerb *pConsoleVerb;

    HRESULT hr = pConsole->QueryConsoleVerb(&pConsoleVerb);
    _ASSERT(SUCCEEDED(hr));

    // can't get to properties (via the standard methods) unless
    // we tell MMC to display the Properties menu item and
    // toolbar button, this wil give the user a visual cue that
    // there's "something" to do
    hr = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

    pConsoleVerb->Release();

    return S_OK;
}

// Implement the dialog proc
BOOL CALLBACK CBicycle::DialogProc(
                                  HWND hwndDlg,  // handle to dialog box
                                  UINT uMsg,     // message
                                  WPARAM wParam, // first message parameter
                                  LPARAM lParam  // second message parameter
                                  )
{
    static CBicycle *pBike = NULL;

    switch (uMsg) 
	{
    case WM_INITDIALOG:
		{
			// catch the "this" pointer so we can actually operate on the object
			pBike = reinterpret_cast<CBicycle *>(reinterpret_cast<PROPSHEETPAGE *>(lParam)->lParam);

			SetDlgItemText(hwndDlg, IDC_PEOPLE_NAME, pBike->GetDisplayName(NAME_COL));
			SetDlgItemText(hwndDlg, IDC_PEOPLE_COLOR, pBike->GetDisplayName(COLOR_COL));
			SetDlgItemText(hwndDlg, IDC_PEOPLE_MATERIAL, pBike->GetDisplayName(MATERIAL_COL));
			SetDlgItemText(hwndDlg, IDC_PEOPLE_OWNER, pBike->GetDisplayName(OWNER_COL));

			Button_SetCheck(GetDlgItem(hwndDlg, IDC_PEOPLE_GIRLS), 
							(pBike->GetGirls()? BST_CHECKED: BST_UNCHECKED));

			VARIANT pVal;
			VariantInit(&pVal);
			if(SUCCEEDED(pBike->m_inst->Get((bstr_t)L"Surface", 0L, &pVal, NULL, NULL)))
			{
				pBike->m_iSurface = V_UI1(&pVal);
				pBike->LoadSurfaces(hwndDlg, pBike->m_iSurface);
				
				VariantClear(&pVal);
			} 

		}
        break;

    case WM_COMMAND:
        // turn the Apply button on
        if (HIWORD(wParam) == EN_CHANGE ||
            HIWORD(wParam) == CBN_SELCHANGE)
            SendMessage(GetParent(hwndDlg), PSM_CHANGED, (WPARAM)hwndDlg, 0);
        break;

    case WM_DESTROY:
        // tell MMC that we're done with the property sheet (we got this
        // handle in CreatePropertyPages
        MMCFreeNotifyHandle(pBike->m_ppHandle);
        break;

    case WM_NOTIFY:
        
		switch(((NMHDR *)lParam)->code) 
		{
        case PSN_APPLY:
			{
				bool changed = false;
				TCHAR temp[50] = {0};
				HRESULT hr = S_OK;

				HWND hWnd = GetDlgItem(hwndDlg, IDC_PEOPLE_NAME);
				if(hWnd && Edit_GetModify(hWnd))
				{
					GetWindowText(hWnd, temp, 50);
					changed |= SUCCEEDED(pBike->PutProperty(L"Name", temp));
				}

				hWnd = GetDlgItem(hwndDlg, IDC_PEOPLE_COLOR);
				if(hWnd && Edit_GetModify(hWnd))
				{
					GetWindowText(hWnd, temp, 50);
					changed |= SUCCEEDED(pBike->PutProperty(L"Color", temp));
				}

				hWnd = GetDlgItem(hwndDlg, IDC_PEOPLE_MATERIAL);
				if(hWnd && Edit_GetModify(hWnd))
				{
					GetWindowText(hWnd, temp, 50);
					changed |= SUCCEEDED(pBike->PutProperty(L"Material", temp));
				}

				hWnd = GetDlgItem(hwndDlg, IDC_PEOPLE_OWNER);
				if(hWnd && Edit_GetModify(hWnd))
				{
					GetWindowText(hWnd, temp, 50);
					changed |= SUCCEEDED(hr = pBike->PutProperty(L"Owner", temp));
				}

				hWnd = GetDlgItem(hwndDlg, IDC_PEOPLE_SURFACE);

				if(hWnd)
				{
					BYTE newValue = ComboBox_GetCurSel(hWnd);
					if(newValue != pBike->m_iSurface)
					{
						changed |= SUCCEEDED(pBike->PutProperty(L"Surface", newValue));
					}
				}

				hWnd = GetDlgItem(hwndDlg, IDC_PEOPLE_GIRLS);
				if(hWnd)
				{
					bool checked = (Button_GetState(hWnd) & BST_CHECKED);
					bool wasChecked = pBike->GetGirls();
					// did it change?
					if(checked != wasChecked)
					{
						changed |= SUCCEEDED(pBike->PutProperty(L"Girls", checked));
					}
				}

				// if any property changed, write it back to WMI.
				if(changed)
				{
					IWbemServices *service = 0;
					// dialogs run in their own thread so use the marshaling helper
					// get a useable IWbemServices ptr.
					// NOTE: IWbemClassObjects are in-proc so they DONT need to be
					// marshaled.
					if(SUCCEEDED(pBike->m_parent->GetPtr(&service)))
					{
						service->PutInstance(pBike->m_inst, WBEM_FLAG_CREATE_OR_UPDATE, 0, 0);
						service->Release();
			            HRESULT hr = MMCPropertyChangeNotify(pBike->m_ppHandle, (long)pBike);
					}
				}
			}
			break;
        } // endswitch (((NMHDR *)lParam)->code) 

        break;

    } // endswitch (uMsg) 

    return DefWindowProc(hwndDlg, uMsg, wParam, lParam);
}


HRESULT CBicycle::HasPropertySheets()
{
    // say "yes" when MMC asks if we have pages
    return S_OK;
}

HRESULT CBicycle::CreatePropertyPages(IPropertySheetCallback *lpProvider, LONG_PTR handle)
{
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage = NULL;

    // cache this handle so we can call MMCPropertyChangeNotify
    m_ppHandle = handle;

    // create the property page for this node.
    // NOTE: if your node has multiple pages, put the following
    // in a loop and create multiple pages calling
    // lpProvider->AddPage() for each page.
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE;
    psp.hInstance = g_hinst;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROPPAGE_PEOPLE);
    psp.pfnDlgProc = DialogProc;
    psp.lParam = reinterpret_cast<LPARAM>(this);
    psp.pszTitle = MAKEINTRESOURCE(IDS_BIKE_TITLE);


    hPage = CreatePropertySheetPage(&psp);
    _ASSERT(hPage);

    return lpProvider->AddPage(hPage);
}

HRESULT CBicycle::GetWatermarks(HBITMAP *lphWatermark,
								   HBITMAP *lphHeader,
								   HPALETTE *lphPalette,
								   BOOL *bStretch)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\wmi\guids.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;


// {40EDBFBE-E4D4-4380-8BFE-AF1D280AB6F4}
DEFINE_GUID(CLSID_CComponentData, 
0x40edbfbe, 0xe4d4, 0x4380, 0x8b, 0xfe, 0xaf, 0x1d, 0x28, 0xa, 0xb6, 0xf4);


// {356DDDA6-310D-4329-82FF-922F91AFDC6A}
DEFINE_GUID(CLSID_CSnapinAbout, 
0x356ddda6, 0x310d, 0x4329, 0x82, 0xff, 0x92, 0x2f, 0x91, 0xaf, 0xdc, 0x6a);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\wmi\statnode.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SNAPINBASE_H
#define _SNAPINBASE_H

#include "DeleBase.h"

class CStaticNode : public CDelegationBase {
public:
    CStaticNode();
    
    virtual ~CStaticNode();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { 
        static _TCHAR szDisplayName[256];
        LoadString(g_hinst, IDS_SNAPINNAME, szDisplayName, sizeof(szDisplayName));
        return szDisplayName; 
    }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_NONE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
    
    // {2974380C-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};



#endif // _SNAPINBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\wmi\people.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _PEOPLE_H
#define _PEOPLE_H

#include "DeleBase.h"
#include <wbemcli.h>
#include "SimpleArray.h"

class CBicycle;
class CEventSink;

class CBicycleFolder : public CDelegationBase {
public:
    CBicycleFolder();
    virtual ~CBicycleFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Bicycles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
	HRESULT GetPtr(IWbemServices **ptr);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
	CSimpleArray<CBicycle *> m_children;

	bool EnumChildren(IWbemServices *service);
	void EmptyChildren(void);
	HRESULT DisplayChildren(void);
	bool ErrorString(HRESULT hr, TCHAR *errMsg, UINT errSize);

	// for the connection thread.
    void StopThread();
    static LRESULT CALLBACK WindowProc(
							  HWND hwnd,      // handle to window
							  UINT uMsg,      // message identifier
							  WPARAM wParam,  // first message parameter
							  LPARAM lParam);   // second message parameter

    static DWORD WINAPI ThreadProc(LPVOID lpParameter);
	void RegisterEventSink(IWbemServices *service);
	IWbemObjectSink *m_pStubSink;
	IUnsecuredApartment *m_pUnsecApp;

    HWND m_connectHwnd;
    DWORD m_threadId;
    HANDLE m_thread;

	HANDLE m_doWork;		// telling the thread to do something.
	int m_threadCmd;		// what command the thread should do.
	#define CT_CONNECT 0
	#define CT_GET_PTR 1
	#define CT_EXIT 2

    CRITICAL_SECTION m_critSect;
    bool m_running;			// thread is processing a command now.

	HANDLE m_ptrReady;		// the thread has done the work.

    IResultData *m_pResultData;
	IStream *m_pStream;
	IWbemServices *m_realWMI;// lives in the background thread. Use marshalling.
};

class CBicycle : public CDelegationBase {
public:
    CBicycle(CBicycleFolder *parent, IWbemClassObject *inst);
    virtual ~CBicycle() 
	{
		if(m_inst)
			m_inst->Release();

		m_inst = 0;
	}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }

public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect);
    
    virtual HRESULT CreatePropertyPages(IPropertySheetCallback *lpProvider, LONG_PTR handle);
    virtual HRESULT HasPropertySheets();
    virtual HRESULT GetWatermarks(HBITMAP *lphWatermark,
									HBITMAP *lphHeader,
									HPALETTE *lphPalette,
									BOOL *bStretch);
    
    virtual HRESULT OnPropertyChange();
    
private:
	CBicycleFolder *m_parent;
    IWbemClassObject *m_inst;

    LONG_PTR m_ppHandle;
    
    static BOOL CALLBACK DialogProc(
						HWND hwndDlg,  // handle to dialog box
						UINT uMsg,     // message
						WPARAM wParam, // first message parameter
						LPARAM lParam);// second message parameter

    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
	bool GetGirls(void);
	const TCHAR *ConvertSurfaceValue(BYTE val);
	HRESULT PutProperty(LPWSTR propName, LPTSTR str);
	HRESULT PutProperty(LPWSTR propName, BYTE val);
	HRESULT PutProperty(LPWSTR propName, bool val);
	void LoadSurfaces(HWND hwndDlg, BYTE iSurface);
	BYTE m_iSurface;
};


class CSkateboard : public CDelegationBase {
public:
    CSkateboard(int i) : id(i) { }
    virtual ~CSkateboard() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CSkateboardFolder : public CDelegationBase {
public:
    CSkateboardFolder();
    virtual ~CSkateboardFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Skateboards"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CIceSkate : public CDelegationBase {
public:
    CIceSkate(int i) : id(i) { }
    virtual ~CIceSkate() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CIceSkateFolder : public CDelegationBase {
public:
    CIceSkateFolder();
    virtual ~CIceSkateFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Ice Skates"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CPeoplePoweredVehicle : public CDelegationBase {
public:
    CPeoplePoweredVehicle();
    virtual ~CPeoplePoweredVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("People-powered Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { IDM_NEW_PEOPLE = 1 };
    
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 3 };
    CDelegationBase *children[3];
};

#endif // _PEOPLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\wmi\registry.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

#define STRINGS_ONLY
#include "globals.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName)       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule,
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;

    assert(dwResult != 0) ;

    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    assert(SUCCEEDED(hr)) ;

        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;
        _tcscat(szKey, pszCLSID) ;

    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;

    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    _tcscat(szKey, _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), _T("Apartment"));

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;


    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;

        MAKE_TSTRPTR_FROMWIDE(pszT, wszCLSID);
        _tcscat(szKey, pszT) ;

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Register the snap-in in the registry.
//
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,         // Class Id for About Class
                       const BOOL fSupportExtensions)
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    LPOLESTR wszAboutCLSID = NULL;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    if (IID_NULL != clsidAbout)
        hr = StringFromCLSID(clsidAbout, &wszAboutCLSID);

        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszAboutCLSID, wszAboutCLSID);


    // Add the CLSID to the registry.
    setSnapInKeyAndValue(pszCLSID, NULL, _T("NameString"), szNameString) ;
    setSnapInKeyAndValue(pszCLSID, _T("StandAlone"), NULL, NULL);
    if (IID_NULL != clsidAbout)
        setSnapInKeyAndValue(pszCLSID, NULL, _T("About"), pszAboutCLSID);

    if (fSupportExtensions) {
        // Build the key NodeType
        setSnapInKeyAndValue(pszCLSID, _T("NodeTypes"), NULL, NULL);

        _TCHAR szKey[64] ;
        _tcscpy(szKey, pszCLSID) ;
        _tcscat(szKey, _T("\\NodeTypes")) ;
        setSnapInKeyAndValue(szKey, pszCLSID, NULL, NULL);
    }

    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    if (IID_NULL != clsidAbout)
        CoTaskMemFree(wszAboutCLSID);

    return S_OK ;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    LPOLESTR wszCLSID = NULL;

    // Get CLSID
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\"));
    _tcscat(szKeyBuf, pszCLSID);

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // free the memory
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }

    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }

    // Close the child.
    RegCloseKey(hKeyChild) ;

    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\")) ;
    _tcscat(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\wmi\simplearray.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#if (_ATL_VER < 0x0300)
/////////////////////////////////////////////////////////////////////////////
// Collection helpers - CSimpleArray & CSimpleMap

template <class T>
class CSimpleArray
{
public:
	T* m_aT;
	int m_nSize;
	int m_nAllocSize;

// Construction/destruction
	CSimpleArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
	{ }

	~CSimpleArray()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(T& t)
	{
		if(m_nSize == m_nAllocSize)
		{
			T* aT;
			int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);
			aT = (T*)realloc(m_aT, nNewAllocSize * sizeof(T));
			if(aT == NULL)
				return FALSE;
			m_nAllocSize = nNewAllocSize;
			m_aT = aT;
		}
		m_nSize++;
		SetAtIndex(m_nSize - 1, t);
		return TRUE;
	}
	BOOL Remove(T& t)
	{
		int nIndex = Find(t);
		if(nIndex == -1)
			return FALSE;
		return RemoveAt(nIndex);
	}
	BOOL RemoveAt(int nIndex)
	{
		if(nIndex != (m_nSize - 1))
			memmove((void*)&m_aT[nIndex], (void*)&m_aT[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(T));
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_aT != NULL)
		{
			free(m_aT);
			m_aT = NULL;
		}
		m_nSize = 0;
		m_nAllocSize = 0;
	}
	T& operator[] (int nIndex) const
	{
		_ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aT[nIndex];
	}
	T* GetData() const
	{
		return m_aT;
	}

// Implementation
	void SetAtIndex(int nIndex, T& t)
	{
		_ASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_aT[nIndex] = t;
	}
	int Find(T& t) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aT[i] == t)
				return i;
		}
		return -1;	// not found
	}
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\wmi\space.cpp ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#include <stdio.h>
#include <windows.h>
#include "Space.h"
#include "Comp.h"
#include "resource.h"

const GUID CSpaceVehicle::thisGuid = { 0x29743810, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };
const GUID CRocket::thisGuid = { 0x29743811, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSpaceVehicle implementation
//
//
CSpaceVehicle::CSpaceVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CRocket(_T("Rocket"), n+1, 500000, 265, 75000);
    }
}

CSpaceVehicle::~CSpaceVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSpaceVehicle::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Rocket Class", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 1, L"Rocket Weight", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 2, L"Rocket Height", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 3, L"Rocket Payload", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 4, L"Status", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

//==============================================================
//
// CRocket implementation
//
//
CRocket::CRocket(_TCHAR *szName, int id, LONG lWeight, LONG lHeight, LONG lPayload)
: szName(NULL), lWeight(0), lHeight(0), lPayload(0), iStatus(STOPPED)
{
    if (szName) {
        this->szName = new _TCHAR[(_tcslen(szName) + 1) * sizeof(_TCHAR)];
        _tcscpy(this->szName, szName);
    }

    this->nId = id;
    this->lWeight = lWeight;
    this->lHeight = lHeight;
    this->lPayload = lPayload;

    m_ppHandle = 0;
}

CRocket::~CRocket()
{
    if (szName)
        delete [] szName;
}

const _TCHAR *CRocket::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    switch (nCol) {
    case 0:
        _stprintf(buf, _T("%s (#%d)"), szName ? szName : _T(""), nId);
        break;

    case 1:
        _stprintf(buf, _T("%ld metric tons"), lWeight);
        break;

    case 2:
        _stprintf(buf, _T("%ld meters"), lHeight);
        break;

    case 3:
        _stprintf(buf, _T("%ld kilos"), lPayload);
        break;

    case 4:
        _stprintf(buf, _T("%s"),
            iStatus == RUNNING ? _T("running") :
        iStatus == PAUSED ? _T("paused") :
        iStatus == STOPPED ? _T("stopped") : _T("unknown"));
        break;

    }

    return buf;
}

HRESULT CRocket::OnRename(LPOLESTR pszNewName)
{
    if (szName) {
        delete [] szName;
        szName = NULL;
    }

    MAKE_TSTRPTR_FROMWIDE(ptrname, pszNewName);
    szName = new _TCHAR[(_tcslen(ptrname) + 1) * sizeof(_TCHAR)];
    _tcscpy(szName, ptrname);

    return S_OK;
}

// handle anything special when the user clicks Apply or Ok
// on the property sheet.  This sample directly accesses the
// operated-on object, so there's nothing special to do when the user presses Ok.
// when the user presses Apply, we update the currently selected result item
HRESULT CRocket::OnPropertyChange(IConsole *pConsole)
{

    //redraw the item 
    IResultData *pResultData = NULL;

	HRESULT hr;

	hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
	_ASSERT( SUCCEEDED(hr) );	

	HRESULTITEM myhresultitem;	
	
	//lparam == this. See CSpaceVehicle::OnShow
	hr = pResultData->FindItemByLParam( (LPARAM)this, &myhresultitem );
	_ASSERT( SUCCEEDED(hr) ); 

	hr = pResultData->UpdateItem( myhresultitem );     
	_ASSERT( SUCCEEDED(hr) );    
	
    pResultData->Release();
	
	
	return S_OK;
}

HRESULT CRocket::OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect)
{
    IConsoleVerb *pConsoleVerb;

    HRESULT hr = pConsole->QueryConsoleVerb(&pConsoleVerb);
    _ASSERT(SUCCEEDED(hr));

    hr = pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, TRUE);

    // can't get to properties (via the standard methods) unless
    // we tell MMC to display the Properties menu item and
    // toolbar button, this wil give the user a visual cue that
    // there's "something" to do
    hr = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

    pConsoleVerb->Release();

    return S_OK;
}

// Implement the dialog proc
BOOL CALLBACK CRocket::DialogProc(
                                  HWND hwndDlg,  // handle to dialog box
                                  UINT uMsg,     // message
                                  WPARAM wParam, // first message parameter
                                  LPARAM lParam  // second message parameter
                                  )
{
    static CRocket *pRocket = NULL;

    switch (uMsg) {
    case WM_INITDIALOG:
        // catch the "this" pointer so we can actually operate on the object
        pRocket = reinterpret_cast<CRocket *>(reinterpret_cast<PROPSHEETPAGE *>(lParam)->lParam);

        SetDlgItemText(hwndDlg, IDC_ROCKET_NAME, pRocket->szName);
        SetDlgItemInt(hwndDlg, IDC_ROCKET_HEIGHT, pRocket->lHeight, FALSE);
        SetDlgItemInt(hwndDlg, IDC_ROCKET_WEIGHT, pRocket->lWeight, FALSE);
        SetDlgItemInt(hwndDlg, IDC_ROCKET_PAYLOAD, pRocket->lPayload, FALSE);

        _ASSERT( CB_ERR != SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_INSERTSTRING, 0, (LPARAM)_T("Running")) );
        _ASSERT( CB_ERR != SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_INSERTSTRING, 1, (LPARAM)_T("Paused")) );
        _ASSERT( CB_ERR != SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_INSERTSTRING, 2, (LPARAM)_T("Stopped")) );

        SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_SETCURSEL, (WPARAM)pRocket->iStatus, 0);

        break;

    case WM_COMMAND:
        // turn the Apply button on
        if (HIWORD(wParam) == EN_CHANGE ||
            HIWORD(wParam) == CBN_SELCHANGE)
            SendMessage(GetParent(hwndDlg), PSM_CHANGED, (WPARAM)hwndDlg, 0);
        break;

    case WM_DESTROY:
        // tell MMC that we're done with the property sheet (we got this
        // handle in CreatePropertyPages
        MMCFreeNotifyHandle(pRocket->m_ppHandle);
        break;

    case WM_NOTIFY:
        switch (((NMHDR *) lParam)->code) {
        case PSN_APPLY:
            // update the information
            if (pRocket->szName) {
                delete [] pRocket->szName;
                pRocket->szName = NULL;
            }

            {
                int n = SendDlgItemMessage(hwndDlg, IDC_ROCKET_NAME, WM_GETTEXTLENGTH, 0, 0);
                if (n != 0) {
                    pRocket->szName = new _TCHAR[n + 1];
                    GetDlgItemText(hwndDlg, IDC_ROCKET_NAME, pRocket->szName, n + 1);
                }
            }
            pRocket->lHeight = GetDlgItemInt(hwndDlg, IDC_ROCKET_HEIGHT, NULL, FALSE);
            pRocket->lWeight = GetDlgItemInt(hwndDlg, IDC_ROCKET_WEIGHT, NULL, FALSE);
            pRocket->lPayload = GetDlgItemInt(hwndDlg, IDC_ROCKET_PAYLOAD, NULL, FALSE);

            pRocket->iStatus = (ROCKET_STATUS)SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_GETCURSEL, 0, 0);

            // ask MMC to send us a message (on the main thread) so
            // we know the Apply button was clicked.
            HRESULT hr = MMCPropertyChangeNotify(pRocket->m_ppHandle, (long)pRocket);

            _ASSERT(SUCCEEDED(hr));

            return PSNRET_NOERROR;
        }
        break;
    }

    return DefWindowProc(hwndDlg, uMsg, wParam, lParam);
}


HRESULT CRocket::HasPropertySheets()
{
    // say "yes" when MMC asks if we have pages
    return S_OK;
}

HRESULT CRocket::CreatePropertyPages(IPropertySheetCallback *lpProvider, LONG_PTR handle)
{
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage = NULL;

    // cache this handle so we can call MMCPropertyChangeNotify
    m_ppHandle = handle;

    // create the property page for this node.
    // NOTE: if your node has multiple pages, put the following
    // in a loop and create multiple pages calling
    // lpProvider->AddPage() for each page.
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEICONID;
    psp.hInstance = g_hinst;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROPPAGE_LARGE);
    psp.pfnDlgProc = DialogProc;
    psp.lParam = reinterpret_cast<LPARAM>(this);
    psp.pszTitle = MAKEINTRESOURCE(IDS_PST_ROCKET);
    psp.pszIcon = MAKEINTRESOURCE(IDI_PSI_ROCKET);


    hPage = CreatePropertySheetPage(&psp);
    _ASSERT(hPage);

    return lpProvider->AddPage(hPage);
}

HRESULT CRocket::GetWatermarks(HBITMAP *lphWatermark,
                               HBITMAP *lphHeader,
                               HPALETTE *lphPalette,
                               BOOL *bStretch)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\shellext\mmcshext.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mmcshext.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mmcshext.rc
//
#define IDS_PROJNAME                    100
#define IDR_EXTRACTICON                 101
#define IDR_HHCOLLECTIONWRAPPER         102
#define IDR_MAINFRAME                   128

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\shellext\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

#include <ntverp.h>
#include <winver.h>
#include <dlgs.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "MMC Shell Extension DLL"
#define VER_INTERNALNAME_STR            "mmcshext.dll"
#define VER_ORIGINALFILENAME_STR        "mmcshext.dll"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\shellext\hhcwrap.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       hhcwrap.h
//
//--------------------------------------------------------------------------

// hhcwrap.h : Declaration of the class CHHCollectionWrapper

#ifndef __HHCWRAP_H_
#define __HHCWRAP_H_

#include "mmcshext.h"       // main symbols
#include "hcolwrap.h"       // idl generated header
#include <collect.h>

#ifdef ASSERT
#undef ASSERT
#endif
#define ASSERT(e)        // get rid of the assert symbol.


/////////////////////////////////////////////////////////////////////////////
// CHHCollectionWrapper
class ATL_NO_VTABLE CHHCollectionWrapper : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CHHCollectionWrapper, &CLSID_HHCollectionWrapper>,
    public IHHCollectionWrapper
{
public:
    CHHCollectionWrapper()
    {
    }

    STDMETHOD(Open) (LPCOLESTR FileName);

    STDMETHOD(Save)();

    STDMETHOD(Close)();

    STDMETHOD(RemoveCollection) (BOOL bRemoveLocalFiles);

    STDMETHOD(SetFindMergedCHMS) (BOOL bFind);

    
    STDMETHOD(AddFolder) (
        LPCOLESTR szName, 
        DWORD Order, 
        DWORD *pDWORD, 
        LANGID LangId
    );
    
    STDMETHOD(AddTitle) (
        LPCOLESTR Id, 
        LPCOLESTR FileName,
        LPCOLESTR IndexFile, 
        LPCOLESTR Query,
        LPCOLESTR SampleLocation, 
        LANGID Lang, 
        UINT uiFlags,
        ULONG_PTR pLocation,  
        DWORD *pDWORD,
        BOOL bSupportsMerge, 
        LPCOLESTR QueryLocation
    );


DECLARE_REGISTRY_RESOURCEID(IDR_HHCOLLECTIONWRAPPER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CHHCollectionWrapper)
    COM_INTERFACE_ENTRY_IID(IID_IHHCollectionWrapper, IHHCollectionWrapper)
END_COM_MAP()

private:
    CCollection m_collection;
};

#endif //__HHCWRAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\shellext\hhcwrap.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       hhcwrap.cpp
//
//--------------------------------------------------------------------------

// hhcwrap.cpp : Implementation of CHHCollectionWrapper
#include "stdafx.h"
#include "shlobj.h"
#include "hhcwrap.h"
#include "hcolwrap_i.c"

/////////////////////////////////////////////////////////////////////////////
// CHHCollectionWrapper
//
// This class is a wrapper class for the HTML Help collection class. MMC uses
// this class so that it doesn't have to statically link to hhsetup.dll, which
// implements the collection class.
//
// The wrapper class methods all return an HRESULT. For collection methods that
// return a DWORD result, the wrapper returns E_FAIL or S_OK. For all other
// collection methods the wrapper returns S_OK.
//

STDMETHODIMP CHHCollectionWrapper::Open(LPCOLESTR FileName)
{
    USES_CONVERSION;
    DWORD dw =  m_collection.Open(W2CT(FileName));
    return dw ? E_FAIL : S_OK;
}

STDMETHODIMP CHHCollectionWrapper::Save()
{
    DWORD dw =  m_collection.Save();
    return dw ? E_FAIL : S_OK;
}

STDMETHODIMP CHHCollectionWrapper::Close()
{
    DWORD dw = m_collection.Close();
    return dw ? E_FAIL : S_OK;
}

STDMETHODIMP CHHCollectionWrapper::RemoveCollection(BOOL bRemoveLocalFiles)
{
    m_collection.RemoveCollection(bRemoveLocalFiles);
    return S_OK;
}

STDMETHODIMP CHHCollectionWrapper::SetFindMergedCHMS(BOOL bFind)
{
    m_collection.SetFindMergedCHMS(bFind);
    return S_OK;
}


STDMETHODIMP CHHCollectionWrapper::AddFolder (
    LPCOLESTR szName,
    DWORD Order,
    DWORD *pDWORD,
    LANGID LangId )
{
    USES_CONVERSION;

    m_collection.AddFolder(W2CT(szName), Order, pDWORD, LangId);
    return S_OK;
}


STDMETHODIMP CHHCollectionWrapper::AddTitle (
    LPCOLESTR Id,
    LPCOLESTR FileName,
    LPCOLESTR IndexFile,
    LPCOLESTR Query,
    LPCOLESTR SampleLocation,
    LANGID Lang,
    UINT uiFlags,
    ULONG_PTR pLocation,
    DWORD *pDWORD,
    BOOL bSupportsMerge,
    LPCOLESTR QueryLocation )
{
    USES_CONVERSION;

    m_collection.AddTitle(W2CT(Id), W2CT(FileName), W2CT(IndexFile), W2CT(Query),
                          W2CT(SampleLocation), Lang, uiFlags, (CLocation*)pLocation, pDWORD,
                          bSupportsMerge, W2CT(QueryLocation));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\shellext\extract.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       extract.cpp
//
//--------------------------------------------------------------------------

// ExtractIcon.cpp : Implementation of CExtractIcon
#include "stdafx.h"
#include "shlobj.h"
#include "Extract.h"
#include "xmlfile.h"

/* 7A80E4A8-8005-11D2-BCF8-00C04F72C717 */
CLSID CLSID_ExtractIcon = {0x7a80e4a8, 0x8005, 0x11d2, {0xbc, 0xf8, 0x00, 0xc0, 0x4f, 0x72, 0xc7, 0x17} };

/////////////////////////////////////////////////////////////////////////////
// CExtractIcon

STDMETHODIMP
CExtractIcon::Extract(LPCTSTR pszFile, UINT nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize)
{
    HRESULT hr = S_OK;
    int	nLargeIconSize = LOWORD(nIconSize);
    int nSmallIconSize = HIWORD(nIconSize);

    // extract from the .msc file ONLY if the file is in local storage, NOT in offline storage.
    DWORD	dwFileAttributes = GetFileAttributes(pszFile);
    bool	bUseMSCFile      = (dwFileAttributes != 0xFFFFFFFF) && !(dwFileAttributes & FILE_ATTRIBUTE_OFFLINE);

	CSmartIcon iconLarge;
	CSmartIcon iconSmall;

    if (bUseMSCFile)
    {
		CPersistableIcon persistableIcon;

        // try to read file as if it was XML document first,
        hr = ExtractIconFromXMLFile (pszFile, persistableIcon);

        // if it fails, assume the file has older MSC format (compound document)
        // and try to read it
        if (FAILED (hr))
		{
			USES_CONVERSION;
            hr = persistableIcon.Load (T2CW (pszFile));
		}

		/*
		 * get the large and small icons; if either of these fail,
		 * we'll get default icons below
		 */
		if (SUCCEEDED (hr) &&
			SUCCEEDED (hr = persistableIcon.GetIcon (nLargeIconSize, iconLarge)) &&
			SUCCEEDED (hr = persistableIcon.GetIcon (nSmallIconSize, iconSmall)))
		{
			ASSERT ((iconLarge != NULL) && (iconSmall != NULL));
		}
    }

	/*
	 * use the default icons if the file is offline, or the Load failed
	 */
    if (!bUseMSCFile || FAILED(hr))
    {
		/*
		 * load the large and small icons from our resources
		 */
        iconLarge.Attach ((HICON) LoadImage (_Module.GetModuleInstance(),
											 MAKEINTRESOURCE(IDR_MAINFRAME),
											 IMAGE_ICON,
											 nLargeIconSize,
											 nLargeIconSize,
											 LR_DEFAULTCOLOR));

        iconSmall.Attach ((HICON) LoadImage (_Module.GetModuleInstance(),
											 MAKEINTRESOURCE(IDR_MAINFRAME),
											 IMAGE_ICON,
											 nSmallIconSize,
											 nSmallIconSize,
											 LR_DEFAULTCOLOR));
    }

	/*
	 * if we successfully got the large and small icons, return them
	 * to the shell (which will take responsibility for their destruction)
	 */
	if ((iconLarge != NULL) && (iconSmall != NULL))
	{
		*phiconLarge = iconLarge.Detach();
		*phiconSmall = iconSmall.Detach();
		hr = S_OK;
	}
	else
		hr = E_FAIL;

    return (hr);
}

STDMETHODIMP
CExtractIcon::GetIconLocation(UINT uFlags, LPTSTR szIconFile, UINT cchMax, LPINT piIndex, UINT *pwFlags)
{
    _tcscpy(szIconFile, (LPCTSTR)m_strIconFile);
    *piIndex = 0;
    *pwFlags = GIL_NOTFILENAME | GIL_PERINSTANCE | GIL_DONTCACHE;

    return NOERROR;
}

STDMETHODIMP
CExtractIcon::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    m_strIconFile = pszFileName;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\shellext\mmcshext.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mmcshext.cpp
//
//--------------------------------------------------------------------------

// mmcshext.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL,
//      run nmake -f mmcshextps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include <shlobj.h>
#include <shlguid.h>
#include "Extract.h"
#include "hhcwrap.h"
#include "picon.h"
#include "modulepath.h"

#include <atlimpl.cpp>

CComModule _Module;

static void RemovePathFromInProcServerEntry (REFCLSID rclsid);

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ExtractIcon, CExtractIcon)
OBJECT_ENTRY(CLSID_HHCollectionWrapper, CHHCollectionWrapper)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    HRESULT hr =  _Module.RegisterServer(FALSE);

    if (hr == S_OK)
    {
        // remove full module path that ATL adds by default
        RemovePathFromInProcServerEntry(CLSID_ExtractIcon);
        RemovePathFromInProcServerEntry(CLSID_HHCollectionWrapper);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer();
}


static void RemovePathFromInProcServerEntry (REFCLSID rclsid)
{
    // Convert the CLSID to a string
    USES_CONVERSION;
    LPOLESTR lpOleStr;
    HRESULT hr = StringFromCLSID (rclsid, &lpOleStr);
    if (FAILED(hr))
        return;

    if (lpOleStr != NULL)
    {
        // Re-register the InProcServer key without the path
        TCHAR szSubKey[MAX_PATH];

        _tcscpy (szSubKey, _T("CLSID\\"));
        _tcscat (szSubKey, OLE2T(lpOleStr));
        _tcscat (szSubKey, _T("\\InprocServer32"));

        CoTaskMemFree(lpOleStr);

        ::ATL::CRegKey regkey;
        long lRes = regkey.Open(HKEY_CLASSES_ROOT, szSubKey);
        ASSERT(lRes == ERROR_SUCCESS);

        if (lRes == ERROR_SUCCESS)
        {
			CStr strPath = _T("mmcshext.dll");
			
			// try to get absolute path value
			CStr strAbsolute = CModulePath::MakeAbsoluteModulePath( strPath );
			if ( strAbsolute.GetLength() > 0 )
				strPath = strAbsolute;

			// see what type of value we need to put
			DWORD dwValueType = CModulePath::PlatformSupports_REG_EXPAND_SZ_Values() ?
								REG_EXPAND_SZ : REG_SZ;

			lRes = RegSetValueEx( regkey, NULL, 0, dwValueType,
 							     (CONST BYTE *)((LPCTSTR)strPath),
							     (strPath.GetLength() + 1) * sizeof(TCHAR) );

            ASSERT(lRes == ERROR_SUCCESS);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\shellext\extract.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       extract.h
//
//--------------------------------------------------------------------------

// ExtractIcon.h : Declaration of the CExtractIcon

#ifndef __EXTRACTICON_H_
#define __EXTRACTICON_H_

#include "mmcshext.h"       // main symbols
#include "picon.h"

#ifdef ASSERT
#undef ASSERT
#endif
#define ASSERT(e)        // get rid of the assert symbol.

#include "cstr.h"

extern CLSID CLSID_ExtractIcon;

/////////////////////////////////////////////////////////////////////////////
// CExtractIcon
class ATL_NO_VTABLE CExtractIcon : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CExtractIcon, &CLSID_ExtractIcon>,
    public IExtractIcon,
    public IPersistFile
{
public:
    CExtractIcon()
    {
    }

    // IExtractIcon
    STDMETHOD(Extract)          (LPCTSTR pszFile, UINT nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize);     
    STDMETHOD(GetIconLocation)  (UINT uFlags, LPTSTR szIconFile, UINT cchMax, LPINT piIndex, UINT *pwFlags);    
    
    // IPersistFile
    STDMETHOD(GetClassID)       (CLSID *pClassID)                           {return E_NOTIMPL;}  
    STDMETHOD(IsDirty)           (void)                                     {return E_NOTIMPL;}
    STDMETHOD(Load)             (LPCOLESTR pszFileName, DWORD dwMode);        
    STDMETHOD(Save)             (LPCOLESTR pszFileName, BOOL fRemember)     {return E_NOTIMPL;}
    STDMETHOD(SaveCompleted)    (LPCOLESTR pszFileName)                     {return E_NOTIMPL;}
    STDMETHOD(GetCurFile)       (LPOLESTR *ppszFileName)                    {return E_NOTIMPL;}


DECLARE_REGISTRY_RESOURCEID(IDR_EXTRACTICON)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CExtractIcon)
    COM_INTERFACE_ENTRY_IID(IID_IExtractIcon, IExtractIcon)
    COM_INTERFACE_ENTRY(IPersistFile)
END_COM_MAP()

private:
    CStr                        m_strIconFile;
};

#endif //__EXTRACTICON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\shellext\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    sources.inc.

!ENDIF

MAJORCOMP=admin
MINORCOMP=MMC

TARGETNAME=mmcshext
TARGETPATH=obj
TARGETTYPE=DYNLINK

DLLENTRY=_DllMainCRTStartup
UMTYPE=windows

WIN32_WINNT_VERSION=0x0400
WIN32_IE_VERSION=0x0500
SUBSYSTEM_VERSION=4.00

USE_NATIVE_EH=1
USE_RTTI=1
USE_VCCOM=1
USE_STL=1
USE_MSVCRT=1
USE_STATIC_ATL=1
ATL_VER=30

!ifdef PrivateBuild_NoLocalSC
C_DEFINES = $(C_DEFINES) -DPrivateBuild_NoLocalSC
!endif

#
# Enable Fusion Build Magic (preprocess the manifest, stick in resources)
#
# The value of SXS_MANIFEST_RESOURCE_ID *must* be 2, to match a hardcoded value
# in WinbasePrivateCreateActCtxForHModule (winbase.inl).
#
SXS_ASSEMBLY_NAME                 = Microsoft.Windows.MMC
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT = 1
SXS_MANIFEST                      = mmcshext.manifest
SXS_MANIFEST_IN_RESOURCES         = 1
SXS_NO_BINPLACE                   = 1
SXS_MANIFEST_RESOURCE_ID          = 2

C_DEFINES = $(C_DEFINES) -DISOLATION_AWARE_ENABLED

#
# Shfusion.lib causes linker warnings. Ignore them.
#
LINKER_FLAGS=$(LINKER_FLAGS) -ignore:4049,4217

# Use LINKLIBS (gets passed first) if: (from build.hlp)
#  You are building a dynamic link.
#  You are exporting something that's defined in some other component library that you also build.
#  In your dirs file in the subdirectory above, you have ordered it so that the component libraries
#     are around before you build the dynamic link.
LINKLIBS = \
	..\..\core\$(CharWidth)\$(O)\uicore.lib

TARGETLIBS = \
	$(SDK_LIB_PATH)\kernel32.lib    \
	$(SDK_LIB_PATH)\user32.lib      \
	$(SDK_LIB_PATH)\gdi32.lib      \
	$(SDK_LIB_PATH)\ole32.lib       \
	$(SDK_LIB_PATH)\oleaut32.lib    \
	$(SDK_LIB_PATH)\advapi32.lib    \
	$(SDK_LIB_PATH)\uuid.lib        \
	$(SDK_LIB_PATH)\comctl32.lib    \
	$(SDK_LIB_PATH)\shell32.lib     \
	$(SDK_LIB_PATH)\hhsetup.lib

DLLDEF=..\mmcshext.def

INCLUDES = \
	..\; 					\
	..\..\types\idl\$(O);	\
	..\..\inc;				\

PRECOMPILED_INCLUDE = ..\stdafx.h
PRECOMPILED_CXX = 1

# This target is required so $O\mmcshext.res doesn't become the default target
# for makefile.def.  We want "all" to be the default target.
#
# We have to go to this effort because sources(.inc) is included very early
# in makefile.def.  makefile.inc is the place where this would naturally go,
# but we don't want to have to maintain this dependency list in
# ansi\makefile.inc and unicode\makefile.inc.
dummytarget:    all

$O\mmcshext.res:            \
    ..\extract.rgs          \
    ..\hhcwrap.rgs          \
    ..\..\conui\res\mmc.ico

SOURCES =    \
    ..\mmcshext.rc   \
    ..\extract.cpp   \
    ..\mmcshext.cpp  \
    ..\hhcwrap.cpp   \
    ..\xmlfile.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\shellext\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

/*
#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\shellext\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__CFE11CCC_8001_11D2_BCF8_00C04F72C717__INCLUDED_)
#define AFX_STDAFX_H__CFE11CCC_8001_11D2_BCF8_00C04F72C717__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__CFE11CCC_8001_11D2_BCF8_00C04F72C717__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\shellext\xmlfile.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      xmlfile.h
 *
 *  Contents:  functions to inspect XML document and extract the app. icon from it
 *
 *  History:   17-Dec-99 audriusz     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef XMLFILE_H_INCLUDED
#define XMLFILE_H_INCLUDED
#pragma once

// this function validates xml document and loads console icon from it if valid
HRESULT ExtractIconFromXMLFile(LPCTSTR lpstrFileName, CPersistableIcon &persistableIcon);


#endif // XMLFILE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\shellext\xmlfile.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      xmlfile.cpp
 *
 *  Contents:  Implements extracting console icon from XML file
 *
 *  History:   17-Dec-99 audriusz   Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "shlobj.h"
#include "Extract.h"
#include "base64.h"
#include "xmlfile.h"
#include "strings.h"

//---------------------------------------------------------------------------
// static (private) implementation helpers used thru this file
//---------------------------------------------------------------------------
static bool FindStringInData( LPCSTR &pstrSource, int nBytesPerChar, DWORD &dwCharsLeft, LPCSTR pstrKey);
static HRESULT DecodeBase64Fragment( LPCSTR &pstrSource, int nBytesPerChar, DWORD &dwCharsLeft, HGLOBAL& hgResult);
static HRESULT FindAndReadIconData(LPCSTR &pstrSource, int nBytesPerChar, DWORD &dwCharsLeft, LPCSTR strIconName, HGLOBAL& hglobIcon);
static HRESULT LoadIconFromHGlobal(HGLOBAL hData, HICON& hIcon);
static HRESULT ValidateXMLDocument(LPCSTR &pFileData, DWORD &dwLen, int *piBytesPerEnglishChar = NULL);

// following function is a friend of class CXMLPersistableIcon. If renaming, take this into accnt
static HRESULT LoadIconFromXMLData(LPCSTR pFileData, DWORD dwLen, CPersistableIcon &persistableIcon);


/***************************************************************************\
 *
 * FUNCTION:  FindStringInData
 *
 * PURPOSE:  This function locates the string in provided data
 *           NOTE - it matches first byte only (codepage of UNICODE string is ignored)
 *
 * PARAMETERS:
 *    LPCSTR &pstrSource    - [in/out] - data to search thru / possition
 *                            of the first char following the found match
 *    int nBytesPerChar     - [in] - width of the character
 *                            ( only the first byte of each character will be examined )
 *    DWORD &dwCharsLeft    - [in/out] - init. data len / data left after matching string
 *    LPCSTR pstrKey        - [in] - substring to search
 *
 * RETURNS:
 *    bool  - true if succeeded
 *
\***************************************************************************/

// Following sample illustrates algorithm used for the search.
// we will try to locate "Console" in the string "Microsoft Management Console"

//------------------------------------------------
// Standard search (a la strstr)
//------------------------------------------------
// 1.
//   Microsoft Management Console
//   Console                            <- comparing (fails - move to the next char)
// 2.
//   Microsoft Management Console
//    Console                           <- comparing (fails - move to the next char)
//  ------------------------ (19 steps skipped)
// 22.
//                        Console       <- comparing (succeeds)
//------------------------------------------------
// More inteligent search
//------------------------------------------------
// 1.     ! <- last char in searched seq
//  Microsoft Management Console
//  Console                            <- comparing (fails - last char in searched seq is 'o';
//                                        and 'o' is 3rd character from the end in the key;
//                                        so we can advance by 2 chars to match it)
// 2.     ! <- matching 'o' to last 'o' in the key
//  Microsoft Management Console
//    Console                          <- comparing (fails - last char in searched seq is 't';
//                                        't' is not in the key
//                                        so we can advance by key length (7 chars) to skip it)
// 3.        ! <- pos following the last char in searched seq
//  Microsoft Management Console
//           Console                   <- comparing (fails - last char in searched seq is 'e';
//                                        'e' is last character in the key;
//                                         we still can advance by key length (7 chars) to skip it)
// 4.               ! <- pos following the last char in searched seq
//  Microsoft Management Console
//                  Console            <- comparing (fails)
// 5.                     ! <- match point
//  Microsoft Management Console
//                    Console          <- comparing (fails)
// 6.                       ! <- match point
//  Microsoft Management Console
//                       Console       <- comparing (succeeds)
//------------------------------------------------

static bool
FindStringInData( LPCSTR &pstrSource, int nBytesPerChar, DWORD &dwCharsLeft, LPCSTR pstrKey)
{
    // check parameters 
    if( (!pstrSource) || (!pstrKey) )
        return false;

    typedef unsigned short KeyLen_t;
    static KeyLen_t nKeyDist[256]; // static - to keep stack small

    // calculate the key length
    DWORD dwKeyLen = strlen(pstrKey);

    // test for empty search key
    if (!dwKeyLen)
        return true; // we always match empty strings

    // test for longer search key than data provided
    if (dwKeyLen > dwCharsLeft)
        return false; // we'll never find longer substrings than the source

    // key length var size is not too big to minimize tho lookup table size
    KeyLen_t nKeyLen = (KeyLen_t)dwKeyLen;

    // recheck here if the key isn't too long
    if ((DWORD)nKeyLen != dwKeyLen) // key len does not fit to our variable -
        return false;               // we do not deel with such a long keys


    // form the table holding minimal character distance from the end of pstrKey
    // It is used for increasing search speed:
    // When key does not match at current location, [instead of trying one location ahead,]
    // algorythm checks the last character in sequence tested with a key (data[keylen-1]).
    // now we check how far this character may be from the end of the key - we will have
    // distance of all key length in case character is not a part of the key.
    // we can safelly advance by that much. Sometimes we'll be positioning the key at whole
    // key_len offsets from previous test position, sometimes less - depending on data.

    // initialize the table. The distance is keylen value for all characters not existing in the key
    for (unsigned i = 0; i < sizeof(nKeyDist)/sizeof(nKeyDist[0]); ++i)
        nKeyDist[i] = nKeyLen;

    // now set minimal distance for characters in the key.
    // Note, that the last character is not included intensionally - to make
    // distance to it equal to whole key length
    for (i = 0; i < nKeyLen - 1; ++i)
        nKeyDist[pstrKey[i]] = nKeyLen - (KeyLen_t)i - 1;

    // we are done with initialization. Time for real work.

    LPCSTR p = pstrSource;             // to speed it up: we use local variables
    DWORD dwLeft = dwCharsLeft;

    while ( 1 )
    {
        // set the pointers to start of inspected sequence
        LPCSTR ke = pstrKey; // pointer to evaluating key char
        LPCSTR pe = p;       // pointer to evaluating source char

        // try to match all characters in the key
        KeyLen_t nToMatch = nKeyLen;
        while ( *pe == *ke )
        {
            --nToMatch;
            pe += nBytesPerChar;
            ++ke;

            // inspect if there still are some chars to match
            if (!nToMatch)
            {
                // we return the possitive answer here
                // change the reference parameters accordingly
                // (pointing right after the string found)
                pstrSource = pe;
                dwCharsLeft = dwLeft - nKeyLen;
                return true;
            }
        }

        // chLastChar is used as an index
        // need to cast the char to unsigned char - else it will
        // not work correctly for values over 127
        // NTRAID#NTBUG9-185761-2000/09/18 AUDRIUSZ
        BYTE chLastChar = p[(nKeyLen - 1) * nBytesPerChar]; // the last char from evaluated source range

        // the key couldn't be found at the position we inspected.
        // we can advance source pointer as far as we can match
        // the position of the last character to any entry in the key
        // or whole key length else.
        // We have a table built for that

        const KeyLen_t nToSkip = nKeyDist[chLastChar];

        if ((DWORD)nToSkip + (DWORD)nKeyLen >= dwLeft)
            return false;   // gone too far... ( couldn't find the match )

        p += (nToSkip * nBytesPerChar);
        dwLeft -= nToSkip;
    }

    // we will not get here anyway...
    return false;
}


/***************************************************************************\
 *
 * METHOD:  DecodeBase64Fragment
 *
 * PURPOSE: decodes base64 data fragment pointed by arguments
 *
 * PARAMETERS:
 *    LPCSTR &pstrSource    - [in/out] - data to decode / possition
 *                            of the first char following the decoded data
 *    int nBytesPerChar     - [in] - width of the character
 *                            ( only the first byte of each character will be examined )
 *    DWORD &dwCharsLeft    - [in/out] - init. data len / data left after skipping converted
 *    HGLOBAL& hgResult     - decoded data
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
static HRESULT
DecodeBase64Fragment( LPCSTR &pstrSource, int nBytesPerChar, DWORD &dwCharsLeft, HGLOBAL& hgResult)
{
    HRESULT hrStatus = S_OK;
    LPCSTR p = pstrSource;
    DWORD  dwLeft = dwCharsLeft;
    const  size_t ICON_ALLOCATION_LEN = 8*1024; // big enough to have 1 allocation in most cases
    LPBYTE pDynamicBuffer = NULL;
    LPBYTE pConversionBuffer = NULL;
    size_t nCharsInDynamicBuffer = 0;
    size_t nDynamicBufferCapacity = 0;
    HGLOBAL hGlobAlloc = NULL;
    ASSERT(hResult == NULL);

    static base64_table conv;

    // convert until done or end is found
    while (1)
    {
        // standard conversion. converts 4 chars (6bit each) to 3 bytes
        BYTE inp[4];
        memset(&inp, 0 ,sizeof(inp));
        // collect 4 characters for conversion, if possible.
        for (int nChars = 0; nChars < 4 && dwLeft && *p != '<' && *p != '='; --dwLeft)
        {
            BYTE bt = conv.map2six(*p);
            p += nBytesPerChar;
            if (bt != 0xff)
                inp[nChars++] = bt;
        }

        // if nothing to convert - we are done
        if (!nChars)
            break;

        // make sure we have enough storage for result
        if (nChars + nCharsInDynamicBuffer > nDynamicBufferCapacity)
        {
            // need to extend the dynamic buffer
            LPBYTE pnewBuffer = (LPBYTE)realloc(pDynamicBuffer, nDynamicBufferCapacity + ICON_ALLOCATION_LEN);

            if (!pnewBuffer)
            {
                hrStatus = E_OUTOFMEMORY;
                goto ON_ERROR;
            }
            // assign new pointer
            pDynamicBuffer = pnewBuffer;
            nDynamicBufferCapacity += ICON_ALLOCATION_LEN;

            pConversionBuffer = &pDynamicBuffer[nCharsInDynamicBuffer];
        }

        // decode and put the staff to the memory;
        int nCharsPut = conv.decode4(inp, nChars, pConversionBuffer);
        // update count & current pointer
        nCharsInDynamicBuffer += nCharsPut;
        pConversionBuffer += nCharsPut;
    }

    // allocate the buffer and store the result data
    // The same buffer is not reused for conversion, because
    // it's assumed to be saffer to load icon from stream, containing only
    // as much data as required ( we would have larger buffer, containing some
    // uninitialized data at the end if returning buffer used for conversion)
    hGlobAlloc = GlobalAlloc(GMEM_MOVEABLE, nCharsInDynamicBuffer);
    if (hGlobAlloc == NULL)
    {
        hrStatus = E_OUTOFMEMORY;
        goto ON_ERROR;
    }

    // if we have characters, copy them to result
    if (nCharsInDynamicBuffer)
    {
        LPVOID pResultStorage = GlobalLock(hGlobAlloc);
        if (pResultStorage == NULL)
        {
            hrStatus = E_OUTOFMEMORY;
            goto ON_ERROR;
        }
        memcpy(pResultStorage, pDynamicBuffer, nCharsInDynamicBuffer);
        GlobalUnlock(hGlobAlloc);
    }

    // assign the memory handle to caller
    hgResult = hGlobAlloc;
    hGlobAlloc = NULL; // assign null to avoid releasing it

    // adjust poiters to start from where we finished the next time
    pstrSource = p;
    dwCharsLeft = dwLeft;

    hrStatus = S_OK;
ON_ERROR:   // note: ok result falls thru as well
    if (hGlobAlloc)
        GlobalFree(hGlobAlloc);
    if (pDynamicBuffer)
        free(pDynamicBuffer);

    return hrStatus;
}

/***************************************************************************\
 *
 * METHOD:  FindAndReadIconData
 *
 * PURPOSE: Function locates Icon data in the xml file data and loads it into HGLOBAL
 *
 * PARAMETERS:
 *    LPCSTR &pstrSource    - [in/out] - data to look thru / possition
 *                            of the first char following the decoded icon data
 *    int nBytesPerChar     - [in] - width of the character
 *                            ( only the first byte of each character will be examined )
 *    DWORD &dwCharsLeft    - [in/out] - init. data len / data left after skipping decoded
 *    LPCSTR strIconName    - [in] name of Icon to locate
 *                          - NOTE: it assumes icon data to be a base64-encoded stream, saved
 *                            as contents of XML element, having IconName as its attribute
 *    HGLOBAL& hglobIcon    - [out] - memory block containing icon data
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
static HRESULT FindAndReadIconData(LPCSTR &pstrSource, int nBytesPerChar, DWORD &dwCharsLeft, LPCSTR strIconName, HGLOBAL& hglobIcon)
{
    ASSERT(hglobIcon == NULL); // we do not free data here, pass null handler!

    // make local vars for efficiency
    DWORD dwLen = dwCharsLeft;
    LPCSTR pstrData = pstrSource;

    // locate the string with the name of icon (assume it's unique enough)
    const bool bIconFound = FindStringInData( pstrData, nBytesPerChar, dwLen, strIconName);
    if (!bIconFound)
        return E_FAIL;

    // now locate the end of tag '>' ( start of the contents )
    const bool bStartFound = FindStringInData( pstrData, nBytesPerChar, dwLen, ">" );
    if (!bStartFound)
        return E_FAIL;

    HRESULT hr = DecodeBase64Fragment( pstrData, nBytesPerChar, dwLen, hglobIcon);
    if (FAILED(hr))
        return hr;

    // update pointers to start from where we finished the next time
    dwCharsLeft = dwLen;
    pstrSource = pstrData;

    return S_OK;
}

/***************************************************************************\
 *
 * METHOD:  LoadIconFromHGlobal
 *
 * PURPOSE: Function extracts HICON from stream contained in HGLOBAL
 *
 * PARAMETERS:
 *    HGLOBAL hData [in] - data to load from
 *    HICON& hIcon  [out] - read icon
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
static HRESULT LoadIconFromHGlobal(HGLOBAL hData, HICON& hIcon)
{
    HRESULT hr = S_OK;

    // create the stream
    IStreamPtr spStream;
    hr = CreateStreamOnHGlobal(hData, FALSE/*do not release*/, &spStream);
    if (FAILED(hr))
        return hr;

    // read the icon as image list
    HIMAGELIST  himl = ImageList_Read (spStream);

    if (!himl)
        return E_FAIL;

    // retrieve icon from image list
    hIcon = ImageList_GetIcon (himl, 0, ILD_NORMAL);

    // destroy image list (no longer need it)
    ImageList_Destroy (himl);
    return S_OK;
}

/***************************************************************************\
 *
 * METHOD:  LoadIconFromXMLData
 *
 * PURPOSE: Loads icon from memory containing file data of XML document
 *
 * PARAMETERS:
 *    LPCSTR pFileData                  - file data suspected to contain XML document
 *    DWORD dwLen                       - the len of input data
 *    CPersistableIcon &persistableIcon - Icon to initialize upon successful loading
 *
 * RETURNS:
 *    HRESULT    - result code (S_OK - icon loaded, error code else)
 *
\***************************************************************************/
static HRESULT LoadIconFromXMLData(LPCSTR pFileData, DWORD dwLen, CPersistableIcon &persistableIcon)
{
    HRESULT hr = S_OK;
    int     nBytesPerChar = 0;

    // check if we recognize the document contents
    hr = ValidateXMLDocument(pFileData,dwLen, &nBytesPerChar);
    if (hr != S_OK) // hr == S_FALSE means format is not recognized
        return E_FAIL;

    // Get required keywords.
    USES_CONVERSION;
    LPCSTR lpcstrLarge = T2CA(XML_ATTR_CONSOLE_ICON_LARGE);
    LPCSTR lpcstrSmall = T2CA(XML_ATTR_CONSOLE_ICON_SMALL);
	HICON  hLargeIcon  = NULL;
	HICON  hSmallIcon  = NULL;

    // try to read large icon first
    HGLOBAL hgLargeIcon = NULL;
    hr = FindAndReadIconData(pFileData, nBytesPerChar, dwLen, lpcstrLarge, hgLargeIcon );
    if (FAILED(hr))
        return hr;

    // try to read small icon ( look behind the large one - it should be there!)
    HGLOBAL hgSmallIcon = NULL;
    hr = FindAndReadIconData( pFileData, nBytesPerChar, dwLen, lpcstrSmall, hgSmallIcon );
    if (FAILED(hr))
        goto ON_ERROR;

    // do get the handles of the icons!
    hr = LoadIconFromHGlobal(hgLargeIcon, hLargeIcon);
    if (FAILED(hr))
        goto ON_ERROR;

    hr = LoadIconFromHGlobal(hgSmallIcon, hSmallIcon);
    if (FAILED(hr))
        goto ON_ERROR;

	persistableIcon.m_icon32.Attach (hLargeIcon);
	persistableIcon.m_icon16.Attach (hSmallIcon);

    // done!
    hr = S_OK;

ON_ERROR:
	if (hLargeIcon && FAILED(hr))
		DestroyIcon(hLargeIcon);
	if (hSmallIcon && FAILED(hr))
		DestroyIcon(hSmallIcon);
    if (hgLargeIcon)
        GlobalFree(hgLargeIcon);
    return hr;
}

/***************************************************************************\
 *
 * METHOD:  ExtractIconFromXMLFile
 *
 * PURPOSE: Loads icon from file containing XML document
 *
 * PARAMETERS:
 *    LPCTSTR lpstrFileName             - name of file to inspect
 *    CPersistableIcon &persistableIcon - Icon to initialize upon successful loading
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
HRESULT ExtractIconFromXMLFile(LPCTSTR lpstrFileName, CPersistableIcon &persistableIcon)
{
    HRESULT hrResult = S_OK;

    // open the file
    HANDLE hFile = CreateFile(lpstrFileName, GENERIC_READ, FILE_SHARE_READ,
                              NULL, OPEN_EXISTING, 0, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
        return hrResult = HRESULT_FROM_WIN32(GetLastError());

    // map data into virtual memory
    HANDLE hMapping = CreateFileMapping(hFile, NULL/*sec*/, PAGE_READONLY,
                                        0/*sizeHi*/, 0/*sizeLo*/, NULL/*szname*/);

    if (hMapping == NULL)
    {
        hrResult = HRESULT_FROM_WIN32(GetLastError());
        CloseHandle(hFile);
        return hrResult;
    }

    // get pointer to physical memory
    LPVOID pData = MapViewOfFile(hMapping, FILE_MAP_READ, 0/*offHi*/, 0/*offLo*/, 0/*len*/);

    if (pData)
    {
        // we are sure here the sizeHi is zero. mapping should fail else
        DWORD dwLen = GetFileSize(hFile, NULL/*pSizeHi*/);

        // try to load icon from mapped data
        hrResult = LoadIconFromXMLData((LPCSTR)pData, dwLen, persistableIcon);

        // we do not need a view any more
        UnmapViewOfFile(pData);
        pData = NULL;
        // fall thru to release handles before return
    }
    else // getting the view failed
    {
        hrResult = HRESULT_FROM_WIN32(GetLastError());
        // fall thru to release handles before return
    }

    CloseHandle(hMapping);
    CloseHandle(hFile);
    return hrResult;
}

/***************************************************************************\
 *
 * METHOD:  ValidateXMLDocument
 *
 * PURPOSE: Validates XML document loaded into memory
 *          NOTE: it's rather __VERY__ weak inspection. it only checks if doc starts with '<'
 *
 * PARAMETERS:
 *    LPCSTR &pFileData         - [in/out] - data to look thru / start of xml documet contents
 *    DWORD &dwLen              - [in/out] - init. data len / data left after skipping header
 *    int *piBytesPerEnglishChar  - [out, optional] - bytes occupied by english character
 *
 * RETURNS:
 *    HRESULT    - (S_FALSE - data does not qualify for XML document)
 *
\***************************************************************************/
static HRESULT
ValidateXMLDocument(LPCSTR &pFileData, DWORD &dwLen, int *piBytesPerEnglishChar /*= NULL*/)
{
    // default to ansi when not sure
    int     nBytesPerChar = 1;

    if (dwLen >= 2)
    {
        // raw UNICODE big endian ?
        if ((unsigned char)pFileData[1] == 0xff && (unsigned char)pFileData[0] == 0xfe)
        {
            // to maintain simplicity of the code, we will treat this like little endian.
            // we just position file pointer incorrectly.
            // since everything we are intersted:
            //          - is in page 0 (xml tags and base 64)
            //          - never is at the end of file ( closing tags expected )
            //          - we do not care about the page of any data
            //  :we can mix the page codes of the elements and pretend dealing w/ little endian
            pFileData += 3; // skip UNICODE signature and first page number
            dwLen -= 3;
            dwLen /= 2;     // we count characters - seems like we have less of them
            nBytesPerChar = 2;
        }
        // raw UNICODE little endian ?
        else if ((unsigned char)pFileData[0] == 0xff && (unsigned char)pFileData[1] == 0xfe)
        {
            pFileData += 2; // skip UNICODE signature
            dwLen -= 2;
            dwLen /= 2;     // we count characters - seems like we have less of them
            nBytesPerChar = 2;
        }
        // compressed UNICODE (UTF 8) ?
        else if (dwLen >= 2 && (unsigned char)pFileData[0] == 0xef
             && (unsigned char)pFileData[1] == 0xbb && (unsigned char)pFileData[2] == 0xbf)
        {
            //just skip signature and treat it as ANSI
            pFileData += 3; // skip UNICODE signature
            dwLen -= 3;
            nBytesPerChar = 1;
        }
    }

    // skip whitespaces
    char ch;
    while (dwLen && (((ch = *pFileData)==' ') || (ch=='\t') || (ch=='\n') || (ch=='\r')))
    {
        pFileData += nBytesPerChar;
        --dwLen;
    }

    // check if we have a valid xml file (it should open with '<')
    if (!dwLen || *pFileData != '<')
        return S_FALSE;

    if (piBytesPerEnglishChar)
        *piBytesPerEnglishChar = nBytesPerChar;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\inc\init.cxx ===
/*
 *      init.cxx
 *
 *
 *      Copyright (c) 1998 Microsoft Corporation
 *
 *      PURPOSE:        Initializes/deinitializes all required libraries
 *                              Designed to be included into a target DLL file.
 *
 *
 *      OWNER:          vivekj
 */

//              free functions


BOOL
CMMCFrame::s_fInitialized = FALSE;


/* CMMCFrame::CMMCFrame
 *
 * PURPOSE:             Constructor. Initializes the MMC frame class.
 *
 * PARAMETERS:
 *                void:
 */
CMMCFrame::CMMCFrame(void)
{
}



/* CMMCFrame::~CMMCFrame
 *
 * PURPOSE:             Destructor
 *
 * PARAMETERS: None
 *
 */
CMMCFrame::~CMMCFrame()
{
}




/* CMMCFrame::DeinitInstance
 *
 * PURPOSE:             Deinitializes the particular loaded instance of the DLL.
 *
 * PARAMETERS:
 *                void:
 *
 * RETURNS:
 *              void
 */
void
CMMCFrame::DeinitInstance( void )
{
    CBaseUIFrame::DeinitInstance();
}



/* CMMCFrame::ScInitApplication
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *                void:
 *
 * RETURNS:
 *              SC
 */
SC CMMCFrame::ScInitApplication( void )
{
        SC sc = S_OK;

        sc = ScInitApplicationBaseMMC();
        if (sc)
                goto Error;

Cleanup:
        return sc;

Error:
        TraceError(_T("CMMCFrame::ScInitApplication"), sc);
        goto Cleanup;
}

//
// Must uninitialize things that were initialized in
// ScInitApplication.
//
void CMMCFrame::DeinitApplication(void)
{
}


/* CMMCFrame::ScInitInstance
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *                void:
 *
 * RETURNS:
 *              SC
 */
SC CMMCFrame::ScInitInstance( void )
{
        SC              sc = S_OK;
        DWORD   dwFlags = 0;

        sc = CBaseUIFrame::ScInitInstance();
        if (sc)
                goto Error;

        sc = ScInitInstanceBaseMMC();
        if (sc)
                goto Error;

Cleanup:
        return sc;

Error:
        TraceError(_T("CMMCFrame::ScInitInstance"), sc);
        goto Cleanup;
}






CBaseFrame * PframeCreate( void )
{
        CMMCFrame *             pframe;

        pframe = new CMMCFrame;

        return pframe;
}



/* CMMCFrame::Initialize
 *
 * PURPOSE:             This version of Initialize is designed to be called from the DLL_PROCESS_ATTACH section
 *                              of DllMain. It does simple things like setting global static variables.
 *
 * PARAMETERS:
 *              INSTANCE                            hinst:              The handle to the running instance.
 *              HINSTANCE                           hinstPrev:  The handle to any previous instance.
 *              CBaseFrame::PropSheetProviderType   pspt:               The type of property pages needed.
 *                                                  LPSTR:
 *              int                                 n:
 *
 * RETURNS:
 *              void
 */
void
CMMCFrame::Initialize(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR, int n)
{
        CBaseUIFrame::s_hinst = hinst;
        CBaseFrame::s_hinstPrev = hinstPrev;
}

/*      CMMCFrame::Initialize()
 *
 *      PURPOSE:        Initializes the DLL. Note: This should be called by all DLL entry points
 *                              EXCEPT DLLMain, because it creates new threads, which DLLMain cannot do.
 *                              If it is called from DLLMain, the system will hang.
 *
 *      PARAMETERS:     None
 */
void CMMCFrame::Initialize()
{
        SC sc = S_OK;

        if(!s_fInitialized)
        {
                s_fInitialized = TRUE;

                CBaseFrame::s_pframe = PframeCreate();
                if (!CBaseUIFrame::Pframe())
                {
                        sc = E_OUTOFMEMORY;
                        goto Error;
                }

                if (!CBaseFrame::s_hinstPrev)
                {
                        sc = CBaseUIFrame::Pframe()->ScInitApplication();
                        if (sc)
                                goto Error;
                }

                sc = CBaseUIFrame::Pframe()->ScInitInstance();
                if (sc)
                        goto Error;
        }

Cleanup:
        return;

Error:
        TraceError(_T("CMMCFrame::Initialize"), sc);
        MMCErrorBox(sc);

        if (CBaseUIFrame::Pframe())
        {
                CBaseUIFrame::Pframe()->DeinitInstance();
                CBaseUIFrame::Pframe()->DeinitApplication();
                delete CBaseUIFrame::Pframe();
        }

        goto Cleanup;
}


/* CMMCFrame::Uninitialize
 *
 * PURPOSE:             Uninitialized the DLL, freeing up any resources. This should be
 *                              called from the DLL_PROCESS_DETACH section of DllMain.
 *
 * PARAMETERS: None
 *
 * RETURNS:
 *              void
 */
void
CMMCFrame::Uninitialize()
{
        if(s_fInitialized)      // only uninitialize once
        {

                if (CBaseUIFrame::Pframe())
                {
                        CBaseUIFrame::Pframe()->DeinitInstance();
                        CBaseUIFrame::Pframe()->DeinitApplication();
                        delete CBaseUIFrame::Pframe();
                }
        }

        s_fInitialized = FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\inc\targetdll.cxx ===
/*
 *      targetdll.cxx
 *
 *
 *      Copyright (c) 1998-1999 Microsoft Corporation
 *
 *      PURPOSE:        Implements the DLL entry points.
 *
 *
 *      OWNER:          ptousig
 */
#ifndef _SNAPINLIST_FILE
    #error  _SNAPINLIST_FILE not defined
#endif

#ifndef _FREGISTERTYPELIB
    #define _FREGISTERTYPELIB       TRUE    // define this equal to FALSE to avoid registering the typelib.
#endif  //_FREGISTERTYPELIB

#ifndef SNAPIN_COM_OBJECTS
    #define SNAPIN_COM_OBJECTS
#endif


extern "C"
{
    BOOL WINAPI _CRT_INIT( HANDLE hInstance, DWORD  nReason, LPVOID pReserved );
}

#define  DECLARE_SNAPIN(_snapin)                                                                                                                                                                \
template CComponentDataTemplate<_snapin, CComponent, &CLSID_ComponentData_##_snapin>;                                                   \
typedef  CComponentDataTemplate<_snapin, CComponent, &CLSID_ComponentData_##_snapin> t_ComponentData_##_snapin; \
typedef  CSnapinAboutTemplate<_snapin, &CLSID_SnapinAbout_##_snapin> t_SnapinAbout_##_snapin;

#include _SNAPINLIST_FILE

// Declare the ATL COM object map.
BEGIN_OBJECT_MAP(ObjectMap)

#define DECLARE_SNAPIN(_snapin)                                                                                 \
OBJECT_ENTRY(CLSID_ComponentData_##_snapin,     t_ComponentData_##_snapin)      \
OBJECT_ENTRY(CLSID_SnapinAbout_##_snapin,       t_SnapinAbout_##_snapin)        \

#include _SNAPINLIST_FILE
SNAPIN_COM_OBJECTS
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    SC              sc;

    CBaseFrame::s_hinst = hInstance;

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        //
        // since _CRT_INIT will create global variables/objects we must make sure
        // that it is called before we initialize ourselves.
        //
        if (!_CRT_INIT(hInstance, dwReason, lpReserved ))
        {
            sc = ScFromWin32(::GetLastError());
            goto Error;
        }

        CMMCFrame::Initialize(hInstance, NULL, NULL, SW_RESTORE);
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
        CMMCFrame::Uninitialize();

        //
        // since _CRT_INIT will destroy global variables/objects we must make sure
        // that it is called after we have unitialized ourselves.
        //
        if (!_CRT_INIT(hInstance, dwReason, lpReserved ))
        {
            sc = ScFromWin32(::GetLastError());
            goto Error;
        }
    }
    else if (!_CRT_INIT(hInstance, dwReason, lpReserved ))
    {
        sc = ScFromWin32(::GetLastError());
        goto Error;
    }


    return TRUE;    // ok

Error:
    MMCErrorBox(sc);
    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    CMMCFrame::Initialize();
    return(_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    CMMCFrame::Initialize();
    return _Module.GetClassObject(rclsid, riid, ppv);
}


HRESULT RegisterSnapins(BOOL fRegister)
{
    HRESULT hr = S_OK;

    // Register/unregister all snapins.
BEGIN_SNAPIN_MAP()
#define DECLARE_SNAPIN(_snapin) SNAPIN_ENTRY(t_ComponentData_##_snapin, fRegister)
#include _SNAPINLIST_FILE
END_SNAPIN_MAP()

return hr;
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hr      = S_OK;
    CMMCFrame::Initialize();
    hr = RegisterSnapins(TRUE);                     // registers all snap-ins.
    if (FAILED(hr))
        goto Error;
    hr = _Module.RegisterServer(_FREGISTERTYPELIB); // registers object, typelib and all interfaces in typelib
    if (hr)
        goto Error;
    CMMCFrame::Uninitialize();                      // hack to avoid a multithreaded uninit in DllMain
Cleanup:
    return hr;
Error:
goto Cleanup;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hr      = S_OK;
    CMMCFrame::Initialize();
    hr = RegisterSnapins(FALSE);    // unregisters all snap-ins.
    if (FAILED(hr))
        goto Error;
    hr = _Module.UnregisterServer();// does not delete the registry keys.
    if (FAILED(hr))
        goto Error;
    CMMCFrame::Uninitialize();                      // hack to avoid a multithreaded uninit in DllMain
Cleanup:
    return hr;
Error:
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\lib\baseatl.cxx ===
#include <headers.hxx>
#include <atliface.h>
#include <atlimpl.cpp>


// The one and only instance of CComModule.
CComModule _Module;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\lib\basewin.cxx ===
/*
 *      basewin.cxx
 *
 *      Copyright (c) 1998 Microsoft Corporation
 *
 *      Purpose:        Implements the Base Windows classes for Trigger
 *
 *      Owner:          pierrec
 */

#include "headers.hxx"


#include <prsht.h>
#include <process.h>

#ifdef  _DEBUG
CTraceTag       tagAttachDetach(_T("Base"), _T("Attach/Detach"));
CTraceTag       tagFrameProc(_T("Base"), _T("FrProc"));
CTraceTag       tagHelp(_T("{Base}"), _T("Help"));
CTraceTag       tagServiceControl(_T("Base"), _T("ServiceControl"));
CTraceTag       tagProgress(_T("Base"), _T("Progress"));
CTraceTag       tagStartup(_T("BaseWin"), _T("Startup"));
#endif









//              class CBaseFrame

//      Static variables

HINSTANCE                               CBaseFrame::s_hinst                     = NULL;
HINSTANCE                               CBaseFrame::s_hinstPrev         = NULL;
HINSTANCE                               CBaseFrame::s_hinstMailBase;
CBaseFrame *                    CBaseFrame::s_pframe            = NULL;

//tstring                  strFrameClassName(_T("CTriggerFrame"));

CBaseFrame::CBaseFrame()
{
        m_nReturn = 0;
        m_fExit = FALSE;

        m_hicon = NULL;

        SetFrameComponentBits(0);
}





CBaseFrame::~CBaseFrame(void)
{

        s_pframe = NULL;
}




/*
 *      CBaseFrame::DeinitInstance()
 *
 *      Purpose:        Finishes the clean-up & dumps memory leaks.
 */
void CBaseFrame::DeinitInstance()
{
}



LONG CBaseFrame::IdMessageBox(tstring& szMessage, UINT fuStyle)
{
    MMCErrorBox(szMessage.data());
    return 0;
}





// Needed to avoid the compiler warning on SEH & destructors.
void FatalAppExit(SC sc)
{
    MMCErrorBox(sc);
    FatalExit(sc.GetCode());
}


/*
 *      CBaseFrame::OnDestroy()
 *
 *      Purpose:
 *              Exit processing that requires the frame window to still be up
 */
void CBaseFrame::OnDestroy(void)
{
        Detach();
}


DWORD CBaseFrame::DwActiveModeBits(void)
{
        return 0;
}


/*
 *      CBaseFrame::ScInitInstance
 *
 *      Purpose:        Standard Windows InitInstance stuff.
 *
 *      Return value:
 *              sc              error encountered.
 */
SC CBaseFrame::ScInitInstance( void )
{
        SC                      sc;

        return sc;
}



//              class CBaseWindow

/*
 *      Purpose:        Place holder for the virtual destructor.
 */
CBaseWindow::~CBaseWindow(void)
{
        ;
}

void CBaseWindow::Attach(HWND hwnd)
{
        ASSERT(hwnd);

#ifdef _DEBUG
        Trace(tagAttachDetach,
                        _T("Attaching hwnd = %#08lX to this = %#08lX"),
                        hwnd, this);
#endif

        ::SetWindowLong(hwnd, GWL_USERDATA, (LONG) this);
        SetHwnd(hwnd);
}

CBaseWindow * CBaseWindow::Pwin(HWND hwnd)
{
        return (CBaseWindow *) ::GetWindowLong(hwnd, GWL_USERDATA);
}

void CBaseWindow::Detach(void)
{
#ifdef _DEBUG
        Trace(tagAttachDetach,
                        _T("Detaching hwnd = %#08lX from this = %#08lX"),
                        Hwnd(), this);
#endif

        if (Hwnd())
        {
                ::SetWindowLong(Hwnd(), GWL_USERDATA, NULL);
        }
        SetHwnd(NULL);
}


void CBaseWindow::InvalidateWindow(PVOID pv)
{
        ASSERT(pv);
        ASSERT(::IsWindow((HWND) pv));
        ::InvalidateRect((HWND) pv, NULL, FALSE);
}





/*******************************************************************************
*  procedure :  ActiveWaitForObjects
*
*    purpose :  Use MsgWaitForMultipleObjects to wait for signal-state of these
*               objects to change -- but remain alive to process windows messages
*
********************************************************************************/
DWORD   ActiveWaitForObjects (DWORD                             cObjects,
                                                          LPHANDLE                      lphObjects,
                                                          BOOL                          fWaitAll,
                                                          DWORD                         dwTimeout,
                                                          DWORD                         fdwWakeMask)
{
        DWORD   dwWaitResult;
        MSG             msg;

        while (TRUE)
        {
                dwWaitResult = MsgWaitForMultipleObjects (cObjects, lphObjects, fWaitAll, dwTimeout, fdwWakeMask);

                if (dwWaitResult == (WAIT_OBJECT_0 + cObjects))
                {
                        // Process the queued windows messages
                        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                        {
                                TranslateMessage(&msg);
                                DispatchMessage(&msg);
                        }
                }
                else
                        break;
        }

        return(dwWaitResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\lib\componentdata.cxx ===
/*
 *      ComponentData.cxx
 *
 *
 *      Copyright (c) 1998-1999 Microsoft Corporation
 *
 *      PURPOSE:        Defines the CComponentData class.
 *
 *
 *      OWNER:          ptousig
 */

#include "headers.hxx"

// -----------------------------------------------------------------------------
CComponentData::CComponentData(CBaseSnapin *psnapin)
{
    Trace(tagBaseSnapinIComponentData, _T("--> CComponentData::CComponentData(psnapin=0x%08X)"), psnapin);

    ASSERT(psnapin);

    m_psnapin = psnapin;
    m_fIsRealComponentData = FALSE;
    m_pitemStandaloneRoot = NULL;

    Trace(tagBaseSnapinIComponentData, _T("<-- CComponentData::CComponentData has constructed 0x%08X"), this);
}

// -----------------------------------------------------------------------------
// Destructor doesn't do anything, but it's useful to have one for debugging
// purposes.
//
CComponentData::~CComponentData(void)
{
    Trace(tagBaseSnapinIComponentData, _T("--> CComponentData::~CComponentData(), this=0x%08X"), this);

    Psnapin()->ScOwnerDying(this);
    if (m_pitemStandaloneRoot)
    {
        Psnapin()->ScReleaseIfRootItem(m_pitemStandaloneRoot);
    }

    Trace(tagBaseSnapinIComponentData, _T("<-- CComponentData::~CComponentData has destructed 0x%08X"), this);
}

// -----------------------------------------------------------------------------
// This version of Pitem() is a shortcut, it forwards the call to the
// CBaseSnapin with the correct CComponentData parameter.
//
CBaseSnapinItem *CComponentData::Pitem( LPDATAOBJECT lpDataObject,
                                        HSCOPEITEM hscopeitem,
                                        long cookie)
{
    return Psnapin()->Pitem(this, NULL, lpDataObject, hscopeitem, cookie);
}

// -----------------------------------------------------------------------------
// The registration routine expects to find this method on the CComponentData
// but the real implementation is on the CBaseSnapin, so we just forward
// the call.
//
SC CComponentData::ScRegister(BOOL fRegister)
{
    CBaseSnapin* pSnapin = Psnapin();
    return pSnapin->ScRegister(fRegister);
}

// -----------------------------------------------------------------------------
// Is called by the MMC to initialize the object. We QueryInterface
// for pointers to the name space and console, which we cache in
// local variables. This is called only once, when the user clicks on
// the snapin.
//
// $REVIEW (ptousig) I am not sure which of interfaces we are allowed to QI
//                                       for from the parameter. The MMC docs are no help (as usual),
//
SC CComponentData::ScInitialize(LPUNKNOWN pUnknown)
{
    SC                              sc = S_OK;
    IImageListPtr   ipScopeImageList;

    ASSERT(pUnknown != NULL);
    ASSERT(m_ipConsoleNameSpace == NULL);

    m_fIsRealComponentData = TRUE;

    sc = Psnapin()->ScInitBitmaps();
    if (sc)
        goto Error;

    // These are CComQIPtr so they will call QueryInterface.
    m_ipConsoleNameSpace = pUnknown;
    m_ipConsole = pUnknown;
    m_ipResultData = pUnknown;
    m_ipPropertySheetProvider = pUnknown;

    // Get a pointer to the scope pane's IImageList.
    sc = m_ipConsole->QueryScopeImageList(&ipScopeImageList);
    if (sc)
        goto Error;

    // Set the icon strip for the scope pane.
    sc = ipScopeImageList->ImageListSetStrip(
                                             reinterpret_cast<long *>(static_cast<HBITMAP>(Psnapin()->BitmapSmall())),
                                             reinterpret_cast<long *>(static_cast<HBITMAP>(Psnapin()->BitmapLarge())),
                                             0, RGB(255, 0, 255));
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponentData::ScInitialize"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Handles component data event notification.
// See MMC docs for the meaning of 'arg' and 'param'.
//
SC CComponentData::ScNotify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param)
{
    SC sc = S_OK;

    switch (event)
    {
    case MMCN_BTN_CLICK:
        sc = ScOnButtonClick(lpDataObject, (MMC_CONSOLE_VERB) param);
        break;

    case MMCN_DELETE:
        sc = ScOnDelete(lpDataObject);
        break;

    case MMCN_RENAME:
        sc = Psnapin()->ScOnRename(lpDataObject, reinterpret_cast<LPCTSTR>(param), IpConsole());
        break;

    case MMCN_EXPAND:
        sc = ScOnExpand(lpDataObject, arg != FALSE, param);
        break;

    case MMCN_EXPANDSYNC:
        sc = ScOnExpandSync(lpDataObject, reinterpret_cast<MMC_EXPANDSYNC_STRUCT *>(param));
        break;

    case MMCN_PROPERTY_CHANGE:
        sc = Psnapin()->ScOnPropertyChange(arg != FALSE, param, IpConsoleNameSpace(), IpConsole());
        break;

    case MMCN_REMOVE_CHILDREN:
        sc = ScOnRemoveChildren(lpDataObject, arg);
        break;

    default:
        sc = S_FALSE;
        ASSERT(_T("CComponentData::ScNotify: unimplemented event %x"));
        break;
    }

    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponentData::ScNotify"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Releases all interfaces.
//
SC CComponentData::ScDestroy(void)
{
    m_ipConsole.Release();
    m_ipConsoleNameSpace.Release();
    m_ipResultData.Release();
    m_ipPropertySheetProvider.Release();

    return S_OK;
}

/*+-------------------------------------------------------------------------*
 *
 * CComponentData::ScQueryDispatch
 *
 * PURPOSE: Dummy implementation. Does nothing.
 *
 * PARAMETERS:
 *    MMC_COOKIE         cookie :
 *    DATA_OBJECT_TYPES  type :
 *    LPDISPATCH*        ppDispatch :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CComponentData::ScQueryDispatch(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDISPATCH* ppDispatch)
{
    DECLARE_SC(sc, TEXT("CComponentData::ScQueryDispatch"));

    CBaseSnapinItem *pitem = NULL;

    // The component data can handle cookie types of CCT_SNAPIN_MANAGER and CCT_SCOPE.
    // CCT_RESULT are handled by CComponent.
    ASSERT(type==CCT_SCOPE);

    //
    // If the cookie does not correspond to a known object, return E_UNEXPECTED.
    // This is correct and is also a workaround for an MMC bug. See X5:74405.
    //
    if (cookie && (Psnapin()->Pcookielist()->find(cookie) == Psnapin()->Pcookielist()->end() ) )
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    pitem = Pitem(NULL, 0, cookie);
    ASSERT(pitem);

    sc = pitem->ScQueryDispatch(cookie, type, ppDispatch);
    if (sc)
        return sc;

    return sc;
}

// -----------------------------------------------------------------------------
// Load information from the first root item.
//
// $REVIEW (ptousig) Why does the root item implement ScLoad() ?
//                                       If a snapin extends two nodes it has two root items, yet
//                                       only one of which will be saved/loaded.
//
SC CComponentData::ScLoad(IStream *pstream)
{
    SC sc = S_OK;

    // Load the snapin's serialized information.
    sc = Psnapin()->ScLoad(pstream);
    if (sc)
        goto Error;

    // Load the root item's serialized information.
    // Only makes sense for standalone snapins.
    sc = Pitem()->ScLoad(pstream);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponentData::ScLoad"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Determines whether any settings have changed since the last time the file
// was saved.
//
// $REVIEW (ptousig) We are never dirty !!! Shouldn't we ask the Pitem() ?
//
SC CComponentData::ScIsDirty(void)
{
    return S_FALSE;
}

// -----------------------------------------------------------------------------
// If one of the commands added to the context menu is
// subsequently selected, MMC calls Command.
//
// Even though this method "looks" like the one in CComponent,
// the use of the Pitem() shortcut makes them different. This
// version does not pass a component to the real Pitem().
//
SC CComponentData::ScCommand(long nCommandID, LPDATAOBJECT pDataObject)
{
    SC              sc = S_OK;
    CBaseSnapinItem *pitem = NULL;

    pitem = Pitem(pDataObject);
    ASSERT(pitem);

    sc = pitem->ScCommand(nCommandID);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponentData::ScCommand"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Gets display information for a scope pane item
// Warning: This is called very very often (on WM_PAINT) so it is important
// we don't take any high latency actions (ie Network or Disk access).
//
SC CComponentData::ScGetDisplayInfo(LPSCOPEDATAITEM pScopeItem)
{
    SC sc = S_OK;
    CBaseSnapinItem *pitem = NULL;

    pitem = Pitem(NULL, 0, pScopeItem->lParam);
    ASSERT(pitem);

    sc = pitem->ScGetDisplayInfo(pScopeItem);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponentData::ScGetDisplayInfo"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    DECLARE_SC(sc,_T("CComponentData::CompareObjects"));
    Trace(tagBaseSnapinIComponentData, _T("--> %s::IComponentData::CompareObjects(lpDataObjectA=0x%08X, lpDataObjectB=0x%08X), this=0x%08X"), StrSnapinClassName(), lpDataObjectA, lpDataObjectB, this);
    ADMIN_TRY;
    sc=Psnapin()->ScCompareObjects(lpDataObjectA, lpDataObjectB);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIComponentData, _T("<-- %s::IComponentData::CompareObjects is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::GetDisplayInfo(LPSCOPEDATAITEM pItem)
{
    DECLARE_SC(sc,_T("CComponentData::GetDisplayInfo"));
    Trace(tagBaseSnapinIComponentDataGetDisplayInfo, _T("--> %s::IComponentData::GetDisplayInfo(cookie=0x%08X), this=0x%08X"), StrSnapinClassName(), pItem->lParam, this);
    ADMIN_TRY;
    sc=ScGetDisplayInfo(pItem);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIComponentDataGetDisplayInfo, _T("<-- %s::IComponentData::GetDisplayInfo is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::QueryDataObject(long cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT * ppDataObject)
{
    DECLARE_SC(sc,_T("CComponentData::QueryDataObject"));
    Trace(tagBaseSnapinIComponentDataQueryDataObject, _T("--> %s::IComponentData::QueryDataObject(cookie=0x%08X, type=%s), this=0x%08X"), StrSnapinClassName(), cookie, SzGetDebugNameOfDATA_OBJECT_TYPES(type), this);
    ADMIN_TRY;
    //
    // If we receive E_UNEXPECTED we don't want to call MMCHrFromSc because
    // that will bring up an error message. We don't want an error message
    // in this case because of a known MMC bug (see bug X5:74405).
    // The bug says that we might receive QueryDataObject on items that
    // we were told no longer exists (by MMCN_REMOVE_CHILDREN).
    //
    sc = ScQueryDataObject(cookie, type, ppDataObject);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIComponentDataQueryDataObject, _T("<-- %s::IComponentData::QueryDataObject is returning hr=%s, *ppDataObject=0x%08X"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()), *ppDataObject);
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param)
{
    DECLARE_SC(sc,_T("CComponentData::Notify"));
    Trace(tagBaseSnapinIComponentData, _T("--> %s::IComponentData::Notify(lpDataObject=0x%08X, event=%s, arg=0x%08X, param=0x%08X), this=0x%08X"), StrSnapinClassName(), lpDataObject, SzGetDebugNameOfMMC_NOTIFY_TYPE(event), arg, param, this);
    ADMIN_TRY;
    sc=ScNotify(lpDataObject, event, arg, param);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIComponentData, _T("<-- %s::IComponentData::Notify is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::CreateComponent(LPCOMPONENT * ppComponent)
{
    DECLARE_SC(sc,_T("CComponentData::CreateComponent"));
    Trace(tagBaseSnapinIComponentData, _T("--> %s::IComponentData::CreateComponent(...), this=0x%08X"), StrSnapinClassName(), this);
    ADMIN_TRY;
    sc=ScCreateComponent(ppComponent);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIComponentData, _T("<-- %s::IComponentData::CreateComponent is returning hr=%s, *ppComponent=0x%08X"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()), *ppComponent);
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::Initialize(LPUNKNOWN pUnknown)
{
    DECLARE_SC(sc,_T("CComponentData::Initialize"));
    Trace(tagBaseSnapinIComponentData, _T("--> %s::IComponentData::Initialize(pUnknown=0x%08X), this=0x%08X"), StrSnapinClassName(), pUnknown, this);
    ADMIN_TRY;
    sc=ScInitialize(pUnknown);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIComponentData, _T("<-- %s::IComponentData::Initialize is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::Destroy(void)
{
    DECLARE_SC(sc,_T("CComponentData::Destroy"));
    Trace(tagBaseSnapinIComponentData, _T("--> %s::IComponentData::Destroy(), , this=0x%08X"), StrSnapinClassName(), this);
    ADMIN_TRY;
    sc=ScDestroy();
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIComponentData, _T("<-- %s::IComponentData::Destroy is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::QueryDispatch(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDISPATCH* ppDispatch)
{
    DECLARE_SC(sc,_T("CComponentData::QueryDispatch"));
    Trace(tagBaseSnapinIComponentData, _T("--> %s::IComponentData::QueryDispatch(), , this=0x%08X"), StrSnapinClassName(), this);
    ADMIN_TRY;
    sc=ScQueryDispatch(cookie, type, ppDispatch);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIComponentData, _T("<-- %s::IComponentData::QueryDispatch is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}


// -----------------------------------------------------------------------------
HRESULT CComponentData::AddMenuItems(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK ipContextMenuCallback, long *pInsertionAllowed)
{
    DECLARE_SC(sc,_T("CComponentData::AddMenuItems"));
    Trace(tagBaseSnapinIExtendContextMenu, _T("--> %s::IExtendContextMenu::AddMenuItems(pDataObject=0x%08X), this=0x%08X"), StrSnapinClassName(), pDataObject, this);
    ADMIN_TRY;
    // By calling Pitem() at this time, we will force the creation of the ghost
    // root node, if necessary.
    Pitem(pDataObject);
    sc=Psnapin()->ScAddMenuItems(pDataObject, ipContextMenuCallback, pInsertionAllowed);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIExtendContextMenu, _T("<-- %s::IExtendContextMenu::AddMenuItems is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
    DECLARE_SC(sc,_T("CComponentData::Command"));
    Trace(tagBaseSnapinIExtendContextMenu, _T("--> %s::IExtendContextMenu::Command(nCommandID=%ld, pDataObject=0x%08X), this=0x%08X"), StrSnapinClassName(), nCommandID, pDataObject, this);
    ADMIN_TRY;
    sc=ScCommand(nCommandID, pDataObject);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIExtendContextMenu, _T("<-- %s::IExtendContextMenu::Command is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, long handle, LPDATAOBJECT lpDataObject)
{
    DECLARE_SC(sc,_T("CComponentData::CreatePropertyPages"));
    Trace(tagBaseSnapinIExtendPropertySheet, _T("--> %s::IExtendPropertySheet::CreatePropertyPages(lpDataObject=0x%08X), this=0x%08X"), StrSnapinClassName(), lpDataObject, this);
    ADMIN_TRY;
    // Why are we ignoring E_UNEXPECTED ?
    // Because when we are called by the snapin manager, and the user hits cancel we
    // need to return E_UNEXPECTED to MMC.
    sc = ScCreatePropertyPages(lpProvider, handle, lpDataObject);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIExtendPropertySheet, _T("<-- %s::IExtendPropertySheet::CreatePropertyPages is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    DECLARE_SC(sc,_T("CComponentData::QueryPagesFor"));
    Trace(tagBaseSnapinIExtendPropertySheet, _T("--> %s::IExtendPropertySheet::QueryPagesFor(lpDataObject=0x%08X), this=0x%08X"), StrSnapinClassName(), lpDataObject, this);
    ADMIN_TRY;
    sc=ScQueryPagesFor(lpDataObject);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIExtendPropertySheet, _T("<-- %s::IExtendPropertySheet::QueryPagesFor is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    DECLARE_SC(sc,_T("CComponentData::GetSizeMax"));
    Trace(tagBaseSnapinIPersistStreamInit, _T("--> %s::IPersistStreamInit::GetSizeMax(...), , this=0x%08X"), StrSnapinClassName(), this);
    ADMIN_TRY;
    pcbSize->LowPart = cMaxStreamSizeLow;
    pcbSize->HighPart = cMaxStreamSizeHigh;
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIPersistStreamInit, _T("<-- %s::IPersistStreamInit::GetSizeMax is returning hr=%s, (*pcbSize).LowPart=%d"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()), (*pcbSize).LowPart);
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::IsDirty(void)
{
    DECLARE_SC(sc,_T("CComponentData::IsDirty"));
    Trace(tagBaseSnapinIPersistStreamInit, _T("--> %s::IPersistStreamInit::IsDirty(), this=0x%08X"), StrSnapinClassName(), this);
    ADMIN_TRY;
    sc=ScIsDirty();
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIPersistStreamInit, _T("<-- %s::IPersistStreamInit::IsDirty is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::Load(IStream *pstream)
{
    DECLARE_SC(sc,_T("CComponentData::Load"));
    Trace(tagBaseSnapinIPersistStreamInit, _T("--> %s::IPersistStreamInit::Load(...), this=0x%08X"), StrSnapinClassName(), this);
    ADMIN_TRY;
    sc=ScLoad(pstream);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIPersistStreamInit, _T("<-- %s::IPersistStreamInit::Load is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::Save(IStream *pstream, BOOL fClearDirty)
{
    DECLARE_SC(sc,_T("CComponentData::Save"));
    Trace(tagBaseSnapinIPersistStreamInit, _T("--> %s::IPersistStreamInit::Save(fClearDirty=%S), this=0x%08X"), StrSnapinClassName(), fClearDirty ? "TRUE" : "FALSE", this);
    ADMIN_TRY;
    sc=ScSave(pstream, fClearDirty);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIPersistStreamInit, _T("<-- %s::IPersistStreamInit::Save is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::InitNew(void)
{
    DECLARE_SC(sc,_T("CComponentData::InitNew"));
    // We don't have anything to do, but we still want to log the call.
    Trace(tagBaseSnapinIPersistStreamInit, _T("--> %s::IPersistStreamInit::InitNew(), this=0x%08X"), StrSnapinClassName(), this);
    Trace(tagBaseSnapinIPersistStreamInit, _T("<-- %s::IPersistStreamInit::InitNew is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::GetClassID(CLSID *pclsid)
{
    DECLARE_SC(sc,_T("CComponentData::GetClassID"));
    Trace(tagBaseSnapinIPersistStreamInit, _T("--> %s::IPersistStreamInit::GetClassID(...), this=0x%08X"), StrSnapinClassName(), this);
    ADMIN_TRY;
    *pclsid = *(Psnapin()->PclsidSnapin());
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIPersistStreamInit, _T("<-- %s::IPersistStreamInit::GetClassID is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::Compare(RDCOMPARE * prdc, int * pnResult)
{
    DECLARE_SC(sc,_T("CComponentData::Compare"));
    Trace(tagBaseSnapinIResultDataCompare, _T("--> %s::IResultDataCompare::Compare(cookieA=0x%08X, cookieB=0x%08X), this=0x%08X"), StrSnapinClassName(), prdc->prdch1->cookie, prdc->prdch2->cookie, this);
    ADMIN_TRY;
    ASSERT(pnResult);
    ASSERT(prdc);
    ASSERT(prdc->prdch1);
    ASSERT(prdc->prdch2);
    sc=Psnapin()->ScCompare(prdc->prdch1->cookie, prdc->prdch2->cookie, prdc->nColumn, pnResult);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIResultDataCompare, _T("<-- %s::IResultDataCompare::Compare is returning hr=%s, *pnResult=%d"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()), *pnResult);
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
// Returns the full path of the compiled file (.chm) for the snapin.
//
HRESULT CComponentData::GetHelpTopic(LPOLESTR *lpCompiledHelpFile)
{
    DECLARE_SC(sc,_T("CComponentData::GetHelpTopic"));
    tstring strCompiledHelpFile;
    USES_CONVERSION;

    Trace(tagBaseSnapinISnapinHelp, _T("--> %s::ISnapinHelp::GetHelpTopic(...), this=0x%08X"), StrSnapinClassName(), this);
    ADMIN_TRY;

    if (lpCompiledHelpFile == NULL)
    {
        sc = E_POINTER;
        goto Error;
    }

    // Automatically displays an error box.
    sc = Psnapin()->ScGetHelpTopic(strCompiledHelpFile);
    if (sc)
        goto Error;

    if (strCompiledHelpFile.empty())
    {
        sc=S_FALSE;
    }
    else
    {
        *lpCompiledHelpFile = reinterpret_cast<LPOLESTR>(CoTaskMemAlloc( (strCompiledHelpFile.length()+1)*sizeof(TCHAR)) );
        sc = ScCheckPointers(*lpCompiledHelpFile, E_OUTOFMEMORY);
        if (sc)
            goto Error;

        wcscpy(*lpCompiledHelpFile, T2CW(strCompiledHelpFile.data()) );
    }

    if (sc)
        goto Error;             // an exception was caught

Cleanup:
    Trace(tagBaseSnapinISnapinHelp, _T("<-- %s::ISnapinHelp::GetHelpTopic is returning hr=%s, lpCompiledHelpFile=\"%s\""), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()), strCompiledHelpFile.data());
    return(sc.ToHr());
Error:
    TraceError(_T("CComponentData::GetHelpTopic"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Creates a data object of the appropriate type, and returns the IDataObject interface
// on it
//
SC CComponentData::ScQueryDataObject(long cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
    SC                              sc = S_OK;
    CBaseSnapinItem *pitem = NULL;

    // The component data can handle cookie types of CCT_SNAPIN_MANAGER and CCT_SCOPE.
    // CCT_RESULT are handled by CComponent.
    ASSERT(type==CCT_SNAPIN_MANAGER || type==CCT_SCOPE);

    //
    // If the cookie does not correspond to a known object, return E_UNEXPECTED.
    // This is correct and is also a workaround for an MMC bug. See X5:74405.
    //
    if (cookie && (Psnapin()->Pcookielist()->find(cookie) == Psnapin()->Pcookielist()->end() ) )
    {
        sc = E_UNEXPECTED;
        goto Cleanup;
    }

    pitem = Pitem(NULL, 0, cookie);
    ASSERT(pitem);

    sc = pitem->ScQueryDataObject(cookie, type, ppDataObject);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponentData::ScQueryDataObject"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Handles the MMCN_EXPAND notification sent to IComponentData::Notify
//
SC CComponentData::ScOnExpand(LPDATAOBJECT lpDataObject, BOOL fExpand, HSCOPEITEM hscopeitem)
{
    SC              sc = S_OK;
    CBaseSnapinItem *pitem = NULL;

    if (fExpand == FALSE)                                    // do nothing on a "contract"
        goto Cleanup;

    pitem = Pitem(lpDataObject, hscopeitem);
    ASSERT(pitem);

    // Use this opportunity to correlate the CSnapinItem and the HSCOPEITEM.
    // $REVIEW (ptousig) Should be done inside Pitem().
    pitem->SetHscopeitem(hscopeitem);
    pitem->SetComponentData(this);

    if (pitem->PitemChild())
    {
        // We have a list of partial children.  We need to remove
        // them because we are going to ask the snapin to enumerate
        // all of it's children. Do not get rid of this node.
        // This can happen if a node creates new children before it is
        // expanded.
        //
        // $REVIEW (ptousig) Creating a child when the parent is not expanded
        //                                       should simply not add the child.
        //
        sc = pitem->ScDeleteSubTree(FALSE);
        if (sc)
            goto Error;
    }

    // If we're creating the children, make sure there aren't any around.
    ASSERT(pitem->PitemChild() == NULL);

    sc = pitem->ScCreateChildren();
    if (sc)
        goto Error;

    if (pitem->PitemChild())
    {
        // Add or remove children to/from the console.
        sc = pitem->PitemChild()->ScInsertScopeItem(this, fExpand, hscopeitem);
        if (sc)
            goto Error;
    }

    pitem->SetWasExpanded(TRUE);

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponentData::ScOnExpand"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Called by the MMC to delete the cookies for the entire subtree under a node. This
// is only to clean up allocated objects. Do NOT call IConsoleNameSpace::DeleteItem.
//
SC CComponentData::ScOnRemoveChildren(LPDATAOBJECT lpDataObject, HSCOPEITEM hscopeitem)
{
    SC sc = S_OK;
    CBaseSnapinItem *pitem = NULL;

    pitem = Pitem(lpDataObject, hscopeitem);
    ASSERT(pitem);

    // Get rid of the children.
    sc = pitem->ScDeleteSubTree(FALSE);
    if (sc)
        goto Error;

    // Release the given node if it is one of the root nodes
    sc = Psnapin()->ScReleaseIfRootItem(pitem);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponentData::ScOnRemoveChildren"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Allows a snapin to control whether it will populate the scope pane
// in the background or not.
//
SC CComponentData::ScOnExpandSync(LPDATAOBJECT lpDataObject, MMC_EXPANDSYNC_STRUCT *pmes)
{
    // We don't care.
    return S_OK;
}

// -----------------------------------------------------------------------------
// The user has asked to delete this node.
//
SC CComponentData::ScOnDelete(LPDATAOBJECT pDataObject)
{
    SC                               sc                             = S_OK;
    CBaseSnapinItem *pitem                  = NULL;
    BOOL                     fDeleted               = FALSE;
    BOOL                     fPagesUp               = FALSE;
    tstring                  strMsg;

    pitem = Pitem(pDataObject);
    ASSERT(pitem);

    // The ComponentData should only receive notifications for scope pane items.
    ASSERT(pitem->FIsContainer());

    sc = pitem->ScIsPropertySheetOpen(&fPagesUp);
    if (sc)
        goto Error;

    if (fPagesUp)
    {
        ASSERT(FALSE && "Add below resource");
        //strMsg.LoadString(_Module.GetResourceInstance(), idsPropsUpNoDelete);
        strMsg += (*pitem->PstrDisplayName());
        MMCErrorBox(strMsg.data());
        goto Cleanup;
    }

    // Ask the item to delete the underlying object.
    sc = pitem->ScOnDelete(&fDeleted);
    if (sc)
        goto Error;

    if (fDeleted == FALSE)
        // The item did not want to be deleted.
        goto Cleanup;

    // Container items need to be deleted from the document
    // Delete the item and everything below it.
    sc = IpConsoleNameSpace()->DeleteItem(pitem->Hscopeitem(), TRUE);
    if (sc)
        goto Error;
    pitem->SetHscopeitem(0);

    // At this point, the item exists only in the tree, if at all.
    // Remove it from the tree.
    pitem->Unlink();
    // Get rid of it for good from the tree of items.
    pitem->Pdataobject()->Release();

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponentData::ScOnDelete"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Toolbar button clicked.
//
SC CComponentData::ScOnButtonClick(LPDATAOBJECT lpDataObject, MMC_CONSOLE_VERB mcvVerb)
{
    return S_OK;
}

// -----------------------------------------------------------------------------
// Used to insert a new item into the tree of items, and, if the item is a container,
// into the namespace as well. The tree and the namespace are document, not view,
// concept. This insertion is done only once.
//
SC CComponentData::ScOnDocumentChangeInsertItem(CBaseSnapinItem *pitemNew)
{
    SC                                      sc                              = S_OK;
    CBaseSnapinItem *       pitemParent             = NULL;

    ASSERT(pitemNew);

    // Insert exactly once.
    if (pitemNew->FInserted())
        goto Cleanup;

    // The parent should have already been filled in
    pitemParent = pitemNew->PitemParent();
    ASSERT(pitemParent);

    if (pitemParent->FIncludesChild(pitemNew) == FALSE)
    {
        sc = pitemParent->ScAddChild(pitemNew);
        if (sc)
            goto Error;
    }

    if (pitemNew->FIsContainer())
    {
        if (pitemParent->FWasExpanded())
        {
            sc = pitemNew->ScInsertScopeItem(this, TRUE, pitemParent->Hscopeitem());
            if (sc)
                goto Error;
        }
    }

    // Only insert the item once.
    pitemNew->SetInserted(TRUE);

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponentData::ScOnDocumentChangeInsertItem"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Tests whether the given item has already enumerated its children.
//
SC CComponentData::ScWasExpandedOnce(CBaseSnapinItem *pitem, BOOL *pfWasExpanded)
{
    SC sc = S_OK;
    SCOPEDATAITEM sdi;

    if (pitem->Hscopeitem() == 0)
    {
        //
        // If we don't have an HSCOPEITEM then we are not displayed in
        // the scope pane, therefore we have never been expanded (and
        // probably never will).
        //
        *pfWasExpanded = FALSE;
        goto Cleanup;
    }

    //
    // Ask for the state member of SCOPEDATAITEM
    //
    ::ZeroMemory(&sdi, sizeof(SCOPEDATAITEM));
    sdi.mask = SDI_STATE;
    sdi.ID = pitem->Hscopeitem();

    sc = IpConsoleNameSpace()->GetItem(&sdi);
    if (sc)
        goto Error;

    //
    // If the MMC_SCOPE_ITEM_STATE_EXPANDEDONCE is on it means we have
    // been asked to expand ourselves at least once before.
    //
    *pfWasExpanded = (sdi.nState & MMC_SCOPE_ITEM_STATE_EXPANDEDONCE) != 0;

Cleanup:
    return sc;

Error:
    TraceError(_T("CComponentData::ScWasExpandedOnce"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Adds property pages for the given data object, taking into account the context and also
// whether the data object is for a new object that is being created.
//
SC CComponentData::ScCreatePropertyPages(LPPROPERTYSHEETCALLBACK ipPropertySheetCallback, long handle, LPDATAOBJECT pDataObject)
{
    SC              sc = S_OK;
    CBaseSnapinItem *pitem = NULL;

    pitem = Pitem(pDataObject);
    ASSERT(pitem);

    if (pitem->FIsSnapinManager())
    {
        sc = pitem->ScCreateSnapinMgrPropertyPages(ipPropertySheetCallback);
        if (sc)
            goto Error;
    }
    else
    {
        // Simple version
        sc = pitem->ScCreatePropertyPages(ipPropertySheetCallback);
        if (sc)
            goto Error;

        // Complete version - for snapins that need all information (like Recipients)
        sc = pitem->ScCreatePropertyPages(ipPropertySheetCallback, handle);
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponentData::ScCreatePropertyPages"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Save information from the first root item.
//
// $REVIEW (ptousig) Why does the root item implement ScSave() ?
//                                       If a snapin extends two nodes it has two root items, yet
//                                       only one of which will be saved/loaded.
//
SC CComponentData::ScSave(IStream *pstream, BOOL fClearDirty)
{
    SC sc = S_OK;

    // Save the snapin's serialized information.
    sc = Psnapin()->ScSave(pstream, fClearDirty);
    if (sc)
        goto Error;

    // Load the root item's serialized information.
    // Only makes sense for standalone snapins.
    sc = Pitem()->ScSave(pstream, fClearDirty);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponentData::ScSave"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Given a dataobject, determines whether or not pages exist.
// Actually, need to return S_OK here in both cases. If no pages exist
// it is CreatePropertyPages that should return S_FALSE. Sad but true.
//
SC CComponentData::ScQueryPagesFor(LPDATAOBJECT pDataObject)
{
    SC                              sc                      = S_OK;
    CBaseSnapinItem *       pitem           = NULL;

    pitem = Pitem(pDataObject);
    ASSERT(pitem);

    sc = pitem->ScQueryPagesFor();
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponentData::ScQueryPagesFor"), sc);
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\lib\component.cxx ===
/*
 *      Component.cxx
 *
 *
 *      Copyright (c) 1998-1999 Microsoft Corporation
 *
 *      PURPOSE:        Defines the CComponent class.
 *
 *
 *      OWNER:          ptousig
 */

#include "headers.hxx"

// -----------------------------------------------------------------------------
CComponent::CComponent(void)
{
    m_pComponentData                                = NULL;
    m_pitemScopeSelected                    = NULL;
    m_pMultiSelectSnapinItem                = NULL;                 // initially not involved in a multi select
}

// -----------------------------------------------------------------------------
// Destructor doesn't do anything, but it's useful to have one for debugging
// purposes.
//
CComponent::~CComponent(void)
{
}

// -----------------------------------------------------------------------------
// This version of Pitem() is a shortcut, it forwards the call to the
// CBaseSnapin with the correct CComponentData and CComponent parameters.
//
CBaseSnapinItem *CComponent::Pitem(
                                  LPDATAOBJECT lpDataObject,
                                  HSCOPEITEM hscopeitem,
                                  long cookie)
{
    return Psnapin()->Pitem(PComponentData(), this, lpDataObject, hscopeitem, cookie);
}

// -----------------------------------------------------------------------------
// Tells this component who the data is. Called shortly after the construction
// of the object. Why isn't this a parameter of the constructor ? Because ATL
// will always use the default constructor when creating a COM object.
//
void CComponent::SetComponentData(CComponentData *pComponentData)
{
    m_pComponentData = pComponentData;
}


/*+-------------------------------------------------------------------------*
 *
 * CComponent::QueryIComponent2
 *
 * PURPOSE: Determines whether or not to expose the IComponent2 interface on
 *          the object. This is because snapins that implement IComponent2
 *          will not be able to test IComponent::GetResultViewType and the MMCN_RESTORE_VIEW
 *          notification.
 *
 * PARAMETERS:
 *    void*   pv :
 *    REFIID  riid :
 *    LPVOID* ppv :   pointer to the "this" object.
 *    DWORD   dw :
 *
 * RETURNS:
 *    HRESULT WINAPI
 *
 *+-------------------------------------------------------------------------*/
HRESULT WINAPI
CComponent::QueryIComponent2(void* pv, REFIID riid, LPVOID* ppv, DWORD dw)
{
    DECLARE_SC(sc, TEXT("CComponent::QueryIComponent2"));
    sc = ScCheckPointers(ppv);
    if (sc)
        return sc.ToHr();

    *ppv = NULL;

    CComponent *pComponent = reinterpret_cast<CComponent *>(pv);
    if(!pComponent)
        return E_NOINTERFACE;

    sc = ScCheckPointers(pComponent->Psnapin());
    if(sc)
        return E_NOINTERFACE;

    if(pComponent->Psnapin()->FSupportsIComponent2())
    {
        // Cant use QueryInterface as it will cause infinite recursion.
        (*ppv) = (LPVOID)reinterpret_cast<IComponent2*>(pv);
        if (*ppv)
        {
            ((IUnknown*)(*ppv))->AddRef();
            return S_OK;
        }
    }

    return E_NOINTERFACE;
}


// -----------------------------------------------------------------------------
// Is called by the MMC to initialize the object. We QueryInterface
// for pointers to various interfaces, which we cache in
// member variables. This is called only once, when the user clicks on
// the snapin.
//
// $REVIEW (ptousig) I am not sure which of interfaces we are allowed to QI
//                                       for from the parameter. The MMC docs are no help (as usual),
//
SC CComponent::ScInitialize(LPCONSOLE lpConsole)
{
    DECLARE_SC(sc, _T("CComponent::ScInitialize"));

    ASSERT(lpConsole != NULL);
    ASSERT(m_ipConsole == NULL);

    // These are CComQIPtr so they will call QueryInterface.
    m_ipConsole                                     = lpConsole;
    m_ipHeaderCtrl                          = lpConsole;
    m_ipColumnDataPtr                       = lpConsole;
    m_ipResultData                          = lpConsole;
    m_ipPropertySheetProvider       = lpConsole;

    ASSERT( (m_ipConsole != NULL) || (m_ipHeaderCtrl != NULL) || (m_ipResultData!=NULL) || (m_ipPropertySheetProvider!=NULL) );

    // Short circuit the header control pointer back to the MMC
    sc = m_ipConsole->SetHeader(m_ipHeaderCtrl);
    if (sc)
        goto Error;

    // Get the IConsoleVerb interface.
    sc = m_ipConsole->QueryConsoleVerb(&m_ipConsoleVerb);
    if (sc)
        goto Error;

    // Get a pointer to the result pane's IImageList.
    sc = m_ipConsole->QueryResultImageList(&m_ipImageList);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScInitialize"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Handles component event notification.
// See MMC docs for the meaning of 'arg' and 'param'.
//
SC CComponent::ScNotify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param)
{
    SC sc = S_OK;

    switch (event)
    {
    case MMCN_ACTIVATE:
        sc = ScOnActivate(lpDataObject, arg != FALSE);
        break;

    case MMCN_ADD_IMAGES:
        sc = ScOnAddImages(lpDataObject, reinterpret_cast<IImageList *>(arg), param);
        break;

    case MMCN_BTN_CLICK:
        sc = ScOnButtonClick(lpDataObject, (MMC_CONSOLE_VERB) param);
        break;

    case MMCN_CONTEXTHELP:
        sc = ScOnContextHelp(lpDataObject);
        break;

    case MMCN_DBLCLICK:
        sc = ScOnDoubleClick(lpDataObject);
        break;

    case MMCN_DELETE:
        sc = ScOnDelete(lpDataObject);
        break;

    case MMCN_CUTORMOVE:
        sc = Psnapin()->ScOnCutOrMove(reinterpret_cast<LPDATAOBJECT>(arg), IpConsoleNameSpace(), IpConsole());
        break;

    case MMCN_QUERY_PASTE:
        sc = Psnapin()->ScOnQueryPaste(lpDataObject, reinterpret_cast<LPDATAOBJECT>(arg), reinterpret_cast<LPDWORD>(param));
        break;

    case MMCN_CANPASTE_OUTOFPROC:
        sc = Psnapin()->ScOnCanPasteOutOfProcDataObject(reinterpret_cast<LPBOOL>(param));
        break;

    case MMCN_PASTE:
        sc = Psnapin()->ScOnPaste(lpDataObject, reinterpret_cast<LPDATAOBJECT>(arg), reinterpret_cast<LPDATAOBJECT *>(param), IpConsole());
        break;

    case MMCN_RENAME:
        sc = Psnapin()->ScOnRename(lpDataObject, reinterpret_cast<LPCTSTR>(param), IpConsole());
        break;

    case MMCN_LISTPAD:
        sc = ScOnListPad(lpDataObject, arg != FALSE);
        break;

    case MMCN_PROPERTY_CHANGE:
        sc = Psnapin()->ScOnPropertyChange(arg != FALSE, param, IpConsoleNameSpace(), IpConsole());
        break;

    case MMCN_REFRESH:
        //
        // Undocumented: arg is the HSCOPEITEM
        //
        sc = ScOnRefresh(lpDataObject, arg);
        break;

    case MMCN_SELECT:
        sc = ScOnSelect(lpDataObject, LOWORD(arg) != FALSE, HIWORD(arg) != FALSE);
        break;

    case MMCN_SHOW:
        sc = ScOnShow(lpDataObject, arg != FALSE, param);
        break;

    case MMCN_VIEW_CHANGE:
        sc = ScOnViewChange(lpDataObject, arg, param);
        break;

    case MMCN_INITOCX:
        sc = ScOnInitOCX(lpDataObject, reinterpret_cast<IUnknown*>(param));
        break;

    default:
		sc = S_FALSE;
        ASSERT(_T("CComponent::ScNotify: unimplemented event"));
        break;
    }
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScNotify"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Releases all interfaces.
//
SC CComponent::ScDestroy(void)
{
    if (m_ipConsole)
        // Release the interfaces that we QI'ed
        m_ipConsole->SetHeader(NULL);

    m_ipConsole.Release();
    m_ipHeaderCtrl.Release();
    m_ipColumnDataPtr.Release();
    m_ipResultData.Release();
    m_ipConsoleVerb.Release();
    m_ipImageList.Release();
    m_ipPropertySheetProvider.Release();

    return S_OK;
}

// -----------------------------------------------------------------------------
// MMC wants to know what to display for a given result item.
// Warning: This is called very very often (on WM_PAINT) so it is important
// we don't take any high latency actions (ie Network or Disk access).
//
SC CComponent::ScGetDisplayInfo(LPRESULTDATAITEM pResultItem)
{
    SC                      sc = S_OK;
    CBaseSnapinItem *pitem = NULL;

    // We need to figure out which snapin item to route the getdisplayinfo
    if (FVirtualResultsPane())
    {
        // We are displaying virtual items in the results pane.  So
        // we will ask the controlling scope item to get the display
        // info because no "real" item exists in the results pane.
        ASSERT(PitemScopeSelected());

        sc = PitemScopeSelected()->ScGetVirtualDisplayInfo(pResultItem, IpResultData());
        if (sc)
            goto Error;
    }
    else
    {
        // The lParam member of RESULTDATAITEM contains the cookie.
        pitem = Pitem(NULL, 0, pResultItem->lParam);
        ASSERT(pitem);

        sc = pitem->ScGetDisplayInfo(pResultItem);
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScGetDisplayInfo"), sc);
    goto Cleanup;
}


/*+-------------------------------------------------------------------------*
 *
 * CComponent::ScQueryDispatch
 *
 * PURPOSE: Returns a dispatch interface for the specified data object.
 *
 * PARAMETERS:
 *    MMC_COOKIE         cookie :
 *    DATA_OBJECT_TYPES  type :
 *    LPDISPATCH*        ppDispatch :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CComponent::ScQueryDispatch(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDISPATCH* ppDispatch)
{
    DECLARE_SC(sc, TEXT("CComponent::ScQueryDispatch"));
    CBaseSnapinItem *               pitem           = NULL;

    // Determine if we have a special cookie for multiselect
    if (IS_SPECIAL_COOKIE(cookie) && (MMC_MULTI_SELECT_COOKIE == cookie))
    {
        // Make sure we are queried for a multiselect
        ASSERT(CCT_UNINITIALIZED == type);

        // We need to create a special multiselect data object
        ASSERT(Psnapin());

        //NOTE: need to implement multi select dispatch obect
        sc = S_FALSE; //Psnapin()->ScCreateMultiSelectionDataObject(ppDataObject, this);
        if (sc)
            return sc;
    }
    else
    {
        // We are a component, we should only receive result pane cookies.
        ASSERT(type==CCT_RESULT);

        if (FVirtualResultsPane())
        {
            ASSERT(PitemScopeSelected());

            // This function is being asked for a data object for a row in a virtual
            // results pane.  By definition there is no snapin item there.  So we ask
            // the controlling scope item to provide us with a "temporary" data object.
            sc = S_FALSE; //PitemScopeSelected()->ScVirtualQueryDataObject(cookie, type, ppDataObject);
            if (sc)
                return sc;
        }
        else
        {
            // If the cookie does not correspond to a known object, return E_UNEXPECTED.
            // This is correct and is also a workaround for a MMC bug. See bug X5:74405.
            if (cookie && (Psnapin()->Pcookielist()->find(cookie) == Psnapin()->Pcookielist()->end() ) )
            {
                return(sc = E_UNEXPECTED);
            }

            pitem = Pitem(NULL, 0, cookie);
            ASSERT(pitem);

            sc = pitem->ScQueryDispatch(cookie, type, ppDispatch);
            if (sc)
                return sc;
        }
    }


    return sc;
}

SC
CComponent::ScGetResultViewType2(MMC_COOKIE cookie, PRESULT_VIEW_TYPE_INFO pResultViewType)
{
    DECLARE_SC(sc, _T("CComponent::ScGetResultViewType2"));
    CBaseSnapinItem *pitem = NULL;

    ASSERT(pResultViewType);

    pitem = Pitem(NULL, 0, cookie);
    ASSERT(pitem);

    sc = pitem->ScGetResultViewType2(m_ipConsole, pResultViewType);
    if (sc)
        return sc;

    return sc;
}

SC
CComponent::ScRestoreResultView(MMC_COOKIE cookie, RESULT_VIEW_TYPE_INFO* pResultViewType)
{
    DECLARE_SC(sc, _T("CComponent::ScRestoreResultView"));
    CBaseSnapinItem *pitem = NULL;

    ASSERT(pResultViewType);

    pitem = Pitem(NULL, 0, cookie);
    ASSERT(pitem);

    sc = pitem->ScRestoreResultView(pResultViewType);
    if (sc)
        return sc;

    return sc;
}


// -----------------------------------------------------------------------------
// Handles the MMCN_SELECT notification sent to IComponent::Notify. Enables the Properties
// and Refresh verbs. Sets Properties as the default verb.
//
SC CComponent::ScOnSelect(LPDATAOBJECT lpDataObject, BOOL fScope, BOOL fSelect)
{
    // Declarations
    SC                                                      sc                                                      = S_OK;
    DWORD                                           dwVerbs                                         = 0;
    MMC_CONSOLE_VERB                        mmcverbDefault                          = MMC_VERB_NONE;
    INT                                                     i                                                       = 0;
    CBaseSnapinItem *                       pitem                                           = NULL;
    CBaseMultiSelectSnapinItem *pBaseMultiSelectSnapinItem  = NULL;

    // Data validation
    ASSERT(lpDataObject);

    // Determine if this is a multiselect data object
    sc = CBaseMultiSelectSnapinItem::ScGetMultiSelectDataObject(lpDataObject, &pBaseMultiSelectSnapinItem);
    if (sc)
        goto Error;

    // If we received a multiselect snapin item
    if (pBaseMultiSelectSnapinItem)
    {
        // Call ScOnSelect for the multiselect object for dispatch
        sc = pBaseMultiSelectSnapinItem->ScOnSelect(this, lpDataObject, fScope, fSelect);
        if (sc)
            goto Error;
    }
    else
    {
        // Handle the normal case - PItem() does more work than a simple cast to verify that the snapin item belongs to the snapin etc.
        pitem = Pitem(lpDataObject);
        ASSERT(pitem);

        if (pitem->FIsContainer())
        {
            // Enable the Open property             // $REVIEW (dominicp) Why 2 separate calls?
            sc = IpConsoleVerb()->SetVerbState(MMC_VERB_OPEN, ENABLED, TRUE);
            if (sc)
                goto Error;

            // Need to hide it but keep it enabled.
            sc = IpConsoleVerb()->SetVerbState(MMC_VERB_OPEN, HIDDEN, TRUE);
            if (sc)
                goto Error;
        }

        if (fSelect)
        {
            // Get all the required verbs, bitwise-ORed together.
            sc = Psnapin()->ScGetVerbs(lpDataObject, &dwVerbs);
            if (sc)
                goto Error;

            // Loop through the list of verbs, turning on the needed ones.
            for (i=0; i<Psnapin()->Cverbmap(); i++)
            {
                ASSERT(Psnapin()->Pverbmap(i));
                if (dwVerbs & Psnapin()->Pverbmap(i)->verbmask)
                {
                    sc = IpConsoleVerb()->SetVerbState(Psnapin()->Pverbmap(i)->mmcverb, ENABLED, TRUE);
                    if (sc)
                        goto Error;
                }
            }

#ifdef _DEBUG
            if (tagBaseSnapinDebugCopy.FAny())
            {
                sc = IpConsoleVerb()->SetVerbState(MMC_VERB_COPY, ENABLED, TRUE);
                if (sc)
                    goto Error;
            }
#endif

            // Get the default verb.
            mmcverbDefault = Psnapin()->MmcverbDefault(lpDataObject);

            // Set the default verb, which is invoked by double clicking.
            if (mmcverbDefault != MMC_VERB_NONE)
            {
                sc = IpConsoleVerb()->SetDefaultVerb(mmcverbDefault);
                if (sc)
                    goto Error;
            }
        }

        // To call DisplayStatusText for example, we need to get to the IComponent's IConsole2
        // IComponentData's IConsole2 is no good, so we pass 'this'
        sc = pitem->ScOnSelect(this, lpDataObject, fScope, fSelect);
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScOnSelect"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Loads per-view information. We don't have any.
//
SC CComponent::ScLoad(IStream *pstream)
{
    return S_OK;
}

// -----------------------------------------------------------------------------
// If one of the commands added to the context menu is
// subsequently selected, MMC calls Command.
//
// Even though this method "looks" like the one in CComponentData,
// the use of the Pitem() shortcut makes them different. The CComponentData
// version does not pass a component to the real Pitem().
//
SC CComponent::ScCommand(long nCommandID, LPDATAOBJECT lpDataObject)
{
    // Declarations
    SC                                                                      sc                                                      = S_OK;
    CBaseSnapinItem *                                       pitem                                           = NULL;
    CBaseMultiSelectSnapinItem *            pBaseMultiSelectSnapinItem      = NULL;

    // Data validation
    ASSERT(lpDataObject);

    // See if we can extract the multi select data object from the composite data object
    sc = CBaseMultiSelectSnapinItem::ScExtractMultiSelectDataObject(Psnapin(), lpDataObject, &pBaseMultiSelectSnapinItem);
    if (sc)
        goto Error;

    // If we actually had a composite data object and we were able to find our multiselect snapin item
    if (pBaseMultiSelectSnapinItem)
    {
        // Call ScCommand for the multiselect object for dispatch
        sc = pBaseMultiSelectSnapinItem->ScCommand(this, nCommandID, lpDataObject);
        if (sc)
            goto Error;
    }
    else
    {
        // Handle the normal case - PItem() does more work than a simple cast to verify that the snapin item belongs to the snapin etc.
        pitem = Pitem(lpDataObject);
        ASSERT(pitem);

        sc = pitem->ScCommand(nCommandID, this);
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScCommand"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// MMC wants to know the kind of result pane we want.
//
SC CComponent::ScGetResultViewType(long cookie, LPOLESTR *ppViewType, long *pViewOptions)
{
    SC sc = S_OK;
    CBaseSnapinItem *pitem = NULL;

    ASSERT(ppViewType);
    ASSERT(pViewOptions);

    pitem = Pitem(NULL, 0, cookie);
    ASSERT(pitem);

    sc = pitem->ScGetResultViewType(ppViewType, pViewOptions);
    if (sc)
        goto Error;

Cleanup:
    return sc;

Error:
    TraceError(_T("CComponent::ScGetResultViewType"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// IResultOwnerData method used to tell a snapin item which rows in
// the result pane it will be asking for soon so they can be cached.
//
SC CComponent::ScCacheHint(INT nStartIndex, INT nEndIndex)
{
    SC sc = S_OK;

    ASSERT(FVirtualResultsPane());
    ASSERT(PitemScopeSelected());

    sc = PitemScopeSelected()->ScCacheHint(nStartIndex, nEndIndex);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScCacheHint"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// IResultOwnerData method used to ask a snapin item sort a virtual list.
//
SC CComponent::ScSortItems(INT nColumn, DWORD dwSortOptions, long lUserParam)
{
    SC sc = S_OK;

    ASSERT(FVirtualResultsPane());
    ASSERT(PitemScopeSelected());

    sc = PitemScopeSelected()->ScSortItems(nColumn, dwSortOptions, lUserParam);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScSortItems"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Are we currently displaying a virtual list in the result pane ?
//
BOOL CComponent::FVirtualResultsPane(void)
{
    // TRUE if an item is currently selected in the scope pane and it says it is virtual.
    return m_pitemScopeSelected && m_pitemScopeSelected->FVirtualResultsPane();
}

// -----------------------------------------------------------------------------
// Determines whether any settings have changed since the last time the file
// was saved.
//
SC CComponent::ScIsDirty(void)
{
    SC              sc = S_OK;
    BOOL    fIsDirty = FALSE;
    INT             i = 0;

    sc = Pitem()->ScIsDirty();
    if (sc == S_FALSE)
        sc = S_OK;
    else if (sc)
        fIsDirty = TRUE;
    else
        goto Error;

Cleanup:
    sc = fIsDirty ? S_OK : S_FALSE;
    return sc;

Error:
    TraceError(_T("CComponent::ScIsDirty"), sc);
    fIsDirty = FALSE;
    goto Cleanup;
}

// -----------------------------------------------------------------------------
HRESULT CComponent::Initialize(LPCONSOLE lpConsole)
{
    DECLARE_SC(sc, _T("CComponent::Initialize"));
    Trace(tagBaseSnapinIComponent, _T("--> %s::IComponent::Initialize(lpConsole=0x%08X)"), StrSnapinClassName(), lpConsole);
    ADMIN_TRY;
    sc = ScInitialize(lpConsole);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIComponent, _T("<-- %s::IComponent::Initialize is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param)
{
    DECLARE_SC(sc, _T("CComponent::Notify"));
    Trace(tagBaseSnapinIComponent, _T("--> %s::IComponent::Notify(lpDataObject=0x%08X, event=%s, arg=0x%08X, param=0x%08X)"), StrSnapinClassName(), lpDataObject, SzGetDebugNameOfMMC_NOTIFY_TYPE(event), arg, param);
    ADMIN_TRY;
    sc=ScNotify(lpDataObject, event, arg, param);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIComponent, _T("<-- %s::IComponent::Notify is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::Destroy(long cookie)
{
    DECLARE_SC(sc, _T("CComponent::Destroy"));
    Trace(tagBaseSnapinIComponent, _T("--> %s::IComponent::Destroy"), StrSnapinClassName());
    ADMIN_TRY;
    sc=ScDestroy();
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIComponent, _T("<-- %s::IComponent::Destroy is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::GetResultViewType(long cookie, LPOLESTR *ppViewType, long *pViewOptions)
{
    DECLARE_SC(sc, _T("CComponent::GetResultViewType"));
    Trace(tagBaseSnapinIComponent, _T("--> %s::IComponent::GetResultViewType(cookie=0x%08X)"), StrSnapinClassName(), cookie);
    ADMIN_TRY;
    sc=ScGetResultViewType(cookie, ppViewType, pViewOptions);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIComponent, _T("<-- %s::IComponent::GetResultViewType is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::QueryDataObject(long cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT *ppDataObject)
{
    DECLARE_SC(sc, _T("CComponent::QueryDataObject"));
    Trace(tagBaseSnapinIComponentQueryDataObject, _T("--> %s::IComponent::QueryDataObject(cookie=0x%08X, type=%s)"), StrSnapinClassName(), cookie, SzGetDebugNameOfDATA_OBJECT_TYPES(type));
    ADMIN_TRY;
    //
    // If we receive E_UNEXPECTED we don't want to call MMCHrFromSc because
    // that will bring up an error message. We don't want an error message
    // in this case because of a known MMC bug (see bug X5:74405).
    // The bug says that we might receive QueryDataObject on items that
    // we were told no longer exists (by MMCN_REMOVE_CHILDREN).
    //
    sc = ScQueryDataObject(cookie, type, ppDataObject);
    if (sc)
        return sc.ToHr();
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIComponentQueryDataObject, _T("<-- %s::IComponent::QueryDataObject is returning hr=%s, *ppDataObject=0x%08X"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()), *ppDataObject);
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::GetDisplayInfo(RESULTDATAITEM *pResultDataItem)
{
    DECLARE_SC(sc, _T("CComponent::GetDisplayInfo"));
    Trace(tagBaseSnapinIComponentGetDisplayInfo, _T("--> %s::IComponent::GetDisplayInfo(cookie=0x%08X)"), StrSnapinClassName(), pResultDataItem->lParam);
    ADMIN_TRY;
    sc=ScGetDisplayInfo(pResultDataItem);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIComponentGetDisplayInfo, _T("<-- %s::IComponent::GetDisplayInfo is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    DECLARE_SC(sc, _T("CComponent::CompareObjects"));
    Trace(tagBaseSnapinIComponent, _T("--> %s::IComponent::CompareObjects(lpDataObjectA=0x%08X, lpDataObjectB=0x%08X)"), StrSnapinClassName(), lpDataObjectA, lpDataObjectB);
    ADMIN_TRY;
    sc=Psnapin()->ScCompareObjects(lpDataObjectA, lpDataObjectB);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIComponent, _T("<-- %s::IComponent::CompareObjects is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}


// -----------------------------------------------------------------------------
HRESULT CComponent::QueryDispatch(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDISPATCH* ppDispatch)
{
    DECLARE_SC(sc, _T("CComponent::QueryDispatch"));
    ADMIN_TRY;
    sc = ScQueryDispatch(cookie, type, ppDispatch);
    ADMIN_CATCH_HR;
    Trace(tagBaseSnapinIComponent, _T("<-- %s::IComponent::QueryDispatch is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::GetResultViewType2(MMC_COOKIE cookie, PRESULT_VIEW_TYPE_INFO pResultViewType)
{
    DECLARE_SC(sc, _T("CComponent::GetResultViewType2"));
    ADMIN_TRY;
    sc = ScGetResultViewType2(cookie, pResultViewType);
    ADMIN_CATCH_HR;
    Trace(tagBaseSnapinIComponent, _T("<-- %s::IComponent::GetResultViewType2 is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::RestoreResultView(MMC_COOKIE cookie, RESULT_VIEW_TYPE_INFO* pResultViewType)
{
    DECLARE_SC(sc, _T("CComponent::RestoreResultView"));
    ADMIN_TRY;
    sc = ScRestoreResultView(cookie, pResultViewType);
    ADMIN_CATCH_HR;
    Trace(tagBaseSnapinIComponent, _T("<-- %s::IComponent::RestoreResultView is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}


// -----------------------------------------------------------------------------
HRESULT CComponent::AddMenuItems(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK ipContextMenuCallback, long *pInsertionAllowed)
{
    DECLARE_SC(sc, _T("CComponent::AddMenuItems"));
    Trace(tagBaseSnapinIExtendContextMenu, _T("--> %s::IExtendContextMenu::AddMenuItems(pDataObject=0x%08X)"), StrSnapinClassName(), pDataObject);
    ADMIN_TRY;
    sc=Psnapin()->ScAddMenuItems(pDataObject, ipContextMenuCallback, pInsertionAllowed);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIExtendContextMenu, _T("<-- %s::IExtendContextMenu::AddMenuItems is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
    DECLARE_SC(sc, _T("CComponent::Command"));
    Trace(tagBaseSnapinIExtendContextMenu, _T("--> %s::IExtendContextMenu::Command(nCommandID=%ld, pDataObject=0x%08X)"), StrSnapinClassName(), nCommandID, pDataObject);
    ADMIN_TRY;
    sc=ScCommand(nCommandID, pDataObject);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIExtendContextMenu, _T("<-- %s::IExtendContextMenu::Command is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, long handle, LPDATAOBJECT lpDataObject)
{
    DECLARE_SC(sc, _T("CComponent::CreatePropertyPages"));
    Trace(tagBaseSnapinIExtendPropertySheet, _T("--> %s::IExtendPropertySheet::CreatePropertyPages(lpDataObject=0x%08X)"), StrSnapinClassName(), lpDataObject);
    ADMIN_TRY;
    sc = ScCreatePropertyPages(lpProvider, handle, lpDataObject);
    if (sc)
        sc=sc.ToHr();
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIExtendPropertySheet, _T("<-- %s::IExtendPropertySheet::CreatePropertyPages is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    DECLARE_SC(sc, _T("CComponent::QueryPagesFor"));
    Trace(tagBaseSnapinIExtendPropertySheet, _T("--> %s::IExtendPropertySheet::QueryPagesFor(lpDataObject=0x%08X)"), StrSnapinClassName(), lpDataObject);
    ADMIN_TRY;
    sc=ScQueryPagesFor(lpDataObject);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIExtendPropertySheet, _T("<-- %s::IExtendPropertySheet::QueryPagesFor is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    DECLARE_SC(sc, _T("CComponent::GetSizeMax"));
    Trace(tagBaseSnapinIPersistStreamInit, _T("--> %s::IPersistStreamInit::GetSizeMax"), StrSnapinClassName());
    ADMIN_TRY;
    ASSERT(pcbSize);
    pcbSize->LowPart = cMaxStreamSizeLow;
    pcbSize->HighPart = cMaxStreamSizeHigh;
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIPersistStreamInit, _T("<-- %s::IPersistStreamInit::GetSizeMax is returning hr=%s, (*pcbSize).LowPart=%d"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()), (*pcbSize).LowPart);
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::IsDirty(void)
{
    DECLARE_SC(sc, _T("CComponent::IsDirty"));
    Trace(tagBaseSnapinIPersistStreamInit, _T("--> %s::IPersistStreamInit::IsDirty"), StrSnapinClassName());
    ADMIN_TRY;
    sc=ScIsDirty();
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIPersistStreamInit, _T("<-- %s::IPersistStreamInit::IsDirty is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::Load(IStream *pstream)
{
    DECLARE_SC(sc, _T("CComponent::Load"));
    Trace(tagBaseSnapinIPersistStreamInit, _T("--> %s::IPersistStreamInit::Load"), StrSnapinClassName());
    ADMIN_TRY;
    sc=ScLoad(pstream);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIPersistStreamInit, _T("<-- %s::IPersistStreamInit::Load is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::Save(IStream *pstream, BOOL fClearDirty)
{
    DECLARE_SC(sc, _T("CComponent::Save"));
    Trace(tagBaseSnapinIPersistStreamInit, _T("--> %s::IPersistStreamInit::Save(fClearDirty=%S)"), StrSnapinClassName(), fClearDirty ? "TRUE" : "FALSE");
    ADMIN_TRY;
    sc=ScSave(pstream, fClearDirty);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIPersistStreamInit, _T("<-- %s::IPersistStreamInit::Save is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::InitNew(void)
{
    DECLARE_SC(sc, _T("CComponent::InitNew"));
    // We don't have anything to do, but we still want to log the call.
    Trace(tagBaseSnapinIPersistStreamInit, _T("--> %s::IPersistStreamInit::InitNew"), StrSnapinClassName());
    Trace(tagBaseSnapinIPersistStreamInit, _T("<-- %s::IPersistStreamInit::InitNew is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::GetClassID(CLSID *pclsid)
{
    DECLARE_SC(sc, _T("CComponent::GetClassID"));
    Trace(tagBaseSnapinIPersistStreamInit, _T("--> %s::IPersistStreamInit::GetClassID"), StrSnapinClassName());
    ADMIN_TRY;
    ASSERT(pclsid);
    *pclsid = *(Psnapin()->PclsidSnapin());
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIPersistStreamInit, _T("<-- %s::IPersistStreamInit::GetClassID is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::CacheHint(int nStartIndex, int nEndIndex)
{
    DECLARE_SC(sc,_T("CComponent::CacheHint"));
    Trace(tagBaseSnapinIResultOwnerData, _T("--> %s::IResultOwnerData::CacheHint(nStartIndex=%d, nEndIndex=%d)"), StrSnapinClassName(), nStartIndex, nEndIndex);
    ADMIN_TRY;
    sc=ScCacheHint(nStartIndex, nEndIndex);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIResultOwnerData, _T("<-- %s::IResultOwnerData::CacheHint is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::SortItems(int nColumn, DWORD dwSortOptions, long lUserParam)
{
    DECLARE_SC(sc,_T("CComponent::SortItems"));
    Trace(tagBaseSnapinIResultOwnerData, _T("--> %s::IResultOwnerData::SortItems"), StrSnapinClassName());
    ADMIN_TRY;
    sc=ScSortItems(nColumn, dwSortOptions, lUserParam);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIResultOwnerData, _T("<-- %s::IResultOwnerData::SortItems is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::FindItem(LPRESULTFINDINFO pFindinfo, int *pnFoundIndex)
{
    DECLARE_SC(sc,_T("CComponent::FindItem"));
    Trace(tagBaseSnapinIResultOwnerData, _T("--> %s::IResultOwnerData::FindItem"), StrSnapinClassName());
    ADMIN_TRY;
    ASSERT(pnFoundIndex);
    sc = ScFindItem(pFindinfo, pnFoundIndex);
    if (! sc)
    // if no error occured -- convert the found item index into the mmc expected return codes
        sc=(*pnFoundIndex != -1) ? S_OK : S_FALSE;
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIResultOwnerData, _T("<-- %s::IResultOwnerData::FindItem is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::Compare(RDCOMPARE * prdc, int * pnResult)
{
    DECLARE_SC(sc,_T("CComponent::Compare"));
    Trace(tagBaseSnapinIResultDataCompare, _T("--> %s::IResultDataCompare::Compare(cookieA=0x%08X, cookieB=0x%08X)"), StrSnapinClassName(), prdc->prdch1->cookie, prdc->prdch2->cookie);
    ADMIN_TRY;
    ASSERT(pnResult);
    ASSERT(prdc);
    ASSERT(prdc->prdch1);
    ASSERT(prdc->prdch2);
    sc=Psnapin()->ScCompare(prdc->prdch1->cookie, prdc->prdch2->cookie, prdc->nColumn, pnResult);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIResultDataCompare, _T("<-- %s::IResultDataCompare::Compare is returning hr=%s, *pnResult=%d"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()), *pnResult);
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
// IResultOwnerData method used to ask a snapin item to do a find
// in a virtual list.
//
SC CComponent::ScFindItem(LPRESULTFINDINFO pFindinfo, INT *pnFoundIndex)
{
    SC sc = S_OK;

    ASSERT(FVirtualResultsPane());
    ASSERT(PitemScopeSelected());

    sc = PitemScopeSelected()->ScFindItem(pFindinfo, pnFoundIndex);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScFindItem"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Handles the MMCN_DBLCLICK notification sent to IComponent::Notify.
//
SC CComponent::ScOnDoubleClick(LPDATAOBJECT lpDataObject)
{
    // $REVIEW (ptousig) What does S_FALSE mean ?
    return S_FALSE;
}

// -----------------------------------------------------------------------------
// Creates a data object of the appropriate type, and returns the
// IDataObject interface on it.
//
SC CComponent::ScQueryDataObject(long cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT * ppDataObject)
{
    // Declarations
    SC                                              sc                      = S_OK;
    CBaseSnapinItem *               pitem           = NULL;

    // Determine if we have a special cookie for multiselect
    if (IS_SPECIAL_COOKIE(cookie) && (MMC_MULTI_SELECT_COOKIE == cookie))
    {
        // Make sure we are queried for a multiselect
        ASSERT(CCT_UNINITIALIZED == type);

        // We need to create a special multiselect data object
        ASSERT(Psnapin());
        sc = Psnapin()->ScCreateMultiSelectionDataObject(ppDataObject, this);
        if (sc)
            goto Error;
    }
    else
    {
        // We are a component, we should only receive result pane cookies.
        ASSERT(type==CCT_RESULT);

        if (FVirtualResultsPane())
        {
            ASSERT(PitemScopeSelected());

            // This function is being asked for a data object for a row in a virtual
            // results pane.  By definition there is no snapin item there.  So we ask
            // the controlling scope item to provide us with a "temporary" data object.
            sc = PitemScopeSelected()->ScVirtualQueryDataObject(cookie, type, ppDataObject);
            if (sc)
                goto Error;
        }
        else
        {
            // If the cookie does not correspond to a known object, return E_UNEXPECTED.
            // This is correct and is also a workaround for a MMC bug. See bug X5:74405.
            if (cookie && (Psnapin()->Pcookielist()->find(cookie) == Psnapin()->Pcookielist()->end() ) )
            {
                sc = E_UNEXPECTED;
                goto Cleanup;
            }

            pitem = Pitem(NULL, 0, cookie);
            ASSERT(pitem);

            sc = pitem->ScQueryDataObject(cookie, type, ppDataObject);
            if (sc)
                goto Error;
        }
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScQueryDataObject"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Handles the MMCN_SHOW notification sent to IComponent::Notify. Initializes the
// default list view's headers.
//
SC CComponent::ScOnShow(LPDATAOBJECT lpDataObject, BOOL fSelect, HSCOPEITEM hscopeitem)
{
    SC sc = S_OK;
    BOOL fIsOwned = TRUE;
    CBaseSnapinItem *pitem = NULL;

    pitem = Pitem(lpDataObject, hscopeitem);
    ASSERT(pitem);

    // Since we are selecting/deselecting a scope item we
    // need to update who the selected scope item is.  Note:
    // we dont do this in MMCN_SELECT.  MMCN_SELECT gets called
    // when a results node is being selected.  We aren't tracking
    // the selected RESULTS node but selected SCOPE node.
    SetItemScopeSelected(fSelect ? pitem : NULL);

    // Use this opportunity to correlate the CSnapinItem and the HSCOPEITEM.
    // $REVIEW (ptousig) Should be done inside Pitem().
    pitem->SetHscopeitem(hscopeitem);

    // Set up the list view.
    sc = pitem->ScOnShow(this, fSelect);
    if (sc)
        goto Error;

    // $REVIEW (ptousig) Couldn't we just call ScOnViewChangeUpdateResultItems either way ?
    if (fSelect)
    {
        // Note: this is not a call to UpdateAllViews
        sc = ScOnViewChangeUpdateResultItems(pitem, fSelect);
        if (sc)
            goto Error;
    }
    else
    {
        // This call doesn't do anything.
        sc = pitem->ScRemoveResultItems(IpResultData());
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScOnShow"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Used to update the description bar
//
SC CComponent::ScOnViewChangeUpdateDescriptionBar(CBaseSnapinItem *pitem)
{
    SC sc = S_OK;

    if (PitemScopeSelected() != pitem)
        goto Cleanup;

    if (pitem->PstrDescriptionBar())
    {
        ASSERT(IpResultData());
        sc = IpResultData()->SetDescBarText((LPTSTR)pitem->PstrDescriptionBar()->data());
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScOnViewChangeUpdateDescriptionBar"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Used to update an item's result-item children.
//
SC CComponent::ScOnViewChangeUpdateResultItems(CBaseSnapinItem *pitem, BOOL fSelect)
{
    SC                              sc = S_OK;
    CViewItemList   viewitemlist;
    CViewItemListBase::iterator viewitemiter;

    if (PitemScopeSelected() != pitem)
        goto Cleanup;

    if (!pitem->FUsesResultList())
        goto Cleanup;

    if (fSelect)
    {
        // Create a result view.
        viewitemlist.Initialize(pitem, pitem->DatPresort(), pitem->DatSort());

        // Update description text
        if (pitem->PstrDescriptionBar())
        {
            sc = IpResultData()->SetDescBarText((LPTSTR)pitem->PstrDescriptionBar()->data());
            if (sc)
                goto Error;
        }

        // remove all result items because are going to re add them
        // all here.
        sc = IpResultData()->DeleteAllRsltItems();
        if (sc)
            goto Error;

        // if we are selecting and updating the result pane then we
        // are inserting all the result items.  We need to make sure that
        // we are in vlb mode and that the number of vlb items is set
        // by initializing the result view.
        sc = pitem->ScInitializeResultView(this);
        if (sc)
            goto Error;


        // Insert all leaf nodes into the list view.
        for (viewitemiter = viewitemlist.begin(); viewitemiter < viewitemlist.end(); viewitemiter++)
        {
            // Only add non-container, ie leaf, nodes.
            if ((*viewitemiter)->FIsContainer() == FALSE)
            {
                sc = (*viewitemiter)->ScInsertResultItem(this);
                if (sc)
                    goto Error;
            }
        }
    }
    else
    {
        // $REVIEW (ptousig) This could be done from inside "pitem->ScRemoveResultItems".
        sc = IpResultData()->DeleteAllRsltItems();
        if (sc)
            goto Error;

        sc = pitem->ScRemoveResultItems(IpResultData());
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScOnViewChangeUpdateResultItems"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Called by the MMC upon a call to IConsole->UpdateAllViews().
//
SC CComponent::ScOnViewChange(LPDATAOBJECT lpDataObject, long data, long hint)
{
    SC                                      sc              = S_OK;
    CBaseSnapinItem *       pitem   = NULL;

    pitem = Pitem(lpDataObject);

    switch (hint)
    {
    case ONVIEWCHANGE_DELETEITEMS:
        // Are we being called to delete all items?
        sc = ScOnViewChangeDeleteItems(pitem);
        break;

    case ONVIEWCHANGE_DELETESINGLEITEM:
        sc = ScOnViewChangeDeleteSingleItem(pitem);
        break;

    case ONVIEWCHANGE_INSERTNEWITEM:
        sc = ScOnViewChangeInsertItem(pitem);
        break;

    case ONVIEWCHANGE_UPDATERESULTITEM:
        sc = ScOnViewChangeUpdateItem(pitem);
        break;

    case ONVIEWCHANGE_REFRESHCHILDREN:
        sc = ScOnRefresh(pitem->Pdataobject(), data);
        break;

    case ONVIEWCHANGE_DELETERESULTITEMS:
        sc = ScOnViewChangeUpdateResultItems(pitem, FALSE);
        break;

    case ONVIEWCHANGE_UPDATEDESCRIPTIONBAR:
        sc = ScOnViewChangeUpdateDescriptionBar(pitem);
        break;

    case ONVIEWCHANGE_INSERTRESULTITEMS:
        sc = ScOnViewChangeUpdateResultItems(pitem, TRUE);
        break;

    default:
        sc = ScOnViewChangeHint(pitem, hint);
        break;
    }

    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScOnViewChange"), sc);
    goto Cleanup;

}


// -----------------------------------------------------------------------------
// Deletes all the items underneath the root. This is typically used to regenerate the tree.
//
SC CComponent::ScOnViewChangeDeleteItems(CBaseSnapinItem *pitem)
{
    SC              sc = S_OK;
    CBaseSnapinItem *pitemRoot = NULL;

    pitemRoot = Pitem();

    // First check that the root item's HSCOPEITEM is non-null.
    // If it is NULL the item was never Expand'ed or Show'ed so OK to ignore.
    if (pitemRoot->Hscopeitem() == 0)
        goto Cleanup;

    // Select the root scope item first.
    ASSERT(pitemRoot->Hscopeitem());
    sc = IpConsole()->SelectScopeItem(pitemRoot->Hscopeitem());
    if (sc)
        goto Error;

    // Delete all items below the root node, not counting the root node itself.
    sc = IpConsoleNameSpace()->DeleteItem(pitemRoot->Hscopeitem(), FALSE);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScOnViewChangeDeleteItems"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Used to delete a single item. If the item is a container, it is deleted from the namespace [NYI]. If it
// is a leaf, it is deleted from the result view.
//
SC CComponent::ScOnViewChangeDeleteSingleItem(CBaseSnapinItem *pitem)
{
    SC                      sc              = S_OK;
    HRESULTITEM itemID      = NULL;

    // Find out the item ID of the data object.
    sc = IpResultData()->FindItemByLParam((LPARAM) pitem, &itemID);
    if (sc)
    {
        // $REVIEW (ptousig) Why are we ignoring errors ?
        sc = S_OK;
        goto Cleanup;
    }

    // Delete it from the result view.
    sc = IpResultData()->DeleteItem(itemID, 0);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScOnViewChangeDeleteSingleItem"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Pass a view change notification (that we don't have a predefined handler for)
// to the snapin item.
//
SC CComponent::ScOnViewChangeHint(CBaseSnapinItem *pitem, long hint)
{
    SC sc = S_OK;

    ASSERT(pitem);

    sc = pitem->ScOnViewChangeHint(hint, this);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScOnViewChangeHint"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Inserts a new item into the namespace/result view. Called when the property sheet for a new item is
// dismissed with OK being pressed.
// The PitemParent() of the node being inserted should already be set.
//
SC CComponent::ScOnViewChangeInsertItem(CBaseSnapinItem *pitem)
{
    SC sc = S_OK;

    // $REVIEW (ptousig) Why is the view inserting the item in the document ?
    //                                       Wouldn't that end up getting executed multiple times ?
    sc = PComponentData()->ScOnDocumentChangeInsertItem(pitem);
    if (sc)
        goto Error;

    if (pitem->FIsContainer() == FALSE)      // leaf items need to be added to every view.
    {
        //
        // If the parent of the new item is the currently selected scope item,
        // then add the new item to the result pane.
        //
        ASSERT(pitem->PitemParent());
        if (PitemScopeSelected() == pitem->PitemParent())
            // $REVIEW (ptousig) Why are we ignoring errors ?
            pitem->ScInsertResultItem(this);
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScOnViewChangeInsertItem"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Used to update an item when properties on it change.
//
SC CComponent::ScOnViewChangeUpdateItem(CBaseSnapinItem *pitem)
{
    SC sc = S_OK;

    // This works as follows. RESULTDATAITEMS are automatically inserted by the MMC for all scope nodes that
    // are in the result pane (ie container nodes.) RESULTDATAITEMS are inserted by the snapin for leaf nodes.
    // So calling ScUpdateResultItem works correctly for all items that are in the result pane, because it first
    // calls IResultData->FindItemByLParam(), and if that succeeded, calls IResultData->UpdateItem().
    sc = pitem->ScUpdateResultItem(IpResultData());
    if (sc == E_FAIL)
        // the item was not updated because it is not in the list anymore
        sc = S_FALSE;
    else if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScOnViewChangeUpdateItem"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Handles the MMCN_REFRESH notification.
//
SC CComponent::ScOnRefresh(LPDATAOBJECT lpDataObject, HSCOPEITEM hscopeitem)
{
    SC sc = S_OK;
    BOOL fIsOwned = FALSE;
    CNodeType *pnodetype = NULL;
    CBaseSnapinItem *pitem = NULL;
    CBaseSnapinItem *pCurrent = NULL;
    BOOL fWasExpanded = FALSE;

    // Find out which item was asked to refresh
    pitem = Pitem(lpDataObject, hscopeitem);

    // Is this the notification for the owner of the node or for
    // the extension of a node ?
    sc = Psnapin()->ScIsOwnedDataObject(lpDataObject, &fIsOwned, &pnodetype);
    if (sc)
        goto Error;

    if (fIsOwned)
    {
        // If we have never been expanded before, refresh would be pointless.
        sc = PComponentData()->ScWasExpandedOnce(pitem, &fWasExpanded);
        if (sc)
            goto Error;

        if (fWasExpanded == FALSE)
            goto Cleanup;

        // Remove all visible result items before we delete the pitems behind them
        sc = IpConsole()->UpdateAllViews(lpDataObject, 0, ONVIEWCHANGE_DELETERESULTITEMS);
        if (sc)
            goto Error;

        // Delete children pitems
        sc = pitem->ScDeleteSubTree(FALSE);
        if (sc)
            goto Error;

        // Ask the node that was refreshed to update its data
        sc = pitem->ScOnRefresh();
        if (sc)
            goto Error;
        // Most of our snapins reload data on ScOnPropertyChange
        sc = pitem->ScOnPropertyChange();
        if (sc)
            goto Error;

        // Recreate children with fresh data
        sc = PComponentData()->ScOnExpand(pitem->Pdataobject(), TRUE, pitem->Hscopeitem());
        if (sc)
            goto Error;

        // Add result items back to all instances of the refreshed node that are selected
        sc = IpConsole()->UpdateAllViews(lpDataObject, 0, ONVIEWCHANGE_INSERTRESULTITEMS);
        if (sc)
            goto Error;
    }
    else
    {

        // Delete children
        sc = pitem->ScDeleteSubTree(FALSE);
        if (sc)
            goto Error;

        // Update refreshed items data
        sc = pitem->ScOnRefresh();
        if (sc)
            goto Error;
        // Most of our snapins reload data on ScOnPropertyChange
        sc = pitem->ScOnPropertyChange();
        if (sc)
            goto Error;

        // Recreate children with fresh data
        sc = PComponentData()->ScOnExpand(pitem->Pdataobject(), TRUE, pitem->Hscopeitem());
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;

Error:
    TraceError(_T("CComponent::ScOnRefresh"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// $REVIEW (ptousig) I don't know when this is called.
//
SC CComponent::ScOnListPad(LPDATAOBJECT lpDataObject, BOOL fAttach)
{
    SC sc = S_OK;
    CBaseSnapinItem *pitem = NULL;

    pitem = Pitem(lpDataObject);
    ASSERT(pitem);

    sc = pitem->ScOnAddImages(IpImageList());
    if (sc)
        goto Error;

    sc = ScOnShow(lpDataObject, fAttach, pitem->Hscopeitem());
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScOnExpand"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// The user has asked to delete this node.
//
SC CComponent::ScOnDelete(LPDATAOBJECT lpDataObject)
{
    // Declarations
    SC                 sc = S_OK;
    CBaseSnapinItem *  pitem = NULL;
    BOOL               fDeleted = FALSE;
    BOOL               fPagesUp = FALSE;
    tstring            strMsg;
    CBaseMultiSelectSnapinItem * pBaseMultiSelectSnapinItem      = NULL;

    // Data validation
    ASSERT(lpDataObject);

    // Determine if this is a multiselect data object
    sc = CBaseMultiSelectSnapinItem::ScGetMultiSelectDataObject(lpDataObject, &pBaseMultiSelectSnapinItem);
    if (sc)
        goto Error;

    // If we received a multiselect snapin item
    if (pBaseMultiSelectSnapinItem)
    {
        // Call ScOnDelete for the multiselect object
        sc = pBaseMultiSelectSnapinItem->ScOnDelete(this, lpDataObject);
        if (sc)
            goto Error;
    }
    else
    {
        // Handle the normal case - PItem() does more work than a simple cast to verify that the snapin item belongs to the snapin etc.
        pitem = Pitem(lpDataObject);
        ASSERT(pitem);

        // The Component should only receive notifications for result pane items
        ASSERT(pitem->FIsContainer() == FALSE);

        // Check if property pages are open for the object
        // $REVIEW (dominicp) What if another Administrator has property pages open anyways? Not much point in doing this.
        sc = pitem->ScIsPropertySheetOpen(&fPagesUp, dynamic_cast<IComponent *>(this));
        if (sc)
            goto Error;
        if (fPagesUp)
        {
            ASSERT(FALSE && "Add below resource string");
            //strMsg.LoadString(_Module.GetResourceInstance(), idsPropsUpNoDelete);
            strMsg += (*pitem->PstrDisplayName());
            MMCErrorBox(strMsg.data());
            goto Cleanup;
        }

        // Ask the item to delete the underlying object.
        sc = pitem->ScOnDelete(&fDeleted);
        if (sc)
            goto Error;
        if (fDeleted == FALSE)
            // The item did not want to be deleted.
            goto Cleanup;

        // Leaf items need to be deleted from the views.
        sc = IpConsole()->UpdateAllViews(lpDataObject, 0, ONVIEWCHANGE_DELETESINGLEITEM);
        if (sc)
            goto Error;

        // At this point, the item exists only in the tree, if at all.
        // Remove it from the tree.
        pitem->Unlink();
        // Get rid of it for good from the tree of items.
        pitem->Pdataobject()->Release();
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScOnDelete"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// The user wants context-sensitive help on the given node.
//
SC CComponent::ScOnContextHelp(LPDATAOBJECT lpDataObject)
{
    SC sc = S_OK;
    tstring strHelpTopic;
    CComQIPtr<IDisplayHelp, &IID_IDisplayHelp> ipDisplayHelp;
    LPOLESTR lpolestr = NULL;
    CBaseSnapinItem *pitem = NULL;
    USES_CONVERSION;

    pitem = Pitem(lpDataObject);
    ASSERT(pitem);

    // Get the name of the compiled help file.
    sc = Psnapin()->ScGetHelpTopic(strHelpTopic);
    if (sc)
        goto Error;

    // Ask the item if it wants to handle this.
    sc = pitem->ScOnContextHelp(strHelpTopic);
    if (sc == S_FALSE)
    {
        // The item refused to handle the request. Default behavior
        // is to append the name of the TOC
        strHelpTopic += szHelpFileTOC;
        sc = S_OK;
    }
    if (sc)
        goto Error;

    // Get an interface pointer to IDisplayHelp
    ipDisplayHelp = IpConsole();
    ASSERT(ipDisplayHelp);

    // Allocate an LPOLESTR
    lpolestr = T2OLE((LPTSTR)strHelpTopic.data());

    // Call ShowTopic to bring up MMC help system.
    // MMC will release the LPOLESTR.
    // $REVIEW (ptousig) If MMC fails we don't know if it released the string or not.
    //                                       For now, I assume that they always do because I prefer to leak
    //                                       memory then to cause a GPF.
    sc = ipDisplayHelp->ShowTopic(lpolestr);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScOnContextHelp"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Toolbar button clicked.
//
SC CComponent::ScOnButtonClick(LPDATAOBJECT lpDataObject, MMC_CONSOLE_VERB mcvVerb)
{
    return S_OK;
}

// -----------------------------------------------------------------------------
// Adds the result view images to the imagelist.
//
SC CComponent::ScOnAddImages(LPDATAOBJECT lpDataObject, IImageList *ipImageList, HSCOPEITEM hscopeitem)
{
    SC sc = S_OK;
    CBaseSnapinItem *pitem = NULL;

    pitem = Pitem(lpDataObject, hscopeitem);
    ASSERT(pitem);

    sc = pitem->ScOnAddImages(ipImageList);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScOnAddImages"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Called when the window of this view is activated. We don't care.
//
SC CComponent::ScOnActivate(LPDATAOBJECT lpDataObject, BOOL fActivate)
{
    return S_OK;
}

// -----------------------------------------------------------------------------
// Adds property pages for the given data object, taking into account the context and also
// whether the data object is for a new object that is being created.
//
SC CComponent::ScCreatePropertyPages(LPPROPERTYSHEETCALLBACK ipPropertySheetCallback, long handle, LPDATAOBJECT lpDataObject)
{
    // Declarations
    SC                                                              sc                                                      = S_OK;
    CBaseSnapinItem *                               pitem                                           = NULL;
    CBaseMultiSelectSnapinItem *    pBaseMultiSelectSnapinItem      = NULL;

    // Data validation
    ASSERT(lpDataObject);
    ASSERT(ipPropertySheetCallback);

    // Determine if this is a multiselect data object
    sc = CBaseMultiSelectSnapinItem::ScGetMultiSelectDataObject(lpDataObject, &pBaseMultiSelectSnapinItem);
    if (sc)
        goto Error;

    // If we received a multiselect snapin item
    if (pBaseMultiSelectSnapinItem)
    {
        // Call ScCreatePropertyPages for the multiselect object
        sc = pBaseMultiSelectSnapinItem->ScCreatePropertyPages(this, ipPropertySheetCallback, handle, lpDataObject);
        if (sc)
            goto Error;
    }
    else
    {
        // Handle the normal case - PItem() does more work than a simple cast to verify that the snapin item belongs to the snapin etc.
        pitem = Pitem(lpDataObject);    // get the correct CSnapinItem object.
        ASSERT(pitem);

        ASSERT(pitem->FIsSnapinManager() == FALSE);

        // Simple version
        sc = pitem->ScCreatePropertyPages(ipPropertySheetCallback);
        if (sc)
            goto Error;

        // Complete version - for snapins that need all information (like Recipients)
        sc = pitem->ScCreatePropertyPages(ipPropertySheetCallback, handle);
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScCreatePropertyPages"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Saves per-view information. We don't have any.
//
SC CComponent::ScSave(IStream *pstream, BOOL fClearDirty)
{
    return S_OK;
}


// -----------------------------------------------------------------------------
// Given a dataobject, determines whether or not pages exist.
// Actually, need to return S_OK here in both cases. If no pages exist
// it is CreatePropertyPages that should return S_FALSE. Sad but true.
//
SC CComponent::ScQueryPagesFor(LPDATAOBJECT lpDataObject)
{
    // Declarations
    SC                                                              sc                                                      = S_OK;
    CBaseSnapinItem *                               pitem                                           = NULL;
    CBaseMultiSelectSnapinItem *    pBaseMultiSelectSnapinItem      = NULL;

    // Data validation
    ASSERT(lpDataObject);

    // Determine if this is a multiselect data object
    sc = CBaseMultiSelectSnapinItem::ScGetMultiSelectDataObject(lpDataObject, &pBaseMultiSelectSnapinItem);
    if (sc)
        goto Error;

    // If we received a multiselect snapin item
    if (pBaseMultiSelectSnapinItem)
    {
        // Call ScQueryPagesFor for the multiselect object
        sc = pBaseMultiSelectSnapinItem->ScQueryPagesFor(this, lpDataObject);
        if (sc)
            goto Error;
    }
    else
    {
        // Handle the normal case - PItem() does more work than a simple cast to verify that the snapin item belongs to the snapin etc.
        pitem = Pitem(lpDataObject);
        ASSERT(pitem);

        sc = pitem->ScQueryPagesFor();
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScQueryPagesFor"), sc);
    goto Cleanup;
}

//+-------------------------------------------------------------------
//
//  Member:      CComponent::ScOnInitOCX
//
//  Synopsis:    MMCN_INITOCX handler
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CComponent::ScOnInitOCX (LPDATAOBJECT lpDataObject, LPUNKNOWN lpOCXUnknown)
{
    DECLARE_SC(sc, _T("CComponent::ScOnInitOCX"));

    CBaseSnapinItem *                               pitem                                           = NULL;
    CBaseMultiSelectSnapinItem *    pBaseMultiSelectSnapinItem      = NULL;

    sc = ScCheckPointers(Psnapin());
    if(sc)
        return E_NOINTERFACE;

    // If snapin has IComponent2 then it created OCX and returned the IUnknown for
    // the OCX using IComponent2::GetResultViewType2. Since it created, it also
    // should initialize the OCX in which case MMC should not send MMCN_INITOCX.
    // The below statement is just in case if MMC sends the notification.
    if(Psnapin()->FSupportsIComponent2())
        return sc;

    // Data validation
    ASSERT(lpDataObject);

    // Determine if this is a multiselect data object
    sc = CBaseMultiSelectSnapinItem::ScGetMultiSelectDataObject(lpDataObject, &pBaseMultiSelectSnapinItem);
    if (sc)
        return sc;

    // If we received a multiselect snapin item
    if (pBaseMultiSelectSnapinItem)
    {
        return (sc = E_UNEXPECTED);
    }
    else
    {
        // Handle the normal case - PItem() does more work than a simple cast to verify that the snapin item belongs to the snapin etc.
        pitem = Pitem(lpDataObject);
        ASSERT(pitem);

        sc = pitem->ScInitOCX(lpOCXUnknown, IpConsole());
        if (sc)
            return sc;
    }

    return (sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\lib\basesnap.cxx ===
/*
 *      basesnap.cxx
 *
 *
 *      Copyright (c) 1998-1999 Microsoft Corporation
 *
 *      PURPOSE:        Defines CBaseSnapin.
 *
 *
 *      OWNER:          ptousig
 */

#include "headers.hxx"

#include "basesnap.rgs"

// Some substitution strings used to create a registry script on the fly.
#define szDLLName               L"DLLName"
#define szModule                L"Module"
#define szCLSID_Snapin          L"CLSID_Snapin"
#define szCLSID_About           L"CLSID_About"
#define szClassName             L"ClassName"
#define szSnapinName            L"SnapinName"
#define szCLSID_NodeType        L"CLSID_NodeType"

// -----------------------------------------------------------------------------
CBaseSnapin::CBaseSnapin(void)
{
}

// -----------------------------------------------------------------------------
CBaseSnapin::~CBaseSnapin(void)
{
    // Release all of our root items.
    while (m_ilRootItems.empty() == false)
    {
        static_cast<LPDATAOBJECT>(m_ilRootItems.back())->Release();
        m_ilRootItems.pop_back();
    }
}

// -----------------------------------------------------------------------------
// The simple version of Pitem() simply calls the full version.
//
CBaseSnapinItem *CBaseSnapin::Pitem(LPDATAOBJECT lpDataObject, HSCOPEITEM hscopeitem, long cookie)
{
    return Pitem(NULL, NULL, lpDataObject, hscopeitem, cookie);
}


// -----------------------------------------------------------------------------
// The full version of Pitem() attempts to find an existing CBaseSnapinItem
// that matches the given parameters. If it can't find any, it will create
// one.
//
// Note: In order to create a new item, one of the two first parameters must
//               be provided.
//
CBaseSnapinItem *CBaseSnapin::Pitem(
                                   CComponentData *        pComponentData,
                                   CComponent *            pComponent,
                                   LPDATAOBJECT            lpDataObject,
                                   HSCOPEITEM                      hscopeitem,
                                   long                            cookie)
{
    SC sc;
    CBaseSnapinItem *pitem = NULL;
    ItemList::iterator iter;

    // For debugging purposes, I don't want to modify the 'hscopeitem' parameter,
    // so I make a copy of it.
    HSCOPEITEM hscopeitem2 = hscopeitem;

    if (cookie)
    {
        //
        // We can simply cast the cookie into a CBaseSnapinItem *.
        //
        pitem = reinterpret_cast<CBaseSnapinItem *>(cookie);
        ASSERT(dynamic_cast<CBaseSnapinItem *>(pitem));
        goto Cleanup;
    }

    if (hscopeitem2 == 0 && lpDataObject == NULL)
    {
        //
        // We are being asked for the stand-alone root.
        //
        ASSERT(pComponentData);

        pitem = pComponentData->PitemStandaloneRoot();
        if (pitem)
            goto Cleanup;
    }

    if (lpDataObject)
    {
        CLSID clsid;

        //
        // Are we the snapin who created this item ?
        //
        sc = CBaseDataObject::ScGetClassID(lpDataObject, &clsid);
        if (sc)
            goto Error;

        if (::IsEqualCLSID(*PclsidSnapin(), clsid))
        {
            //
            // We created this item, we can simply cast the pointer
            // to a CBaseSnapinItem.
            //
            pitem = dynamic_cast<CBaseSnapinItem *>(lpDataObject);
            ASSERT(pitem);
            goto Cleanup;
        }
    }

    if (lpDataObject && hscopeitem2 == 0)
    {
        //
        // We got an IDataObject *, but we were not given a HSCOPEITEM :-(
        // We'll get it from the CF_EXCHANGE_ADMIN_HSCOPEITEM clipboard format.
        //
        sc = CBaseDataObject::ScGetAdminHscopeitem(lpDataObject, &hscopeitem2);
        if (sc == DV_E_FORMATETC)
        {
            //
            // We don't own this item, we were not given a HSCOPEITEM and it
            // doesn't support CF_EXCHANGE_ADMIN_HSCOPEITEM.
            //
            // $REVIEW (ptousig) Does this ever happen ?
            //
            ASSERT("Does this ever happen ?" && FALSE);
            sc = S_OK;
        }
        else if (sc)
            goto Error;
    }

    // If the user adds the snapin twice in the same console, we will
    // be asked for two root items. If we are being asked for the same root
    // twice, then the "if (hscopeitem2 == 0 && lpDataObject == NULL)" above
    // will have caught it. If we get this far, it means we are being asked
    // for another root item. So we want to search through our existing
    // list of roots only if we have a HSCOPEITEM.
    if (hscopeitem2)
    {
        //
        // We are going to search through our list of existing root items
        // to find one with this HSCOPEITEM.
        // We can't really use a STL map here because the HSCOPEITEM of the items
        // will change after the root is added to the list. Besides, we don't expect
        // more than a handful of roots anyway.
        //
        for (iter = m_ilRootItems.begin(); iter != m_ilRootItems.end(); iter++)
        {
            if ((*iter)->Hscopeitem() == hscopeitem2)
            {
                pitem = *iter;
                goto Cleanup;   // We found it, stop looking
            }
        }
    }

    //
    // If we reach this point it's because we couldn't find this node.
    // So we create a new one and append it to the end of the list.
    //
    sc = ScCreateRootItem(lpDataObject, hscopeitem2, &pitem);
    if (sc)
        goto Error;

    ASSERT(pitem);

    //
    // Initialize the new root
    //
    if (pComponentData)
        pitem->SetComponentData(pComponentData);

    sc = pitem->ScInit(this, NULL, 0, TRUE);
    if (sc)
        goto Error;

    // Add this new item to our list of roots.
    static_cast<LPDATAOBJECT>(pitem)->AddRef();
    m_ilRootItems.push_back(pitem);

    // If this is a standalone root, better tell the component data about it.
    if (hscopeitem2 == 0 && lpDataObject == NULL)
    {
        ASSERT(pComponentData);
        pComponentData->SetPitemStandaloneRoot(pitem);
    }

    if (lpDataObject)
    {
        BOOL fIsOwned = FALSE;
        CNodeType *pnodetype = NULL;

        // $REVIEW (ptousig) There's a better way of doing this.
        // We know we don't own that node, but ScInitializeNamespaceExtension expects
        // a CNodeType so we have to call this to get one.
        sc = ScIsOwnedDataObject(lpDataObject, &fIsOwned, &pnodetype);
        if (sc)
            goto Error;

        // Initialize the root item's code from the dataobject of the parent item.
        pitem->SetIsGhostRoot(TRUE);
        sc = pitem->ScInitializeNamespaceExtension(lpDataObject, hscopeitem2, pnodetype);
        if (sc)
            goto Error;
    }

Cleanup:
    // Make sure this item knows its HSCOPEITEM
    if (hscopeitem2)
        pitem->SetHscopeitem(hscopeitem2);

    ASSERT(pitem);
    return pitem;
Error:
    TraceError(_T("CBaseSnapin::Pitem"), sc);
    MMCErrorBox(sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Returns whether a dataobject is "owned" by this snapin. It does that
// by looking at the list of nodetypes this snapin says it can create, if
// this node is one of these, we assume we own it.
// As a side-effect, this function also returns the nodetype of the node.
//
// $REVIEW (ptousig) This is not an accurate test, we need to use the CCF_SNAPIN_CLASSID.
//
SC CBaseSnapin::ScIsOwnedDataObject(LPDATAOBJECT pdataobject, BOOL *pfIsOwned, CNodeType **ppnodetype)
{
    SC                      sc;
    BOOL            fIsOwned        = FALSE;
    CNodeType * pnodetype   = NULL;
    CLSID           clsid;
    INT                     isnr            = 0;

    ASSERT(pdataobject);
    ASSERT(pfIsOwned);
    ASSERT(ppnodetype);

    // Get the nodetype, in guid format, of the data object.
    sc = CBaseDataObject::ScGetNodeType(pdataobject, &clsid);
    if (sc)
        goto Error;

    for (isnr = 0; isnr < Csnr(); isnr ++)
    {
        if (IsEqualCLSID(*(Psnr(isnr)->pnodetype->PclsidNodeType()), clsid))
        {
            // We found the CLSID, keep track of its nodetype.
            pnodetype = Psnr(isnr)->pnodetype;
            SNRTypes snrtypes = Psnr(isnr)->snrtypes;

            // Do we enumerate nodes of this type? If so, we must be the owner.
            if ((snrtypes & snrEnumSP) || (snrtypes & snrEnumRP) || (snrtypes & snrEnumSM))
                fIsOwned = TRUE;
            break;                                                  // exit the loop.
        }
    }

Cleanup:
    *pfIsOwned      = fIsOwned;
    *ppnodetype     = pnodetype;
    return sc;
Error:
    TraceError(_T("CBaseSnapin::ScIsOwnedDataObject"), sc);
    goto Cleanup;
}

#ifdef _DEBUG
// -----------------------------------------------------------------------------
// Debug menu options
//
SnapinMenuItem CBaseSnapin::s_rgmenuitemBase[] =
{
    {IDS_Test, IDS_Test, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK, NULL, 0, dwMenuNeverGray,        dwMenuNeverChecked},
#if 0
    {idsBarfTraces,                 idsBarfTracesStatusText,                        idmBarfTraces,                  CCM_INSERTIONPOINTID_PRIMARY_TASK,      NULL,   dwMenuAlwaysEnable,     dwMenuNeverGray,        dwMenuNeverChecked},
    {idsBarfClearDbgScreen, idsBarfClearDbgScreenStatusText,        idmBarfClearDbgScreen,  CCM_INSERTIONPOINTID_PRIMARY_TASK,      NULL,   dwMenuAlwaysEnable,     dwMenuNeverGray,        dwMenuNeverChecked},
    {idsBarfSCDescription,  idsBarfSCDescriptionStatusText,         idmBarfSCDescription,   CCM_INSERTIONPOINTID_PRIMARY_TASK,      NULL,   dwMenuAlwaysEnable,     dwMenuNeverGray,        dwMenuNeverChecked},
    {NULL,                                  idsBarfSeparatorStatusText,                     idmBarfSeparator1,              CCM_INSERTIONPOINTID_PRIMARY_TASK,      NULL,   MF_SEPARATOR,           dwMenuNeverGray,        dwMenuNeverChecked},
    {idsBarfSettings,               idsBarfSettingsStatusText,                      idmBarfSettings,                CCM_INSERTIONPOINTID_PRIMARY_TASK,      NULL,   dwMenuAlwaysEnable,     dwMenuNeverGray,        dwMenuNeverChecked},
    {idsBarfAll,                    idsBarfAllStatusText,                           idmBarfAll,                             CCM_INSERTIONPOINTID_PRIMARY_TASK,      NULL,   dwMenuAlwaysEnable,     dwMenuNeverGray,        dwMenuNeverChecked},
    {idsBarfMemoryChkpoint, idsBarfMemoryChkpointStatusText,        idmBarfMemoryChkpoint,  CCM_INSERTIONPOINTID_PRIMARY_TASK,      NULL,   dwMenuAlwaysEnable,     dwMenuNeverGray,        dwMenuNeverChecked},
    {idsBarfMemoryDiff,             idsBarfMemoryDiffStatusText,            idmBarfMemoryDiff,              CCM_INSERTIONPOINTID_PRIMARY_TASK,      NULL,   dwMenuAlwaysEnable,     dwMenuNeverGray,        dwMenuNeverChecked},
    {idsBarfValidateMemory, idsBarfValidateMemoryStatusText,        idmBarfValidateMemory,  CCM_INSERTIONPOINTID_PRIMARY_TASK,      NULL,   dwMenuAlwaysEnable,     dwMenuNeverGray,        dwMenuNeverChecked},
    {idsBarfTotalMemAllocd, idsBarfTotalMemAllocdStatusText,        idmBarfTotalMemAllocd,  CCM_INSERTIONPOINTID_PRIMARY_TASK,      NULL,   dwMenuAlwaysEnable,     dwMenuNeverGray,        dwMenuNeverChecked},
    {NULL,                                  idsBarfSeparatorStatusText,                     idmBarfSeparator3,              CCM_INSERTIONPOINTID_PRIMARY_TASK,      NULL,   MF_SEPARATOR,           dwMenuNeverGray,        dwMenuNeverChecked},
    {idsBarfDebugBreak,             idsBarfDebugBreakStatusText,            idmBarfDebugBreak,              CCM_INSERTIONPOINTID_PRIMARY_TASK,      NULL,   dwMenuAlwaysEnable,     dwMenuNeverGray,        dwMenuNeverChecked},
#endif
};

INT CBaseSnapin::s_cMenuItemBase = CMENUITEM(s_rgmenuitemBase);

// -----------------------------------------------------------------------------
SnapinMenuItem *CBaseSnapin::PmenuitemBase(void)
{
    return s_rgmenuitemBase;
}

// -----------------------------------------------------------------------------
INT CBaseSnapin::CMenuItemBase(void)
{
    return s_cMenuItemBase;
}
#endif // _DEBUG

// -----------------------------------------------------------------------------
// This table allows us to map a MMC verb to a specific bit in a dword.
//
VerbMap CBaseSnapin::s_rgverbmap[] =
{
    { vmOpen,               MMC_VERB_OPEN},
    { vmCopy,               MMC_VERB_COPY},
    { vmPaste,              MMC_VERB_PASTE},
    { vmDelete,             MMC_VERB_DELETE},
    { vmProperties, MMC_VERB_PROPERTIES},
    { vmRename,             MMC_VERB_RENAME},
    { vmRefresh,    MMC_VERB_REFRESH},
    { vmPrint,              MMC_VERB_PRINT},
    { vmCut,                MMC_VERB_CUT},
};

// -----------------------------------------------------------------------------
// Accesses a given entry in the VerbMap table.
//
VerbMap *CBaseSnapin::Pverbmap(INT i)
{
    ASSERT(i>=0 && i<Cverbmap());
    return &(s_rgverbmap[i]);
}

// -----------------------------------------------------------------------------
// Returns the number of entries in the VerbMap table.
//
INT CBaseSnapin::Cverbmap(void)
{
    return(sizeof(s_rgverbmap) / sizeof(VerbMap));
}

// -----------------------------------------------------------------------------
// Has the icon information been initialized ?
BOOL CBaseSnapin::s_fBaseSnapinInitialized = FALSE;

// -----------------------------------------------------------------------------
// The bitmaps containing all the icons
WTL::CBitmap CBaseSnapin::s_bmpImage16;
WTL::CBitmap CBaseSnapin::s_bmpImage32;

// -----------------------------------------------------------------------------
// The Registrar
//
CRegistrar CBaseSnapin::s_registrar;

// -----------------------------------------------------------------------------
// Initializes the global bitmaps (once) as well as the per-snapin bitmaps.
//
SC CBaseSnapin::ScInitBitmaps(void)
{
    DECLARE_SC(sc, _T("CBaseSnapin::ScInitBitmaps"));

    // Once for the whole app...
    if (s_fBaseSnapinInitialized == FALSE)
    {
        sc = BmpImage16().LoadBitmap(IDB_NODES16) ? S_OK : E_FAIL;
        if (sc)
            return sc;

        sc = BmpImage32().LoadBitmap(IDB_NODES32) ? S_OK : E_FAIL;
        if (sc)
            return sc;

        s_fBaseSnapinInitialized = TRUE;
    }

	if (BitmapSmall().IsNull())
	{
		sc = BitmapSmall().LoadBitmap(IDB_NODES16) ? S_OK : E_FAIL;
		if (sc)
			return sc;
	}

    if (BitmapLarge().IsNull())
	{
	    sc = BitmapLarge().LoadBitmap(IDB_NODES32) ? S_OK : E_FAIL;
		if (sc)
			return sc;
	}

    if (BitmapStaticSmall().IsNull())
	{
		sc = BitmapStaticSmall().LoadBitmap(IDB_FOLDER16) ? S_OK : E_FAIL;
		if (sc)
			return sc;
	}

    if (BitmapStaticSmallOpen().IsNull())
	{
		sc = BitmapStaticSmallOpen().LoadBitmap(IDB_FOLDER16OP) ? S_OK : E_FAIL;
		if (sc)
			return sc;
	}

    if (BitmapStaticLarge().IsNull())
	{
		sc = BitmapStaticLarge().LoadBitmap(IDB_FOLDER32) ? S_OK : E_FAIL;
		if (sc)
			return sc;
	}

    return sc;
}


inline HBITMAP CopyBitmap (HBITMAP hbm)
{
	return ((HBITMAP) CopyImage ((HANDLE) hbm, IMAGE_BITMAP, 0, 0, 0));
}


// -----------------------------------------------------------------------------
// MMC wants icons to persist in the .msc file.
//
SC CBaseSnapin::ScGetStaticFolderImage(HBITMAP *phSmallImage, HBITMAP *phSmallImageOpen, HBITMAP *phLargeImage, COLORREF *pcMask)
{
    ASSERT(phSmallImage && phSmallImageOpen && phLargeImage && pcMask);

    *phSmallImage     = CopyBitmap (BitmapStaticSmall());
    *phSmallImageOpen = CopyBitmap (BitmapStaticSmallOpen());
    *phLargeImage     = CopyBitmap (BitmapStaticLarge());
    *pcMask           = RGB (255, 0, 255);
    return S_OK;
}

// -----------------------------------------------------------------------------
// Compares two fields for sorting by MMC. This applies to regular result items, i.e. not to virtual
// list snapin items. Our snapins can override the compare and impact the sort. We use a smart compare
// to guess if the field is numeric. If so, we perform a numeric compare.
// Otherwise we use case insensitive string compare.
//
// On input, *pnResult contains the column number to compare.
// On output, *pnResult contains the result of our comparison:
//              -1 means A is smaller than B
//              0 means A is equal to B
//              1 means A is greater than B
//
SC CBaseSnapin::ScCompare(MMC_COOKIE cookieA, MMC_COOKIE cookieB, INT nColumn, INT * pnResult)
{
    // Declarations
    SC                                      sc;                     // execution code
    CBaseSnapinItem *       pitemA  = NULL;                         // snapin item A
    CBaseSnapinItem *       pitemB  = NULL;                         // snapin item B
    tstring                 strBufferA;                             // field A
    tstring                 strBufferB;                             // field B
    LONG                    lValueA = 0;                            // numeric value for field A
    LONG                    lValueB = 0;                            // numeric value for field B

    // Validate data
    ASSERT(pnResult);

    // Check that these cookies are not special cookies
    ASSERT(IS_SPECIAL_COOKIE(cookieA) == FALSE);
    ASSERT(IS_SPECIAL_COOKIE(cookieB) == FALSE);

    // Cast the cookies into snapin items
    pitemA = reinterpret_cast<CBaseSnapinItem *>(cookieA);
    pitemB = reinterpret_cast<CBaseSnapinItem *>(cookieB);

    // Get the fields from the snapin items
    sc = pitemA->ScGetField(pitemA->PcolinfoexDisplay(nColumn)->Dat(), strBufferA);
    if (sc)
        goto Error;
    sc = pitemB->ScGetField(pitemB->PcolinfoexDisplay(nColumn)->Dat(), strBufferB);
    if (sc)
        goto Error;

    ASSERT(FALSE && "Use Dat and compare data type properly");

    // Use the default string compare (case-insensitive)
    *pnResult = _tcsicmp(strBufferA.data(), strBufferB.data());
    if (*pnResult < 0)
        *pnResult = -1;         // string A < string B
    else if (*pnResult > 0)
        *pnResult = 1;
    else
        *pnResult = 0;

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapin::ScCompare()"), sc);
    goto Cleanup;
}

/* CBaseMultiSelectSnapinItem::ScCreateMultiSelectionDataObject
 *
 * PURPOSE:                     Creates a multiselect data object - we store a list of selected object in this special object.
 *
 * PARAMETERS:
 *                                      LPDATAOBJECT *                  ppDataObject                    Pointer to a pointer to the multiselect snapin item to create.
 *                                      CComponent *                    pComponent                              Pointer to the component object.
 *
 * RETURNS:
 *                                      SC                                                                                              Execution code
 */
SC
CBaseSnapin::ScCreateMultiSelectionDataObject(LPDATAOBJECT * ppDataObject, CComponent * pComponent)
{
    // Declarations
    SC                                                                                      sc                                                      ;               // execution code
    HRESULT                                                                         hr                                                      = S_FALSE;              // local execution code
    RESULTDATAITEM                                                          rdi;                                                                            // a selected item
    BOOL                                                                            fFoundASelection                        = FALSE;                // did we find at least one selected item
    CBaseMultiSelectSnapinItem *                            pBaseMultiSelectSnapinItem      = NULL;                 // multiselect dataobject
    // are we processing the first object of the selected object set
    // Data validation
    ASSERT(ppDataObject);
    ASSERT(*ppDataObject == NULL);
    ASSERT(pComponent);

    // Allocate a typed multiselection data object
    sc = ScAllocateMultiSelectionDataObject(&pBaseMultiSelectSnapinItem);
    if (sc)
        goto Error;
    ASSERT(pBaseMultiSelectSnapinItem);

    // Assign the snapin - important for some clipboard formats
    pBaseMultiSelectSnapinItem->SetSnapin(this);

    // Identify the selected items
    ::ZeroMemory(&rdi,      sizeof(rdi));
    rdi.nIndex                      = -1;                                                                                                                           // first item requested
    rdi.nState                      = LVIS_SELECTED;                                                                                                        // only the selected items requested
    rdi.mask                        = RDI_STATE | RDI_INDEX | RDI_PARAM;                                                            // state, cookie and index

    // Get the result data interface
    ASSERT(pComponent->IpResultData());                                                                                                             // verify we have an IResultData interface
    while (S_OK == (hr = pComponent->IpResultData()->GetNextItem(&rdi)))
    {
        // Local declarations
        CBaseSnapinItem *       pitem = NULL;

        // Make sure we got a cookie for the item
        ASSERT(rdi.lParam);
        pitem = reinterpret_cast<CBaseSnapinItem *>(rdi.lParam);
        ASSERT(pitem);

        // Add the item to the list managed by our multiselect data object
        ASSERT(pBaseMultiSelectSnapinItem->PivSelectedItems());
        pBaseMultiSelectSnapinItem->PivSelectedItems()->push_back(pitem);

        // Remember we found a selected object
        fFoundASelection = TRUE;
    }
    if (FAILED(hr))
    {
        sc = hr;
        goto Error;
    }

    // Let the component it is in multiselect mode
    *(pComponent->PpMultiSelectSnapinItem()) = pBaseMultiSelectSnapinItem;

    // Make sure we found at least one selected object, otherwise we should never have been called in the first place
    ASSERT(fFoundASelection);

    // Set the result
    *ppDataObject = pBaseMultiSelectSnapinItem;

Cleanup:
    return sc;
Error:
    if (pBaseMultiSelectSnapinItem)
        delete pBaseMultiSelectSnapinItem;
    pBaseMultiSelectSnapinItem = NULL;

    TraceError(_T("CBaseSnapin::ScCreateMultiSelectionDataObject()"), sc);
    goto Cleanup;
}

/* CBaseMultiSelectSnapinItem::ScAllocateMultiSelectionDataObject
 *
 * PURPOSE:                     Allocates a multiselect data object - we store a list of selected object in this special object.
 *
 * PARAMETERS:
 *                                      CBaseMultiSelectSnapinItem ** ppBaseMultiSelectSnapinItem       Pointer to a pointer to the multiselect snapin item to allocate.
 *
 * RETURNS:
 *                                      SC                                                                                                                      Execution code
 */
SC
CBaseSnapin::ScAllocateMultiSelectionDataObject(CBaseMultiSelectSnapinItem ** ppBaseMultiSelectSnapinItem)
{
    // Declarations
    SC                                                                                      sc                                                      ;
    t_itemBaseMultiSelectSnapinItem *                       pBaseMultiSelectSnapinItem      = NULL;                 // create multiselect snapin item

    // Data validation
    ASSERT(ppBaseMultiSelectSnapinItem);
    ASSERT(!*ppBaseMultiSelectSnapinItem);

    // Allocate the object
    sc = ScCreateItemQuick(&pBaseMultiSelectSnapinItem);
    if (sc)
        goto Error;

    // Assign the result
    *ppBaseMultiSelectSnapinItem = pBaseMultiSelectSnapinItem;

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapin::ScAllocateMultiSelectionDataObject()"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Returns the version information string for the snapin.
// The output string must be allocated with CoTaskMemAlloc.
//
SC CBaseSnapin::ScGetSnapinVersion(LPOLESTR *lpVersion)
{
    DECLARE_SC(sc, _T("CBaseSnapin::ScGetSnapinVersion"));
    sc = ScCheckPointers(lpVersion);
    if (sc)
        return sc;

    *lpVersion = CoTaskDupString(L"");
	if ((*lpVersion) == NULL)
		return (E_OUTOFMEMORY);

    return sc;
}

SC CBaseSnapin::ScGetProvider(LPOLESTR *lpName)
{
    DECLARE_SC(sc, _T("CBaseSnapin::ScGetProvider"));
    sc = ScCheckPointers(lpName);
    if (sc)
        return sc;

    *lpName = CoTaskDupString(L"Microsoft");
	if ((*lpName) == NULL)
		return (E_OUTOFMEMORY);

    return sc;
}

// -----------------------------------------------------------------------------
// Creates an ATL Registrar script for the snapin and registers/unregisters it.
// If fRegister is TRUE then we are registering, FALSE we are unregistering.
//
SC CBaseSnapin::ScRegister(BOOL fRegister)
{
    SC                      sc ;
    HRESULT         hr = S_OK;
    INT                     i = 0;
    const INT       cchMaxLen = 256;
    TCHAR           szFileName[cchMaxLen];
    CStr            cstrTemp;

    tstring         strVersion;
    const INT       cchMaxRegScript         = 10000;
    tstring         strRegScript;
    tstring         strFmtSnapinRegScript;
    tstring         strSnapinAboutRegScript;
    tstring         strSnapinNodeTypes;
    tstring         strExtensionScript;
    tstring         strPropertySheetScript;
    tstring         strToolBarScript;
    tstring         strNameSpaceScript;
    tstring         strContextMenuScript;
    tstring         strTemp;
    tstring         strSnapinName;
    tstring         strStandalone;


    // Hacks for version, snapin name.

    // Version number eg 6.3523.0.0
    strVersion = _T("6.3523.0.0");

    strSnapinAboutRegScript = szSnapinAboutRegScript + strVersion;
    cstrTemp.Format(szSnapinAboutRegScript, strVersion.data());
    strSnapinAboutRegScript = cstrTemp;

    strSnapinName.LoadString(_Module.GetModuleInstance(), IdsName());
    // strSnapinName = _T("Sample Framework Snapin");

    GetModuleFileName(_Module.GetModuleInstance(), szFileName, cchMaxLen);

    // Create the Standalone key only if we're a standalone snapin.
    if (FStandalone())
        strStandalone = szStandalone;

    // Format all the extension node stuff.
    for (i = 0; i<Csnr(); i++)
    {
        tstring strNodeTypeName;
        CNodeType *pnodetype = Psnr()[i].pnodetype;
        SNRTypes   snrtypes  = Psnr()[i].snrtypes;

        // Get the name of the node type
        if (! pnodetype->StrName().empty())
        {
            strTemp = pnodetype->StrName();
            strNodeTypeName  = pnodetype->StrClsidNodeType();
            strNodeTypeName += _T(" = s '");
            strNodeTypeName += pnodetype->StrName();
            strNodeTypeName += _T("'");
        }
        else
            strNodeTypeName = pnodetype->StrClsidNodeType();

        // Add the ID of the node to the NodeTypes key if we enumerate it.
        tstring strSnapinNodeTypesTemp;

        if ( (snrtypes & snrEnumSP) || (snrtypes & snrEnumRP) || (snrtypes & snrEnumSM))
        {
            // Add the opening brace the first time around.
            if (strSnapinNodeTypes.empty())
                strSnapinNodeTypes = szSnapinNodeTypeOpen;

            cstrTemp.Format(szFmtSnapinNodeType, pnodetype->StrClsidNodeType().data());
            strSnapinNodeTypesTemp = cstrTemp;
            strSnapinNodeTypes    += strSnapinNodeTypesTemp;
        }

        // Needed because this is a for loop.
        strContextMenuScript = _T("");

        // Menu extensions
        if ( snrtypes & snrExtCM)
        {
            cstrTemp.Format(szfmtSingleExtension, szSingleExtension);
            strContextMenuScript  = cstrTemp;
        }

        // Property Page extensions
        strPropertySheetScript = _T("");
        if ( snrtypes & snrExtPS)
        {
            cstrTemp.Format(szfmtSingleExtension, szSingleExtension);
            strPropertySheetScript = cstrTemp;
        }

        // Toolbar extensions
        strToolBarScript = _T("");
        if ( snrtypes & snrExtTB)
        {
            cstrTemp.Format(szfmtSingleExtension, szSingleExtension);
            strToolBarScript = cstrTemp;
        }

        // Namespace extensions
        strNameSpaceScript = _T("");
        if ( snrtypes & snrExtNS)
        {
            cstrTemp.Format(szfmtSingleExtension, szSingleExtension);
            strNameSpaceScript = cstrTemp;
        }

        cstrTemp.Format(szfmtAllExtensions, strNodeTypeName.data(), strNameSpaceScript.data() , strContextMenuScript.data() , strPropertySheetScript.data() , strToolBarScript.data());

        strExtensionScript += cstrTemp;
    }

    // Add a closing brace to the NodeTypes key if needed
    if (! strSnapinNodeTypes.empty())
        strSnapinNodeTypes += szSnapinNodeTypeClose;

    // Need to concatenate these to form the real fmt string!
    strFmtSnapinRegScript  = szfmtSnapinRegScript1;
    strFmtSnapinRegScript += szfmtSnapinRegScript2;

    cstrTemp.Format(strFmtSnapinRegScript.data(), strVersion.data(), strVersion.data(), strStandalone.data(), strSnapinNodeTypes.data(), strExtensionScript.data());

    strRegScript  = strSnapinAboutRegScript;
    strRegScript += cstrTemp;

    USES_CONVERSION;

    // Set all the replacement parameter values.
    // $REVIEW (ptousig) DLLName is always set to Exadmin !!!
    sc = Registrar().ClearReplacements( );
    sc = Registrar().AddReplacement(szDLLName,                                   L"Snapins");
    sc = Registrar().AddReplacement(szModule,                                    T2COLE(szFileName));
    sc = Registrar().AddReplacement(szCLSID_Snapin,                              T2COLE(StrClsidSnapin().data()));
    sc = Registrar().AddReplacement(szCLSID_About,                               T2COLE(StrClsidAbout().data()));
    sc = Registrar().AddReplacement(szClassName,                                 T2COLE(StrClassName().data()));
    sc = Registrar().AddReplacement(szSnapinName,                                T2COLE(strSnapinName.data()));
    sc = Registrar().AddReplacement(szCLSID_NodeType,                    L"");

    if (fRegister)
    {
        LPCOLESTR lpOleStr = T2COLE(strRegScript.data());
        sc = Registrar().StringRegister(lpOleStr);
        if (sc)
            goto Error;
    }
    else
    {
        hr = Registrar().StringUnregister(strRegScript.data());
        if (hr == DISP_E_EXCEPTION)
        {
            //
            // When trying to unregister a snapin that wasn't registered in
            // the first place, the Registrar returns a DISP_E_EXCEPTION.
            // I don't know why, seems to be a bug in the Registrar. Our
            // solution for now is to ignore the error, not very clean but
            // effective. We are un-registering a snapin that wasn't registered
            // anyway.
            //
            hr = S_OK;
        }
        else if (FAILED(hr))
        {
            //
            // Some other error occured
            //
            sc = hr;
            goto Error;
        }
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapin::ScRegister"), sc);
    goto Cleanup;
}

#if 0
#ifdef _DEBUG

// -----------------------------------------------------------------------------
// Displays the Traces menu (in debug only)
//
SC CBaseSnapin::ScOnMenuTraces(void)
{
    DoTraceDialog();
    return S_OK;
}


// -----------------------------------------------------------------------------
// Provides a description of a given SC Code (in debug only)
//
SC CBaseSnapin::ScOnMenuSCDescription(void)
{
    CStr            strPrompt(_T("Enter the Status Code (sc)"));
    CSTR            (strAnswer, 10);
    CAskStringDialog        dlg;
    ID                      id;
    SC                      sc;

    dlg.SetPrompt(&strPrompt);
    dlg.SetAnswer(&strAnswer);
    strAnswer.BlankString();
    id = dlg.IdModal();
    if (id != IDOK)
        return(sc = S_OK);

    //
    // Convert the text the user entered into a SC.
    //
    sc = (SC) strAnswer.strtoul(NULL, 16);
    MbbErrorBox(sc);
    return sc;
}


// -----------------------------------------------------------------------------
// Debug stuff (in debug only)
//
SC CBaseSnapin::ScOnMenuMemoryDiff(void)
{
    #ifdef USE_BARFMEM
    CBaseWaitCursor wc;
    CBarfMemory::DumpMarked();
    #endif // USE_BARFMEM
    return S_OK;
}

// -----------------------------------------------------------------------------
// Validates Memory (in debug only)
//
SC CBaseSnapin::ScOnMenuValidateMemory(void)
{
    #ifdef USE_BARFMEM
    CBaseWaitCursor wc;
    //Ensure output even if tagMemoryCorruption not turned on
    Trace(&tagAlways, _T("CBaseSnapin::ScOnMenuValidateMemory() - Validating memory ..."));
    ValidateMemory(&tagAlways);
    Trace(&tagAlways, _T("CBaseSnapin::ScOnMenuValidateMemory() - ... Done validating memory."));
    #endif // USE_BARFMEM
    return S_OK;
}

// -----------------------------------------------------------------------------
// Displays Dialog Box of Total Memory Allocated (in debug only)
//
SC CBaseSnapin::ScOnMenuTotalMemory(void)
{
    #ifdef USE_BARFMEM
    INT                             nAlloc;
    INT                             nBytes;
    CSTR                    (str, cchMaxLine);
    CBaseWaitCursor wc;

    TotalMemory(&nAlloc, &nBytes);
    str.Format(_T("Memory currently allocated:\n\n%d allocations\n%d bytes"), nAlloc, nBytes);
    MbbErrorBox(str.Sz(), MB_OK | MB_ICONINFORMATION);
    #endif // USE_BARFMEM
    return S_OK;
}
#endif
#endif //#if 0

// -----------------------------------------------------------------------------
// Given two pointers to dataObjects, are they the same?
// Returns S_OK if objects A and B are the same, S_FALSE if they are different.
//
// $REVIEW (ptousig) Will there ever be a case where two different
//                                       dataobjects should be considered equal ?
//
SC CBaseSnapin::ScCompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    SC sc = S_FALSE;
    BOOL fOwnedA = FALSE;
    BOOL fOwnedB = FALSE;
    CNodeType *pnodetypeA = NULL;
    CNodeType *pnodetypeB = NULL;

    // Check if one of the pointers is NULL.
    if (!lpDataObjectA || !lpDataObjectB)
    {
        // This happens when one of the objects is new.
        // See bug 117170.
        sc = S_FALSE;
        goto Cleanup;
    }

    if (lpDataObjectA == lpDataObjectB)
    {
        // If both pointers are the same, then obviously they are
        // the same object.
        sc = S_OK;
        goto Cleanup;
    }

    // Do we own both dataobjects.
    sc = ScIsOwnedDataObject(lpDataObjectA, &fOwnedA, &pnodetypeA);
    if (sc)
        goto Error;

    sc = ScIsOwnedDataObject(lpDataObjectB, &fOwnedB, &pnodetypeB);
    if (sc)
        goto Error;

    if (fOwnedA == FALSE || fOwnedB == FALSE)
    {
        // We don't own at least of the dataobjects. They are either
        // different or we are not qualified to compare them.
        sc = S_FALSE;
        goto Cleanup;
    }

    // Since we own both dataobjects, and the pointers are different
    // then we can conclude that they represent different objects.
    sc = S_FALSE;

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapin::ScCompareObjects"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Handler of AddMenuItems we ask the item for its menu items. And in debug
// mode we add debug menu items if the item wants us to.
//
SC CBaseSnapin::ScAddMenuItems(LPDATAOBJECT lpDataObject, LPCONTEXTMENUCALLBACK ipContextMenuCallback, long *pInsertionAllowed)
{
    // Declarations
    SC                                      sc;
    CBaseSnapinItem *                       pitem                                           = NULL;
    CBaseMultiSelectSnapinItem *            pBaseMultiSelectSnapinItem      = NULL;

    // Data validation
    ASSERT(lpDataObject);
    ASSERT(ipContextMenuCallback);
    ASSERT(pInsertionAllowed);

    // See if we can extract the multi select data object from the composite data object
    sc = CBaseMultiSelectSnapinItem::ScExtractMultiSelectDataObject(this, lpDataObject, &pBaseMultiSelectSnapinItem);
    if (sc)
        goto Error;

    // If we actually had a composite data object and we were able to find our multiselect snapin item
    if (pBaseMultiSelectSnapinItem)
    {
        // Call ScAddMenuItems for the multiselect object for menu merging
        sc = pBaseMultiSelectSnapinItem->ScAddMenuItems(this, lpDataObject, ipContextMenuCallback, pInsertionAllowed);
        if (sc)
            goto Error;
    }
    else
    {
        // Handle the normal case - PItem() does more work than a simple cast to verify that the snapin item belongs to the snapin etc.
        pitem = Pitem(lpDataObject);
        ASSERT(pitem);

        sc = ScAddMenuItems(pitem, *pInsertionAllowed, ipContextMenuCallback, pitem->Pmenuitem(), pitem->CMenuItem());
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapin::ScAddMenuItems"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Constructor for CSnapinContextMenuItem
//
CSnapinContextMenuItem::CSnapinContextMenuItem(void)
{
    // Initialize members
    ::ZeroMemory(&cm, sizeof(cm));
}

// -----------------------------------------------------------------------------
// Destructor for CSnapinContextMenuItemVectorWrapper
//
CSnapinContextMenuItemVectorWrapper::~CSnapinContextMenuItemVectorWrapper(void)
{
    // Declarations
    INT             nIterator       = 0;

    // Go through all the referenced CSnapinContextMenuItem objects and delete them
    for (nIterator=0; nIterator < cmiv.size(); nIterator++)
    {
        if (cmiv[nIterator])
        {
            delete cmiv[nIterator];
            cmiv[nIterator] = NULL;
        }
    }
}

// -----------------------------------------------------------------------------
// Adds menu items to the context menu.
//
SC
CBaseSnapin::ScAddMenuItems(CBaseSnapinItem * pitem, long lInsertionAllowed, LPCONTEXTMENUCALLBACK ipContextMenuCallback, SnapinMenuItem * rgmenuitem, INT cmenuitem)
{
    // Declarations
    SC                                      sc                      ;
    BOOL                            fAllowed        = TRUE;
    INT                                     nIterator       = 0;

    // Data validation
    ASSERT(pitem);
    ASSERT(ipContextMenuCallback);
    // ASSERT(rgmenuitem); sometimes there is no menu

    // Go through the different menu items
    for (nIterator=0; nIterator < cmenuitem; nIterator++)
    {
        // Local declarations
        CSnapinContextMenuItem        cmi;

        // Get the menu item
        sc = ScGetMenuItem(&cmi, pitem, &(rgmenuitem[nIterator]), &fAllowed, lInsertionAllowed);
        if (sc)
            goto Error;

        // If the menu item is allowed, then add it
        if (fAllowed)
        {
            sc = ipContextMenuCallback->AddItem(&(cmi.cm));
            if (sc)
                goto Error;
        }
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapin::ScAddMenuItems"), sc);
    goto Cleanup;
};

/* CBaseSnapin::ScGetMenuItem
 *
 * PURPOSE:                     Sets a menu item struct for a particular snapin item and for a particular source menu item of that snapin item.
 *
 * PARAMETERS:
 *                                      CSnapinContextMenuItem *      pcmiReturned                            Menu item struct to set
 *                                      CBaseSnapinItem *       pitem                                           Snapin item from which the source menu item comes
 *                                      MenuItem *                      pMenuItemSource                         Source menu item
 *                                      BOOL *                          pfAllowed                                       TRUE if the menu item allowed?
 *
 * RETURNS:
 *                                      SC                                                                                              Execution code
 */
SC
CBaseSnapin::ScGetMenuItem(CSnapinContextMenuItem * pcmiReturned, CBaseSnapinItem * pitem, SnapinMenuItem * pMenuItemSource, BOOL * pfAllowed, long lInsertionAllowed)
{
    // Declarations
    SC                              sc                                                      ;
    LONG                    fFlags                                          = 0;
    DWORD                   dwFlagsMenuDisable                      = 0;
    DWORD                   dwFlagsMenuGray                         = 0;
    DWORD                   dwFlagsMenuChecked                      = 0;

    // Data validation
    ASSERT(pcmiReturned);
    ASSERT(pitem);
    ASSERT(pMenuItemSource);
    ASSERT(pfAllowed);

    // Set default
    *pfAllowed = TRUE;

    // Get the flags from the snapin item
    dwFlagsMenuDisable      = pitem->DwFlagsMenuDisable();
    dwFlagsMenuGray         = pitem->DwFlagsMenuGray();
    dwFlagsMenuChecked      = pitem->DwFlagsMenuChecked();

    // Disabled means don't show at all. Not the same as MMC's MF_DISABLED.
    if (dwFlagsMenuDisable & pMenuItemSource->dwFlagsDisable)
    {
        *pfAllowed = FALSE;
        goto Cleanup;
    }

    // Check if the menu item should be allowed
    switch (pMenuItemSource->lInsertionPointID)
    {
    case CCM_INSERTIONPOINTID_PRIMARY_TOP:
        *pfAllowed = (lInsertionAllowed & CCM_INSERTIONALLOWED_TOP) != 0;
        break;

    case CCM_INSERTIONPOINTID_PRIMARY_NEW:
    case CCM_INSERTIONPOINTID_3RDPARTY_NEW:
        *pfAllowed = ((lInsertionAllowed & CCM_INSERTIONALLOWED_NEW) != 0) && pitem->FHasComponentData();
        break;

    case CCM_INSERTIONPOINTID_PRIMARY_TASK:
    case CCM_INSERTIONPOINTID_3RDPARTY_TASK:
        *pfAllowed = (lInsertionAllowed & CCM_INSERTIONALLOWED_TASK) != 0;
        break;

    case CCM_INSERTIONPOINTID_PRIMARY_VIEW:
        *pfAllowed = (lInsertionAllowed & CCM_INSERTIONALLOWED_VIEW) != 0;
        break;
    }

    // If the menu item is not to be enabled, then discard
    if (!*pfAllowed)
        goto Cleanup;

    // Set flags
    if (dwFlagsMenuGray & pMenuItemSource->dwFlagsGray)
        fFlags |= MF_GRAYED;
    else
        fFlags |= MF_ENABLED;
    if (dwFlagsMenuChecked & pMenuItemSource->dwFlagsChecked)
        fFlags |= MF_CHECKED;
    else
        fFlags |= MF_UNCHECKED;

    // Set other parameters
    if (pMenuItemSource->idsName)
        pcmiReturned->strName.LoadString(_Module.GetResourceInstance(), pMenuItemSource->idsName);
    if (pMenuItemSource->idsStatusBarText)
        pcmiReturned->strStatusBarText.LoadString(_Module.GetResourceInstance(), pMenuItemSource->idsStatusBarText);

    pcmiReturned->cm.strName                = (LPWSTR)pcmiReturned->strName.data();
    pcmiReturned->cm.strStatusBarText       = (LPWSTR)pcmiReturned->strStatusBarText.data();
    pcmiReturned->cm.lCommandID             = pMenuItemSource->lCommandID;
    pcmiReturned->cm.lInsertionPointID      = pMenuItemSource->lInsertionPointID;
    pcmiReturned->cm.fFlags                 = fFlags;
    pcmiReturned->cm.fSpecialFlags          = pMenuItemSource->fSpecialFlags;

Cleanup:
    return sc;
}

// -----------------------------------------------------------------------------
// Load the icon for the snapin and return it to MMC.
//
SC CBaseSnapin::ScGetSnapinImage(HICON *phAppIcon)
{
    SC sc ;

    ASSERT(phAppIcon);

    if (phAppIcon == NULL)
    {
        sc = E_INVALIDARG;
        goto Error;
    }

    if (Idi() == 0)
    {
        // There is no icon for this snapin
        *phAppIcon = NULL;
        goto Cleanup;
    }

    *phAppIcon = ::LoadIcon(_Module.GetModuleInstance(), MAKEINTRESOURCE(Idi()));
    if (*phAppIcon == NULL)
    {
        sc = ScFromWin32(GetLastError());
        goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapin::ScGetSnapinImage"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Release the given item, but only if it is one of the root items.
// Used during MMCN_REMOVE_CHILDREN. We are being told that the item
// that we are "ghosting" is either being destroyed or all of its children
// are being destroyed. In either case, we don't need the ghost item
// anymore.
//
SC CBaseSnapin::ScReleaseIfRootItem(CBaseSnapinItem *pitem)
{
    SC sc ;
    ItemList::iterator iter;

    ASSERT(pitem);

    for (iter = m_ilRootItems.begin(); iter != m_ilRootItems.end(); iter++)
    {
        if (pitem == (*iter))
        {
            m_ilRootItems.erase(iter);
            static_cast<LPDATAOBJECT>(pitem)->Release();
            break;
        }
    }
    return sc;
}

// -----------------------------------------------------------------------------
// Determines whether the specified dataobject is pastable.
//
SC
CBaseSnapin::ScIsPastableDataObject(CBaseSnapinItem * pitemTarget, LPDATAOBJECT lpDataObject, BOOL * pfPastable)
{
    // Declarations
    SC                              sc                              ;
    BOOL                    fPastable               = FALSE;
    CNodeType *             pnodetype               = NULL;
    CLSID                   clsid;
    INT                             isnr                    = 0;

    // Validate parameters
    ASSERT(pitemTarget);
    ASSERT(lpDataObject);
    ASSERT(pfPastable);

    // Is this an MMC node?
    // Get the nodetype, in guid format, of the data object.
    sc = CBaseDataObject::ScGetNodeType(lpDataObject, &clsid);
    if (sc == DV_E_FORMATETC || sc == E_NOTIMPL)
    {
        // Not an MMC Node
        fPastable = FALSE;
        sc = S_FALSE;                                                                                                                   // override the execution code
        goto Cleanup;
    }
    if (sc)
        goto Error;

    // Verify that the snapin item class type is acceptable to the destination
    for (isnr=0; isnr < Csnr(); isnr++)
    {
        // Find a class id match
        if (IsEqualCLSID(*(Psnr(isnr)->pnodetype->PclsidNodeType()), clsid))    // found the CLSID
        {
            // SNR verification
            SNRTypes snrtypes = Psnr(isnr)->snrtypes;

            // $REVIEW (ptousig) So all nodes are pastable ? Sounds to me like
            //                                       snrEnumSP and snrEnumRP shouldn't be in here.
            if ( (snrtypes & snrEnumSP) || (snrtypes & snrEnumRP) || (snrtypes & snrPaste))
                fPastable = TRUE;
            break;                                                  // exit the loop.
        }
    }

    // If it seems we can paste, ask the target item if we can paste here
    if (fPastable)
    {
        sc = pitemTarget->ScOnQueryPaste(lpDataObject, &fPastable);
        if (sc)
            goto Error;
    }

Cleanup:
    // Assign result
    *pfPastable     = fPastable;
    return sc;
Error:
    fPastable = FALSE;
    TraceError(_T("CBaseSnapin::ScIsPastableDataObject()"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Find out which verb should be the default.
//
MMC_CONSOLE_VERB CBaseSnapin::MmcverbDefault(LPDATAOBJECT lpDataObject)
{
    // Ask the item.
    return Pitem(lpDataObject)->MmcverbDefault();
}

// -----------------------------------------------------------------------------
// Find out the verbs that are allowed on this item.
//
SC CBaseSnapin::ScGetVerbs(LPDATAOBJECT lpDataObject, DWORD * pdwVerbs)
{
    // Ask the item.
    return Pitem(lpDataObject)->ScGetVerbs(pdwVerbs);
}


// -----------------------------------------------------------------------------
// Returns the path to the help file for this snapin.
//
SC CBaseSnapin::ScGetHelpTopic(tstring& strCompiledHelpFile)
{
    DECLARE_SC(sc, _T("CBaseSnapin::ScGetHelpTopic"));
    DWORD dwLen = 0;
    const int cchMaxLen = 256;
    TCHAR szFileName[cchMaxLen];

    //
    // Get the full path to the current module
    //
    dwLen = ::GetModuleFileName(_Module.GetModuleInstance() , szFileName, cchMaxLen);
    if (dwLen == 0)
        return (ScFromWin32(GetLastError()));

    strCompiledHelpFile = szFileName;
    //
    // Replace the extension with .CHM
    //
    int nDotPos = strCompiledHelpFile.rfind(_T("."));
    strCompiledHelpFile.erase(nDotPos);
    strCompiledHelpFile += _T(".CHM");

    return sc;
}

// -----------------------------------------------------------------------------
// We are being told that something has changed on the item pointed
// by lParam.
//
SC CBaseSnapin::ScOnPropertyChange(BOOL fScope, LPARAM lParam, IConsoleNameSpace *ipConsoleNameSpace, IConsole *ipConsole)
{
    SC                                      sc                      ;
    LPDATAOBJECT            pdataobject = NULL;
    CBaseSnapinItem *       pitem   = NULL;

    pdataobject = reinterpret_cast<LPDATAOBJECT>(lParam);
    ASSERT(pdataobject);

    pitem = Pitem(pdataobject);
    ASSERT(pitem);

    sc = pitem->ScOnPropertyChange();
    if (sc)
        goto Error;

    if (pitem->FIsContainer())
    {
        // Container items should be updated just once.
        sc = pitem->ScUpdateScopeItem(ipConsoleNameSpace);
        if (sc)
            goto Error;
    }
    else
    {
        // Result item. Need to update the item in all views.
        // Call out to all the views to update themselves.
        sc = ipConsole->UpdateAllViews(pdataobject, 0, ONVIEWCHANGE_UPDATERESULTITEM);
        if (sc)
            goto Error;
    }
Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapin::ScOnPropertyChange"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// The user has changed the name of an item.
//
SC CBaseSnapin::ScOnRename(LPDATAOBJECT lpDataObject, const tstring& strNewName, IConsole *ipConsole)
{
    SC               sc= S_FALSE;
    CBaseSnapinItem *pitem = NULL;

    ASSERT(lpDataObject);

    pitem = Pitem(lpDataObject);
    ASSERT(pitem);

    if (strNewName.empty())
    {
        // ScOnQueryPaste should prevent this from ever happening
        sc = E_UNEXPECTED;
        goto Error;
    }

    if (strNewName.length() == 0)
        goto Cleanup;

    // Tell the object to rename
    // If it returns S_FALSE, the rename was not done.
    sc = pitem->ScOnRename(strNewName);
    if (sc)
        goto Error;

    if (sc == S_OK)
    {
        // If this was renamed, reload our children
        sc = ipConsole->UpdateAllViews(static_cast<IDataObject *>(pitem), 0, ONVIEWCHANGE_REFRESHCHILDREN);
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapin::ScOnRename"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Received on a paste command.
//
// lpDataObject is the node receiving the past command.
// lpDataObjectList are the nodes being pasted.
// ppDataObjectPasted is where we answer the list of nodes that were successfully pasted.
//
SC CBaseSnapin::ScOnPaste(LPDATAOBJECT lpDataObject, LPDATAOBJECT lpDataObjectList, LPDATAOBJECT * ppDataObjectPasted, IConsole * ipConsole)
{
    // Declarations
    SC                                                              sc                                                      ;
    CBaseSnapinItem *                               pitemTarget                                     = NULL;
    DWORD                                                   dwCanCopyCut                            = 0;
    BOOL                                                    fPasted                                         = FALSE;
    CBaseMultiSelectSnapinItem *    pBaseMultiSelectSnapinItem      = NULL;

    // Handle special case
    if (!lpDataObjectList)
    {
        // ScOnQueryPaste should prevent this from ever happening
        sc = E_UNEXPECTED;
        goto Error;
    }

    // Data validation
    ASSERT(lpDataObject);
    ASSERT(lpDataObjectList);
    ASSERT(ipConsole);
    // other parameters can not be ASSERTed

    // Get the target item
    pitemTarget = Pitem(lpDataObject);
    ASSERT(pitemTarget);

    // Determine if this is a multiselect data object
    sc = CBaseMultiSelectSnapinItem::ScGetMultiSelectDataObject(lpDataObjectList, &pBaseMultiSelectSnapinItem);
    if (sc)
        goto Error;

    // If we received a multiselect snapin item
    if (pBaseMultiSelectSnapinItem)
    {
        // Call ScOnPaste for the multiselect object for dispatch
        sc = pBaseMultiSelectSnapinItem->ScOnPaste(this, pitemTarget, lpDataObjectList, ppDataObjectPasted, ipConsole);
        if (sc)
            goto Error;
    }
    else
    {
        // Ask the item to copy the underlying object
        sc = pitemTarget->ScOnPaste(lpDataObjectList, ppDataObjectPasted ? TRUE : FALSE, &fPasted);
        if (sc)
            goto Error;

        // If the object was pasted
        if (fPasted)
        {
            // If this was a cut, we need to return to MMC the items that were pasted
            // (do not delete the dropped item if we are just adding it to a policy)
            if (ppDataObjectPasted && !pitemTarget->FIsPolicy())
			{
                *ppDataObjectPasted = lpDataObjectList;
				(*ppDataObjectPasted)->AddRef();
			}

            // Reload our children
            sc = ipConsole->UpdateAllViews(static_cast<IDataObject *>(pitemTarget), 0, ONVIEWCHANGE_REFRESHCHILDREN);
            if (sc)
                goto Error;
        }
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapin::ScOnPaste"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// We need to figure out whether we will allow pasting of this object.
// lpDataObject is the target object.
// lpDataObjectList are the objects being pasted.
//
SC CBaseSnapin::ScOnQueryPaste(LPDATAOBJECT lpDataObject, LPDATAOBJECT lpDataObjectList, LPDWORD pdwFlags)
{
    // Declarations
    SC                                                              sc                                                      ;
    CBaseSnapinItem *                               pitemTarget                                     = NULL;
    BOOL                                                    fCanPaste                                       = FALSE;
    CNodeType               *                               pnodetype                                       = NULL;
    CBaseMultiSelectSnapinItem *    pBaseMultiSelectSnapinItem      = NULL;

    // Data validation
    ASSERT(lpDataObject);
    ASSERT(lpDataObjectList);
    ASSERT(pdwFlags);

    // Get the target item
    pitemTarget = Pitem(lpDataObject);
    ASSERT(pitemTarget);

    // Determine if this is a multiselect data object
    // Determine if this is a multiselect data object
    sc = CBaseMultiSelectSnapinItem::ScGetMultiSelectDataObject(lpDataObjectList, &pBaseMultiSelectSnapinItem);
	if (sc == SC(DV_E_FORMATETC) )
	{
		sc = S_FALSE; // Cant paste.
		return sc;
	}

    if (sc)
        goto Error;

    // If we received a multiselect snapin item
    if (pBaseMultiSelectSnapinItem)
    {
        // Call ScOnCutOrMove for the multiselect object for dispatch
        sc = pBaseMultiSelectSnapinItem->ScIsPastableDataObject(this, pitemTarget, lpDataObjectList, &fCanPaste);
        if (sc)
            goto Error;
    }
    else
    {
        // Determine if the parse operation is acceptable
        // Here lpDataObjectList is only one item
        sc = ScIsPastableDataObject(pitemTarget, lpDataObjectList, &fCanPaste);
        if (sc)
            goto Error;
    }

    // Determine if we can paste
    if (!fCanPaste)
        sc = S_FALSE;                                                                   // indicate no pasting

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapin::ScOnQueryPaste()"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// We need to figure out whether we can handle the given dataobject that is from
// different process.
// lpDataObject is the target object.
// lpDataObjectList are the objects being pasted.
//
SC CBaseSnapin::ScOnCanPasteOutOfProcDataObject(LPBOOL pbCanHandle)
{
    // Declarations
    DECLARE_SC(sc, TEXT("CBaseSnapin::ScOnCanPasteOutOfProcDataObject"));
    sc = ScCheckPointers(pbCanHandle);
    if (sc)
        return sc;

    *pbCanHandle = TRUE;

    return sc;
}

// -----------------------------------------------------------------------------
SC CBaseSnapin::ScOnCutOrMove(LPDATAOBJECT lpDataObjectList, IConsoleNameSpace * ipConsoleNameSpace, IConsole * ipConsole)
{
    // Declarations
    SC                                                              sc                                                      ;
    CBaseSnapinItem *                               pitem                                           = NULL;
    CBaseMultiSelectSnapinItem *    pBaseMultiSelectSnapinItem      = NULL;

    // Data validation
    ASSERT(lpDataObjectList);
    ASSERT(ipConsoleNameSpace);
    ASSERT(ipConsole);

    // Determine if this is a multiselect data object
    sc = CBaseMultiSelectSnapinItem::ScGetMultiSelectDataObject(lpDataObjectList, &pBaseMultiSelectSnapinItem);
    if (sc)
        goto Error;

    // If we received a multiselect snapin item
    if (pBaseMultiSelectSnapinItem)
    {
        // Call ScOnCutOrMove for the multiselect object for dispatch
        sc = pBaseMultiSelectSnapinItem->ScOnCutOrMove(this, lpDataObjectList, ipConsoleNameSpace, ipConsole);
        if (sc)
            goto Error;
    }
    else
    {
        // Handle the normal case - PItem() does more work than a simple cast to verify that the snapin item belongs to the snapin etc.
        pitem = Pitem(lpDataObjectList);
        ASSERT(pitem);

        // Ask the item to delete the underlying object.
        sc = pitem->ScOnCutOrMove();
        if (sc)
            goto Error;
        if (sc == S_FALSE)
            goto Cleanup;

        if (pitem->FIsContainer())
        {
            // Container items need to be deleted from the document
            // Delete the item and everything below it.
            if (pitem->Hscopeitem())
            {
                sc = ipConsoleNameSpace->DeleteItem(pitem->Hscopeitem(), TRUE);
                if (sc)
                    goto Error;
                pitem->SetHscopeitem(0);
            }
        }
        else
        {
            // Leaf items need to be deleted from the views.
            sc = ipConsole->UpdateAllViews(lpDataObjectList, 0, ONVIEWCHANGE_DELETESINGLEITEM);
            if (sc)
                goto Error;
        }

        // Delete this item, MMC is still using it. Below ScDeleteSubTree
		// will release the object so Addref it. We got this through
        // the Pitem() call which just type cast the dataobject.
		pitem->AddRef();
        sc = pitem->ScDeleteSubTree(TRUE);
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapin::ScOnCutOrMove"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// This method allows a CComponentData to tell us it is being
// destroyed. Any item referring to this CD as its owner will
// have their owner pointer nulled.
SC CBaseSnapin::ScOwnerDying(CComponentData *pComponentData)
{
    ItemList::iterator iter;
    for (iter = m_ilRootItems.begin(); iter != m_ilRootItems.end(); iter++)
    {
        if ((*iter)->FHasComponentData() && (*iter)->PComponentData() == pComponentData)
            (*iter)->SetComponentData(NULL);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\lib\snapinabout.cxx ===
/*
 *      SnapinAbout.cxx
 *
 *
 *      Copyright (c) 1998-1999 Microsoft Corporation
 *
 *      PURPOSE:        Defines the CSnapinAbout class.
 *
 *
 *      OWNER:          ptousig
 */

#include <headers.hxx>

CSnapinAbout::CSnapinAbout(CBaseSnapin *psnapin)
{
    SC sc = S_OK;

    m_psnapin = psnapin;

    sc = Psnapin()->ScInitBitmaps();
    if (sc)
        goto Error;

Cleanup:
    return;
Error:
    TraceError(_T("CSnapinAbout::CSnapinAbout"), sc);
    MMCErrorBox(sc);
    goto Cleanup;
}

CSnapinAbout::~CSnapinAbout(void)
{
}

HRESULT CSnapinAbout::GetSnapinDescription(LPOLESTR *lpDescription)
{
    DECLARE_SC(sc,_T("CSnapinAbout::GetSnapinDescription"));
    Trace(tagBaseSnapinISnapinAbout, _T("--> %s::ISnapinAbout::GetSnapinDescription()"), StrSnapinClassName());
    ADMIN_TRY;
    sc=Psnapin()->ScGetSnapinDescription(lpDescription);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinISnapinAbout, _T("<-- %s::ISnapinAbout::GetSnapinDescription is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

HRESULT CSnapinAbout::GetProvider(LPOLESTR * lpName)
{
    DECLARE_SC(sc,_T("CSnapinAbout::GetProvider"));
    Trace(tagBaseSnapinISnapinAbout, _T("--> %s::ISnapinAbout::GetProvider()"), StrSnapinClassName());
    ADMIN_TRY;
    sc=Psnapin()->ScGetProvider(lpName);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinISnapinAbout, _T("<-- %s::ISnapinAbout::GetProvider is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

HRESULT CSnapinAbout::GetSnapinVersion(LPOLESTR *lpVersion)
{
    DECLARE_SC(sc,_T("CSnapinAbout::GetSnapinVersion"));
    Trace(tagBaseSnapinISnapinAbout, _T("--> %s::ISnapinAbout::GetSnapinVersion()"), StrSnapinClassName());
    ADMIN_TRY;
    sc=Psnapin()->ScGetSnapinVersion(lpVersion);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinISnapinAbout, _T("<-- %s::ISnapinAbout::GetSnapinVersion is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

HRESULT CSnapinAbout::GetSnapinImage(HICON *phAppIcon)
{
    DECLARE_SC(sc,_T("CSnapinAbout::GetSnapinImage"));
    Trace(tagBaseSnapinISnapinAbout, _T("--> %s::ISnapinAbout::GetSnapinImage()"), StrSnapinClassName());
    ADMIN_TRY;
    ASSERT(phAppIcon);
    sc=Psnapin()->ScGetSnapinImage(phAppIcon);
    if (sc.ToHr() == S_OK && *phAppIcon == NULL)
        sc=S_FALSE;
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinISnapinAbout, _T("<-- %s::ISnapinAbout::GetSnapinImage is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

HRESULT CSnapinAbout::GetStaticFolderImage(HBITMAP *hSmallImage, HBITMAP *hSmallImageOpen, HBITMAP *hLargeImage, COLORREF *cMask)
{
    DECLARE_SC(sc,_T("CSnapinAbout::GetStaticFolderImage"));
    Trace(tagBaseSnapinISnapinAbout, _T("--> %s::ISnapinAbout::GetStaticFolderImage()"), StrSnapinClassName());
    ADMIN_TRY;
    sc=Psnapin()->ScGetStaticFolderImage(hSmallImage, hSmallImageOpen, hLargeImage, cMask);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinISnapinAbout, _T("<-- %s::ISnapinAbout::GetStaticFolderImage is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\lib\headers.cxx ===
/*
 *      headers.cxx
 *
 *
 *      Copyright (c) 1998 Microsoft Corporation
 *
 *      PURPOSE:        Contains all the junk that couldn't fit anywhere else.
 *
 *
 *      OWNER:          vivekj
 */

#include <headers.hxx>

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#ifdef VIEW_SUB
// hack here
extern "C"
const CLSID CLSID_CCertConfig = {0x52F2ED5B,0x6C6C,0x11D1,{0xA1,0x22,0x00,0xC0,0x4F,0xC3,0x35,0x89}};
extern "C"
const CLSID IID_ICertConfig = {0x52F2ED5B,0x6C6C,0x11D1,{0xA1,0x22,0x00,0xC0,0x4F,0xC3,0x35,0x89}};
#endif //VIEW_SUB

/*
 *      Purpose:        Initializes the BaseMMC subsystem (Instance).
 *
 *      Return value:
 *              sc              Error encountered
 */
SC ScInitInstanceBaseMMC( void )
{
        SC              sc = S_OK;
        return sc;
}


/*
 *      Purpose:        Undoes what ScInitInstanceBaseMMC did.
 */
void DeinitInstanceBaseMMC( void )
{
}

/*
 *      Purpose:        Initializes the BaseMMC subsystem (Application).
 *
 *      Return value:
 *              sc              Error encountered
 */
SC ScInitApplicationBaseMMC()
{
        SC              sc = S_OK;
        return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\lib\dataobject.cxx ===
/*
 *      dataobject.cxx
 *
 *
 *      Copyright (c) 1998-1999 Microsoft Corporation
 *
 *      PURPOSE:        Implements the CDataObject class
 *
 *
 *      OWNER:          ptousig
 */

#include <headers.hxx>

// -----------------------------------------------------------------------------
// static variables
UINT CBaseDataObject::s_cfAdminHscopeitem               = RegisterClipboardFormat(CF_EXCHANGE_ADMIN_HSCOPEITEM);        // The HSCOPEITEM of this node
UINT CBaseDataObject::s_cfMMCSnapinMachineName          = RegisterClipboardFormat(CF_MMC_SNAPIN_MACHINE_NAME);          // Format supplied by the Computer manager snapin. Passes in the name of the server.
UINT CBaseDataObject::s_cfDisplayName                   = RegisterClipboardFormat(CCF_DISPLAY_NAME);
UINT CBaseDataObject::s_cfNodeType                      = RegisterClipboardFormat(CCF_NODETYPE);
UINT CBaseDataObject::s_cfSzNodeType                    = RegisterClipboardFormat(CCF_SZNODETYPE);
UINT CBaseDataObject::s_cfSnapinClsid                   = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
UINT CBaseDataObject::s_cfNodeID                        = RegisterClipboardFormat(CCF_NODEID);
UINT CBaseDataObject::s_cfColumnSetId                   = RegisterClipboardFormat(CCF_COLUMN_SET_ID);
UINT CBaseDataObject::s_cfMultiSelectionItemTypes       = RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT);    // Multiselect - list of types for the selected nodes

// -----------------------------------------------------------------------------
HRESULT CBaseDataObject::GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium)
{
    DECLARE_SC(sc,_T(""));
    Trace(tagBaseSnapinIDataObject, _T("--> %S::IDataObject::GetDataHere(pformatetc->cfFormat=%s)"), SzGetSnapinItemClassName(), SzDebugNameFromFormatEtc(pformatetc->cfFormat));
    ADMIN_TRY;
    sc=ScGetDataHere(pformatetc, pmedium);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIDataObject, _T("<-- %S::IDataObject::GetDataHere is returning hr=%s"), SzGetSnapinItemClassName(), SzGetDebugNameOfHr(sc.ToHr()));

	if (sc == SC(DV_E_FORMATETC) )
	{
		sc.Clear();
        return DV_E_FORMATETC;
	}

    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CBaseDataObject::GetData(FORMATETC *pformatetc, STGMEDIUM *pmedium)
{
    DECLARE_SC(sc,_T(""));
    Trace(tagBaseSnapinIDataObject, _T("--> %S::IDataObject::GetData(pformatetc->cfFormat=%s)"), SzGetSnapinItemClassName(), SzDebugNameFromFormatEtc(pformatetc->cfFormat));
    ADMIN_TRY;
    sc=ScGetData(pformatetc, pmedium);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIDataObject, _T("<-- %S::IDataObject::GetData is returning hr=%s"), SzGetSnapinItemClassName(), SzGetDebugNameOfHr(sc.ToHr()));

	if (sc == SC(DV_E_FORMATETC) )
	{
		sc.Clear();
        return DV_E_FORMATETC;
	}

    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CBaseDataObject::QueryGetData(FORMATETC *pformatetc)
{
    DECLARE_SC(sc,_T(""));
    Trace(tagBaseSnapinIDataObject, _T("--> %S::IDataObject::QueryGetData(pformatetc->cfFormat=%s)"), SzGetSnapinItemClassName(), SzDebugNameFromFormatEtc(pformatetc->cfFormat));
    ADMIN_TRY;
    sc=ScQueryGetData(pformatetc);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIDataObject, _T("<-- %S::IDataObject::QueryGetData is returning hr=%s"), SzGetSnapinItemClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CBaseDataObject::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
{
    DECLARE_SC(sc,_T(""));
    Trace(tagBaseSnapinIDataObject, _T("--> %S::IDataObject::EnumFormatEtc(dwDirection=%d)"), SzGetSnapinItemClassName(), dwDirection);
    ADMIN_TRY;
    sc=ScEnumFormatEtc(dwDirection, ppEnumFormatEtc);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIDataObject, _T("<-- %S::IDataObject::EnumFormatEtc is returning hr=%s"), SzGetSnapinItemClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
// Renders the data in a preallocated medium.
//
SC CBaseDataObject::ScGetDataHere(FORMATETC *pFormatEtc, STGMEDIUM *pMedium)
{
    SC sc = S_OK;

    // check parameters
    if (pFormatEtc == NULL || pMedium == NULL)
        return sc = E_INVALIDARG;

    const   CLIPFORMAT cf = pFormatEtc->cfFormat;
    CComPtr<IStream> spStream;
    HGLOBAL hGlobal = NULL;

    // see what kind of medium we have
    if (pFormatEtc->tymed == TYMED_ISTREAM)
    {
        // it's a stream
        spStream = pMedium->pstm;
        if (spStream == NULL)
        {
            sc = E_UNEXPECTED;
            goto Error;
        }
    }
    else if (pFormatEtc->tymed == TYMED_HGLOBAL)
    {
        // it's hGlobal
        hGlobal = pMedium->hGlobal;

        sc = CreateStreamOnHGlobal( hGlobal, FALSE, &spStream );
        if ( sc )
            goto Error;                                              // Minimal error checking
    }
    else // got the media we do not support
    {
        sc = DV_E_TYMED;
        goto Error;
    }

    pMedium->tymed = pFormatEtc->tymed;
    pMedium->pUnkForRelease = NULL;          // by OLE spec

    if (cf == s_cfDisplayName )
        sc = ScWriteDisplayName( spStream );

    else if ( cf == s_cfAdminHscopeitem )
        sc = ScWriteAdminHscopeitem( spStream );

    else if ( cf == s_cfNodeType )
        sc = ScWriteNodeType( spStream );

    else if ( cf == s_cfSzNodeType )
        sc = ScWriteSzNodeType( spStream );

    else if ( cf == s_cfSnapinClsid )
        sc = ScWriteClsid( spStream );

    else if ( cf == s_cfNodeID )
        sc = ScWriteNodeID( spStream );
    else if (cf == s_cfColumnSetId )
        sc = ScWriteColumnSetId( spStream );

    else if ( (cf == s_cfMultiSelectionItemTypes) && FIsMultiSelectDataObject())            // the clipboard format is enabled only for multiselect data objects
        sc = ScWriteMultiSelectionItemTypes( spStream );

	else if ( cf == CF_TEXT)
		sc = ScWriteAnsiName( spStream );

    else // Unknown format
    {
        // we will pretend to suport it for IStream based media (it probably comes from object model)
        if (pFormatEtc->tymed == TYMED_ISTREAM)
        {
            WCHAR szDescription[] = L"Sample Value For Requested Format Of: ";
            spStream->Write(szDescription, wcslen(szDescription) * sizeof(WCHAR), NULL);

            TCHAR szFormatName[512];
            int nChars = GetClipboardFormatName(cf, szFormatName, sizeof(szFormatName) / sizeof(szFormatName[0]));

            USES_CONVERSION;
            spStream->Write(T2W(szFormatName), nChars * sizeof(WCHAR), NULL);
        }
        else
        {
            sc = DV_E_FORMATETC;
            goto Cleanup;
        }
    }

    if (sc)
        goto Error;

    if (pFormatEtc->tymed == TYMED_HGLOBAL)
    {
        sc = GetHGlobalFromStream(spStream, &hGlobal);
        if (sc)
            goto Error;

        ASSERT(pMedium->hGlobal == NULL || pMedium->hGlobal == hGlobal);
        pMedium->hGlobal = hGlobal;
    }

Cleanup:
    return sc;
Error:
    if (sc == E_NOTIMPL)
    {
        sc = DV_E_FORMATETC; // Format not supported by this node
        goto Cleanup;
    }
    TraceError(_T("CBaseDataObject::GetDataHere"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Renders the data in a newly allocated medium.
//
SC CBaseDataObject::ScGetData(FORMATETC *pFormatEtc, STGMEDIUM *pmedium)
{
    SC sc = S_OK;

    pmedium->tymed = TYMED_HGLOBAL;
    pmedium->pUnkForRelease = NULL;
    pmedium->hGlobal = NULL;

    sc = ScGetDataHere(pFormatEtc, pmedium);

	if (sc == SC(DV_E_FORMATETC) )
	{
		sc.Clear();
        return DV_E_FORMATETC;
	}

    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseDataObject::ScGetData"), sc);
    if (pmedium->hGlobal)
        GlobalFree(pmedium->hGlobal);
    pmedium->hGlobal = NULL;
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Asks whether a given format is supported by this data object.
//
SC CBaseDataObject::ScQueryGetData(FORMATETC *pFormatEtc)
{
    SC                                      sc              = S_OK;
    const   CLIPFORMAT      cf              = pFormatEtc->cfFormat;


    if ( ( cf == s_cfDisplayName )               ||
         ( cf == s_cfNodeType )                  ||
         ( cf == s_cfSzNodeType )                ||
         ( cf == s_cfSnapinClsid )               ||
         ( cf == s_cfNodeID )                    ||
		 ( cf == CF_TEXT)                        ||
         ( (cf == s_cfMultiSelectionItemTypes) && FIsMultiSelectDataObject() )           // the clipboard format is enabled only for multiselect data objects
       )
    {
        sc = S_OK;                                                      // known and acceptable format
    }
    else
    {
        sc = S_FALSE;                                           // unknown or unacceptable format
    }

    return sc;
}

// -----------------------------------------------------------------------------
// Enumerates available clipboard format supported by this data object.
// Only implemented in DEBUG.
//
SC CBaseDataObject::ScEnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
#ifdef DBG
{
    SC                                      sc              = S_OK;
    CComObject<CEnumFormatEtc>      *pEnum = NULL;

    ASSERT(ppEnumFormatEtc);

    sc = CComObject<CEnumFormatEtc>::CreateInstance(&pEnum);
    if (!pEnum)
        goto MemoryError;

    sc = pEnum->QueryInterface(__uuidof(IEnumFORMATETC),(void **) ppEnumFormatEtc );
    pEnum = NULL;
    if (sc)
        goto Error;

Cleanup:
    return sc;
MemoryError:
    if (pEnum)
        delete pEnum;
    pEnum = NULL;
Error:
    TraceError(_T("CBaseDataObject::ScEnumFormatEtc"), sc);
    goto Cleanup;

}
#else
{
    return E_NOTIMPL;
}
#endif


// -----------------------------------------------------------------------------
// A convenience function to extract a GUID of the specified clipboard format
// from a dataobject.
//
SC CBaseDataObject::ScGetGUID(UINT cf, LPDATAOBJECT lpDataObject, GUID *pguid)
{
    SC              sc              = S_OK;
    STGMEDIUM       stgmedium       = {TYMED_HGLOBAL,  NULL};
    FORMATETC       formatetc       = {(CLIPFORMAT)cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    BYTE*           pb              = NULL;

    // validate parameters
    ASSERT(lpDataObject);
    ASSERT(pguid);

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, sizeof(GUID));
    if (!stgmedium.hGlobal)
        goto MemoryError;

    // Attempt to get data from the object
    sc = lpDataObject->GetDataHere(&formatetc, &stgmedium);
	if (sc == SC(DV_E_FORMATETC) )
	{
		SC scNoTrace = sc;
		sc.Clear();
		return scNoTrace;
	}

    if (sc)
        goto Error;

    // Copy the GUID into the return buffer
    pb = (BYTE*) GlobalLock(stgmedium.hGlobal);
    CopyMemory(pguid, pb, sizeof(GUID));

Cleanup:
    if (pb)
        GlobalUnlock(stgmedium.hGlobal);
    if (stgmedium.hGlobal)
    {
        ASSERT(GlobalFree(stgmedium.hGlobal) == NULL);
    }
    stgmedium.hGlobal = NULL;

    return sc;
MemoryError:
    sc = E_OUTOFMEMORY;
Error:
    TraceError(_T("CBaseDataObject::ScGetGUID"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// A convenience function to extract a string of the specified clipboard format
// from a dataobject.
//
SC CBaseDataObject::ScGetString(UINT cf, LPDATAOBJECT lpDataObject, tstring& str)
{
    SC                      sc                      = S_OK;
    STGMEDIUM       stgmedium       = {TYMED_HGLOBAL,  NULL};
    FORMATETC       formatetc       = {(CLIPFORMAT)cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    BYTE*                      pb                      = NULL;

    // validate parameters
    ASSERT(lpDataObject);

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, str.length());
    if (!stgmedium.hGlobal)
        goto MemoryError;

    // Attempt to get data from the object
    sc = lpDataObject->GetData(&formatetc, &stgmedium);
    if (sc)
        goto Error;

    // copy the string into the return buffer
    pb = (BYTE*) GlobalLock(stgmedium.hGlobal);
	str = (LPTSTR)pb;

Cleanup:
    if (pb)
        GlobalUnlock(stgmedium.hGlobal);
    if (stgmedium.hGlobal)
    {
        ASSERT(GlobalFree(stgmedium.hGlobal) == NULL);
    }
    stgmedium.hGlobal = NULL;

    return sc;
MemoryError:
    sc = E_OUTOFMEMORY;
Error:
    TraceError(_T("CBaseDataObject::ScGetString"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// A convenience function to extract a bool of the specified clipboard format
// from a dataobject.
//
SC CBaseDataObject::ScGetBool(UINT cf, LPDATAOBJECT lpDataObject, BOOL *pf)
{
    SC                      sc                      = S_OK;
    STGMEDIUM       stgmedium       = {TYMED_HGLOBAL,  NULL};
    FORMATETC       formatetc       = {(CLIPFORMAT)cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    BYTE*                      pb                      = NULL;

    // validate parameters
    ASSERT(lpDataObject);
    ASSERT(pf);

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, sizeof(BOOL));
    if (!stgmedium.hGlobal)
        goto MemoryError;

    // Attempt to get data from the object
    sc = lpDataObject->GetDataHere(&formatetc, &stgmedium);
    if (sc)
        goto Error;

    // copy the BOOL into the return buffer
    pb = (BYTE*) GlobalLock(stgmedium.hGlobal);
    CopyMemory(pf, pb, sizeof(BOOL));

Cleanup:
    if (pb)
        GlobalUnlock(stgmedium.hGlobal);
    if (stgmedium.hGlobal)
    {
        ASSERT(GlobalFree(stgmedium.hGlobal) == NULL);
    }
    stgmedium.hGlobal = NULL;

    return sc;
MemoryError:
    sc = E_OUTOFMEMORY;
Error:
    TraceError(_T("CBaseDataObject::ScGetBool"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// A convenience function to extract a dword of the specified clipboard format
// from a dataobject.
//
SC CBaseDataObject::ScGetDword(UINT cf, LPDATAOBJECT lpDataObject, DWORD *pdw)
{
    SC                      sc                      = S_OK;
    STGMEDIUM       stgmedium       = {TYMED_HGLOBAL,  NULL};
    FORMATETC       formatetc       = {(CLIPFORMAT)cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    BYTE*                      pb                      = NULL;

    // validate parameters
    ASSERT(lpDataObject);
    ASSERT(pdw);

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, sizeof(DWORD));
    if (!stgmedium.hGlobal)
        goto MemoryError;

    // Attempt to get data from the object
    sc = lpDataObject->GetDataHere(&formatetc, &stgmedium);
    if (sc)
        goto Error;

    // copy the DWORD into the return buffer
    pb = (BYTE*) GlobalLock(stgmedium.hGlobal);
    CopyMemory(pdw, pb, sizeof(DWORD));

Cleanup:
    if (pb)
        GlobalUnlock(stgmedium.hGlobal);
    if (stgmedium.hGlobal)
    {
        ASSERT(GlobalFree(stgmedium.hGlobal) == NULL);
    }
    stgmedium.hGlobal = NULL;

    return sc;
MemoryError:
    sc = E_OUTOFMEMORY;
Error:
    TraceError(_T("CBaseDataObject::ScGetDword"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// A convenience function to extract the SNodeID from a dataobject.
// The SNodeID will be allocated with PvAlloc() and needs to be freed by
// the caller.
//
SC CBaseDataObject::ScGetNodeID(LPDATAOBJECT lpDataObject, SNodeID **ppsnodeid)
{
    SC                      sc                      = S_OK;
    STGMEDIUM       stgmedium       = {TYMED_HGLOBAL, NULL, NULL};
    FORMATETC       formatetc       = {(CLIPFORMAT)s_cfNodeID, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    BYTE*           pb              = NULL;
    int             cb              = 0;
    SNodeID *       psnodeid        = NULL;

    // validate parameters
    ASSERT(lpDataObject);
    ASSERT(ppsnodeid);
    ASSERT(*ppsnodeid == NULL);

    // Attempt to get data from the object
    sc = lpDataObject->GetData(&formatetc, &stgmedium);
    if (sc)
        goto Error;

    // Get a pointer to the blob
    pb = (BYTE*) GlobalLock(stgmedium.hGlobal);
    psnodeid = (SNodeID *) pb;
    cb = sizeof(DWORD) + psnodeid->cBytes;

    // Allocate a new buffer with PvAlloc
    psnodeid = (SNodeID *) GlobalAlloc(GMEM_FIXED, cb);
    if (psnodeid == NULL)
        goto MemoryError;

    CopyMemory(psnodeid, pb, cb);

    // Transfer ownership to our caller
    *ppsnodeid = psnodeid;
    psnodeid = NULL;

Cleanup:
    if (pb)
        GlobalUnlock(stgmedium.hGlobal);
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);
    if (psnodeid)
        GlobalFree(psnodeid);
    return sc;
MemoryError:
    sc = E_OUTOFMEMORY;
Error:
    TraceError(_T("CBaseDataObject::ScGetNodeID"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// A convenience function to extract an MMC Column Set ID from a dataobject.
//
SC CBaseDataObject::ScGetColumnSetID(LPDATAOBJECT lpDataObject, SColumnSetID ** ppColumnSetID)
{
    SC                      sc          = S_OK;
    STGMEDIUM               stgmedium   = {TYMED_HGLOBAL,  NULL};
    FORMATETC               formatetc   = {(CLIPFORMAT)s_cfColumnSetId, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    BYTE*                   pb          = NULL;
    SColumnSetID *  pColumnSetID        = NULL;
    int                     cb          = 0;

    // validate parameters
    ASSERT(lpDataObject);
    ASSERT(ppColumnSetID);
    ASSERT(!*ppColumnSetID);

    // Attempt to get data from the object
    sc = lpDataObject->GetData(&formatetc, &stgmedium);
    if (sc)
        goto Error;

    pb = (BYTE*)GlobalLock(stgmedium.hGlobal);
    pColumnSetID = (SColumnSetID *) pb;
    cb = sizeof(SColumnSetID) + pColumnSetID->cBytes;

    // Allocate a new buffer with PvAlloc
    *ppColumnSetID = (SColumnSetID *)GlobalAlloc(GMEM_FIXED, cb);
    if (*ppColumnSetID == NULL)
        goto MemoryError;

    CopyMemory(*ppColumnSetID, pColumnSetID, cb);

Cleanup:
    if (pColumnSetID)
        GlobalUnlock(stgmedium.hGlobal);
    if (stgmedium.hGlobal)
    {
        ASSERT(GlobalFree(stgmedium.hGlobal) == NULL);
    }
    stgmedium.hGlobal = NULL;

    return sc;
MemoryError:
    sc = E_OUTOFMEMORY;
Error:
    if(*ppColumnSetID)
        delete (*ppColumnSetID);
    (*ppColumnSetID) = NULL;
    TraceError(_T("CBaseDataObject::ScGetColumnSetID"), sc);
    goto Cleanup;
}


// -----------------------------------------------------------------------------
// Returns the name of the clipboard format (debug only)
//
#ifdef DBG
LPTSTR CBaseDataObject::SzDebugNameFromFormatEtc(UINT format)
{
    const int cchMaxLine = 256;
    static TCHAR s_szName[cchMaxLine];
    int ret = 0;

    ret = GetClipboardFormatName(format, s_szName, cchMaxLine);
    if (ret == 0)
        _tcscpy(s_szName, _T("Unknown Clipboard Format"));

    return s_szName;
}
#endif

// -----------------------------------------------------------------------------
// Moves to the next available clipboard format (debug only)
//
#ifdef DBG
STDMETHODIMP CEnumFormatEtc::Next(
                                 /* [in] */                                              ULONG           celt,
                                 /* [length_is][size_is][out] */ FORMATETC       *rgelt,
                                 /* [out] */                                     ULONG           *pceltFetched)
{
    ASSERT(rgelt);

    if (celt != 1)
        return E_FAIL;

    if (m_dwIndex > 0)
        return S_FALSE;

    if (pceltFetched)
        *pceltFetched = 1;

    if (rgelt)
    {
        rgelt->cfFormat = CF_UNICODETEXT;
        rgelt->dwAspect = DVASPECT_CONTENT;
        rgelt->tymed = TYMED_HGLOBAL;
    }
    else
        return E_INVALIDARG;

    m_dwIndex++;

    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\lib\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    sources.inc.

!ENDIF

TARGETNAME=     SnapinBase
TARGETPATH=     obj
TARGETTYPE=     LIBRARY

UMTYPE    =     windows

WIN32_WINNT_VERSION=0x0400
WIN32_IE_VERSION=0x0500
SUBSYSTEM_VERSION=4.00

SYNCHRONIZE_BLOCK = 1
USE_NATIVE_EH     = 1
USE_STATIC_ATL    = 1
USE_CRTDLL        = 1
ATL_VER           = 30
USE_RTTI          = 1
USE_WTL           = 1

# Use LINKLIBS (gets passed first) if: (from build.hlp)
#  You are building a dynamic link.
#  You are exporting something that's defined in some other component library that you also build.
#  In your dirs file in the subdirectory above, you have ordered it so that the component libraries
#     are around before you build the dynamic link.
#LINKLIBS=\
#           $(SDK_LIB_PATH)\mmc.lib            \
#           ..\..\..\core\$(CharWidth)\$(O)\uicore.lib \
#           ..\..\..\base\$(CharWidth)\$(O)\mmcbase.lib


INCLUDES=\
        ..\; \
        ..\..\inc; \
        ..\..\..\..\inc; \
		..\..\..\..\types\idl\$(O); \
        $(SDK_INC_PATH);\



SOURCES=\
        ..\basesnap.cxx         \
        ..\component.cxx        \
        ..\componentdata.cxx    \
        ..\dataobject.cxx       \
        ..\snapinabout.cxx      \
        ..\snapinitem.cxx       \
        ..\headers.cxx          \
        ..\snaptrace.cxx        \
        ..\baseatl.cxx          \
        ..\basewin.cxx          \
        ..\viewlist.cxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\lib\snapinitem.cxx ===
/*
 *      snapinitem.cxx
 *
 *
 *      Copyright (c) 1998-1999 Microsoft Corporation
 *
 *      PURPOSE:        Defines the CSnapinItem class.
 *
 *
 *      OWNER:          ptousig
 */
#include <headers.hxx>
#include <atlhost.h>

// class CBaseSnapinItem
// -----------------------------------------------------------------------------
CBaseSnapinItem::CBaseSnapinItem()
{
    Trace(tagBaseSnapinItemTracker, _T("0x%08lX: %S: Creation"), this, SzGetSnapinItemClassName());

    m_type                                                  = CCT_UNINITIALIZED;
    m_hscopeitem                                    = 0;
    m_pComponentData                                = NULL;
    m_pitemParent                                   = NULL;
    m_pitemNext                                             = NULL;
    m_pitemPrevious                                 = NULL;
    m_pitemChild                                    = NULL;
    m_fInserted                                             = FALSE;
    m_fIsRoot                                               = FALSE;
    m_fIsGhostRoot                                  = FALSE;
    m_fWasExpanded                                  = FALSE;
}

// -----------------------------------------------------------------------------
// Cleans up the subtree below the item.
//
CBaseSnapinItem::~CBaseSnapinItem()
{
    // Declarations
    SC      sc = S_OK;

    // Do not do anything below if the object is a multiselect data object.
    // We can not call FIsMultiSelectDataObject(). Use another criteria.
    // $REVIEW (dominicp) Is it possible to have a type set to CCT_UNINITIALIZED and not be a multiselect snapin item?
    if (CCT_UNINITIALIZED != m_type)
    {
        Trace(tagBaseSnapinItemTracker, _T("0x%08lX: %S: Destroyed"), this, SzGetSnapinItemClassName());

        sc = ScDeleteSubTree(FALSE);
        if (sc)
            goto Error;

        // Remove the item from the tree.
        Unlink();

        // The Pcookielist is in CBaseSnapin.
        if (Psnapin())
        {
            // Root nodes do not addref the frame and so should not release them.
            if (FIsRoot() == FALSE)
            {
                // Remove the cookie from the list of available cookies.
                Pcookielist()->erase(Cookie());
            }
        }
    }

Cleanup:
    return;
Error:
    sc.Throw ();
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Set the HSCOPEITEM of this node.
//
void CBaseSnapinItem::SetHscopeitem(HSCOPEITEM hscopeitem)
{
    // If we already have a HSCOPEITEM, we don't want it to change.
    ASSERT(m_hscopeitem == 0 || hscopeitem == 0 || m_hscopeitem == hscopeitem);
    m_hscopeitem = hscopeitem;
}

// -----------------------------------------------------------------------------
// This is the CCF_DISPLAY_NAME clipboard format.
//
SC CBaseSnapinItem::ScWriteDisplayName(IStream *pstream)
{
    SC      sc = S_OK;

    ASSERT(PstrDisplayName());

    sc = pstream->Write(PstrDisplayName()->data(), (PstrDisplayName()->length()+1)*sizeof(TCHAR), NULL);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapinItem::ScWriteDisplayName"), sc);
    goto Cleanup;
}

SC CBaseSnapinItem::ScWriteAnsiName(IStream *pStream )
{
    SC      sc = S_OK;

    ASSERT(PstrDisplayName());

    USES_CONVERSION;
    sc = pStream->Write( T2A(PstrDisplayName()->data()), (PstrDisplayName()->length()+1), NULL);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapinItem::ScWriteAnsiName"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Write the Node type's GUID out to a stream in CLSID form.
// This is the CCF_NODETYPE clipboard format.
//
SC CBaseSnapinItem::ScWriteNodeType(IStream *pstream)
{
    return pstream->Write(Pnodetype()->PclsidNodeType(), sizeof(CLSID), NULL);
}

// -----------------------------------------------------------------------------
// Write a unique ID to represent this node. This implementation uses the 'this'
// pointer. A SNodeID is simply a blob prefixed by its length (as a DWORD).
//
SC CBaseSnapinItem::ScWriteNodeID(IStream *pstream)
{
    SC              sc = S_OK;
    CBaseSnapinItem *pitemThis = this;
    DWORD   dwSize = sizeof(pitemThis);

    // Write the size of the data
    sc = pstream->Write(&dwSize, sizeof(dwSize), NULL);
    if (sc)
        goto Error;

    // Write the data itself.
    sc = pstream->Write(&pitemThis, sizeof(pitemThis), NULL);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapinItem::ScWriteNodeID"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Write the Node type's Column Set ID.  We use the node guid
// as a default implementation.
//
SC CBaseSnapinItem::ScWriteColumnSetId(IStream *pstream)
{
    SC              sc              = S_OK;
    DWORD   dwFlags = 0;
    DWORD   dwSize  = sizeof(GUID);

    // write out an MMC  SColumnSetID structure
    sc = pstream->Write(&dwFlags, sizeof(dwFlags), NULL);
    if (sc)
        goto Error;

    sc = pstream->Write(&dwSize, sizeof(dwSize), NULL);
    if (sc)
        goto Error;

    sc = pstream->Write(Pnodetype()->PclsidNodeType(), sizeof(GUID), NULL);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapinItem::ScWriteColumnSetId"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Write the HSCOPEITEM of this node out to a stream.
// This is the CF_EXCHANGE_ADMIN_HSCOPEITEM clipboard format.
//
SC CBaseSnapinItem::ScWriteAdminHscopeitem(IStream *pstream)
{
    return pstream->Write(&m_hscopeitem, sizeof(m_hscopeitem), NULL);
}

// -----------------------------------------------------------------------------
// Write the class ID of the Snapin out to a stream.
// This is the CCF_SNAPIN_CLASSID clipboard format.
//
SC CBaseSnapinItem::ScWriteClsid(IStream *pstream)
{
    return pstream->Write(PclsidSnapin(), sizeof(CLSID), NULL);
}

// -----------------------------------------------------------------------------
// Returns the snapin to which this item belongs.
//
CBaseSnapin *CBaseSnapinItem::Psnapin(void)
{
    return m_pSnapin;
}

// -----------------------------------------------------------------------------
// Get an IConsole interface.
// It is possible that this item is not associated with a ComponentData. We
// cannot ASSERT in this case, because in many situations we don't mind if it's NULL.
// Without an ASSERT, the worst that will happen is that you will hit an AV
// (which would happen in retail builds anyway) and that is as easy to debug as
// an ASSERT.
//
IConsole *CBaseSnapinItem::IpConsole(void)
{
    if (m_pComponentData)
        return m_pComponentData->IpConsole();
    else
        return NULL;
}

// -----------------------------------------------------------------------------
// Get an IPropertySheetProvider interface.
//
IPropertySheetProvider *CBaseSnapinItem::IpPropertySheetProvider(void)
{
    ASSERT(m_pComponentData);
    return m_pComponentData->IpPropertySheetProvider();
}

// -----------------------------------------------------------------------------
// Get the CComponentData that is associated with this node.
//
CComponentData *CBaseSnapinItem::PComponentData(void)
{
    ASSERT(m_pComponentData);
    return m_pComponentData;
}

// -----------------------------------------------------------------------------
// Set the given CComponentData as the "owner" of this node.
//
void CBaseSnapinItem::SetComponentData(CComponentData *pComponentData)
{
    if (pComponentData == NULL)
    {
        // We are being told to forget our owner
        m_pComponentData = NULL;
    }
    else if (pComponentData->FIsRealComponentData())
    {
        // Once the "real" owner is set, it shouldn't be changed.
        ASSERT(m_pComponentData == NULL || m_pComponentData == pComponentData);
        m_pComponentData = pComponentData;
    }
}

// -----------------------------------------------------------------------------
// Is the given item one of the children of this node.
//
BOOL CBaseSnapinItem::FIncludesChild(CBaseSnapinItem *pitem)
{
    CBaseSnapinItem *pitemIter = PitemChild();
    while (pitemIter)
    {
        if (pitemIter == pitem)
            return TRUE;
        pitemIter = pitemIter->PitemNext();
    }
    return FALSE;
}

// -----------------------------------------------------------------------------
// Add a child to this node.
//
SC CBaseSnapinItem::ScAddChild(CBaseSnapinItem *pitem)
{
    SC sc = S_OK;
    CBaseSnapinItem *pitemPrevious = NULL;

    pitemPrevious = PitemChild();
    if (pitemPrevious)
    {
        while (pitemPrevious->PitemNext())
            pitemPrevious = pitemPrevious->PitemNext();
        pitemPrevious->SetNext(pitem);
        pitem->m_pitemParent = this;
        // Successfully inserted.
    }
    else
    {
        // First child item
        SetChild(pitem);
    }

    return sc;
}

// -----------------------------------------------------------------------------
// This node will be used to represent another node (aka Ghost root node).
// We don't own the other node, it might not even be from this DLL, the only
// information we can get about this other node has to come from clipboard
// data from the provided 'lpDataObject'.
//
SC CBaseSnapinItem::ScInitializeNamespaceExtension(LPDATAOBJECT lpDataObject, HSCOPEITEM item, CNodeType *pnodetype)
{
    return S_OK;
}

// -----------------------------------------------------------------------------
// Called to ask this node to create its children.
//
SC CBaseSnapinItem::ScCreateChildren(void)
{
    return S_OK;
}

// -----------------------------------------------------------------------------
// Removes an item from the linked list. Links up the previous and next items,
// if any. If this is the first item in the list, set the parent's child pointer
// to the next item (if it exists.)
//
void CBaseSnapinItem::Unlink()
{
    // Make sure that this item has no children. Wouldn't know what to do with them.
    ASSERT(PitemChild() == NULL);

    // A real clear way of checking all cases: 8 in all.
    if (PitemPrevious())
    {
        if (PitemParent())
        {
            if (PitemNext())                                                         // PitemPrevious() && PitemParent() && PitemNext()
                PitemPrevious()->SetNext(PitemNext());
            else                                                                            // PitemPrevious() && PitemParent() && !PitemNext()
                PitemPrevious()->SetNext(NULL);
        }
        else                                                                                    // !PitemParent()
        {
            if (PitemNext())                                                         // PitemPrevious() && !PitemParent() && PitemNext()
                PitemPrevious()->SetNext(PitemNext());
            else                                                                            // PitemPrevious() && !PitemParent() && !PitemNext()
                PitemPrevious()->SetNext(NULL);
        }
    }
    else                                                                                            // !PitemPrevious()     - this is the first item in the list.
    {
        if (PitemParent())
        {
            if (PitemNext())                                                         // !PitemPrevious() && PitemParent() && PitemNext()
            {
                PitemParent()->SetChild(PitemNext());
                PitemNext()->SetPrevious(NULL);
            }
            else                                                                            // !PitemPrevious() && PitemParent() && !PitemNext()
            {
                // Set the Parent's Child pointer to NULL if we are the (only) child of the parent.
                if (PitemParent()->PitemChild() == static_cast<CBaseSnapinItem*>(this))
                    PitemParent()->SetChild(NULL);
            }
        }
        else                                                                                    // !PitemParent()
        {
            if (PitemNext())                                                         // !PitemPrevious() && !PitemParent() && PitemNext()
                PitemNext()->SetPrevious(NULL);
            else                                                                            // !PitemPrevious() && !PitemParent() && !PitemNext()
                ;                                                                               // do nothing - already an orphan.
        }
    }

    // Clear all the link pointers.
    SetNext(NULL);
    SetPrevious(NULL);
    // Can't use SetParent() because it ASSERTs.
    m_pitemParent = NULL;
}

// -----------------------------------------------------------------------------
// Initializes the snapinitem.
//
// The 'pcolinfoex' and 'ccolinfoex' are no longer used. The derived class is
// now responsible for maintaining per-item column information. The default
// implementation of the accessors will get the column information from the
// CBaseSnapin-derived class.
//
SC CBaseSnapinItem::ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex, INT ccolinfoex, BOOL fIsRoot)
{
    SC      sc                      = S_OK;
    m_pSnapin               = pSnapin;
    m_fIsRoot               = fIsRoot;
    // Add the cookie to the list of available cookies.
    pSnapin->Pcookielist()->insert(Cookie());

    return sc;
}

// -----------------------------------------------------------------------------
// Initializes a child item.
//
SC CBaseSnapinItem::ScInitializeChild(CBaseSnapinItem* pitem)
{
    return pitem->ScInit(Psnapin(), NULL, 0);
}


// -----------------------------------------------------------------------------
// Information obtained from Psnapin().
//
const tstring&  CBaseSnapinItem::StrClassName(void)             { return Psnapin()->StrClassName();}
const CLSID *   CBaseSnapinItem::PclsidSnapin(void)             { return Psnapin()->PclsidSnapin();}
const tstring&  CBaseSnapinItem::StrClsidSnapin(void)           { return Psnapin()->StrClsidSnapin();}
WTL::CBitmap*   CBaseSnapinItem::PbitmapImageListSmall(void)    { return Psnapin()->PbitmapImageListSmall();}
WTL::CBitmap*   CBaseSnapinItem::PbitmapImageListLarge(void)    { return Psnapin()->PbitmapImageListLarge();}
CCookieList *   CBaseSnapinItem::Pcookielist(void)              { return Psnapin()->Pcookielist();}

// -----------------------------------------------------------------------------
// Deletes the entire subtree rooted at this node, thereby freeing up all the cookies.
// If fDeleteRoot is TRUE we need to delete the root node as well.
//
SC CBaseSnapinItem::ScDeleteSubTree(BOOL fDeleteRoot)
{
    SC                                      sc                      = S_OK;
    CBaseSnapinItem *       pitem           = PitemChild();
    CBaseSnapinItem *       pitemNext       = NULL;

    while (pitem)
    {
        // We are about to delete 'pitem', keep a pointer to the next one.
        pitemNext = pitem->PitemNext();

        // Delete the entire subtree including the root node.
        sc = pitem->ScDeleteSubTree(TRUE);
        if (sc)
            goto Error;

        pitem = pitemNext;
    }

    // We don't have any children left.
    m_pitemChild = NULL;
    m_fWasExpanded = FALSE;

    // if we have not removed the scope item, do it now

    if (fDeleteRoot)
    {
        if (m_hscopeitem)
        {
            sc = PComponentData()->IpConsoleNameSpace()->DeleteItem(m_hscopeitem, TRUE);
            if (sc)
                goto Error;
        }

        Unlink();
        // Since we are no longer known by MMC we have to forget our HSCOPEITEM
        // so that it doesn't get mis-used. This can happen if you refresh a parent
        // of a node that has properties open.
        m_hscopeitem = 0;
        static_cast<IDataObject *>(this)->Release();
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapinItem::ScDeleteSubTree"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Get the root of this item tree.
//
CBaseSnapinItem *CBaseSnapinItem::PitemRoot(void)
{
    if (m_pitemParent)
        return m_pitemParent->PitemRoot();
    else
        return this;
}

// -----------------------------------------------------------------------------
// We are the data object. We just return a pointer to the IDataObject of
// ourselves.
//
SC CBaseSnapinItem::ScQueryDataObject(long cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
    SC sc = S_OK;

    //
    // The item will remember what type it is at the moment.
    //
    m_type = type;

    //
    // This seems like a very twisted way of getting a pointer to ourselves,
    // but it is actualy because we want to make sure we play within ATL rules.
    // In a way, QueryDataObject is the same thing as a QueryInterface.
    //
    sc = static_cast<IDataObject *>(this)->QueryInterface(IID_IDataObject, reinterpret_cast<void**>(ppDataObject));
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapinItem::ScQueryDataObject"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Handles the MMCN_SHOW notification. Initializes the default result view headers.
//
SC CBaseSnapinItem::ScOnShow(CComponent *pComponent, BOOL fSelect)
{
    SC sc = S_OK;

    ASSERT(pComponent);

    if (fSelect)
    {
        sc = ScInitializeResultView(pComponent);
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapinItem::ScOnShow"), sc);
    goto Cleanup;

}

// -----------------------------------------------------------------------------
// Called during the  MMCN_EXPAND notification sent to IComponentData::Notify. Inserts
// the current item into the scope pane (if it is a container item) using IConsoleNameSpace
// methods. If fExpand is FALSE, don't do anything.
// Chains all sibling items.
//
SC CBaseSnapinItem::ScInsertScopeItem(CComponentData *pComponentData, BOOL fExpand, HSCOPEITEM item)
{
    SC                                      sc              = S_OK;
    CBaseSnapinItem*        pitem   = this;
    SCOPEDATAITEM           scopedataitem;

    if (fExpand == FALSE)
        goto Cleanup;

    while (pitem)
    {
        // Only add container items.
        if (pitem->FIsContainer())
        {
            pitem->SetComponentData(pComponentData);

            ZeroMemory(&scopedataitem, sizeof(SCOPEDATAITEM));
            scopedataitem.lParam            = pitem->Cookie();
            scopedataitem.mask              = SDI_STR | SDI_PARAM | SDI_PARENT | SDI_CHILDREN;
            if (pitem->Iconid() != iconNil)
                scopedataitem.mask |= SDI_IMAGE;
            if (pitem->OpenIconid() != iconNil)
                scopedataitem.mask |= SDI_OPENIMAGE;

            // Callback for the display name.
            // $REVIEW (ptousig) Why don't we take advantage of the displayname ?
            //                                       Callbacks can be pretty inefficient.

            scopedataitem.displayname       = MMC_CALLBACK;
            scopedataitem.nImage            = pitem->Iconid();
            scopedataitem.nOpenImage        = pitem->OpenIconid();
            scopedataitem.relativeID        = item;
            // If there are no children, MMC will suppress the "+" sign
            scopedataitem.cChildren         = pitem->FHasChildren() ? 1 : 0;

            ASSERT(pComponentData);
            sc = pComponentData->IpConsoleNameSpace()->InsertItem(&scopedataitem);
            if (sc)
                goto Error;

            pitem->SetHscopeitem(scopedataitem.ID);
        }

        pitem = pitem->PitemNext();
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapinItem::ScInsertScopeItem"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Inserts all child items into the default result list view.
//
SC CBaseSnapinItem::ScInsertResultItem(CComponent *pComponent)
{
    SC                              sc = S_OK;
    RESULTDATAITEM  resultdataitem;

    ASSERT(pComponent && pComponent->IpResultData());

    // Add this item
    ZeroMemory(&resultdataitem, sizeof(resultdataitem));

    resultdataitem.lParam   = Cookie();
    resultdataitem.mask             = RDI_STR | RDI_PARAM | RDI_IMAGE;
    // Callback for the display name.
    resultdataitem.str              = MMC_CALLBACK;
    // Custom icon
    resultdataitem.nImage   = (int) MMC_CALLBACK;

    sc = pComponent->IpResultData()->InsertItem(&resultdataitem);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapinItem::ScInsertResultItem"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Asks MMC to update the display of this item in the result pane.
//
SC CBaseSnapinItem::ScUpdateResultItem(IResultData *ipResultData)
{
    DECLARE_SC(sc, _T("CBaseSnapinItem::ScUpdateResultItem"));
    HRESULTITEM             item    = NULL;

    ASSERT(ipResultData);
    sc = ipResultData->FindItemByLParam(Cookie(), &item);
    if (sc)
        return (sc);

    // If not found, does not exist in this view. Ignore.
    if (!item)
        return (sc);

    // $REVIEW (ptousig) Why are we ignoring errors ?
    ipResultData->UpdateItem(item);

    return sc;
}

// -----------------------------------------------------------------------------
// Asks MMC to update the display of this item in the scope pane.
//
SC CBaseSnapinItem::ScUpdateScopeItem(IConsoleNameSpace *ipConsoleNameSpace)
{
    SC                              sc              = S_OK;
    SCOPEDATAITEM   scopedataitem;

    ASSERT(FIsContainer());

    //
    // If this item doesn't have a HSCOPEITEM, then it is not known by MMC
    // therefore we would get an "invalid arg" error from the call to SetItem.
    //
    if (Hscopeitem() == 0)
        goto Cleanup;

    ZeroMemory(&scopedataitem, sizeof(SCOPEDATAITEM));
    scopedataitem.ID                        = Hscopeitem();
    scopedataitem.lParam            = Cookie();
    scopedataitem.mask                      = SDI_PARAM;

    if (Iconid() != iconNil)
    {
        scopedataitem.mask              |= SDI_IMAGE;
        ASSERT(FALSE && "Bitmap");
        //scopedataitem.nImage    = PbitmapImageListSmall()->GetIndex(Iconid());
    }

    if (OpenIconid() != iconNil)
    {
        scopedataitem.mask                      |= SDI_OPENIMAGE;
        ASSERT(FALSE && "Bitmap");
        //scopedataitem.nOpenImage        = PbitmapImageListSmall()->GetIndex(OpenIconid());
    }

    ASSERT(ipConsoleNameSpace);
    sc = ipConsoleNameSpace->SetItem(&scopedataitem);
    if (sc)
        goto Error;

    // Send a notification to update the result pane description bar.
    IpConsole()->UpdateAllViews(Pdataobject(), 0, ONVIEWCHANGE_UPDATEDESCRIPTIONBAR);

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapinItem::ScUpdateScopeItem"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// This is where we should tell MMC to remove all the items in the result pane.
//
// $REVIEW (ptousig) Why aren't we doing anything ?
//
SC CBaseSnapinItem::ScRemoveResultItems(LPRESULTDATA ipResultData)
{
    return S_OK;
}


// -----------------------------------------------------------------------------
// Provides (to MMC) the display string (or icon) for a given node in the
// scope pane.
//
SC CBaseSnapinItem::ScGetDisplayInfo(LPSCOPEDATAITEM pScopeItem)
{
    SC sc = S_OK;

#ifdef _DEBUG
    static tstring str;
#endif

    ASSERT(pScopeItem);

    if (pScopeItem->mask & SDI_STR)
    {
        pScopeItem->displayname = (LPTSTR)PstrDisplayName()->data();
#ifdef _DEBUG
        if (tagBaseSnapinDebugDisplay.FAny())
        {
            USES_CONVERSION;
            str  = OLE2T(pScopeItem->displayname);
            str += A2T(SzGetSnapinItemClassName());
//            str += this;
//            str += Hscopeitem();
            pScopeItem->displayname = T2OLE((LPTSTR)str.data());
        }
#endif
    }

    if (pScopeItem->mask & SDI_IMAGE)
    {
        ASSERT(FALSE && "Bitmap");
        //pScopeItem->nImage = PbitmapImageListSmall()->GetIndex(Iconid());
    }

    return sc;
}

// -----------------------------------------------------------------------------
// Provides (to MMC) the display string (or icon) for a given node in the
// result pane.
//
SC CBaseSnapinItem::ScGetDisplayInfo(LPRESULTDATAITEM pResultItem)
{
    DECLARE_SC(sc, _T("CBaseSnapinItem::ScGetDisplayInfo"));
    static  tstring s_sz;

    ASSERT(pResultItem);

    if (pResultItem->mask & RDI_STR)
    {
        // Need to do this explicitly because the same buffer is reused.
        pResultItem->str = (LPTSTR)s_sz.data();

        // "Old" snapins might be referring to columns that don't exist.
        if (pResultItem->nCol < CcolinfoexDisplay())
        {
            Trace(tagBaseSnapinItemTracker, _T("Requesting field data - requested DAT is %d"), PcolinfoexDisplay(pResultItem->nCol)->Dat());
            sc= ScGetField( PcolinfoexDisplay(pResultItem->nCol)->Dat(), s_sz);
            if (sc)
                return sc;


#ifdef _DEBUG
            if (pResultItem->nCol == 0 && tagBaseSnapinDebugDisplay.FAny())
            {
                s_sz  = pResultItem->str;
//                s_sz += this;
            }
#endif

            USES_CONVERSION;
            pResultItem->str = T2OLE((LPTSTR)s_sz.data());
        }
    }

    if (pResultItem->mask & RDI_IMAGE)       // $REVIEW for extension snapins.
    {
        pResultItem->nImage = Iconid();
    }

    return sc;
}

// -----------------------------------------------------------------------------
// Fills in result pane item information needed by MMC.  This
// method is used when the results pane is in virtual list mode
// and we will be asking for data by index.
//
SC CBaseSnapinItem::ScGetVirtualDisplayInfo(LPRESULTDATAITEM pResultItem, IResultData *ipResultData)
{
    DECLARE_SC(sc, _T("CBaseSnapinItem::ScGetDisplayInfo"));
    static  tstring s_sz; //$REVIEW

    ASSERT(FVirtualResultsPane() && pResultItem);

    if (pResultItem->mask & RDI_STR)
    {
        sc= ScGetField(pResultItem->nIndex, PcolinfoexDisplay(pResultItem->nCol)->Dat(), s_sz, ipResultData);
        if (sc)
            return sc;
        pResultItem->str = (LPTSTR)s_sz.data();
    }

    if (pResultItem->mask & RDI_IMAGE)       // $REVIEW for extension snapins.
    {
        pResultItem->nImage = Iconid();
    }

    return sc;
}

// -----------------------------------------------------------------------------
// Returns the default icon ID : Folder
//
LONG CBaseSnapinItem::Iconid(void)
{
    ASSERT(FALSE);
    return 0;
}

// -----------------------------------------------------------------------------
// Returns the default open icon ID : Handles open folder / open RO folder / custom
//
LONG CBaseSnapinItem::OpenIconid(void)
{
    ASSERT(FALSE);
    return 0;
}

// -----------------------------------------------------------------------------
// Initializes the result view. This implementation requires a column info
// structure, and creates the default set of columns.
//
SC CBaseSnapinItem::ScInitializeResultView(CComponent *pComponent)
{
    SC              sc = S_OK;
    INT             i  = 0;

    ASSERT(pComponent && pComponent->IpHeaderCtrl());

    // Remove any old column headers (on refresh / view change)
    while (!sc)
        sc = pComponent->IpHeaderCtrl()->DeleteColumn(0);
    sc = S_OK;

    for (i = 0; i < CcolinfoexHeaders(); i++)
    {
        Trace(tagBaseSnapinItemTracker, _T("Inserting column with title %s"), PcolinfoexHeaders(i)->strTitle().data());
        sc = pComponent->IpHeaderCtrl()->InsertColumn(i,
                                                      PcolinfoexHeaders(i)->strTitle().data(),
                                                      PcolinfoexHeaders(i)->NFormat(),
                                                      PcolinfoexHeaders(i)->NWidth());
        // Will get fail if items are already in result pane.  This is not an error, happens on refresh.
        // $REVIEW (ptousig) Maybe we should remove the items before re-initializing the columns.
        if (sc.ToHr() == E_FAIL)
            sc = S_OK;

        if (sc)
            goto Error;
    }
    // remove the NOSORTHEADER option - by default all items will have push-button header controls
    sc = pComponent->IpResultData()->ModifyViewStyle((MMC_RESULT_VIEW_STYLE)0, MMC_NOSORTHEADER);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapinItem::ScInitializeResultView"), sc);
    goto Cleanup;

}

// -----------------------------------------------------------------------------
// MMC wants to know the image strip that should be used for the result pane.
//
SC CBaseSnapinItem::ScOnAddImages(IImageList* ipResultImageList)
{
    SC              sc = S_OK;

    ASSERT(ipResultImageList);

    sc = ipResultImageList->ImageListSetStrip(
        reinterpret_cast<long*>(static_cast<HBITMAP>(*PbitmapImageListSmall())),
        reinterpret_cast<long*>(static_cast<HBITMAP>(*PbitmapImageListLarge())),
        0, RGB(255, 0, 255));
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapinItem::ScOnAddImages"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Cause this node to refresh itself.
//
// WARNING: The "flicker" effect of this call is very annoying to look at. Do
//                      not use this as a "silver bullet" solution. If you are adding,
//                      removing or updating a child then use the appropriate ONVIEWCHANGE_*
//                      notification.
//
SC CBaseSnapinItem::ScRefreshNode(void)
{
    SC sc = S_OK;

    sc = IpConsole()->UpdateAllViews(this, 0, ONVIEWCHANGE_REFRESHCHILDREN);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapinItem::ScRefreshNode"), sc);
    goto Cleanup;
}


// -----------------------------------------------------------------------------
// MMC is asking us the type of result pane we want
//
SC CBaseSnapinItem::ScGetResultViewType(LPOLESTR *ppViewType, long *pViewOptions)
{
    DECLARE_SC(sc, TEXT("CBaseSnapinItem::ScGetResultViewType"));
    // Validate parameters
    ASSERT(ppViewType);
    ASSERT(pViewOptions);

    if ( FResultPaneIsOCX())
    {
        tstring strclsidOCX;
        sc = ScGetOCXCLSID(strclsidOCX);
        if (sc == S_FALSE) // default to listview.
            return sc;

        *ppViewType = (LPOLESTR)CoTaskMemAlloc( (strclsidOCX.length()+1) * sizeof(WCHAR));

        USES_CONVERSION;
        wcscpy(*ppViewType, T2COLE(strclsidOCX.data()));

        return sc;
    }

    if (FResultPaneIsWeb())
    {
        tstring strURL;
        sc = ScGetWebURL(strURL);
        if (sc == S_FALSE) // default to listview.
            return sc;

        *ppViewType = (LPOLESTR)CoTaskMemAlloc( (strURL.length()+1) * sizeof(WCHAR));

        USES_CONVERSION;
        wcscpy(*ppViewType, T2COLE(strURL.data()));

        return sc;
    }

    // Set the default
    *pViewOptions = MMC_VIEW_OPTIONS_NONE;

    // Check if we are displaying a virtual result pane list
    if (FVirtualResultsPane())
        // Ask for owner data listview (virtual list box mode).
        *pViewOptions = MMC_VIEW_OPTIONS_OWNERDATALIST;

    // Check if we should enable multiselect
    if (FAllowMultiSelectionForChildren())
        *pViewOptions = *pViewOptions | MMC_VIEW_OPTIONS_MULTISELECT;

    //
    // Return S_FALSE to indicate we want the standard result view.
    //
    return S_FALSE;
}

// -----------------------------------------------------------------------------
// MMC is asking us the type of result pane we want using IComponent2
//
SC CBaseSnapinItem::ScGetResultViewType2(IConsole *pConsole, PRESULT_VIEW_TYPE_INFO pResultViewType)
{
    DECLARE_SC(sc, _T("CBaseSnapinItem::ScGetResultViewType2"));

    // Validate parameters
    ASSERT(pResultViewType);
    ASSERT(PstrDisplayName());

    LPOLESTR pszViewDesc = (LPOLESTR)CoTaskMemAlloc((PstrDisplayName()->length()+1) * sizeof(WCHAR));
    if (! pszViewDesc)
        return (sc = E_OUTOFMEMORY);

    USES_CONVERSION;
    wcscpy(pszViewDesc, T2COLE(PstrDisplayName()->data()));
    pResultViewType->pstrPersistableViewDescription = pszViewDesc;

    if ( FResultPaneIsOCX())
    {
        tstring strclsidOCX;
        sc = ScGetOCXCLSID(strclsidOCX);
        if (sc == S_FALSE) // default to listview.
            return sc;

        pResultViewType->eViewType = MMC_VIEW_TYPE_OCX;
        pResultViewType->dwOCXOptions = RVTI_OCX_OPTIONS_NOLISTVIEW;

        pResultViewType->pUnkControl = NULL;

        if (FCacheOCX())
        {
            pResultViewType->dwOCXOptions = RVTI_OCX_OPTIONS_CACHE_OCX;
            pResultViewType->pUnkControl = GetCachedOCX(pConsole);
        }

        CComQIPtr<IConsole2> spConsole2(pConsole);

        if (! pResultViewType->pUnkControl)
        {
            CLSID clsidOCX;

            USES_CONVERSION;
            sc = CLSIDFromString(T2OLE(const_cast<LPTSTR>(strclsidOCX.data())), &clsidOCX);
            if (sc)
                return sc;

            LPUNKNOWN pUnkControl = NULL;
            sc = CoCreateInstance(clsidOCX, NULL, CLSCTX_SERVER, IID_IUnknown, (LPVOID*)&pUnkControl);
            if (sc)
                return sc;

            sc = ScInitOCX(pUnkControl, pConsole);

            pResultViewType->pUnkControl = pUnkControl;

            if (spConsole2)
            {
                tstring strStatusText = L"OCX: ";
                strStatusText += strclsidOCX;
                strStatusText += L" Created";
                spConsole2->SetStatusText(const_cast<LPOLESTR>(T2COLE(strStatusText.data())));
            }
        }
        else
        {
            pResultViewType->pUnkControl->AddRef();
            if (spConsole2)
            {
                tstring strStatusText = L"OCX: ";
                strStatusText += strclsidOCX;
                strStatusText += L" cached is used";
                spConsole2->SetStatusText(const_cast<LPOLESTR>(T2COLE(strStatusText.data())));
            }
        }

        return sc;
    }

    if (FResultPaneIsWeb())
    {
        tstring strURL = TEXT("msw");
        sc = ScGetWebURL(strURL);
        if (sc == S_FALSE) // default to listview.
            return sc;

        pResultViewType->eViewType = MMC_VIEW_TYPE_HTML;
        pResultViewType->dwHTMLOptions = RVTI_HTML_OPTIONS_NONE | RVTI_HTML_OPTIONS_NOLISTVIEW;
        LPOLESTR lpszURL = (LPOLESTR)CoTaskMemAlloc( (strURL.length()+1) * sizeof(WCHAR));

        USES_CONVERSION;
        wcscpy(lpszURL, T2COLE(strURL.data()));

        pResultViewType->pstrURL = lpszURL;

        return sc;
    }

    // Set the default
    pResultViewType->dwMiscOptions = RVTI_LIST_OPTIONS_NONE;

    // Check if we are displaying a virtual result pane list
    if (FVirtualResultsPane())
        // Ask for owner data listview (virtual list box mode).
        pResultViewType->dwListOptions = RVTI_LIST_OPTIONS_OWNERDATALIST;

    // Check if we should enable multiselect
    if (FAllowMultiSelectionForChildren())
        pResultViewType->dwListOptions |= RVTI_LIST_OPTIONS_MULTISELECT;

    if (FAllowPasteForResultItems())
        pResultViewType->dwListOptions |= RVTI_LIST_OPTIONS_ALLOWPASTE;

    //
    // Return S_FALSE to indicate we want the standard result view.
    //
    return S_FALSE;
}

// -----------------------------------------------------------------------------
// MMC is trying to restore the view, see if it is our view description.
//
SC CBaseSnapinItem::ScRestoreResultView(PRESULT_VIEW_TYPE_INFO pResultViewType)
{
    DECLARE_SC(sc, _T("CBaseSnapinItem::ScRestoreResultView"));

    // Validate parameters
    ASSERT(pResultViewType);
    ASSERT(pResultViewType->pstrPersistableViewDescription);
    ASSERT(PstrDisplayName());

    LPOLESTR pszViewDesc = pResultViewType->pstrPersistableViewDescription;
    if (! pszViewDesc)
        return (sc = E_OUTOFMEMORY);

    USES_CONVERSION;
    if ( 0 != wcscmp(pszViewDesc, T2COLE(PstrDisplayName()->data())) )
        return (sc = S_FALSE);

    if (! pResultViewType->dwMiscOptions & RVTI_LIST_OPTIONS_NONE)
        return (sc = S_FALSE);

    // Check if we are displaying a virtual result pane list
    if (FVirtualResultsPane())
    {
        if (! (pResultViewType->dwListOptions & RVTI_LIST_OPTIONS_OWNERDATALIST))
            return (sc = S_FALSE);
    }

    // Check if we should enable multiselect
    if (FAllowMultiSelectionForChildren())
    {
        if (! (pResultViewType->dwListOptions & RVTI_LIST_OPTIONS_MULTISELECT) )
            return (sc = S_FALSE);
    }

    // Check if result pane items allow paste.
    if (FAllowPasteForResultItems())
    {
        if (! (pResultViewType->dwListOptions & RVTI_LIST_OPTIONS_ALLOWPASTE) )
            return (sc = S_FALSE);
    }

    return S_OK;
}

// -----------------------------------------------------------------------------
// Used to create a property sheet for an item. This uses MMC trickery to
// display property pages on an object that has not yet been added to the MMC
// result view.
//
SC CBaseSnapinItem::ScDisplayPropertySheet(void)
{
    SC                              sc                      = S_OK;
    IPropertySheetCallbackPtr       ipPropertySheetCallback;
    // If fCleanup == TRUE, we need to call Show(-1, 0) on an error.
    BOOL                            fCleanup        = FALSE;
    TCHAR                           strTitle[256];
    CComPtr<IUnknown>               spIUnknown;

    // Get a pointer to the IPropertySheetProvider interface.
    ipPropertySheetCallback = IpPropertySheetProvider();
    ASSERT(NULL != ipPropertySheetCallback);

    // Create the property pages for this object.
    // TRUE for property sheet, not wizard
    sc = IpPropertySheetProvider()->CreatePropertySheet(strTitle, TRUE, Cookie(), Pdataobject(), 0);
    if (sc)
        goto Error;

    // If failure occurs after a successful call to CreatePropertySheet, need to call Show(-1,0). See MMC docs.
    fCleanup = TRUE;

    sc = ((IComponentData *)PComponentData())->QueryInterface(IID_IUnknown, (void **)&spIUnknown);
    if (sc)
        goto Error;

    // Add the primary pages for the object.
    sc = IpPropertySheetProvider()->AddPrimaryPages(spIUnknown, TRUE, NULL, TRUE);
    if (sc)
        goto Error;

    //$REVIEW (ptousig) Why is this commented out ?
    //sc = IpPropertySheetProvider()->AddExtensionPages();
    if (sc)
        goto Error;

    sc = IpPropertySheetProvider()->Show((long) GetActiveWindow(), 0);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    // If failure occurs after a successful call to CreatePropertySheet, need to call Show(-1,0). See MMC docs.
    if (fCleanup)
        IpPropertySheetProvider()->Show(-1, 0);
    TraceError(_T("CBaseSnapinItem::ScDisplayPropertySheet"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
void CBaseSnapinItem::SetParent(CBaseSnapinItem *pitemParent)
{
    ASSERT(pitemParent);
    m_pitemParent = pitemParent;
}

// -----------------------------------------------------------------------------
void CBaseSnapinItem::SetNext(CBaseSnapinItem *pitemNext)
{
    m_pitemNext = pitemNext;
    if (pitemNext)
        pitemNext->m_pitemPrevious = this;
}

// -----------------------------------------------------------------------------
void CBaseSnapinItem::SetPrevious(CBaseSnapinItem *pitemPrevious)
{
    m_pitemPrevious = pitemPrevious;
    if (pitemPrevious)
        pitemPrevious->m_pitemNext = this;
}

// -----------------------------------------------------------------------------
void CBaseSnapinItem::SetChild(CBaseSnapinItem *pitemChild)
{
    m_pitemChild = pitemChild;
    if (pitemChild)
        pitemChild->m_pitemParent = this;
}

// -----------------------------------------------------------------------------
// A context menu option was selected.
//
SC CBaseSnapinItem::ScCommand(long nCommandID, CComponent *pComponent)
{
    SC sc = S_OK;

    switch (nCommandID)
    {
    case IDS_Test:
        break;
#if 0
    case idmBarfTraces:
        sc = Psnapin()->ScOnMenuTraces();
        break;

    case idmBarfClearDbgScreen:
        Trace(tagAlways, _T("\x1B[2J"));
        break;

    case idmBarfSCDescription:
        sc = Psnapin()->ScOnMenuSCDescription();
        break;

    case idmBarfSettings:
        DoBarfDialog();
        break;

    case idmBarfAll:
        BarfAll();
        break;


    case idmBarfMemoryDiff:
        sc = Psnapin()->ScOnMenuMemoryDiff();
        break;

    case idmBarfValidateMemory:
        sc = Psnapin()->ScOnMenuMemoryDiff();
        break;

    case idmBarfTotalMemAllocd:
        sc = Psnapin()->ScOnMenuTotalMemory();
        break;

    case idmBarfDebugBreak:
        DebugBreak();
        break;
#endif

    default:
        break;
    }

    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapinItem::ScCommand"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Determines whether any property pages are open on this item. As a side-effect
// if any property sheet is found, it will be given focus. MMC does that by
// itself, we don't have any way of stopping it.
// If the item is a result pane item, we must provide an IComponent to MMC, this
// is the component that will receive then CompareObjects call. In our
// implementation, we don't care which IComponent does the comparison, so pass
// in any IComponent you can get your hands on.
//
SC CBaseSnapinItem::ScIsPropertySheetOpen(BOOL *pfPagesUp, IComponent *ipComponent)
{
    SC sc = S_OK;

    ASSERT(pfPagesUp);

    *pfPagesUp = FALSE;

    if (FIsContainer())
    {
        // Scope pane nodes are owned by the MMC.
        // Note: MMC docs says first parameter is the cookie. It is in fact the HSCOPEITEM.
        sc = IpPropertySheetProvider()->FindPropertySheet(Hscopeitem(), NULL, Pdataobject());
        if (sc)
            goto Error;
    }
    else
    {
        // Result pane nodes are owned by the IComponent.
        ASSERT(ipComponent);

        sc = IpPropertySheetProvider()->FindPropertySheet(Cookie(), ipComponent, Pdataobject());
        if (sc)
            goto Error;
    }

    if (sc == S_FALSE)
        *pfPagesUp = FALSE;
    else if (sc == S_OK)
        *pfPagesUp = TRUE;

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapinItem::ScIsPropertySheetOpen"), sc);
    goto Cleanup;
}

// =============================================================================
// Class CBaseMultiSelectSnapinItem
// =============================================================================

UINT CBaseMultiSelectSnapinItem::s_cfMultiSelectSnapins         = RegisterClipboardFormat(CCF_MULTI_SELECT_SNAPINS);                    // Multiselect - list of multi select snapin items in a composite data object
UINT CBaseMultiSelectSnapinItem::s_cfCompositeDataObject        = RegisterClipboardFormat(CCF_MMC_MULTISELECT_DATAOBJECT);              // Multi select - used to determine if an object is a composite data object

// -----------------------------------------------------------------------------
// Constructor for CBaseMultiSelectSnapinItem
// -----------------------------------------------------------------------------
CBaseMultiSelectSnapinItem::CBaseMultiSelectSnapinItem() : CBaseSnapinItem()
{
    // Remember we created a multiselect snapin item
    Trace(tagBaseMultiSelectSnapinItemTracker, _T("0x%08lX: Creation"), this);

    // By default, a multiselect object is not involved in copy/paste operations
    // Set the pointer to an array indicating the pasted items to NULL
    m_pfPastedWithCut = NULL;
}

// -----------------------------------------------------------------------------
// Destructor for CBaseMultiSelectSnapinItem
// -----------------------------------------------------------------------------
CBaseMultiSelectSnapinItem::~CBaseMultiSelectSnapinItem()
{
    // Delete the array indicating the pasted items (if any was allocated)
    if (m_pfPastedWithCut)
    {
        delete [] m_pfPastedWithCut;
        m_pfPastedWithCut = NULL;
    }
}

/* CBaseMultiSelectSnapinItem::ScWriteMultiSelectionItemTypes
 *
 * PURPOSE:                     Implement the CCF_OBJECT_TYPES_IN_MULTI_SELECT clipboard format.
 *                                      The clipboard data info indicates the types of nodes selected by a multi-select operation.
 *
 * PARAMETERS:
 *                                      IStream *       pstream                 The stream to write to.
 *
 * RETURNS:
 *                                      SC                                                      Execution code.
 */
SC
CBaseMultiSelectSnapinItem::ScWriteMultiSelectionItemTypes(IStream * pstream)
{
    // Declarations
    SC                                     sc                                                                                      = S_OK;
    INT                                    nIterator                                                                       = 0;
    GUIDSet                                gsItemTypes;

    // Data validation
    ASSERT(pstream);

    // Remember we created a multiselect snapin item
    Trace(tagBaseMultiSelectSnapinItemTracker, _T("Received a request for clipboard data on node types"), this);

    // First determine how many GUIDs we have - note that the selection of snapin items was obtained for a particular component
    // Therefore the selection contains snapin items which were instanciated from the same snapin and does not include items which may have been added by other snapins
    for (nIterator=0; nIterator < PivSelectedItems()->size(); nIterator++)
    {
        // Local declarations
        LPGUID  pGuidItemType   = (LPGUID)((*PivSelectedItems())[nIterator])->Pnodetype()->PclsidNodeType();

        // Determine if the guid can be located in the guid set and if not add it
        ASSERT(pGuidItemType);
        if (gsItemTypes.find(*pGuidItemType) == gsItemTypes.end())              // means not found
            gsItemTypes.insert(*pGuidItemType);
    }

    // Write a SMMCObjectTypes data structure
    // First: number of found types
    {
        // Local declarations
        DWORD                           dwcItemTypes                                                    = 0;

        ASSERT(gsItemTypes.size() > 0);
        dwcItemTypes = gsItemTypes.size();
        sc = pstream->Write(&dwcItemTypes, sizeof(DWORD), NULL);      // need l-value
        if (sc)
            goto Error;
    }

    // Write a SMMCObjectTypes data structure
    // Second: the guids
    {
        for (GUIDSet::iterator p = gsItemTypes.begin(); p != gsItemTypes.end(); p++)
        {
            sc = pstream->Write(&p, sizeof(GUID), NULL);
            if (sc)
                goto Error;
        }
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseMultiSelectSnapinItem::ScWriteMultiSelectionItemTypes()"), sc);
    goto Cleanup;

}



/* CBaseMultiSelectSnapinItem::ScOnSelect
 *
 * PURPOSE:                     Forward a selection notification to selected items - select verbs.
 *
 * PARAMETERS:
 *                                      CComponent *            pComponent                              Pointer to the component object.
 *                                      LPDATAOBJECT            lpDataObject                    Pointer to the multiselect snapin item.
 *                                      BOOL                            fScope                                  TRUE if selection in the scope pane.
 *                                      BOOL                            fSelect                                 TRUE if selected.
 *
 * RETURNS:
 *                                      SC                                                                                      Execution code
 */
SC
CBaseMultiSelectSnapinItem::ScOnSelect(CComponent * pComponent, LPDATAOBJECT lpDataObject, BOOL fScope, BOOL fSelect)
{
    // Declarations
    SC                                                      sc                      = S_OK;
    INT                                                     nIterator       = 0;

    // Data validation
    ASSERT(pComponent);
    ASSERT(lpDataObject);

    // Forward the request to the component as if only the first snapin item had been selected (this will allow us to select verbs)
    // MMC finds will select these verbs for all selected snapin items
    ASSERT(PivSelectedItemsFirst());

    // For this call we have to go back to the component as there is some work to do at the snapin level
    // We contact only the first snapin item to select verbs
    // $REVIEW (dominicp) MMC recommends doing this. We should probably merge verbs only though. This would be smarter.
    sc = pComponent->ScOnSelect(PivSelectedItemsFirst(), fScope, fSelect);
    if (sc)
        goto Error;

    // We just let the other snapin items know they have been selected
    for (nIterator=1; nIterator < PivSelectedItems()->size(); nIterator++)          // start at index 1
    {
        // Get the next item
        ASSERT((*PivSelectedItems())[nIterator]);

        // Call ScOnSelect for each snapin item - pass pitem as an lpDataObject parameter
        sc = (*PivSelectedItems())[nIterator]->ScOnSelect(pComponent, (*PivSelectedItems())[nIterator], fScope, fSelect);
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseMultiSelectSnapinItem::ScOnSelect()"), sc);
    goto Cleanup;
}

/* CBaseMultiSelectSnapinItem::ScAddMenuItems
 *
 * PURPOSE:                     Computes the merged context menu items and sets them.
 *
 * PARAMETERS:
 *                                      CBaseSnapin *                   pSnapin                                 Pointer to the snapin object.
 *                                      LPDATAOBJECT                    lpDataObject                    Pointer to the multiselect snapin item.
 *                                      LPCONTEXTMENUCALLBACK   ipContextMenuCallback   Context menu callback to add menu items.
 *                                      long *                                  pInsertionAllowed               Pointer to insertion flags.
 *
 * RETURNS:
 *                                      SC                                                                                              Execution code
 */
SC
CBaseMultiSelectSnapinItem::ScAddMenuItems(CBaseSnapin * pSnapin, LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK ipContextMenuCallback, long * pInsertionAllowed)
{
    // Declarations
    SC                                                              sc                                      = S_OK;
    CBaseSnapinItem *                               pitem                           = NULL;
    INT                                                             nIterator                       = 0;
    INT                                                             nIteratorMenuItems      = 0;
    CSnapinContextMenuItemVectorWrapper   cmivwMerged;                                                                    // vector of merged context menu items

    // Data validation
    ASSERT(pSnapin);
    ASSERT(pDataObject);
    ASSERT(ipContextMenuCallback);
    ASSERT(pInsertionAllowed);

    // Iterate through the snapin items and retrieve a list of context menus - combine the menus across snapin items
    for (nIterator=0; nIterator < PivSelectedItems()->size(); nIterator++)                  // start at index 1
    {
        // Get the snapin item
        pitem = (*PivSelectedItems())[nIterator];
        ASSERT(pitem);

        // Create a vector of menu items
        CSnapinContextMenuItemVectorWrapper           cmivw;                                                                  // we will have to merge these context menu item`s

        // Determine the menu items for the snapin item
        for (nIteratorMenuItems=0; nIteratorMenuItems < pitem->CMenuItem(); nIteratorMenuItems++)
        {
            // Declarations
            CSnapinContextMenuItem *              pcmi                    = NULL;
            BOOL                                    fAllowed                = FALSE;

            // Create a new context menu item
            pcmi = new CSnapinContextMenuItem();
            if (!pcmi)
                goto MemoryError;

            // Get the context menu item
            ASSERT(pitem->Pmenuitem());
            sc = pSnapin->ScGetMenuItem(pcmi, pitem, &((pitem->Pmenuitem())[nIteratorMenuItems]), &fAllowed, *pInsertionAllowed);
            if (sc)
                goto Error;

            // If the context menu item is allowed, add it to the vector
            if (fAllowed)
            {
                if (nIterator > 0)
                    cmivw.cmiv.push_back(pcmi);                                     // for other items, set a new array and then merge
                else
                    cmivwMerged.cmiv.push_back(pcmi);                       // for the first item, set the merge
            }
            // Otherwise delete the context menu item
            else
            {
                if (pcmi)
                {
                    delete pcmi;
                    pcmi = NULL;
                }
            }
        }

        // Now combine the menus we found with the merged menus
        if (nIterator > 0)
            MergeMenuItems(&cmivwMerged, &cmivw);
    }

    // Now add the merged menu items
    for (nIteratorMenuItems=0; nIteratorMenuItems < cmivwMerged.cmiv.size(); nIteratorMenuItems++)
    {
        sc = ipContextMenuCallback->AddItem(&(cmivwMerged.cmiv[nIteratorMenuItems]->cm));
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
MemoryError:
    sc = E_OUTOFMEMORY;
    goto Error;
Error:
    TraceError(_T("CBaseMultiSelectSnapinItem::ScAddMenuItems()"), sc);
    goto Cleanup;
}

/* CBaseMultiSelectSnapinItem::ScCommand
 *
 * PURPOSE:                     Forward an add menu request to selected items.
 *
 * PARAMETERS:
 *                                      CComponent *                    pComponent                              Pointer to the component object.
 *                                      long                                    nCommandID                              Id of the invoked command.
 *                                      LPDATAOBJECT                    pDataObject                             Pointer to the multiselect snapin item.
 *
 * RETURNS:
 *                                      SC                                                                                              Execution code
 */
SC
CBaseMultiSelectSnapinItem::ScCommand(CComponent * pComponent, long nCommandID, LPDATAOBJECT pDataObject)
{
    // Declarations
    SC                                                      sc                              = S_OK;
    CBaseSnapinItem *                       pitem                   = NULL;
    INT                                                     nIterator               = 0;

    // Data validation
    ASSERT(pComponent);
    ASSERT(pDataObject);

    // We forward the call to all items in the default implementation
    // This can be overriden if you want to provide bulk operation behaviour
    // You will then have to create you own CBaseMultiSelectSnapinItem based multiselect data object
    for (nIterator=0; nIterator < PivSelectedItems()->size(); nIterator++)
    {
        // Get the next item
        ASSERT((*PivSelectedItems())[nIterator]);

        // Call the menu by going back to the component
        sc = pComponent->ScCommand(nCommandID, (*PivSelectedItems())[nIterator]);
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseMultiSelectSnapinItem::ScCommand()"), sc);
    goto Cleanup;
}

/* CBaseMultiSelectSnapinItem::ScQueryPagesFor
 *
 * PURPOSE:                     Indicate that there are properties for a multi selection (in fact a page saying that there are no properties available).
 *
 * PARAMETERS:
 *                                      CComponent *            pComponent                              Pointer to the component object.
 *                                      LPDATAOBJECT            lpDataObject                    Pointer to the multiselect snapin item.
 *
 * RETURNS:
 *                                      SC                                                                                      Execution code
 */
SC
CBaseMultiSelectSnapinItem::ScQueryPagesFor(CComponent * pComponent, LPDATAOBJECT lpDataObject)
{
    // Declarations
    SC                                                      sc                      = S_OK;
    INT                                                     nIterator       = 0;

    // Data validation
    ASSERT(pComponent);
    ASSERT(lpDataObject);

    // By default, no page for a multiselection
    return S_FALSE;
}

/* CBaseMultiSelectSnapinItem::ScCreatePropertyPages
 *
 * PURPOSE:                     Display a page saying that there are no properties available.
 *
 * PARAMETERS:
 *                                      CComponent *            pComponent                              Pointer to the component object.
 *                                      LPDATAOBJECT            lpDataObject                    Pointer to the multiselect snapin item.
 *
 * RETURNS:
 *                                      SC                                                                                      Execution code
 */
SC
CBaseMultiSelectSnapinItem::ScCreatePropertyPages(CComponent * pComponent, LPPROPERTYSHEETCALLBACK ipPropertySheetCallback, long handle, LPDATAOBJECT lpDataObject)
{
    // Data validation
    ASSERT(pComponent);
    ASSERT(ipPropertySheetCallback);
    ASSERT(lpDataObject);

    // By default, no page for a multiselection
    return S_FALSE;
}

/* CBaseMultiSelectSnapinItem::ScOnPaste
 *
 * PURPOSE:                     We receive a multiselect snapin item and we must determine which items are okay with the paste.
 *                                      Also, if the operation involves a cut, we have to return a list of items to be pasted.
 *                                      We use an array of boolean to indicate the items for which a cut notification has to be sent.
 *                                      We reuse the existing multiselect snapin item as the multiselect snapin item sent to MMC to identify
 *                                      the objects which should receive a cut notification.
 *
 * PARAMETERS:
 *                                      CBaseSnapin *                                           psnapin                                                         Pointer to the snapin.
 *                                      CBaseSnapinItem *                                       pitemTarget                                                     Target item for the paste.
 *                                      LPDATAOBJECT                                            lpDataObjectList                                        Pointer to the multiselect snapin item.
 *                                      LPDATAOBJECT *                                          ppDataObjectPasted                                      If not NULL, we must set this pointer to the multiselect snapin item indicating the objects which need a cut notification.
 *                                      IConsole *                                                      ipConsole                                                       Pointer to the console interface.
 *
 * RETURNS:
 *                                      SC                                                                                                                                              Execution code
 */
SC
CBaseMultiSelectSnapinItem::ScOnPaste(CBaseSnapin * pSnapin, CBaseSnapinItem * pitemTarget, LPDATAOBJECT lpDataObjectList, LPDATAOBJECT * ppDataObjectPasted, IConsole * ipConsole)
{
    // Declarations
    SC                                                      sc                                              = S_OK;
    INT                                                     nIterator                               = 0;
    BOOL                                            fAtLeastOnePaste                = FALSE;

    // Data validation
    ASSERT(pSnapin);
    ASSERT(pitemTarget);
    ASSERT(lpDataObjectList);
    ASSERT(ipConsole);
    // other parameters can not be ASSERTed

    // Allocate an array of booleans to indicate the correctly pasted items
    ASSERT(PivSelectedItems()->size() > 0);
    m_pfPastedWithCut = new BOOL[PivSelectedItems()->size()];
    if (!m_pfPastedWithCut)
        goto MemoryError;
    for (nIterator=0; nIterator < PivSelectedItems()->size(); nIterator++)
        m_pfPastedWithCut[nIterator] = FALSE;

    // Iterate through all the objects and verify that they can be pasted
    for (nIterator=0; nIterator < PivSelectedItems()->size(); nIterator++)
    {
        // Local declarations
        DWORD                   dwCanCopyCut            = 0;
        BOOL                    fPasted                         = FALSE;

        // Ask the item to copy the underlying object
        sc = pitemTarget->ScOnPaste((*PivSelectedItems())[nIterator], ppDataObjectPasted ? TRUE : FALSE, &fPasted);
        if (sc)
            goto Error;
        if (fPasted)
        {
            // Remember we pasted at least one item
            fAtLeastOnePaste        = TRUE;
        }

        // If this was a cut, we need to return to MMC the items that were pasted
        // (do not delete the dropped item if we are just adding it to a policy)
        if (fPasted && ppDataObjectPasted && !pitemTarget->FIsPolicy())
        {
            // Remember the items which should receive a cut notification
            m_pfPastedWithCut[nIterator]    = TRUE;
        }
    }

    // Indicate to MMC the pasted item
    if (ppDataObjectPasted)
    {
        *ppDataObjectPasted = this;
        AddRef();                                               // reuse ourselves as the multiselect data object which indicates the pasted items
    }

    // Refresh
    if (fAtLeastOnePaste)
    {
        sc = ipConsole->UpdateAllViews(static_cast<IDataObject *>(pitemTarget), 0, ONVIEWCHANGE_REFRESHCHILDREN);
        if (sc)
            goto Error;
    }
Cleanup:
    return sc;
MemoryError:
    sc = E_OUTOFMEMORY;
    goto Error;
Error:
    TraceError(_T("CBaseMultiSelectSnapinItem::ScOnPaste()"), sc);
    goto Cleanup;
}

/* CBaseMultiSelectSnapinItem::ScOnCutOrMove
 *
 * PURPOSE:                     We are a multiselect snapin item which points to an array of booleans indicating which snapin items need a cut notification.
 *                                      We must forward a cut notification to these items.
 *
 * PARAMETERS:
 *                                      CBaseSnapin *                                           psnapin                                                         Pointer to the snapin.
 *                                      LPDATAOBJECT                                            lpDataObjectList                                        Pointer to the multiselect snapin item.
 *                                      IConsoleNameSpace *                                     ipConsoleNameSpace                                      Pointer to the namespace console interface.
 *                                      IConsole *                                                      ipConsole                                                       Pointer to the console interface.
 *
 * RETURNS:
 *                                      SC                                                                                                                                              Execution code
 */
SC
CBaseMultiSelectSnapinItem::ScOnCutOrMove(CBaseSnapin * pSnapin, LPDATAOBJECT lpDataObjectList, IConsoleNameSpace * ipConsoleNameSpace, IConsole * ipConsole)
{
    // Declarations
    SC                                                      sc                                              = S_OK;
    INT                                                     nIterator                               = 0;

    // Data validation
    ASSERT(pSnapin);
    ASSERT(lpDataObjectList);
    ASSERT(ipConsoleNameSpace);
    ASSERT(ipConsole);

    // Iterate through the items and find those which need a cut notification
    for (nIterator=0; nIterator < PivSelectedItems()->size(); nIterator++)          // start at index 1
    {
        // Get the next item
        ASSERT((*PivSelectedItems())[nIterator]);
        ASSERT(m_pfPastedWithCut);

        // Check if the item needs a cut notification
        if (m_pfPastedWithCut[nIterator])
        {
            // Call ScOnCutOrMove for each snapin item - pass pitem as an lpDataObjectList parameter
            sc = pSnapin->ScOnCutOrMove((*PivSelectedItems())[nIterator], ipConsoleNameSpace, ipConsole);
            if (sc)
                goto Error;
        }
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseMultiSelectSnapinItem::ScOnCutOrMove()"), sc);
    goto Cleanup;
}

/* CBaseMultiSelectSnapinItem::ScOnDelete
 *
 * PURPOSE:                     Forward a delete notification to selected items.
 *
 * PARAMETERS:
 *                                      CComponent *                    pComponent                              Pointer to the component.
 *                                      LPDATAOBJECT                    lpDataObject                    Pointer to the multiselect snapin item.
 * RETURNS:
 *                                      SC                                                                                              Execution code
 */
SC
CBaseMultiSelectSnapinItem::ScOnDelete(CComponent * pComponent, LPDATAOBJECT lpDataObject)
{
    // Declarations
    SC                                                      sc                                              = S_OK;
    INT                                                     nIterator                               = 0;

    // Data validation
    ASSERT(pComponent);
    ASSERT(lpDataObject);

    // Iterate through the items and find those which need a cut notification
    for (nIterator=0; nIterator < PivSelectedItems()->size(); nIterator++)          // start at index 1
    {
        // Get the next item
        ASSERT((*PivSelectedItems())[nIterator]);

        // Call ScOnDelete for each snapin item - pass pitem as an lpDataObject parameter
        sc = pComponent->ScOnDelete((*PivSelectedItems())[nIterator]);
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseMultiSelectSnapinItem::ScOnDelete()"), sc);
    goto Cleanup;
}

/* CBaseMultiSelectSnapinItem::ScExtractMultiSelectObjectFromCompositeMultiSelectObject
 *
 * PURPOSE:                     On some notifications, MMC gives us a composite object made of multiselect object from different snapins.
 *                                      This method's goal is to extract a multiselect object from the composite object.
 *
 * PARAMETERS:
 *                                      CBaseSnapin *                                           psnapin                                                         Snapin (used to determine which multiselect data object is the right one in the composite multiselect data object).
 *                                      LPDATAOBJECT                                            pDataObjectComposite                            Composite data object.
 *                                      CBaseMultiSelectSnapinItem **           ppBaseMultiSelectSnapinItem                     Determined multiselect data object.
 *
 * RETURNS:
 *                                      SC                                                                                              Execution code
 */
SC
CBaseMultiSelectSnapinItem::ScExtractMultiSelectObjectFromCompositeMultiSelectObject(CBaseSnapin * psnapin, LPDATAOBJECT pDataObjectComposite, CBaseMultiSelectSnapinItem ** ppBaseMultiSelectSnapinItem)
{
    // Declarations
    SC                                                              sc                                                      = S_OK;
    STGMEDIUM                                               stgmedium                                       = {TYMED_HGLOBAL,  NULL};
    FORMATETC                                               formatetc                                       = {(CLIPFORMAT)s_cfMultiSelectSnapins, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    SMMCDataObjects *                               pSMMCDataObjects                        = NULL;
    CBaseMultiSelectSnapinItem *    pBaseMultiSelectSnapinItem      = NULL;
    INT                                                             nIterator                                       = 0;

    // Data validation
    ASSERT(pDataObjectComposite);
    ASSERT(ppBaseMultiSelectSnapinItem);
    ASSERT(!*ppBaseMultiSelectSnapinItem);
    ASSERT(psnapin);

    // Retrieve data
    sc = pDataObjectComposite->GetData(&formatetc, &stgmedium);
    if (sc)
        goto Error;

    // Lock memory and cast
    pSMMCDataObjects = (SMMCDataObjects *)(::GlobalLock(stgmedium.hGlobal));
    ASSERT(pSMMCDataObjects);

    // What we get here is a composite object made of multiselection sets of snapin items from the same snapin
    // We have to locate the multiselection set for our snapin
    ASSERT(pSMMCDataObjects->count > 0);
    for (nIterator=0; nIterator < pSMMCDataObjects->count; nIterator++)
    {
        // Local declarations
        CLSID           clsid;

        // Get the class id for the dataobject
        ASSERT(pSMMCDataObjects->lpDataObject[nIterator]);
        sc = ScGetClassID(pSMMCDataObjects->lpDataObject[nIterator], &clsid);
        if (sc)
        {
            // Ignore the error, probably this node does not belong to us
            sc = S_OK;
        }
        else if (::IsEqualCLSID(clsid, *(psnapin->PclsidSnapin())))
        {
            pBaseMultiSelectSnapinItem = dynamic_cast<CBaseMultiSelectSnapinItem *>(pSMMCDataObjects->lpDataObject[nIterator]);
            ASSERT(pBaseMultiSelectSnapinItem);
            break;
        }
    }

    // Assign the result
    ASSERT(pBaseMultiSelectSnapinItem);
    ASSERT(*(psnapin->PclsidSnapin()) == *(pBaseMultiSelectSnapinItem->PclsidSnapin()));
    *ppBaseMultiSelectSnapinItem = pBaseMultiSelectSnapinItem;

Cleanup:
    // Cleanup allocated resources
    if (pSMMCDataObjects)
        ::GlobalUnlock(stgmedium.hGlobal);
    if (stgmedium.hGlobal)
        ::GlobalFree(stgmedium.hGlobal);
    return sc;
Error:
    TraceError(_T("CBaseMultiSelectSnapinItem::ScExtractMultiSelectObjectFromCompositeMultiSelectObject()"), sc);
    goto Cleanup;
}

/* CBaseMultiSelectSnapinItem::ScIsPastableDataObject
 *
 * PURPOSE:                     Determine, using the multiselect object, if a paste operation is acceptable.
 *
 * PARAMETERS:
 *                                      CBaseSnapin *                                           psnapin                                                         Pointer to the snapin.
 *                                      CBaseSnapinItem *                                       pitemTarget                                                     Target item for the paste.
 *                                      LPDATAOBJECT                                            lpDataObjectList                                        Pointer to the multiselect snapin item.
 *                                      BOOL *                                                          pfPastable                                                      Must be set to TRUE if the paste operation is acceptable.
 *
 * RETURNS:
 *                                      SC                                                                                                                                              Execution code
 */
SC
CBaseMultiSelectSnapinItem::ScIsPastableDataObject(CBaseSnapin * pSnapin, CBaseSnapinItem * pitemTarget, LPDATAOBJECT lpDataObjectList, BOOL * pfPastable)
{
    // Declarations
    SC                                                              sc                                                      = S_OK;
    INT                                                             nIterator                                       = 0;

    // Data validation
    ASSERT(pSnapin);
    ASSERT(pitemTarget);
    ASSERT(lpDataObjectList);
    ASSERT(pfPastable);

    // Go through each snapin items for the multiselect snapin items
    for (nIterator=0; nIterator < PivSelectedItems()->size(); nIterator++)
    {
        // Check if we can paste - if any item can not be pasted, then cancel out
        sc = pSnapin->ScIsPastableDataObject(pitemTarget, (*(PivSelectedItems()))[nIterator], pfPastable);
        if (sc)
            goto Error;
        if (!*pfPastable)
        {
            sc = S_FALSE;
            goto Cleanup;
        }
    }

Cleanup:
    return sc;
Error:
    *pfPastable = FALSE;
    TraceError(_T("CBaseMultiSelectSnapinItem::ScIsPastableDataObject()"), sc);
    goto Cleanup;
}

/* CBaseMultiSelectSnapinItem::MergeMenuItemsVectors
 *
 * PURPOSE:                     Merges menu item vectors in a smart way.
 *                                      If a menu item in the merge is not found in the list to add, then remove this item from the merge (one snapin item does not support the operation).
 *                                      If a menu item in the merge is found in the list to add, logically combine the flags.
 *
 * PARAMETERS:
 *                                      CSnapinContextMenuItemVectorWrapper   *       pcmivwForMerge          Vector of menu items to merge - will contain the result of the merge
 *                                      CSnapinContextMenuItemVectorWrapper   *       pcmivwToAdd                     Vector of menu items to merge - specify what to add here
 */
void
CBaseMultiSelectSnapinItem::MergeMenuItems(CSnapinContextMenuItemVectorWrapper * pcmivwForMerge, CSnapinContextMenuItemVectorWrapper * pcmivwToAdd)
{
    // Declarations
    INT                             nIteratorToAdd                          = 0;
    INT                             nIteratorForMerge                       = 0;

    // Data validation
    ASSERT(pcmivwForMerge);
    ASSERT(pcmivwToAdd);

    // Iterate through the merge
    for (nIteratorForMerge=0; nIteratorForMerge < pcmivwForMerge->cmiv.size(); nIteratorForMerge++)
    {
        // Local declarations
        BOOL            fFound  = FALSE;                        // if we are not able to find, then we must remove them menu item

        // See if we can find in the add a menu item with the same command id and the same insertion point
        for (nIteratorToAdd=0; nIteratorToAdd < pcmivwToAdd->cmiv.size(); nIteratorToAdd++)
        {
            if (((pcmivwToAdd->cmiv)[nIteratorToAdd]->cm.lCommandID == (pcmivwForMerge->cmiv)[nIteratorForMerge]->cm.lCommandID) &&
                ((pcmivwToAdd->cmiv)[nIteratorToAdd]->cm.lInsertionPointID == (pcmivwForMerge->cmiv)[nIteratorForMerge]->cm.lInsertionPointID))
            {
                // Set the new default
                fFound = TRUE;

                // Combine the flags in merge
                (pcmivwForMerge->cmiv)[nIteratorForMerge]->cm.fFlags = (pcmivwForMerge->cmiv)[nIteratorForMerge]->cm.fFlags | (pcmivwToAdd->cmiv)[nIteratorToAdd]->cm.fFlags;
                (pcmivwForMerge->cmiv)[nIteratorForMerge]->cm.fSpecialFlags = (pcmivwForMerge->cmiv)[nIteratorForMerge]->cm.fSpecialFlags | (pcmivwToAdd->cmiv)[nIteratorToAdd]->cm.fSpecialFlags;

                // Handle flag combining exceptions: MF_ENABLED and MF_GRAYED -> MF_GRAYED
                if ((pcmivwForMerge->cmiv)[nIteratorForMerge]->cm.fFlags & (MF_ENABLED | MF_GRAYED))
                    (pcmivwForMerge->cmiv)[nIteratorForMerge]->cm.fFlags = (pcmivwForMerge->cmiv)[nIteratorForMerge]->cm.fFlags & ~MF_ENABLED;

                // Handle flag combining exceptions: MF_MENUBARBREAK and MF_MENUBREAK -> MF_MENUBREAK
                if ((pcmivwForMerge->cmiv)[nIteratorForMerge]->cm.fFlags & (MF_MENUBARBREAK | MF_MENUBREAK))
                    (pcmivwForMerge->cmiv)[nIteratorForMerge]->cm.fFlags = (pcmivwForMerge->cmiv)[nIteratorForMerge]->cm.fFlags & ~MF_MENUBARBREAK;

                // Handle flag combining exceptions: MF_CHECKED and MF_UNCHECKED -> MF_UNCHECKED
                if ((pcmivwForMerge->cmiv)[nIteratorForMerge]->cm.fFlags & (MF_CHECKED | MF_UNCHECKED))
                    (pcmivwForMerge->cmiv)[nIteratorForMerge]->cm.fFlags = (pcmivwForMerge->cmiv)[nIteratorForMerge]->cm.fFlags & ~MF_CHECKED;

                // Stop now
                break;
            }
        }

        // If we were not able to find a menu item from merge in add, we have to remove this menu item because at least one snapin item does not advertise it
        if (!fFound)
        {
            // Delete the pointed context menu item
            if (pcmivwForMerge->cmiv[nIteratorForMerge])
            {
                delete pcmivwForMerge->cmiv[nIteratorForMerge];
                pcmivwForMerge->cmiv[nIteratorForMerge] = NULL;
            }
            pcmivwForMerge->cmiv.erase(&(pcmivwForMerge->cmiv[nIteratorForMerge]));
            nIteratorForMerge--;
        }
    }
}

/* CBaseMultiSelectSnapinItem::ScGetMultiSelectDataObject
 *
 * PURPOSE:                     Determines if an object is a multiselect data object and casts it.
 *
 * PARAMETERS:
 *                                      LPDATAOBJECT                                    lpDataObject                            Received data object to cast
 *                                      CBaseMultiSelectSnapinItem **   ppMultiSelectSnapinItem         Pointer to multiselect pointer - set to  NULL we can not convert.
 *
 * RETURNS                      SC                                                                                                                      Execution code.
 */
SC
CBaseMultiSelectSnapinItem::ScGetMultiSelectDataObject(LPDATAOBJECT lpDataObject, CBaseMultiSelectSnapinItem ** ppMultiSelectSnapinItem)
{
    // Declarations
    SC                                      sc                              = S_OK;
    CLSID                           clsid;

    // Data validation
    ASSERT(lpDataObject);
    ASSERT(ppMultiSelectSnapinItem);
    ASSERT(!*ppMultiSelectSnapinItem);

    // Use the clipboard format to identify the object type
    sc = CBaseDataObject::ScGetNodeType(lpDataObject, &clsid);
    if (sc == SC(DV_E_FORMATETC) )
    {
        SC scNoTrace = sc;
        sc.Clear();
        return scNoTrace;
    }

    if (sc)
        goto Error;

    // If the node type is nodetypeBaseMultiSelect then we know we are a multiselect data object
    if (::IsEqualCLSID(clsid, *(nodetypeBaseMultiSelect.PclsidNodeType())))
    {
        ASSERT(dynamic_cast<CBaseSnapinItem *>(lpDataObject));
        *ppMultiSelectSnapinItem = dynamic_cast<CBaseMultiSelectSnapinItem *>(lpDataObject);
    }
    else
        *ppMultiSelectSnapinItem = NULL;

Cleanup:
    return sc;
Error:
    *ppMultiSelectSnapinItem = NULL;
    TraceError(_T("CBaseMultiSelectSnapinItem::ScGetMultiSelectDataObject()"), sc);
    goto Cleanup;
}

/* CBaseMultiSelectSnapinItem::ScExtractMultiSelectDataObject
 *
 * PURPOSE:                     Determines if an object is a composite data object and extracts the correct multiselect snapin item from it.
 *
 * PARAMETERS:
 *                                      CBaseSnapin *                                   psnapin                                         Snapin (used to determine which multiselect data object is the right one in the composite multiselect data object).
 *                                      LPDATAOBJECT                                    lpDataObject                            Received data object to cast
 *                                      CBaseMultiSelectSnapinItem **   ppMultiSelectSnapinItem         Pointer to multiselect pointer - set to  NULL we can not convert.
 *
 * RETURNS                      SC                                                                                                                      Execution code.
 */
SC
CBaseMultiSelectSnapinItem::ScExtractMultiSelectDataObject(CBaseSnapin * psnapin, LPDATAOBJECT lpDataObject, CBaseMultiSelectSnapinItem ** ppMultiSelectSnapinItem)
{
    // Declarations
    SC                                                              sc                                                      = S_OK;
    STGMEDIUM                                               stgmedium                                       = {TYMED_HGLOBAL,  NULL};
    FORMATETC                                               formatetc                                       = {(CLIPFORMAT)s_cfCompositeDataObject, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    BOOL                    *                               pfCompositeDataObject           = NULL;

    // Data validation
    ASSERT(lpDataObject);
    ASSERT(psnapin);
    ASSERT(ppMultiSelectSnapinItem);
    ASSERT(!*ppMultiSelectSnapinItem);

    // Retrieve data
    sc = lpDataObject->GetData(&formatetc, &stgmedium);
    if (sc)
    {
        sc = S_OK;                    // ignore the error, consider that we are not a composite data object
        goto Cleanup;
    }

    // Lock memory and cast
    pfCompositeDataObject = (BOOL *)(::GlobalLock(stgmedium.hGlobal));
    ASSERT(pfCompositeDataObject);

    // If the object is a composite data object then extract the correct multiselect snapin item
    if (*pfCompositeDataObject)
    {
        sc = ScExtractMultiSelectObjectFromCompositeMultiSelectObject(psnapin, lpDataObject, ppMultiSelectSnapinItem);
        if (sc)
            goto Error;
    }

Cleanup:
    // Cleanup allocated resources
    if (pfCompositeDataObject)
        ::GlobalUnlock(stgmedium.hGlobal);
    if (stgmedium.hGlobal)
        ::GlobalFree(stgmedium.hGlobal);
    return sc;
Error:
    *ppMultiSelectSnapinItem = NULL;
    TraceError(_T("CBaseMultiSelectSnapinItem::ScExtractMultiSelectDataObject()"), sc);
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\lib\snaptrace.cxx ===
/*
 *      SnapTrace.cxx
 *
 *
 *      Copyright (c) 1998-1999 Microsoft Corporation
 *
 *      PURPOSE:        Support functions for debug trace
 *
 *
 *      OWNER:          ptousig
 */
#include "headers.hxx"

#ifdef DBG
// ScFromHr(E_UNEXPECTED);
CTraceTag tagBaseSnapinNotify(_T("BaseMMC"), _T("Notify"));
CTraceTag tagBaseSnapinRegister(_T("BaseMMC"), _T("Register"));

CTraceTag tagBaseSnapinISnapinAbout(_T("BaseMMC"), _T("ISnapinAbout"));
CTraceTag tagBaseSnapinIComponent(_T("BaseMMC"), _T("IComponent"));
CTraceTag tagBaseSnapinIComponentQueryDataObject(_T("BaseMMC"), _T("IComponent::QueryDataObject"));
CTraceTag tagBaseSnapinIComponentGetDisplayInfo(_T("BaseMMC"), _T("IComponent::GetDisplayInfo"));
CTraceTag tagBaseSnapinIComponentData(_T("BaseMMC"), _T("IComponentData"));
CTraceTag tagBaseSnapinIComponentDataQueryDataObject(_T("BaseMMC"), _T("IComponentData::QueryDataObject"));
CTraceTag tagBaseSnapinIComponentDataGetDisplayInfo(_T("BaseMMC"), _T("IComponentData::GetDisplayInfo"));
CTraceTag tagBaseSnapinIResultOwnerData(_T("BaseMMC"), _T("IResultOwnerData"));
CTraceTag tagBaseSnapinIDataObject(_T("BaseMMC"), _T("IDataObject"));
CTraceTag tagBaseSnapinISnapinHelp(_T("BaseMMC"), _T("ISnapinHelp"));
CTraceTag tagBaseSnapinIExtendContextMenu(_T("BaseMMC"), _T("IExtendContextMenu"));
CTraceTag tagBaseSnapinIExtendPropertySheet(_T("BaseMMC"), _T("IExtendPropertySheet"));
CTraceTag tagBaseSnapinIResultDataCompare(_T("BaseMMC"), _T("IResultDataCompare"));
CTraceTag tagBaseSnapinIPersistStreamInit(_T("BaseMMC"), _T("IPersistStreamInit"));

CTraceTag tagBaseSnapinDebugDisplay(_T("BaseMMC"), _T("Debug Display"));
CTraceTag tagBaseSnapinDebugCopy(_T("BaseMMC"), _T("Copy to WordPad"));
CTraceTag tagBaseSnapinItemTracker(_T("BaseMMC"), _T("Item Tracker"));
CTraceTag tagBaseMultiSelectSnapinItemTracker(_T("BaseMMC"), _T("Multiselect Item Tracker"));

#define CASE_DEBUG_NAME(a)         case a: return _T(#a)

tstring SzGetDebugNameOfHr(HRESULT hr)
{
    //
    // First try some of the common HRESULTs
    //
    switch (hr)
    {
        CASE_DEBUG_NAME(S_FALSE);
        CASE_DEBUG_NAME(E_NOTIMPL);
        CASE_DEBUG_NAME(DV_E_FORMATETC);
        CASE_DEBUG_NAME(E_INVALIDARG);
        CASE_DEBUG_NAME(DV_E_TYMED);
        CASE_DEBUG_NAME(S_OK);
        CASE_DEBUG_NAME(E_UNEXPECTED);
    default:
        //
        // If we reached this point we don't know what the HRESULT is.
        // We can still say wether it's an error code or not.
        //
        if (SUCCEEDED(hr))
            return TEXT("Unknown Success Code");
        else
            return TEXT("Unknown Error Code");
    }
}

tstring SzGetDebugNameOfDATA_OBJECT_TYPES(DATA_OBJECT_TYPES type)
{
    switch (type)
    {
        CASE_DEBUG_NAME(CCT_SCOPE);
        CASE_DEBUG_NAME(CCT_RESULT);
        CASE_DEBUG_NAME(CCT_SNAPIN_MANAGER);
        CASE_DEBUG_NAME(CCT_UNINITIALIZED);
    default:
        return _T("Unknown");
    }
}

tstring SzGetDebugNameOfMMC_NOTIFY_TYPE(MMC_NOTIFY_TYPE event)
{
    switch (event)
    {
        CASE_DEBUG_NAME(MMCN_ACTIVATE);
        CASE_DEBUG_NAME(MMCN_ADD_IMAGES);
        CASE_DEBUG_NAME(MMCN_BTN_CLICK);
        CASE_DEBUG_NAME(MMCN_CLICK);
        CASE_DEBUG_NAME(MMCN_COLUMN_CLICK);
        CASE_DEBUG_NAME(MMCN_CONTEXTMENU);
        CASE_DEBUG_NAME(MMCN_CUTORMOVE);
        CASE_DEBUG_NAME(MMCN_DBLCLICK);
        CASE_DEBUG_NAME(MMCN_DELETE);
        CASE_DEBUG_NAME(MMCN_DESELECT_ALL);
        CASE_DEBUG_NAME(MMCN_EXPAND);
        CASE_DEBUG_NAME(MMCN_EXPANDSYNC);
        CASE_DEBUG_NAME(MMCN_HELP);
        CASE_DEBUG_NAME(MMCN_MENU_BTNCLICK);
        CASE_DEBUG_NAME(MMCN_MINIMIZED);
        CASE_DEBUG_NAME(MMCN_PASTE);
        CASE_DEBUG_NAME(MMCN_PROPERTY_CHANGE);
        CASE_DEBUG_NAME(MMCN_QUERY_PASTE);
        CASE_DEBUG_NAME(MMCN_REFRESH);
        CASE_DEBUG_NAME(MMCN_REMOVE_CHILDREN);
        CASE_DEBUG_NAME(MMCN_RENAME);
        CASE_DEBUG_NAME(MMCN_SELECT);
        CASE_DEBUG_NAME(MMCN_SHOW);
        CASE_DEBUG_NAME(MMCN_VIEW_CHANGE);
        CASE_DEBUG_NAME(MMCN_SNAPINHELP);
        CASE_DEBUG_NAME(MMCN_CONTEXTHELP);
        CASE_DEBUG_NAME(MMCN_INITOCX);
        CASE_DEBUG_NAME(MMCN_FILTER_CHANGE);
        CASE_DEBUG_NAME(MMCN_FILTERBTN_CLICK);
        CASE_DEBUG_NAME(MMCN_RESTORE_VIEW);
        CASE_DEBUG_NAME(MMCN_PRINT);
        CASE_DEBUG_NAME(MMCN_PRELOAD);
        CASE_DEBUG_NAME(MMCN_LISTPAD);
    default:
        return _T("Unknown");
    }
}

#else
tstring SzGetDebugNameOfHr(HRESULT hr){return _T("");}
    //

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\lib\viewlist.cxx ===
/*
 *      viewlist.cxx
 *
 *
 *      Copyright (c) 1998 Microsoft Corporation
 *
 *      PURPOSE:        Implements the CGenericSnapin class.
 *
 *
 *      OWNER:          vivekj
 */

#include <headers.hxx>

//---------------------------------------------------------------------------------
// class CViewItemList

/* CViewItemList::CViewItemList
 *
 * PURPOSE:             Constructor
 *
 * PARAMETERS:  None
 */
CViewItemList::CViewItemList()
{
    m_pitemSelectedContainer= NULL;
    m_fValid                                = FALSE;
    m_datSort                               = datNil;
}

/* CViewItemList::Initialize
 *
 * PURPOSE:             Initializes a view, by creating pointers to all items underneath the selected container, and
 *                              sorting them.
 *
 * PARAMETERS:
 *              CBaseSnapinItem *  pitemSelectedContainer:      The container containing the items we need to enumerate.
 *              DAT            datPresort:                              The dat according to which the list of items is already sorted.
 *              DAT            datSort:                                 The dat according to which the view is sorted.
 *
 * RETURNS:
 *              void
 */
void
CViewItemList::Initialize(CBaseSnapinItem *pitemSelectedContainer, DAT datPresort, DAT datSort)
{
    CBaseSnapinItem *                                       pitem   = NULL;
    Invalidate();                                                                   // delete any existing items and clear the valid flag

    pitem = pitemSelectedContainer->PitemChild();   // get the first child item
    while (pitem)                                                                   // Iterate through all the children
    {
        push_back(pitem);                                                       // Insert each item
        pitem = pitem->PitemNext();
    }

    if (datPresort != datSort)                                               // need to sort if not already in the correct order.
        Sort();

    SaveSortResults();                                                              // need to save the results for fast lookup.
    m_fValid = TRUE;                                                                // set the valid flag

    return;
}


/* CViewItemList::Sort
 *
 * PURPOSE:             Sorts the view list according to DatSort().
 *
 * PARAMETERS:  None
 *
 * RETURNS:
 *              void
 */
void
CViewItemList::Sort()
{
}

/* CViewItemList::SaveSortResults
 *
 * PURPOSE:             SaveSortResultss the view list according to DatSaveSortResults().
 *
 * PARAMETERS:  None
 *
 * RETURNS:
 *              void
 */
void
CViewItemList::SaveSortResults()
{
    CViewItemListBase::iterator             viewitemiter;

    Pviewsortresultsmap()->clear();

    for (viewitemiter = begin(); viewitemiter < end(); viewitemiter ++)      // create a map of the sort results
    {
        t_sortmapitem sortmapitem(*viewitemiter, viewitemiter);
        Pviewsortresultsmap()->insert(sortmapitem);     // This maps the CBaseSnapinItem *'s onto their location in the sorted array.
    }
}


/* CViewItemList::ScCompare
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *              CBaseSnapinItem *   pitem1:
 *              CBaseSnapinItem *   pitem2:
 *
 * RETURNS:
 *              INT
 */
INT
CViewItemList::Compare(CBaseSnapinItem * pitem1, CBaseSnapinItem *pitem2)
{
    SC              sc              = S_OK;
    INT             result  = 0;            // initialize to "=="

    CViewSortResultsMap:: iterator  sortresultsiterator1, sortresultsiterator2;

    sortresultsiterator1 = Pviewsortresultsmap()->find(pitem1);     // locate the iterators for the items
    sortresultsiterator2 = Pviewsortresultsmap()->find(pitem2);

    if (sortresultsiterator1 == Pviewsortresultsmap()->end() || sortresultsiterator2 == Pviewsortresultsmap()->end())
        goto Cleanup;                                                                                   // didn't find, use "=="

    result = sortresultsiterator1->second - sortresultsiterator2->second;                   // fast compare based on indexes.

    Cleanup:
    return result;
}

/* CViewItemList::Invalidate
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *              void
 */
void
CViewItemList::Invalidate()
{
    m_fValid = FALSE;
    clear();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\sample\component2snapin.cxx ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       Component2Testsnap.cxx
//
//  Contents:   Classes that implement Component2Test snapin using the framework.
//
//--------------------------------------------------------------------
#include "stdafx.hxx"


//+-------------------------------------------------------------------
//
//  Member:      CComponent2TestRootItem::ScInit
//
//  Synopsis:    Called immeadiately after the item is created to init
//               displayname, icon index etc...
//
//  Arguments:   [CBaseSnapin]   -
//               [CColumnInfoEx] - Any columns to be displayed for this item.
//               [INT]           - # of columns
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CComponent2TestRootItem::ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex, INT ccolinfoex, BOOL fIsRoot)
{
    DECLARE_SC(sc, _T("CComponent2TestRootItem::ScInit"));

    sc = CBaseSnapinItem::ScInit(pSnapin, pcolinfoex, ccolinfoex, fIsRoot);
    if (sc)
        return sc;

    // Init following
    //  a. Icon index.
    //  b. Load display name.

    m_uIconIndex = 3; // use an enum instead of 3

    m_strDisplayName.LoadString(_Module.GetResourceInstance(), IDS_Component2TestROOT);

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CComponent2TestRootItem::ScGetField
//
//  Synopsis:    Get the string representation for given field to display
//               it in result pane.
//
//  Arguments:   [DAT]     - The column requested (this is an enumeration).
//               [tstring] - Out string.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CComponent2TestRootItem::ScGetField (DAT dat, tstring& strField)
{
    DECLARE_SC(sc, _T("CComponent2TestRootItem::ScGetField"));

    switch(dat)
    {
    case datString1:
        strField = _T("Root String1");
        break;

    case datString2:
        strField = _T("Root String2");
        break;

    case datString3:
        strField = _T("Root String3");
        break;

    default:
        E_INVALIDARG;
        break;
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CComponent2TestRootItem::ScCreateChildren
//
//  Synopsis:    Create any children (nodes & leaf items) for this item.
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CComponent2TestRootItem::ScCreateChildren ()
{
    DECLARE_SC(sc, _T("CComponent2TestRootItem::ScCreateChildren"));

    t_itemChild *   pitemChild      = NULL;
    t_itemChild *   pitemPrevious   = NULL;

    // Let us create 10 items for this container.
    for (int i = 0; i < 10; ++i)
    {
        // Create the child nodes and init them.
        sc = CComponent2TestSnapinLVLeafItem::ScCreateLVLeafItem(this, pitemPrevious, &pitemChild, FALSE); // Why FALSE???
        if (sc)
            return sc;
        pitemPrevious = pitemChild;
    }

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CComponent2TestRootItem::ScQueryDispatch
//
//  Synopsis:    We support IDispatch for scripting, just return a pointer
//               to the IDispatch of ourselves.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CComponent2TestRootItem::ScQueryDispatch(long cookie, DATA_OBJECT_TYPES type, LPDISPATCH *ppDispatch)
{
    DECLARE_SC(sc, _T("CComponent2TestRootItem::ScQueryDispatch"));

    *ppDispatch = dynamic_cast<IDispatch*>(this);
    if (! *ppDispatch)
        return (sc = E_NOINTERFACE);

    (*ppDispatch)->AddRef();

    return sc;
}

HRESULT CComponent2TestRootItem::StringFromScriptToSnapin(BSTR bstrMessage)
{
    DECLARE_SC(sc , _T("CComponent2TestRootItem::StringFromScriptToSnapin"));

    // The script is supposed to give us this function name in the string.
    if (0 == _wcsicmp(bstrMessage, L"StringFromScriptToSnapin"))
        return sc.ToHr();

    sc = E_FAIL;

    return sc.ToHr();
}

HRESULT CComponent2TestRootItem::StringFromSnapinToScript(BSTR *pbstrMessage)
{
    DECLARE_SC(sc , _T("CComponent2TestRootItem::StringFromSnapinToScript"));
    sc = ScCheckPointers(pbstrMessage);
    if (sc)
        return sc.ToHr();

    // The script is supposed to expect this function name in the string.
    *pbstrMessage = ::SysAllocString(OLESTR("StringFromSnapinToScript"));

    return sc.ToHr();
}

HRESULT CComponent2TestRootItem::get_Name(BSTR *pbstrMessage)
{
    DECLARE_SC(sc , _T("CComponent2TestRootItem::get_Name"));
    sc = ScCheckPointers(pbstrMessage);
    if (sc)
        return sc.ToHr();

    // The script is supposed to expect this function name in the string.
    *pbstrMessage = ::SysAllocString(OLESTR("Name"));

    return sc.ToHr();
}

HRESULT CComponent2TestRootItem::put_Name(BSTR bstrMessage)
{
    DECLARE_SC(sc , _T("CComponent2TestRootItem::put_Name"));

    // The script is supposed to give us this function name in the string.
    if (0 == _wcsicmp(bstrMessage, L"Name"))
        return sc.ToHr();

    sc = E_FAIL;

    return sc.ToHr();
}



//+-------------------------------------------------------------------
//
//  Member:      CComponent2TestSnapinLVLeafItem::ScInit
//
//  Synopsis:    Called immeadiately after the item is created to init
//               displayname, icon index etc...
//
//  Arguments:   [CBaseSnapin]   -
//               [CColumnInfoEx] - Any columns to be displayed for this item.
//               [INT]           - # of columns
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CComponent2TestSnapinLVLeafItem::ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex, INT ccolinfoex, BOOL fIsRoot)
{
    DECLARE_SC(sc, _T("CComponent2TestSnapinLVLeafItem::ScInit"));

    sc = CBaseSnapinItem::ScInit(pSnapin, pcolinfoex, ccolinfoex, fIsRoot);
    if (sc)
        return sc;

    // Init following
    //  a. Icon index.
    //  b. Load display name.

    m_uIconIndex = 7; // use an enum instead of 7

    m_strDisplayName.LoadString(_Module.GetResourceInstance(), IDS_LVLeafItem);

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CComponent2TestSnapinLVLeafItem::ScGetField
//
//  Synopsis:    Get the string representation for given field to display
//               it in result pane.
//
//  Arguments:   [DAT]     - The column requested (this is an enumeration).
//               [tstring] - Out string.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CComponent2TestSnapinLVLeafItem::ScGetField (DAT dat, tstring& strField)
{
    DECLARE_SC(sc, _T("CComponent2TestSnapinLVLeafItem::ScGetField"));

    switch(dat)
    {
    case datString1:
        strField = _T("LVLeaf String1");
        break;

    case datString2:
        strField = _T("LVLeaf String2");
        break;

    case datString3:
        strField = _T("LVLeaf String3");
        break;

    default:
        E_INVALIDARG;
        break;
    }

    return (sc);
}



//+-------------------------------------------------------------------
//
//  Member:      CComponent2TestSnapinLVLeafItem::ScCreateLVLeafItem
//
//  Synopsis:    Do we really need this method?
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CComponent2TestSnapinLVLeafItem::ScCreateLVLeafItem(CComponent2TestRootItem *pitemParent, t_itemChild * pitemPrevious, t_itemChild ** ppitem, BOOL fNew)
{
    DECLARE_SC(sc, _T("CComponent2TestSnapinLVLeafItem::ScCreateLVLeafItem"));
    t_itemChild *   pitem   = NULL;
    *ppitem = NULL;

    // What to do here?
    sc = ::ScCreateItem(pitemParent, pitemPrevious, &pitem, fNew);
    if (sc)
        return sc;

    *ppitem = pitem;

    return (sc);
}

// Initialize context menu structures. Let us have one item for demonstration.
SnapinMenuItem CComponent2TestSnapinLVLeafItem::s_rgmenuitemLVLeafItem[] =
{
    {IDS_NewLVItem, IDS_NewLVItem, IDS_NewLVItem, CCM_INSERTIONPOINTID_PRIMARY_TOP, NULL, dwMenuAlwaysEnable, dwMenuNeverGray,        dwMenuNeverChecked},
};

INT CComponent2TestSnapinLVLeafItem::s_cmenuitemLVLeafItem = CMENUITEM(s_rgmenuitemLVLeafItem);

// -----------------------------------------------------------------------------
SnapinMenuItem *CComponent2TestSnapinLVLeafItem::Pmenuitem(void)
{
    return s_rgmenuitemLVLeafItem;
}

// -----------------------------------------------------------------------------
INT CComponent2TestSnapinLVLeafItem::CMenuItem(void)
{
    return s_cmenuitemLVLeafItem;
}


//+-------------------------------------------------------------------
//
//  Member:      CComponent2TestSnapinLVLeafItem::ScCommand
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CComponent2TestSnapinLVLeafItem::ScCommand (long nCommandID, CComponent *pComponent)
{
    DECLARE_SC(sc, _T("CComponent2TestSnapinLVLeafItem::ScCommand"));

    switch(nCommandID)
    {
    case IDS_NewLVItem:
        sc = ScInsertResultItem(pComponent);
        break;

    default:
        sc = E_INVALIDARG;
        break;
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CComponent2TestSnapinLVLeafItem::ScQueryDispatch
//
//  Synopsis:    We support IDispatch for scripting, just return a pointer
//               to the IDispatch of ourselves.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CComponent2TestSnapinLVLeafItem::ScQueryDispatch(long cookie, DATA_OBJECT_TYPES type, LPDISPATCH *ppDispatch)
{
    DECLARE_SC(sc, _T("CComponent2TestSnapinLVLeafItem::ScQueryDispatch"));

    *ppDispatch = dynamic_cast<IDispatch *>(this);
    if (! *ppDispatch)
        return (sc = E_NOINTERFACE);

    (*ppDispatch)->AddRef();

    return sc;
}


HRESULT CComponent2TestSnapinLVLeafItem::StringFromScriptToSnapin(BSTR bstrMessage)
{
    DECLARE_SC(sc , _T("CComponent2TestSnapinLVLeafItem::StringFromScriptToSnapin"));

    // The script is supposed to give us this function name in the string.
    if (0 == _wcsicmp(bstrMessage, L"StringFromScriptToSnapin"))
        return sc.ToHr();

    sc = E_FAIL;

    return sc.ToHr();
}

HRESULT CComponent2TestSnapinLVLeafItem::StringFromSnapinToScript(BSTR *pbstrMessage)
{
    DECLARE_SC(sc , _T("CComponent2TestSnapinLVLeafItem::StringFromSnapinToScript"));
    sc = ScCheckPointers(pbstrMessage);
    if (sc)
        return sc.ToHr();

    // The script is supposed to expect this function name in the string.
    *pbstrMessage = ::SysAllocString(OLESTR("StringFromSnapinToScript"));

    return sc.ToHr();
}

HRESULT CComponent2TestSnapinLVLeafItem::get_Name(BSTR *pbstrMessage)
{
    DECLARE_SC(sc , _T("CComponent2TestSnapinLVLeafItem::get_Name"));
    sc = ScCheckPointers(pbstrMessage);
    if (sc)
        return sc.ToHr();

    // The script is supposed to expect this function name in the string.
    *pbstrMessage = ::SysAllocString(OLESTR("Name"));


    return sc.ToHr();
}

HRESULT CComponent2TestSnapinLVLeafItem::put_Name(BSTR bstrMessage)
{
    DECLARE_SC(sc , _T("CComponent2TestSnapinLVLeafItem::put_Name"));

    // The script is supposed to give us this function name in the string.
    if (0 == _wcsicmp(bstrMessage, L"Name"))
        return sc.ToHr();

    sc = E_FAIL;

    return sc.ToHr();
}


//-------------------------------------------------------------------------------------
// class CComponent2TestSnapin

#pragma BEGIN_CODESPACE_DATA
SNR     CComponent2TestSnapin::s_rgsnr[] =
{
    SNR(&nodetypeComponent2TestRoot,         snrEnumSP ),              // Standalone snapin.
    SNR(&nodetypeComponent2TestLVLeafItem,   snrEnumSP | snrEnumRP ),  // enumerates this node in the scope pane and result pane.
};

LONG  CComponent2TestSnapin::s_rgiconid[]           = {3};
LONG  CComponent2TestSnapin::s_iconidStatic         = 2;


CColumnInfoEx CComponent2TestSnapin::s_colinfo[] =
{
    CColumnInfoEx(_T("Column Name0"),   LVCFMT_LEFT,    180,    datString1),
    CColumnInfoEx(_T("Column Name1"),   LVCFMT_LEFT,    180,    datString2),
    CColumnInfoEx(_T("Column Name2"),   LVCFMT_LEFT,    180,    datString3),
};

INT CComponent2TestSnapin::s_ccolinfo = sizeof(s_colinfo) / sizeof(CColumnInfoEx);
INT CComponent2TestSnapin::s_colwidths[1];
#pragma END_CODESPACE_DATA

// include members needed for every snapin.
SNAPIN_DEFINE(CComponent2TestSnapin);

/* CComponent2TestSnapin::CComponent2TestSnapin
 *
 * PURPOSE:             Constructor
 *
 * PARAMETERS: None
 *
 */
CComponent2TestSnapin::CComponent2TestSnapin()
{
    m_pstrDisplayName = new tstring();

    *m_pstrDisplayName = _T("Component2Test Snapin Root");
}

/* CComponent2TestSnapin::~CComponent2TestSnapin
 *
 * PURPOSE:             Destructor
 *
 * PARAMETERS: None
 *
 */
CComponent2TestSnapin::~CComponent2TestSnapin()
{
    delete m_pstrDisplayName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\sample\dragdroptest.cpp ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       DragDropTest.cxx
//
//  Contents:   Classes that implement Drag & Drop tests using the framework.
//
//--------------------------------------------------------------------
#include "stdafx.hxx"

int CDragDropSnapinRootItem::s_iNextChildID = 0;

//+-------------------------------------------------------------------
//
//  Member:      CDragDropSnapinRootItem::ScInit
//
//  Synopsis:    Called immeadiately after the item is created to init
//               displayname, icon index etc...
//
//  Arguments:   [CBaseSnapin]   -
//               [CColumnInfoEx] - Any columns to be displayed for this item.
//               [INT]           - # of columns
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CDragDropSnapinRootItem::ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex, INT ccolinfoex, BOOL fIsRoot)
{
    DECLARE_SC(sc, _T("CDragDropSnapinRootItem::ScInit"));

    sc = CBaseSnapinItem::ScInit(pSnapin, pcolinfoex, ccolinfoex, fIsRoot);
    if (sc)
        return sc;

    // Init following
    //  a. Icon index.
    //  b. Load display name.

    m_uIconIndex = 3; // use an enum instead of 3
    m_strDisplayName.LoadString(_Module.GetResourceInstance(), IDS_DragDropRoot);

    tstring strItem;
    strItem.LoadString(_Module.GetResourceInstance(), IDS_DragDropScopeItem);
    int cChildren = 4; // child nodes.

    WTL::CString strTemp;
    for (int i = 0; i < cChildren; ++i)
    {
        strTemp.Format(_T("%s - %d"), strItem.data(), i);
        m_vecContainerItems.push_back((LPCTSTR)strTemp);
    }

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CDragDropSnapinRootItem::ScGetField
//
//  Synopsis:    Get the string representation for given field to display
//               it in result pane.
//
//  Arguments:   [DAT]     - The column requested (this is an enumeration).
//               [tstring] - Out string.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CDragDropSnapinRootItem::ScGetField (DAT dat, tstring& strField)
{
    DECLARE_SC(sc, _T("CDragDropSnapinRootItem::ScGetField"));

    switch(dat)
    {
    case datString1:
        strField = m_strDisplayName;
        break;

    case datString2:
        strField = _T("Root String2");
        break;

    case datString3:
        strField = _T("Root String3");
        break;

    default:
        E_INVALIDARG;
        break;
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CDragDropSnapinRootItem::ScCreateChildren
//
//  Synopsis:    Create any children (nodes & leaf items) for this item.
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CDragDropSnapinRootItem::ScCreateChildren ()
{
    DECLARE_SC(sc, _T("CDragDropSnapinRootItem::ScCreateChildren"));

    CDragDropSnapinLVContainer *   pitemChild      = NULL;
    CDragDropSnapinLVContainer *   pitemPrevious   = NULL;

    // Let us create child items for this container.
    StringVector::iterator itItem;

    // Create scope items for this container.
    for (itItem =  m_vecContainerItems.begin(); itItem  !=  m_vecContainerItems.end(); ++itItem, ++s_iNextChildID )
    {
        // Create the child nodes and init them.
        sc = CDragDropSnapinLVContainer::ScCreateLVContainer(this, pitemPrevious, &pitemChild, FALSE); // Why FALSE???
        if (sc)
            return sc;

        pitemPrevious = pitemChild;
        pitemChild->SetDisplayName(*itItem);
    }

    return (sc);
}

SC CDragDropSnapinRootItem::ScInitializeChild(CBaseSnapinItem* pitem)
{
	CDragDropSnapinLVContainer *pDDItem = dynamic_cast<CDragDropSnapinLVContainer*>(pitem);
	if (pDDItem)
		pDDItem->SetDisplayIndex(s_iNextChildID);
	
	return CBaseSnapinItem::ScInitializeChild(pitem);
}

// Initialize context menu structures. Let us have one item for demonstration.
SnapinMenuItem CDragDropSnapinRootItem::s_rgmenuitemRoot[] =
{
    {IDS_EnablePasteInToResultItem, IDS_EnablePasteInToResultItem, IDS_EnablePasteInToResultItem, CCM_INSERTIONPOINTID_PRIMARY_TOP, NULL, dwMenuAlwaysEnable, dwMenuNeverGray, 0},
    {IDS_DisableCut, IDS_DisableCut, IDS_DisableCut, CCM_INSERTIONPOINTID_PRIMARY_TOP, NULL, dwMenuAlwaysEnable, dwMenuNeverGray, 0},
};

INT CDragDropSnapinRootItem::s_cmenuitemRoot = CMENUITEM(s_rgmenuitemRoot);

// -----------------------------------------------------------------------------
SnapinMenuItem *CDragDropSnapinRootItem::Pmenuitem(void)
{
    return s_rgmenuitemRoot;
}

// -----------------------------------------------------------------------------
INT CDragDropSnapinRootItem::CMenuItem(void)
{
    return s_cmenuitemRoot;
}


//+-------------------------------------------------------------------
//
//  Member:      CDragDropSnapinRootItem::ScCommand
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CDragDropSnapinRootItem::ScCommand (long nCommandID, CComponent *pComponent)
{
    DECLARE_SC(sc, _T("CDragDropSnapinRootItem::ScCommand"));

    CDragDropSnapin *pDragDropSnapin = dynamic_cast<CDragDropSnapin*>(Psnapin());
    if (!pDragDropSnapin)
        return sc;

    switch(nCommandID)
    {
    case IDS_EnablePasteInToResultItem:
        {
            BOOL bEnabled = pDragDropSnapin->FPasteIntoResultPane();
            pDragDropSnapin->SetPasteIntoResultPane(!bEnabled);

            for (int i = 0; i < CMenuItem(); ++i)
            {
                if (s_rgmenuitemRoot[i].lCommandID == IDS_EnablePasteInToResultItem)
                    s_rgmenuitemRoot[i].dwFlagsChecked = (!bEnabled);
            }

        }
        break;

    case IDS_DisableCut:
        {
            BOOL bDisabled = pDragDropSnapin->FCutDisabled();
            pDragDropSnapin->SetCutDisabled(! bDisabled);

            for (int i = 0; i < CMenuItem(); ++i)
            {
                if (s_rgmenuitemRoot[i].lCommandID == IDS_DisableCut)
                    s_rgmenuitemRoot[i].dwFlagsChecked = (!bDisabled);
            }
        }
        break;

    default:
        sc = E_INVALIDARG;
        break;
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CDragDropSnapinLVContainer::ScInit
//
//  Synopsis:    Called immeadiately after the item is created to init
//               displayname, icon index etc...
//
//  Arguments:   [CBaseSnapin]   -
//               [CColumnInfoEx] - Any columns to be displayed for this item.
//               [INT]           - # of columns
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CDragDropSnapinLVContainer::ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex, INT ccolinfoex, BOOL fIsRoot)
{
    DECLARE_SC(sc, _T("CDragDropSnapinLVContainer::ScInit"));

    sc = CBaseSnapinItem::ScInit(pSnapin, pcolinfoex, ccolinfoex, fIsRoot);
    if (sc)
        return sc;

    // Init following
    //  a. Icon index.
    //  b. Load display name.

    m_uIconIndex = 4; // use an enum instead of 4

    m_strDisplayName = _T("None");

    tstring strLeafItem;
    strLeafItem.LoadString(_Module.GetResourceInstance(), IDS_DragDropResultItem);
    int cLeafItems = 4;

    WTL::CString strTemp;
    for (int i = 0; i < cLeafItems; ++i)
    {
        strTemp.Format(_T("%s - [%d : %d]"), strLeafItem.data(), m_index, i);
        m_vecLeafItems.push_back((LPCTSTR)strTemp);
    }

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CDragDropSnapinLVContainer::ScGetField
//
//  Synopsis:    Get the string representation for given field to display
//               it in result pane.
//
//  Arguments:   [DAT]     - The column requested (this is an enumeration).
//               [tstring] - Out string.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CDragDropSnapinLVContainer::ScGetField (DAT dat, tstring& strField)
{
    DECLARE_SC(sc, _T("CDragDropSnapinLVContainer::ScGetField"));

    switch(dat)
    {
    case datString1:
        strField = m_strDisplayName;
        break;

    case datString2:
        strField = _T("None");
        break;

    default:
        E_INVALIDARG;
        break;
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CDragDropSnapinLVContainer::ScCreateChildren
//
//  Synopsis:    Create any children (nodes & leaf items) for this item.
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CDragDropSnapinLVContainer::ScCreateChildren ()
{
    DECLARE_SC(sc, _T("CDragDropSnapinLVContainer::ScCreateChildren"));

    CDragDropSnapinLVContainer*   pitem           = NULL;
    CDragDropSnapinLVLeafItem *   pitemChild      = NULL;
    CBaseSnapinItem *             pitemPrevious   = NULL;

    StringVector::iterator itItem;

	int index = 0;
    // Create scope items for this container.
    for (itItem =  m_vecContainerItems.begin(); itItem  !=  m_vecContainerItems.end(); ++itItem, ++index )
    {
        // Create the child nodes and init them.
        sc = CDragDropSnapinLVContainer::ScCreateLVContainer(this, NULL, &pitem, FALSE); // Why FALSE???
        if (sc)
            return sc;

        pitem->SetDisplayName(*itItem);
		pitem->SetDisplayIndex(index);

        pitemPrevious = pitem;
    }

    // Create leaf items for this container.
    for (itItem  =  m_vecLeafItems.begin(); itItem  !=  m_vecLeafItems.end(); ++itItem )
    {
        // Create the child nodes and init them.
        sc = CDragDropSnapinLVLeafItem::ScCreateLVLeafItem(this, pitemPrevious, &pitemChild, FALSE); // Why FALSE???
        if (sc)
            return sc;

        pitemChild->SetDisplayName(*itItem );

        pitemPrevious = pitemChild;
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CDragDropSnapinLVContainer::ScCreateLVContainer
//
//  Synopsis:    Do we really need this method?
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CDragDropSnapinLVContainer::ScCreateLVContainer(CBaseSnapinItem *pitemParent, CBaseSnapinItem *pitemPrevious, CDragDropSnapinLVContainer ** ppitem, BOOL fNew)
{
    DECLARE_SC(sc, _T("CDragDropSnapinRootItem::ScCreateLVContainer"));
    t_item *   pitem   = NULL;
    *ppitem = NULL;

    // What to do here?
    sc = ::ScCreateItem(pitemParent, pitemPrevious, &pitem, fNew);
    if (sc)
        return sc;

    *ppitem = pitem;

    return (sc);
}

SC CDragDropSnapinLVContainer::ScOnSelect(CComponent * pComponent, LPDATAOBJECT lpDataObject, BOOL fScope, BOOL fSelect)
{
    DECLARE_SC(sc, TEXT("CDragDropSnapinLVContainer::ScOnSelect"));
    sc = ScCheckPointers(pComponent);
    if (sc)
        return sc;

    CDragDropSnapin *pDragDropSnapin = dynamic_cast<CDragDropSnapin*>(Psnapin());
    if (!pDragDropSnapin)
        return S_OK;


    IConsoleVerb *pConsoleVerb = pComponent->IpConsoleVerb();
    sc = pConsoleVerb ? pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, !pDragDropSnapin->FCutDisabled()) : E_UNEXPECTED;

    return (sc);
}

SC CDragDropSnapinLVContainer::ScOnQueryPaste(LPDATAOBJECT pDataObject, BOOL *pfCanPaste)
{
	DECLARE_SC(sc, _T("CDragDropSnapinLVContainer::ScOnQueryPaste"));
	sc = ScCheckPointers(pDataObject, pfCanPaste);
	if (sc)
		return sc;

	*pfCanPaste  = FALSE;

	CLSID guidNodeType;
	sc = ScGetNodeType(pDataObject, &guidNodeType);
	if (sc)
		return sc;

	if (IsEqualGUID(guidNodeType, clsidNodeTypeDragDropLVContainer) || 
	    IsEqualGUID(guidNodeType, clsidNodeTypeDragDropLVLeafItem) )
	{
	    *pfCanPaste = TRUE;
		return (sc = S_OK);
	}

	return (sc = S_FALSE);
}

SC CDragDropSnapinLVContainer::ScOnPaste(LPDATAOBJECT pDataObject, BOOL fMove, BOOL *pfPasted)
{
    DECLARE_SC(sc, TEXT("CDragDropSnapinLVContainer::ScOnPaste"));
	sc = ScCheckPointers(pDataObject, pfPasted);
	if (sc)
		return sc;

    *pfPasted = FALSE;

	CLSID guidNodeType;
	sc = ScGetNodeType(pDataObject, &guidNodeType);
	if (sc)
		return sc;

	tstring strDispName;
	sc = ScGetDisplayName(pDataObject, strDispName);
	if (sc)
		return sc;

	if (IsEqualGUID(guidNodeType, clsidNodeTypeDragDropLVContainer) )
	{
		m_vecContainerItems.push_back(strDispName);
	}
	else if (IsEqualGUID(guidNodeType, clsidNodeTypeDragDropLVLeafItem) )
	{
		m_vecLeafItems.push_back(strDispName);
	}
	else
		return (sc = S_FALSE);

    *pfPasted = TRUE;

    return sc;
}

BOOL CDragDropSnapinLVContainer::FAllowPasteForResultItems()
{
    CDragDropSnapin *pDragDropSnapin = dynamic_cast<CDragDropSnapin*>(Psnapin());
    if (!pDragDropSnapin)
        return FALSE;

    return pDragDropSnapin->FPasteIntoResultPane();

}

SC CDragDropSnapinLVContainer::ScOnCutOrMove()
{
    DECLARE_SC(sc, TEXT("CDragDropSnapinLVContainer::ScOnCutOrMove"));

	LPDATAOBJECT pDataObject = dynamic_cast<LPDATAOBJECT>(this);
	sc = ScCheckPointers(pDataObject, E_UNEXPECTED);
	if (sc)
		return sc;

	tstring strDispName;
	sc = ScGetDisplayName(pDataObject, strDispName);
	if (sc)
		return sc;

	CDragDropSnapinLVContainer *pitemParent = dynamic_cast<CDragDropSnapinLVContainer*>(PitemParent());
	sc = ScCheckPointers(pitemParent, E_UNEXPECTED);
	if (! sc.IsError())
	{
		sc = pitemParent->_ScDeleteCutItem(strDispName, true);
		return sc;
	}

	CDragDropSnapinRootItem *pRootitem= dynamic_cast<CDragDropSnapinRootItem*>(PitemParent());
	sc = ScCheckPointers(pRootitem, E_UNEXPECTED);
	if (sc)
		return sc;

	sc = pRootitem->_ScDeleteCutItem(strDispName);

	return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CDragDropSnapinLVLeafItem::ScInit
//
//  Synopsis:    Called immeadiately after the item is created to init
//               displayname, icon index etc...
//
//  Arguments:   [CBaseSnapin]   -
//               [CColumnInfoEx] - Any columns to be displayed for this item.
//               [INT]           - # of columns
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CDragDropSnapinLVLeafItem::ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex, INT ccolinfoex, BOOL fIsRoot)
{
    DECLARE_SC(sc, _T("CDragDropSnapinLVLeafItem::ScInit"));

    sc = CBaseSnapinItem::ScInit(pSnapin, pcolinfoex, ccolinfoex, fIsRoot);
    if (sc)
        return sc;

    // Init following
    //  a. Icon index.
    //  b. Load display name.

    m_uIconIndex = 7; // use an enum instead of 7

    m_strDisplayName = m_strItemPasted = _T("None");

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CDragDropSnapinLVLeafItem::ScGetField
//
//  Synopsis:    Get the string representation for given field to display
//               it in result pane.
//
//  Arguments:   [DAT]     - The column requested (this is an enumeration).
//               [tstring] - Out string.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CDragDropSnapinLVLeafItem::ScGetField (DAT dat, tstring& strField)
{
    DECLARE_SC(sc, _T("CDragDropSnapinLVLeafItem::ScGetField"));

    switch(dat)
    {
    case datString1:
        strField = m_strDisplayName;
        break;

    case datString2:
        strField = m_strItemPasted;
        break;

    default:
        E_INVALIDARG;
        break;
    }

    return (sc);
}



//+-------------------------------------------------------------------
//
//  Member:      CDragDropSnapinLVLeafItem::ScCreateLVLeafItem
//
//  Synopsis:    Do we really need this method?
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CDragDropSnapinLVLeafItem::ScCreateLVLeafItem(CBaseSnapinItem *pitemParent, CBaseSnapinItem * pitemPrevious, CDragDropSnapinLVLeafItem ** ppitem, BOOL fNew)
{
    DECLARE_SC(sc, _T("CDragDropSnapinLVLeafItem::ScCreateLVLeafItem"));
    t_itemChild *   pitem   = NULL;
    *ppitem = NULL;

    // What to do here?
    sc = ::ScCreateItem(pitemParent, pitemPrevious, &pitem, fNew);
    if (sc)
        return sc;

    *ppitem = pitem;

    return (sc);
}

SC CDragDropSnapinLVLeafItem::ScOnQueryPaste(LPDATAOBJECT pDataObject, BOOL *pfCanPaste)
{
	DECLARE_SC(sc, TEXT("CDragDropSnapinLVLeafItem::ScOnQueryPaste"));
	sc = ScCheckPointers(pDataObject, pfCanPaste);
	if (sc)
		return sc;

	*pfCanPaste  = FALSE;

	CLSID guidNodeType;
	sc = ScGetNodeType(pDataObject, &guidNodeType);
	if (sc)
		return sc;

	if (IsEqualGUID(guidNodeType, clsidNodeTypeDragDropLVContainer) || 
	    IsEqualGUID(guidNodeType, clsidNodeTypeDragDropLVLeafItem) )
	{
		CDragDropSnapin *pDragDropSnapin = dynamic_cast<CDragDropSnapin*>(Psnapin());
		if (!pDragDropSnapin)
			return S_OK;

	    *pfCanPaste = pDragDropSnapin->FPasteIntoResultPane();
		return (sc = S_OK);
	}

	return (sc = S_FALSE);
}

SC CDragDropSnapinLVLeafItem::ScGetVerbs(DWORD * pdwVerbs)
{
    *pdwVerbs = vmDelete | vmCopy | vmRename;

    CDragDropSnapin *pDragDropSnapin = dynamic_cast<CDragDropSnapin*>(Psnapin());
    if (!pDragDropSnapin)
        return S_OK;

    if (pDragDropSnapin->FPasteIntoResultPane())
        *pdwVerbs |= vmPaste;

    return S_OK;
}


SC CDragDropSnapinLVLeafItem::ScOnSelect(CComponent * pComponent, LPDATAOBJECT lpDataObject, BOOL fScope, BOOL fSelect)
{
    DECLARE_SC(sc, TEXT("CDragDropSnapinLVLeafItem::ScOnSelect"));
    sc = ScCheckPointers(pComponent);
    if (sc)
        return sc;

    CDragDropSnapin *pDragDropSnapin = dynamic_cast<CDragDropSnapin*>(Psnapin());
    if (!pDragDropSnapin)
        return S_OK;

    IConsoleVerb *pConsoleVerb = pComponent->IpConsoleVerb();
    sc = pConsoleVerb ? pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, !pDragDropSnapin->FCutDisabled()) : E_UNEXPECTED;

    return (sc);
}

SC CDragDropSnapinLVLeafItem::ScOnPaste(LPDATAOBJECT pDataObject, BOOL fMove, BOOL *pfPasted)
{
    DECLARE_SC(sc, TEXT("CDragDropSnapinLVLeafItem::ScOnPaste"));
	sc = ScCheckPointers(pDataObject, pfPasted);
    *pfPasted = FALSE;

	CLSID guidNodeType;
	sc = ScGetNodeType(pDataObject, &guidNodeType);
	if (sc)
		return sc;

	tstring strDispName;
	sc = ScGetDisplayName(pDataObject, strDispName);
	if (sc)
		return sc;

	if (IsEqualGUID(guidNodeType, clsidNodeTypeDragDropLVContainer) ||
		IsEqualGUID(guidNodeType, clsidNodeTypeDragDropLVLeafItem) )
	{
		m_strItemPasted = strDispName;
	}
	else
		return (sc = S_FALSE);

    *pfPasted = TRUE;

    return sc;
}

SC CDragDropSnapinLVLeafItem::ScOnCutOrMove()
{
    DECLARE_SC(sc, TEXT("CDragDropSnapinLVLeafItem::ScOnCutOrMove"));

	LPDATAOBJECT pDataObject = dynamic_cast<LPDATAOBJECT>(this);
	sc = ScCheckPointers(pDataObject, E_UNEXPECTED);
	if (sc)
		return sc;

	tstring strDispName;
	sc = ScGetDisplayName(pDataObject, strDispName);
	if (sc)
		return sc;

	CDragDropSnapinLVContainer *pitemParent = dynamic_cast<CDragDropSnapinLVContainer*>(PitemParent());
	sc = ScCheckPointers(pitemParent, E_UNEXPECTED);
	if (sc)
		return sc;

	sc = pitemParent->_ScDeleteCutItem(strDispName, false);

	return sc;
}

//-------------------------------------------------------------------------------------
// class CDragDropSnapin

#pragma BEGIN_CODESPACE_DATA
SNR     CDragDropSnapin::s_rgsnr[] =
{
    SNR(&nodetypeDragDropRoot,         snrEnumSP ),              // Standalone snapin.
    SNR(&nodetypeDragDropLVContainer,  snrEnumSP | snrEnumRP | snrPaste),  // enumerates this node in the scope pane and result pane.
    SNR(&nodetypeDragDropLVLeafItem,   snrEnumSP | snrEnumRP | snrPaste),  // enumerates this node in the scope pane and result pane.
};

LONG  CDragDropSnapin::s_rgiconid[]           = {3};
LONG  CDragDropSnapin::s_iconidStatic         = 2;


CColumnInfoEx CDragDropSnapin::s_colinfo[] =
{
    CColumnInfoEx(_T("Name"),   LVCFMT_LEFT,    250,    datString1),
    CColumnInfoEx(_T("Last Cut/Copy/Paste operation"),   LVCFMT_LEFT,    180,    datString2),
};

INT CDragDropSnapin::s_ccolinfo = sizeof(s_colinfo) / sizeof(CColumnInfoEx);
INT CDragDropSnapin::s_colwidths[1];
#pragma END_CODESPACE_DATA

// include members needed for every snapin.
SNAPIN_DEFINE( CDragDropSnapin);

/* CDragDropSnapin::CDragDropSnapin
 *
 * PURPOSE:             Constructor
 *
 * PARAMETERS: None
 *
 */
CDragDropSnapin::CDragDropSnapin()
{
    m_pstrDisplayName = new tstring();

    *m_pstrDisplayName = _T("DragDrop Snapin Root");
}

/* CDragDropSnapin::~CDragDropSnapin
 *
 * PURPOSE:             Destructor
 *
 * PARAMETERS: None
 *
 */
CDragDropSnapin::~CDragDropSnapin()
{
    delete m_pstrDisplayName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\sample\extension.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      extension.cpp
 *
 *  Contents:
 *
 *  History:   13-Mar-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.hxx"
#include "Extension.h"


static const WCHAR szRegistrationScript[] =
    L"HKCR"                                                                     L"\n"
    L"{"                                                                        L"\n"
    L"    %VProgID% = s '%VClassName%'"                                         L"\n"
    L"    {"                                                                    L"\n"
    L"        CLSID = s '%VCLSID%'"                                             L"\n"
    L"    }"                                                                    L"\n"
    L"    %VVersionIndependentProgID% = s '%VClassName%'"                       L"\n"
    L"    {"                                                                    L"\n"
    L"        CurVer = s '%VProgID%'"                                           L"\n"
    L"    }"                                                                    L"\n"
    L"    NoRemove CLSID"                                                       L"\n"
    L"    {"                                                                    L"\n"
    L"        ForceRemove %VCLSID% = s '%VClassName%'"                          L"\n"
    L"        {"                                                                L"\n"
    L"            ProgID = s '%VProgID%'"                                       L"\n"
    L"            VersionIndependentProgID = s '%VVersionIndependentProgID%'"   L"\n"
    L"            InprocServer32 = s '%VModule%'"                               L"\n"
    L"            {"                                                            L"\n"
    L"                val ThreadingModel = s 'Apartment'"                       L"\n"
    L"            }"                                                            L"\n"
    L"        }"                                                                L"\n"
    L"    }"                                                                    L"\n"
    L"}"                                                                        L"\n"
    L"HKLM"                                                                     L"\n"
    L"{"                                                                        L"\n"
    L"    NoRemove Software"                                                    L"\n"
    L"    {"                                                                    L"\n"
    L"        NoRemove Microsoft"                                               L"\n"
    L"        {"                                                                L"\n"
    L"            NoRemove MMC"                                                 L"\n"
    L"            {"                                                            L"\n"
    L"                NoRemove SnapIns"                                         L"\n"
    L"                {"                                                        L"\n"
    L"                    ForceRemove %VCLSID%"                                 L"\n"
    L"                    {"                                                    L"\n"
    L"                        val NameString = s '%VSnapinName%'"               L"\n"
    L"                    }"                                                    L"\n"
    L"                }"                                                        L"\n"
    L"                NoRemove NodeTypes"                                       L"\n"
    L"                {"                                                        L"\n"
    L"                    NoRemove %VExtendedNodeType%"                         L"\n"
    L"                    {"                                                    L"\n"
    L"                        NoRemove Extensions"                              L"\n"
    L"                        {"                                                L"\n"
    L"                            NoRemove %VExtensionType%"                    L"\n"
    L"                            {"                                            L"\n"
    L"                                val %VCLSID% = s '%VClassName%'"          L"\n"
    L"                            }"                                            L"\n"
    L"                        }"                                                L"\n"
    L"                    }"                                                    L"\n"
    L"                }"                                                        L"\n"
    L"            }"                                                            L"\n"
    L"        }"                                                                L"\n"
    L"    }"                                                                    L"\n"
    L"}";


/*+-------------------------------------------------------------------------*
 * CExtension::UpdateRegistry
 *
 *
 *--------------------------------------------------------------------------*/

HRESULT WINAPI CExtension::UpdateRegistry (
	BOOL			bRegister,
	ExtensionType	eExtType,
	const CLSID&	clsidSnapIn,	
	LPCWSTR			pszClassName,
	LPCWSTR			pszProgID,
	LPCWSTR			pszVersionIndependentProgID,
	LPCWSTR			pszExtendedNodeType)
{
    DECLARE_SC (sc, _T("CExtension::UpdateRegistry"));

	if ((eExtType < eExtType_First) || (eExtType > eExtType_Last))
		return ((sc = E_INVALIDARG).ToHr());

    /*
     * string-ify the CLSID
     */
    CCoTaskMemPtr<WCHAR> spszClsid;
    sc = StringFromCLSID (clsidSnapIn, &spszClsid);
    if (sc)
        return sc.ToHr();

    static const LPCWSTR rgExtTypes[eExtType_Count] =
    {
        L"Namespace",       // eExtType_Namespace
        L"ContextMenu",     // eExtType_ContextMenu
        L"PropertySheet",   // eExtType_PropertySheet
        L"Taskpad",         // eExtType_Taskpad
        L"View",			// eExtType_View
    };

	/*
	 * get the filename for the module
	 */
	USES_CONVERSION;
	TCHAR szModule[_MAX_PATH];
	GetModuleFileName (_Module.GetModuleInstance(), szModule, countof(szModule));

    /*
     * specify the standard object substitution parameters for CRegObject
     */
    ::ATL::ATL::CRegObject ro;  // hack around nested namespace bug in ATL30
    _ATL_REGMAP_ENTRY rgObjEntries[] =
    {
        {   L"VModule",                   T2W(szModule)                 },
        {   L"VCLSID",                    spszClsid                     },
        {   L"VExtendedNodeType",         pszExtendedNodeType          	},
        {   L"VClassName",                pszClassName                  },
        {   L"VProgID",                   pszProgID                     },
        {   L"VVersionIndependentProgID", pszVersionIndependentProgID   },
        {   L"VExtensionType",            rgExtTypes[eExtType]			},
        {   L"VSnapinName",               pszClassName}
    };

    for (int i = 0; i < countof (rgObjEntries); i++)
    {
        sc = ro.AddReplacement (rgObjEntries[i].szKey, rgObjEntries[i].szData);
        if (sc)
            return (sc.ToHr());
    }

    /*
     * (un)register!
     */
    sc = (bRegister) ? ro.StringRegister   (szRegistrationScript)
                     : ro.StringUnregister (szRegistrationScript);

    return sc.ToHr();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\sample\dragdroptest.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       dragdroptest.hxx
//
//  Contents:   Classes that implement Drag&Drop test snapin using the framework.
//
//--------------------------------------------------------------------
#ifndef _DRAGDROPTEST_H_
#define _DRAGDROPTEST_H_

// Forward declarations.
class CDragDropSnapinLVContainer;
class CDragDropSnapinLVLeafItem;
class CDragDropSnapin;

typedef vector<tstring>  StringVector;

//+-------------------------------------------------------------------
//
//  Class:      CDragDropSnapinRootItem
//
//  Purpose:    Implements the root item for a standalone snapin.
//
//--------------------------------------------------------------------
class CDragDropSnapinRootItem : public CBaseSnapinItem
{
    typedef          CBaseSnapinItem super;

    // Used by CBaseSnapinItem::ScCreateItem, connect this item with its children.
    typedef          CComObject<CSnapinItem<CDragDropSnapinRootItem> >          t_item;
    typedef          CComObject<CSnapinItem<CDragDropSnapinLVContainer> > t_itemChild; // Who is my child?

public:
    CDragDropSnapinRootItem( void )   {} // Raw constructor - use only for static item.
    virtual          ~CDragDropSnapinRootItem( void ) {}

    BEGIN_COM_MAP(CDragDropSnapinRootItem)
        COM_INTERFACE_ENTRY(IDataObject) // Cant have empty map so add IDataObject
    END_COM_MAP()

protected:
    // Item tree related information

    // node type related information
    virtual const CNodeType* Pnodetype( void )     { return &nodetypeDragDropRoot;}

    // the display name of the item
    virtual const tstring* PstrDisplayName( void ) { return &m_strDisplayName;}

    // Get ListView data (GetDisplayInfo calls this).
    virtual SC       ScGetField(DAT dat, tstring& strField);

    // Image list information
    virtual LONG     Iconid() { return m_uIconIndex; }
    virtual LONG     OpenIconid() { return m_uIconIndex; }

    virtual BOOL     FIsContainer( void ) { return TRUE; }

    // Context menu support
    virtual SnapinMenuItem *Pmenuitem(void);
    virtual INT             CMenuItem(void);
    virtual SC              ScCommand(long nCommandID, CComponent *pComponent = NULL);
    virtual DWORD           DwFlagsMenuChecked(void)          { return TRUE;}

public:
    virtual SC       ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex = NULL, INT ccolinfoex = 0, BOOL fIsRoot = FALSE);
	virtual SC       ScInitializeChild(CBaseSnapinItem* pitem);

public:
    // Creates children for the node
    virtual SC       ScCreateChildren( void );
    void             SetDisplayName(tstring & strItemName) { m_strDisplayName = strItemName; }
	SC       _ScDeleteCutItem(tstring& strItemName)
	{
		StringVector::iterator itItem = std::find(m_vecContainerItems.begin(),
			                                      m_vecContainerItems.end(),
												  strItemName);
		if (itItem == m_vecContainerItems.end())
			return S_FALSE;

		m_vecContainerItems.erase(itItem);

		return S_OK;
	}

protected:
    virtual SC       ScGetVerbs(DWORD * pdwVerbs)     { *pdwVerbs = 0; return S_OK;}

protected:
    tstring          m_strDisplayName;
    UINT             m_uIconIndex;

    StringVector     m_vecContainerItems;
	static int       s_iNextChildID;

    // For context menus
    static SnapinMenuItem  s_rgmenuitemRoot[];
    static INT             s_cmenuitemRoot;
};


//+-------------------------------------------------------------------
//
//  Class:      CDragDropSnapinLVContainer
//
//  Purpose:    Implements a scope pane item.
//
//--------------------------------------------------------------------
class CDragDropSnapinLVContainer : public CBaseSnapinItem
{
    typedef          CBaseSnapinItem super;

    // Used by CBaseSnapinItem::ScCreateItem, connect this item with its children.
    typedef          CComObject<CSnapinItem<CDragDropSnapinLVContainer> > t_item;
    typedef          CComObject<CSnapinItem<CDragDropSnapinLVLeafItem> >  t_itemChild;

public:
    CDragDropSnapinLVContainer( void ) {}
    virtual          ~CDragDropSnapinLVContainer( void ) {}

    BEGIN_COM_MAP(CDragDropSnapinLVContainer)
        COM_INTERFACE_ENTRY(IDataObject) // Cant have empty map so add IDataObject
    END_COM_MAP()
protected:
    // Item tree related information

    // node type related information
    const CNodeType *Pnodetype( void )                { return &nodetypeDragDropLVContainer;}

    // the display name of the item
    virtual const tstring*    PstrDisplayName( void ) { return &m_strDisplayName;}

    // Get ListView data (GetDisplayInfo calls this).
    virtual SC                ScGetField(DAT dat, tstring& strField);

    // Image list information
    virtual LONG     Iconid()     { return m_uIconIndex; }
    virtual LONG     OpenIconid() { return m_uIconIndex; }

    // This item attributes.
    virtual BOOL     FIsContainer( void ) { return TRUE; }
    virtual BOOL     FAllowMultiSelectionForChildren() { return TRUE;}
    virtual BOOL     FAllowPasteForResultItems();

public:
    virtual SC       ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex = NULL, INT ccolinfoex = 0, BOOL fIsRoot = FALSE);

public:
    // Creates children for the node
    virtual SC       ScCreateChildren( void );
    static  SC       ScCreateLVContainer(CBaseSnapinItem *pitemParent, CBaseSnapinItem *pitemPrevious, CDragDropSnapinLVContainer ** ppitem, BOOL fNew);
    void             SetDisplayName(tstring & strItemName) { m_strDisplayName = strItemName;}
    void             SetDisplayIndex(int index) { m_index = index;}
	SC       _ScDeleteCutItem(tstring& strItemName, bool bContainerItem)
	{
		StringVector::iterator itItem;
		StringVector& vecStrings = bContainerItem ? m_vecContainerItems : m_vecLeafItems;

		itItem = std::find(vecStrings.begin(), vecStrings.end(), strItemName);
		if (itItem == vecStrings.end())
			return S_FALSE;

		vecStrings.erase(itItem);

		return S_OK;
	}

public: // Notification handlers
    virtual SC       ScOnQueryPaste(LPDATAOBJECT pDataObject, BOOL *pfCanPaste);
    virtual SC       ScOnDelete(BOOL *pfDeleted)                                        { *pfDeleted = TRUE; return S_OK;}
    virtual SC       ScOnSelect(CComponent * pComponent, LPDATAOBJECT lpDataObject, BOOL fScope, BOOL fSelect);
    virtual SC       ScOnPaste(LPDATAOBJECT pDataObject, BOOL fMove, BOOL *pfPasted);
	virtual SC       ScOnCutOrMove();

protected:
    virtual SC       ScGetVerbs(DWORD * pdwVerbs)     { *pdwVerbs = vmCopy | vmDelete | vmPaste; return S_OK;}

protected:
    tstring          m_strDisplayName;
	int              m_index; // ID given by container of this item.
    UINT             m_uIconIndex;

    StringVector     m_vecContainerItems;
    StringVector     m_vecLeafItems;
};


//+-------------------------------------------------------------------
//
//  Class:      CDragDropSnapinLVLeafItem
//
//  Purpose:    Implements a result pane item.
//
//--------------------------------------------------------------------
class CDragDropSnapinLVLeafItem : public CBaseSnapinItem
{
    typedef          CBaseSnapinItem super;

    // Used by CBaseSnapinItem::ScCreateItem, connect this item with its children.
    // This is a leaf item so this item acts as its child.
    typedef          CComObject<CSnapinItem<CDragDropSnapinLVLeafItem> > t_item;
    typedef          CComObject<CSnapinItem<CDragDropSnapinLVLeafItem> > t_itemChild;

public:
    CDragDropSnapinLVLeafItem( void ) {}
    virtual          ~CDragDropSnapinLVLeafItem( void ) {}

    BEGIN_COM_MAP(CDragDropSnapinLVLeafItem)
        COM_INTERFACE_ENTRY(IDataObject) // Cant have empty map so add IDataObject
    END_COM_MAP()
protected:
    // Item tree related information

    // node type related information
    virtual const CNodeType *Pnodetype( void ) {return &nodetypeDragDropLVLeafItem;}

    // the display name of the item
    virtual const tstring* PstrDisplayName( void ) { return &m_strDisplayName; }

    // Get ListView data (GetDisplayInfo calls this).
    virtual SC       ScGetField(DAT dat, tstring& strField);

    // Image list information
    virtual LONG     Iconid() { return m_uIconIndex; }

    virtual BOOL     FIsContainer( void ) { return FALSE; }

public:
    virtual SC       ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex = NULL, INT ccolinfoex = 0, BOOL fIsRoot = FALSE);

public:
    static SC        ScCreateLVLeafItem(CBaseSnapinItem *pitemParent, CBaseSnapinItem * pitemPrevious, CDragDropSnapinLVLeafItem ** ppitem, BOOL fNew);
    void             SetDisplayName(tstring & strItemName) { m_strDisplayName = strItemName; }

public: // Notification handlers
    virtual SC       ScOnQueryPaste(LPDATAOBJECT pDataObject, BOOL *pfCanPaste);
    virtual SC       ScOnDelete(BOOL *pfDeleted)         { *pfDeleted = TRUE; return S_OK;}
    virtual SC       ScOnSelect(CComponent * pComponent, LPDATAOBJECT lpDataObject, BOOL fScope, BOOL fSelect);
    virtual SC       ScOnPaste(LPDATAOBJECT pDataObject, BOOL fMove, BOOL *pfPasted);
	virtual SC       ScOnCutOrMove();
    virtual SC       ScOnRename(const tstring& strNewName)   { m_strDisplayName = strNewName; return S_OK;}

protected:
    virtual SC       ScGetVerbs(DWORD * pdwVerbs);

private:
    tstring          m_strDisplayName;
    UINT             m_uIconIndex;

    tstring          m_strItemPasted;
};


//+-------------------------------------------------------------------
//
//  Class:      CDragDropSnapin
//
//  Purpose:    Implements a snapin.
//
//--------------------------------------------------------------------
class CDragDropSnapin : public CBaseSnapin
{
    // Specify the root node of the snapin.
    typedef          CComObject<CSnapinItem<CDragDropSnapinRootItem> > t_itemRoot;

    SNAPIN_DECLARE(CDragDropSnapin);

public:
                     CDragDropSnapin();
    virtual          ~CDragDropSnapin();

    // information about the snapin and root (ie initial) node
    virtual BOOL     FStandalone()  { return TRUE; }
    virtual BOOL     FIsExtension() { return FALSE; }

    virtual BOOL     FSupportsIComponent2() {return TRUE;}

    virtual LONG     IdsDescription(void)   {return IDS_DragDropSnapinDesc;}
    virtual LONG     IdsName(void)          {return IDS_DragDropSnapinName;}

    const CSnapinInfo* Psnapininfo() { return &snapininfoDragDrop; }

    BOOL             FCutDisabled()         {return m_bDisableCut;}
    BOOL             FPasteIntoResultPane() {return m_bPasteIntoResultPane;}

    void             SetCutDisabled(BOOL b) {m_bDisableCut = b;}
    void             SetPasteIntoResultPane(BOOL b) {m_bPasteIntoResultPane = b;}

protected:
    // The column header info structures.
    static  CColumnInfoEx     s_colinfo[];
    static  INT      s_colwidths[];
    static  INT      s_ccolinfo;

protected:
    virtual CColumnInfoEx*    Pcolinfoex(INT icolinfo=0) { return s_colinfo + icolinfo; }
    virtual INT     &ColumnWidth(INT icolwidth=0) { return s_colwidths[icolwidth]; }
    virtual INT      Ccolinfoex() { return s_ccolinfo; }

private:
    BOOL              m_bDisableCut;
    BOOL              m_bPasteIntoResultPane;
};

#endif  //_DRAGDROPTEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\sample\nodetypes.cxx ===
/*
 *      nodetypes.cxx
 *
 *
 *      Copyright (c) 1998 Microsoft Corporation
 *
 *      PURPOSE:        Instantiates all guids, nodetypes etc.
 *
 *
 *      OWNER:          vivekj
 */

#include <stdafx.hxx>
#include <objbase.h>
#include <initguid.h>

//--------------------------------------------------------------------------
// Collect all the Snapin CLSIDs.

// DO NOT CHANGE THE COMMENT ON THE NEXT LINE
//-----------------_SUBSYSTEM_-----------------

#include "TestSnapins.h"
#include "TestSnapins_i.c"

//--------------------------------------------------------------------------
// This instantiates all the nodetypes
#define DEFINE_CONST
#include <nodetypes.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\sample\extension.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      extension.h
 *
 *  Contents:
 *
 *  History:   13-Mar-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once

class CExtension :
    public CComObjectRoot
{
protected:
    enum ExtensionType
    {
        eExtType_Namespace,
        eExtType_ContextMenu,
        eExtType_PropertySheet,
        eExtType_Taskpad,
        eExtType_View,

        // must be last
        eExtType_Count,
		eExtType_First = eExtType_Namespace,
		eExtType_Last  = eExtType_View,
    };

protected:
    static HRESULT WINAPI UpdateRegistry (
		BOOL			bRegister,
		ExtensionType	eType,
		const CLSID&	clsidSnapIn,
		LPCWSTR			pszClassName,
		LPCWSTR			pszProgID,
		LPCWSTR			pszVersionIndependentProgID,
		LPCWSTR			pszExtendedNodeType);
};

#define DECLARE_EXTENSION_REGISTRATION(                           	\
	eType,															\
    clsid,                                                          \
    szClassName,                                                    \
    szProgID,                                                       \
    szVersionIndependentProgID,                                     \
    szExtendedNodeType)                                             \
public: static HRESULT WINAPI UpdateRegistry(BOOL bRegister)        \
{                                                                   \
    return (CExtension::UpdateRegistry (                            \
				bRegister,                                          \
				eType,                                              \
				clsid,                                              \
				OLESTR(szClassName),                                \
				OLESTR(szProgID),                                   \
				OLESTR(szVersionIndependentProgID),                 \
				OLESTR(szExtendedNodeType)));                       \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\sample\ocxcaching.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       ocxcaching.h
//
//  Contents:   Classes that implement OCX caching snapin using the framework.
//
//--------------------------------------------------------------------
#ifndef _OCXCACHING_H_
#define _OCXCACHING_H_

// Forward declarations.
class COCXContainer;

//+-------------------------------------------------------------------
//
//  Class:      COCXCachingSnapinRootItem
//
//  Purpose:    Implements the root item for a standalone snapin.
//
//--------------------------------------------------------------------
class COCXCachingSnapinRootItem : public CBaseSnapinItem
{
    typedef          CBaseSnapinItem super;

    // Used by CBaseSnapinItem::ScCreateItem, connect this item with its children.
    typedef          CComObject<CSnapinItem<COCXCachingSnapinRootItem> >          t_item;
    typedef          CComObject<CSnapinItem<COCXContainer> > t_itemChild; // Who is my child?

public:
    COCXCachingSnapinRootItem( void )   {} // Raw constructor - use only for static item.
    virtual          ~COCXCachingSnapinRootItem( void ) {}

    BEGIN_COM_MAP(COCXCachingSnapinRootItem)
        COM_INTERFACE_ENTRY(IDataObject) // Cant have empty map so add IDataObject
    END_COM_MAP()

protected:
    // Item tree related information

    // node type related information
    virtual const CNodeType* Pnodetype( void )     { return &nodetypeSampleRoot;}

    // the display name of the item
    virtual const tstring* PstrDisplayName( void ) { return &m_strDisplayName;}

    // Get ListView data (GetDisplayInfo calls this).
    virtual SC       ScGetField(DAT dat, tstring& strField);

    // Image list information
    virtual LONG     Iconid() { return m_uIconIndex; }
    virtual LONG     OpenIconid() { return m_uIconIndex; }

    virtual BOOL     FIsContainer( void ) { return TRUE; }

    // Context menu support
    virtual SnapinMenuItem *Pmenuitem(void);
    virtual INT             CMenuItem(void);
    virtual SC              ScCommand(long nCommandID, CComponent *pComponent = NULL);
    virtual DWORD           DwFlagsMenuChecked(void)          { return TRUE;}
public:
    virtual SC       ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex = NULL, INT ccolinfoex = 0, BOOL fIsRoot = FALSE);

public:
    // Creates children for the node
    virtual SC       ScCreateChildren( void );

protected:
    tstring          m_strDisplayName;
    UINT             m_uIconIndex;

    // For context menus
    static SnapinMenuItem  s_rgmenuitem[];
    static INT             s_cmenuitem;
};



//+-------------------------------------------------------------------
//
//  Class:      COCXContainer
//
//  Purpose:    Implements a scope pane item.
//
//--------------------------------------------------------------------
class COCXContainer : public CBaseSnapinItem
{
    typedef          CBaseSnapinItem super;

    // Used by CBaseSnapinItem::ScCreateItem, connect this item with its children.
    typedef          CComObject<CSnapinItem<COCXContainer> > t_item;

    // If we cache OCX's then it should be cached per IComponent. But this CBaseSnapinItem based
    // container is per snapin (not per IComponent) so we use a map to store the per IComponent OCX.
    typedef          std::map<IConsole*, IUnknownPtr>  CachedOCXs;

public:
    COCXContainer( void ) {}
    virtual          ~COCXContainer( void ) {}

    BEGIN_COM_MAP(COCXContainer)
        COM_INTERFACE_ENTRY(IDataObject) // Cant have empty map so add IDataObject
    END_COM_MAP()
protected:
    // Item tree related information

    // node type related information
    const CNodeType *Pnodetype( void )                { return &nodetypeSampleLVContainer;}

    // the display name of the item
    virtual const tstring*    PstrDisplayName( void ) { return &m_strDisplayName;}

    // Get ListView data (GetDisplayInfo calls this).
    virtual SC                ScGetField(DAT dat, tstring& strField);

    // Image list information
    virtual LONG     Iconid()     { return m_uIconIndex; }
    virtual LONG     OpenIconid() { return m_uIconIndex; }

    // This item attributes.
    virtual BOOL     FIsContainer( void ) { return TRUE; }

    virtual BOOL     FUsesResultList()    { return FALSE;}
    virtual BOOL     FResultPaneIsOCX()   { return TRUE; }
    virtual SC       ScGetOCXCLSID(tstring& strclsidOCX) { strclsidOCX = m_strOCX; return S_OK;}

    virtual BOOL     FAllowMultiSelectionForChildren() { return FALSE;}

    virtual SC       ScInitOCX(LPUNKNOWN pUnkOCX, IConsole* pConsole);
    virtual BOOL     FCacheOCX();
    virtual IUnknown* GetCachedOCX(IConsole* pConsole);

    // There is no list-view so following methods are empty.
    virtual SC       ScInitializeResultView(CComponent *pComponent) { return S_OK;}
    virtual SC       ScOnAddImages(IImageList* ipResultImageList) { return S_OK;}

public:
    virtual SC       ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex = NULL, INT ccolinfoex = 0, BOOL fIsRoot = FALSE);

public:
    // Creates children for the node
    virtual SC       ScCreateChildren( void );
    static SC        ScCreateLVContainer(CBaseSnapinItem *pitemParent, CBaseSnapinItem *pitemPrevious, COCXContainer ** ppitem, BOOL fNew);

    void     SetOCXGUID(LPCTSTR szGUID)      { m_strOCX = szGUID;}

protected:
//    virtual SC       ScGetVerbs(DWORD * pdwVerbs);

protected:
    tstring          m_strDisplayName;
    UINT             m_uIconIndex;

    CachedOCXs       m_mapOCXs;
    tstring          m_strOCX;
};


//+-------------------------------------------------------------------
//
//  Class:      COCXCachingSnapin
//
//  Purpose:    Implements a snapin.
//
//--------------------------------------------------------------------
class COCXCachingSnapin : public CBaseSnapin
{
    // Specify the root node of the snapin.
    typedef          CComObject<CSnapinItem<COCXCachingSnapinRootItem> > t_itemRoot;

    SNAPIN_DECLARE(COCXCachingSnapin);

public:
                     COCXCachingSnapin();
    virtual          ~COCXCachingSnapin();

    // information about the snapin and root (ie initial) node
    virtual BOOL     FStandalone()  { return TRUE; }
    virtual BOOL     FIsExtension() { return FALSE; }

    virtual BOOL     FSupportsIComponent2() {return TRUE;}

    virtual LONG     IdsDescription(void)   {return IDS_OCXCachingRoot;}
    virtual LONG     IdsName(void)          {return IDS_OCXCachingSnapin;}

    const CSnapinInfo* Psnapininfo() { return &snapininfoOCXCaching; }
            bool     FCacheOCX()     { return m_bCacheOCX;}
            void     SetCacheOCX(bool b) { m_bCacheOCX = b;}

protected:
    // The column header info structures.
    static  CColumnInfoEx     s_colinfo[];
    static  INT      s_colwidths[];
    static  INT      s_ccolinfo;

    bool                   m_bCacheOCX;

protected:
    virtual CColumnInfoEx*    Pcolinfoex(INT icolinfo=0) { return s_colinfo + icolinfo; }
    virtual INT     &ColumnWidth(INT icolwidth=0) { return s_colwidths[icolwidth]; }
    virtual INT      Ccolinfoex() { return s_ccolinfo; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\sample\powertest.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 00
 *
 *  File:      powertest.h
 *
 *  Contents:  Interface for ACPI test snap-in
 *
 *  History:   29-Feb-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapinItem
 *
 *
 *--------------------------------------------------------------------------*/

class CPowerTestSnapinItem : public CBaseSnapinItem
{
public:
    CPowerTestSnapinItem();

    BEGIN_COM_MAP(CPowerTestSnapinItem)
        COM_INTERFACE_ENTRY(IDataObject) // Cant have empty map so add IDataObject
    END_COM_MAP()

public:
    virtual const tstring*  PstrDisplayName(void);
    virtual BOOL            FIsContainer(void)          { return FALSE; }
    virtual BOOL            FUsesResultList(void)       { return FALSE; }
    virtual const CNodeType*Pnodetype(void)             { return &nodetypePowerTestRoot; }
    virtual SC              ScGetField(DAT dat, tstring& strField)  { strField.erase(); return S_OK;}
    virtual SC              ScGetResultViewType(LPOLESTR* ppViewType, long* pViewOptions);
    virtual SC              ScOnShow(CComponent *pComponent, BOOL fSelect);
    virtual SnapinMenuItem *Pmenuitem(void);
    virtual INT             CMenuItem(void);
    virtual SC              ScCommand(long nCommandID, CComponent *pComponent = NULL);
    virtual DWORD           DwFlagsMenuGray(void);

    // There is no list-view so following methods are empty.
    virtual SC       ScInitializeResultView(CComponent *pComponent) { return S_OK;}
    virtual SC       ScOnAddImages(IImageList* ipResultImageList) { return S_OK;}

private:
    // bits returned from DwFlagsMenuGray
    enum
    {
        eFlag_ConsolePowerCreated    = 0x00000001,
        eFlag_ConsolePowerNotCreated = 0x00000002,
    };

    std::wstring GetMessageText();

    void ReleaseAll              ();
    void UpdateMessageView       ();
    SC   ScOnCreateConsolePower  (CComponent *pComponent);
    SC   ScOnReleaseConsolePower (CComponent *pComponent);
    SC   ScOnResetIdleTimer      (CComponent *pComponent);
    SC   ScOnSetExecutionState   (CComponent *pComponent);


private:
    CComQIPtr<IMessageView>     m_spMsgView;
    CComPtr<IConsolePower>      m_spConsolePower;
    CComPtr<IConsolePowerSink>  m_spConsolePowerSink;

    DWORD                       m_dwAdviseCookie;
    int                         m_cSystem;
    int                         m_cDisplay;

    static SnapinMenuItem       s_rgMenuItems[];
};


/*+-------------------------------------------------------------------------*
 * CPowerTestConsolePowerSinkImpl
 *
 *
 *--------------------------------------------------------------------------*/

class CPowerTestConsolePowerSinkImpl :
    public CComObjectRoot,
    public IConsolePowerSink
{
    BEGIN_COM_MAP(CPowerTestConsolePowerSinkImpl)
        COM_INTERFACE_ENTRY(IConsolePowerSink)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(CPowerTestConsolePowerSinkImpl);

public:
    STDMETHOD (OnPowerBroadcast)(WPARAM wParam, LPARAM lParam, LRESULT* plResult);
};


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapin
 *
 *
 *--------------------------------------------------------------------------*/

class CPowerTestSnapin : public CBaseSnapin
{
    typedef                 CComObject<CSnapinItem<CPowerTestSnapinItem> > t_itemRoot;

    SNAPIN_DECLARE( CPowerTestSnapin);

public:
                                  CPowerTestSnapin();
        virtual                   ~CPowerTestSnapin();

        // information about the snapin and root (ie initial) node
        virtual BOOL              FStandalone()          {return TRUE;} // only an extension snapin.
        virtual BOOL              FIsExtension()         {return FALSE;}

        virtual LONG              IdsDescription(void)   {return IDS_POWERTESTSNAPIN;}
        virtual LONG              IdsName(void)          {return IDS_POWERTESTSNAPIN;}
        virtual SC                ScInitBitmaps(void);

        const CSnapinInfo *       Psnapininfo()          {return &snapininfoPowerTest;}

private:
    tstring m_strDisplayName;
};


/*+-------------------------------------------------------------------------*
 * CPowerTestDlg
 *
 *
 *--------------------------------------------------------------------------*/

class CPowerTestDlg : public CDialogImpl<CPowerTestDlg>
{
public:
    CPowerTestDlg(bool fResetTimer = false) :
        m_fResetTimer (fResetTimer),
        m_dwAdd       (0),
        m_dwRemove    (0)
    {}


    DWORD GetAddFlags    () const       { return (m_dwAdd);     }
    DWORD GetRemoveFlags () const       { return (m_dwRemove);  }

    enum { IDD = IDD_ConsolePowerTest };

BEGIN_MSG_MAP(CPowerTestDlg)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    COMMAND_ID_HANDLER(IDOK, OnOK)
    COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        if (m_fResetTimer)
        {
            SetWindowText (_T("IConsolePower::ResetIdleTimer"));
            ::EnableWindow (GetDlgItem (IDC_RemoveGroup),   false);
            ::EnableWindow (GetDlgItem (IDC_RemoveSystem),  false);
            ::EnableWindow (GetDlgItem (IDC_RemoveDisplay), false);
        }

        return 1;  // Let the system set the focus
    }

    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        if (IsDlgButtonChecked (IDC_AddSystem))     m_dwAdd    |= ES_SYSTEM_REQUIRED;
        if (IsDlgButtonChecked (IDC_AddDisplay))    m_dwAdd    |= ES_DISPLAY_REQUIRED;

        if (IsDlgButtonChecked (IDC_RemoveSystem))  m_dwRemove |= ES_SYSTEM_REQUIRED;
        if (IsDlgButtonChecked (IDC_RemoveDisplay)) m_dwRemove |= ES_DISPLAY_REQUIRED;

        EndDialog(wID);
        return 0;
    }

    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        EndDialog(wID);
        return 0;
    }

private:
    const bool  m_fResetTimer;
    DWORD       m_dwAdd;
    DWORD       m_dwRemove;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\sample\powertest.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      powertest.cpp
 *
 *  Contents:  Implements ACPI test snap-in
 *
 *  History:   29-Feb-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.hxx"
#include "powertest.h"



/*+-------------------------------------------------------------------------*
 * ShowReturn
 *
 *
 *--------------------------------------------------------------------------*/

static void ShowReturn (const SC& sc, LPCTSTR pszPrefix)
{
    tstring strMessage = pszPrefix;

	/*
	 * Successful HRESULTs will map to unsuccessful Win32 error codes,
	 * so if the SC doesn't contain an error, give it S_OK so GetErrorMessage
	 * doesn't return confusing error text.
	 */
	SC scLocal = sc;
	if (!scLocal.IsError())
		scLocal = S_OK;

    TCHAR szErrorMessage[256];
    scLocal.GetErrorMessage (256, szErrorMessage);
    strMessage += szErrorMessage;

	if (!sc.IsError() && !(sc == S_OK))
	{
		strMessage += _T("  ");

		if (sc == S_FALSE)
			strMessage += _T("(S_FALSE)");
		else
			strMessage += tstring(_T("(")) + _itot(sc.GetCode(), szErrorMessage, 10) + _T(")");
	}

    MessageBox (NULL, strMessage.data(), _T("Debug message"), MB_OK);
}


/*+=========================================================================*
 *                                                                          *
 *                    CPowerTestSnapinItem Implmentation                    *
 *                                                                          *
 *==========================================================================*/


#define DECLARE_SNAPIN_MENU_ITEM(id, dwGray) \
    { id, id, id, CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, dwMenuAlwaysEnable, dwGray, dwMenuNeverChecked}

SnapinMenuItem CPowerTestSnapinItem::s_rgMenuItems[] =
{
    DECLARE_SNAPIN_MENU_ITEM (IDS_CreateConsolePower,   eFlag_ConsolePowerCreated),
    DECLARE_SNAPIN_MENU_ITEM (IDS_ReleaseConsolePower,  eFlag_ConsolePowerNotCreated),
    DECLARE_SNAPIN_MENU_ITEM (IDS_SetExecutionState,    eFlag_ConsolePowerNotCreated),
    DECLARE_SNAPIN_MENU_ITEM (IDS_ResetIdleTimer,       eFlag_ConsolePowerNotCreated),
};


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapinItem::CPowerTestSnapinItem
 *
 *
 *--------------------------------------------------------------------------*/

CPowerTestSnapinItem::CPowerTestSnapinItem() :
    m_cSystem        (0),
    m_cDisplay       (0),
    m_dwAdviseCookie (0)
{
}


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapinItem::DwFlagsMenuGray
 *
 *
 *--------------------------------------------------------------------------*/

DWORD CPowerTestSnapinItem::DwFlagsMenuGray(void)
{
    return ((m_spConsolePower) ? eFlag_ConsolePowerCreated : eFlag_ConsolePowerNotCreated);
}


/*+-------------------------------------------------------------------------*
 * tstring* CPowerTestSnapinItem::PstrDisplayName
 *
 *
 *--------------------------------------------------------------------------*/

const tstring* CPowerTestSnapinItem::PstrDisplayName()
{
    return (&Psnapin()->StrDisplayName());
}


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapinItem::ScGetResultViewType
 *
 *
 *--------------------------------------------------------------------------*/

SC CPowerTestSnapinItem::ScGetResultViewType(LPOLESTR* ppViewType, long* pViewOptions)
{
    DECLARE_SC (sc, _T("CPowerTestSnapinItem::ScGetResultViewType"));

    /*
     * use the standard message view OCX
     */
    sc = StringFromCLSID (CLSID_MessageView, ppViewType);
    if (sc)
        return (sc);

    /*
     * use only the OCX
     */
    *pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapinItem::ScOnShow
 *
 * WM_SHOW handler for CPowerTestSnapinItem.
 *--------------------------------------------------------------------------*/

SC CPowerTestSnapinItem::ScOnShow(CComponent *pComponent, BOOL fSelect)
{
    DECLARE_SC (sc, _T("CPowerTestSnapinItem::ScOnShow"));

    if (fSelect)
    {
        if (pComponent == NULL)
            return (sc = E_UNEXPECTED);

        IConsole* pConsole = pComponent->IpConsole();
        if (pConsole == NULL)
            return (sc = E_NOINTERFACE);

        CComPtr<IUnknown> spResultUnk;
        sc = pConsole->QueryResultView (&spResultUnk);
        if (sc)
            return (sc);

        m_spMsgView = spResultUnk;
        if (m_spMsgView == NULL)
            return (sc = E_NOINTERFACE);

        UpdateMessageView();
    }
    else
    {
        m_spMsgView.Release();
    }

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapinItem::UpdateMessageView
 *
 *
 *--------------------------------------------------------------------------*/

void CPowerTestSnapinItem::UpdateMessageView ()
{
    if (m_spMsgView)
    {
        m_spMsgView->SetIcon      (Icon_Information);
        m_spMsgView->SetTitleText (L"Power Test Snap-in");
        m_spMsgView->SetBodyText  (GetMessageText().data());
    }
}


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapinItem::GetMessageText
 *
 *
 *--------------------------------------------------------------------------*/

std::wstring CPowerTestSnapinItem::GetMessageText()
{
    std::wstring strMessageText;

    if (m_spConsolePower)
    {
        WCHAR szMessageText[256];
        wsprintfW (szMessageText,
                   L"CLSID_ConsolePower created\n\n"
                   L"Current execution state:\n"
                   L"ES_SYSTEM_REQUIRED = %d\n"
                   L"ES_DISPLAY_REQUIRED = %d\n",
                   m_cSystem, m_cDisplay);

        strMessageText = szMessageText;
    }
    else
        strMessageText = L"CLSID_ConsolePower not created";

    return (strMessageText);
}


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapinItem::Pmenuitem
 *
 *
 *--------------------------------------------------------------------------*/

SnapinMenuItem* CPowerTestSnapinItem::Pmenuitem(void)
{
    return (s_rgMenuItems);
}


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapinItem::CMenuItem
 *
 *
 *--------------------------------------------------------------------------*/

INT CPowerTestSnapinItem::CMenuItem(void)
{
    return (sizeof(s_rgMenuItems) / sizeof(s_rgMenuItems[0]));
}


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapinItem::ScCommand
 *
 *
 *--------------------------------------------------------------------------*/

SC CPowerTestSnapinItem::ScCommand(long nCommandID, CComponent *pComponent)
{
    DECLARE_SC (sc, _T("CPowerTestSnapinItem::ScCommand"));

    switch (nCommandID)
    {
        case IDS_CreateConsolePower:
            sc = ScOnCreateConsolePower (pComponent);
            break;

        case IDS_ReleaseConsolePower:
            sc = ScOnReleaseConsolePower (pComponent);
            break;

        case IDS_ResetIdleTimer:
            sc = ScOnResetIdleTimer (pComponent);
            break;

        case IDS_SetExecutionState:
            sc = ScOnSetExecutionState (pComponent);
            break;

        default:
            sc = E_UNEXPECTED;
            break;
    }

    UpdateMessageView();
    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapinItem::ScOnCreateConsolePower
 *
 *
 *--------------------------------------------------------------------------*/

SC CPowerTestSnapinItem::ScOnCreateConsolePower (CComponent *pComponent)
{
    DECLARE_SC (sc, _T("CPowerTestSnapinItem::ScOnCreateConsolePower"));

    /*
     * create the CLSID_ConsolePower object
     */
    sc = m_spConsolePower.CoCreateInstance (CLSID_ConsolePower);
    if (sc)
        return (sc);

    /*
     * create a CPowerTestConsolePowerSinkImpl
     */
    CComObject<CPowerTestConsolePowerSinkImpl>* pPowerSinkImpl;
    sc = CComObject<CPowerTestConsolePowerSinkImpl>::CreateInstance (&pPowerSinkImpl);
    if (sc)
        return (ReleaseAll(), sc);

    m_spConsolePowerSink = pPowerSinkImpl;

    /*
     * set up the event sink
     */
    sc = AtlAdvise (m_spConsolePower, m_spConsolePowerSink, IID_IConsolePowerSink, &m_dwAdviseCookie);
    if (sc)
        return (ReleaseAll(), sc);

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapinItem::ScOnReleaseConsolePower
 *
 *
 *--------------------------------------------------------------------------*/

SC CPowerTestSnapinItem::ScOnReleaseConsolePower (CComponent *pComponent)
{
    DECLARE_SC (sc, _T("CPowerTestSnapinItem::ScOnCreateConsolePower"));

    AtlUnadvise (m_spConsolePower, IID_IConsolePowerSink, m_dwAdviseCookie);
    ReleaseAll();

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapinItem::ReleaseAll
 *
 *
 *--------------------------------------------------------------------------*/

void CPowerTestSnapinItem::ReleaseAll()
{
    m_spConsolePower.Release();
    m_spConsolePowerSink.Release();
}


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapinItem::ScOnResetIdleTimer
 *
 *
 *--------------------------------------------------------------------------*/

SC CPowerTestSnapinItem::ScOnResetIdleTimer (CComponent *pComponent)
{
    DECLARE_SC (sc, _T("CPowerTestSnapinItem::ScOnCreateConsolePower"));

    if (!m_spConsolePower)
    {
        MMCErrorBox (sc = E_UNEXPECTED);
        sc.Clear();
        return (sc);
    }

    CPowerTestDlg dlg(true);

    if (dlg.DoModal() == IDOK)
    {
        sc = m_spConsolePower->ResetIdleTimer (dlg.GetAddFlags());
        ShowReturn (sc, _T("IConsolePower::ResetIdleTimer returned:\n\n"));
    }

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapinItem::ScOnSetExecutionState
 *
 *
 *--------------------------------------------------------------------------*/

SC CPowerTestSnapinItem::ScOnSetExecutionState (CComponent *pComponent)
{
    DECLARE_SC (sc, _T("CPowerTestSnapinItem::ScOnCreateConsolePower"));

    if (!m_spConsolePower)
    {
        MMCErrorBox (sc = E_UNEXPECTED);
        sc.Clear();
        return (sc);
    }


    CPowerTestDlg dlg;

    if (dlg.DoModal() == IDOK)
    {
        DWORD dwAdd    = dlg.GetAddFlags();
        DWORD dwRemove = dlg.GetRemoveFlags();

        sc = m_spConsolePower->SetExecutionState (dwAdd, dwRemove);
        ShowReturn (sc, _T("IConsolePower::SetExecutionState returned:\n\n"));

        if (sc == S_OK)
        {
            if (dwAdd & ES_SYSTEM_REQUIRED)         m_cSystem++;
            if (dwAdd & ES_DISPLAY_REQUIRED)        m_cDisplay++;
            if (dwRemove & ES_SYSTEM_REQUIRED)      m_cSystem--;
            if (dwRemove & ES_DISPLAY_REQUIRED)     m_cDisplay--;
        }
    }

    return (sc);
}



/*+=========================================================================*
 *                                                                          *
 *               CPowerTestConsolePowerSinkImpl Implmentation               *
 *                                                                          *
 *==========================================================================*/


/*+-------------------------------------------------------------------------*
 * CPowerTestConsolePowerSinkImpl::OnPowerBroadcast
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CPowerTestConsolePowerSinkImpl::OnPowerBroadcast (
    WPARAM      wParam,
    LPARAM      lParam,
    LRESULT*    plResult)
{
    if (plResult == NULL)
        return (E_INVALIDARG);

    if (wParam == PBT_APMQUERYSUSPEND)
        *plResult = BROADCAST_QUERY_DENY;
    else
        *plResult = TRUE;

    return (S_OK);
}



/*+=========================================================================*
 *                                                                          *
 *                      CPowerTestSnapin Implmentation                      *
 *                                                                          *
 *==========================================================================*/


SNR     CPowerTestSnapin::s_rgsnr[] =
{
    SNR(&nodetypePowerTestRoot, snrEnumSP ),
};

LONG  CPowerTestSnapin::s_rgiconid[]           = {0};
LONG  CPowerTestSnapin::s_iconidStatic         = 0;


// include members needed for every snapin.
SNAPIN_DEFINE(CPowerTestSnapin);


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapin::CPowerTestSnapin
 *
 *
 *--------------------------------------------------------------------------*/

CPowerTestSnapin::CPowerTestSnapin() :
    m_strDisplayName (_T("PowerTest Snap-in"))
{
    m_pstrDisplayName = &m_strDisplayName;
}


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapin::~CPowerTestSnapin
 *
 *
 *--------------------------------------------------------------------------*/

CPowerTestSnapin::~CPowerTestSnapin()
{
}


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapin::ScInitBitmaps
 *
 *
 *--------------------------------------------------------------------------*/

SC CPowerTestSnapin::ScInitBitmaps(void)
{
    DECLARE_SC (sc, _T("CPowerTestSnapin::ScInitBitmaps"));

    if (BitmapSmall())
        return (sc);

    sc = CBaseSnapin::ScInitBitmaps();
    if (sc)
        return (sc);

    BitmapSmall().DeleteObject();
    sc = BitmapSmall().LoadBitmap(IDB_POWER16) ? S_OK : E_FAIL;
    if (sc)
        return sc;

    BitmapLarge().DeleteObject();
    sc = BitmapLarge().LoadBitmap(IDB_POWER32) ? S_OK : E_FAIL;
    if (sc)
        return sc;

    BitmapStaticSmall().DeleteObject();
    sc = BitmapStaticSmall().LoadBitmap(IDB_POWER16) ? S_OK : E_FAIL;
    if (sc)
        return sc;

    BitmapStaticSmallOpen().DeleteObject();
    sc = BitmapStaticSmallOpen().LoadBitmap(IDB_POWER16) ? S_OK : E_FAIL;
    if (sc)
        return sc;

    BitmapStaticLarge().DeleteObject();
    sc = BitmapStaticLarge().LoadBitmap(IDB_POWER32) ? S_OK : E_FAIL;
    if (sc)
        return sc;

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\sample\ocxcaching.cpp ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       ocxcaching.cpp
//
//  Contents:   Classes that implement OCX caching snapin using the framework.
//
//--------------------------------------------------------------------
#include "stdafx.hxx"

//+-------------------------------------------------------------------
//
//  Member:      COCXCachingSnapinRootItem::ScInit
//
//  Synopsis:    Called immeadiately after the item is created to init
//               displayname, icon index etc...
//
//  Arguments:   [CBaseSnapin]   -
//               [CColumnInfoEx] - Any columns to be displayed for this item.
//               [INT]           - # of columns
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC COCXCachingSnapinRootItem::ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex, INT ccolinfoex, BOOL fIsRoot)
{
    DECLARE_SC(sc, _T("COCXCachingSnapinRootItem::ScInit"));

    sc = CBaseSnapinItem::ScInit(pSnapin, pcolinfoex, ccolinfoex, fIsRoot);
    if (sc)
        return sc;

    // Init following
    //  a. Icon index.
    //  b. Load display name.

    m_uIconIndex = 3; // use an enum instead of 3

    m_strDisplayName.LoadString(_Module.GetResourceInstance(), IDS_OCXCachingRoot);

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      COCXCachingSnapinRootItem::ScGetField
//
//  Synopsis:    Get the string representation for given field to display
//               it in result pane.
//
//  Arguments:   [DAT]     - The column requested (this is an enumeration).
//               [tstring] - Out string.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC COCXCachingSnapinRootItem::ScGetField (DAT dat, tstring& strField)
{
    DECLARE_SC(sc, _T("COCXCachingSnapinRootItem::ScGetField"));

    switch(dat)
    {
    case datString1:
        strField = _T("OCX Caching Snapin Root Node");
        break;

    default:
        E_INVALIDARG;
        break;
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      COCXCachingSnapinRootItem::ScCreateChildren
//
//  Synopsis:    Create any children (nodes & leaf items) for this item.
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC COCXCachingSnapinRootItem::ScCreateChildren ()
{
    DECLARE_SC(sc, _T("COCXCachingSnapinRootItem::ScCreateChildren"));

    COCXContainer *   pitemChild      = NULL;
    COCXContainer *   pitemPrevious   = NULL;

    // Create the 1st child node for calendar OCX.
    sc = COCXContainer::ScCreateLVContainer(this, pitemPrevious, &pitemChild, FALSE); // Why FALSE???
    if (sc)
        return sc;

    pitemChild->SetOCXGUID(TEXT("{8E27C92B-1264-101C-8A2F-040224009C02}"));
    pitemPrevious = pitemChild;

    // Create the 2nd child node for calendar OCX.
    sc = COCXContainer::ScCreateLVContainer(this, pitemPrevious, &pitemChild, FALSE); // Why FALSE???
    if (sc)
        return sc;

    pitemChild->SetOCXGUID(TEXT("{2179C5D3-EBFF-11CF-B6FD-00AA00B4E220}"));
    pitemPrevious = pitemChild;

    return (sc);
}


// Initialize context menu structures. Let us have one item for demonstration.
SnapinMenuItem COCXCachingSnapinRootItem::s_rgmenuitem[] =
{
    {IDS_EnableOCXCaching, IDS_EnableOCXCaching, IDS_EnableOCXCaching, CCM_INSERTIONPOINTID_PRIMARY_TOP, NULL, dwMenuAlwaysEnable, dwMenuNeverGray, 0},
};

INT COCXCachingSnapinRootItem::s_cmenuitem = CMENUITEM(s_rgmenuitem);

// -----------------------------------------------------------------------------
SnapinMenuItem *COCXCachingSnapinRootItem::Pmenuitem(void)
{
    return s_rgmenuitem;
}

// -----------------------------------------------------------------------------
INT COCXCachingSnapinRootItem::CMenuItem(void)
{
    return s_cmenuitem;
}


//+-------------------------------------------------------------------
//
//  Member:      COCXCachingSnapinRootItem::ScCommand
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC COCXCachingSnapinRootItem::ScCommand (long nCommandID, CComponent *pComponent)
{
    DECLARE_SC(sc, _T("COCXCachingSnapinRootItem::ScCommand"));

    COCXCachingSnapin *pSnapin = dynamic_cast<COCXCachingSnapin*>(Psnapin());
    if (!pSnapin)
        return sc;

    switch(nCommandID)
    {
    case IDS_EnableOCXCaching:
        {
            bool bCachingEnabled = pSnapin->FCacheOCX();

                pSnapin->SetCacheOCX(! bCachingEnabled);

            for (int i = 0; i < CMenuItem(); ++i)
            {
                if (s_rgmenuitem[i].lCommandID == IDS_EnableOCXCaching)
                    s_rgmenuitem[i].dwFlagsChecked = (!bCachingEnabled);
            }

        }
        break;

    default:
        sc = E_INVALIDARG;
        break;
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      COCXContainer::ScInit
//
//  Synopsis:    Called immeadiately after the item is created to init
//               displayname, icon index etc...
//
//  Arguments:   [CBaseSnapin]   -
//               [CColumnInfoEx] - Any columns to be displayed for this item.
//               [INT]           - # of columns
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC COCXContainer::ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex, INT ccolinfoex, BOOL fIsRoot)
{
    DECLARE_SC(sc, _T("COCXContainer::ScInit"));

    sc = CBaseSnapinItem::ScInit(pSnapin, pcolinfoex, ccolinfoex, fIsRoot);
    if (sc)
        return sc;

    // Init following
    //  a. Icon index.
    //  b. Load display name.

    m_uIconIndex = 4; // use an enum instead of 4

    m_strDisplayName.LoadString(_Module.GetResourceInstance(), IDS_OCXContainer);

    return sc;
}


BOOL COCXContainer::FCacheOCX()
{
    COCXCachingSnapin *pSnapin = dynamic_cast<COCXCachingSnapin*>(Psnapin());
    if (!pSnapin)
        return FALSE;

    return pSnapin->FCacheOCX();
}


//+-------------------------------------------------------------------
//
//  Member:      COCXContainer::ScGetField
//
//  Synopsis:    Get the string representation for given field to display
//               it in result pane.
//
//  Arguments:   [DAT]     - The column requested (this is an enumeration).
//               [tstring] - Out string.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC COCXContainer::ScGetField (DAT dat, tstring& strField)
{
    DECLARE_SC(sc, _T("COCXContainer::ScGetField"));

    switch(dat)
    {
    case datString1:
        strField = _T("OCX Container");
        break;

    default:
        E_INVALIDARG;
        break;
    }

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      COCXContainer::ScInitOCX
//
//  Synopsis:    OCX is created & attached to host. Now MMC has asked
//               us to initialize the OCX.
//
//  Arguments:   [pUnkOCX] - IUnknown of the OCX.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC COCXContainer::ScInitOCX (LPUNKNOWN pUnkOCX, IConsole* pConsole)
{
    DECLARE_SC(sc, _T("COCXContainer::ScInitOCX"));
    sc = ScCheckPointers(pUnkOCX, pConsole);
    if (sc)
        return sc;

    // Store the cached OCX ptr to provide it later in GetResultViewType2.
    if (FCacheOCX())
        m_mapOCXs.insert(CachedOCXs::value_type(pConsole, pUnkOCX));

    CComQIPtr <IPersistStreamInit> spPerStm(pUnkOCX);

    if (spPerStm)
        spPerStm->InitNew();

    return (sc);
}

IUnknown* COCXContainer::GetCachedOCX(IConsole* pConsole)
{
    CachedOCXs::iterator it = m_mapOCXs.find(pConsole);

    if (it != m_mapOCXs.end())
        return it->second;

    return NULL;
}

//+-------------------------------------------------------------------
//
//  Member:      COCXContainer::ScCreateChildren
//
//  Synopsis:    Create any children (nodes & leaf items) for this item.
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC COCXContainer::ScCreateChildren ()
{
    DECLARE_SC(sc, _T("COCXContainer::ScCreateChildren"));

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      COCXContainer::ScCreateLVContainer
//
//  Synopsis:    Do we really need this method?
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC COCXContainer::ScCreateLVContainer(CBaseSnapinItem *pitemParent, CBaseSnapinItem *pitemPrevious, COCXContainer ** ppitem, BOOL fNew)
{
    DECLARE_SC(sc, _T("COCXCachingSnapinRootItem::ScCreateLVContainer"));
    t_item *   pitem   = NULL;
    *ppitem = NULL;

    // What to do here?
    sc = ::ScCreateItem(pitemParent, pitemPrevious, &pitem, fNew);
    if (sc)
        return sc;

    *ppitem = pitem;

    return (sc);
}

//-------------------------------------------------------------------------------------
// class COCXCachingSnapin

#pragma BEGIN_CODESPACE_DATA
SNR     COCXCachingSnapin::s_rgsnr[] =
{
    SNR(&nodetypeOCXCachingRoot,         snrEnumSP ),              // Standalone snapin.
    SNR(&nodetypeOCXCachingContainer1,   snrEnumSP ),  // enumerates this node in the scope pane
    SNR(&nodetypeOCXCachingContainer2,   snrEnumSP ),  // enumerates this node in the scope pane
};

LONG  COCXCachingSnapin::s_rgiconid[]           = {3};
LONG  COCXCachingSnapin::s_iconidStatic         = 2;


CColumnInfoEx COCXCachingSnapin::s_colinfo[] =
{
    CColumnInfoEx(_T("Column Name0"),   LVCFMT_LEFT,    180,    datString1),
    CColumnInfoEx(_T("Column Name1"),   LVCFMT_LEFT,    180,    datString2),
    CColumnInfoEx(_T("Column Name2"),   LVCFMT_LEFT,    180,    datString3),
};

INT COCXCachingSnapin::s_ccolinfo = sizeof(s_colinfo) / sizeof(CColumnInfoEx);
INT COCXCachingSnapin::s_colwidths[1];
#pragma END_CODESPACE_DATA

// include members needed for every snapin.
SNAPIN_DEFINE( COCXCachingSnapin);

/* COCXCachingSnapin::COCXCachingSnapin
 *
 * PURPOSE:             Constructor
 *
 * PARAMETERS: None
 *
 */
COCXCachingSnapin::COCXCachingSnapin()
{
    m_pstrDisplayName = new tstring();

    m_bCacheOCX = false;

    *m_pstrDisplayName = _T("OCX Caching Snapin Root");
}

/* COCXCachingSnapin::~COCXCachingSnapin
 *
 * PURPOSE:             Destructor
 *
 * PARAMETERS: None
 *
 */
COCXCachingSnapin::~COCXCachingSnapin()
{
    delete m_pstrDisplayName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\sample\renamesnapin.cxx ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       Renamesnap.cxx
//
//  Contents:   Classes that implement Rename snapin using the framework.
//
//--------------------------------------------------------------------
#include "stdafx.hxx"


//+-------------------------------------------------------------------
//
//  Member:      CRenameRootItem::ScInit
//
//  Synopsis:    Called immeadiately after the item is created to init
//               displayname, icon index etc...
//
//  Arguments:   [CBaseSnapin]   -
//               [CColumnInfoEx] - Any columns to be displayed for this item.
//               [INT]           - # of columns
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CRenameRootItem::ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex, INT ccolinfoex, BOOL fIsRoot)
{
    DECLARE_SC(sc, _T("CRenameRootItem::ScInit"));

    sc = CBaseSnapinItem::ScInit(pSnapin, pcolinfoex, ccolinfoex, fIsRoot);
    if (sc)
        return sc;

    // Init following
    //  a. Icon index.
    //  b. Load display name.

    m_uIconIndex = 3; // use an enum instead of 3

    m_strDisplayName.LoadString(_Module.GetResourceInstance(), IDS_RenameROOT);

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CRenameRootItem::ScGetField
//
//  Synopsis:    Get the string representation for given field to display
//               it in result pane.
//
//  Arguments:   [DAT]     - The column requested (this is an enumeration).
//               [tstring] - Out string.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CRenameRootItem::ScGetField (DAT dat, tstring& strField)
{
    DECLARE_SC(sc, _T("CRenameRootItem::ScGetField"));

    switch(dat)
    {
    case datString1:
        strField = _T("Root String1");
        break;

    case datString2:
        strField = _T("Root String2");
        break;

    case datString3:
        strField = _T("Root String3");
        break;

    default:
        E_INVALIDARG;
        break;
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CRenameRootItem::ScCreateChildren
//
//  Synopsis:    Create any children (nodes & leaf items) for this item.
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CRenameRootItem::ScCreateChildren ()
{
    DECLARE_SC(sc, _T("CRenameRootItem::ScCreateChildren"));

    t_itemChild *   pitemChild      = NULL;
    t_itemChild *   pitemPrevious   = NULL;

    // Let us create 10 items for this container.
    for (int i = 0; i < 10; ++i)
    {
        // Create the child nodes and init them.
        sc = CRenameSnapinLVLeafItem::ScCreateLVLeafItem(this, pitemPrevious, &pitemChild, FALSE); // Why FALSE???
        if (sc)
            return sc;
        pitemPrevious = pitemChild;
    }

    return (sc);
}

/*+-------------------------------------------------------------------------*
 *
 * CRenameRootItem::ScOnRename
 *
 * PURPOSE: Renames the item
 *
 * PARAMETERS: 
 *    const  tstring :
 *
 * RETURNS: 
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC       
CRenameRootItem::ScOnRename(const tstring& strNewName)
{
    DECLARE_SC(sc, TEXT("CRenameRootItem::ScOnRename"));

    m_strDisplayName = strNewName;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CRenameSnapinLVLeafItem::ScInit
//
//  Synopsis:    Called immeadiately after the item is created to init
//               displayname, icon index etc...
//
//  Arguments:   [CBaseSnapin]   -
//               [CColumnInfoEx] - Any columns to be displayed for this item.
//               [INT]           - # of columns
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CRenameSnapinLVLeafItem::ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex, INT ccolinfoex, BOOL fIsRoot)
{
    DECLARE_SC(sc, _T("CRenameSnapinLVLeafItem::ScInit"));

    sc = CBaseSnapinItem::ScInit(pSnapin, pcolinfoex, ccolinfoex, fIsRoot);
    if (sc)
        return sc;

    // Init following
    //  a. Icon index.
    //  b. Load display name.

    m_uIconIndex = 7; // use an enum instead of 7

    m_strDisplayName.LoadString(_Module.GetResourceInstance(), IDS_LVLeafItem);

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CRenameSnapinLVLeafItem::ScGetField
//
//  Synopsis:    Get the string representation for given field to display
//               it in result pane.
//
//  Arguments:   [DAT]     - The column requested (this is an enumeration).
//               [tstring] - Out string.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CRenameSnapinLVLeafItem::ScGetField (DAT dat, tstring& strField)
{
    DECLARE_SC(sc, _T("CRenameSnapinLVLeafItem::ScGetField"));

    switch(dat)
    {
    case datString1:
        strField = _T("LVLeaf String1");
        break;

    case datString2:
        strField = _T("LVLeaf String2");
        break;

    case datString3:
        strField = _T("LVLeaf String3");
        break;

    default:
        E_INVALIDARG;
        break;
    }

    return (sc);
}



//+-------------------------------------------------------------------
//
//  Member:      CRenameSnapinLVLeafItem::ScCreateLVLeafItem
//
//  Synopsis:    Do we really need this method?
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CRenameSnapinLVLeafItem::ScCreateLVLeafItem(CRenameRootItem *pitemParent, t_itemChild * pitemPrevious, t_itemChild ** ppitem, BOOL fNew)
{
    DECLARE_SC(sc, _T("CRenameSnapinLVLeafItem::ScCreateLVLeafItem"));
    t_itemChild *   pitem   = NULL;
    *ppitem = NULL;

    // What to do here?
    sc = ::ScCreateItem(pitemParent, pitemPrevious, &pitem, fNew);
    if (sc)
        return sc;

    *ppitem = pitem;

    return (sc);
}

// Initialize context menu structures. Let us have one item for demonstration.
SnapinMenuItem CRenameSnapinLVLeafItem::s_rgmenuitemLVLeafItem[] =
{
    {IDS_NewLVItem,        IDS_NewLVItem,        IDS_NewLVItem,        CCM_INSERTIONPOINTID_PRIMARY_TOP, NULL, dwMenuAlwaysEnable, dwMenuNeverGray,        dwMenuNeverChecked},
    {IDS_RenameScopeItem,  IDS_RenameScopeItem,  IDS_RenameScopeItem,  CCM_INSERTIONPOINTID_PRIMARY_TOP, NULL, dwMenuAlwaysEnable, dwMenuNeverGray,        dwMenuNeverChecked},
    {IDS_RenameResultItem, IDS_RenameResultItem, IDS_RenameResultItem, CCM_INSERTIONPOINTID_PRIMARY_TOP, NULL, dwMenuAlwaysEnable, dwMenuNeverGray,        dwMenuNeverChecked},
};

INT CRenameSnapinLVLeafItem::s_cmenuitemLVLeafItem = CMENUITEM(s_rgmenuitemLVLeafItem);

// -----------------------------------------------------------------------------
SnapinMenuItem *CRenameSnapinLVLeafItem::Pmenuitem(void)
{
    return s_rgmenuitemLVLeafItem;
}

// -----------------------------------------------------------------------------
INT CRenameSnapinLVLeafItem::CMenuItem(void)
{
    return s_cmenuitemLVLeafItem;
}


//+-------------------------------------------------------------------
//
//  Member:      CRenameSnapinLVLeafItem::ScCommand
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CRenameSnapinLVLeafItem::ScCommand (long nCommandID, CComponent *pComponent)
{
    DECLARE_SC(sc, _T("CRenameSnapinLVLeafItem::ScCommand"));

    switch(nCommandID)
    {
    case IDS_NewLVItem:
        sc = ScInsertResultItem(pComponent);
        break;

    case IDS_RenameScopeItem:
        sc = ScRenameScopeItem();
        break;

    case IDS_RenameResultItem:
        sc = ScRenameResultItem();
        break;

    default:
        sc = E_INVALIDARG;
        break;
    }

    return (sc);
}

/*+-------------------------------------------------------------------------*
 *
 * CRenameSnapinLVLeafItem::ScRenameScopeItem
 *
 * PURPOSE: Puts the parent scope item into rename mode.
 *
 * RETURNS: 
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CRenameSnapinLVLeafItem::ScRenameScopeItem()
{
    DECLARE_SC(sc, _T("CRenameSnapinLVLeafItem::ScRenameScopeItem"));

    IConsole3Ptr spConsole3 = IpConsole(); // get a pointer to the IConsole3 interface

    sc = ScCheckPointers(spConsole3, PitemParent(), E_FAIL);
    if(sc)
        return sc;

    sc = spConsole3->RenameScopeItem(PitemParent()->Hscopeitem());

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CRenameSnapinLVLeafItem::ScInsertResultItem
 *
 * PURPOSE: Overrides the base class method because we need to cache the 
 *          IResultData2 and HRESULTITEM
 *
 * PARAMETERS: 
 *    CComponent * pComponent :
 *
 * RETURNS: 
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC 
CRenameSnapinLVLeafItem::ScInsertResultItem(CComponent *pComponent)
{
    DECLARE_SC(sc, _T("CRenameSnapinLVLeafItem::ScInsertResultItem"));

    RESULTDATAITEM  resultdataitem;

    ASSERT(pComponent && pComponent->IpResultData());

    // Add this item
    ZeroMemory(&resultdataitem, sizeof(resultdataitem));

    resultdataitem.lParam   = Cookie();
    resultdataitem.mask             = RDI_STR | RDI_PARAM | RDI_IMAGE;
    // Callback for the display name.
    resultdataitem.str              = MMC_CALLBACK;
    // Custom icon
    resultdataitem.nImage   = (int) MMC_CALLBACK;

    sc = pComponent->IpResultData()->InsertItem(&resultdataitem);
    if (sc)
        return sc;

    // cache this item - NOTE: breaks for multiple views
    m_hresultItem = resultdataitem.itemID;
    m_spResultData2 = pComponent->IpResultData();

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CRenameSnapinLVLeafItem::ScRenameResultItem
 *
 * PURPOSE: Renames the list item
 *
 * RETURNS: 
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CRenameSnapinLVLeafItem::ScRenameResultItem()
{
    DECLARE_SC(sc, _T("CRenameSnapinLVLeafItem::ScRenameResultItem"));

    sc = ScCheckPointers(m_spResultData2, PitemParent(), E_FAIL);
    if(sc)
        return sc;

    if(m_hresultItem==NULL)
        return (sc = E_FAIL);

    sc = m_spResultData2->RenameResultItem(m_hresultItem);

    return sc;
}


//-------------------------------------------------------------------------------------
// class CRenameSnapin

#pragma BEGIN_CODESPACE_DATA
SNR     CRenameSnapin::s_rgsnr[] =
{
    SNR(&nodetypeRenameRoot,         snrEnumSP ),              // Standalone snapin.
    SNR(&nodetypeRenameLVLeafItem,   snrEnumSP | snrEnumRP ),  // enumerates this node in the scope pane and result pane.
};

LONG  CRenameSnapin::s_rgiconid[]           = {3};
LONG  CRenameSnapin::s_iconidStatic         = 2;


CColumnInfoEx CRenameSnapin::s_colinfo[] =
{
    CColumnInfoEx(_T("Column Name0"),   LVCFMT_LEFT,    180,    datString1),
    CColumnInfoEx(_T("Column Name1"),   LVCFMT_LEFT,    180,    datString2),
    CColumnInfoEx(_T("Column Name2"),   LVCFMT_LEFT,    180,    datString3),
};

INT CRenameSnapin::s_ccolinfo = sizeof(s_colinfo) / sizeof(CColumnInfoEx);
INT CRenameSnapin::s_colwidths[1];
#pragma END_CODESPACE_DATA

// include members needed for every snapin.
SNAPIN_DEFINE(CRenameSnapin);

/* CRenameSnapin::CRenameSnapin
 *
 * PURPOSE:             Constructor
 *
 * PARAMETERS: None
 *
 */
CRenameSnapin::CRenameSnapin()
{
    m_pstrDisplayName = new tstring();

    *m_pstrDisplayName = _T("Rename Snapin Root");
}

/* CRenameSnapin::~CRenameSnapin
 *
 * PURPOSE:             Destructor
 *
 * PARAMETERS: None
 *
 */
CRenameSnapin::~CRenameSnapin()
{
    delete m_pstrDisplayName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\sample\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TestSnapins.rc
//
#define IDR_TESTSNAPINS_TYPELIB         1
#define IDS_LVContainer                 2
#define IDS_LVLeafItem                  3
#define IDS_SAMPLEROOT                  4
#define IDB_NODES16                     103
#define IDB_NODES32                     105
#define IDB_COMMONTB                    106
#define IDB_SNAPINTB                    107
#define IDB_FOLDER16                    108
#define IDB_FOLDER16OP                  109
#define IDB_FOLDER32                    110
#define IDB_POWER16                     111
#define IDB_POWER32                     112
#define IDD_ConsolePowerTest            133
#define IDS_SAMPLESNAPIN                1000
#define IDS_POWERTESTSNAPIN             1001
#define IDS_CreateConsolePower          1002
#define IDS_ReleaseConsolePower         1003
#define IDS_ResetIdleTimer              1004
#define IDS_SetExecutionState           1005
#define IDS_SampleExtnSnapinDescription 1006
#define IDS_SampleExtnSnapinName        1007
#define IDS_Component2TestROOT          1008
#define IDS_Component2SNAPIN            1009
#define IDS_Component2SNAPINDesc        1009
#define IDS_Component2SNAPINName        1010
#define IDS_NewLVItem                   1011
#define IDS_Test                        1012
#define IDS_RenameROOT                  1013
#define IDS_RenameScopeItem             1014
#define IDS_RenameResultItem            1015
#define IDS_RenameSnapinDesc            1016
#define IDS_RenameSnapinName            1017
#define IDS_DragDropRoot                1018
#define IDS_DragDropScopeItem           1019
#define IDS_DragDropResultItem          1020
#define IDS_DragDropSnapinDesc          1021
#define IDS_DragDropSnapinName          1022
#define IDS_EnablePasteInToResultItem   1023
#define IDS_DisableCut                  1024
#define IDS_OCXCachingSnapin            1025
#define IDS_OCXCachingRoot              1026
#define IDS_OCXContainer                1027
#define IDS_EnableOCXCaching            1028
#define IDC_AddGroup                    2000
#define IDC_AddSystem                   2001
#define IDC_AddDisplay                  2002
#define IDC_RemoveGroup                 2003
#define IDC_RemoveSystem                2004
#define IDC_RemoveDisplay               2005
#define IDR_EventViewExt1               3001
#define IDR_EventViewExt2               3002

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        114
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         2006
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\sample\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    sources.

!ENDIF

MAJORCOMP=admin
MINORCOMP=MMC

TARGETNAME=     TestSnapins
TARGETPATH=     obj
TARGETTYPE=     DYNLINK

DLLENTRY=_DllMainCRTStartup
UMTYPE    =     windows

WIN32_WINNT_VERSION=0x0400
WIN32_IE_VERSION=0x0500
SUBSYSTEM_VERSION=4.00

USE_NATIVE_EH   = 1
USE_RTTI        = 1
USE_VCCOM       = 1
USE_STL         = 1
USE_STATIC_ATL  = 1
ATL_VER         = 30
USE_MSVCRT      = 1
USE_WTL         = 1

MIDL_TLBDIR     = $(O)
PASS0_HEADERDIR = $(O)
PASS0_SOURCEDIR = $(O)
MIDL_UUIDDIR    = $(O)

DLLDEF = ..\TestSnapins.def

# Use LINKLIBS (gets passed first) if: (from build.hlp)
#  You are building a dynamic link.
#  You are exporting something that's defined in some other component library that you also build.
#  In your dirs file in the subdirectory above, you have ordered it so that the component libraries
#     are around before you build the dynamic link.
LINKLIBS = \
    $(SDK_LIB_PATH)\mmc.lib                         \
    ..\..\..\..\core\$(CharWidth)\$(O)\uicore.lib   \
    ..\..\..\..\base\$(CharWidth)\$(O)\mmcbase.lib  \
    ..\..\lib\$(CharWidth)\$(O)\SnapinBase.lib


TARGETLIBS = \
    $(SDK_LIB_PATH)\kernel32.lib    \
    $(SDK_LIB_PATH)\user32.lib      \
    $(SDK_LIB_PATH)\oleaut32.lib    \
    $(SDK_LIB_PATH)\ole32.lib       \
    $(SDK_LIB_PATH)\advapi32.lib    \
    $(SDK_LIB_PATH)\uuid.lib        \
    $(SDK_LIB_PATH)\comctl32.lib    \
    $(SDK_LIB_PATH)\gdi32.lib       \
    $(SDK_LIB_PATH)\comdlg32.lib    \
    $(SDK_LIB_PATH)\urlmon.lib      \
    $(SDK_LIB_PATH)\shell32.lib

TLBDir = $(O)

INCLUDES = \
    ..;                    	\
    inc;                    \
    ..\..\inc;              \
    ..\..\..\..\inc;        \
    ..\..\..\..\types\idl\$(O); \
    $(SDK_INC_PATH);        \
    $(TLBDir);


PRECOMPILED_INCLUDE = ..\stdafx.hxx
PRECOMPILED_CXX     = 1

# This target is required so $O\testsnapins.res doesn't become the default target
# for makefile.def.  We want "all" to be the default target.
#
# We have to go to this effort because sources(.inc) is included very early
# in makefile.def.  makefile.inc is the place where this would naturally go,
# but we don't want to have to maintain this dependency list in
# ansi\makefile.inc and unicode\makefile.inc.
dummytarget:    all

$O\testsnapins.res: \
    $(TLBDir)\testsnapins.tlb   \
    ..\res\commontb.bmp         \
    ..\res\folder.bmp           \
    ..\res\folder32.bmp         \
    ..\res\power16.bmp          \
    ..\res\power32.bmp          \
    ..\res\nodes16.bmp          \
    ..\res\nodes32.bmp          \
    ..\res\snpinlst.bmp         \
    ..\res\EventViewExt1.htm    \
    ..\res\EventViewExt2.htm    \
    ..\testsnapins.idl          \

SOURCES = \
    ..\TestSnapins.rc       \
    ..\TestSnapins.idl      \
    ..\TestSnapins.cxx      \
    ..\Component2Snapin.cxx \
    ..\Extension.cpp        \
    ..\nodetypes.cxx        \
    ..\PowerTest.cpp        \
    ..\RenameSnapin.cxx     \
    ..\samplesnap.cxx       \
    ..\ViewExtTest.cpp      \
	..\DragDropTest.cpp     \
	..\OcxCaching.cpp       \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\sample\stdafx.cxx ===
#include "stdafx.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\sample\samplesnap.cxx ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       samplesnap.cxx
//
//  Contents:   Classes that implement sample snapin using the framework.
//
//--------------------------------------------------------------------
#include "stdafx.hxx"


//+-------------------------------------------------------------------
//
//  Member:      CSnapinRootItem::ScInit
//
//  Synopsis:    Called immeadiately after the item is created to init
//               displayname, icon index etc...
//
//  Arguments:   [CBaseSnapin]   -
//               [CColumnInfoEx] - Any columns to be displayed for this item.
//               [INT]           - # of columns
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSnapinRootItem::ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex, INT ccolinfoex, BOOL fIsRoot)
{
    DECLARE_SC(sc, _T("CSnapinRootItem::ScInit"));

    sc = CBaseSnapinItem::ScInit(pSnapin, pcolinfoex, ccolinfoex, fIsRoot);
    if (sc)
        return sc;

    // Init following
    //  a. Icon index.
    //  b. Load display name.

    m_uIconIndex = 3; // use an enum instead of 3

    m_strDisplayName.LoadString(_Module.GetResourceInstance(), IDS_SAMPLEROOT);

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CSnapinRootItem::ScGetField
//
//  Synopsis:    Get the string representation for given field to display
//               it in result pane.
//
//  Arguments:   [DAT]     - The column requested (this is an enumeration).
//               [tstring] - Out string.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSnapinRootItem::ScGetField (DAT dat, tstring& strField)
{
    DECLARE_SC(sc, _T("CSnapinRootItem::ScGetField"));

    switch(dat)
    {
    case datString1:
        strField = _T("Root String1");
        break;

    case datString2:
        strField = _T("Root String2");
        break;

    case datString3:
        strField = _T("Root String3");
        break;

    default:
        E_INVALIDARG;
        break;
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CSnapinRootItem::ScCreateChildren
//
//  Synopsis:    Create any children (nodes & leaf items) for this item.
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSnapinRootItem::ScCreateChildren ()
{
    DECLARE_SC(sc, _T("CSnapinRootItem::ScCreateChildren"));

    t_itemChild *   pitemChild      = NULL;
    t_itemChild *   pitemPrevious   = NULL;

    // If creating multiple items pass "previous" parameter so that the items are linked in
    // the internal linked list which will be enumerated & inserted in scope/result pane.
    // See CBaseSnapinItem::ScCreateItem which will be called by ScCreateLVContainer.

    // Create the child nodes and init them.
    sc = CSampleSnapinLVContainer::ScCreateLVContainer(this, &pitemChild, FALSE); // Why FALSE???
    if (sc)
        return sc;
    pitemPrevious = pitemChild;

    // Next item to create... (If there is next item then it must be linked with previous item)
    // See comments above for more information.

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CSampleSnapinLVContainer::ScInit
//
//  Synopsis:    Called immeadiately after the item is created to init
//               displayname, icon index etc...
//
//  Arguments:   [CBaseSnapin]   -
//               [CColumnInfoEx] - Any columns to be displayed for this item.
//               [INT]           - # of columns
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSampleSnapinLVContainer::ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex, INT ccolinfoex, BOOL fIsRoot)
{
    DECLARE_SC(sc, _T("CSampleSnapinLVContainer::ScInit"));

    sc = CBaseSnapinItem::ScInit(pSnapin, pcolinfoex, ccolinfoex, fIsRoot);
    if (sc)
        return sc;

    // Init following
    //  a. Icon index.
    //  b. Load display name.

    m_uIconIndex = 4; // use an enum instead of 4

    m_strDisplayName.LoadString(_Module.GetResourceInstance(), IDS_LVContainer);

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CSampleSnapinLVContainer::ScGetField
//
//  Synopsis:    Get the string representation for given field to display
//               it in result pane.
//
//  Arguments:   [DAT]     - The column requested (this is an enumeration).
//               [tstring] - Out string.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSampleSnapinLVContainer::ScGetField (DAT dat, tstring& strField)
{
    DECLARE_SC(sc, _T("CSampleSnapinLVContainer::ScGetField"));

    switch(dat)
    {
    case datString1:
        strField = _T("LVContainer String1");
        break;

    case datString2:
        strField = _T("LVContainer String2");
        break;

    case datString3:
        strField = _T("LVContainer String3");
        break;

    default:
        E_INVALIDARG;
        break;
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CSampleSnapinLVContainer::ScCreateChildren
//
//  Synopsis:    Create any children (nodes & leaf items) for this item.
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSampleSnapinLVContainer::ScCreateChildren ()
{
    DECLARE_SC(sc, _T("CSampleSnapinLVContainer::ScCreateChildren"));

    t_itemChild *   pitemChild      = NULL;
    t_itemChild *   pitemPrevious   = NULL;

    // Let us create 10 items for this container.
    for (int i = 0; i < 10; ++i)
    {
        // Create the child nodes and init them.
        sc = CSampleSnapinLVLeafItem::ScCreateLVLeafItem(this, pitemPrevious, &pitemChild, FALSE); // Why FALSE???
        if (sc)
            return sc;
        pitemPrevious = pitemChild;
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CSampleSnapinLVContainer::ScCreateLVContainer
//
//  Synopsis:    Do we really need this method?
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSampleSnapinLVContainer::ScCreateLVContainer(CSnapinRootItem *pitemParent, t_item ** ppitem, BOOL fNew)
{
    DECLARE_SC(sc, _T("CSnapinRootItem::ScCreateLVContainer"));
    t_item *   pitem   = NULL;
    *ppitem = NULL;

    // What to do here?
    sc = ::ScCreateItem(pitemParent, NULL, &pitem, fNew);
    if (sc)
        return sc;

    *ppitem = pitem;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CSampleSnapinLVLeafItem::ScInit
//
//  Synopsis:    Called immeadiately after the item is created to init
//               displayname, icon index etc...
//
//  Arguments:   [CBaseSnapin]   -
//               [CColumnInfoEx] - Any columns to be displayed for this item.
//               [INT]           - # of columns
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSampleSnapinLVLeafItem::ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex, INT ccolinfoex, BOOL fIsRoot)
{
    DECLARE_SC(sc, _T("CSampleSnapinLVLeafItem::ScInit"));

    sc = CBaseSnapinItem::ScInit(pSnapin, pcolinfoex, ccolinfoex, fIsRoot);
    if (sc)
        return sc;

    // Init following
    //  a. Icon index.
    //  b. Load display name.

    m_uIconIndex = 7; // use an enum instead of 7

    m_strDisplayName.LoadString(_Module.GetResourceInstance(), IDS_LVLeafItem);

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CSampleSnapinLVLeafItem::ScGetField
//
//  Synopsis:    Get the string representation for given field to display
//               it in result pane.
//
//  Arguments:   [DAT]     - The column requested (this is an enumeration).
//               [tstring] - Out string.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSampleSnapinLVLeafItem::ScGetField (DAT dat, tstring& strField)
{
    DECLARE_SC(sc, _T("CSampleSnapinLVLeafItem::ScGetField"));

    switch(dat)
    {
    case datString1:
        strField = _T("LVLeaf String1");
        break;

    case datString2:
        strField = _T("LVLeaf String2");
        break;

    case datString3:
        strField = _T("LVLeaf String3");
        break;

    default:
        E_INVALIDARG;
        break;
    }

    return (sc);
}



//+-------------------------------------------------------------------
//
//  Member:      CSampleSnapinLVLeafItem::ScCreateLVLeafItem
//
//  Synopsis:    Do we really need this method?
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSampleSnapinLVLeafItem::ScCreateLVLeafItem(CSampleSnapinLVContainer *pitemParent, t_itemChild * pitemPrevious, t_itemChild ** ppitem, BOOL fNew)
{
    DECLARE_SC(sc, _T("CSampleSnapinLVLeafItem::ScCreateLVLeafItem"));
    t_itemChild *   pitem   = NULL;
    *ppitem = NULL;

    // What to do here?
    sc = ::ScCreateItem(pitemParent, pitemPrevious, &pitem, fNew);
    if (sc)
        return sc;

    *ppitem = pitem;

    return (sc);
}

// Initialize context menu structures. Let us have one item for demonstration.
SnapinMenuItem CSampleSnapinLVLeafItem::s_rgmenuitemLVLeafItem[] =
{
    {IDS_NewLVItem, IDS_NewLVItem, IDS_NewLVItem, CCM_INSERTIONPOINTID_PRIMARY_TOP, NULL, dwMenuAlwaysEnable, dwMenuNeverGray,        dwMenuNeverChecked},
};

INT CSampleSnapinLVLeafItem::s_cmenuitemLVLeafItem = CMENUITEM(s_rgmenuitemLVLeafItem);

// -----------------------------------------------------------------------------
SnapinMenuItem *CSampleSnapinLVLeafItem::Pmenuitem(void)
{
    return s_rgmenuitemLVLeafItem;
}

// -----------------------------------------------------------------------------
INT CSampleSnapinLVLeafItem::CMenuItem(void)
{
    return s_cmenuitemLVLeafItem;
}


//+-------------------------------------------------------------------
//
//  Member:      CSampleSnapinLVLeafItem::ScCommand
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSampleSnapinLVLeafItem::ScCommand (long nCommandID, CComponent *pComponent)
{
    DECLARE_SC(sc, _T("CSampleSnapinLVLeafItem::ScCommand"));

    switch(nCommandID)
    {
    case IDS_NewLVItem:
        sc = ScInsertResultItem(pComponent);
        break;

    default:
        sc = E_INVALIDARG;
        break;
    }

    return (sc);
}



//-------------------------------------------------------------------------------------
// class CSampleSnapin

#pragma BEGIN_CODESPACE_DATA
SNR     CSampleSnapin::s_rgsnr[] =
{
    SNR(&nodetypeSampleRoot,         snrEnumSP ),              // Standalone snapin.
    SNR(&nodetypeSampleLVContainer,  snrEnumSP | snrEnumRP ),  // enumerates this node in the scope pane and result pane.
    SNR(&nodetypeSampleLVLeafItem,   snrEnumSP | snrEnumRP ),  // enumerates this node in the scope pane and result pane.
};

LONG  CSampleSnapin::s_rgiconid[]           = {3};
LONG  CSampleSnapin::s_iconidStatic         = 2;


CColumnInfoEx CSampleSnapin::s_colinfo[] =
{
    CColumnInfoEx(_T("Column Name0"),   LVCFMT_LEFT,    180,    datString1),
    CColumnInfoEx(_T("Column Name1"),   LVCFMT_LEFT,    180,    datString2),
    CColumnInfoEx(_T("Column Name2"),   LVCFMT_LEFT,    180,    datString3),
};

INT CSampleSnapin::s_ccolinfo = sizeof(s_colinfo) / sizeof(CColumnInfoEx);
INT CSampleSnapin::s_colwidths[1];
#pragma END_CODESPACE_DATA

// include members needed for every snapin.
SNAPIN_DEFINE( CSampleSnapin);

/* CSampleSnapin::CSampleSnapin
 *
 * PURPOSE:             Constructor
 *
 * PARAMETERS: None
 *
 */
CSampleSnapin::CSampleSnapin()
{
    m_pstrDisplayName = new tstring();

    *m_pstrDisplayName = _T("Sample Snapin Root");
}

/* CSampleSnapin::~CSampleSnapin
 *
 * PURPOSE:             Destructor
 *
 * PARAMETERS: None
 *
 */
CSampleSnapin::~CSampleSnapin()
{
    delete m_pstrDisplayName;
}


//-------------------------------------------------------------------------------------
// class CSampleGhostRootSnapinItem


/* CSampleGhostRootSnapinItem::ScInitializeNamespaceExtension
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *              PDATAOBJECT    lpDataObject:
 *              HSCOPEITEM     item:
 *              CNodeType *    pNodeType:
 *
 * RETURNS:
 *              SC
 */
SC
CSampleGhostRootSnapinItem::ScInitializeNamespaceExtension(LPDATAOBJECT lpDataObject, HSCOPEITEM item, CNodeType *pNodeType)
{
    DECLARE_SC(sc, _T("CSampleGhostRootSnapinItem::ScInitializeNamespaceExtension()"));

    return sc;
}


/* CSampleGhostRootSnapinItem::ScCreateChildren
 *
 * PURPOSE:     Creates children items
 *
 * PARAMETERS:
 *
 * RETURNS:
 *              SC
 */
SC
CSampleGhostRootSnapinItem::ScCreateChildren( void )
{
    DECLARE_SC(sc, _T("CSampleGhostRootSnapinItem::ScCreateChildren()"));
    t_itemChild *    pitemChild = NULL;

    sc = CBaseProtSnapinItem::ScCreateItem(this, NULL, &pitemChild, FALSE /*fNew*/ );
    if (sc)
        return sc;

    pitemChild->InitContainer();

    return sc;
}


//-------------------------------------------------------------------------------------
// class CBaseProtSnapinItem


/* CBaseProtSnapinItem::CBaseProtSnapinItem
 *
 * PURPOSE:             Constructor
 *
 * PARAMETERS:  None
 *
 */
CBaseProtSnapinItem::CBaseProtSnapinItem()
{
    m_fIsContainer  = FALSE;
}


/* CBaseProtSnapinItem::ScGetField
 *
 * PURPOSE:                     Gets the string value of a field.
 *
 * PARAMETERS:
 *              DAT             dat:            The field.
 *              STR *   pstrField:      [OUT]: The string value.
 *
 * RETURNS:
 *              SC
 */
SC
CBaseProtSnapinItem::ScGetField(DAT dat, tstring& strField)
{
    ASSERT(FALSE);
    return S_OK;
}


/* CBaseProtSnapinItem::ScCreateChildren
 *
 * PURPOSE:     Creates children items
 *
 * PARAMETERS:
 *
 * RETURNS:
 *              SC
 */
SC
CBaseProtSnapinItem::ScCreateChildren( void )
{
    DECLARE_SC(sc, _T("CBaseProtSnapinItem::ScCreateChildren()"));
    t_itemChild *   pitemChild = NULL;
    t_itemChild *   pitemPrevious = NULL;

    if ( FIsContainer() )
    {
        for ( INT idob = 0; idob < 10; idob++ )
        {
            // insert protocols
            sc = ScCreateItem(this, pitemPrevious, &pitemChild, FALSE /*fNew*/);
            if (sc)
                return sc;

            pitemPrevious = pitemChild;
        }
    }

    return sc;
}


/* CBaseProtSnapinItem::ScCreateItem
 *
 * PURPOSE:             Creates a new child item, assuming the DOB for it already exists.
 *
 * PARAMETERS:
 *              CBaseSnapinItem * pitemParent   The parent of this item - should be 'this' of the calling class
 *              t_itemChild *   pitemPrevious:  The previous item to link the newly created item to.
 *              t_itemChild **  ppitem:                 [OUT]: The new item.
 *              BOOL                    fNew                    new item?
 *
 * RETURNS:
 *              SC
 */
SC
CBaseProtSnapinItem::ScCreateItem(CBaseSnapinItem *pitemParent, t_itemChild * pitemPrevious, t_itemChild ** ppitem, BOOL fNew)
{
    DECLARE_SC(sc, _T("CBaseProtSnapinItem::ScCreateItem()"));
    t_itemChild *   pitem   = NULL;

    *ppitem = NULL;

    sc = ::ScCreateItem(pitemParent, pitemPrevious, &pitem, fNew);
    if (sc)
        return sc;

    *ppitem = pitem;
    return sc;
}


//-------------------------------------------------------------------------------------
// class CSampleExtnSnapin

#pragma BEGIN_CODESPACE_DATA    // $REVIEW should all the nodetypes be registered?
SNR     CSampleExtnSnapin::s_rgsnr[] =
{
//    SNR(&nodetypeSampleRoot,     snrExtNS ),                             // extends the namespace of a server node.
    SNR(&nodetypeSampleExtnNode, snrEnumSP | snrEnumRP ),// enumerates this node in the scope pane and result pane.
};

LONG  CSampleExtnSnapin::s_rgiconid[]               = { 0};
LONG  CSampleExtnSnapin::s_iconidStatic             = 0;


CColumnInfoEx CSampleExtnSnapin::s_colinfo[] =
{
    CColumnInfoEx(_T("Extn Column Name0"),   LVCFMT_LEFT,    180,    datString1),
};

INT CSampleExtnSnapin::s_ccolinfo = sizeof(s_colinfo) / sizeof(CColumnInfoEx);
INT CSampleExtnSnapin::s_colwidths[1];
#pragma END_CODESPACE_DATA

// include members needed for every snapin.
SNAPIN_DEFINE(CSampleExtnSnapin);

/* CSampleExtnSnapin::CSampleExtnSnapin
 *
 * PURPOSE:             Constructor
 *
 * PARAMETERS: None
 *
 */
CSampleExtnSnapin::CSampleExtnSnapin()
{
    m_pstrDisplayName = new tstring();

    *m_pstrDisplayName = _T("Sample Snapin Extn");
}

/* CSampleExtnSnapin::~CSampleExtnSnapin
 *
 * PURPOSE:             Destructor
 *
 * PARAMETERS: None
 *
 */
CSampleExtnSnapin::~CSampleExtnSnapin()
{
    delete m_pstrDisplayName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\types\proxy\dlldata_wrap.c ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      dlldata_wrap.c
 *
 *  Contents:  Wraps dlldata_p.c from MIDL
 *
 *  History:   20-Jun-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#include "dlldata.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\sample\testsnapins.cxx ===
#include "stdafx.hxx"

#include "init.cxx"
#include "ViewExtTest.h"

#define _SNAPINLIST_FILE        "TestSnapinslist.hxx"
#define _FREGISTERTYPELIB       FALSE

#define SNAPIN_COM_OBJECTS												\
	OBJECT_ENTRY(CLSID_EventViewExtension1, CEventViewExtension1)		\
	OBJECT_ENTRY(CLSID_EventViewExtension2, CEventViewExtension2)		\

#include <targetdll.cxx>

const tstring szHelpFileTOC = _T("");

// Name of context-sensitive help file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\sample\viewexttest.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      viewexttest.cpp
 *
 *  Contents:  Implementation file for view extension test snap-ins
 *
 *  History:   20-Mar-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.hxx"
#include "ViewExtTest.h"


// {49737049-EBF3-4e1c-B034-DE4936EDD1F4}
const CLSID CLSID_EventViewExtension1 =
{ 0x49737049, 0xebf3, 0x4e1c, { 0xb0, 0x34, 0xde, 0x49, 0x36, 0xed, 0xd1, 0xf4 } };

// {94AED30D-A033-436c-9919-E09CBA339973}
const CLSID CLSID_EventViewExtension2 =
{ 0x94aed30d, 0xa033, 0x436c, { 0x99, 0x19, 0xe0, 0x9c, 0xba, 0x33, 0x99, 0x73 } };


/*+-------------------------------------------------------------------------*
 * CEventViewExtension1::GetViews
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CViewExtension::GetViews (
	IDataObject*			pDataObject,
	IViewExtensionCallback*	pViewExtCallback)
{
	DECLARE_SC (sc, _T("CEventViewExtension1::GetView"));

	sc = ScCheckPointers (pViewExtCallback);
	if (sc)
		return (sc.ToHr());

	/*
	 * generate a URL for the view extension using the res: protocol and
	 * duplicate it into a CoTaskMemAlloc'd buffer
	 */
	TCHAR szModule[_MAX_PATH];
	GetModuleFileName (_Module.GetModuleInstance(), szModule, countof(szModule));

	std::wstring strURL;
	UINT nResourceID = GetResourceID();

	if (nResourceID != 0)
	{
		WCHAR szResourceID[6];
		_itow (nResourceID, szResourceID, 10);

		USES_CONVERSION;
		strURL = std::wstring(L"res://") + T2W(szModule) + L"/" + szResourceID;
	}
	else
		strURL = GetResource();

	std::wstring	strTabName (GetTabName());
	std::wstring	strTooltip (GetTooltip());

	MMC_EXT_VIEW_DATA xvd;
	xvd.viewID               = GetCLSID();
	xvd.pszURL               = strURL.data();
	xvd.pszViewTitle         = strTabName.data();
	xvd.pszTooltipText       = strTooltip.data();
	xvd.bReplacesDefaultView = TRUE;

	return (pViewExtCallback->AddView (&xvd));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\sample\viewexttest.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      viewexttest.h
 *
 *  Contents:
 *
 *  History:   20-Mar-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once

#include "Extension.h"
#include "string.h"


class CViewExtension :
	public CExtension,
	public IExtendView
{
	BEGIN_COM_MAP(CViewExtension)
		COM_INTERFACE_ENTRY(IExtendView)
	END_COM_MAP()

public:
	// IExtendView methods
	STDMETHOD(GetViews) (IDataObject* pDataObject, IViewExtensionCallback* pViewExtCallback);

	virtual const CLSID&	GetCLSID()		const = 0;
	virtual std::wstring	GetTabName()	const = 0;
	virtual std::wstring	GetTooltip()	const = 0;
	virtual UINT			GetResourceID()	const		{ return 0; }
	virtual std::wstring	GetResource()	const		{ return L""; }

private:

};


extern const CLSID CLSID_EventViewExtension1;

class CEventViewExtension1 :
	public CViewExtension,
	public CComCoClass<CEventViewExtension1, &CLSID_EventViewExtension1>
{
	DECLARE_EXTENSION_REGISTRATION(
		eExtType_View,
		CLSID_EventViewExtension1,
		"EventViewExtension1 Class",
		"TestSnapins.EventViewExtension1.1",
		"TestSnapins.EventViewExtension1",
		"{7AB4A1FC-E403-11D0-9A97-00C04FD8DBF7}");	// event viewer nodetype

public:
	virtual const CLSID&	GetCLSID()		const	{ return (CLSID_EventViewExtension1);	}
	virtual std::wstring	GetTabName()	const	{ return (L"Event Ext 1"); }
	virtual std::wstring	GetTooltip()	const	{ return (L"Tooltip for Event Ext 1"); }
	virtual UINT			GetResourceID()	const	{ return (IDR_EventViewExt1); }
	virtual std::wstring	GetResource()	const	{ return (L"file://d:\\newnt\\admin\\mmcdev\\test\\Snapins\\Sample\\res\\EventViewExt1.htm"); }

};


extern const CLSID CLSID_EventViewExtension2;

class CEventViewExtension2 :
	public CViewExtension,
	public CComCoClass<CEventViewExtension2, &CLSID_EventViewExtension2>
{
	DECLARE_EXTENSION_REGISTRATION(
		eExtType_View,
		CLSID_EventViewExtension2,
		"EventViewExtension2 Class",
		"TestSnapins.EventViewExtension2.1",
		"TestSnapins.EventViewExtension2",
		"{7AB4A1FC-E403-11D0-9A97-00C04FD8DBF7}");	// event viewer nodetype

public:
	virtual const CLSID&	GetCLSID()		const	{ return (CLSID_EventViewExtension2);	}
	virtual std::wstring	GetTabName()	const	{ return (L"Event Ext 2"); }
	virtual std::wstring	GetTooltip()	const	{ return (L"Tooltip for Event Ext 2"); }
	virtual UINT			GetResourceID()	const	{ return (IDR_EventViewExt2); }
	virtual std::wstring	GetResource()	const	{ return (L"file://d:\\newnt\\admin\\mmcdev\\test\\Snapins\\Sample\\res\\EventViewExt2.htm"); }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\types\proxy\hcolwrap_wrap.c ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      hcolwrap_wrap.c
 *
 *  Contents:  Wraps hcolwrap_p.c from MIDL
 *
 *  History:   20-Jun-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#include "hcolwrap_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\types\proxy\ndmgriid.c ===
#include "ndmgr_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\types\proxy\ndmgr_wrap.c ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      ndmgr_wrap.c
 *
 *  Contents:  Wraps ndmgr_p.c from MIDL
 *
 *  History:   20-Jun-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#include "ndmgr_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\adminpak\dllsource\msidatabase.h ===
// MsiDatabase.h: interface for the CMsiDatabase class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MSIDATABASE_H__43FFFD81_6D04_11D2_9EE3_00C04FC2F1A5__INCLUDED_)
#define AFX_MSIDATABASE_H__43FFFD81_6D04_11D2_9EE3_00C04FC2F1A5__INCLUDED_

#include <tchar.h>

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define BUFFERSIZE 1000


class CMsiDatabase  
{
public:
	BOOL GetProperty(TCHAR* name, TCHAR** pszBuf);
	BOOL SetProperty(TCHAR* ptName, TCHAR* ptValue);
	CMsiDatabase();
	CMsiDatabase(MSIHANDLE hInstall);
	virtual ~CMsiDatabase();

protected:
	MSIHANDLE	m_hDatabase;
	MSIHANDLE	m_hInstall;
	TCHAR**		m_pszBuf;
private:

};

#endif // !defined(AFX_MSIDATABASE_H__43FFFD81_6D04_11D2_9EE3_00C04FC2F1A5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\adminpak\dllsource\adminpak.cpp ===
// adminpak.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
#include <stdio.h>
#include <shellapi.h>
#include "shlobj.h"
#include "adminpak.h"

#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"
#include "shlwapi.h"

// version resource specific structures
typedef struct __tagLanguageAndCodePage {
  WORD wLanguage;
  WORD wCodePage;
} TTRANSLATE, *PTTRANSLATE;

typedef struct __tagVersionBreakup {
    DWORD dwMajor;
    DWORD dwMinor;
    DWORD dwRevision;           // build number
    DWORD dwSubRevision;        // QFE / SP
} TVERSION, *PTVERSION;

enum {
    translateError = -2,
    translateLesser = -1, translateEqual = 0, translateGreater = 1,
    translateWrongFile = 2
};


#define ADMINPAK_EXPORTS		1

BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    UNREFERENCED_PARAMETER( hModule );
    UNREFERENCED_PARAMETER( lpReserved );
    switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		case DLL_PROCESS_DETACH:
			break;
    }
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// CMAK Migration Code

//
//  Define Strings Chars
//
static const CHAR c_szDaoClientsPath[] = "SOFTWARE\\Microsoft\\Shared Tools\\DAO\\Clients";
static const CHAR c_szCmakRegPath[] = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\CMAK.EXE";
static const CHAR c_szPathValue[] = "Path";
static const CHAR c_szProfiles32Fmt[] = "%s\\Profiles-32";
static const CHAR c_szCm32Fmt[] = "%s\\cm32";
static const CHAR c_szProfilesFmt[] = "%s\\Profiles";
static const CHAR c_szSupportFmt[] = "%s\\Support";
static const CHAR c_szCmHelpFmt[] = "%s\\Support\\CmHelp";
static const CHAR c_szCmakGroup[] = "Connection Manager Administration Kit";
static const CHAR OC_OLD_IEAK_DOCDIR[] = "Docs";
static const CHAR OC_NTOP4_GROUPNAME[] = "Windows NT 4.0 Option Pack";
static const CHAR OC_ICS_GROUPNAME[] = "Internet Connection Services for RAS";
static const CHAR OC_ADMIN_TOOLS[] = "\\Administrative Tools\\Phone Book Administrator.lnk";
static const CHAR OC_PBA_DESC[] = "Use Phone Book Administrator to create Connection Manager Phone Book ";
static const CHAR OC_PWS_GROUPNAME[] = "Microsoft Personal Web Server";

const DWORD c_dwCmakDirID = 123174; // just must be larger than DIRID_USER = 0x8000;

//
//  Define Functions
//
BOOL migrateProfiles(LPCTSTR pszSource, LPCTSTR pszDestination, LPCTSTR pszDestinationProfiles);
void DeleteOldCmakSubDirs(LPCTSTR pszCmakPath);
void DeleteProgramGroupWithLinks(LPCTSTR pszGroupPath);
void DeleteOldNtopLinks();
void DeleteIeakCmakLinks();
void DeleteCmakRegKeys();
void CreateNewProfilesDirectory( LPCTSTR pszNewProfilePath );
HRESULT HrGetPBAPathIfInstalled(PSTR pszCpaPath, DWORD dwNumChars);
BOOL GetAdminToolsFolder(PSTR pszAdminTools);
HRESULT HrCreatePbaShortcut(PSTR pszCpaPath);

// This function migrates the old profile versions of CMAK to the new one placed 
// by the adminpak....
extern "C" ADMINPAK_API int __stdcall  fnMigrateProfilesToNewCmak( MSIHANDLE hInstall )
{
    OutputDebugString("ADMINPAK: fnMigrateProfilesToNewCmak...\n");

    // Get the location of the old CMAK folder.
    DWORD   dwPathLength = MAX_PATH * sizeof(char);
    char    *szCmakOldPath = NULL;
    DWORD   dwCmakOldPathLen = dwPathLength;
    char    *szCmakOldProfilePath = NULL;
    DWORD   dwCmakOldProfilePathLen = dwPathLength;

    char    *szCmakNewPath = NULL;
    DWORD   dwCmakNewPathLen = dwPathLength;
    char    *szCmakNewProfilePath = NULL;
    DWORD   dwCmakNewProfilePathLen = dwPathLength;

    long    sc;
    UINT    uintRet;
    HKEY    phkResult = NULL;
    HRESULT res = S_OK;

#if (defined(DBG) || defined(_DEBUG) || defined(DEBUG))
    char    tempOut1[MAX_PATH];
#endif

    szCmakOldPath = new char[dwCmakOldPathLen];
    szCmakNewPath = new char[dwCmakNewPathLen];
    szCmakOldProfilePath = new char[dwCmakOldProfilePathLen];
    szCmakNewProfilePath = new char[dwCmakNewProfilePathLen];
    if ( szCmakOldPath == NULL || 
         szCmakNewPath == NULL || 
         szCmakOldProfilePath == NULL || 
         szCmakNewProfilePath == NULL )
    {
        if ( szCmakOldPath != NULL )
        {
            delete [] szCmakOldPath;
        }

        if ( szCmakNewPath != NULL )
        {
            delete [] szCmakNewPath;
        }

        if ( szCmakOldProfilePath != NULL )
        {
            delete [] szCmakOldProfilePath;
        }

        if ( szCmakNewProfilePath != NULL )
        {
            delete [] szCmakNewProfilePath;
        }

        return E_OUTOFMEMORY;
    }

// Put together OLD path information
    sc = RegOpenKeyEx( HKEY_LOCAL_MACHINE, c_szCmakRegPath, 0, KEY_READ, &phkResult);
    if ( sc != ERROR_SUCCESS )
    {
        delete [] szCmakOldPath;
        delete [] szCmakOldProfilePath;
        delete [] szCmakNewPath;
        delete [] szCmakNewProfilePath;
        return sc;
    }

    sc = RegQueryValueEx( phkResult, "Path", NULL, NULL, (unsigned char*)szCmakOldPath, &dwCmakOldPathLen );
    RegCloseKey( phkResult );
//    sc = ERROR_SUCCESS;
//    strcpy(szCmakOldPath, "c:\\cmak\\");

    if ( sc == ERROR_SUCCESS ) {
        dwCmakOldPathLen = (DWORD)strlen( szCmakOldPath );
        char tmpLastChar = *(szCmakOldPath + (dwCmakOldPathLen - 1));
        if ( tmpLastChar == '\\' ) {
            *(szCmakOldPath + (dwCmakOldPathLen - 1)) = NULL;
            dwCmakOldPathLen = (DWORD)strlen( szCmakOldPath );
        }

#if (defined(DBG) || defined(_DEBUG) || defined(DEBUG))
//		StringCchPrintf(tempOut1, "ADMINPAK: szCmakOldPath: %s\n", szCmakOldPath);
		OutputDebugString( tempOut1 );
#endif

        res = StringCchCopy( szCmakOldProfilePath, dwPathLength, szCmakOldPath );
        dwCmakOldProfilePathLen = dwCmakOldPathLen;

        res = StringCchCat(szCmakOldProfilePath, dwPathLength, "\\Profiles");
        dwCmakOldProfilePathLen = (DWORD)strlen( szCmakOldProfilePath );
    }

// Put together NEW path information
    uintRet = MsiGetTargetPath( hInstall, "DirCMAK", szCmakNewPath, &dwCmakNewPathLen);
//    uintRet = ERROR_SUCCESS;
//    strcpy(szCmakNewPath, "c:\\cmak\\program files");

    if ( uintRet == ERROR_SUCCESS ) {
        dwCmakNewPathLen = (DWORD)strlen( szCmakNewPath );
        char tmpLastChar = *(szCmakNewPath + (dwCmakNewPathLen - 1));
        if ( tmpLastChar == '\\' ) {
            *(szCmakNewPath + (dwCmakNewPathLen - 1)) = NULL;
            dwCmakNewPathLen = (DWORD)strlen( szCmakNewPath );
        }

#if (defined(DBG) || defined(_DEBUG) || defined(DEBUG))
 //       StringCchPrintf(tempOut1, "ADMINPAK: szCmakNewPath: %s\n", szCmakNewPath);
        OutputDebugString( tempOut1 );
#endif

        res = StringCchCopy( szCmakNewProfilePath, dwPathLength, szCmakNewPath );
        dwCmakNewProfilePathLen = dwCmakNewPathLen;

        res = StringCchCat(szCmakNewProfilePath, dwPathLength, "\\Profiles");
        dwCmakNewProfilePathLen = strlen( szCmakNewProfilePath );
    }

    // if all is Success then DO IT!
    if ( sc == ERROR_SUCCESS && uintRet == ERROR_SUCCESS && res == S_OK) {
//    RenameProfiles32(LPCTSTR pszCMAKpath, LPCTSTR pszProfilesDir);
//        RenameProfiles32( szCmakOldPath, szCmakNewProfilePath );

//    BOOL migrateProfiles(PCWSTR pszSource, LPCTSTR pszDestination);
        migrateProfiles( szCmakOldPath, szCmakNewPath, szCmakNewProfilePath );

//    DeleteOldCmakSubDirs(LPCTSTR pszCmakPath);
        DeleteOldCmakSubDirs( szCmakOldPath );
        
    }

    delete [] szCmakOldPath;
    delete [] szCmakOldProfilePath;
    delete [] szCmakNewPath;
    delete [] szCmakNewProfilePath;

	
    return ERROR_SUCCESS;
}

extern "C" ADMINPAK_API int __stdcall  fnDeleteOldCmakVersion( MSIHANDLE hInstall )
{
    OutputDebugString("ADMINPAK: fnDeleteOldCmakVersion...\n");

    // If PBA exists, you need to 
    CHAR szPbaInstallPath[MAX_PATH+1];
    
    HRESULT hr;
    hr = HrGetPBAPathIfInstalled(szPbaInstallPath, MAX_PATH);

    UNREFERENCED_PARAMETER( hInstall );

    if (S_OK == hr)
    {
        HrCreatePbaShortcut(szPbaInstallPath);
    }

    DeleteOldNtopLinks();
    DeleteIeakCmakLinks();
    DeleteCmakRegKeys();

	
	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  Function:   migrateProfiles
//
//  Purpose:    This is the function that migrates the profiles.  It takes the current
//              CMAK dir as its first input and the new CMAK dir as its second input..
//
//  Arguments:  PCWSTR pszSource - root of source CMAK dir
//              PCWSTR pszDestination - root of destination CMAK dir
//
//  Returns:    BOOL - Returns TRUE if it was able to migrate the profiles.
//
//  Author:     a-anasj   9 Mar 1998
//
//  Notes:
// History:   quintinb Created    12/9/97
//
BOOL migrateProfiles(LPCTSTR pszSource, LPCTSTR pszDestination, LPCTSTR pszDestinationProfiles)
{
    OutputDebugString("ADMINPAK: migrateProfiles...\n");

    CHAR szSourceProfileSearchString1[MAX_PATH+1] ="" ;
    CHAR szSourceProfileSearchString2[MAX_PATH+1] = "";
    CHAR szFile[MAX_PATH+1] = "";
    HANDLE hFileSearch;
    WIN32_FIND_DATA fdFindData;
    BOOL bReturn = TRUE;
    SHFILEOPSTRUCT fOpStruct;
	
	DWORD dwSize = _MAX_PATH;      
	HRESULT res;
    //
    //  Initialize the searchstring and the destination dir
    //
	
    //StringCchPrintf(szSourceProfileSearchString1, "%s\\*.*", pszSource);

    //
    //  Create the destination directory
    //

    CreateNewProfilesDirectory( pszDestinationProfiles );
//    ::CreateDirectory(pszDestination, NULL); //lint !e534 this might fail if it already exists

    hFileSearch = FindFirstFile(szSourceProfileSearchString1, &fdFindData);

    while (INVALID_HANDLE_VALUE != hFileSearch)
    {

        if((fdFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
            (0 != _stricmp(fdFindData.cFileName, "cm32")) && // 1.1/1.2 Legacy
            (0 != _stricmp(fdFindData.cFileName, "cm16")) && // 1.1/1.2 Legacy
            (0 != _stricmp(fdFindData.cFileName, "Docs")) &&
            (0 != _stricmp(fdFindData.cFileName, "Profiles-32")) && // 1.1/1.2 Legacy
            (0 != _stricmp(fdFindData.cFileName, "Profiles-16")) && // 1.1/1.2 Legacy
            (0 != _stricmp(fdFindData.cFileName, "Support")) &&
            (0 != _stricmp(fdFindData.cFileName, "Profiles")) &&
            (0 != _stricmp(fdFindData.cFileName, ".")) &&
            (0 != _stricmp(fdFindData.cFileName, "..")))
        {
            //
            //  Then I have a profile directory
            //
			
            ZeroMemory(&fOpStruct, sizeof(fOpStruct));
            ZeroMemory(szFile, sizeof(szFile));
            //StringCchPrintf(szFile, "%s\\%s", pszSource, fdFindData.cFileName);

            fOpStruct.hwnd = NULL;
            fOpStruct.wFunc = FO_MOVE;
            fOpStruct.pTo = pszDestinationProfiles;
            fOpStruct.pFrom = szFile;
            fOpStruct.fFlags = FOF_SILENT | FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR | FOF_RENAMEONCOLLISION;

            bReturn &= (0== SHFileOperation(&fOpStruct));   //lint !e514, intended use of boolean, quintinb
        }
        else if((fdFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
            ((0 == _stricmp(fdFindData.cFileName, "Profiles")) ||// 1.1/1.2 Legacy
            (0 == _stricmp(fdFindData.cFileName, "Profiles-32")) ||// 1.1/1.2 Legacy
            (0 == _stricmp(fdFindData.cFileName, "Profiles-16"))) )// 1.1/1.2 Legacy
        {
            //
            //  Then I have a profile directory
            //

            res = StringCchCopy(szSourceProfileSearchString2, dwSize, pszSource);
            res = StringCchCat(szSourceProfileSearchString2, dwSize,"\\");
            res = StringCchCat(szSourceProfileSearchString2, dwSize,fdFindData.cFileName);
            //StringCchPrintf(szSourceProfileSearchString2, "%s\\*.*", szSourceProfileSearchString2);

            if (res == S_OK)
			{
				HANDLE hFileSearch2;
				WIN32_FIND_DATA fdFindData2;
			

				hFileSearch2 = FindFirstFile(szSourceProfileSearchString2, &fdFindData2);
				while (INVALID_HANDLE_VALUE != hFileSearch2)
				{
					if((fdFindData2.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
						(0 != _stricmp(fdFindData2.cFileName, ".")) &&
						(0 != _stricmp(fdFindData2.cFileName, "..")))
					{
						ZeroMemory(&fOpStruct, sizeof(fOpStruct));
						ZeroMemory(szFile, sizeof(szFile));
						//StringCchPrintf(szFile, "%s\\%s\\%s", pszSource, fdFindData.cFileName, fdFindData2.cFileName);

						fOpStruct.hwnd = NULL;
						fOpStruct.wFunc = FO_MOVE;
						fOpStruct.pTo = pszDestinationProfiles;
						fOpStruct.pTo = NULL;
						fOpStruct.pFrom = szFile;
						fOpStruct.fFlags = FOF_SILENT | FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR | FOF_RENAMEONCOLLISION;

						bReturn &= (0== SHFileOperation(&fOpStruct));   //lint !e514, intended use of boolean, quintinb
					}
					if (!FindNextFile(hFileSearch2, &fdFindData2)) {
						// Delete the folder
						if ( 0 != _stricmp(fdFindData.cFileName, "Profiles") ) {
							//StringCchPrintf(szFile, "%s\\%s", pszSource, fdFindData.cFileName);
							::RemoveDirectory(szFile);
						}
						break;
					}
				}
				if (INVALID_HANDLE_VALUE != hFileSearch2) {
				FindClose(hFileSearch2);
				}
			}

        }
        //Modified by v-mmosko. Need speical case to leave behind these 2 files
        else if ( 0 != _stricmp(fdFindData.cFileName, "cmproxy.dll") ||
           0 != _stricmp(fdFindData.cFileName, "cmroute.dll") )
        {
            
        }
        else if ( 0 != _stricmp(fdFindData.cFileName, ".") &&
                  0 != _stricmp(fdFindData.cFileName, "..") )
        {
            ZeroMemory(&fOpStruct, sizeof(fOpStruct));
            ZeroMemory(szFile, sizeof(szFile));
            //StringCchPrintf(szFile, "%s\\%s", pszSource, fdFindData.cFileName);

            fOpStruct.hwnd = NULL;
            fOpStruct.wFunc = FO_DELETE;
            fOpStruct.pFrom = szFile;
            fOpStruct.fFlags = FOF_SILENT | FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR;

            bReturn &= (0== SHFileOperation(&fOpStruct));   //lint !e514, intended use of boolean, quintinb
        }

        //
        //  Check to see if we have any more Files
        //
        if (!FindNextFile(hFileSearch, &fdFindData))
        {
            if (ERROR_NO_MORE_FILES != GetLastError())
            {
                //
                //  We had some unexpected error, report unsuccessful completion
                //
                bReturn = FALSE;
            }

            // Exit loop
            break;
        }
    }

    if (INVALID_HANDLE_VALUE != hFileSearch)
    {
        FindClose(hFileSearch);
    }

    //
    //  Delete the old CMAK directory if it is not the same as the new directory.
    //
    if ( 0 != _stricmp(pszSource, pszDestination) ) {
        ZeroMemory(&fOpStruct, sizeof(fOpStruct));

        fOpStruct.hwnd = NULL;
        fOpStruct.wFunc = FO_DELETE;
        fOpStruct.pTo = NULL;
        fOpStruct.pFrom = pszSource;
        fOpStruct.fFlags = FOF_SILENT | FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR;

        bReturn &= (0== SHFileOperation(&fOpStruct));   //lint !e514, intended use of boolean, quintinb
    }

    return bReturn;
}


//+---------------------------------------------------------------------------
//
//  Function:   DeleteOldCmakSubDirs
//
//  Purpose:    Deletes the old Cmak sub directories.  Uses FindFirstFile becuase
//              we don't want to delete any customized doc files that the user may
//              have customized.  Thus anything in the CMHelp directory except the
//              original help files is deleted.
//
//  Arguments:  PCWSTR pszCMAKpath - current cmak path
//
//  Returns:    Nothing
//
//  Author:     quintinb   6 Nov 1998
//
//  Notes:
void DeleteOldCmakSubDirs(LPCTSTR pszCmakPath)
{
	UNREFERENCED_PARAMETER( pszCmakPath );
    OutputDebugString("ADMINPAK: DeleteOldCmakSubDirs...\n");

    CHAR szCm32path[MAX_PATH+1];
    CHAR szCm32SearchString[MAX_PATH+1];
    CHAR szTemp[MAX_PATH+1];
    HANDLE hCm32FileSearch;
    WIN32_FIND_DATA fdCm32;

    //
    // Delete the old IEAK Docs Dir
    //
    //StringCchPrintf(szTemp, "%s\\%s", pszCmakPath, OC_OLD_IEAK_DOCDIR);
    RemoveDirectory(szTemp);

    //StringCchPrintf(szCm32path, c_szCm32Fmt, pszCmakPath);

    //
    //  First look in the Cm32 directory itself.  Delete all files found, continue down
    //  into subdirs.
    //

    //StringCchPrintf(szCm32SearchString, "%s\\*.*", szCm32path);

    hCm32FileSearch = FindFirstFile(szCm32SearchString, &fdCm32);

    while (INVALID_HANDLE_VALUE != hCm32FileSearch)
    {

        if (fdCm32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            if ((0 != _stricmp(fdCm32.cFileName, ".")) &&
               (0 != _stricmp(fdCm32.cFileName, "..")))
            {
                //
                //  Then we want to delete all the files in this lang sub dir and we
                //  we want to delete the four help files from the CM help dir.  If all the
                //  files are deleted from a dir then we should remove the directory.
                //
                CHAR szLangDirSearchString[MAX_PATH+1];
                HANDLE hLangDirFileSearch;
                WIN32_FIND_DATA fdLangDir;

                //StringCchPrintf(szLangDirSearchString, "%s\\%s\\*.*", szCm32path, fdCm32.cFileName);

                hLangDirFileSearch = FindFirstFile(szLangDirSearchString, &fdLangDir);

                while (INVALID_HANDLE_VALUE != hLangDirFileSearch)
                {
                    if (fdLangDir.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    {
                        if ((0 != _stricmp(fdLangDir.cFileName, ".")) &&
                           (0 != _stricmp(fdLangDir.cFileName, "..")))
                        {
                            //
                            //  We only want to delete help files from our help source dirs
                            //
                            if (0 == _strnicmp(fdLangDir.cFileName, "CM", 2))
                            {
                                //
                                //  Delete the four help files only.
                                //
								//StringCchPrintf(szTemp, "%s\\%s\\%s\\cmctx32.rtf", szCm32path, fdCm32.cFileName, fdLangDir.cFileName);
                                DeleteFile(szTemp);

                                //StringCchPrintf(szTemp, "%s\\%s\\%s\\cmmgr32.h", szCm32path, fdCm32.cFileName, fdLangDir.cFileName);
                                DeleteFile(szTemp);

                                //StringCchPrintf(szTemp, "%s\\%s\\%s\\cmmgr32.hpj", szCm32path, fdCm32.cFileName, fdLangDir.cFileName);
                                DeleteFile(szTemp);

                                //StringCchPrintf(szTemp, "%s\\%s\\%s\\cmtrb32.rtf", szCm32path, fdCm32.cFileName, fdLangDir.cFileName);
                                DeleteFile(szTemp);

                                //
                                //  Now try to remove the directory
                                //
                                //StringCchPrintf(szTemp, "%s\\%s\\%s", szCm32path, fd32.cFileName, fdLangDir.cFileName);
                                RemoveDirectory(szTemp);
                            }
                        }
                    }
                    else
                    {
                        //StringCchPrintf(szTemp, "%s\\%s\\%s", szCm32path, fdCm32.cFileName, fdLangDir.cFileName);

                        DeleteFile(szTemp);
                    }

                    //
                    //  Check to see if we have any more Files
                    //
                    if (!FindNextFile(hLangDirFileSearch, &fdLangDir))
                    {
                        //
                        //  Exit the loop
                        //
                        break;
                    }
                }

                if (INVALID_HANDLE_VALUE != hLangDirFileSearch)
                {
                    FindClose(hLangDirFileSearch);

                    //
                    //  Now try to remove the lang dir directory
                    //
                    //StringCchPrintf(szTemp, "%s\\%s", szCm32path, fdCm32.cFileName);
                    RemoveDirectory(szTemp);
                }
            }
        }
        else
        {
            //StringCchPrintf(szTemp, "%s\\%s", szCm32path, fdCm32.cFileName);

            DeleteFile(szTemp);
        }

        //
        //  Check to see if we have any more Files
        //
        if (!FindNextFile(hCm32FileSearch, &fdCm32))
        {
            if (INVALID_HANDLE_VALUE != hCm32FileSearch)
            {
                FindClose(hCm32FileSearch);
            }

            //
            //  Now try to remove the cm32 directory
            //
            RemoveDirectory(szCm32path);

            //
            //  Exit the loop
            //
            break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteProgramGroupWithLinks
//
//  Purpose:    Utility function to delete a given program group and its links.
//              Thus if you pass in the full path to a program group to delete,
//              the function does a findfirstfile to find and delete any links.
//              The function ignores sub-dirs.
//
//
//  Arguments:  PCWSTR pszGroupPath - Full path to the program group to delete.
//
//  Returns:    Nothing
//
//  Author:     quintinb   6 Nov 1998
//
//  Notes:
void DeleteProgramGroupWithLinks(LPCTSTR pszGroupPath)
{
    OutputDebugString("ADMINPAK: DeleteProgramGroupWithLinks...\n");

    HANDLE hLinkSearch;
    WIN32_FIND_DATA fdLinks;
    CHAR szLinkSearchString[MAX_PATH+1];
    CHAR szTemp[MAX_PATH+1];

    //StringCchPrintf(szLinkSearchString, "%s\\*.*", pszGroupPath);

    hLinkSearch = FindFirstFile(szLinkSearchString, &fdLinks);

    while (INVALID_HANDLE_VALUE != szLinkSearchString)
    {
        if (!(fdLinks.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            //StringCchPrintf(szTemp, "%s\\%s", pszGroupPath, fdLinks.cFileName);

            DeleteFile(szTemp);
        }

        //
        //  Check to see if we have any more Files
        //
        if (!FindNextFile(hLinkSearch, &fdLinks))
        {
            FindClose(hLinkSearch);

            //
            //  Now try to remove the directory
            //
            RemoveDirectory(pszGroupPath);

            //
            //  Exit the loop
            //
            break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteOldNtopLinks
//
//  Purpose:    Deletes the old links from the NT 4.0 Option Pack
//
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Author:     quintinb   6 Nov 1998
//
//  Notes:
void DeleteOldNtopLinks()
{
    OutputDebugString("ADMINPAK: DeleteOldNtopLinks...\n");

    BOOL bResult = FALSE;

    //
    //  First Delete the old NTOP4 Path
    //
    CHAR szGroup[MAX_PATH+1];
    CHAR szTemp[MAX_PATH+1];

    //
    //  Get the CSIDL_COMMON_PROGRAMS value
    //
    bResult = SHGetSpecialFolderPath(NULL, szTemp, CSIDL_COMMON_PROGRAMS, FALSE);
    if ( bResult == TRUE )
    {
        //StringCchPrintf(szGroup, "%s\\%s\\%s", szTemp, OC_NTOP4_GROUPNAME, OC_ICS_GROUPNAME);

        DeleteProgramGroupWithLinks(szGroup);

        //StringCchPrintf(szGroup, "%s\\%s\\%s", szTemp, OC_PWS_GROUPNAME, OC_ICS_GROUPNAME);

        DeleteProgramGroupWithLinks(szGroup);

    }
}


//+---------------------------------------------------------------------------
//
//  Function:   DeleteIeakCmakLinks
//
//  Purpose:    Deletes the old links from the IEAK4 CMAK
//
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Author:     quintinb   6 Nov 1998
//
//  Notes:
void DeleteIeakCmakLinks()
{
    OutputDebugString("ADMINPAK: DeleteIeakCmakLinks...\n");

    CHAR szUserDirRoot[MAX_PATH+1];
    CHAR szGroup[MAX_PATH+1];
    CHAR szTemp[MAX_PATH+1];
    CHAR szEnd[MAX_PATH+1];
	DWORD dwSize = _MAX_PATH;
	HRESULT res;

    //
    //  Next Delete the old IEAK CMAK links
    //
    //
    //  Get the Desktop directory and then remove the desktop part.  This will give us the
    //  root of the user directories.
    //
    BOOL bResult = SHGetSpecialFolderPath(NULL, szUserDirRoot, CSIDL_DESKTOPDIRECTORY, FALSE);
    if (bResult == TRUE)
    {

        //
        //  Remove \\Desktop
        //
        CHAR* pszTemp = strrchr(szUserDirRoot, '\\');
        if (NULL == pszTemp)
        {
            return;
        }
        else
        {
            *pszTemp = '\0';
        }

        bResult = SHGetSpecialFolderPath(NULL, szTemp, CSIDL_PROGRAMS, FALSE);

        if (bResult == TRUE )
        {
            if (0 == _strnicmp(szUserDirRoot, szTemp, strlen(szUserDirRoot)))
            {
                res = StringCchCopy(szEnd, dwSize, &(szTemp[strlen(szUserDirRoot)]));
				if (res != S_OK)
					return;
            }
        }

        //
        //  Remove \\<User Name>>
        //
        pszTemp = strrchr(szUserDirRoot, '\\');
        if (NULL == pszTemp)
        {
            return;
        }
        else
        {
            *pszTemp = '\0';
        }

        //
        //  Now start searching for user dirs to delete the CMAK group from
        //
        CHAR szUserDirSearchString[MAX_PATH+1];
        HANDLE hUserDirSearch;
        WIN32_FIND_DATA fdUserDirs;

        //StringCchPrintf(szUserDirSearchString, "%s\\*.*", szUserDirRoot);
        hUserDirSearch = FindFirstFile(szUserDirSearchString, &fdUserDirs);

        while (INVALID_HANDLE_VALUE != hUserDirSearch)
        {
            if ((fdUserDirs.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                (0 != _stricmp(fdUserDirs.cFileName, ".")) &&
                (0 != _stricmp(fdUserDirs.cFileName, "..")))
            {
                //StringCchPrintf(szGroup, "%s\\%s%s\\%s", szUserDirRoot, fdUserDirs.cFileName, szEnd, c_szCmakGroup);
                DeleteProgramGroupWithLinks(szGroup);

            }

            if (!FindNextFile(hUserDirSearch, &fdUserDirs))
            {
                FindClose(hUserDirSearch);

                //
                //  Exit the loop
                //
                break;
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   DeleteCmakRegKeys
//
//  Purpose:    Deletes the old Keys from Registery
//
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Author:     Darryl W. Wood   13 Jul 1999
//
//  Notes:
void DeleteCmakRegKeys()
{
    OutputDebugString("ADMINPAK: DeleteCmakRegKeys...\n");

	LRESULT  lResult;
    char    szCmakUnInstRegPath[MAX_PATH] = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\CMAK";
	lResult = RegDeleteKey (
	  HKEY_LOCAL_MACHINE,			// handle to open key
	  szCmakUnInstRegPath			// address of name of subkey to delete
	);

    char    szCmakAppRegPath[MAX_PATH] = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\CMAK.EXE";
	lResult = RegDeleteKey (
	  HKEY_LOCAL_MACHINE,			// handle to open key
	  szCmakAppRegPath		    	// address of name of subkey to delete
	);

    char    szCmakAppUserInfoPath[MAX_PATH] = "SOFTWARE\\Microsoft\\Connection Manager Administration Kit\\User Info";
	lResult = RegDeleteKey (
	  HKEY_LOCAL_MACHINE,			// handle to open key
	  szCmakAppUserInfoPath		  	// address of name of subkey to delete
	);
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateNewProfilesDirectory
//
//  Author:     Darryl W. Wood   13 Jul 1999
//
//  Notes:
void CreateNewProfilesDirectory( LPCTSTR pszNewProfilePath )
{
    OutputDebugString("ADMINPAK: CreateNewProfilesDirectory...\n");

    char seps[] = "\\";
    char *token = NULL;

    char *szDriectoryString = NULL;
    szDriectoryString = new char[MAX_PATH * sizeof(char)];
	if ( NULL == szDriectoryString )
	{
		return;
	}

    char *szNewString = NULL;
    szNewString = new char[MAX_PATH * sizeof(char)];
    if ( NULL == szNewString )
    {
        if ( szDriectoryString != NULL )
        {
            delete [] szDriectoryString;
        }

        return;
    }

	HRESULT res;
	DWORD dwSize = _MAX_PATH;

	(void)StringCchCopy( szNewString, MAX_PATH * sizeof( char ), "" );

    res = StringCchCopy(szDriectoryString, dwSize, pszNewProfilePath);


    token = strtok( szDriectoryString, seps );
    res = StringCchCopy(szNewString, dwSize, token);
    res = StringCchCat(szNewString, dwSize, "\\");

    while( token != NULL && res == S_OK )
    {
        /* Get next token: */
        token = strtok( NULL, seps );
        if ( token == NULL ) {
            break;
        }
        res = StringCchCat(szNewString, dwSize, token);
        ::CreateDirectory(szNewString, NULL);
        res = StringCchCat(szNewString, dwSize, "\\");

    }

	
    delete [] szDriectoryString;
    delete [] szNewString;
}


HRESULT HrGetPBAPathIfInstalled(PSTR pszCpaPath, DWORD dwNumChars)
{
    HRESULT hr;
    HKEY hKey;
    BOOL bFound = FALSE;

    //  We need to see if PBA is installed or not.  If it is then we want to 
    //  add back the PBA start menu link.  If it isn't, then we want to do nothing
    //  with PBA.
    //

    ZeroMemory(pszCpaPath, sizeof(CHAR)*dwNumChars);
    hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szDaoClientsPath, 0, KEY_READ, &hKey);

    if (SUCCEEDED(hr))
    {
        CHAR szCurrentValue[MAX_PATH+1];
        CHAR szCurrentData[MAX_PATH+1];
        DWORD dwValueSize = MAX_PATH;
        DWORD dwDataSize = MAX_PATH;
        DWORD dwType;
        DWORD dwIndex = 0;
		HRESULT res;

        while (ERROR_SUCCESS == RegEnumValue(hKey, dwIndex, szCurrentValue, &dwValueSize, NULL, &dwType,
               (LPBYTE)szCurrentData, &dwDataSize))
        {
            _strlwr(szCurrentValue);
            if (NULL != strstr(szCurrentValue, "pbadmin.exe"))
            {
                //
                //  Then we have found the PBA path
                //

                CHAR* pszTemp = strrchr(szCurrentValue, '\\');
                if (NULL != pszTemp)
                {
                    *pszTemp = '\0';
                    res = StringCchCopy(pszCpaPath, dwDataSize ,szCurrentValue);
                    bFound = TRUE;
                    break;
                }
            }
            dwValueSize = MAX_PATH;
            dwDataSize = MAX_PATH;
            dwIndex++;
        }

        RegCloseKey(hKey);
    }

    if (!bFound)
    {
        //  We didn't find PBA, so lets return S_FALSE
        //
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}

BOOL GetAdminToolsFolder(PSTR pszAdminTools)
{
    BOOL bReturn = FALSE;
	HRESULT res;
	DWORD dwSize = _MAX_PATH;

    if (pszAdminTools)
    {
        bReturn = SHGetSpecialFolderPath(NULL, pszAdminTools, CSIDL_COMMON_PROGRAMS, TRUE);

        if (bReturn)
        {
            //  Now Append Administrative Tools
            //
            res = StringCchCat(pszAdminTools, dwSize, OC_ADMIN_TOOLS);
			if (res != S_OK)
				return FALSE;
        }
    }

    return bReturn;
}

HRESULT HrCreatePbaShortcut(PSTR pszCpaPath)
{
    HRESULT hr = CoInitialize(NULL);
	DWORD dwSize = _MAX_PATH;

    if (SUCCEEDED(hr))
    {
        IShellLink *psl = NULL;

        hr = CoCreateInstance(CLSID_ShellLink, NULL,
                CLSCTX_INPROC_SERVER, //CLSCTX_LOCAL_SERVER,
                IID_IShellLink,
                (LPVOID*)&psl);
        
        if (SUCCEEDED(hr))
        {
            IPersistFile *ppf = NULL;

            // Set up the properties of the Shortcut
            //
            static const CHAR c_szPbAdmin[] = "\\pbadmin.exe";

            CHAR szPathToPbadmin[MAX_PATH+1] = {0};
            DWORD dwLen = strlen(c_szPbAdmin) + strlen(pszCpaPath) + 1;

            if (MAX_PATH >= dwLen)
            {
                //  Set the Path to pbadmin.exe
                //
                hr = StringCchCopy(szPathToPbadmin, dwSize,pszCpaPath);
                hr = StringCchCat(szPathToPbadmin, dwSize,c_szPbAdmin);
            
                hr = psl->SetPath(szPathToPbadmin);
            
                if (SUCCEEDED(hr))
                {
                    //  Set the Description to Phone Book Administrator
                    //
                    hr = psl->SetDescription(OC_PBA_DESC);

                    if (SUCCEEDED(hr))
                    {
                        hr = psl->QueryInterface(IID_IPersistFile,
                                                 (LPVOID *)&ppf);
                        if (SUCCEEDED(hr))
                        {
                            CHAR szAdminTools[MAX_PATH+1] = {0};                            
                            if (GetAdminToolsFolder(szAdminTools))
                            {
                                // Create the link file.
                                //
                                long nLenString = 0;
                                nLenString = strlen(szAdminTools) + 1;
                                WCHAR wszAdminTools[MAX_PATH+1] = {0};

                                mbstowcs( wszAdminTools, szAdminTools, nLenString );
                                hr = ppf->Save(wszAdminTools, TRUE);
                            }

                            if ( ppf ) {
                                ppf->Release();
                                ppf = NULL;
                            }
                        }                    
                    }
                }
            }

            if ( psl ) {
                psl->Release();
                psl = NULL;
            }
        }

        CoUninitialize();
    }

    return hr;
}

////////////////////////////////////////////////////////////