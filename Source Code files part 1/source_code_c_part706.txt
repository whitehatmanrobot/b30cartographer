ecvsize--;

                t_size++;
            } 
            else 
            {
                FProcessIAC(hwnd, pwi, &ps, &pd, &recvsize, &t_size);
            }
        }
        else 
        {

            *(char FAR *)pd = *(char FAR *)ps;
            pd++;
            ps++;

            t_size++;
        }
    }

    if( t_size )
    {
        /* add received data to buffer */
        if ( !(ui.fFlushOut)  || ui.nottelnet ) 
        {
            FProcessSessionData( t_size, pwi->nd.lpReadBuffer, pwi );
        }
    }
}


void
FProcessFDOOB(HWND hwnd)
{
    WI *pwi = (WI *)GetWindowLongPtr(hwnd, WL_TelWI);
    int recvsize;
    LPSTR ps;

    if ((recvsize=recv(pwi->nd.hsd, pwi->nd.lpTempBuffer,
          READ_BUF_SZ, MSG_OOB)) < 0) {
#ifdef  TCPTEST
             OutputDebugString("recv error \n");
#endif
             return;
    }

    ps = pwi->nd.lpTempBuffer;

    if (*(unsigned char *)ps == (unsigned char)DM)
    {
#ifdef  TCPTEST
        OutputDebugString("DM received\n");
#endif
        FDisableFlush(hwnd);
    }
}

BOOL
FAttemptServerConnect(WI *pwi, LPSTR szHostName, LPNETDATA lpData)
{
    BOOL got_connected = FALSE;
    struct servent *serv;
    struct sockaddr_storage myad;
    int  on = 1;
    char szService[256];
    char *pszService = NULL;
    struct addrinfo *aiTemp = NULL;

    g_dwSockErr = 0; //Intialize to no error


    if(rgService)
    {
    	pszService = szService;
    	_snprintf(pszService,sizeof(szService)-1, "%d",rgService);
    }
    else
    {
        got_connected = FALSE;
        return(got_connected);
    }
    	
    strncpy(lpData->szHostName, szHostName,sizeof(lpData->szHostName));
    if(getaddrinfo(szHostName, pszService, NULL, &lpData->ai ) != 0 )
    {
        got_connected = FALSE;
        return(got_connected);
    }
	aiTemp = lpData->ai;
    ui.nottelnet = TRUE; // Assume that it is not a telnet server for starters, later when it is set this flag... to false.
    ui.honor_localecho = (ui.fDebug & fdwLocalEcho); // Save this and restore after a logon has happned in case of telnet 
    ui.fDebug &= ~fdwLocalEcho; // Clear it.
	//Continue till connection is successfully established or till the list is exausted
	while(aiTemp)
	{
		if ((lpData->hsd = socket( aiTemp->ai_family, SOCK_STREAM, 0)) == INVALID_SOCKET) 
		{
	        DEBUG_PRINT(("socket failed \n"));
			aiTemp = aiTemp->ai_next;
			continue;
		}
	    SfuZeroMemory(&myad, sizeof(myad)); //no overflow. Size is constant.
		myad.ss_family = (u_short)aiTemp->ai_family;
	    if(bind( lpData->hsd, (struct sockaddr *)&myad, sizeof(myad))<0)
	    {
	        DEBUG_PRINT(("bind failed\n"));
    		closesocket( lpData->hsd );
	    	lpData->hsd = INVALID_SOCKET;
			aiTemp = aiTemp->ai_next;
			continue;
	    }
	    on = 1;
	    {
	        BOOL        value_to_set = TRUE;

	        setsockopt(
	            lpData->hsd, 
	            SOL_SOCKET, 
	            SO_DONTLINGER, 
	            ( char * )&value_to_set, 
	            sizeof( value_to_set )
	            );
	    }
	    if( setsockopt( lpData->hsd, SOL_SOCKET, SO_OOBINLINE,
	                    (char *)&on, sizeof(on) ) < 0)
	    {
	        g_dwSockErr = WSAGetLastError();
        	closesocket( lpData->hsd );
	        lpData->hsd = INVALID_SOCKET;
	        got_connected = FALSE;
	        DEBUG_PRINT(("setsockopt SO_OOBINLINE failed\n"));
	        DEBUG_PRINT(("FAttemptServerConnect Out\n"));
			freeaddrinfo(lpData->ai);
			lpData->ai = NULL;
	        return(got_connected);
	    }
	    else
	        DEBUG_PRINT(("setsockopt SO_OOBINLINE worked\n"));

	    if(SafeSetSocketOptions(lpData->hsd) < 0)
	    {
	    	g_dwSockErr = WSAGetLastError();
        	closesocket( lpData->hsd );
	        lpData->hsd = INVALID_SOCKET;
	        got_connected = FALSE;
	        DEBUG_PRINT(("setsockopt SO_EXCLUSIVEADDRUSE failed\n"));
	        DEBUG_PRINT(("FAttemptServerConnect Out\n"));
			freeaddrinfo(lpData->ai);
			lpData->ai = NULL;
	        return(got_connected);
	    }
		
	    // ================================================================
	    // MohsinA, 09-Dec-96.

		if(connect( lpData->hsd, (PVOID)aiTemp->ai_addr,aiTemp->ai_addrlen )<0)
	    {
	        DEBUG_PRINT(("connect failed\n"));
	    	closesocket( lpData->hsd );
	        lpData->hsd = INVALID_SOCKET;
			aiTemp = aiTemp->ai_next;
			continue;
	    }
	    break;
	}
	freeaddrinfo(lpData->ai);
	lpData->ai = NULL;
	if(aiTemp == NULL)
	{
        DEBUG_PRINT(("FAttemptServerConnect Out\n"));
        g_dwSockErr = WSAGetLastError();
        if(lpData->hsd != INVALID_SOCKET)
        	closesocket( lpData->hsd );
       	lpData->hsd = INVALID_SOCKET;
   		got_connected = FALSE;
        return(got_connected);
	}
	aiTemp=NULL;
    // ================================================================

    lpData->SessionNumber = 1;

    if (lpData->SessionNumber != nSessionNone)
    {
        DEBUG_PRINT(("sess# <> nsessnone\n"));
        /* post Async select */
        if (WSAAsyncSelect( lpData->hsd, pwi->hwnd, WS_ASYNC_SELECT,
					        (FD_READ | FD_WRITE | FD_CLOSE | FD_OOB)) < 0) 
        {
			g_dwSockErr = WSAGetLastError();
            closesocket( lpData->hsd );
            lpData->hsd = INVALID_SOCKET;
            got_connected = FALSE;
            lpData->SessionNumber = nSessionNone;
            DEBUG_PRINT(("WSAAsyncSelect failed\n"));
            DEBUG_PRINT(("FAttemptServerConnect Out\n"));
            return(got_connected);
        }
        else
            DEBUG_PRINT(("WSAAsyncSelect worked\n"));
        got_connected = TRUE;
    }
    else
        DEBUG_PRINT(("sess# <> nsessnone\n"));
    DEBUG_PRINT(("FAttemptServerConnect Out\n"));
    return got_connected;
}

void
FCloseConnection(HWND hwnd)
{
    WI *pwi = (WI *)GetWindowLongPtr(hwnd, WL_TelWI);
	if(pwi->nd.hsd != INVALID_SOCKET)
	{
    	closesocket( pwi->nd.hsd );
	    pwi->nd.hsd = INVALID_SOCKET;
	}
}

#endif

#ifdef __NOT_USED
#define INC(i) (((i)+1 == DATA_BUF_SZ) ? 0 : (i)+1)
#define DEC(i) (((i)-1 < 0)                              ? DATA_BUF_SZ-1 : (i)-1)

WORD
WGetData(LPNETDATA lpData, LPSTR lpBuffer, WORD cLen)
{
    WORD cb;

#ifdef TCPTEST
    snprintf(DebugBuffer,sizeof(DebugBuffer)-1, "WGetData length %d\n", cLen);
    OutputDebugString(DebugBuffer);
#endif
    if (lpData->iHead < lpData->iTail)
    {
        cb = ( USHORT )  ( (cLen < (lpData->iTail - lpData->iHead - 1))
                ? cLen : (lpData->iTail - lpData->iHead - 1) );
        memcpy(lpBuffer, &lpData->achData[lpData->iHead+1], cb); //Attack ? size not known. No caller.
        lpData->iHead = ( USHORT ) ( lpData->iHead + cb );
    }
    else
    {
        for(cb=0;
            (cb<cLen) && ((WORD)INC(lpData->iHead) != lpData->iTail);
            ++cb)
        {
            lpData->iHead = ( USHORT ) INC(lpData->iHead);
            *lpBuffer++ = lpData->achData[lpData->iHead];
        }
    }

#ifdef TCPTEST
    snprintf(DebugBuffer, sizeof(DebugBuffer)-1, "WGetData returning %d bytes (head = %d, tail = %d)\n",
            cb,
            lpData->iHead,
            lpData->iTail );
    OutputDebugString(DebugBuffer);
#endif

    return cb;
}

BOOL
FStoreData(LPNETDATA lpData, int max)
{
    BOOL fSuccess = TRUE;
    WORD tail = lpData->iTail;
    LPSTR p = lpData->lpReadBuffer;

#ifdef TCPTEST
    snprintf(DebugBuffer, sizeof(DebugBuffer)-1, "FStoreData max %d, (head = %d, tail = %d)\n",
            max,
            tail,
            lpData->iHead );
    OutputDebugString(DebugBuffer);
#endif

    if ((max+tail) < DATA_BUF_SZ)
    {
            memcpy(&lpData->achData[tail], p, max); //Attack ? Size not known. No caller.
            tail = ( USHORT ) ( tail + max );
    }
    else
    {
            WORD head = lpData->iHead;
            int i;

            for (i=0; i<max; ++i)
            {
                    if (tail == head)
                    {
                            /* the buffer is full! Rest of the data will be lost */
                            fSuccess = FALSE;
                            break;
                    }
                    else
                    {
                            lpData->achData[tail] = *p++;
                            tail = ( USHORT ) INC(tail);
                    }
            }
    }

    lpData->iTail = tail;

#ifdef TCPTEST
    snprintf(DebugBuffer, sizeof(DebugBuffer)-1, "FStoreData returning %d\n",
            fSuccess );
    OutputDebugString(DebugBuffer);
#endif

    return fSuccess;
}
#endif

void CALLBACK
NBReceiveData(PVOID pncb)
{
}

/* following four routines modified from VTP's routines. */

BOOL
FTelXferStart(WI *pwi, int nSessionNumber)
{
#ifdef TELXFER
    unsigned short   u;
        char rgchFileOrig[OFS_MAXPATHNAME];
        char rgchFile[OFS_MAXPATHNAME];

    xfGetData(0, (char *)&u, 2, nSessionNumber);                // Mode

        SfuZeroMemory(&pwi->svi, sizeof(SVI)); //no overflow. Size is constant
        pwi->svi.hfile = INVALID_HANDLE_VALUE;
        pwi->svi.lExit = -1;
        pwi->svi.lCleanup = -1;

    if (u != 0)                                                 // For now must be zero
        return FALSE;

        pwi->trm.fHideCursor = TRUE;

    xfGetData(1, (char *)&u, 2, nSessionNumber);                // Length of name
    xfGetData(2, rgchFileOrig, u, nSessionNumber);              // Name

    xfGetData(3, (char *)&pwi->svi.cbFile, 4, nSessionNumber);  // Filesize

        lstrcpyn(rgchFile, rgchFileOrig, OFS_MAXPATHNAME -1);

        /* If the user doesn't have the shift key down, prompt for */
        /* a directory and name for the file */
        if (!(ui.fPrompt & fdwSuppressDestDirPrompt) &&
                (GetAsyncKeyState(VK_SHIFT) >= 0))
        {
                if ( !FGetFileName(hwnd, rgchFile, NULL) )
                {
                        goto err;
                }
        }

        pwi->svi.hfile = CreateFile(rgchFile, GENERIC_WRITE | GENERIC_READ,
                                                FILE_SHARE_READ, NULL,
                                                CREATE_ALWAYS,
                                                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                                NULL);
        if (pwi->svi.hfile == INVALID_HANDLE_VALUE)
        {
                ErrorMessage(szCantOpenFile, szAppName);
                goto err;
        }
        pwi->svi.puchBuffer = LocalAlloc(LPTR, SV_DATABUF);
        if (pwi->svi.puchBuffer == NULL)
        {
                ErrorMessage(szOOM, szAppName);
                goto err;
        }

        pwi->svi.nSessionNumber = nSessionNumber;
        pwi->svi.hthread = CreateThread(NULL, 0, SVReceive, &pwi->svi,
                                                                        CREATE_SUSPENDED, &pwi->svi.dwThreadId);
        if (pwi->svi.hthread == NULL)
        {
                ErrorMessage(szNoThread, szAppName);
                goto err;
        }

    // Skip 4 which is ^D
    xfPutc(5, nSessionNumber);                         // Get file

    _snwprintf(rgchFile, OFS_MAXPATHNAME -1, szBannerMessage, rgchFileOrig, pwi->svi.cbFile);
        DoIBMANSIOutput(hwnd, &pwi->trm, lstrlen(rgchFile), rgchFile);

        DoIBMANSIOutput(hwnd, &pwi->trm, lstrlen(szInitialProgress), szInitialProgress);

        /* In case the screen just scrolled up, paint the window */
        UpdateWindow( hwnd );
        ResumeThread( pwi->svi.hthread );

        return TRUE;

err:
        if ( pwi )
        {
                if (pwi->svi.puchBuffer != NULL)
                        LocalFree( (HANDLE)pwi->svi.puchBuffer );
                if (pwi->svi.hfile != INVALID_HANDLE_VALUE)
                        CloseHandle( pwi->svi.hfile );

                SfuZeroMemory(&pwi->svi, sizeof(SVI)); //no overflow. size is constant.
                pwi->svi.hfile = INVALID_HANDLE_VALUE;
                pwi->svi.lExit = -1;
                pwi->svi.lCleanup = -1;
        }
        pwi->trm.fHideCursor = FALSE;

        return FALSE;
#else
    return TRUE;
#endif
}


BOOL
FTelXferEnd(WI *pwi, DWORD dwWhy)
{
#ifdef TELXFER
        DWORD dwStatus = NO_ERROR;
        BOOL fTransferOK = FALSE;
        BOOL fAbortDownload = FALSE;
        BOOL fCleanup = FALSE;
        LPNETDATA lpData = &pwi->nd;
        SVI *psvi = &pwi->svi;
        MSG msg;

        switch ( dwWhy )
        {
        case SV_DISCONNECT:
        case SV_HANGUP:
        case SV_QUIT:
                if (InterlockedIncrement(&psvi->lExit) == 0)
                {
                        if (psvi->hthread != NULL)
                        {
                                (void)GetExitCodeThread(psvi->hthread, &dwStatus);
                                if (dwStatus == STILL_ACTIVE)
                                {
                                        if (MessageBox(hwnd, szAbortDownload, szAppName,
                                                MB_DEFBUTTON2 | MB_YESNO | MB_ICONEXCLAMATION) == IDYES)
                                        {
                                                fAbortDownload = fCleanup = TRUE;
                                        }

                                        /* See if the thread has finished yet */
                                        GetExitCodeThread(psvi->hthread, &dwStatus);

                                        if ( fAbortDownload )
                                        {
                                                /* If the thread hasn't finished yet, tell it to stop */
                                                if (dwStatus == STILL_ACTIVE)
                                                {
                                                        HCURSOR hcursorOld;
                                                        hcursorOld = SetCursor( LoadCursor(NULL, IDC_WAIT));
                                                        psvi->dwCommand = 1;
                                                        WaitForSingleObject(psvi->hthread, INFINITE);
                                                        GetExitCodeThread(psvi->hthread, &dwStatus);
                                                        (void)SetCursor( hcursorOld );
                                                }

                                                /* "Eat" any progress messages that might be around */
                                                while (PeekMessage(&msg, hwnd, SV_PROGRESS, SV_DONE,
                                                                                        PM_REMOVE))
                                                {
                                                        if (msg.message == SV_PROGRESS)
                                                        {
                                                                TranslateMessage( &msg );
                                                                DispatchMessage( &msg );
                                                        }
                                                }
                                        }
                                        else if (dwStatus != STILL_ACTIVE)
                                        {
                                                fCleanup = TRUE;
                                        }
                                }
                                else
                                {
                                        fAbortDownload = fCleanup = TRUE;
                                }

                                /* If we've stopped the download, then close the thread */
                                if ( fCleanup )
                                {
                                        CloseHandle( psvi->hthread );
                                        psvi->hthread = NULL;
                                        if (lpData->SessionNumber != nSessionNone)
                                        {
                                                xfPutc((char)(!fTransferOK ? 0x7F : 0x06),
                                                                lpData->SessionNumber);
                                                if ( !fAbortDownload )
                                                        (void)FPostReceive( lpData );
                                        }
                                }
                                if (dwStatus == NO_ERROR)
                                        fTransferOK = TRUE;
                        }
                        InterlockedDecrement( &psvi->lExit );

                        /* If the thread wasn't aborted and it hasn't finished, return */
                        if (!fAbortDownload && !fCleanup)
                                return fAbortDownload;
                }
                else
                {
                        InterlockedDecrement( &psvi->lExit );
                        break;
                }

        case SV_DONE:
                if (dwWhy == SV_DONE)
                {
                        fAbortDownload = fCleanup = TRUE;
                }

                /* If we're the only thread in the function, close everything down */
                if (InterlockedIncrement(&psvi->lExit) == 0)
                {
                        if (psvi->hthread != NULL)
                        {
                                WaitForSingleObject(psvi->hthread, INFINITE);
                                GetExitCodeThread(psvi->hthread, &dwStatus);
                                CloseHandle( psvi->hthread );
                                psvi->hthread = NULL;
                                if (dwStatus == NO_ERROR)
                                        fTransferOK = TRUE;
                        }
                }

                /* Do cleanup of struct only once */
                if ((InterlockedIncrement(&psvi->lCleanup) == 0) &&
                        (psvi->puchBuffer != NULL))
                {
                        LocalFree( (HANDLE)psvi->puchBuffer );
                        psvi->puchBuffer = NULL;

                        if (psvi->hfile != INVALID_HANDLE_VALUE)
                        {
                                CloseHandle( psvi->hfile );
                                psvi->hfile = INVALID_HANDLE_VALUE;
                        }

                        psvi->cbFile = 0;
                        psvi->cbReadTotal = 0;
                        psvi->dwCommand = 0;
                        psvi->dwThreadId = 0;
                        psvi->nSessionNumber = nSessionNone;

                        if ((dwStatus == NO_ERROR) || (dwStatus == ERROR_OPERATION_ABORTED))
                        {
                                lstrcpyn(pchNBBuffer, szSendTelEnd,sizeof(pchNBBuffer)-1);
                        }
                        else
                        {
                                _snwprintf(pchNBBuffer,sizeof(pchNBBuffer)-1,szSendTelError, dwStatus);
                        }
                        DoIBMANSIOutput(hwnd, &pwi->trm, lstrlen(pchNBBuffer), pchNBBuffer);

                        pwi->ichTelXfer = 0;
                        pwi->trm.fHideCursor = FALSE;
                }
                InterlockedDecrement( &psvi->lCleanup );

                if ((dwWhy == SV_DONE) && (lpData->SessionNumber != nSessionNone))
                {
                        xfPutc((char)(!fTransferOK ? 0x7F : 0x06), lpData->SessionNumber);
                        (void)FPostReceive( lpData );
                }
                InterlockedDecrement( &psvi->lExit );
                break;
        default:
                break;
        }

        return fAbortDownload;
#else
    return TRUE;
#endif
}

#ifdef TELXFER
static void
xfGetData(char c, char *pchBuffer, DWORD cbBuffer, int nSessionNumber)
{
    DWORD cbRead;

    xfPutc(c, nSessionNumber);
    while ( cbBuffer )
        {
        cbRead = xfGetSomeData(pchBuffer, cbBuffer, nSessionNumber);
                if (cbRead == 0)
                        break;
        cbBuffer -= cbRead;
        pchBuffer += cbRead;
    }
}
#endif

#ifdef USETCP
#ifdef TELXFER
static DWORD
xfGetSomeData(char *pchBuffer, DWORD cbBuffer, int nSessionNumber)
{
    return 1;
}
#endif //TELXFER


#ifdef TELXFER
static void
xfPutc(char c, int nSessionNumber)
{

}
#endif
#endif

#ifdef TELXFER
BOOL
FGetFileName(HWND hwndOwner, char *rgchFile, char *rgchTitle)
{
        OPENFILENAME ofn;

        /* Fill in struct. */
        ofn.lStructSize                 = sizeof(ofn);
        ofn.hwndOwner                   = hwndOwner;
        ofn.hInstance                   = NULL;
        ofn.lpstrFilter                 = (LPSTR) szAllFiles;
        ofn.lpstrCustomFilter   = (LPSTR) NULL;
        ofn.nMaxCustFilter              = 0;
        ofn.nFilterIndex                = 0;
        ofn.lpstrFile                   = (LPSTR) rgchFile;
        ofn.nMaxFile                    = OFS_MAXPATHNAME;
        ofn.lpstrFileTitle              = (LPSTR) rgchTitle;
        ofn.nMaxFileTitle               = OFS_MAXPATHNAME;
        ofn.lpstrInitialDir             = (LPSTR) 0;
        ofn.lpstrTitle                  = (LPSTR) szDownloadAs;
        ofn.Flags                               = OFN_HIDEREADONLY | OFN_NOREADONLYRETURN |
                                                                OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;

        ofn.nFileOffset                 = 0;
        ofn.nFileExtension              = 0;
        ofn.lpstrDefExt                 = (LPSTR) NULL;
        ofn.lCustData                   = 0;
        ofn.lpfnHook                    = NULL;
        ofn.lpTemplateName              = NULL;

        if ( !GetSaveFileName(&ofn) )
        {
                return FALSE;
        }
        return TRUE;
}
#endif

DWORD WINAPI
SVReceive(SVI *psvi)
{
        DWORD   dwReturn = NO_ERROR;

#ifdef TELXFER
        if ( psvi )
        {
                while ((psvi->cbFile > 0) && (psvi->dwCommand == 0))
                {
                        DWORD cbSomeData;
                        DWORD cbRead;

                        cbRead = 0;
                        while ((psvi->cbFile > 0) && (cbRead < 1024))
                        {
                                cbSomeData = xfGetSomeData(psvi->puchBuffer+cbRead,
                                                                        (unsigned short) 0x4000 - cbRead,
                                                                        psvi->nSessionNumber);

                                if (cbSomeData > psvi->cbFile)
                                        cbSomeData = psvi->cbFile;

                                psvi->cbFile -= cbSomeData;
                                cbRead += cbSomeData;
                        }

                        if (!WriteFile(psvi->hfile, psvi->puchBuffer, cbRead,
                                                        &cbSomeData, NULL))
                        {
                                dwReturn = GetLastError();
                                break;
                        }

                        psvi->cbReadTotal += cbRead;
                        PostMessage(hwndMain, SV_PROGRESS, 0, psvi->cbReadTotal);
                }

                /* caller must've signaled and waited for thread to stop */
                if ((dwReturn == NO_ERROR) && (psvi->dwCommand != 0) &&
                        (psvi->cbFile > 0))
                {
                        dwReturn = ERROR_OPERATION_ABORTED;
                }
                else if ((psvi->dwCommand == 0) || (psvi->cbFile == 0))
                {
                        /* If thread stopped by itself, need to tell caller to kill it
                         * BUT ONLY if the main thread  isn't tying to kill off this
                         * thread.
                         */
                        if (InterlockedIncrement(&psvi->lExit) == 0)
                                PostMessage(hwndMain, SV_END, 0, 0L);
                        InterlockedDecrement( &psvi->lExit );
                }
        }
        else if (psvi->lExit < 0)
        {
                /* If thread stopped by itself, need to tell caller to kill it */
                PostMessage(hwndMain, SV_END, 0, 0L);
        }
#endif

        return dwReturn;
}

#ifdef USETCP
BOOL
FHangupConnection(WI *pwi, LPNETDATA lpData)
{

    if (lpData->SessionNumber != nSessionNone)
    {
    	if(lpData->hsd != INVALID_SOCKET)
    	{
        	closesocket( lpData->hsd );
	        lpData->hsd = INVALID_SOCKET;
    	}
        lpData->SessionNumber = nSessionNone;
    }

    return FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\client\trmio.h ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
/*
trmio.h
*/

#define fdwCursorToEOS  ((DWORD)0)
#define fdwBOSToCursor  ((DWORD)1)
#define fdwEntireScreen ((DWORD)2)

#define fdwCursorToEOL  ((DWORD)0)
#define fdwBOLToCursor  ((DWORD)1)
#define fdwEntireLine   ((DWORD)2)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\client\telnetcr.c ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
#include "windows.h"
#pragma warning(disable:4100)

BOOL WINAPI DllMain(HINSTANCE hinstDLL,	DWORD fdwReason,	LPVOID lpvReserved)
{
return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\client\trmio.c ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
#include <windows.h>                    //required for all Windows applications 
#pragma warning (disable: 4201)			// disable "nonstandard extension used : nameless struct/union"
#include <commdlg.h>
#pragma warning (default: 4201)
#include <stdlib.h>
#include <stdio.h>

#include <ctype.h>
#include <string.h>

#pragma warning( disable: 4100 )
#pragma warning( disable: 4244 )

#include <imm.h>

#include "WinTel.h"                     // specific to this program 
#include "debug.h"
#include "trmio.h"
#include "vtnt.h"

static UCHAR pchNBBuffer[ READ_BUF_SZ ];
static void NewLineUp(WI *, TRM *);
static void NewLine(WI *pwi, TRM *);
static void SetBufferStart(TRM *);
static BOOL FAddTabToBuffer( TRM *, DWORD );
static BOOL FAddCharToBuffer(TRM *, UCHAR);
static void FlushBuffer(WI *pwi, TRM *);
static void CursorUp(TRM *);
static void CursorDown(TRM *);
static void CursorRight(TRM *);
static void CursorLeft(TRM *);
static void ClearLine(WI *pwi, TRM *, DWORD);
static void SetMargins(TRM *, DWORD, DWORD);

//For eg: home key: ^[[2~. 'x' needs replacement for each particular key
static CHAR szVt302KeySequence[] = { 0x1B, '[', 'x', '~', 0 }; 
static CHAR szVt302LongKeySequence[] = { 0x1B, '[', 'x', 'x', '~', 0 }; 
static CHAR szVt302ShortKeySequence[] = { 0x1B, '[', 'x', 0 }; 

UCHAR uchOutPrev = 0;
UCHAR uchInPrev = 0;

#define IsEUCCode(uch)  (((uch) > 0xa0) ? TRUE : FALSE)
#define IsKatakana(uch) (((uch) > 0xa0) ? ((uch < 0xe0) ? TRUE : FALSE) : FALSE)

void jistosjis( UCHAR *, UCHAR *);
void euctosjis( UCHAR *, UCHAR *);
void sjistojis( UCHAR *, UCHAR *);
void sjistoeuc( UCHAR *, UCHAR *);
//void DBCSTextOut( HDC, int, int, LPCSTR, int, int);
void ForceJISRomanSend( WI *);

VOID SetImeWindow(TRM *ptrm);
void PrepareForNAWS( );
void DoNawsSubNegotiation( WI * );

extern POINT ptWindowMaxSize;

#define MAX_TABSTOPS 100         //Max tabstops

extern WI gwi;
SMALL_RECT srOldClientWindow = { 0, 0, 0, 0 };
CONSOLE_SCREEN_BUFFER_INFO consoleBufferInfo;
DWORD g_rgdwHTS[ MAX_TABSTOPS ];  //Array of tab stops
WORD g_iHTS = 0;                  //Index in to the tab stops array
WORD wSaveCurrentLine = 0;

static BOOL g_bIsToBeLogged = FALSE;

void WriteCharInfoToLog( CHAR_INFO pCharInfo[], COORD coSize )
{
   WORD  wRows    = 0;
   
   while( wRows < coSize.Y )
   {
       DWORD nBytes   = 0;
       DWORD length   = 0;
       UCHAR *pcTmp   = NULL;
       WORD  wSrc     = 0;
       WORD  wDst     = 0;
       
       while( wSrc < coSize.X )
       {           
           DWORD dwSize = 0;

           dwSize = WideCharToMultiByte( GetConsoleCP(), 0, 
                        &( ( *( pCharInfo + wRows * coSize.X + wSrc ) ).Char.UnicodeChar ),
                        1, NULL, 0, NULL, NULL );

           if( !WideCharToMultiByte( GetConsoleCP(), 0, 
                &( ( *( pCharInfo + wRows * coSize.X + wSrc ) ).Char.UnicodeChar ),
                1, ( PCHAR ) ( g_rgchRow+wDst ), dwSize, NULL, NULL ) )
           {
                g_rgchRow[ wDst++ ] = 
                    ( *( pCharInfo + wRows * coSize.X + wSrc ) ).Char.AsciiChar;
	            wSrc++;
           }
           else
           {
                wDst += ( WORD )dwSize;
                if( (*(pCharInfo + wRows * coSize.X + wSrc )).Attributes & COMMON_LVB_LEADING_BYTE )
                {
                    ++wSrc;
                }
                wSrc++ ; 
           }
           
       }

       pcTmp = g_rgchRow + ( coSize.X  - 1 );

       //
       //   Find the last non space character in the string.
       //
       while ( pcTmp != g_rgchRow && *pcTmp == ' ' )
       {
          pcTmp -= 1;
       }

       length = (DWORD)( pcTmp - g_rgchRow ) + 1;

       WriteFile(ui.hLogFile, g_rgchRow, length, &nBytes, NULL);

       WriteFile(ui.hLogFile, ( PUCHAR )szNewLine, strlen( ( const char * ) szNewLine), &nBytes, NULL);
       wRows++ ;
   }
}

void WriteToLog( DWORD dwLine )
{
   SMALL_RECT srRead = { 0, 0, 0, 0};
   COORD coSize = { 0, 1 }, coOrigin = { 0, 0 };

   if( !g_bIsToBeLogged )
   {
        return;       
   }

   coSize.X     = ( WORD )ui.dwMaxCol;
   srRead.Top   = ( WORD )dwLine, srRead.Bottom = ( WORD ) ( dwLine + 1 );
   srRead.Left  = 0, srRead.Right = ( WORD ) ( ui.dwMaxCol - 1 );           

   if( ReadConsoleOutput( gwi.hOutput, g_rgciCharInfo, coSize, coOrigin, &srRead ) )
   {
        coSize.Y = srRead.Bottom - srRead.Top + 1;
        coSize.X = srRead.Right - srRead.Left + 1;
        WriteCharInfoToLog( g_rgciCharInfo, coSize );               
   }

   g_bIsToBeLogged = FALSE;

}

void GetWindowCoordinates( SMALL_RECT  *srClientWindow, COORD* coordSize )
{
    CONSOLE_SCREEN_BUFFER_INFO csbiRestore;

    ASSERT( srClientWindow );

    if( GetConsoleScreenBufferInfo( gwi.hOutput, &csbiRestore ) )
    {
        *srClientWindow = csbiRestore.srWindow;
        if( coordSize )
        { 
            *coordSize = csbiRestore.dwSize;
        }
    }
    else
    {
        srClientWindow->Bottom = 0;
        srClientWindow->Top = 0;
        srClientWindow->Right = 0;
        srClientWindow->Left = 0;
        if( coordSize )
        {
            coordSize->X = 0;
            coordSize->Y = 0;
        }
    }
}

void SetWindowSize( HANDLE hConsoleToBeChanged )
{
    COORD coordSize = { 0, 0 };
    SMALL_RECT srPromptWindow = { 0, 0, 0, 0 };
    HANDLE hOldConsole = NULL;
    COORD coordLargest = { 0, 0 };

    hOldConsole = gwi.hOutput;
    gwi.hOutput = hConsoleToBeChanged;
    GetWindowCoordinates( &srPromptWindow, &coordSize );
    gwi.hOutput = hOldConsole;

    //if error, return
    if( coordSize.X == 0 || srPromptWindow.Bottom == 0 )
    {
        return;
    }

    if( srPromptWindow.Bottom - srPromptWindow.Top != gwi.sbi.srWindow.Bottom - gwi.sbi.srWindow.Top ||
      srPromptWindow.Right - srPromptWindow.Left != gwi.sbi.srWindow.Right - gwi.sbi.srWindow.Left ) 
    {

        srPromptWindow.Right  += ( gwi.sbi.srWindow.Right - gwi.sbi.srWindow.Left ) -
                                ( srPromptWindow.Right - srPromptWindow.Left );
        srPromptWindow.Bottom += ( gwi.sbi.srWindow.Bottom - gwi.sbi.srWindow.Top ) -
                                ( srPromptWindow.Bottom - srPromptWindow.Top );    

        coordLargest = GetLargestConsoleWindowSize( gwi.hOutput );
        if( srPromptWindow.Right  - srPromptWindow.Left >= coordLargest.X )
        {
            srPromptWindow.Right = srPromptWindow.Left + coordLargest.X  - 1;
        }
        if( srPromptWindow.Bottom -  srPromptWindow.Top >= coordLargest.Y )
        {
            srPromptWindow.Bottom = srPromptWindow.Top + coordLargest.Y  - 1;
        }        
    }


    if ( ( coordSize.X < gwi.sbi.dwSize.X ) || ( coordSize.Y < gwi.sbi.dwSize.Y ) )
    {
        COORD coordTmpSize = { 0, 0 };

        coordTmpSize .X = ( coordSize.X < gwi.sbi.dwSize.X ) ? gwi.sbi.dwSize.X : coordSize.X ;
        coordTmpSize .Y = ( coordSize.Y < gwi.sbi.dwSize.Y ) ? gwi.sbi.dwSize.Y : coordSize.Y ;

        SetConsoleScreenBufferSize( hConsoleToBeChanged, coordTmpSize );
        SetConsoleWindowInfo( hConsoleToBeChanged, TRUE, &srPromptWindow );
        SetConsoleScreenBufferSize ( hConsoleToBeChanged, gwi.sbi.dwSize );
    }
    else
    {
        SetConsoleWindowInfo( hConsoleToBeChanged, TRUE, &srPromptWindow );
        SetConsoleScreenBufferSize( hConsoleToBeChanged, gwi.sbi.dwSize );
    }

}


void CheckForChangeInWindowSize()
{
    SMALL_RECT srClientWindow = { 0, 0, 0, 0 };
    COORD coordSize = { 0, 0 };

    GetWindowCoordinates( &srClientWindow, &coordSize );

    if( gwi.nd.fRespondedToDoNAWS  && !g_bDontNAWSReceived && 
             ( srClientWindow.Bottom - srClientWindow.Top != srOldClientWindow.Bottom - srOldClientWindow.Top ||
              srOldClientWindow.Right - srOldClientWindow.Left != srClientWindow.Right - srClientWindow.Left ) )
    {
        //We found that window size has changed and we already did naws. 
        //Do naws again

        COORD coordLargest = { 0, 0 };
        BOOL  fChangedFromUserSetting  = FALSE;

        coordLargest = GetLargestConsoleWindowSize( gwi.hOutput );
        if( srClientWindow.Right  - srOldClientWindow.Left >= coordLargest.X )
        {
            srClientWindow.Right = srClientWindow.Left + coordLargest.X  - 1;
            fChangedFromUserSetting = TRUE;
        }
        if( srClientWindow.Bottom -  srOldClientWindow.Top >= coordLargest.Y )
        {
            srClientWindow.Bottom = srClientWindow.Top + coordLargest.Y  - 1;
            fChangedFromUserSetting = TRUE;
        }        

        if( fChangedFromUserSetting )
        {
            //The max window size that can be set through the ui on cmd is larger than what GetLargestConsoleWindowSize
            //returns. In that case, force the window size to be smaller 
            SetConsoleWindowInfo( gwi.hOutput, TRUE, &srClientWindow );

            if( srClientWindow.Bottom - srClientWindow.Top == srOldClientWindow.Bottom - srOldClientWindow.Top &&
              srOldClientWindow.Right - srOldClientWindow.Left == srClientWindow.Right - srClientWindow.Left ) 
            {
                //This is needed so that we don't do NAWS when unnecessary
                return;
            }
        }

        if( srClientWindow.Bottom < srOldClientWindow.Bottom )
        {
            WORD wDifference = ( srOldClientWindow.Bottom - srClientWindow.Bottom );
            if( srClientWindow.Bottom + wDifference < coordSize.Y )
            {
                //Move the window to bottom
                srClientWindow.Top    = srClientWindow.Top + wDifference;
                srClientWindow.Bottom = srOldClientWindow.Bottom;
                SetConsoleWindowInfo( gwi.hOutput, TRUE,  &srClientWindow );
            }

            if( ( WORD ) gwi.trm.dwCurLine > srClientWindow.Bottom )
            {
               gwi.trm.dwCurLine = srClientWindow.Bottom;
            }
        }

        srOldClientWindow = srClientWindow;

        if( FGetCodeMode(eCodeModeIMEFarEast) )
        {
            srOldClientWindow.Bottom--; //Last row for IME status
        }

        gwi.sbi.srWindow  = srOldClientWindow;
        gwi.sbi.dwSize    = coordSize;
        PrepareForNAWS();
        DoNawsSubNegotiation( &gwi );
        SetMargins( &(gwi.trm), 1, gwi.sbi.dwSize.Y );
        SetWindowSize( g_hTelnetPromptConsoleBuffer );
    }
    else
    {
        //if the buffer size has changed
        if( gwi.sbi.dwSize.X != coordSize.X || gwi.sbi.dwSize.Y != coordSize.Y )
        {
            gwi.sbi.dwSize    = coordSize;
            srOldClientWindow = srClientWindow; //window changes
            PrepareForNAWS();
            SetMargins( &(gwi.trm), 1, gwi.sbi.dwSize.Y );
            if( ( WORD ) gwi.trm.dwCurLine > srClientWindow.Bottom )
            {
               gwi.trm.dwCurLine = srClientWindow.Bottom;
            }
        }

    }
}

void SaveCurrentWindowCoords()
{
    SMALL_RECT srClientWindow = { 0, 0, 0, 0 };

    GetWindowCoordinates( &srClientWindow, NULL );
    srOldClientWindow = srClientWindow;
}

void RestoreWindowCoordinates( )
{
    SMALL_RECT srClientWindow = { 0, 0, 0, 0 };

    GetWindowCoordinates( &srClientWindow, NULL );

    if( ( srClientWindow.Bottom != 0 )  &&//valid values of srClientWindow?
        ( srOldClientWindow.Bottom != 0 ) &&
        ( srOldClientWindow.Top  != srClientWindow.Top ||
          srOldClientWindow.Left != srClientWindow.Left )  )    //Window position over the buffer changed ?
    {
        SetConsoleWindowInfo( gwi.hOutput, TRUE, &srOldClientWindow );
    }

    if( srOldClientWindow.Bottom == 0 )
    {
        srOldClientWindow = srClientWindow;
    }
}

void
ReSizeWindow(HWND hwnd, long cx, long cy)
{
  BOOL bScrollBars;
  NONCLIENTMETRICS NonClientMetrics;

  ASSERT( ( 0, 0 ) );
  NonClientMetrics.cbSize = sizeof( NonClientMetrics );

  SystemParametersInfo( SPI_GETNONCLIENTMETRICS,
                        0,
                        &NonClientMetrics,
                        FALSE );

  //
  //  if cx and cy are -1, then set the window size to the desktop
  //  minus the offset of the window.  This sets the window to the
  //  maximum size that will still be contained on the desktop
  //

  if ( cx == -1 && cy == -1 )
  {
    RECT rect;

    GetWindowRect( hwnd, &rect );

    cx = (SHORT) (GetSystemMetrics( SM_CXFULLSCREEN ) - rect.left);
    cy = (SHORT) (GetSystemMetrics( SM_CYFULLSCREEN ) - rect.top);
  }

  if (( ui.dwClientRow < ui.dwMaxRow ) &&
      ( ui.dwClientCol < ui.dwMaxCol ) &&
      ( (( cy + NonClientMetrics.iScrollHeight ) ) == (LONG)ui.dwMaxRow ) &&
      ( (( cx + NonClientMetrics.iScrollWidth ) ) == (LONG)ui.dwMaxCol ) )
  {
    cy += NonClientMetrics.iScrollHeight;
    cx += NonClientMetrics.iScrollWidth;
  }

  ui.dwClientRow = cy;
  ui.dwClientCol = cx;

  ui.dwClientRow = min ( ui.dwClientRow, ui.dwMaxRow);
  ui.dwClientCol = min ( ui.dwClientCol, ui.dwMaxCol);

  if ( (ui.dwClientRow < ui.dwMaxRow) ||
       (ui.dwClientCol < ui.dwMaxCol) )
  {
    ui.nScrollMaxRow = (SHORT)(ui.dwMaxRow - ui.dwClientRow);
    ui.nScrollRow = ( WORD )min (ui.nScrollRow, ui.nScrollMaxRow);
    ui.nScrollMaxCol = (SHORT)(ui.dwMaxCol - ui.dwClientCol);
    ui.nScrollCol = ( WORD )min (ui.nScrollCol, ui.nScrollMaxCol);
    bScrollBars = TRUE;
  }
  else
  {
    ui.nScrollRow = 0;
    ui.nScrollMaxRow = 0;
    ui.nScrollCol = 0;
    ui.nScrollMaxCol = 0;
    bScrollBars = FALSE;
  }

}

static void
InsertLine(WI *pwi, TRM *ptrm, DWORD iLine)
{
    COORD dwDest;
    SMALL_RECT rect;
    
    rect.Top    = ( short )( iLine );
    rect.Bottom = ( short )( ptrm->dwScrollBottom - 1 - 1 );
        
    rect.Left   = 0;
    rect.Right  = ( short )( ui.nCxChar * ui.dwMaxCol );

    dwDest.X = 0; 
    dwDest.Y = ( short )( iLine + 1 );

    pwi->cinfo.Attributes = pwi->sbi.wAttributes;
    ScrollConsoleScreenBuffer( pwi->hOutput, &rect, NULL, dwDest, &pwi->cinfo );

}


static void
NewLineUp( WI* pwi, TRM* ptrm )
{
    if (ui.bLogging)
    {        
        WriteToLog( ptrm->dwCurLine );
    }

    if( ptrm->dwCurLine <= ptrm->dwScrollTop )
    {
        ptrm->dwCurLine = ptrm->dwScrollTop;
        InsertLine( pwi, ptrm, ptrm->dwScrollTop );
    }
    else
    {
        ptrm->dwCurLine -= 1;

        if( ( SHORT )ptrm->dwCurLine < srOldClientWindow.Top )
        {
            /*SetConsoleWindowInfo should fail when the top reaches buffer top*/

            srOldClientWindow.Top  -= 1;
            srOldClientWindow.Bottom  -= 1;
            SetConsoleWindowInfo( gwi.hOutput, TRUE, &srOldClientWindow );
        }
    }
}

static void
DeleteLine(WI *pwi, TRM *ptrm, DWORD iLine)
{
    SMALL_RECT rect;
    COORD dwDest;

    rect.Top    = ( WORD )( iLine + 1 * iCursorHeight );
    rect.Bottom = ( WORD )( ( ptrm->dwScrollBottom - 1 ) * iCursorHeight );
    rect.Left   = 0;
    rect.Right  = ( WORD )( ui.nCxChar * ui.dwMaxCol );

    dwDest.X = 0;
    dwDest.Y = ( WORD ) ( iLine + 1 - 1 );

    pwi->cinfo.Attributes = pwi->sbi.wAttributes;
    ScrollConsoleScreenBuffer( pwi->hOutput, &rect, NULL, dwDest, &pwi->cinfo );
}

void MoveOneLineDownTheBuffer( WI *pwi, TRM *ptrm )
{
    DWORD dwNumWritten = 0;
    COORD coCursorPosition = { 0, 0 };
/* SetConsoleWindowInfo should fail when the bottom reaches buffer bottom*/

    srOldClientWindow.Top  += 1;
    srOldClientWindow.Bottom  += 1;

    //To avoid the color flickering paint it first and then scroll
    coCursorPosition.X=0; coCursorPosition.Y=srOldClientWindow.Bottom;
    FillConsoleOutputAttribute( pwi->hOutput, pwi->sbi.wAttributes,   
        srOldClientWindow.Right - srOldClientWindow.Left + 1, 
        coCursorPosition, &dwNumWritten );

    SetConsoleWindowInfo( gwi.hOutput, TRUE, &srOldClientWindow );
}

static void
NewLine(WI *pwi, TRM *ptrm)
{
    if (ui.bLogging)
    {        
        WriteToLog( ptrm->dwCurLine );
    }

    if(( ptrm->dwCurLine + 1 ) >= ptrm->dwScrollBottom )
    {
     //   DeleteLines( pwi, ptrm, ptrm->dwScrollTop, 1 );
        DeleteLine( pwi, ptrm, ptrm->dwScrollTop );
    }
    else
    {
        WORD bottom = srOldClientWindow.Bottom;
        if( FGetCodeMode( eCodeModeFarEast ) )
        {
            bottom--;
        }
        ptrm->dwCurLine += 1;

        if( ptrm->dwCurLine > bottom )
        {
            MoveOneLineDownTheBuffer( pwi, ptrm);
        }
    }

    if(( ptrm->dwCurLine > ( ui.dwMaxRow - ( ui.nScrollMaxRow - ui.nScrollRow ))) &&
        ( ui.nScrollRow < ui.nScrollMaxRow ) ) 
    {
        ui.nScrollRow += 1;
        //ScrollWindow(hwnd, 0, -ui.nCyChar, NULL, NULL);
    }
}

static void
SetBufferStart(TRM *ptrm)
{
    ptrm->dwCurCharBT = ptrm->dwCurChar;
    ptrm->dwCurLineBT = ptrm->dwCurLine;
    ptrm->fInverseBT = ptrm->fInverse;
}

static BOOL
FAddCharToBuffer(TRM *ptrm, UCHAR uch)
{
    if (FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80))
    {
        if(FIsVT80(ptrm) || GetACP() == KOR_CODEPAGE ) 
        {
            if( FIsJISKanji(ptrm) || FIsJIS78Kanji(ptrm) || FIsNECKanji(ptrm) || FIsACOSKanji(ptrm) ) 
            {
                if( !(GetKanjiStatus(ptrm) & JIS_KANJI_CODE) ) 
                {
                    if( GetKanjiStatus(ptrm) & (SINGLE_SHIFT_2|SINGLE_SHIFT_3) )
                    {
                        ptrm->rgchBufferText[ptrm->cchBufferText++] = uch;
                        ptrm->dwCurChar++;

                        ClearKanjiStatus(ptrm,(SINGLE_SHIFT_2|SINGLE_SHIFT_3));
                        PopCharSet(ptrm,GRAPHIC_LEFT);
                        PopCharSet(ptrm,GRAPHIC_RIGHT);
                        uchOutPrev = 0;

                    } 
                    else 
                    {
                        ptrm->rgchBufferText[ptrm->cchBufferText++] = uch;
                        ptrm->dwCurChar++;
                        uchOutPrev = 0;
                    }
                } 
                else
                {
                    if ( uchOutPrev == 0 ) 
                    {
                        uchOutPrev = uch;
                    } 
                    else
                    {
                        jistosjis(&uchOutPrev,&uch);
                        ptrm->rgchBufferText[ptrm->cchBufferText++] = uchOutPrev;
                        ptrm->rgchBufferText[ptrm->cchBufferText++] = uch;
                        ptrm->dwCurChar+=2;
                        uchOutPrev = 0;
                    }
                }

            } 
            else if( FIsSJISKanji(ptrm) || GetACP() == KOR_CODEPAGE ) 
            {
                if( uchOutPrev == 0 && IsDBCSLeadByte(uch) ) 
                {
                    /* do not write only LeadByte into buffer.
                       keep current leadbyte character */

                    uchOutPrev = uch;

                }
                else
                {
                    if( uchOutPrev == 0 ) 
                    {
                        ptrm->rgchBufferText[ptrm->cchBufferText++] = uch;
                        ptrm->dwCurChar++;
                    }
                    else 
                    {
                        ptrm->rgchBufferText[ptrm->cchBufferText++] = uchOutPrev;
                        ptrm->rgchBufferText[ptrm->cchBufferText++] = uch;
                        ptrm->dwCurChar+=2;
                        uchOutPrev = 0;
                    }
                }
            } 
            else if( FIsEUCKanji(ptrm) || FIsDECKanji(ptrm) ) 
            {
                if( GetKanjiStatus(ptrm) & (SINGLE_SHIFT_2|SINGLE_SHIFT_3) ) 
                {
                    ptrm->rgchBufferText[ptrm->cchBufferText++] = uch;
                    ptrm->dwCurChar++;

                    ClearKanjiStatus(ptrm,(SINGLE_SHIFT_2|SINGLE_SHIFT_3));
                    PopCharSet(ptrm,GRAPHIC_LEFT);
                    PopCharSet(ptrm,GRAPHIC_RIGHT);
                    uchOutPrev = 0;
                }
                else if( IsEUCCode(uch) || uchOutPrev != 0 ) 
                {
                    if( uchOutPrev == 0 ) 
                    {
                        uchOutPrev = uch;
                    }
                    else 
                    {
                        euctosjis(&uchOutPrev,&uch);
                        ptrm->rgchBufferText[ptrm->cchBufferText++] = uchOutPrev;
                        ptrm->rgchBufferText[ptrm->cchBufferText++] = uch;
                        ptrm->dwCurChar+=2;
                        uchOutPrev = 0;
                    }
                }
                else 
                {
                    ptrm->rgchBufferText[ptrm->cchBufferText++] = uch;
                    ptrm->dwCurChar++;
                    uchOutPrev = 0;
                }
            }
        }
        else
        {
            ptrm->rgchBufferText[ptrm->cchBufferText++] = uch;
            ptrm->dwCurChar++;
        }
        return (ptrm->cchBufferText >= sizeof(ptrm->rgchBufferText));
    }
    ASSERT(!(FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80)));
    ptrm->rgchBufferText[ptrm->cchBufferText++] = uch;
    return (ptrm->cchBufferText >= sizeof(ptrm->rgchBufferText));
}

static BOOL FAddTabToBuffer(TRM *ptrm, DWORD wSpaces)
{
    (void)memset((void *)(ptrm->rgchBufferText+ptrm->cchBufferText), (int)' ', (size_t)wSpaces);
    ptrm->cchBufferText += wSpaces;

    return (ptrm->cchBufferText >= sizeof(ptrm->rgchBufferText));
}

void ResetColors( WI* pwi )
{
    pwi->sbi.wAttributes = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
}


void SetForegroundColor( WI* pwi, UCHAR color )
{
    pwi->sbi.wAttributes = ( WORD )( ( pwi->sbi.wAttributes & ~( ( UCHAR )( FOREGROUND_RED |
        FOREGROUND_GREEN | FOREGROUND_BLUE ))) | color );
}

void SetBackgroundColor( WI* pwi, UCHAR color )
{
    pwi->sbi.wAttributes =( WORD ) ( ( pwi->sbi.wAttributes & ~( ( UCHAR )( BACKGROUND_RED | 
        BACKGROUND_GREEN | BACKGROUND_BLUE ))) | (( UCHAR) ( color << 4 )) );
}

void NegativeImageOn( WI* pwi )
{
    //pwi->sbi.wAttributes = BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE;
    pwi->sbi.wAttributes = ( WORD )( (( pwi->sbi.wAttributes & 
        ( BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE )) >> 4 ) |
        (( pwi->sbi.wAttributes & ( FOREGROUND_RED | FOREGROUND_GREEN | 
        FOREGROUND_BLUE )) << 4 ) | ( pwi->sbi.wAttributes & 
        FOREGROUND_INTENSITY ) | ( pwi->sbi.wAttributes & 
        BACKGROUND_INTENSITY ) ); 
}

void NegativeImageOff( WI* pwi )
{
    //pwi->sbi.wAttributes = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
    pwi->sbi.wAttributes = ( WORD ) ( (( pwi->sbi.wAttributes & 
        ( BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE )) >> 4 ) |
        (( pwi->sbi.wAttributes & ( FOREGROUND_RED | FOREGROUND_GREEN | 
        FOREGROUND_BLUE )) << 4 ) | ( pwi->sbi.wAttributes & 
        FOREGROUND_INTENSITY ) | ( pwi->sbi.wAttributes & 
        BACKGROUND_INTENSITY ) );  
}


void BoldOff( WI* pwi )
{
    pwi->sbi.wAttributes &= (UCHAR) ~( FOREGROUND_INTENSITY );
}

void BoldOn( WI* pwi )
{
    pwi->sbi.wAttributes |= (UCHAR) FOREGROUND_INTENSITY;
}


void SetLightBackground( WI* pwi )
{
    WORD* pAttribs = NULL; 
    COORD co = { 0, 0 };
    DWORD dwNumRead;
    DWORD dwNumWritten;
    int j;
    DWORD dwStatus;
    CONSOLE_SCREEN_BUFFER_INFO cSBInfo;
    COORD dwSize;
    
    GetConsoleScreenBufferInfo( gwi.hOutput, &cSBInfo ); 
    dwSize.X = ( WORD ) ( cSBInfo.srWindow.Bottom - cSBInfo.srWindow.Top + 1 );
    dwSize.Y = ( WORD ) ( cSBInfo.srWindow.Right - cSBInfo.srWindow.Left + 1 );

    pAttribs = ( WORD* ) malloc( sizeof( WORD ) * dwSize.X * dwSize.Y );
    if( !pAttribs) 
        return;

    co.X = cSBInfo.srWindow.Left; 
    co.Y = cSBInfo.srWindow.Top;

    dwStatus = ReadConsoleOutputAttribute( pwi->hOutput, pAttribs, 
        ( DWORD ) dwSize.X * ( DWORD ) dwSize.Y , co, &dwNumRead );
#ifdef DEBUG
    if( !dwStatus )
    {
        _snwprintf(rgchDbgBfr,sizeof(rgchDbgBfr)-1, L"Error: SetLightBackground() -- %d", 
                GetLastError() );
        OutputDebugString(rgchDbgBfr);
    }
#endif
    
    for( j = 0; j < dwSize.X * dwSize.Y; j++ )
    {
        pAttribs[j] |= (UCHAR) BACKGROUND_INTENSITY;
    }

    dwStatus = WriteConsoleOutputAttribute( pwi->hOutput, pAttribs, 
        ( DWORD )dwSize.Y * ( DWORD )dwSize.X, co, &dwNumWritten );
#ifdef DEBUG
    if( !dwStatus )
    {
        _snwprintf(rgchDbgBfr,sizeof(rgchDbgBfr)-1, L"Error: SetLightBackground() -- %d", 
                GetLastError() );
        OutputDebugString(rgchDbgBfr);
    }
#endif

    pwi->sbi.wAttributes |= (UCHAR) BACKGROUND_INTENSITY;
    free( pAttribs );
}

void SetDarkBackground( WI* pwi )
{
    //I am doing this for the whole console screen buffer
    //beacuse right now we don't support scrolling and expect
    //the console screen buffer size to be same as window size
    //but if and when we implement scrolling then we can optimize
    //this stuff so that we change the attributes only for the
    //current visible part of the screen buffer
    WORD* pAttribs = ( WORD* ) malloc( sizeof( WORD) * pwi->sbi.dwSize.X 
        * pwi->sbi.dwSize.Y );
    DWORD dwNumRead;
    DWORD dwNumWritten;
    int j;
    COORD co = { 0, 0 };

    if (!pAttribs)
        return;

    ReadConsoleOutputAttribute( pwi->hOutput, pAttribs, 
        ( DWORD ) ( pwi->sbi.dwSize.X ) * ( DWORD ) ( pwi->sbi.dwSize.Y ),
        co, &dwNumRead );
    
    for( j = 0; j < ( pwi->sbi.dwSize.X ) * ( pwi->sbi.dwSize.Y ); j++ )
    {
        pAttribs[j] &= (UCHAR) ~( BACKGROUND_INTENSITY );
    }

    WriteConsoleOutputAttribute( pwi->hOutput, pAttribs, 
        ( DWORD ) ( pwi->sbi.dwSize.Y ) * ( DWORD )( pwi->sbi.dwSize.X ),
        co, &dwNumWritten );

    pwi->sbi.wAttributes &= (UCHAR) ~( BACKGROUND_INTENSITY );
    free( pAttribs );
}


static void FlushBuffer( WI* pwi, TRM* ptrm )
{
    if( ptrm->cchBufferText != 0 )
    {
        DWORD dwNumWritten;
        COORD dwCursorPosition;

        if( ui.bLogging )
        {                        
            g_bIsToBeLogged = TRUE; //There is data to be logged
        }

        dwCursorPosition.X = ( short ) ( ptrm->dwCurCharBT - ui.nScrollCol );
        dwCursorPosition.Y = ( short ) ( ptrm->dwCurLineBT - ui.nScrollRow);
        
        //WriteConsole is a tty ( kind of sending to stdout ) function.
        //When you write on the right most bottom char on a window, it makes the        
        //widow scroll. It can make the screen look ugly in the presence of 
        //colors. So unless, 81st char on the bottom row is a DBCS char, 
        //use WriteConsoleOutPutCharacter. 

        //Each DBCS char requires two cells on the console screen
        if( FGetCodeMode(eCodeModeFarEast ) &&
            ( srOldClientWindow.Bottom - 1 ==  ( WORD )ptrm->dwCurLine ) &&                
            ptrm->dwCurCharBT + ptrm->cchBufferText > ui.dwMaxCol
          )
        {
            //This is the bottom of the fareast client windows
            DeleteLine( pwi, ptrm, ptrm->dwScrollTop );
            dwCursorPosition.Y--;
            ptrm->dwCurLine--;
        }

        SetConsoleCursorPosition( pwi->hOutput, dwCursorPosition );
        if( srOldClientWindow.Bottom == ( WORD )ptrm->dwCurLine )
        {
            //This will never happen on non FE lang m/cs since status line will be 
            //present at the bottom
            WriteConsoleOutputCharacterA( pwi->hOutput, (PCHAR)ptrm->rgchBufferText, 
                ptrm->cchBufferText, dwCursorPosition, &dwNumWritten );
        }
        else
        {
            WriteConsoleA( pwi->hOutput, ptrm->rgchBufferText, 
                ptrm->cchBufferText, &dwNumWritten, NULL );
        }
        FillConsoleOutputAttribute( pwi->hOutput, pwi->sbi.wAttributes,   
            ptrm->cchBufferText, dwCursorPosition, &dwNumWritten );

        //part of fix for Bug 1470 - DBCS char disappearance at 81 column.
        if( FGetCodeMode(eCodeModeFarEast ) )
        {
            CONSOLE_SCREEN_BUFFER_INFO  csbiCurrent;
            if( GetConsoleScreenBufferInfo( gwi.hOutput, &csbiCurrent ) )
            {
                if( csbiCurrent.dwCursorPosition.Y > dwCursorPosition.Y )
                {
                    //Occupied some space even on next row
                    ptrm->dwCurChar = csbiCurrent.dwCursorPosition.X;
                }
            }
        }

        // Reset parameters 
        ptrm->cchBufferText = 0;
        ptrm->dwCurCharBT = 0;
        ptrm->dwCurLineBT = 0;
        ptrm->fInverseBT = FALSE;
    }
}


void
DoTermReset(WI *pwi, TRM *ptrm)
{
    ptrm->dwVT100Flags = 0;

    //ui.dwCrLf ? SetLineMode(ptrm): ClearLineMode(ptrm);

    SetVTWrap(ptrm);

    ptrm->fSavedState = FALSE;
    ptrm->fRelCursor = FALSE;
    SetMargins( ptrm, 1, ui.dwMaxRow );

    ptrm->cchBufferText = 0;
    ptrm->dwCurCharBT = 0;
    ptrm->dwCurLineBT = 0;
    ptrm->fInverseBT = FALSE;
    if (FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80))
        {
        ClearKanjiFlag(ptrm);
        ClearKanjiStatus(ptrm,CLEAR_ALL);
        SetupCharSet( ptrm );
        }
    else
        {
        ptrm->puchCharSet = rgchNormalChars;
        ptrm->currCharSet = 'B';
        ptrm->G0 = 'B';
        ptrm->G1 = 'B';
        }
    ptrm->fEsc = 0;
    ptrm->cEscParams = 0;
    ptrm->fFlushToEOL = FALSE;
    ptrm->fLongLine = FALSE;
}

static void
CursorUp(TRM *ptrm)
{
	if( ui.bLogging )
	{
		WriteToLog( ptrm->dwCurLine );
	}
    if( ptrm->dwEscCodes[0] == 0 )
    {
        ptrm->dwEscCodes[0] = 1;
    }

    if( ptrm->dwCurLine < (DWORD)ptrm->dwEscCodes[0] )
    {
        ptrm->dwCurLine = 0;
    }
    else
    {
        ptrm->dwCurLine -= ptrm->dwEscCodes[0];
    }

    if(( ptrm->fRelCursor == TRUE ) && ( ptrm->dwCurLine < ptrm->dwScrollTop ))
    {
        ptrm->dwCurLine = ptrm->dwScrollTop;
    }

    ptrm->fEsc = 0;
}


static void
CursorDown(TRM *ptrm)
{
	if( ui.bLogging )
	{
		WriteToLog( ptrm->dwCurLine );
	}

    if (ptrm->dwEscCodes[0] == 0)
            ptrm->dwEscCodes[0]=1;
    ptrm->dwCurLine += ptrm->dwEscCodes[0];
    if (ptrm->dwCurLine >= ui.dwMaxRow)
            ptrm->dwCurLine = ui.dwMaxRow - 1;
    if ((ptrm->fRelCursor == TRUE) &&
            (ptrm->dwCurLine >= ptrm->dwScrollBottom))
    {
            ptrm->dwCurLine = ptrm->dwScrollBottom-1;
    }
    ptrm->fEsc = 0;
}

static void
CursorRight(TRM *ptrm)
{
    if( ptrm->dwEscCodes[0] == 0 )
    {
        ptrm->dwEscCodes[0] = 1;
    }
    
    ptrm->dwCurChar += ptrm->dwEscCodes[0];
    
    if( ptrm->dwCurChar >= ui.dwMaxCol )
    {
        ptrm->dwCurChar = ui.dwMaxCol - 1;
    }

    ptrm->fEsc = 0;
}

static void
CursorLeft(TRM *ptrm)
{
    if( ptrm->dwEscCodes[0] == 0 )
    {
        ptrm->dwEscCodes[0] = 1;
    }
    if( ptrm->dwCurChar < ( DWORD ) ptrm->dwEscCodes[0] )
    {
        ptrm->dwCurChar = 0;
    }
    else
    {
        ptrm->dwCurChar -= ptrm->dwEscCodes[0];
    }
    ptrm->fEsc = 0;
    ptrm->fFlushToEOL = FALSE;
}

void
ClearScreen(WI *pwi, TRM *ptrm, DWORD dwType)
{
    DWORD dwNumWritten;
    COORD dwWriteCoord;

    if( dwType <= fdwEntireScreen )
    {
        ptrm->fInverse = FALSE;

        /*
         * If the cursor is already at the top-left corner
         * and we're supposed to clear from the cursor
         * to the end of the screen, then just clear
         * the entire screen.
         */
        if(( ptrm->dwCurChar == 0 ) && ( ptrm->dwCurLine == 0 ) &&
            ( dwType == fdwCursorToEOS ))
        {
            dwType = fdwEntireScreen;
        }

        if (dwType == fdwEntireScreen)
        {
            /* Clear entire screen */
            ptrm->dwCurChar = srOldClientWindow.Left;
            ptrm->dwCurLine = srOldClientWindow.Top;

//            if (ui.nScrollRow > 0) 
            {
                dwWriteCoord.X = 0; dwWriteCoord.Y = 0;

                FillConsoleOutputCharacter( pwi->hOutput,
                    ' ', ( pwi->sbi.dwSize.X ) * ( pwi->sbi.dwSize.Y ),
                    dwWriteCoord, &dwNumWritten );
                FillConsoleOutputAttribute( pwi->hOutput, pwi->sbi.wAttributes,
                    ( pwi->sbi.dwSize.X ) * ( pwi->sbi.dwSize.Y ), dwWriteCoord,
                    &dwNumWritten );

                ui.nScrollRow = 0;
            }
        }
        else if( dwType == fdwBOSToCursor )
        {
         // Clear from beginning of screen to cursor 

            dwWriteCoord.X = 0; 
            dwWriteCoord.Y = 0;

            FillConsoleOutputCharacter( pwi->hOutput, ' ',
                ptrm->dwCurLine * pwi->sbi.dwSize.X + ptrm->dwCurChar + 1,
                dwWriteCoord, &dwNumWritten );
            FillConsoleOutputAttribute( pwi->hOutput, pwi->sbi.wAttributes,
                ptrm->dwCurLine * pwi->sbi.dwSize.X + ptrm->dwCurChar + 1,
                dwWriteCoord, &dwNumWritten );
        }
        else
        {
            // Clear from cursor to end of screen 

            dwWriteCoord.X = ( short ) ptrm->dwCurChar; 
            dwWriteCoord.Y = ( short ) ptrm->dwCurLine;

            FillConsoleOutputCharacter( pwi->hOutput, ' ',
                ( pwi->sbi.dwSize.Y - ( ptrm->dwCurLine + 1 )) * pwi->sbi.dwSize.X + 
                ( pwi->sbi.dwSize.X - ptrm->dwCurChar ), dwWriteCoord,
                &dwNumWritten );
            FillConsoleOutputAttribute( pwi->hOutput, pwi->sbi.wAttributes,
                ( pwi->sbi.dwSize.Y - ( ptrm->dwCurLine + 1 )) * pwi->sbi.dwSize.X + 
                ( pwi->sbi.dwSize.X - ptrm->dwCurChar ), dwWriteCoord,
                &dwNumWritten );
        }

    }
    ptrm->fEsc = 0;
}


// Fill Screen With E's
void
DECALN(WI *pwi, TRM *ptrm )
{
    DWORD dwNumWritten;
    COORD dwWriteCoord;

    ptrm->fInverse = FALSE;

    ptrm->dwCurLine = ptrm->dwCurChar = 0;
//  if (ui.nScrollRow > 0) 
    {
        dwWriteCoord.X = 0; dwWriteCoord.Y = 0;

        FillConsoleOutputCharacter( pwi->hOutput, 'E',
            ( pwi->sbi.dwSize.X ) * ( pwi->sbi.dwSize.Y ), dwWriteCoord,
            &dwNumWritten );

            ui.nScrollRow = 0;
    }

    ptrm->fEsc = 0;
}


static void
ClearLine(WI *pwi, TRM *ptrm, DWORD dwType)
{
    DWORD   dwStart;
    DWORD   cch;
    COORD   dwWriteCoord;
    DWORD   dwNumWritten;

    if (dwType <= fdwEntireLine)
    {
        ptrm->fInverse = FALSE;

        /* Set starting point and # chars to clear
         *
         * fdwCursorToEOL (0) = from cursor to end of line (inclusive)
         * fdwBOLToCursor (1) = from beginning of line to cursor (inclusive)
         * fdwEntireLine  (2) = entire line
         */

        dwStart = (dwType == fdwCursorToEOL) ? ptrm->dwCurChar : 0;
        cch = (dwType == fdwBOLToCursor)
                                        ? ptrm->dwCurChar+1 : ui.dwMaxCol-dwStart;

        dwWriteCoord.X = (short)(dwStart-ui.nScrollCol);
        dwWriteCoord.Y = (short)(ptrm->dwCurLine-ui.nScrollRow);

        FillConsoleOutputCharacter( pwi->hOutput,
                                        ' ',
                                        cch,
                                        dwWriteCoord,
                                        &dwNumWritten );

        FillConsoleOutputAttribute( pwi->hOutput, pwi->sbi.wAttributes,
            cch, dwWriteCoord, &dwNumWritten );
    }
    ptrm->fEsc = 0;
}

static void
SetMargins(TRM* ptrm, DWORD dwMarginTop, DWORD dwMarginBottom )
{
    if( dwMarginTop > 0 )
    {
        ptrm->dwScrollTop = dwMarginTop - 1;
    }

    if( dwMarginBottom <= ui.dwMaxRow )
    {
        ptrm->dwScrollBottom = dwMarginBottom ;
    }
}

#define MAX_VTNT_BUF_SIZE   81920
#define MAX_ROWS  300
#define MAX_COLS  300
static int dwCurBufSize = 0;
static UCHAR szBuffer[MAX_VTNT_BUF_SIZE];
BOOL bDoVtNTFirstTime = 1;

BOOL
DoVTNTOutput( WI* pwi, TRM* ptrm, int cbTermOut, UCHAR* pchTermOut )
{
    COORD coDest = { 0, 0 };
    CHAR_INFO *pCharInfo; 
    int dwRequire;
    VTNT_CHAR_INFO* pOutCharInfo;
    CONSOLE_SCREEN_BUFFER_INFO csbInfo;
    CHAR pTmp[4];
    DWORD dwWritten = 0;

    RestoreWindowCoordinates( );
    do 
    {
        // we should wait atleast until we get the whole VTNT_CHAR_INFO struct.
        if ( (cbTermOut + dwCurBufSize) < sizeof(VTNT_CHAR_INFO) )
        {
            if( bDoVtNTFirstTime )
            {
                //This hack is meant to work well with SUN.
                //This is necessary because SUN accepts to talk in VTNT but
                //sends out vt100/ansi
                bDoVtNTFirstTime = 0;
                if( !strncmp( ( CHAR * )pchTermOut,"\r\n\r\nSunOS ", 10 ) )
                {
                    return FALSE;
                }
            }
            // we copy all the data that we are called with.
            if(MAX_VTNT_BUF_SIZE > dwCurBufSize+cbTermOut)
            {
            	//copy maximum 'n' bytes where 'n' is the available buffer size
            	memcpy(szBuffer + dwCurBufSize, pchTermOut, cbTermOut); 
	            dwCurBufSize += cbTermOut;
           	}
            SaveCurrentWindowCoords();
            return TRUE;
        }
        
        if ( dwCurBufSize == 0 )
            pOutCharInfo = (VTNT_CHAR_INFO*) pchTermOut;
        else 
        {
            if ( dwCurBufSize < sizeof(VTNT_CHAR_INFO) )
            {
                memcpy(szBuffer + dwCurBufSize, pchTermOut, sizeof(VTNT_CHAR_INFO) - dwCurBufSize );//no overflow. Check already present.
                cbTermOut -= (sizeof(VTNT_CHAR_INFO) - dwCurBufSize);
                pchTermOut += (sizeof(VTNT_CHAR_INFO) - dwCurBufSize);
                dwCurBufSize = sizeof(VTNT_CHAR_INFO);
            }
            pOutCharInfo = (VTNT_CHAR_INFO *) szBuffer;
        }

        if( pOutCharInfo->coSizeOfData.X > MAX_COLS || pOutCharInfo->coSizeOfData.X < 0 )
            return FALSE;

        if( pOutCharInfo->coSizeOfData.Y > MAX_ROWS || pOutCharInfo->coSizeOfData.Y < 0 )
            return FALSE;

        dwRequire = sizeof(VTNT_CHAR_INFO) + 
            pOutCharInfo->coSizeOfData.X * pOutCharInfo->coSizeOfData.Y * sizeof(CHAR_INFO);

        if( dwRequire > MAX_VTNT_BUF_SIZE )
            return FALSE;

        // we also wait until we get all of the CHAR_INFO structures.
        if ( (cbTermOut + dwCurBufSize) < dwRequire )
        {
            // we copy all the data that we are called with.
            memcpy(szBuffer + dwCurBufSize, pchTermOut, cbTermOut);//no overflow. Check present.
            dwCurBufSize += cbTermOut;

            SaveCurrentWindowCoords();
            return TRUE;
        }

        if ( dwCurBufSize == 0 )
        {
            pCharInfo = (CHAR_INFO *)(pchTermOut + sizeof(VTNT_CHAR_INFO));

            // adjust the pointers for one more go around the while loop.
            // we are consuming as much as we require
            cbTermOut -= dwRequire;
            pchTermOut += dwRequire;            
        }
        else
        {
        	if(MAX_VTNT_BUF_SIZE>dwRequire-dwCurBufSize)
       		{
	            memcpy(szBuffer + dwCurBufSize, pchTermOut, dwRequire - dwCurBufSize);

		   	     // adjust the pointers for one more go around the while loop.
	            // we are consuming only what we require which is dwRequire - dwCurBufSize.
	            cbTermOut -= (dwRequire - dwCurBufSize);
	            pchTermOut += (dwRequire - dwCurBufSize);
	            
	            pCharInfo = (CHAR_INFO *)(szBuffer + sizeof(VTNT_CHAR_INFO));
       		}
        }

        if ( !GetConsoleScreenBufferInfo( pwi->hOutput, &csbInfo ) )
        {
            csbInfo.srWindow.Top = csbInfo.srWindow.Bottom = 0;
            csbInfo.srWindow.Left = csbInfo.srWindow.Right = 0;
        }

        if( FGetCodeMode(eCodeModeFarEast) )
        {
            //Last line is meant for IME status
            csbInfo.srWindow.Bottom--;
        }

        //Update cursor Position
        pOutCharInfo->coCursorPos.Y += csbInfo.srWindow.Top ;                                               
        pOutCharInfo->coCursorPos.X += csbInfo.srWindow.Left;
                
        //check if there is data
        if( !( pOutCharInfo->coSizeOfData.X == 0 && pOutCharInfo->coSizeOfData.Y == 0 ))
        {       
            //See if we have to scroll

            //csbi.wAttributes is filled by v2 server with following meaning
            //When a scrolling case is detected, this is set to 1.
            if( pOutCharInfo->csbi.wAttributes == ABSOLUTE_COORDS )                
            {
                //No scroling at all                           
                //Update rectangle to write to
                pOutCharInfo->srDestRegion.Top    += csbInfo.srWindow.Top ; 
                pOutCharInfo->srDestRegion.Left   += csbInfo.srWindow.Left;
                pOutCharInfo->srDestRegion.Right  += csbInfo.srWindow.Left;
                pOutCharInfo->srDestRegion.Bottom += csbInfo.srWindow.Top;               
            }

            if( pOutCharInfo->csbi.wAttributes == RELATIVE_COORDS ) 
            {
                if( pOutCharInfo->srDestRegion.Left > 0 && pOutCharInfo->coSizeOfData.Y == 1 &&
                    pOutCharInfo->srDestRegion.Top < csbInfo.srWindow.Bottom - csbInfo.srWindow.Top + 1)
                {
                    //This condition is for VTNT stream mode.
                    //Append to the last row
                    pOutCharInfo->srDestRegion.Top    = csbInfo.srWindow.Bottom; 
                    pOutCharInfo->srDestRegion.Left   += csbInfo.srWindow.Left;
                    pOutCharInfo->srDestRegion.Right  += pOutCharInfo->coSizeOfData.X - 1;
                    pOutCharInfo->srDestRegion.Bottom =  csbInfo.srWindow.Bottom;

                    //Update cursor Position                
                    pOutCharInfo->coCursorPos.Y = csbInfo.srWindow.Bottom;
                                                      
                }
                else if( csbInfo.srWindow.Bottom + pOutCharInfo->coSizeOfData.Y > csbInfo.dwSize.Y - 1 )
                {
                    //need to scroll the buffer itself
                    SMALL_RECT srRect = { 0, 0, 0, 0 };
                    COORD      coDestination = { 0, 0 };
                    CHAR_INFO  cInfo;

                    srRect.Top    = pOutCharInfo->coSizeOfData.Y;
                    srRect.Left   = 0;
                    srRect.Bottom = csbInfo.dwSize.Y - 1;
                    srRect.Right  = csbInfo.dwSize.X - 1;

                    if( FGetCodeMode(eCodeModeFarEast) )
                    {
                        //Last line is meant for IME status
                        srRect.Bottom++;
                    }


                    cInfo.Char.UnicodeChar    =  L' ';
                    cInfo.Attributes          =  csbInfo.wAttributes;
                
                    //We have to scroll screen buffer. we need space to write.
                    ScrollConsoleScreenBuffer( pwi->hOutput,
                                               &srRect, 
                                               NULL, 
                                               coDestination, 
                                               &cInfo );

                    pOutCharInfo->srDestRegion.Top    = csbInfo.srWindow.Bottom - pOutCharInfo->coSizeOfData.Y + 1;
                    pOutCharInfo->srDestRegion.Bottom = csbInfo.srWindow.Bottom;

                    //Update cursor Position                
                    pOutCharInfo->coCursorPos.Y = csbInfo.srWindow.Bottom;
                }
                else
                {
                    //Update rectangle to write to
                    //Append to the bootom of the screen
                    pOutCharInfo->srDestRegion.Top    = csbInfo.srWindow.Bottom + 1 ; 
                    pOutCharInfo->srDestRegion.Left   = csbInfo.srWindow.Left;
                    pOutCharInfo->srDestRegion.Right  = pOutCharInfo->coSizeOfData.X - 1;
                    pOutCharInfo->srDestRegion.Bottom = ( csbInfo.srWindow.Bottom + 1 ) +
                                                            ( pOutCharInfo->coSizeOfData.Y - 1 );
                    //Update cursor Position                
                    pOutCharInfo->coCursorPos.Y = csbInfo.srWindow.Bottom + pOutCharInfo->coSizeOfData.Y;

                    if( FGetCodeMode(eCodeModeFarEast) )
                    {
                        if( csbInfo.srWindow.Bottom + pOutCharInfo->coSizeOfData.Y < csbInfo.dwSize.Y )
                        {
                            csbInfo.srWindow.Top    += pOutCharInfo->coSizeOfData.Y;
                            csbInfo.srWindow.Bottom += pOutCharInfo->coSizeOfData.Y;
                        }
                        else
                        {
                            SHORT sDiff = csbInfo.srWindow.Bottom - csbInfo.srWindow.Top;
                            csbInfo.srWindow.Bottom = csbInfo.dwSize.Y - 1;
                            csbInfo.srWindow.Top    = csbInfo.srWindow.Bottom - sDiff;
                        }
                    }
                }
            }

            WriteConsoleOutput( pwi->hOutput, pCharInfo,
                pOutCharInfo->coSizeOfData, coDest, 
                &pOutCharInfo->srDestRegion );

            if( ui.bLogging )
            {
                WriteCharInfoToLog( pCharInfo, pOutCharInfo->coSizeOfData );
            }
        }

        if( FGetCodeMode(eCodeModeFarEast) )
        {
            //Last line is meant for IME status
            csbInfo.srWindow.Bottom ++;
            SetConsoleWindowInfo( pwi->hOutput, TRUE, &csbInfo.srWindow );
        }

        SetConsoleCursorPosition( pwi->hOutput, pOutCharInfo->coCursorPos );

        // reset for the new loop.
        dwCurBufSize = 0;
    } while ( cbTermOut >= 0 );

    // cbTermOut is negative, that is impossible.
    return FALSE;
}

void SetGraphicRendition( WI *pwi, TRM *ptrm, INT iIndex, 
        DWORD rgdwGraphicRendition[] )
{
    INT i=0;
    for( i=0; i<= iIndex; i++ )
    {
        switch ( rgdwGraphicRendition[i] )
        {
        case 40:  
            //black
            SetBackgroundColor( pwi, 0 );
            break;

        case 41:
            //red
            SetBackgroundColor( pwi, FOREGROUND_RED );
            break;

        case 42:
            //green
            SetBackgroundColor( pwi, FOREGROUND_GREEN );
            break;

        case 43:
            SetBackgroundColor( pwi, ( FOREGROUND_RED | 
                FOREGROUND_GREEN ) );
            break;

        case 44:
            SetBackgroundColor( pwi, FOREGROUND_BLUE );
            break;

        case 45:
            SetBackgroundColor( pwi, ( FOREGROUND_RED | 
                FOREGROUND_BLUE ) );
            break;

        case 46:
             SetBackgroundColor( pwi, ( FOREGROUND_BLUE | 
                FOREGROUND_GREEN ) );
            break;

        case 47:
             //white
            SetBackgroundColor( pwi, ( FOREGROUND_RED | 
                FOREGROUND_BLUE | FOREGROUND_GREEN ) );
            break;
        
            
        case 30:  
            //black
            SetForegroundColor( pwi, 0 );
            break;

        case 31:
            //red
            SetForegroundColor( pwi, FOREGROUND_RED );
            break;

        case 32:
            //green
            SetForegroundColor( pwi, FOREGROUND_GREEN );
            break;

        case 33:
            SetForegroundColor( pwi, ( FOREGROUND_RED | 
                FOREGROUND_GREEN ) );
            break;

        case 34:
            SetForegroundColor( pwi, FOREGROUND_BLUE );
            break;

        case 35:
            SetForegroundColor( pwi, ( FOREGROUND_RED | 
                FOREGROUND_BLUE ) );
            break;

        case 36:
            SetForegroundColor( pwi, ( FOREGROUND_BLUE | 
                FOREGROUND_GREEN ) );
            break;

        case 37:
            //white
            SetForegroundColor( pwi, ( FOREGROUND_RED | 
                FOREGROUND_BLUE | FOREGROUND_GREEN ) );
            break;

        case 21:                             
        case 22: 
            BoldOff( pwi );
            break; 

        case 24: // Underscore off
            break;

        case 25: // Blink off
            break;
            
        case 27: // Negative (reverse) image off
            if( ptrm->fInverse == TRUE )
            {
                ptrm->fInverse = FALSE;
                NegativeImageOff( pwi );
            }
            break; 
        case 10:
            break;

        case 11:
            break;

        case 12:
            break;

        case 8:
            break;

        case 7: // Negative (reverse) image; reverse video
            ptrm->fInverse = TRUE;
            NegativeImageOn( pwi );
            break;

        case 5: // Blink 
            //have to wait until WIN32 console provides
            //a way to do this :-(
            break;

        case 4: // Underscore / underline 
            //have to wait until WIN32 console provides
            //a way to do this :-(
            break;

        case 2: // low video
            BoldOff( pwi );
            break;

        case 1: // Bold or increased intensity; high video
            BoldOn( pwi );
            break;

        case 0: // Attributes Off; normal video
            if( ptrm->fInverse == TRUE )
            {
                ptrm->fInverse = FALSE;
                NegativeImageOff( pwi );
                //BoldOff( pwi );
            }
            BoldOff( pwi );
            ResetColors( pwi );
            break;

        default:
            //ptrm->fInverse = FALSE;

            if( ptrm->fInverse == TRUE )
            {
                ptrm->fInverse = FALSE;
                NegativeImageOff( pwi );
                //BoldOff( pwi );
            }   
            BoldOff( pwi );
            break;  
        }
    }
    return;
}


/* This is meant only for FAREAST IME. In this case, there will be one blank 
 * line at the bottom whose presence is not known to the server. i.e; During 
 * NAWS we gave window size - 1 as our actual size. To maintain this during 
 * scrolling we need to write extra blank line. When the cursor is at the 
 * bottom, if we try to write one char just down the buffer, we get a blank line
 * Otherwise, no effect.*/

void WriteOneBlankLine( HANDLE hOutput, WORD wRow )
{
    COORD coWrite = { 0, 0 };
    if( wRow <= gwi.trm.dwScrollBottom )
    {
        coWrite.Y = wRow;
        SetConsoleCursorPosition( hOutput, coWrite );
    }
}


/*///////////////////////////////////////////////////////////////////////////////
VT100 NOTES:

This info was obatined from 
http://www.cs.utk.edu/~shuford/terminal/vt100_codes_news.txt


  The following describes information needed for controlling the VT100 terminal
from a remote computer.  All of the information was derived from the VT100 
user's manual, Programmer's Information section.  Full documentation can be 
obtain from DIGITAL'S Accessory and Supplies Group.


[The notation  <ESC>  denotes a single ASCII Escape character, 1Bx.]

                                ANSI mode w/cursor      ANSI mode w/cursor
Cursor Key      VT52 mode       key mode reset          key mode set
--------------------------------------------------------------------------
   UP           <ESC>A          <ESC>[A                 <ESC>OA
  DOWN          <ESC>B          <ESC>[B                 <ESC>OB
  RIGHT         <ESC>C          <ESC>[C                 <ESC>OC
  LEFT          <ESC>D          <ESC>[D                 <ESC>OD


 --------------------------
| Terminal Control Commands |
 --------------------------

    Control Characters
    ------------------
        look for details in code below





    The VT100 is an upward and downward software-compatible terminal;
that is, previous Digital video terminals have Digital's private standards
for control sequences. The American National Standards Institute has since
standardized escape and control sequences in terminals in documents X3.41-1974
and X3.64-1977.

    The VT100 is compatible with both the previous Digital standard and
ANSI standards.  Customers may use existing Digital software designed around
the VT52 or new VT100 software.  The VT100 has a "VT52 compatible" mode in
which the VT100 responds to control sequences like a VT52.  In this mode, most
of the new VT100 features cannot be used.

        Throughout this document references will be made to "VT52 mode" or
"ANSI mode".  These two terms are used to indicate the VT100's software
compatibility.

NOTE: The ANSI standards allow the manufacturer flexibility in implementing
each function.  This document describes how the VT100 will respond to the
implemented ANSI central function.

NOTE: ANSI standards may be obtained by writing:

                American National Standards Institute
                Sales Department 
                1430 Broadway
                New York, NY, 10018

        [July 1995 update:  current address for ordering ANSI standards:
        
        American National Standards Institute 
        Attn: Customer Service
        11 West 42nd Street 
        New York, NY  10036 
        USA
        
        ANSI's fax number for placing publication orders is +1 212/302-1286.]

        [Further update, from Tim Lasko <lasko@regent.enet.dec.com>:
        "ANSI X3.64 has been withdrawn in favor of the more complete and
         updated ISO standard 6429. (ECMA-48 is equivalent to ISO DP6429,
         last I checked.) X3.64 has been out of date for some time. At the
         time when I was on the relevant committee, we couldn't get enough
         resources to  really do a good job of updating the standard.
         Later, the proposal came up to withdraw it in favor of the ISO
         standard.]



Definitions
-----------

        Control Sequence Introducer (CSI) - An escape sequence that provides
                supplementary controls and is itself a prefix affecting the
                interpretation of a limited number of contiguous characters.
                In the VT100, the CSI is: <ESC>[

        Parameter:  (1) A string of zero or more decimal characters which
                represent a single value.  Leading zeros are ignored.  The
                decimal characters have a range of 0 (060) to 9 (071).
                (2) The value so represented.

        Numeric Parameter:  A parameter that represents a number, designated by
                Pn.

        Selective Parameter:  A parameter that selects a subfunction from a
                specified set of subfunctions, designated by Ps.  In general, a
                control sequence with more than one selective parameter causes
                the same effect as several control sequences, each with one
                selective parameter, e.g., CSI Psa; Psb; Psc F is identical to
                CSI Psa F CSI Psb F CSI Psc F.

        Parameter String:  A string of parameters separated by a semicolon.

        Default: A function-dependent value that is assumed when no explicit
                value, or a value of 0, is specified.

        Final character:  A character whose bit combination terminates an
                escape or control sequence.

        EXAMPLE:  Control sequence to turn off all character attributes, then
        turn on underscore and blink attributes (SGR).  <ESC>[0;4;5m


                Sequence:
                
                  
                        Delimiters
                          / \
                         /   \
                         |   | 
                        \ / \ /
                <ESC>[ 0 ; 4 ; 5 m
                ^^^^^^ ^   ^   ^ ^
                |||||| |   |   | |
                \||||/  \  |  /  +------Final character
                 \||/    \ | /
                 CSI   Selective
                       Parameters

                The octal representation of this string is:

                        033 0133 060 073 064 073 065 0155
                      <ESC>   [   0   ;   4   ;   5    m


                Alternate sequences which will accomplish the same thing:

                        1) <ESC>[;4;m 

                        2) <ESC>[m
                           <ESC>[4m 
                           <ESC>[5m

                        3) <ESC>[0;04;005m


Control Sequences
-----------------

    All of the following control sequences are transmitted from the Host to
VT100 unless otherwise noted.  All of the control sequences are a subset of
those defined in ANSI X 3.64 1977 and ANSI X 3.41 1974.

    The following text conforms to these formatting conventions:

        1) Control characters are designated by angle brackets (e.g.
            the Escape character is <ESC>).

        2) Parameters are indicated by curly braces.

        3) Parameter types usually are indicated as one of:
            
            {Pn}    A string of digits representing a numerical
                    value.
            
            {Ps}    A character that selects an item from a list.

            {a-z}   Any lowercase sequence of one44 or more
                    characters in braces represent a value to be
                    entered (as in {Pn}), and the name in the
                    braces will be referred to in explanatory text.

        4) Spaces in the control sequence are present for clarity and
           may be omitted.  Spaces which are required will be
           surrounded by single quotes: ' '.
        
        5) All other characters are literals.


    look for details in code below

    CPR     Cursor Position Report          VT100 to Host

        <ESC>[ {Pn} ; {Pn} R            Default Value: 1

        The CPR sequence reports the active position by means of the
        parameters.  This sequence has two parameter values, the first
        specifying the line and the second specifying the column.  The default
        condition with no parameters present, or parameters of 0, is equivelent
        to a cursor at home position.

        The numbering of the lines depends upon the state of the Origin Mode
        (DECOM).

        This control sequence is sent in reply to a device status report (DSR)
        command sent from the host.

    CUB
    
    CUD

    CUF

    CUP

    CUU

    DA




    "I doubt if a lot of these DEC commands work..a few do.. (like scroll areas)"
    I think that this guy means that he doubts whether they even work on a real 
    vt100

    DECALN  

    DECANM 
    
    DECARM

    DECAWM

    DECCKM
    
    DECCOLM

    DECDHL

    DECDWL    

    DECID

    DECINLM

    DECKPAM    

    DECKNPNM

    DECLL

    DECOM

    DECRC

    DECREPTPARM     Report Terminal Parameters      VT100 to Host

        <ESC>[ {sol} ; {par} ; {nbits} ; {xspd} ; {rspd} ; {cmul} ; {flags} x

        This sequence is generated by the VT100 to notify the host of the
        status of selected terminal parameters.  The status sequence may be
        sent when requested by the host (via DECREQTPARM) or at the terminal's
        discretion.  On power up or reset, the VT100 is inhibited from sending
        unsolicited reports.      
        
        The meanings of the sequence paramters are:
        Parameter       Value   Meaning
        ------------------------------------------------------------------
          {sol}           1     This message is a report.
                          2     This message is a report, and the terminal is
                                only reporting on request.

          {par}           1     No parity set
                          4     Parity set and odd
                          5     Parity set and even

         {nbits}          1     8 bits per character
                          2     7 bits per character

         {xspd}           0     Speed set to 50 bps
         -and-            8     Speed set to 75 bps
         {rspd}          16     Speed set to 110 bps
                         24     Speed set to 134.5 bps
         {xspd}=         32     Speed set to 150 bps
          Transmit       40     Speed set to 200 bps
          Speed          48     Speed set to 300 bps
                         56     Speed set to 600 bps
         {rspd}=         64     Speed set to 1200 bps
          Recieve        72     Speed set to 1800 bps
          Speed          80     Speed set to 2000 bps
                         88     Speed set to 2400 bps
                         96     Speed set to 3600 bps
                        104     Speed set to 4800 bps
                        112     Speed set to 9600 bps
                        120     Speed set tp 19200 bps

        {cmul}            1     The bit rate multiplier is 16

        {flags}        0-15     This value communicates the four switch values
                                in block 5 of SET-UP B, which are only visible
                                to the user when an STP option is installed.

        
    DECREQTPARM 

    DECSC

    DECSCLM

    DECSCNM

    DECSTBM

    DECSWL

    DECTST

    DSR

    ED

    EL

    HTS

    HVP

    IND

    LNM

    MODES   The Following is a list of VT100 modes which may be changed with Set
            Mode (SM) and Reset Mode (RM) controls. 
            
            ANSI Specified Modes

            Parameter       Mnemonic        Function
            ------------------------------------------------------------------
                0                           Error (Ignored)
                20             LNM           Line Feed/New Line Mode

            DEC Private Modes

            If the first character in the parameter string is ? (077), the
            parameters are interpreted as DEC private parameters according to the
            following:
            
            Parameter       Mnemonic        Function
            -------------------------------------------------------------------
                0                           Error (Ignored)
                1            DECCKM         Cursor Key
                2            DECANM         ANSI/VT52
                3            DECCOLM        Column
                4            DECSCLM        Scrolling
                5            DECSCNM        Screen
                6            DECOM          Origin
                7            DECAWM         Auto Wrap
                8            DECARM         Auto Repeat
                9            DECINLM        Interlace


            Any other parameter values are ignored.

            The following modes, which are specified in the ANSI standard, may be
            considered to be permanently set, permanently reset, or not applicable,
            as noted. 
            
            Mnemonic        Function                        State
            ------------------------------------------------------
            CRM             Control Representation          Reset
            EBM             Editing Boundary                Reset
            ERM             Erasure                         Set
            FEAM            Format Effector Action          Reset
            FETM            Format Effector Transfer        Reset
            GATM            Guarded Area Transfer           NA
            HEM             Horizontal Editing              NA
            IRM             Insertion-replacement           Reset
            KAM             Keyboard Action                 Reset
            MATM            Multiple area transfer          NA
            PUM             Positioning Unit                Reset
            SATM            Selected Area Transfer          NA
            SRTM            Status Reporting Transfer       Reset
            TSM             Tabulation Stop                 Reset
            TTM             Transfer Termination            NA
            VEM             Vertical Editing                NA


    NEL

    RI

    RIS

    RM

    SCS

    SGR

    SM

    TBC

*////////////////////////////////////////////////////////////////////////////////

/*///////////////////////////////////////////////////////////////////////////////
  DoIBMANSIOutput

    Purpose:
    Interpret any IBM ANSI escape sequences in the output stream
    and perform the correct terminal emulation in response.
    Normal text is just output to the screen.

    Changes for v4.1:
        - now support Clear to end of display ESC[J
        - better support for the FTCU machine by "eating" certain
    unknown escape sequences, namely ESC)0 and ESC[?7h.
*////////////////////////////////////////////////////////////////////////////////

void
DoIBMANSIOutput( WI *pwi, TRM *ptrm, DWORD cbTermOut, UCHAR *pchTermOut )
{
    DWORD ich;
    DWORD i = 0;
    DWORD dwDECMode = 0;
    UCHAR *pchT;
    COORD cp;
    COORD dwSize, dwMaximumWindowSize;
    DWORD dwSavedCurPos;
    CHAR *pchTemp = NULL;

    //* suppress cursor on screen 
    ptrm->fHideCursor = TRUE;

    ptrm->cTilde = 0;
    
    RestoreWindowCoordinates( );
    CheckForChangeInWindowSize( );

    for( ich = 0, pchT = pchTermOut; ich < cbTermOut; ++ich, ++pchT )
    {
               
        if( ( !FGetCodeMode(eCodeModeFarEast) && !FGetCodeMode(eCodeModeVT80)) 
            && IS_EXTENDED_CHAR( *pchT ) )
        {
            DWORD dwNumWritten;
            COORD dwCursorPosition;

            FlushBuffer( pwi, ptrm );

            dwCursorPosition.X = ( short ) ( ptrm->dwCurChar - ui.nScrollCol );
            dwCursorPosition.Y = ( short ) ( ptrm->dwCurLine - ui.nScrollRow);
            ptrm->dwCurChar++;

            SetConsoleCursorPosition( pwi->hOutput, dwCursorPosition );
            
            WriteConsoleA( pwi->hOutput,  (CHAR *)pchT, 1, &dwNumWritten, NULL );       
                       
            FillConsoleOutputAttribute( pwi->hOutput, pwi->sbi.wAttributes,
                                        1, dwCursorPosition, &dwNumWritten );
            if( ui.bLogging )
            {
                g_bIsToBeLogged = TRUE; //There is data to be logged
            }

            continue;
        }

        // process character 
        switch ( ptrm->fEsc )
        {
        case 0: // normal processing 

        /*
        Control Characters
        ------------------

        The control characters recognized by the VT100 are listed below. All 
        other control characters cause no action to be taken.

            Control characters (codes 00 - 037 inclusive) are specifically 
        excluded from the control sequence syntax, but may be embedded within a 
        control sequence. Embedded control characters are executed as soon as 
        they are encountered by the VT100.  The processing of the control 
        sequence then continues with the next character recieved. The exceptions
        are: if the <ESC> character occurs, the current control sequence is
        aborted, and a new one commences beginning with the <ESC> just recieved.
        If the character <CAN> (030) or the character <SUB> (032) occurs, the 
        current control sequence is aborted.  The ability to embed control 
        characters allows the synchronization characters XON and XOFF to be 
        interpreted properly without affecting the control sequence.

        detailed comments below are in the format
        // Control Character; Octal Code; Action Taken

        */

            switch( *pchT )
            {


            case 0x1B:      // ESC? 
                //<ESC>; 0033; Introduces a control sequence.
                ptrm->fEsc = 1;
                break;

            case 0:
                //<NUL>; 0000; Ignored on input, not stored in buffer
                break;

            case 0x05 :
                //<ENQ>; 0005; Transmit ANSWERBACK message
                break;

            case 0x08: // Backspace 
                //<BS>; 0010; Move cursor to the left one position, unless it is
                //at the left margin, in which case no action is taken.

                if( ptrm->dwCurChar > 0 )
                {
                    --ptrm->dwCurChar;
                }
                FlushBuffer( pwi, ptrm );
                break;

            case 0x07:      
                //<BEL>; 0007; Sound bell
                MessageBeep( ( UINT ) (~0) );
                break;

            case 0x09:      // TAB 
                //<HT>; 0011; Move cursor to the next tab stop, or to the right
                //margin if no further tabs are set.

                dwSavedCurPos = ptrm->dwCurChar;
                if( g_iHTS )
                {
                    int x=0;
                    while( x < g_iHTS )
                    {
                        if( g_rgdwHTS[ x ] > ptrm->dwCurChar 
                                && g_rgdwHTS[ x ] != -1 ) 
                        {
                            break;
                        }
                        x++;
                    }
                    while( x < g_iHTS && g_rgdwHTS[ x ] == -1 )
                    {
                        x++;
                    }
                    if( x < g_iHTS )
                    {
                        ptrm->dwCurChar = g_rgdwHTS[ x ];

                    }
                    else
                    {
                        ptrm->dwCurChar += TAB_LENGTH;
                        ptrm->dwCurChar -= ptrm->dwCurChar % TAB_LENGTH;
                    }
                }
                else
                {
                    ptrm->dwCurChar += TAB_LENGTH;
                    ptrm->dwCurChar -= ptrm->dwCurChar % TAB_LENGTH;
                }

                if( ui.fDebug & fdwTABtoSpaces )
                {
                    if( ptrm->cchBufferText == 0 )
                    {
                        SetBufferStart( ptrm );
                    }
                    if( FAddTabToBuffer( ptrm, ptrm->dwCurChar-dwSavedCurPos ) )
                    {
                        FlushBuffer( pwi, ptrm );
                    }
                }

                if( !( ui.fDebug & fdwTABtoSpaces ) )
                {
                    FlushBuffer(pwi, ptrm);
                }
                if( ptrm->dwCurChar >= ui.dwMaxCol )
                {
                    if( ui.fDebug & fdwTABtoSpaces )
                    {
                        FlushBuffer( pwi, ptrm );
                    }
                    ptrm->dwCurChar = 0;
                    NewLine( pwi, ptrm );
                }
                break;

            case '\r': // Carriage Return 
                //<CR>; 0015 ;Move the cursor to the left margin of the current
                //line.
                ptrm->dwCurChar = 0;
                ptrm->fFlushToEOL = FALSE;
                FlushBuffer( pwi, ptrm );
                break;
            
            case 11:
                //<VT>; 0013; Same as <LF>.

            case 12: // Form feed
                //<FF>; 0014 ;Same as <LF>.

            case '\n': //Line Feed 
                //<LF>; 0012; Causes either a line feed or new line operation 
                //(See new line mode.)

                if( ptrm->fFlushToEOL ) 
                {
                    ptrm->fLongLine = FALSE;
                    ptrm->fFlushToEOL = FALSE;
                    break;
                }
                if( ptrm->fLongLine )
                {
                    ptrm->fLongLine = FALSE;
                    break;
                }
                FlushBuffer( pwi, ptrm );
                NewLine( pwi, ptrm );
                break;

            case 0x0F:
                //<SI>; 0017; Invoke the G0 character set, as selected by the <ESC>(
                //sequence.
                
                ptrm->currCharSet = 0; // 0 signifies G0

                if (FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80))
                    {
                    if(FIsVT80(ptrm)) {
                        SetCharSet(ptrm,GRAPHIC_LEFT,ptrm->g0);
                    } else {
                        SetCharSet(ptrm,GRAPHIC_LEFT,rgchIBMAnsiChars);
                    }
                    break;
                    }
                ASSERT(!(FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80)));
                switch( ptrm->G0 ) {
                case '0' :
                    ptrm->puchCharSet = rgchSpecialGraphicsChars;
                    break;
                case '1':
                    ptrm->puchCharSet = rgchNormalChars;
                    break;
                case '2' :
                    ptrm->puchCharSet = rgchSpecialGraphicsChars;
                    break;
                case 'A' :
                    ptrm->puchCharSet = rgchUKChars;
                    break;
                case 'B' :
                    ptrm->puchCharSet = rgchNormalChars;
                    break;
                default:
                    
                    break;
                }

                break;

            case 0x0E:
                //<SO>; 0016; Invoke the G1 character set, as designated by the
                //SCS control sequence.

                ptrm->currCharSet = 1;  // 1 signifies G1

                if (FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80))
                    {
                    if(FIsVT80(ptrm)) {
                        SetCharSet(ptrm,GRAPHIC_LEFT,ptrm->g1);
                    } else {
                         SetCharSet(ptrm,GRAPHIC_LEFT,rgchGraphicsChars);
                    }
                    break;
                    }
                ASSERT(!(FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80)));
                switch( ptrm->G1 ) {
                case '0' :
                    ptrm->puchCharSet = rgchSpecialGraphicsChars;
                    break;
                case '1':
                    ptrm->puchCharSet = rgchNormalChars;
                    break;
                case '2' :
                    ptrm->puchCharSet = rgchSpecialGraphicsChars;
                    break;
                case 'A' :
                    ptrm->puchCharSet = rgchUKChars;
                    break;
                case 'B' :
                    ptrm->puchCharSet = rgchNormalChars;
                    break;
                default:
                    
                    break;
                }
                break;

            case 0x8E:
                if (FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80) && FIsVT80(ptrm)) 
                {
                           if( !(GetKanjiStatus(ptrm) & JIS_KANJI_CODE) &&
                            (FIsJISKanji(ptrm) || FIsJIS78Kanji(ptrm) ||
                            FIsEUCKanji(ptrm) || FIsDECKanji(ptrm)      ) ) {
                            PushCharSet(ptrm,GRAPHIC_LEFT,ptrm->g2);
                            PushCharSet(ptrm,GRAPHIC_RIGHT,ptrm->g2);
                            SetKanjiStatus(ptrm,SINGLE_SHIFT_2);
#ifdef DEBUG
                            wsprintf(rgchDbgBfr,"VT80 EUC/DEC/JIS SS2 Mode Enter\n");
                            OutputDebugString(rgchDbgBfr);
#endif /* DEBUG */
                        } else {
                            goto Fall_Through;
                        }
                    } else {
                        goto Fall_Through;
                    }
                break;
            case 0x8F:
                if (FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80) )
                {
                   if( FIsVT80(ptrm) )
                    {
                    if( !(GetKanjiStatus(ptrm) & JIS_KANJI_CODE) &&
                        (FIsJISKanji(ptrm) || FIsJIS78Kanji(ptrm) ||
                        FIsEUCKanji(ptrm) || FIsDECKanji(ptrm)      ) ) {
                        PushCharSet(ptrm,GRAPHIC_LEFT,ptrm->g3);
                        PushCharSet(ptrm,GRAPHIC_RIGHT,ptrm->g3);
                        SetKanjiStatus(ptrm,SINGLE_SHIFT_3);
#ifdef DEBUG
                        wsprintf(rgchDbgBfr,"VT80 EUC/DEC/JIS SS3 Mode Enter\n");
                        OutputDebugString(rgchDbgBfr);
#endif /* DEBUG */
                    } else {
                        goto Fall_Through;
                    }
                } else {
                    goto Fall_Through;
                }
                }
                break;
            case 0x1A:
                if (FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80))
                    {
                    if (FIsACOSKanji(ptrm) && (ui.fAcosSupportFlag & fAcosSupport)) {
                        ptrm->fEsc = 7;
                    } else {
                        //goto Fall_Through;
                        break;
                    }
                    }
                break;


            case 0021:
                //<DC1>; 0021; Causes terminal to resume transmission (XON).
                break;

            case 0023:
                //<DC3>; 0023; Causes terminal to stop transmitting all codes 
                //except XOFF and XON (XOFF).
                break;

//            case 0032:
            case 0030:
                //<CAN>; 0030; If sent during a control sequence, the sequence is
                //immediately terminated and not executed.  It also causes the
                //error character (checkerboard) to be displayed.
                break;

            case 0177:
                //<DEL>; 0177; Ignored on input; not stored in buffer.
                break;
                
            case '~':
                // optimization to detect ~~Begin TelXFer signature 
                ++ptrm->cTilde;
                // fall through 

            default:

Fall_Through:
                
                if ( ptrm->dwCurChar >= ui.dwMaxCol )
                {
                    ptrm->dwCurChar = 0;
                    FlushBuffer( pwi, ptrm );
                    NewLine( pwi, ptrm );
                    ptrm->fLongLine = TRUE;

                    if( !FIsVTWrap( ptrm )) 
                    {
                        ptrm->fFlushToEOL = TRUE;
                    }
                }

                if( ptrm->fFlushToEOL )
                {
                    break;
                }
                ptrm->fLongLine = FALSE;

                if( ptrm->cchBufferText == 0 )
                {
                    SetBufferStart( ptrm );
                }

                if( FAddCharToBuffer( ptrm, ptrm->puchCharSet[*pchT] )) 
                {
                    FlushBuffer( pwi, ptrm );
                }
                /* For FE Incremantation was done in FAddCharToBuffer() */
                if (!(FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80)))
                   ( ptrm->dwCurChar) ++ ;

                break;
            }
            break;


    case 1: /* ESC entered, wait for [ */

            //If there is some data to be flushed
            if( ptrm->cchBufferText != 0 )
            {
                FlushBuffer(pwi, ptrm);
            }

            if (((*pchT) != '[') && ((*pchT) != '#'))
                    ptrm->fEsc = 0;

            switch (*pchT)
            {
            case '1': 
                break;
            
            case '2':
                break;

            case '7':
                //
                // DECSC
                // Save cursor position, origin mode etc.
                //
                //DECSC   Save Cursor (DEC Private)  
                
                //<ESC>7

                //Causes the cursor position, graphic rendition, and character 
                //set to be saved.  (See DECRC)

                GetConsoleScreenBufferInfo( gwi.hOutput, &consoleBufferInfo ); 

                ptrm->fSavedState = TRUE;
                ptrm->dwSaveChar = ptrm->dwCurChar;
                ptrm->dwSaveLine = ptrm->dwCurLine;
                ptrm->dwSaveRelCursor = ptrm->fRelCursor;
                ptrm->pSaveUchCharSet = ptrm->puchCharSet;
                ptrm->iSaveCurrCharSet = ptrm->currCharSet;
                ptrm->cSaveG0 = ptrm->G0;
                ptrm->cSaveG1 = ptrm->G1;
                ptrm->dwSaveIndexOfGraphicRendition = 
                    ptrm->dwIndexOfGraphicRendition;
                for( i=0; ( WORD) i<= ptrm->dwSaveIndexOfGraphicRendition; i++ )
                {
                    ptrm->rgdwSaveGraphicRendition[i] = 
                        ptrm->rgdwGraphicRendition[i];
                }

                break;

            case '8':
                //
                // DECRC
                // Restore cursor position, etc. from DECSC

                //DECRC   Restore Cursor (DEC Private) 

                //<ESC>8
                //This sequence causes the previously saved cursor position, 
                //graphic rendition, and character set to be restored.
                //

                //Restore charset 
                if( ptrm->pSaveUchCharSet )
                {
                    ptrm->puchCharSet = ptrm->pSaveUchCharSet;
                    ptrm->currCharSet = ptrm->iSaveCurrCharSet;
                    ptrm->G0 = ptrm->cSaveG0;
                    ptrm->G1 = ptrm->cSaveG1;
                }
                
                //Restore Graphic rendition
                {
                    BOOL fNeedToRestore = 0;
                    if( ptrm->dwSaveIndexOfGraphicRendition != 
                            ptrm->dwIndexOfGraphicRendition )
                    {
                        fNeedToRestore = 1;
                    }
                    for( i=0; ( WORD )i<= ptrm->dwSaveIndexOfGraphicRendition && 
                            !fNeedToRestore; i++ )
                    {
                        if( ptrm->rgdwSaveGraphicRendition[i] != 
                                ptrm->rgdwGraphicRendition[i] )
                        {
                            fNeedToRestore = 1;
                        }
                    }
                    if( fNeedToRestore )
                    {
                        SetGraphicRendition( pwi, ptrm, 
                                ptrm->dwSaveIndexOfGraphicRendition, 
                                ptrm->rgdwSaveGraphicRendition );
                    }
                }
                
                //Restore Cursor position
                SetConsoleWindowInfo( gwi.hOutput, TRUE, &(consoleBufferInfo.
                                srWindow ) );

                if( ptrm->fSavedState == FALSE )
                {
                    ptrm->dwCurChar = 1;
                    ptrm->dwCurLine = ( ptrm->fRelCursor )
                        ? ptrm->dwScrollTop : 0;
                    break;
                }
                ptrm->dwCurChar = ptrm->dwSaveChar;
                ptrm->dwCurLine = ptrm->dwSaveLine;
                ptrm->fRelCursor = ( BOOL ) ( ptrm->dwSaveRelCursor );
                break;

            case '[':
                // VT102 - CSI Control Sequence Introducer 
                ptrm->fEsc = 2;
                ptrm->dwEscCodes[0] = 0xFFFFFFFF;
                ptrm->dwEscCodes[1] = 0xFFFFFFFF;
                ptrm->cEscParams = 0;
                ptrm->dwSum = 0xFFFFFFFF;
                dwDECMode = FALSE;
                break;

            case '#':
                ptrm->fEsc = 3;
                break;

            case 'A':
                if( FIsVT52( ptrm ) )
                {
                    // VT52 - Cursor up 
                    ptrm->dwEscCodes[0] = 1;
                    CursorUp( ptrm );
                }
                break;

            case 'B':
                if( FIsVT52( ptrm ) )
                {
                    // VT52 - Cursor down 
                    ptrm->dwEscCodes[0] = 1;
                    CursorDown( ptrm );
                }
                break;

            case 'C':
                if( FIsVT52(ptrm) )
                {
                    // VT52 - Cursor right 
                    ptrm->dwEscCodes[0] = 1;
                    CursorRight( ptrm );
                }
                break;

            case 'D':
                if( FIsVT52(ptrm) )
                {
                    // VT52 - Cursor left 
                    ptrm->dwEscCodes[0] = 1;
                    CursorLeft( ptrm );
                }
                else
                {
                    //VT102 - IND, Index cursor down 1 line, can scroll 
                    //IND     Index       

                    //<ESC>D

                    //This sequence causes the cursor to move downward one line
                    //without changing the column.  If the cursor is at the 
                    //bottom margin, a scroll up is performed.  Format Effector.

                    NewLine( pwi, ptrm );
                }
                break;

            case 'E': // Next Line  ; cr/lf
                //
                // VT102 - NEL, New Line
                // cursor to start of line below, can scroll
                //
                //NEL     Next Line 
                
                //<ESC>E

                //This causes the cursor to move to the first position of the 
                //next line down.  If the cursor is on the bottom line, a scroll
                //is performed. Format Effector.

                ptrm->dwCurChar = 0;
                NewLine( pwi, ptrm );
                break;

            case 'F':
                // VT52 - Enter graphics mode ; alternate graphics character set
                if( FIsVT52( ptrm ) )
                {
                    SetVT52Graphics( ptrm );
                if (FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80))
                    SetCharSet(ptrm,GRAPHIC_LEFT,rgchGraphicsChars);
                else    
                    ptrm->puchCharSet = rgchAlternateChars;
                }
                break;

            case 'G':
                // VT52 - Exit graphics mode ; ASCII character set
                if( FIsVT52( ptrm ))
                {
                    ClearVT52Graphics( ptrm );
                if (FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80))
                    SetCharSet(ptrm,GRAPHIC_LEFT,rgchIBMAnsiChars);
                else
                    ptrm->puchCharSet = rgchNormalChars;
                }
                break;

            case 'H':
                if ( (FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80)) && ( FIsVT80(ptrm) && FIsNECKanji(ptrm) ) )
                    {
                        /* NEC Kanji OUT (JIS Roman to G0(GL)) */
                        ClearKanjiStatus(ptrm,JIS_KANJI_CODE);
                        SetCharSet(ptrm,GRAPHIC_LEFT,rgchJISRomanChars);
                    }
                else
                if( FIsVT52( ptrm ) )
                {
                    // VT52 - Cursor Home 
                    CONSOLE_SCREEN_BUFFER_INFO info;
                    if( !GetConsoleScreenBufferInfo( gwi.hOutput,
                        &info ) )
                    {
                        info.srWindow.Top = 0;
                        info.srWindow.Left = 0;
                    }
                    ptrm->dwCurLine = info.srWindow.Top;
                    ptrm->dwCurChar = info.srWindow.Left;
                }
                else
                {
                    // VT102 - HTS Set Tab Stop 
                    //HTS     Horizontal Tab Set       

                    //<ESC>H

                    //Set a tab stop at the current cursor position.  
                    //Format Effector.
                    
                     if( g_iHTS < MAX_TABSTOPS )
                     {
                        g_rgdwHTS[ g_iHTS++ ] = ptrm->dwCurChar;
                     }
                    
                }
                break;

            case 'I':
                if ( FIsVT52(ptrm) )
                {
                    // VT52 - Reverse linefeed 
                    NewLineUp( pwi, ptrm );
                }
                break;

            case 'J':
                if( FIsVT52( ptrm ))
                {
                    // VT52 - Clears to end of screen 
                    ClearScreen( pwi, ptrm, fdwCursorToEOS );
                }
                break;

            case 'K':
                if ((FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80)) && FIsVT80(ptrm) && FIsNECKanji(ptrm) )
                    {
                        /* NEC Kanji IN (Kanji to G0(GL)) */
                        SetKanjiStatus(ptrm,JIS_KANJI_CODE);
                        SetCharSet(ptrm,GRAPHIC_LEFT,rgchJISKanjiChars);
                    }
                else
                if( FIsVT52( ptrm ))
                {
                    // VT52 - Erases to end of line 
                    ClearLine( pwi, ptrm, fdwCursorToEOL );
                }
                break;

            case 'M':
                // VT102 - RI Reverse Index, cursor up 1 line, can scroll 

                //RI      Reverse Index       

                //<ESC>M

                //Move the cursor up one line without changing columns.  If the
                //cursor is on the top line, a scroll down is performed.


                NewLineUp( pwi, ptrm );
                break;

            case 'N':
                if ((FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80)))
                    {
                    if(FIsVT80(ptrm)) {
                        if( !(GetKanjiStatus(ptrm) & JIS_KANJI_CODE) &&
                            (FIsJISKanji(ptrm) || FIsJIS78Kanji(ptrm) ||
                            FIsEUCKanji(ptrm) || FIsDECKanji(ptrm)      ) ) {
                            PushCharSet(ptrm,GRAPHIC_LEFT,ptrm->g2);
                            PushCharSet(ptrm,GRAPHIC_RIGHT,ptrm->g2);
                            SetKanjiStatus(ptrm,SINGLE_SHIFT_2);
#ifdef DEBUG
                            wsprintf(rgchDbgBfr,"VT80 EUC/DEC/JIS SS2 Mode Enter\n");
                            OutputDebugString(rgchDbgBfr);
#endif /* DEBUG */
                        }
                    }
                    }
                break;
            case 'O':
                if ((FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80)))
                    {
                    if(FIsVT80(ptrm)) {
                        if( !(GetKanjiStatus(ptrm) & JIS_KANJI_CODE) &&
                            (FIsJISKanji(ptrm) || FIsJIS78Kanji(ptrm) ||
                            FIsEUCKanji(ptrm) || FIsDECKanji(ptrm)      ) ) {
                            PushCharSet(ptrm,GRAPHIC_LEFT,ptrm->g3);
                            PushCharSet(ptrm,GRAPHIC_RIGHT,ptrm->g3);
                            SetKanjiStatus(ptrm,SINGLE_SHIFT_3);
#ifdef DEBUG
                            wsprintf(rgchDbgBfr,"VT80 EUC/DEC/JIS SS3 Mode Enter\n");
                            OutputDebugString(rgchDbgBfr);
#endif /* DEBUG */
                        }
                    }
                    }
                    break;

            case 'Y':
                if ( FIsVT52(ptrm) )
                {
                    // VT52 - direct cursor address 
                    if(( ich + 3 ) <= cbTermOut )
                    {
                        DWORD dwNewLine = ptrm->dwCurLine;
                        dwNewLine = ( pchT[1] > 31 ) ? pchT[1]-32 : 0;
                        if (dwNewLine != ptrm->dwCurLine)
                        {
                            WriteToLog(ptrm->dwCurLine);
                        }
                        ptrm->dwCurLine = dwNewLine;
                        ptrm->dwCurChar = ( pchT[2] > 31 ) ? pchT[2]-32 : 0;
                        {
                            CONSOLE_SCREEN_BUFFER_INFO info;
                            if( !GetConsoleScreenBufferInfo( gwi.hOutput,
                                &info ) )
                            {
                                info.srWindow.Top = 0;
                                info.srWindow.Left = 0;
                            }
                            ptrm->dwCurLine += info.srWindow.Top;
                            ptrm->dwCurChar += info.srWindow.Left;
                        }


                        ich += 2;
                        pchT += 2;
                    }
                    else
                    {
                        ptrm->fEsc = 4;
                        ptrm->dwEscCodes[0] = 0xFFFFFFFF;
                        ptrm->dwEscCodes[1] = 0xFFFFFFFF;
                        ptrm->cEscParams = 0;
                    }
                }
                break;

            case 'Z':
                //DECID   Identify Terminal (DEC Private)
                
                //<ESC>Z

                //This sequence causes the same response as the DA sequence.
                //This sequence will not be supported in future models.

                if( !FIsVT52(ptrm) )
                {

                if ((FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80)) && ( FIsVT80(ptrm) ))
                    {
                        /* VT80 - DECID Identify terminal */
                        pchNBBuffer[0] = 0x1B;
                        pchNBBuffer[1] = '[';
                        pchNBBuffer[2] = '?';
                        pchNBBuffer[3] = '1';
                        pchNBBuffer[4] = '8';
                        pchNBBuffer[5] = ';';
                        pchNBBuffer[6] = '2';
                        pchNBBuffer[7] = 'c';
                        i = 8;
                    }
                    else
                    {
                    // VT102 - DECID Identify terminal 
                    pchNBBuffer[0] = 0x1B;
                    pchNBBuffer[1] = '[';
                    pchNBBuffer[2] = '?';
                    pchNBBuffer[3] = '1';
                    pchNBBuffer[4] = ';';
                    pchNBBuffer[5] = '0';
                    pchNBBuffer[6] = 'c';
                    i = 7;
                    }
                }
                else
                {
                    // VT52 - Identify terminal 
                    pchNBBuffer[0] = 0x1B;
                    pchNBBuffer[1] = '/';
                    pchNBBuffer[2] = 'Z';
                    i = 3;
                }
                ( void ) FWriteToNet( pwi, ( LPSTR ) pchNBBuffer, ( int ) i );
                break;

            case 'c':
                // VT102 RIS Hard reset, reset term to initial state 

                //RIS     Reset to Initial State        
                
                //<ESC>c

                //Resets the VT100 to the state is has upon power up.  This also
                //causes the execution of the POST and signal INT H to be
                //asserted briefly.

                FlushBuffer( pwi, ptrm );
    
    			DoTermReset( pwi, ptrm );

                
                break;

            case '=':
                // VT102 - DECKPAM Enter numeric keypad app mode 

                //DECKPAM Keypad Application Mode (DEC Private)   
                
                //<ESC>=

                //The auxiliary keypad keys will transmit control sequences.

                ClearVTKeypad( ptrm );
                break;

            case '>':
                // VT102 - DECKNPNM Enter numeric keypad numeric mode 

                //DECKPNM Keypad Numeric Mode (DEC Private)        

                //<ESC> >

                //The auxiliary keypad keys will send ASCII codes corresponding
                //to the characters engraved on their keys.

                SetVTKeypad( ptrm );
                break;

            case '<':
                // ENTER - ANSI Mode if in VT52. 
                if( FIsVT52(ptrm) )
                {
                    SetANSI(ptrm);
                }
                break;

            case '(':
                if (FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80))
                    {
                     if ( FIsVT80(ptrm) &&
                        (FIsJISKanji(ptrm) || FIsJIS78Kanji(ptrm))) {
                        // SetKanjiStatus(ptrm,JIS_INVOKE_MB);
                        ptrm->fEsc = 5;
                     }
                    break;
                     } 
                else
                    {
                        ++ich;
                        ++pchT;
                        ptrm->G0 = *pchT;
                        break;
                    }

            case '$':
                if (FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80))
                    {
           
                    if ( FIsVT80(ptrm) &&
                        (FIsJISKanji(ptrm) || FIsJIS78Kanji(ptrm))) {
                        // SetKanjiStatus(ptrm,JIS_INVOKE_SB);
                        ptrm->fEsc = 6;
#if DEBUG
                        _snwprintf(rgchDbgBfr,sizeof(rgchDbgBfr)-1,"VT80 JIS MB Invoke Enter\n");
                        OutputDebugString(rgchDbgBfr);
#endif /* DEBUG */
                    }
                   } 
                break;

            case ')':
                
                // VT102 SCS 
                //SCS     Select Character Set
                //The appropriate D0 and G1 character sets are 
                //designated from one of the five possible sets.  The G0
                //and G1 sets are invokedd by the characters <SI> and
                //<SO>, respectively.
                //G0 Sets         G1 Sets
                //Sequence        Sequence      Meaning
                //------------------------------------------------------
                //<ESC>(A         <ESC>)A       United Kingdom Set
                //<ESC>(B         <ESC>)B       ASCII Set
                //<ESC>(0         <ESC>)0       Special Graphics
                //<ESC>(1         <ESC>)1       Alternate Character ROM
                //                              Standard Character Set
                //<ESC>(2         <ESC>)2       Alternate Character ROM
                //                              Special Graphics
                //
                //
                //The United Kingdom and ASCII sets conform to the "ISO 
                //international register of character sets to be used 
                //with escape sequences".  The other sets are private 
                //character sets.  Special graphics means that the 
                //graphic characters fpr the codes 0137 to 0176 are 
                //replaced with other characters.  The specified 
                //character set will be used until another SCS is 
                //recieved.


                ++ich;
                ++pchT;
                ptrm->G1 = *pchT;
                break;

            case '%':
                break;

            case '~':
                if (FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80))
                    {
                    if(FIsVT80(ptrm)) {
                        SetCharSet(ptrm,GRAPHIC_RIGHT,ptrm->g1);
                    }
                    }
                else
                    break;

            default:
                // Is if a form feed? 
                if( *pchT == 12 )
                {
                    ptrm->dwCurChar = ptrm->dwCurLine = 0;
                    ClearScreen( pwi, ptrm, fdwCursorToEOS );
                }
                break;

            }
            break;



        case 2: // ESC [ entered 
            /*
             * HACK: Handle the problem where a number has been read
             * and then a letter. The number won't be in the dwEscCodes[]
             * since only on a ';' does it get put in there.
             * So, check to see if we have a character which
             * signifies an Control Sequence,
             * i.e. !(0...9) && !'?' && !';'
             *
             * Also, zero out the following element in the dwEscCodes[]
             * array to be safe.
             */
            if( ! (( '0' <= *pchT ) && ( *pchT <= '9' )) && 
                ( *pchT != '?' ) && ( *pchT != ';' ))
            {
                if( ptrm->dwSum == 0xFFFFFFFF )
                {
                    ptrm->dwSum = 0;
                }

                ptrm->dwEscCodes[ptrm->cEscParams++] = ptrm->dwSum;

                if( ptrm->cEscParams < 10 )
                {
                    ptrm->dwEscCodes[ptrm->cEscParams] = 0;
                }
            }

            switch( *pchT )
            {
            case 0x08:      // Backspace 
                if( ptrm->dwCurChar > 0 )
                {
                    --ptrm->dwCurChar;
                }
                break;

            case '\n': //Line Feed 
                //<LF>; 0012; Causes either a line feed or new line operation 
                //(See new line mode.)

                if( ptrm->fFlushToEOL ) 
                {
                    ptrm->fLongLine = FALSE;
                    ptrm->fFlushToEOL = FALSE;
                    break;
                }
                if( ptrm->fLongLine )
                {
                    ptrm->fLongLine = FALSE;
                    break;
                }
                FlushBuffer( pwi, ptrm );
                NewLine( pwi, ptrm );
                break;

            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                if( ptrm->dwSum == 0xFFFFFFFF )
                {
                    ptrm->dwSum = ( *pchT ) - '0';
                }
                else
                {
                    ptrm->dwSum = ( 10 * ptrm->dwSum ) + ( *pchT ) - '0';
                }
                break;

                    /////////////////////////////////////////////////////
                    // Hack for FTCU machine
                    // 'Eat' the Esc?7h escape sequence emitted from FTCU
                    /////////////////////////////////////////////////////
            case '?':
                    // Sets or resets DEC mode 
                    dwDECMode = TRUE;
                    break;

            case ';':

                if( ptrm->cEscParams < 9 )
                {
                    ptrm->dwEscCodes[ptrm->cEscParams++] = ptrm->dwSum;
                    ptrm->dwEscCodes[ptrm->cEscParams] = 0xFFFFFFFF;
                    ptrm->dwSum = 0xFFFFFFFF;
                    break;
                }
                break;

            case 'A':   // VT102 CUU cursor up 
                //CUU   Cursor Up       Host to VT100 & VT100 to Host

                //      <ESC>[ {Pn} A   Default Value: 1

                //Moves the cursor up without changing columns. The cursor is 
                //moved up a number of lines as indicated by the parameter. The
                //cursor cannot be moved beyond the top margin.  Editor Function.

                CursorUp( ptrm );
                break;

            case 'B':   // VT102 CUD cursor down 
            case 'e':
                //CUD   Cursor Down         Host to VT100 & VT100 to Host

                //      <ESC>[ {Pn} B       Default value: 1

                //Moves the cursor down a number of lines as specified in the
                //parameter without changing columns.  The cursor cannot be 
                //moved past the bottom margin.  Editor Function.
            
                CursorDown( ptrm );
                break;

            case 'C':   // VT102 CUF cursor right 
            case 'a':
                //CUF   Cursor Forward         Host to VT100 & VT100 to Host

                //      <ESC>[ {Pn} C                   Default Value: 1

                //The CUF sequence moves the cursor to the right a number of
                //positions specified in the parameter.  The cursor cannot be
                //moved past the right margin.  Editor Function.

            
                CursorRight( ptrm );
                break;

            case 'D':   // VT102 CUB cursor left 
                //CUB     Cursor Backward       Host to VT100 & VT100 to Host

                //         <ESC>[ {Pn} D        Default Value: 1
                
                //The CUB sequence move the cursor to the left.  The distance
                //moved is determined by the parameter.  If the parameter 
                //missing, zero, or one,the cursor is moved one position. 
                //The cursor cannot be moved past the left margin. 
                //Editor Function.

                CursorLeft( ptrm );
                break;
            
            case 'E':   // Move cursor to beginning of line, p lines down.
                
                break;

            case 'F':   // Move active position to beginning of line, p lines up
                
                break;
            
            case '`':   // move cursor to column p
            case 'G':

                break;

            case 'H':   // VT102 CUP position cursor 
                //HVP     Horizontal and Vertical Position        

                //<ESC>[ {Pn} ; {Pn} f

                //Moves the cursor to the position specified by the parameters.
                //The first parameter specifies the line, and the second 
                //specifies the column.  A parameter of 0 or 1 causes the active
                //position to move to the first line or column in the display.  
                //In the VT100, this control behaves identically with it's editor
                //counterpart, CUP.  The numbering of the lines depends upon the
                //state of the Origin Mode (DECOM).  Format Effector.

            case 'f':   // VT102 HVP position cursor 

                //CUP   Cursor Position         

                //<ESC>[ {Pn} ; {Pn} H            Default Value: 1

                //The CUP sequence moves the curor to the position specified by
                //the parameters.  The first parameter specifies the line, and 
                //the second specifies the column.  A value of zero for either 
                //line or column moves the cursor to the first line or column in
                //the display.  The default string (<ESC>H) homes the cursor. In
                //the VT100, this command behaves identically to it's format 
                //effector counterpart, HVP.The numbering of the lines depends 
                //upon the state of the Origin Mode (DECOM).  Editor Function.


                if( ptrm->dwEscCodes[0] == 0 )
                {
                    ptrm->dwEscCodes[0] = 1;
                }

                if( ptrm->dwEscCodes[1] == 0 )
                {
                    ptrm->dwEscCodes[1] = 1;
                }

                {
                    DWORD dwNewLine = 0;
                    CONSOLE_SCREEN_BUFFER_INFO info;

                    if( !GetConsoleScreenBufferInfo( gwi.hOutput, 
                        &info ) )
                    {
                        info.srWindow.Top = 0;
                        info.srWindow.Left = 0;
                    }
                    dwNewLine = info.srWindow.Top +
                                        ( ptrm->dwEscCodes[0] - 1 );
                    ptrm->dwCurChar = info.srWindow.Left +
                                    ( ptrm->dwEscCodes[1] - 1 );

                    if( ( SHORT )ptrm->dwCurChar >=  info.srWindow.Right )
                    {
                        ptrm->dwCurChar = info.srWindow.Right;
                    }

                    if( ( SHORT )dwNewLine >= info.srWindow.Bottom  )
                    {
                        dwNewLine = info.srWindow.Bottom;
                    }

                    if( ui.bLogging && dwNewLine != ptrm->dwCurLine )
                    {
                        WriteToLog( ptrm->dwCurLine );
                    }

                    ptrm->dwCurLine = dwNewLine;

                }


                if(( ptrm->fRelCursor == TRUE ) && ( ptrm->dwCurLine < ptrm->dwScrollTop ))
                {
                    ptrm->dwCurLine = ptrm->dwScrollTop;
                }
                if ((ptrm->fRelCursor == TRUE) && (ptrm->dwCurLine >= ptrm->dwScrollBottom))
                {
                    ptrm->dwCurLine = ptrm->dwScrollBottom - 1;
                }

                ptrm->fEsc = 0;
                ptrm->fFlushToEOL = FALSE;
                ptrm->fLongLine = FALSE;
                break;

            case 'J':       // VT102 ED erase display 

                //ED      Erase in Display

                //<ESC>[ {Ps} J         Default: 0

                //This sequence erases some or all of the characters in the 
                //display according to the parameter.  Any complete line erased
                //by this sequence will return that line to single width mode.  
                //Editor Function.

                //Parameter    Meaning
                //-------------------------------------------------------------
                //    0        Erase from the cursor to the end of the screen.
                //    1        Erase from the start of the screen to the cursor.
                //    2        Erase the entire screen.

                ClearScreen( pwi, ptrm, ptrm->dwEscCodes[0] );
                break;


            case 'K':       // VT102 EL erase line 
                //EL      Erase in Line

                //<ESC>[ {Ps} K                                   Default: 0

                //Erases some or all characters in the active line, according to
                //the parameter.  Editor Function.     

                //Parameter       Meaning
                //-------------------------------------------------------------
                //0               Erase from cursor to the end of the line.
                //1               Erase from the start of the line to the cursor.
                //2               Erase the entire line.

                ClearLine( pwi, ptrm, ptrm->dwEscCodes[0] );
                break;

            case 'L':       // VT102 IL insert lines 
            {
                int j;
                if( ptrm->dwEscCodes[0] == 0 )
                {
                    ptrm->dwEscCodes[0] = 1;
                }
                
                for( j = 0 ; ( WORD )j < ptrm->dwEscCodes[0]; j++ )
                {
                    InsertLine( pwi, ptrm, ptrm->dwCurLine );
                }

                ptrm->fEsc = 0;
                break;
            }
            case 'M':       // VT102 DL delete line 
            {
                int j;

                if( ptrm->dwEscCodes[0] == 0 )
                {
                    ptrm->dwEscCodes[0] = 1;
                }

                //DeleteLines( pwi, ptrm, ptrm->dwCurLine, ptrm->dwEscCodes[0] );
                for( j = 0 ; ( WORD )j < ptrm->dwEscCodes[0]; j++ )
                {
                    DeleteLine( pwi, ptrm, ptrm->dwCurLine );
                }


                ptrm->fEsc = 0;

                break;
            }
            case '@':       // VT102 ICH? insert characters 
                if( ptrm->dwEscCodes[0] == 0 )
                {
                        ptrm->dwEscCodes[0] = 1;
                }
                
                if( ptrm->dwEscCodes[0] > ( ui.dwMaxCol - ptrm->dwCurChar ))
                {
                    ptrm->dwEscCodes[0] = ui.dwMaxCol - ptrm->dwCurChar;
                }

                i = ptrm->dwCurChar+ptrm->dwEscCodes[0];

                if(( ui.dwMaxCol-i ) > 0 )
                {
                    SMALL_RECT  lineRect;
                    COORD       dwDest;

                    // Form a rectangle for the line.
                    lineRect.Bottom = ( short ) ptrm->dwCurLine;
                    lineRect.Top = ( short ) ptrm->dwCurLine;
                    lineRect.Left = ( short ) ptrm->dwCurChar; 
                    lineRect.Right = ( short ) ( ui.dwMaxCol );
                    
                    // Destination is one character to the right.
                    dwDest.X = ( short ) (i);
                    dwDest.Y = ( short ) ptrm->dwCurLine;

                    pwi->cinfo.Attributes = pwi->sbi.wAttributes;
                    ScrollConsoleScreenBuffer( pwi->hOutput, &lineRect, NULL, dwDest, &pwi->cinfo );
                }

                if( ui.bLogging )
                {
                    WriteToLog( ptrm->dwCurLine );
                }

                ptrm->fEsc = 0;
                break;

            case 'P':       // VT102 DCH delete chars 
                if( ptrm->dwEscCodes[0] == 0 )
                {
                    ptrm->dwEscCodes[0] = 1;
                }
                if( ptrm->dwEscCodes[0] > ( ui.dwMaxCol-ptrm->dwCurChar ))
                {
                    ptrm->dwEscCodes[0] = ui.dwMaxCol-ptrm->dwCurChar;
                }

                if(( ui.dwMaxCol - ptrm->dwCurChar - 1) > 0 )
                {
                    SMALL_RECT lineRect;
                    COORD      dwDest;
                    SMALL_RECT clipRect;

                    // Form a rectangle for the line.
                    lineRect.Bottom = ( short ) ptrm->dwCurLine;
                    lineRect.Top = ( short ) ptrm->dwCurLine;
                    lineRect.Left = ( short ) ptrm->dwCurChar; 
                    lineRect.Right = ( short )( ui.dwMaxCol );
                    
                    clipRect = lineRect;

                    // Destination is one character to the right.
                    dwDest.X = ( short ) ( ptrm->dwCurChar - ptrm->dwEscCodes[0] );
                    dwDest.Y = ( short ) ptrm->dwCurLine;

                    pwi->cinfo.Attributes = pwi->sbi.wAttributes;
                    ScrollConsoleScreenBuffer( pwi->hOutput, &lineRect, &clipRect, dwDest, &pwi->cinfo );
                }

                if( ui.bLogging )
                {
                    WriteToLog( ptrm->dwCurLine );
                }

                ptrm->fEsc = 0;
                break;

            case 'S':

                break;

            case 'T':
            
                break;

            case 'X':   // Erase p characters up to the end of line

                break;

            case 'Z':   // move back p tab stops

                break;

            case 'c':       // VT102 DA Same as DECID 

                //DA    Device Attributes       Host to VT100 & VT100 to Host

                //      <ESC>[ {Pn} c           Default Value: 0

                //1) The host requests the VT100 to send a DA sequence to 
                //indentify itself.  This is done by sending the DA sequence
                //with no parameters, or with a parameter of zero.

                //2) Response to the request described above (VT100 to host) is
                //generated by the VT100 as a DA control sequencewith the 
                //numeric parameters as follows: 
                
                //Option Present                  Sequence Sent
                //---------------------------------------------
                //No options                      <ESC>[?1;0c
                //Processor Option (STP)          <ESC>[?1;1c
                //Advanced Video Option (AVO)     <ESC>[?1;2c
                //AVO and STP                     <ESC>[?1;3c
                //Graphics Option (GPO)           <ESC>[?1;4c
                //GPO and STP                     <ESC>[?1;5c
                //GPO and AVO                     <ESC>[?1;6c
                //GPO, ACO, and STP               <ESC>[?1;7c


                pchNBBuffer[0] = 0x1B;
                pchNBBuffer[1] = '[';
                pchNBBuffer[2] = '?';
                pchNBBuffer[3] = '1';
                pchNBBuffer[4] = ';';
                pchNBBuffer[5] = '0';
                pchNBBuffer[6] = 'c';
                i = 7;

                ( void ) FWriteToNet( pwi, ( LPSTR ) pchNBBuffer, ( int ) i );
                ptrm->fEsc = 0;

                break;

            case 'd': // move to line p

                break;

            case 'g':       // VT102 TBC Clear Tabs 
                //TBC     Tabulation Clear     

                //<ESC>[ {Ps} g

                //If the parameter is missing or 0, this will clear the tab stop
                //at the cursor's position.  If it is 3, this will clear all of 
                //the tab stops. Any other parameter is ignored.  Format Effector.

                if( ptrm->dwEscCodes[0] == 3 )
                {
                    // Clear all tabs 
                    g_iHTS = 0; 
                }
                else if( ptrm->dwEscCodes[0] == 0 && g_iHTS )
                {
                    // Clear tab stop at current position 
                    int x=0;
                    while( x < g_iHTS )
                    {
                        if( g_rgdwHTS[ x ] >= ptrm->dwCurChar && 
                            g_rgdwHTS[ x ] != -1 )
                        {
                            if( g_rgdwHTS[ x ] == ptrm->dwCurChar )
                            {
                                g_rgdwHTS[ x ] = ( DWORD )-1; //clear the tab stop
                            }
                            break;
                        }

                        x++;
                    }
                }

                ptrm->fEsc = 0;
                break;

            case 'h':
                //SM      Set Mode     
                
                //<ESC> [ {Ps} ; {Ps} h

                //Causes one or more modes to be set within the VT100 as 
                //specified by each selective parameter string.  Each mode to be
                //set is specified by a seperate parameter.  A mode is 
                //considered set until it is reset by a Reset Mode (RM) control 
                //sequence.  See RM and MODES.

                //[Editor's note: The original DEC VT100 documentation 
                //EK-VT100-UG-003 erroneously omitted the "[" character from the
                //SM sequence.]

                for( i = 0; i < ptrm->cEscParams; ++i )
                {
                    if( dwDECMode == TRUE )
                    {
                        switch( ptrm->dwEscCodes[i] )
                        {       // Field specs 
                        
                        case 0:
                            //Error (ignored)
                            break;

                        case 1: // DECCKM  

                            //DECCKM  Cursor Keys Mode (DEC Private)
                            //This is a private parameter to the SM and RM 
                            //control requences. This mode is only effective 
                            //when the terminal is in keypad application mode
                            //(DECPAM) and the ANSI/VT52 mode (DECANM) is set. 
                            //Under these conditions, if this mode is reset, 
                            //the cursor keys will send ANSI cursor control 
                            //commands.  If setm the cursor keys will send 
                            //application function commands (See MODES, RM,
                            //and SM).

                            /*This is a hack so that in vt100, vi works properly
                             * */
                            {
                                CONSOLE_SCREEN_BUFFER_INFO info;
                                if( !GetConsoleScreenBufferInfo( gwi.hOutput,
                                        &info ) )
                                {
                                    consoleBufferInfo.srWindow.Top = 0;
                                    consoleBufferInfo.srWindow.Bottom = 0;
                                }
                                if( FGetCodeMode(eCodeModeFarEast) )
                                {
                                    SetMargins( ptrm, info.srWindow.Top,
                                            info.srWindow.Bottom );
                                }
                                else
                                {
                                    SetMargins( ptrm, info.srWindow.Top,
                                            info.srWindow.Bottom + 1);
                                }
                            }
                            
                            SetVTArrow( ptrm );
                            break;

                        case 2: // DECANM : ANSI/VT52 

                            //DECANM  ANSI/VT52 Mode (DEC Private)

                            //This is a private parameter to the SM and RM 
                            //control sequences. The reset state causes only 
                            //VT52 compatible escape sequences to be recognized.
                            //The set state causes only ANSI compatible escape 
                            //sequences to be recognized.  See the entries for 
                            //MODES, SM, and RM.


                            SetANSI( ptrm ); //ClearVT52(ptrm);
                            ClearVT52Graphics( ptrm );
                            if (FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80))

                                SetCharSet(ptrm,GRAPHIC_LEFT,rgchIBMAnsiChars);
                            else
                                ptrm->puchCharSet = rgchNormalChars;
                            break;

                        case 3: // DECCOLM : Col = 132 
                            //DECCOLM Column Mode (DEC Private)
                            //This is a private parameter to the SM and RM 
                            //control sequences. The reset state causes an 80
                            //column screen to be used.  The set state causes a 
                            //132 column screen to be used.  See MODES, RM, and
                            //SM.
                        
                            SetDECCOLM(ptrm);

                            GetConsoleScreenBufferInfo( gwi.hOutput, 
                                    &consoleBufferInfo );
                            consoleBufferInfo.srWindow.Right = 131;
                            dwSize.X = 132;
                            dwSize.Y = consoleBufferInfo.dwSize.Y;
                            dwMaximumWindowSize = 
                                GetLargestConsoleWindowSize( gwi.hOutput );
                            if( 131 > dwMaximumWindowSize.X )
                            {
                                consoleBufferInfo.srWindow.Right = 
                                     ( SHORT )( dwMaximumWindowSize.X - 1 - 
                                    consoleBufferInfo.srWindow.Left );
                            }
                            if( consoleBufferInfo.dwSize.X <= 132 )
                            {
                                SetConsoleScreenBufferSize( gwi.hOutput,
                                    dwSize );
                                SetConsoleWindowInfo( gwi.hOutput, TRUE, 
                                    &(consoleBufferInfo.srWindow) );  
                            }
                            else
                            {
                                SetConsoleWindowInfo( gwi.hOutput, TRUE, 
                                    &(consoleBufferInfo.srWindow) ); 
                                SetConsoleScreenBufferSize( gwi.hOutput,
                                    dwSize );
                            }
                            //update global data structures
                            ui.dwMaxCol = 132;
                            gwi.sbi.dwSize.X = 132;
                            consoleBufferInfo.dwSize.X = 132;

                            ClearScreen( pwi, ptrm, fdwEntireScreen );
                            break;

                        case 4: // DECSCLM : smooth scroll
                            // Scrolling Mode (DEC Private)
                            // This is a private parameter to RM and 
                            // SM control sequences.  The reset
                            // state causes scrolls to "jump" 
                            // instantaneuously one line at a time.
                            // The set state causes the scrolls to be
                            // "smooth", and scrolls at a maximum rate 
                            // of siz lines/sec.  See MODES, RM, and SM.
                            
                            break;

                        case 5: // DECSCNM : Light background
                            //DECSCNM Screen Mode (DEC Private)
                            //This is a private parameter to RM and SM 
                            //control sequences.  The reset state causes 
                            //the screen to be black with white 
                            //characters; the set state causes the 
                            //screen to be white with black characters.
                            //See MODES, RM, and SM.
                            
                            if( FIsDECSCNM( ptrm ) )
                            {
                                break;
                            }
                            SetDECSCNM( ptrm );

                            SetLightBackground( pwi );
                            break;

                        case 6: // DECOM : Relative origin ; stay in margin
                            //DECOM   Origin Mode (DEC Private)
                            //This is a private parameter to SM and RM control
                            //sequences. The reset state causes the origin (or 
                            //home position) to be the upper left character 
                            //position of the screen.  Line and column numbers
                            //are, therefore, independent of current margin 
                            //settings.  The cursor may be positioned outside 
                            //the margins with a cursor position (CUP) or
                            //horizontal and vertical position (HVP) control.

                            //The set state causes the origin to be at the upper
                            //left character position within the current margins. 
                            //Line and column numbers are, therefore, relative 
                            //to the current margin settings.  The cursor cannot
                            //be positioned outside of the margins.

                            //The cursor is moved to the new home position when 
                            //this mode is set or reset.  Lines and columns are 
                            //numbered consecutively, with the origin being 
                            //line 1, column 1.

                            ptrm->fRelCursor = TRUE;
                            ptrm->dwCurChar = 0;
                            ptrm->dwCurLine = ptrm->dwScrollTop;

                            break;

                        case 7: // DECAWM 

                            //DECAWM  Autowrap Mode (DEC Private)
                            //This is a private parameter to the SM and RM
                            //control sequences. The reset state prevents the
                            //cursor from moving when characters are recieved 
                            //while at the right margin.  The set state causes
                            //these characters to advance to the next line, 
                            //causing a scroll up if required and permitted.  
                            //See MODES, SM, and RM.

                            SetVTWrap( ptrm );
                            break;

                        case 8: // DECARM : auto-repeat keys

                            //DECARM  Auto Repeat Mode (DEC Private)
                            //This is a private parameter to the SM and RM 
                            //control sequences. The reset state causes no 
                            //keyboard keys to auto-repeat, the set state
                            //causes most of them to.  See MODES, SM, and RM.

                            break;

                        case 9: // DECINLM 
                            //DECINLM Interlace Mode (DEC Private)

                            //This is a private parameter to the RM and SM 
                            //control sequences.  The reset state 
                            //(non-interlace) causes the video processor to 
                            //display 240 scan lines per frame.  The set state 
                            //causes the video processor to display 480 scan 
                            //lines per screen.  See MODES, RM, and SM.

                            break;

                        case 18: // Send FF to printer
                            break;

                        case 19: // Entire screen legal for printer
                            break;

                        case 25: // Visible cursor
                            break;

                        case 66: // Application numeric keypad
                            break;
            
                        default:
                            break;
                        }
                    }
                    else
                    {
                        switch( ptrm->dwEscCodes[i] )
                        {
                        case 0:
                            // Error (Ignored)
                            break;

                        case 2: // Keyboard locked 
                            SetKeyLock( ptrm );
                            break;

                        case 3: // act on control codes
                            break;

                        case 4: // Ansi insert mode  
                            SetInsertMode( ptrm );
                            break;

                        case 12: // Local echo off
                            break;

                        case 20: // Ansi linefeed mode ; Newline sends cr/lf
                            //LNM     Line Feed/New Line Mode
                            //This is a parameter to SM and RM control sequences.
                            //The reset state causes the interpretation of the 
                            //<LF> character to imply only vertical movement of 
                            //the cursor and causes the RETURN key to send the 
                            //single code <CR>.  The set state causes the <LF>
                            //character to imply movement to the first position
                            //of the following line, and causes the RETURN key
                            //to send the code pair <CR><LF>.  This is the New 
                            //Line option.

                            //This mode does not affect the Index (IND) or the 
                            //next line (NEL) format effectors.

                            SetLineMode( ptrm );
                            break;

                        default:
                            break;
                        }
                    }
                }

                ptrm->fEsc = 0;
                break;

            case 'l':       // Reset Mode ( unset extended mode )
                //RM      Reset Mode        

                //<ESC>[ {Ps} ; {Ps} l

                //Resets one or more VT100 modes as specified by each selective
                //parameter in the parameter string.  Each mode to be reset is 
                //specified by a separate parameter.  See MODES and SM.
                
                for( i = 0; i < ptrm->cEscParams; ++i )
                {
                    if( dwDECMode == TRUE )
                    {
                        switch( ptrm->dwEscCodes[i] )
                        {       // Field specs 
                        case 0:
                            //Error (Ignored)
                            break;

                        case 1: // DECCKM  : numeric cursor keys
                            //DECCKM  Cursor Keys Mode (DEC Private)
                            //This is a private parameter to the SM and RM 
                            //control requences. This mode is only effective 
                            //when the terminal is in keypad application mode
                            //(DECPAM) and the ANSI/VT52 mode (DECANM) is set. 
                            //Under these conditions, if this mode is reset, 
                            //the cursor keys will send ANSI cursor control 
                            //commands.  If setm the cursor keys will send 
                            //application function commands (See MODES, RM,
                            //and SM).

                            /* This is a hack so that you will scroll even after
                             * coming out of vi in vt100.
                             * In vt100, vi sets scroll regions. but does not
                             * reset when vi is exited */
                            {
                                CONSOLE_SCREEN_BUFFER_INFO info;
                                if( !GetConsoleScreenBufferInfo( gwi.hOutput,
                                        &info ) )
                                {
                                    consoleBufferInfo.dwSize.Y = 0;
                                }

                                SetMargins( ptrm, 1, info.dwSize.Y );
                            }

                            ClearVTArrow( ptrm );
                            break;

                        case 2: // DECANM : ANSI/VT52
                            //DECANM  ANSI/VT52 Mode (DEC Private)

                            //This is a private parameter to the SM and RM 
                            //control sequences. The reset state causes only 
                            //VT52 compatible escape sequences to be recognized.
                            //The set state causes only ANSI compatible escape 
                            //sequences to be recognized.  See the entries for 
                            //MODES, SM, and RM.

                            SetVT52( ptrm );
                            ClearVT52Graphics( ptrm );
                            break;

                        case 3: // DECCOLM : 80 col 
                            //DECCOLM Column Mode (DEC Private)
                            //This is a private parameter to the SM and RM 
                            //control sequences. The reset state causes an 80
                            //column screen to be used.  The set state causes a 
                            //132 column screen to be used.  See MODES, RM, and
                            //SM.
                        
                            ClearDECCOLM( ptrm );
                            
                            GetConsoleScreenBufferInfo( gwi.hOutput, 
                                    &consoleBufferInfo );
                            consoleBufferInfo.srWindow.Right = 79;
                            dwMaximumWindowSize = 
                                GetLargestConsoleWindowSize( gwi.hOutput );
                            if( 79 > dwMaximumWindowSize.X )
                            {
                                consoleBufferInfo.srWindow.Right = 
                                    ( SHORT ) ( dwMaximumWindowSize.X - 1 - 
                                    consoleBufferInfo.srWindow.Left );
                            }
                            dwSize.X = 80;
                            dwSize.Y = consoleBufferInfo.dwSize.Y;
                            if( consoleBufferInfo.dwSize.X <= 80 )
                            {
                                SetConsoleScreenBufferSize( gwi.hOutput,
                                    dwSize );
                                SetConsoleWindowInfo( gwi.hOutput, TRUE, 
                                    &(consoleBufferInfo.srWindow) ); 
                            }
                            else
                            {
                                SetConsoleWindowInfo( gwi.hOutput, TRUE, 
                                    &(consoleBufferInfo.srWindow) ); 
                                SetConsoleScreenBufferSize( gwi.hOutput,
                                    dwSize );
                            }
                            //Update global data structures.
                            ui.dwMaxCol = 80;
                            gwi.sbi.dwSize.X = 80;
                            consoleBufferInfo.dwSize.X = 80;

                            ClearScreen( pwi, ptrm, fdwEntireScreen );
                            break;

                        case 4: // DECSCLM : jump scroll
                            // Scrolling Mode (DEC Private)
                            // This is a private parameter to RM and 
                            // SM control sequences.  The reset
                            // state causes scrolls to "jump" 
                            // instantaneuously one line at a time.
                            // The set state causes the scrolls to be
                            // "smooth", and scrolls at a maximum rate 
                            // of siz lines/sec.  See MODES, RM, and SM.
                                break;

                        case 5: // DECSCNM ; dark background
                            //DECSCNM Screen Mode (DEC Private)
                            //This is a private parameter to RM and SM 
                            //control sequences.  The reset state causes 
                            //the screen to be black with white 
                            //characters; the set state causes the 
                            //screen to be white with black characters.
                            //See MODES, RM, and SM.
                                if( !FIsDECSCNM( ptrm ) )
                                {
                                    break;
                                }

                                //was setting instead of clearing
                                //SetDECSCNM( ptrm ); 
                                ClearDECSCNM( ptrm );

                                SetDarkBackground( pwi );
                                break;

                        case 6: // DECOM : Relative origin ; ignore margins
                            //DECOM   Origin Mode (DEC Private)
                            //This is a private parameter to SM and RM control
                            //sequences. The reset state causes the origin (or 
                            //home position) to be the upper left character 
                            //position of the screen.  Line and column numbers
                            //are, therefore, independent of current margin 
                            //settings.  The cursor may be positioned outside 
                            //the margins with a cursor position (CUP) or
                            //horizontal and vertical position (HVP) control.

                            //The set state causes the origin to be at the upper
                            //left character position within the current margins. 
                            //Line and column numbers are, therefore, relative 
                            //to the current margin settings.  The cursor cannot
                            //be positioned outside of the margins.

                            //The cursor is moved to the new home position when 
                            //this mode is set or reset.  Lines and columns are 
                            //numbered consecutively, with the origin being 
                            //line 1, column 1.

                            ptrm->fRelCursor = FALSE;
                            ptrm->dwCurChar = ptrm->dwCurLine = 0;
                            break;

                        case 7: // DECAWM 
                            //DECAWM  Autowrap Mode (DEC Private)
                            //This is a private parameter to the SM and RM
                            //control sequences. The reset state prevents the
                            //cursor from moving when characters are recieved 
                            //while at the right margin.  The set state causes
                            //these characters to advance to the next line, 
                            //causing a scroll up if required and permitted.  
                            //See MODES, SM, and RM.

                            ClearVTWrap( ptrm );
                            break;

                        case 8: // DECARM ; auto-repeat keys

                            //DECARM  Auto Repeat Mode (DEC Private)
                            //This is a private parameter to the SM and RM 
                            //control sequences. The reset state causes no 
                            //keyboard keys to auto-repeat, the set state
                            //causes most of them to.  See MODES, SM, and RM.

                                break;

                        case 9: // DECINLM 
                            //DECINLM Interlace Mode (DEC Private)

                            //This is a private parameter to the RM and SM 
                            //control sequences.  The reset state 
                            //(non-interlace) causes the video processor to 
                            //display 240 scan lines per frame.  The set state 
                            //causes the video processor to display 480 scan 
                            //lines per screen.  See MODES, RM, and SM.

                            break;
                        
                        case 19: // send only scrolling region to printer
                            break;

                        case 25: // cursor should be invisible
                            break;

                        case 66: // Numeric keypad
                            break;

                        default:
                            break;
                        }
                    }
                    else
                    {
                        switch ( ptrm->dwEscCodes[i] )
                        {
                        case 0:
                            //Error (Ignored)
                            break;

                        case 2: // Keyboard unlocked 
                            ClearKeyLock( ptrm );
                            break;

                        case 3: // display control codes

                        case 4: // Ansi insert mode ; set overtype mode
                            ClearInsertMode( ptrm );
                            break;

                        case 12: // local echo on
                            break;

                        case 20: // Ansi linefeed mode ; new-line sends only lf
                            //LNM     Line Feed/New Line Mode
                            //This is a parameter to SM and RM control sequences.
                            //The reset state causes the interpretation of the 
                            //<LF> character to imply only vertical movement of 
                            //the cursor and causes the RETURN key to send the 
                            //single code <CR>.  The set state causes the <LF>
                            //character to imply movement to the first position
                            //of the following line, and causes the RETURN key
                            //to send the code pair <CR><LF>.  This is the New 
                            //Line option.

                            //This mode does not affect the Index (IND) or the 
                            //next line (NEL) format effectors.

                            ClearLineMode( ptrm );
                            break;

                        default:
                            break;
                        }
                    }
                }
                ptrm->fEsc = 0;
                break;
            
            case 'i': // VT102 MC Media Copy ; print screen

                if( ptrm->dwEscCodes[0] == 5 )
                {
                    // Enter Media copy 
                }
                else if( ptrm->dwEscCodes[0] == 4 )
                {
                    // Exit Media copy 
                }
                ptrm->fEsc = 0;

            case '=':
                break;

            case '}':
            case 'm': // VT102 SGR Select graphic rendition ; set color
                //SGR     Select Graphic Rendition        
                //<ESC>[ {Ps} ; {Ps} m
                //Invoke the graphic rendition specified by the 
                //parameter(s).  All following characters transmitted 
                //to the VT100 are rendered according to the 
                //parameter(s) until the next occurrence of an SGR.  
                //FormatEffector. 
                //
                //Parameter       Meaning
                //---------------------------------------------
                //    0           Attributes Off
                //    1           Bold or increased intensity
                //    4           Underscore            
                //    5           Blink
                //    7           Negative (reverse) image
                //
                //All other parameter values are ignored.
                //
                //Without the Advanced Video Option, only one type of 
                //character attribute is possible, as determined by the
                //cursor selection; in that case specifying either 
                //underscore or reverse will activate the currently
                //selected attribute.
                //
                //[Update:  DP6429 defines parameters in the 30-37 range
                //to change foreground color and in the 40-47 range to 
                //change background.]

                for( i = 0; i < ( DWORD )ptrm->cEscParams; ++i )
                {
                    ptrm->rgdwGraphicRendition[i] = ptrm->dwEscCodes[i];
                    ptrm->dwIndexOfGraphicRendition = i;
                }
                SetGraphicRendition( pwi, ptrm, ptrm->dwIndexOfGraphicRendition,
                        ptrm->rgdwGraphicRendition );

                ptrm->fEsc = 0;
                break;

            case 'n': // VT102 DSR ; // report cursor position Row X Col

                //DSR     Device Status Report     Host to VT100 & VT100 to Host

                //<ESC>[ {Ps} n

                //Requests and reports the general status of the VT100 according
                //to the following parameters:       
                
                //Parameter       Meaning
                //--------------------------------------------------------------
                //  0            Response from VT100 - Ready, no faults detected
                //  3            Response from VT100 - Malfunction Detected
                //  5            Command from host - Report Status (using a DSR 
                //               control sequence)
                //  6            Command from host - Report Active Position 
                //               (using a CPR sequence)

                //DSR with a parameter of 0 or 3 is always sent as a response to
                //a requesting DSR with a parameter of 5.

                pchNBBuffer[0] = 0;
                if( ptrm->dwEscCodes[0] == 5 )
                {
                    // Terminal Status Report 
                    pchNBBuffer[0] = 0x1B;
                    pchNBBuffer[1] = '[';
                    pchNBBuffer[2] = 'c';
                    i = 3;
                }
                else if( ptrm->dwEscCodes[0] == 6 )
                {
                    CONSOLE_SCREEN_BUFFER_INFO info;
                    if( !GetConsoleScreenBufferInfo( gwi.hOutput,
                        &info ) )
                    {
                        info.srWindow.Top = 0;
                        info.srWindow.Left = 0;
                    }

                    i = _snprintf( ( CHAR * )pchNBBuffer,sizeof(pchNBBuffer)-1,"%c[%d;%dR", 
                        ( char ) 0x1B, 
			(ptrm->dwCurLine + 1 - info.srWindow.Top),
                        (ptrm->dwCurChar + 1 - info.srWindow.Left));
                }

                if( pchNBBuffer[0] != 0 )
                {
                    ( void ) FWriteToNet( pwi, ( LPSTR ) pchNBBuffer, 
                        ( int ) i );
                }

                // fall through 

            case 'q':       // Load LEDs 
                
                //DECLL   Load LEDs (DEC Private)

                //<ESC>[ {Ps} q                           Default Value: 0

                //Load the four programmable LEDs on the keyboard according to
                //theparameter(s).
                
                    //Parameter       Meaning
                    //-----------------------
                    //    0           Clear All LEDs
                    //    1           Light L1      
                    //    2           Light L2
                    //    3           Light L3
                    //    4           Light L4    

                ptrm->fEsc = 0;
                break;              // (nothing) 

            case 'p':
                break;
                
            case 'r': // VT102 DECSTBM ; scroll screen
                //DECSTBM Set Top and Bottom Margins (DEC Private)

                //<ESC>[ {Pn} ; {Pn} r      Default Values: See Below
                
                //This sequence sets the top and bottom margins to define the 
                //scrolling region.  The first parameter is the line number of 
                //the first line in the scrolling region; the second parameter 
                //is the line number of the bottom line of the scrolling region. 
                //Default is the entire screen (no margins).  The minimum region
                //allowed is two lines, i.e., the top line must be less than the
                //bottom.  The cursor is placed in the home position (See DECOM).
            
                if( ( ptrm->cEscParams < 2 ) || ( ptrm->dwEscCodes[1] == 0 ) )
                {
                    ptrm->dwEscCodes[1] = ui.dwMaxRow;
                }

                if( ptrm->dwEscCodes[0] == 0 )
                {
                    ptrm->dwEscCodes[0] = 1;
                }
                
                {
                    CONSOLE_SCREEN_BUFFER_INFO info;
                    if( !GetConsoleScreenBufferInfo( gwi.hOutput, 
                            &info ) )
                    {
                        consoleBufferInfo.srWindow.Top = 0;
                    }

                    if(( ptrm->dwEscCodes[0] > 0 ) &&
                        ( ptrm->dwEscCodes[0] < ptrm->dwEscCodes[1]) &&
                        ( ptrm->dwEscCodes[1] <= ui.dwMaxRow ))
                    {
                        SetMargins( ptrm, 
                            info.srWindow.Top + ptrm->dwEscCodes[0], 
                            info.srWindow.Top + ptrm->dwEscCodes[1] );
                        
                        ptrm->dwCurChar = 0;
                        ptrm->dwCurLine = ( ptrm->fRelCursor == TRUE ) 
                            ? ptrm->dwScrollTop : 0;
                        
                        ptrm->fFlushToEOL = FALSE;
                    }
                }
                ptrm->fEsc = 0;
                break;
            

            case 's': // ANSI.SYS save current cursor pos 
                ptrm->dwSaveChar = ptrm->dwCurChar;
                ptrm->dwSaveLine = ptrm->dwCurLine;
                ptrm->fEsc = 0;
                break;

            case 'u': // ANSI.SYS restore current cursor pos 
                ptrm->dwCurChar = ptrm->dwSaveChar;
                ptrm->dwCurLine = ptrm->dwSaveLine;
                ptrm->fEsc = 0;
                ptrm->fFlushToEOL = FALSE;
                break;
            
            case 'x': // DEC terminal report
                // DECREQTPARM     Request Terminal Parameters  
                // <ESC>[ {Ps} x
                //The host sends this sequence to request the VT100 to
                //send a DECREPTPARM sequence back. {Ps} can be either
                //0 or 1.  If 0, the terminal will be allowed to send
                //unsolicited DECREPTPARMs.  These reports will be
                //generated each time the terminal exits the SET-UP 
                //mode.  If {Ps} is 1, then the terminal will only 
                //generate DECREPTPARMs in response to a request.
                if( ptrm->dwEscCodes[0] )
                {
                    strncpy( pchNBBuffer,"\033[3;1;1;128;128;1;0x",sizeof(pchNBBuffer)-1);
                    i = strlen(pchNBBuffer);
                }
                else
                {
                    strncpy( pchNBBuffer,"\033[3;1;1;128;128;1;0x",sizeof(pchNBBuffer)-1 );
                    i = strlen(pchNBBuffer);
                }
                
                if( pchNBBuffer[0] != 0 )
                {
                    ( void ) FWriteToNet( pwi, ( LPSTR ) pchNBBuffer, i );
                }
                break;

            case 'y':
                //
                //DECTST  Invoke Confidence Test       
                    
                //    <ESC>[ 2 ; {Ps} y

                //Ps is the parameter indicating the test to be done.  It is 
                //computed by taking the weight indicated for each desired test
                //and adding them together.  If Ps is 0, no test is performed 
                //but the VT100 is reset.

                //Test                                                    Weight
                //--------------------------------------------------------------
                //POST (ROM checksum, RAM NVR, keyboardm and AVO)           1
                //Data Loop Back (Loopback connector required)              2
                //EIA Modem Control Test (Loopback connector req.)          4
                //Repeat Testing until failure                              8

                break;

            default:  // unhandled 
                ptrm->fEsc = 0;
            }
            break;



        case 3:
            // Handle VT102's Esc# 
            switch( *pchT )
            {
            case '8':   // Fill Screen with "E" 
                // DECALN  Screen Alignment Display (DEC private) 

                //  <ESC># 8

                //This command causes the VT100 to fill it's screen with 
                //uppercase Es for screen focus and alignment.

                DECALN( pwi, ptrm );
                break;
                
            //DECDHL  Double Height Line (DEC Private)

            //Top Half:       <ESC>#3
            //Bottom Half:    <ESC>#4

            //These sequences cause the line containing the cursor to become the
            //top or bottom half of a double-height, double width line. The
            //sequences should be used in pairs on adjacent lines with each line
            //containing the same character string.  If the line was single 
            //width single height, all characters to the right of the center of 
            //the screen will be lost.  The cursor remains over the same 
            //character position, unless it would be to the right of the right
            //margin, in which case it is moved to the right margin.    

            case 3:
                break;
            case 4:
                break;

            case 5:
                //DECSWL  Single-width Line (DEC Private)        
                
                //<ESC>#5

                //This causes the line which contains the cursor to become 
                //single-width, single-height.  The cursor remains on the same 
                //character position. This is the default condition for all new 
                //lines on the screen.
                break;

            case 6:
                //DECDWL  Double Width Line (DEC Private)     

                //<ESC>#6

                //This causes the line that contains the cursor to become 
                //double-width single height.  If the line was single width, all
                //characters ro the right of the center of the screen will be 
                //lost.  The cursor remains over the same character position, 
                //unless it would be to the right of the right margin, in which 
                //case it is moved to the right margin.

            default:
                break;
            }
            ptrm->fEsc = 0;
            break;

        case 4:
            // Handle VT52's Esc Y 
            if(( *pchT ) >= ' ')
            {
                ptrm->dwEscCodes[ptrm->cEscParams++] = *pchT - 0x20;
                if( ptrm->cEscParams == 2 )
                {
                    ptrm->dwCurLine = ptrm->dwEscCodes[0];
                    ptrm->dwCurChar = ptrm->dwEscCodes[1];
                    ptrm->fEsc = 0;
                    ptrm->fFlushToEOL = FALSE;
                }
            }
            else
            {
                ptrm->fEsc = 0;
            }
            break;



        case 5:
            if (FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80))
                {
                /* Single-Byte char invoke */
                if (((*pchT) == 'B') || ((*pchT) =='J') || ((*pchT) == 'H'))
                {
                    ClearKanjiStatus(ptrm,JIS_KANJI_CODE);
                    SetCharSet(ptrm,GRAPHIC_LEFT,rgchJISRomanChars);
#ifdef DEBUG
                    _snwprintf(rgchDbgBfr,sizeof(rgchDbgBfr)-1,"VT80 JIS Roman Mode Enter\n");
                    OutputDebugString(rgchDbgBfr);
#endif /* DEBUG */
                }

                ptrm->fEsc = 0;
                }
            break;



        case 6:
            if (FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80))
                {
                /* Multi-Byte char invoke */
                if (((*pchT) == '@') || ((*pchT) =='B'))
                {
                    SetKanjiStatus(ptrm,JIS_KANJI_CODE);
                    SetCharSet(ptrm,GRAPHIC_LEFT,rgchJISKanjiChars);
#ifdef DEBUG
                    _snwprintf(rgchDbgBfr,sizeof(rgchDbgBfr)-1,"VT80 JIS Kanji Mode Enter\n");
                    OutputDebugString(rgchDbgBfr);
#endif /* DEBUG */
                }

                ptrm->fEsc = 0;
                }
            break;



        case 7: /* SUB */
            if (FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80))
                {            
                switch( *pchT )
                {
                case 'p':
                  /* ACOS Kanji IN (Kanji to G0(GL)) */
                  SetKanjiStatus(ptrm,JIS_KANJI_CODE);
                  SetCharSet(ptrm,GRAPHIC_LEFT,rgchJISKanjiChars);
                  break;

                case 'q':
                  /* ACOS Kanji OUT (JIS Roman to G0(GL)) */
                  ClearKanjiStatus(ptrm,JIS_KANJI_CODE);
                  SetCharSet(ptrm,GRAPHIC_LEFT,rgchJISRomanChars);
                  break;

                default:
                    break;
                }

                ptrm->fEsc = 0;
                }
            break;

        default:
            break;

        }
    }

    FlushBuffer(pwi, ptrm);

    if( FGetCodeMode(eCodeModeIMEFarEast) )
    {
        if (ui.fDebug & fdwKanjiModeMask)
        {
            SetImeWindow(ptrm);
        }
    }

    cp.X = ( short )ptrm->dwCurChar;
    cp.Y = ( short )ptrm->dwCurLine;
    if( wSaveCurrentLine != cp.Y )
    {
        wSaveCurrentLine = cp.Y;
        if( FGetCodeMode( eCodeModeIMEFarEast ) )
        {
            WriteOneBlankLine( pwi->hOutput, ( WORD )( cp.Y + 1 ) );
        }
    }

    SetConsoleCursorPosition( pwi->hOutput, cp );
    ptrm->fHideCursor = FALSE;

    SaveCurrentWindowCoords();
}

void
HandleCharEvent(WI *pwi, CHAR AsciiChar, DWORD dwControlKeyState)
{
    DWORD   i;

    //This is for informing change in window size to server, if any, before sending a char
    CheckForChangeInWindowSize( );

    /* Map Alt-Control-C to Delete */
    if ((AsciiChar == 3) && ((dwControlKeyState & ALT_PRESSED) &&  (dwControlKeyState & CTRL_PRESSED)))
            AsciiChar = 0x7F;
    /*Map Ctrl-space to ASCII NUL (0) */
    if( (AsciiChar == ' ') && (dwControlKeyState & CTRL_PRESSED) && 
            !( dwControlKeyState & ( SHIFT_PRESSED | ALT_PRESSED ) ) )
    {
        AsciiChar = 0;
    }

    if (FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80))
        {

        //
        // Fix to bug 1149
        // if (GetKeyState(VK_CONTROL) < 0) {
        //
        if (dwControlKeyState & CTRL_PRESSED) {
            UCHAR RevChar = LOBYTE(LOWORD(AsciiChar));
            UCHAR SendChar;

            ForceJISRomanSend(pwi);

            if(RevChar == VK_SPACE) {
                /*
                * !!! This code is nessesary to control Unix IME
                */
                SendChar = 0x00;
                /* write to network */
                FWriteToNet(pwi, (LPSTR)&SendChar, 1);
                return;
            } else {
                if((RevChar >= '@') && (RevChar <= ']')) {
                    SendChar = ( UCHAR ) ( RevChar - '@' );
                    /* write to network */
                    FWriteToNet(pwi, (LPSTR)&SendChar, 1);
                    return;
                } else if((RevChar >= 'a') && (RevChar <= 'z')) {
                    SendChar = (UCHAR)toupper(RevChar);
                    SendChar -= (UCHAR)'@';
                    /* write to network */
                     FWriteToNet(pwi, (LPSTR)&SendChar, 1);
                     return;
                } else {
                    FWriteToNet(pwi, (LPSTR)&RevChar, 1);
                    return;
                }
            }

        } else if (FIsVT80(&pwi->trm)) {
            DWORD  j = 0;
            BOOL   bWriteToNet = TRUE;
            UCHAR *WriteBuffer = pchNBBuffer + 3; /* +3:room for escape sequence.*/

            /* INPUT SJIS -> */
            if (uchInPrev != 0) {
                WriteBuffer[0] = uchInPrev;
                WriteBuffer[1] = (CHAR)AsciiChar;
                uchInPrev = 0;
                j = 2;
            } else if(IsDBCSLeadByte((CHAR)AsciiChar) && uchInPrev == 0) {
                uchInPrev = (CHAR)AsciiChar;
                bWriteToNet = FALSE;        /* don't send only lead byte */
            } else {
                WriteBuffer[0] = (CHAR)AsciiChar;
                j = 1;
            }

            /* Do convert */

            if (bWriteToNet) {

                if (WriteBuffer[0] == ASCII_CR && (FIsLineMode(&(gwi.trm)) || ui.nottelnet)) {

                    //
                    // Automatically add a line feed to a carriage return
                    //
                    WriteBuffer[1] = ASCII_LF;
                    j = 2;

                } else if (FIsJISKanji(&pwi->trm) || FIsJIS78Kanji(&pwi->trm)) {

                /* OUTPUT -> JIS Kanji or JIS 78 Kanji */
                if(j==2) {
                    /* full width area code */
                    sjistojis( &(WriteBuffer[0]), &(WriteBuffer[1]) );

                    /* if we still not send Kanji esc. send it. */
                    if( !(GetKanjiStatus(&pwi->trm) & JIS_SENDING_KANJI ) ) {
                        WriteBuffer -= 3;
                        if (FIsJISKanji(&pwi->trm)) {
                            WriteBuffer[0] = (UCHAR)0x1B; // Ecs
                            WriteBuffer[1] = (UCHAR)'$';
                            WriteBuffer[2] = (UCHAR)'B';  // JIS Kanji 1983
                        } else {
                            WriteBuffer[0] = (UCHAR)0x1B; // Ecs
                            WriteBuffer[1] = (UCHAR)'$';
                            WriteBuffer[2] = (UCHAR)'@';  // JIS Kanji 1978
                        }
                        SetKanjiStatus(&pwi->trm,JIS_SENDING_KANJI);
                        j += 3;
                    }

                } else {

                    /* half width area code */
                    /* if we are in Kanji mode, clear it */
                    if( GetKanjiStatus(&pwi->trm) & JIS_SENDING_KANJI ) {
                        WriteBuffer -= 3;
                        WriteBuffer[0] = (UCHAR)0x1B; // Ecs
                        WriteBuffer[1] = (UCHAR)'(';
                        WriteBuffer[2] = (UCHAR)'J';  // JIS Roman
                        ClearKanjiStatus(&pwi->trm,JIS_SENDING_KANJI);
                        j += 3;
                    }

                }

            } else if (FIsEUCKanji(&pwi->trm) || FIsDECKanji(&pwi->trm)) {
                /* OUTPUT -> Japanese EUC / DEC Kanji */
                if(j==2) {
                    /* full width area code */
                    sjistoeuc( &(WriteBuffer[0]), &(WriteBuffer[1]) );
                } else {
                    /* half width area code */
                    if(IsKatakana(WriteBuffer[0])) {
                        /* Add escape sequence for Katakana */
                        WriteBuffer--;
                        WriteBuffer[0] = (UCHAR)0x8E; // 0x8E == SS2
                        j++;
                    }
                }
            } else if (FIsNECKanji(&pwi->trm)) {
                /* OUTPUT -> NEC Kanji */
                if(j==2) {
                    /* full width area code */
                    sjistojis( &(WriteBuffer[0]), &(WriteBuffer[1]) );

                    /* if we still not send Kanji esc. send it. */
                    if( !(GetKanjiStatus(&pwi->trm) & JIS_SENDING_KANJI ) ) {
                        WriteBuffer -= 2;
                        WriteBuffer[0] = (UCHAR)0x1B; // Ecs
                        WriteBuffer[1] = (UCHAR)'K';  // NEC Kanji IN
                        SetKanjiStatus(&pwi->trm,JIS_SENDING_KANJI);
                        j += 2;
                    }
                } else {
                    /* half width area code */
                    /* if we are in Kanji mode, clear it */
                    if( GetKanjiStatus(&pwi->trm) & JIS_SENDING_KANJI ) {
                        WriteBuffer -= 2;
                        WriteBuffer[0] = (UCHAR)0x1B; // Ecs
                        WriteBuffer[1] = (UCHAR)'H';  // NEC Kanji OUT
                        ClearKanjiStatus(&pwi->trm,JIS_SENDING_KANJI);
                        j += 2;
                    }
                }
            } else if (FIsACOSKanji(&pwi->trm)) {
                
                /* OUTPUT -> ACOS Kanji */
                if(j==2) {
                    /* full width area code */
                    sjistojis( &(WriteBuffer[0]), &(WriteBuffer[1]) );

                    /* if we still not send Kanji esc. send it. */
                    if( !(GetKanjiStatus(&pwi->trm) & JIS_SENDING_KANJI ) ) {
                        WriteBuffer -= 2;
                        WriteBuffer[0] = (UCHAR)0x1A; // Sub
                        WriteBuffer[1] = (UCHAR)'p';  // ACOS Kanji IN
                        SetKanjiStatus(&pwi->trm,JIS_SENDING_KANJI);
                        j += 2;
                    }

                } else {

                    /* half width area code */
                    /* if we are in Kanji mode, clear it */
                    if( GetKanjiStatus(&pwi->trm) & JIS_SENDING_KANJI ) {
                        WriteBuffer -= 2;
                        WriteBuffer[0] = (UCHAR)0x1A; // Sub
                        WriteBuffer[1] = (UCHAR)'q';  // ACOS Kanji OUT
                        ClearKanjiStatus(&pwi->trm,JIS_SENDING_KANJI);
                        j += 2;
                    }

                }
                } else {

                    /* OUTPUT -> SJIS */
                    /* Nothing to do  */ ;

                }

                /* echo to local */
                if (ui.nottelnet || (ui.fDebug & fdwLocalEcho)) {
                    //InvalidateEntryLine(hwnd, &pwi->trm);
                    DoIBMANSIOutput(pwi, &pwi->trm, j, WriteBuffer);
                }

                /* write to network */
                FWriteToNet(pwi, (LPSTR)WriteBuffer, j);
            }

                return;
        }
    }


    pchNBBuffer[0] = (UCHAR)AsciiChar;

    //
    //  Automatically add a line feed to a carriage return
    //

    i = 1;
    if (pchNBBuffer[0] == ASCII_CR) // Check whether we need to translate cr->crlf
    {
        if (FIsLineMode(&(gwi.trm)) || ui.nottelnet)
        {
            pchNBBuffer[i++] = ASCII_LF;
        }
    }

    if (ui.nottelnet || (ui.fDebug & fdwLocalEcho))
    {
        DoIBMANSIOutput(pwi, &pwi->trm, i, pchNBBuffer);
    }

    FWriteToNet(pwi, (LPSTR)pchNBBuffer, i);
}

BOOL
FHandleKeyDownEvent(WI *pwi, CHAR AsciiChar, DWORD dwControlKeyState)
{
    int iIndex = 2;   //needed for forming vt302 key sequence
    
    //This is for informing change in window size to server, if any, before sending a char
    CheckForChangeInWindowSize( );

    switch( LOWORD(AsciiChar) )
    {
    case VK_PAUSE:
        szVt302ShortKeySequence[ iIndex ] = VT302_PAUSE;
        FWriteToNet(pwi, szVt302ShortKeySequence, strlen( szVt302ShortKeySequence ) );
        break;

    case VK_HOME:
        szVt302KeySequence[ iIndex ] = VT302_HOME;
        FWriteToNet(pwi, szVt302KeySequence, strlen( szVt302KeySequence ) );
        break;

    case VK_END:
        szVt302KeySequence[ iIndex ] = VT302_END;
        FWriteToNet(pwi, szVt302KeySequence, strlen( szVt302KeySequence ) );
        break;

    case VK_INSERT:
        szVt302KeySequence[ iIndex ] = VT302_INSERT;
        FWriteToNet(pwi, szVt302KeySequence, strlen( szVt302KeySequence ) );
        break;

    case VK_PRIOR:
        szVt302KeySequence[ iIndex ] = VT302_PRIOR;
        FWriteToNet(pwi, szVt302KeySequence, strlen( szVt302KeySequence ) );

        break;

    case VK_NEXT:
        szVt302KeySequence[ iIndex ] = VT302_NEXT;
        FWriteToNet(pwi, szVt302KeySequence, strlen( szVt302KeySequence ) );

        break;

    case VK_DELETE:
        {
            UCHAR ucCharToBeSent = 0;
            if (FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80))
            {
                ForceJISRomanSend(pwi);
            }

            ucCharToBeSent = ASCII_DEL; //0x7F;
            pchNBBuffer[0] = ucCharToBeSent;
            FWriteToNet(pwi, (LPSTR)pchNBBuffer, 1);
        }
        break;

    case VK_RETURN:
        if (FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80))
        {
            ForceJISRomanSend(pwi);
        }
        {
            INT x = 0;

            pchNBBuffer[ x++ ] = ( UCHAR ) LOWORD(AsciiChar);
            if( FIsLineMode( &( gwi.trm ) ) )
            {
                pchNBBuffer[ x++ ] = ( UCHAR ) ASCII_LF;
            }

            FWriteToNet(pwi, (LPSTR)pchNBBuffer, x );
        }
        break;

    case VK_DIVIDE:
        FWriteToNet(pwi, "/", 1);
        break;

    /*F5 to F12 are not used in VT100. Using VT302 sequences*/
    case VK_F5:
        szVt302LongKeySequence[ iIndex ]    = CHAR_ONE;
        szVt302LongKeySequence[ iIndex+1 ]  = CHAR_FIVE;
        FWriteToNet(pwi, szVt302LongKeySequence, strlen( szVt302LongKeySequence ) );
        break;

    case VK_F6:
        szVt302LongKeySequence[ iIndex ]    = CHAR_ONE;
        szVt302LongKeySequence[ iIndex+1 ]  = CHAR_SEVEN;
        FWriteToNet(pwi, szVt302LongKeySequence, strlen( szVt302LongKeySequence ) );
        break;

    case VK_F7:
        szVt302LongKeySequence[ iIndex ]    = CHAR_ONE;
        szVt302LongKeySequence[ iIndex+1 ]  = CHAR_EIGHT;
        FWriteToNet(pwi, szVt302LongKeySequence, strlen( szVt302LongKeySequence ) );
        break;

    case VK_F8:
        szVt302LongKeySequence[ iIndex ]    = CHAR_ONE;
        szVt302LongKeySequence[ iIndex+1 ]  = CHAR_NINE;
        FWriteToNet(pwi, szVt302LongKeySequence, strlen( szVt302LongKeySequence ) );
        break;

    case VK_F9:
        szVt302LongKeySequence[ iIndex ]    = CHAR_TWO;
        szVt302LongKeySequence[ iIndex+1 ]  = CHAR_ZERO;
        FWriteToNet(pwi, szVt302LongKeySequence, strlen( szVt302LongKeySequence ) );
        break;

    case VK_F10:
        szVt302LongKeySequence[ iIndex ]    = CHAR_TWO;
        szVt302LongKeySequence[ iIndex+1 ]  = CHAR_ONE;
        FWriteToNet(pwi, szVt302LongKeySequence, strlen( szVt302LongKeySequence ) );
        break;

    case VK_F11:
        szVt302LongKeySequence[ iIndex ]    = CHAR_TWO;
        szVt302LongKeySequence[ iIndex+1 ]  = CHAR_THREE;
        FWriteToNet(pwi, szVt302LongKeySequence, strlen( szVt302LongKeySequence ) );
        break;

    case VK_F12:
        szVt302LongKeySequence[ iIndex ]    = CHAR_TWO;
        szVt302LongKeySequence[ iIndex+1 ]  = CHAR_FOUR;
        FWriteToNet(pwi, szVt302LongKeySequence, strlen( szVt302LongKeySequence ) );
        break;

    default:
    if ( !(ui.fDebug & fdwNoVT100Keys) )
    {
        /*
         * When F1-F4 or the up/down/right/left cursor keys
         * are hit, the bytes sent to the connected machine
         * depend on what mode the terminal emulator is in.
         * There are three relevant modes, VT102 Application,
         * VT102 Cursor, VT52.
         *
         * Mode                 Pattern sent
         * VT102 App    EscO* (3 bytes)
         * VT102 Cursor Esc[* (3 bytes)
         * VT52                 Esc*  (2 bytes)
         *
         * where '*' represents the byte to be sent and
         * is dependant upon the key that was hit.
         * For the function keys F1-F4, their VT102
         * Cursor mode is the same as their VT102 App mode.
         */

        DWORD   iPos     = (FIsVT52(&pwi->trm)) ? 1 : 2;
        DWORD   cch      = (FIsVT52(&pwi->trm)) ? 2 : 3;
        WORD    wKeyCode = LOWORD(AsciiChar);

        pchNBBuffer[0] = 0;
        pchNBBuffer[1] = ( UCHAR ) ( (FIsVTArrow(&pwi->trm)) ? 'O' : '[' );

        if ((wKeyCode == VK_F1) || (wKeyCode == VK_F2) ||
                        (wKeyCode == VK_F3) || (wKeyCode == VK_F4))
        {
            pchNBBuffer[0] = 0x1B;
            pchNBBuffer[1] = 'O';
            pchNBBuffer[iPos] = ( UCHAR ) ( ((UCHAR)'P'+(UCHAR)(wKeyCode-VK_F1)));
        }
        else if (wKeyCode == VK_UP)
        {
            pchNBBuffer[0] = 0x1B;
            pchNBBuffer[iPos] = 'A';
        }
        else if (wKeyCode == VK_DOWN)
        {
            pchNBBuffer[0] = 0x1B;
            pchNBBuffer[iPos] = 'B';
        }
        else if (wKeyCode == VK_RIGHT)
        {
            pchNBBuffer[0] = 0x1B;
            pchNBBuffer[iPos] = 'C';
        }
        else if (wKeyCode == VK_LEFT)
        {
            pchNBBuffer[0] = 0x1B;
            pchNBBuffer[iPos] = 'D';
        }

        if (pchNBBuffer[0] == 0x1B)
        {
            FWriteToNet(pwi, (LPSTR)pchNBBuffer, (int)cch);
        }
    }
    }
    return TRUE;
}

void SetCharSet( TRM *ptrm , INT iCodeArea , UCHAR *pSource )
{
    if( iCodeArea == GRAPHIC_LEFT )
        ptrm->CurrentCharSet[0] = pSource;
    else
        ptrm->CurrentCharSet[1] = pSource;
       
    RtlCopyMemory( (PBYTE)((ptrm->puchCharSet) + iCodeArea) ,
                   pSource ,
                   128
                 ); //Attack ? Size of destination not known.
}

void PushCharSet( TRM *ptrm , INT iCodeArea , UCHAR *pSource )
{
    if( iCodeArea == GRAPHIC_LEFT )
        ptrm->PreviousCharSet[0] = ptrm->CurrentCharSet[0];
     else
        ptrm->PreviousCharSet[1] = ptrm->CurrentCharSet[1];

    SetCharSet( ptrm , iCodeArea , pSource );
}

void PopCharSet( TRM *ptrm , INT iCodeArea )
{
    if( iCodeArea == GRAPHIC_LEFT )
        SetCharSet( ptrm , iCodeArea , ptrm->PreviousCharSet[0]);
     else
        SetCharSet( ptrm , iCodeArea , ptrm->PreviousCharSet[1]);
}

void SetupCharSet( TRM *ptrm )
{
    if( ui.fDebug & fdwVT80Mode ) {

        SetVT80(ptrm);

        ClearKanjiFlag(ptrm);

#ifdef DEBUG
        snprintf(rgchDbgBfr,sizeof(rgchDbgBfr)-1, "VT80 - ");
        OutputDebugString(rgchDbgBfr);
#endif
        switch( ui.fDebug & fdwKanjiModeMask ) {
        case fdwJISKanjiMode :
        case fdwJIS78KanjiMode :

#ifdef DEBUG
            snprintf(rgchDbgBfr,sizeof(rgchDbgBfr)-1, "JIS or JIS78 Kanji Mode\n");
            OutputDebugString(rgchDbgBfr);
#endif

            if((ui.fDebug & fdwKanjiModeMask) == fdwJIS78KanjiMode)
                SetJIS78Kanji(ptrm);
             else
                SetJISKanji(ptrm);

            ptrm->g0 = rgchJISRomanChars;
            ptrm->g1 = rgchKatakanaChars;
            ptrm->g2 = rgchJISKanjiChars;
            ptrm->g3 = rgchNullChars;     // rgchJISHojyoKanjiChars;

            SetCharSet(ptrm,GRAPHIC_LEFT ,ptrm->g0);
            SetCharSet(ptrm,GRAPHIC_RIGHT,ptrm->g1);
            break;

        case fdwSJISKanjiMode :

#ifdef DEBUG
            snprintf(rgchDbgBfr,sizeof(rgchDbgBfr)-1, "ShiftJIS Kanji Mode\n");
            OutputDebugString(rgchDbgBfr);
#endif
            SetSJISKanji(ptrm);

            ptrm->g0 = rgchJISRomanChars;
            ptrm->g1 = rgchKatakanaChars;
            ptrm->g2 = rgchNullChars;     // N/A
            ptrm->g3 = rgchNullChars;     // N/A

            SetCharSet(ptrm,GRAPHIC_LEFT ,ptrm->g0);
            SetCharSet(ptrm,GRAPHIC_RIGHT,ptrm->g1);
            break;

        case fdwEUCKanjiMode :

#ifdef DEBUG
            snprintf(rgchDbgBfr,sizeof(rgchDbgBfr)-1, "EUC Kanji Mode\n");
            OutputDebugString(rgchDbgBfr);
#endif
            SetEUCKanji(ptrm);

            ptrm->g0 = rgchJISRomanChars;
            ptrm->g1 = rgchEUCKanjiChars;
            ptrm->g2 = rgchKatakanaChars;
            ptrm->g3 = rgchNullChars;     // rgchEUCHojyoKanjiChars;

            SetCharSet(ptrm,GRAPHIC_LEFT ,ptrm->g0);
            SetCharSet(ptrm,GRAPHIC_RIGHT,ptrm->g1);
            break;

        case fdwNECKanjiMode :

#ifdef DEBUG
            snprintf(rgchDbgBfr,sizeof(rgchDbgBfr)-1, "NEC Kanji Mode\n");
            OutputDebugString(rgchDbgBfr);
#endif
            SetNECKanji(ptrm);

            ptrm->g0 = rgchJISRomanChars;
            ptrm->g1 = rgchKatakanaChars;
            ptrm->g2 = rgchJISKanjiChars;
            ptrm->g3 = rgchNullChars;     // rgchJISHojyoKanjiChars;

            SetCharSet(ptrm,GRAPHIC_LEFT ,ptrm->g0);
            SetCharSet(ptrm,GRAPHIC_RIGHT,ptrm->g1);
            break;

        case fdwACOSKanjiMode :

#ifdef DEBUG
            snprintf(rgchDbgBfr,sizeof(rgchDbgBfr)-1, "ACOS Kanji Mode\n");
            OutputDebugString(rgchDbgBfr);
#endif
            SetACOSKanji(ptrm);

            ptrm->g0 = rgchJISRomanChars;
            ptrm->g1 = rgchKatakanaChars;
            ptrm->g2 = rgchJISKanjiChars;
            ptrm->g3 = rgchNullChars;     // rgchJISHojyoKanjiChars;

            SetCharSet(ptrm,GRAPHIC_LEFT ,ptrm->g0);
            SetCharSet(ptrm,GRAPHIC_RIGHT,ptrm->g1);
            break;

        case fdwDECKanjiMode :

#ifdef DEBUG
            snprintf(rgchDbgBfr,sizeof(rgchDbgBfr)-1, "DEC Kanji Mode\n");
            OutputDebugString(rgchDbgBfr);
#endif
            SetDECKanji(ptrm);

            ptrm->g0 = rgchJISRomanChars;
            ptrm->g1 = rgchGraphicsChars;
            ptrm->g2 = rgchKatakanaChars;
            ptrm->g3 = rgchDECKanjiChars;

            SetCharSet(ptrm,GRAPHIC_LEFT ,ptrm->g0);
            SetCharSet(ptrm,GRAPHIC_RIGHT,ptrm->g3); // Kanji Terminal Mode
            break;
            }
    } else {

#ifdef DEBUG
        snprintf(rgchDbgBfr,sizeof(rgchDbgBfr)-1, "VT52/100 Non Kanji Mode\n");
        OutputDebugString(rgchDbgBfr);
#endif
        if( ui.fDebug & fdwVT52Mode ) SetVT52( ptrm );

        SetCharSet(ptrm,GRAPHIC_LEFT ,rgchIBMAnsiChars);
        SetCharSet(ptrm,GRAPHIC_RIGHT,rgchDefaultRightChars);
    }
}

void jistosjis( UCHAR *p1 , UCHAR *p2 )
{
    UCHAR c1 = *p1;
    UCHAR c2 = *p2;

    int rowOffset = c1 < 95 ? 112 : 176;
    int cellOffset = c1 % 2 ? (c2 > 95 ? 32 : 31) : 126;

    *p1 = ( UCHAR ) ( ((c1 + 1) >> 1) + rowOffset );
    *p2 = ( UCHAR ) ( *p2 + cellOffset );
}

void euctosjis( UCHAR *p1 , UCHAR *p2 )
{
    *p1 -= 128;
    *p2 -= 128;

    jistosjis( p1 , p2 );
}

void sjistojis( UCHAR *p1 , UCHAR *p2 )
{
    UCHAR c1 = *p1;
    UCHAR c2 = *p2;

    int adjust = c2 < 159;
    int rowOffset = c1 < 160 ? 112 : 176;
    int cellOffset = adjust ? (c2 > 127 ? 32 : 31) : 126;

    *p1 = ( UCHAR ) ( ((c1 - rowOffset) << 1) - adjust );
    *p2 = ( UCHAR ) ( *p2 - cellOffset );
}

void sjistoeuc( UCHAR *p1 , UCHAR *p2 )
{
    sjistojis( p1 , p2 );

    *p1 += 128;
    *p2 += 128;
}

/******
BOOL
IsDBCSCharPoint(
    POINT *ppt
)
{
    LPSTR lpstrRow;

    lpstrRow = apcRows[ppt->y];

    return(IsDBCSLeadByte(*(lpstrRow+ppt->x)));
}

void
AlignDBCSPosition(
    POINT *ppt,
    BOOL   bLeftAlign
)
{
    LPSTR lpstrRow;
    LONG  current = 0;
    BOOL  bDBCSChar;

    lpstrRow = apcRows[ppt->y];

    while( current < ppt->x ) {
        bDBCSChar = FALSE;
        if(IsDBCSLeadByte(*lpstrRow)) {
            bDBCSChar = TRUE;
            lpstrRow++;
            current++;
        }
        lpstrRow++;
        current++;
    }

    if(bLeftAlign) {
        if(bDBCSChar) {
            current -= 2;
        } else {
            current --;
        }
    }

    ppt->x = current;
}

void
AlignDBCSPosition2(
    POINT *ppt,
    LPCSTR pch,
    BOOL   bLeftAlign
)
{
    LPCSTR lpstrRow;
    LONG  current = 0;
    BOOL  bDBCSChar = FALSE;

    lpstrRow = pch;

    while( current < ppt->x ) {
        bDBCSChar = FALSE;
        if(IsDBCSLeadByte(*lpstrRow)) {
            bDBCSChar = TRUE;
            lpstrRow++;
            current++;
        }
        lpstrRow++;
        current++;
    }

    if(bLeftAlign) {
        if(bDBCSChar) {
            current -= 2;
        } else {
            current --;
        }
    }

    ppt->x = current;
}

void DBCSTextOut(HDC hdc, int j, int i, LPCSTR pch, int offset, int len)
{
    POINT pt;
    int x, y;
    int delta;

    pt.x = offset;
    pt.y = i;

    if(offset)
        AlignDBCSPosition2(&pt,pch,(fHSCROLL ? TRUE : FALSE));

    if( (delta = offset - pt.x) > 0 )
        x = aixPos(j) - aixPos(delta);
     else
        x = aixPos(j);
    y = aiyPos(i);

    (void)TextOut((HDC)hdc,x,y,pch+pt.x,len);
}

*****/


void ForceJISRomanSend(WI *pwi)
{
    CHAR Buffer[5];
    CHAR *WriteBuffer = Buffer;
    int  j = 0;

    if( FIsVT80(&pwi->trm) ) {

        if( GetKanjiStatus(&pwi->trm) & JIS_SENDING_KANJI ) {

            if(FIsJISKanji(&pwi->trm) || FIsJIS78Kanji(&pwi->trm)) {
                *WriteBuffer++ = (UCHAR)0x1B; // Ecs
                *WriteBuffer++ = (UCHAR)'(';
                *WriteBuffer++ = (UCHAR)'J';  // JIS Roman
                ClearKanjiStatus(&pwi->trm,JIS_SENDING_KANJI);
                j = 3;

            } else if (FIsNECKanji(&pwi->trm)) {

                *WriteBuffer++ = (UCHAR)0x1B; // Ecs
                *WriteBuffer++ = (UCHAR)'H';  // NEC Kanji OUT
                ClearKanjiStatus(&pwi->trm,JIS_SENDING_KANJI);
                j = 2;
            } else if (FIsACOSKanji(&pwi->trm)) {

                *WriteBuffer++ = (UCHAR)0x1A; // Sub
                *WriteBuffer++ = (UCHAR)'q';  // ACOS Kanji OUT
                ClearKanjiStatus(&pwi->trm,JIS_SENDING_KANJI);
                j = 2;
            }

            if( j ) FWriteToNet(pwi, (LPSTR)Buffer, j);
        }
    }
}

void FWriteTextDataToNet(HWND hwnd, LPSTR szString, int c)
{
    WI *pwi = (WI *)GetWindowLongPtr(hwnd, WL_TelWI);

    if ( FIsVT80(&pwi->trm) && !FIsSJISKanji(&pwi->trm) )
    {
        DWORD  j = 0;
        UCHAR*  WriteBuffer = pchNBBuffer;

        if (FIsJISKanji(&pwi->trm) || FIsJIS78Kanji(&pwi->trm)) {

            while(c > 0) {

                /* OUTPUT -> JIS Kanji or JIS 78 Kanji */

                if (IsDBCSLeadByte(*szString)) {

                    /* full width area code */

                    if( !(GetKanjiStatus(&pwi->trm) & JIS_SENDING_KANJI ) ) {
                        if (FIsJISKanji(&pwi->trm)) {
                            *WriteBuffer++ = (UCHAR)0x1B; // Ecs
                            *WriteBuffer++ = (UCHAR)'$';
                            *WriteBuffer++ = (UCHAR)'B';  // JIS Kanji 1983
                        } else {
                            *WriteBuffer++ = (UCHAR)0x1B; // Ecs
                            *WriteBuffer++ = (UCHAR)'$';  
                            *WriteBuffer++ = (UCHAR)'@';  // JIS Kanji 1978
                        }
                        SetKanjiStatus(&pwi->trm,JIS_SENDING_KANJI);
                        j += 3;
                    }

                    *WriteBuffer = *szString++;
                    *(WriteBuffer+1) = *szString++;
                    c -= 2;

                    /* convert sjis -> jis */

                    sjistojis( WriteBuffer, WriteBuffer+1 );

                    WriteBuffer += 2;
                    j += 2;

                } else {

                    /* half width area code */
                    /* if we are in Kanji mode, clear it */

                    if( GetKanjiStatus(&pwi->trm) & JIS_SENDING_KANJI ) {
                        *WriteBuffer++ = (UCHAR)0x1B; // Ecs
                        *WriteBuffer++ = (UCHAR)'(';
                        *WriteBuffer++ = (UCHAR)'J';  // JIS Roman
                        ClearKanjiStatus(&pwi->trm,JIS_SENDING_KANJI);
                        j += 3;
                    }

                    /* copy to destination */

                    *WriteBuffer++ = *szString++;
                    c--; j++;
                }
            }

        } else if (FIsEUCKanji(&pwi->trm) || FIsDECKanji(&pwi->trm)) {

            /* OUTPUT -> Japanese EUC / DEC Kanji */

            while(c > 0) {

                if (IsDBCSLeadByte(*szString)) {

                    /* full width area code */

                    *WriteBuffer = *szString++;
                    *(WriteBuffer+1) = *szString++;
                    c -= 2;

                    /* convert sjis -> euc */

                    sjistoeuc( WriteBuffer, WriteBuffer+1 );

                    WriteBuffer += 2;
                    j += 2;

                } else {

                    /* half width area code */

                    if(IsKatakana(*szString)) {
                        /* Add escape sequence for Katakana */
                        *WriteBuffer++ = (UCHAR)0x8E; // 0x8E == SS2
                        j++;
                    }

                    *WriteBuffer++ = *szString++;
                    c--; j++;

                }

            }

        } else if (FIsNECKanji(&pwi->trm)) {

            while(c > 0) {

                /* OUTPUT -> NEC Kanji */

                if (IsDBCSLeadByte(*szString)) {

                    /* full width area code */

                    if( !(GetKanjiStatus(&pwi->trm) & JIS_SENDING_KANJI ) ) {
                        *WriteBuffer++ = (UCHAR)0x1B; // Ecs
                        *WriteBuffer++ = (UCHAR)'K';  // NEC Kanji IN
                        SetKanjiStatus(&pwi->trm,JIS_SENDING_KANJI);
                        j += 2;
                    }

                    *WriteBuffer = *szString++;
                    *(WriteBuffer+1) = *szString++;
                    c -= 2;

                    /* convert sjis -> jis */

                    sjistojis( WriteBuffer, WriteBuffer+1 );

                    WriteBuffer += 2;
                    j += 2;

                } else {

                    /* half width area code */
                    /* if we are in Kanji mode, clear it */

                    if( GetKanjiStatus(&pwi->trm) & JIS_SENDING_KANJI ) {
                        *WriteBuffer++ = (UCHAR)0x1B; // Ecs
                        *WriteBuffer++ = (UCHAR)'H';  // NEC Kanji OUT
                        ClearKanjiStatus(&pwi->trm,JIS_SENDING_KANJI);
                        j += 2;
                    }

                    /* copy to destination */

                    *WriteBuffer++ = *szString++;
                    c--; j++;
                }
            }
        } else if (FIsACOSKanji(&pwi->trm)) {

            while(c > 0) {

                /* OUTPUT -> NEC Kanji */

                if (IsDBCSLeadByte(*szString)) {

                    /* full width area code */

                    if( !(GetKanjiStatus(&pwi->trm) & JIS_SENDING_KANJI ) ) {
                        *WriteBuffer++ = (UCHAR)0x1A; // Sub
                        *WriteBuffer++ = (UCHAR)'p';  // ACOS Kanji IN
                        SetKanjiStatus(&pwi->trm,JIS_SENDING_KANJI);
                        j += 2;
                    }

                    *WriteBuffer = *szString++;
                    *(WriteBuffer+1) = *szString++;
                    c -= 2;

                    /* convert sjis -> jis */

                    sjistojis( WriteBuffer, WriteBuffer+1 );

                    WriteBuffer += 2;
                    j += 2;

                } else {

                    /* half width area code */
                    /* if we are in Kanji mode, clear it */

                    if( GetKanjiStatus(&pwi->trm) & JIS_SENDING_KANJI ) {
                        *WriteBuffer++ = (UCHAR)0x1A; // Sub
                        *WriteBuffer++ = (UCHAR)'q';  // ACOS Kanji OUT
                        ClearKanjiStatus(&pwi->trm,JIS_SENDING_KANJI);
                        j += 2;
                    }

                    /* copy to destination */

                    *WriteBuffer++ = *szString++;
                    c--; j++;
                }
            }
        }

        /* write to network */
        FWriteToNet( ( struct _WI * )hwnd, (LPSTR)pchNBBuffer, j);

    } else {

        /* write to network */
        FWriteToNet( ( struct _WI * )hwnd, (LPSTR)szString, c);

    }
}

VOID SetImeWindow(TRM *ptrm)
{
    COMPOSITIONFORM cf;

    cf.dwStyle = CFS_POINT;
    cf.ptCurrentPos.x = aixPos(ptrm->dwCurChar-ui.nScrollCol);
    cf.ptCurrentPos.y = aiyPos(ptrm->dwCurLine-ui.nScrollRow);
    
    SetRectEmpty(&cf.rcArea);

    ImmSetCompositionWindow(hImeContext,&cf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\client\wintel.h ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
#include "ime.h"

#define NAMSZ   255
#ifndef WHISTLER_BUILD
#include "winsock2.h"
#include "ws2tcpip.h"
#include "wspiapi.h"
#include "mswsock.h"
#else
#include <winsock2.h>
#include <ws2tcpip.h>
#include <wspiapi.h>
#include <mswsock.h>
#endif

#include "wintelsz.h"

//#define VT52    1

/* display rows array indices */
#define idwDR25         0
#define idwDR43         1
#define idwDR50         2
#define idwDRCustom     3

/* resource #defines */
#define IDM_CONNECT  100
#define IDM_HANGUP   101
#define IDM_EXIT     102

#define IDM_TRIMSPACE   124

#define IDM_LOCALECHO   209
#define IDM_TEXTCOLOUR  210
#define IDM_BACKCOLOUR  211
#define IDM_UNDERLINECURSOR     212
#define IDM_BLINKCURSOR 213
#define IDM_VT100CURSORKEYS     214
#define IDM_VT52MODE    215
#define IDM_VT80MODE    216
#define IDM_VT100MODE   217

#define IDM_TERMPREF    225
#define IDM_BLOCKCURSOR 226

#define IDM_KANJI_LIST  229

#ifdef MAKAG_AMBIGUOUS
#define IDM_VT100MODE   216 // Why is FE value 217?
#define IDM_TERMPREF    217 // Why is FE value 225?
#define IDM_BLOCKCURSOR 218 // Why is FE value 226?
#endif

#define IDM_LOGGING     219
#define IDM_STLOGGING   220

#define IDM_INDEX    400
#define IDM_SEARCH   401
#define IDM_HELP     402
#define IDM_ABOUT    403

// MohsinA, 12-Dec-96.
#ifdef DBG
#define IDM_DBG_FONT        500
#define IDM_DBG_USERINFO    501
#define IDM_DBG_GLOBALS     502
#endif

#define IDC_START_LOGGING 117
#define IDC_APPEND 118

#define ID_WINTEL_HELP          16

#define CID_HOSTNAME            100
#define CID_DISPLAYLINE         101
#define CID_USESTDNETBIOS       102
#define CID_HOSTNAME2           103
#define CID_SERVNAME            104
#define CID_TERMTYPENAME        105

#define IDS_DEBUGFLAGS          121
#define IDS_PROMPTFLAGS         122
#define IDS_HELPFILE            126
#define IDS_TITLEBASE           127
#define IDS_TITLENONE           128
#define IDS_APPNAME             129
#define IDS_CONNECT             130
#define IDS_CONNECTIONLOST      132
#define IDS_CONNECTFAILED       135
#define IDS_CANTACCESSSETTINGS  136
#define IDS_OOM                 137
#define IDS_TOOMUCHTEXT         138
#define IDS_VERSION             139
#define IDS_CONNECTING          141
#define IDS_USAGE               142

#define IDS_CANT_INIT_SOCKETS   181
#define IDS_CONNECTFAILEDMSG    185  
#define IDS_ONPORT              900
#define IDS_KANJI_JIS           186
#define IDS_KANJI_SJIS          187
#define IDS_KANJI_EUC           188
#define IDS_KANJI_DEC           189
#define IDS_KANJI_NEC           190
#define IDS_KANJI_JIS78         191
#define IDS_KANJI_ACOS          192
#define IDS_BUGEMUFLAGS         193
#define IDS_ACOSFLAG            194
#define IDS_VT100KANJI_EMULATION            195

#ifdef DBCS
#define IDS_INPROPERFONT        200
#endif

#define IDS_SENT_BRK            243
#define IDS_INFO_BANNER         250
#define IDS_ESCAPE_CHAR         903
#define IDS_PROMPT_STR          251
#define IDS_INVALID_STR         252
#define IDS_HELP_STR            253
#define IDS_BUILD_INFO          254

#define IDS_CLOSE               255
#define IDS_DISPLAY             256
#define IDS_HELP                257
#define IDS_OPEN                258
#define IDS_OPENTO              901
#define IDS_OPENUSAGE           902
#define IDS_QUIT                259
#define IDS_SET                 260
#define IDS_STATUS              261
#define IDS_UNSET               262
#define IDS_NO_ESCAPE           263
#define IDS_WILL_AUTH           264
#define IDS_WONT_AUTH           265
#define IDS_LOCAL_ECHO_ON       266
#define IDS_LOCAL_ECHO_OFF      267

#define IDS_CONNECTED_TO        268
#define IDS_NOT_CONNECTED       269
#define IDS_NEGO_TERM_TYPE      270
#define IDS_PREF_TERM_TYPE      271

#define IDS_SET_FORMAT          272
#define IDS_SET_HELP            273
#define IDS_UNSET_FORMAT        274
#define IDS_UNSET_HELP          275

#define IDS_ENABLE_IME_SUPPORT  276
#define IDS_ENABLE_IME_FORMAT   277
#define IDS_ENABLE_IME_HELP     278
#define IDS_ENABLE_IME_ON       279
#define IDS_DISABLE_IME_SUPPORT 280
#define IDS_DISABLE_IME_FORMAT  281
#define IDS_DISABLE_IME_HELP    282

#define IDS_SUPPORTED_TERMS     284

#define IDS_SET_HELP_JAP        285
#define IDS_UNSET_HELP_JAP      286
#define IDS_HELP_STR_JAP        287

#define IDS_ERR_LICENSE         288
#define IDS_CONTINUE            289
#define IDS_NO_EMULATION        290

#define IDS_NTLM_PROMPT         904



#define IDS_LOGGING_ON          291
#define IDS_LOGGING_OFF         292
#define IDS_LOGFILE_NAME        293
#define IDS_BAD_LOGFILE         294
#define IDS_NO_LOGFILE          295

#define IDS_SEND                296
#define IDS_SENT_AO             297
#define IDS_SENT_AYT            298
#define IDS_SENT_ESC            299
#define IDS_SENT_IP             300
#define IDS_SEND_HELP           301
#define IDS_SEND_FORMAT         302
#define IDS_SENT_CHARS          303
#define IDS_SENT_SYNCH          304
#define IDS_DELASBACKSPACE      305
#define IDS_BACKSPACEASDEL      306
#define IDS_DELASDEL            307
#define IDS_BACKSPACEASBACKSPACE 308
#define IDS_CRLF                309
#define IDS_CR                  310
#define IDS_STREAM              311
#define IDS_CONSOLE             312
#define IDS_CURRENT_MODE        313
#define IDS_STREAM_ONLY         314
#define IDS_CONSOLE_ONLY        315
#define IDS_SUPPORTED_MODES    316
#define IDS_SET_CODESET_FORMAT 317
#define IDS_INVALID_ESC_KEY     318

#define MSG_LOGGING_ON          "Client logging on\r\n"
#define MSG_DELASDEL            "Delete will be sent as delete\r\n"
#define MSG_BACKSPACEASBACKSPACE "Backspace will be sent as backspace\r\n"
#define MSG_DELASBACKSPACE      "Delete will be sent as backspace\r\n"
#define MSG_BACKSPACEASDEL      "Backspace will be sent as delete\r\n"
#define MSG_SENT_AO             "Sent abort output\r\n"
#define MSG_SENT_AYT            "Sent are you there\r\n"
#define MSG_SENT_BRK            "Sent break\r\n"
#define MSG_SENT_ESC            "Sent escape character\r\n"
#define MSG_SENT_IP             "Sent interrupt process\r\n"
#define MSG_SENT_SYNCH          "Sent command synch\r\n"
#define MSG_SENT_CHARS          "Sent string %s\r\n"
#define MSG_SEND_HELP           "ayt\t\tSend telnet command 'Abort Output'\r\nayt\t\tSend telnet command 'Are You There'\r\nbrk\tSend telnet command brk\r\nesc\t\tSend current telnet escape character\r\nip\t\tSend telnet command 'Interrupt Process'\r\nany other string will be sent as it is to the telnet server\r\n"
#define MSG_SEND_FORMAT         "Format is 'send String'\r\ntype 'send ?' for help\r\n"
#define MSG_NOT_CONNECTED       "Not Connected\r\n"
#define MSG_CRLF                "New line mode - Causes return key to send CR, LF\r\n"
#define MSG_CR                  "Line feed mode - Causes return key to send CR\r\n"
#define MSG_STREAM              "Stream mode - Works well with command line applications\r\n"
#define MSG_CONSOLE             "Console mode - Works well with screen applications like vi\r\n"    
#define MSG_CURRENT_MODE        "Current mode: "
#define MSG_STREAM_ONLY         "Stream\r\n"
#define MSG_CONSOLE_ONLY        "Console\r\n"
#define MSG_SUPPORTED_MODES     "Supported modes are console and stream only.\r\n"
#define MSG_SET_CODESET_FORMAT  "Supported codesets are Shift JIS, Japanese EUC, JIS Kanji, JIS Kanji(78), DEC Kanji and NEC Kanji only.\r\n"
#define MSG_INVALID_ESC_KEY       "Invalid Key Combination\r\n"

#define STREAM  "stream"
#define CONSOLE "console"

#define ATTRIB_INVERT           1

#define wKeyPressed     ((WORD)0x8000)

#define SV_PROGRESS                     (WM_USER+350)
#define SV_END                          (WM_USER+351)

#define SV_DATABUF                      (0x4000)

#define SV_DONE                         0
#define SV_CONNECT                      1
#define SV_DISCONNECT           2
#define SV_HANGUP                       3
#define SV_QUIT                         4

#define BLOCK_CURSOR        50
#define NORMAL_CURSOR       25
#define VK_INSERT_KEY		45


typedef struct _SupportedKanji
{
        DWORD   KanjiID;
        DWORD   KanjiEmulationID;
        DWORD   KanjiMessageID;
        DWORD   KanjiItemID;
        TCHAR   KanjiDescription[255];
} KANJILIST;

typedef struct _SendTelInfo
{
        LONG    lExit;
        LONG    lCleanup;
        HANDLE  hthread;
        HANDLE  hfile;
        UCHAR   *puchBuffer;
        DWORD   cbFile;
        DWORD   cbReadTotal;
        volatile DWORD  dwCommand;
        DWORD   dwThreadId;
        int             nSessionNumber;
} SVI;

#ifdef USETCP
/* Data structure and #defines for TCP stuff */
#define READ_BUF_SZ             (4096)
#define DATA_BUF_SZ             (2*READ_BUF_SZ)
#endif

#define nSessionNone    ((int)-1)

typedef struct _NetOBJData
{
        char                    szHostName[NAMSZ+1];
        int                     SessionNumber;

        SOCKET                  hsd;
        char                    szResolvedHost[MAXGETHOSTSTRUCT+1];
        struct addrinfo 		*ai;

        //
        //  Options can cross packet boundaries.  This is the number of bytes
        //  left over from the previous packet.  It is contained in the
        //  first cbOld bytes of lpTempBuffer.
        //

        int                     cbOld;

        LPSTR                   lpTempBuffer;

        //
        //  To prevent endless loops doing option negotiation, we will
        //  only respond to Will Echo and Will Suppress Go Ahead once
        //

        BOOL                    fRespondedToWillEcho;
        BOOL                    fRespondedToWillSGA;
        BOOL                    fRespondedToDoAUTH;
        BOOL                    fRespondedToDoNAWS;


        LPSTR                   lpReadBuffer;
#ifdef __NOT_USED
        WORD                    iHead,
                                iTail;
        char                    achData[DATA_BUF_SZ];
#endif
} NETDATA, *LPNETDATA;


#define cchMaxHostName  (NAMSZ+1)

/* don't prompt for dest. dir on dl */
#define fdwSuppressDestDirPrompt ((DWORD)0x01)

/* Mask off high bit for ASCII-only */
#define fdwASCIIOnly            ((DWORD)0x01)
/* Display output stream for debugging */
#define fdwDebugOutput          ((DWORD)0x02)
/* Don't pass on VT100 function or cursor keys */
#define fdwNoVT100Keys          ((DWORD)0x04)
/* Replace TABs by up to 8 spaces */
#define fdwTABtoSpaces          ((DWORD)0x08)
/* Echo user input to display */
#define fdwLocalEcho            ((DWORD)0x0010)
/* VT100 Cursor Keys mode */
#define fdwVT100CursorKeys      ((DWORD)0x0020)
/* VT52 Mode */
#define fdwVT52Mode                     ((DWORD)0x0040)
/* VT80 Mode */
#define fdwVT80Mode                     ((DWORD)0x0080)
/* Kanji Mode Mask */
#define fdwKanjiModeMask                ((DWORD)0xFF00)
/* DEC KanjiMode */ 
#define fdwDECKanjiMode                 ((DWORD)0x0400)
/* NEC Kanji Mode */
#define fdwNECKanjiMode                 ((DWORD)0x0800)
/* JIS78 Kanji Mode */ 
#define fdwJIS78KanjiMode               ((DWORD)0x1000)
/* JIS Kanji Mode */
#define fdwJISKanjiMode                 ((DWORD)0x2000)
/* ShiftJIS Kanji Mode */
#define fdwSJISKanjiMode                ((DWORD)0x4000)
/* EUC Kanji Mode */
#define fdwEUCKanjiMode                 ((DWORD)0x8000)
/* ACOS Kanji Mode */
#define fdwACOSKanjiMode                ((DWORD)0x0200)

/* Enable IME Support */
#define fdwEnableIMESupport             ((DWORD)0x100000)

/* CRLF sending ==== for backward compatibility with w2k telnet client */
#define fdwOnlyCR               ((DWORD)0x80000000)


/* Is the cursor a block or underline? */
#define fdwCursorUnderline      ((DWORD)0x01)
/* Is the cursor supposed to blink? */
#define fdwCursorBlink          ((DWORD)0x02)
/* Are we in QuickEdit mode? */
#define fdwQuickEditMode        ((DWORD)0x04)
/* Trim whitespace at end of every line? */
#define fdwTrimEndWhitespace    ((DWORD)0x08)

typedef enum _Term_Type {
    TT_UNKNOWN = -1,
    TT_ANSI = 0,
    TT_VT100,
    TT_VT52,
    TT_VTNT,
    TT_LAST = TT_VTNT
} TERM_TYPE;


typedef struct _USERINFO
{
        DWORD   dwMaxRow;       /* number of rows in display */
        DWORD   dwMaxCol;       /* number of columns in display */
        DWORD   dwClientRow;    /* number of visible rows */
        DWORD   dwClientCol;    /* number of visible columns */
        DWORD   nScrollRow;     /* scroll row */
        DWORD   nScrollCol;     /* scroll column */
        DWORD   nScrollMaxRow;  /* max scroll row */
        DWORD   nScrollMaxCol;  /* max scroll column */
        DWORD   nCyChar;        /* char height */
        DWORD   nCxChar;        /* char width */
        DWORD   nLeftoff;       /* Leftoff */
        DWORD   fPrompt;        /* prompt bit flags */
        DWORD   fDebug;         /* Debug bit flags */
        DWORD   fFlushOut;      /* flushing output */
        HANDLE  hLogFile;       /* Indicates whether logging is turned on now */
        DWORD   bLogging;       /* Handle for the logfile */
        DWORD   bAppend;
        DWORD   nottelnet;
        DWORD   honor_localecho;    // This is false till authentication happens, only to a telnet server
        DWORD   dwCrLf;
        DWORD   fBugEmulation;    /* Bug Emulation bit flags */
        DWORD   fAcosSupportFlag; /* ACOS-KANJI Support flag */
        LOGFONT lf;                     /* description of font used */
        DWORD   bWillAUTH;        

        DWORD   bPromptForNtlm;
        DWORD   bSendCredsToRemoteSite;

} UI;

#define fBugEmulationDBCS    ((DWORD)0x0001)
#define fAcosSupport         ((DWORD)0x0001)

#define uTerminalTimerID        ((UINT)2)
#define uCursorBlinkMsecs       ((UINT)250)

/* VT100 Flags */
#define dwVTArrow       ((DWORD)0x0001)
#define dwVTKeypad      ((DWORD)0x0002)
#define dwVTWrap        ((DWORD)0x0004)
#define dwVT52          ((DWORD)0x0008)
#define dwVTCursor      ((DWORD)0x0010)
#define dwVTScrSize     ((DWORD)0x0020)
#define dwDECCOLM       ((DWORD)0x0040)
#define dwDECSCNM       ((DWORD)0x0080)
#define dwLineMode      ((DWORD)0x0100)
#define dwInsertMode    ((DWORD)0x0200)
#define dwVT52Graphics  ((DWORD)0x0400)
#define dwKeyLock       ((DWORD)0x0800)
#define dwVT80          ((DWORD)0x1000)

#define FIsVTArrow(ptrm)        ((ptrm)->dwVT100Flags & dwVTArrow)
#define SetVTArrow(ptrm)        ((ptrm)->dwVT100Flags |= dwVTArrow)
#define ClearVTArrow(ptrm)      ((ptrm)->dwVT100Flags &= ~dwVTArrow)

#define FIsVTKeypad(ptrm)       ((ptrm)->dwVT100Flags & dwVTKeypad)
#define SetVTKeypad(ptrm)       ((ptrm)->dwVT100Flags |= dwVTKeypad)
#define ClearVTKeypad(ptrm)     ((ptrm)->dwVT100Flags &= ~dwVTKeypad)

#define FIsVTWrap(ptrm) ((ptrm)->dwVT100Flags & dwVTWrap)
#define SetVTWrap(ptrm) ((ptrm)->dwVT100Flags |= dwVTWrap)
#define ClearVTWrap(ptrm)       ((ptrm)->dwVT100Flags &= ~dwVTWrap)

#define SetANSI(ptrm)   ((ptrm)->CurrentTermType = TT_ANSI)

#define FIsVT52(ptrm)   ((ptrm)->CurrentTermType == TT_VT52)
#define SetVT52(ptrm)   ((ptrm)->CurrentTermType = TT_VT52)

#define FIsVT80(ptrm)   ((ptrm)->dwVT100Flags & dwVT80)
#define SetVT80(ptrm)   ((ptrm)->dwVT100Flags |= dwVT80)
#define ClearVT80(ptrm) ((ptrm)->dwVT100Flags &= ~dwVT80)

#define FIsVTCursor(ptrm)       ((ptrm)->dwVT100Flags & dwVTCursor)
#define SetVTCursor(ptrm)       ((ptrm)->dwVT100Flags |= dwVTCursor)
#define ClearVTCursor(ptrm)     ((ptrm)->dwVT100Flags &= ~dwVTCursor)

#define FIsVTScrSize(ptrm)      ((ptrm)->dwVT100Flags & dwVTScrSize)
#define SetVTScrSize(ptrm)      ((ptrm)->dwVT100Flags |= dwVTScrSize)
#define ClearVTScrSize(ptrm)    ((ptrm)->dwVT100Flags &= ~dwVTScrSize)

#define FIsDECCOLM(ptrm)        ((ptrm)->dwVT100Flags & dwDECCOLM)
#define SetDECCOLM(ptrm)        ((ptrm)->dwVT100Flags |= dwDECCOLM)
#define ClearDECCOLM(ptrm)      ((ptrm)->dwVT100Flags &= ~dwDECCOLM)

#define FIsDECSCNM(ptrm)        ((ptrm)->dwVT100Flags & dwDECSCNM)
#define SetDECSCNM(ptrm)        ((ptrm)->dwVT100Flags |= dwDECSCNM)
#define ClearDECSCNM(ptrm)      ((ptrm)->dwVT100Flags &= ~dwDECSCNM)

#define FIsLineMode(ptrm)       ((ptrm)->dwVT100Flags & dwLineMode)
#define SetLineMode(ptrm)       ((ptrm)->dwVT100Flags |= dwLineMode)
#define ClearLineMode(ptrm)     ((ptrm)->dwVT100Flags &= ~dwLineMode)

#define FIsInsertMode(ptrm)     ((ptrm)->dwVT100Flags & dwInsertMode)
#define SetInsertMode(ptrm)     ((ptrm)->dwVT100Flags |= dwInsertMode)
#define ClearInsertMode(ptrm)   ((ptrm)->dwVT100Flags &= ~dwInsertMode)

#define FIsVT52Graphics(ptrm)   ((ptrm)->dwVT100Flags & dwVT52Graphics)
#define SetVT52Graphics(ptrm)   ((ptrm)->dwVT100Flags |= dwVT52Graphics)
#define ClearVT52Graphics(ptrm) ((ptrm)->dwVT100Flags &= ~dwVT52Graphics)

#define FIsKeyLock(ptrm)        ((ptrm)->dwVT100Flags & dwKeyLock)
#define SetKeyLock(ptrm)        ((ptrm)->dwVT100Flags |= dwKeyLock)
#define ClearKeyLock(ptrm)      ((ptrm)->dwVT100Flags &= ~dwKeyLock)

/* JIS Kanji Mode */
#define dwJISKanji              ((DWORD)0x0001)
/* Shift JIS Kanji Mode */
#define dwSJISKanji             ((DWORD)0x0002)
/* EUC Kanji Mode */
#define dwEUCKanji              ((DWORD)0x0004)
/* NEC Kanji Mode */
#define dwNECKanji              ((DWORD)0x0008)
/* DEC Kanji Mode */
#define dwDECKanji              ((DWORD)0x0010)
/* JIS78 Kanji Mode */
#define dwJIS78Kanji            ((DWORD)0x0020)
/* ACOS Kanji Mode */
#define dwACOSKanji             ((DWORD)0x0040)

#define ClearKanjiFlag(ptrm)    ((ptrm)->dwKanjiFlags = (DWORD)0)

#define FIsJISKanji(ptrm)       ((ptrm)->dwKanjiFlags & dwJISKanji)
#define SetJISKanji(ptrm)       ((ptrm)->dwKanjiFlags |= dwJISKanji)
#define ClearJISKanji(ptrm)     ((ptrm)->dwKanjiFlags &= ~dwJISKanji)

#define FIsJIS78Kanji(ptrm)     ((ptrm)->dwKanjiFlags & dwJIS78Kanji)
#define SetJIS78Kanji(ptrm)     ((ptrm)->dwKanjiFlags |= dwJIS78Kanji)
#define ClearJIS78Kanji(ptrm)   ((ptrm)->dwKanjiFlags &= ~dwJIS78Kanji)

#define FIsSJISKanji(ptrm)      ((ptrm)->dwKanjiFlags & dwSJISKanji)
#define SetSJISKanji(ptrm)      ((ptrm)->dwKanjiFlags |= dwSJISKanji)
#define ClearSJISKanji(ptrm)    ((ptrm)->dwKanjiFlags &= ~dwSJISKanji)

#define FIsEUCKanji(ptrm)       ((ptrm)->dwKanjiFlags & dwEUCKanji)
#define SetEUCKanji(ptrm)       ((ptrm)->dwKanjiFlags |= dwEUCKanji)
#define ClearEUCKanji(ptrm)     ((ptrm)->dwKanjiFlags &= ~dwEUCKanji)

#define FIsNECKanji(ptrm)       ((ptrm)->dwKanjiFlags & dwNECKanji)
#define SetNECKanji(ptrm)       ((ptrm)->dwKanjiFlags |= dwNECKanji)
#define ClearNECKanji(ptrm)     ((ptrm)->dwKanjiFlags &= ~dwNECKanji)

#define FIsDECKanji(ptrm)       ((ptrm)->dwKanjiFlags & dwDECKanji)
#define SetDECKanji(ptrm)       ((ptrm)->dwKanjiFlags |= dwDECKanji)
#define ClearDECKanji(ptrm)     ((ptrm)->dwKanjiFlags &= ~dwDECKanji)

#define FIsACOSKanji(ptrm)      ((ptrm)->dwKanjiFlags & dwACOSKanji)
#define SetACOSKanji(ptrm)      ((ptrm)->dwKanjiFlags |= dwACOSKanji)
#define ClearACOSKanji(ptrm)    ((ptrm)->dwKanjiFlags &= ~dwACOSKanji)

#define FIsKanjiMode(ptrm,KanjiFlag)   ((ptrm)->dwKanjiFlags & (KanjiFlag))
#define SetKanjiMode(ptrm,KanjiFlag)   ((ptrm)->dwKanjiFlags |= (KanjiFlag))
#define ClearKanjiMode(ptrm,KanjiFlag) ((ptrm)->dwKanjiFlags &= ~(KanjiFlag))

/* General */
#define SINGLE_SHIFT_2          ((DWORD)0x0001)
#define SINGLE_SHIFT_3          ((DWORD)0x0002)

/* JIS */
/* for recieve status */
#define JIS_INVOKE_MB           ((DWORD)0x0010)
#define JIS_INVOKE_SB           ((DWORD)0x0020)
#define JIS_KANJI_CODE          ((DWORD)0x0040)
/* for send status */
#define JIS_SENDING_KANJI       ((DWORD)0x0080)

#define CLEAR_ALL               ((DWORD)0xFFFF)

#define GetKanjiStatus(ptrm)       ((ptrm)->dwKanjiStatus)
#define SetKanjiStatus(ptrm,val)   ((ptrm)->dwKanjiStatus |= val)
#define ClearKanjiStatus(ptrm,val) ((ptrm)->dwKanjiStatus &= ~val)

#define NUMBER_OF_KANJI         7

typedef struct _TERM
{
    TERM_TYPE   CurrentTermType;        /* the Term type that has been 
                                          negotiated between server & client. This
                                        is ANSI to start with i.e. if no negotiation
                                        happens. */
    TERM_TYPE   SentTermType;           /* this is the last term type that we sent
                                        to the Server during TermType negotiation */
    TERM_TYPE   RequestedTermType;      /* this is the preferred term type of the user */
    TERM_TYPE   FirstTermTypeSent;      /* this is the first term type sent by us */
        DWORD   dwCurLine;
        DWORD   dwCurChar;
        DWORD   dwEscCodes[10];
        DWORD   rgdwGraphicRendition[10];
        INT     dwIndexOfGraphicRendition;
        DWORD   cEscParams;
        DWORD   dwScrollTop;
        DWORD   dwScrollBottom;
        DWORD   fEsc;
        DWORD   dwSum;
        UCHAR*  puchCharSet;
        char    G0, G1;
        int     currCharSet;
        UINT    uTimer;
        DWORD   cTilde;
        DWORD   dwVT100Flags;
        BOOL    fRelCursor;
        BOOL    fSavedState;
        BOOL    fInverse;
        BOOL    fHideCursor;
        BOOL    fCursorOn;
        BOOL    fFlushToEOL;
        BOOL    fLongLine;
        UCHAR   rgchBufferText[256];
        int     cchBufferText;
        DWORD   dwCurCharBT;
        DWORD   dwCurLineBT;
        BOOL    fInverseBT;

        DWORD   rgdwSaveGraphicRendition[10];
        INT     dwSaveIndexOfGraphicRendition;
        char    cSaveG0, cSaveG1;
        int     iSaveCurrCharSet;
        UCHAR*  pSaveUchCharSet;
        DWORD   dwSaveChar;
        DWORD   dwSaveLine;
        DWORD   dwSaveRelCursor;
        DWORD   dwKanjiFlags;
        DWORD   dwKanjiStatus;
        UCHAR   *g0,*g1,*g2,*g3;
        UCHAR   *CurrentCharSet[2];
        UCHAR   *PreviousCharSet[2];
} TRM;

#define uRetryTimerID   ((UINT)1)

typedef struct _AUTORETRY
{
        HWND    hwnd;
        LPSTR   szHostName;
        LPNETDATA       lpData;
        UINT    uTimer;
} AR;

#define dwNothingChanged        ((DWORD)0)
#define dwYChanged      ((DWORD)0x01)
#define dwXChanged      ((DWORD)0x02)

#define dwForceNone     ((DWORD)0)
#define dwForceOn       ((DWORD)0x01)
#define dwForceOff      ((DWORD)0x02)

#define SMALL_STRING  64

typedef struct _SPB
{
    POINT   ptCursor;       /* cursor point */
    POINT   ptAnchor;       /* anchor point */
    RECT    rectSelect;     /* selection rect */
    DWORD   dwFlags;
    WPARAM  wData;
} SPB;

typedef enum {
    Connecting,
    Authenticating,
    AuthChallengeRecvd,
    Telnet,
    Interactive
} SESSION_STATE;

/* Window Information */

#define WL_TelWI                (0)

typedef struct _WI
{
    NETDATA         nd;
    TRM             trm;
    DWORD           ichTelXfer;
    SVI             svi;
    SPB             spb;
    HWND            hwnd;
    HANDLE          hNetworkThread;
    HANDLE          hOutput;
    HANDLE          hInput;
    CONSOLE_SCREEN_BUFFER_INFO sbi;
    CHAR_INFO       cinfo;
    SESSION_STATE   eState;
} WI;


extern  UI              ui;

extern  int             iCursorHeight;  /* height of cursor */
extern  int             iCursorWidth;   /* width of cursor */

extern  BOOL    fConnected;             /* if we're connected to a machine */
extern  BOOL    fHungUp;

extern  HWND    hwndMain;               /* HANDLE to main display window */
extern  int     spec_port;              /* user specified port number */

extern  CHAR_INFO   *g_rgciCharInfo;
extern  UCHAR       *g_rgchRow;             /* One row of char */

extern WCHAR g_chEsc;
extern SHORT g_EscCharShiftState;
extern BOOL g_bDontNAWSReceived;
extern TCHAR g_szLogFile[];


POINT _ptCharSize;

#define aixPos( col ) ( (col)*_ptCharSize.x)
#define aiyPos( col ) ( (col)*_ptCharSize.y)

#ifdef  __NOT_USED
extern  UCHAR   *pchNBBuffer;
#endif

extern  HFONT   hfontDisplay;                   /* display font */
extern  DWORD   rgdwCustColours[16];    /* custom colour array */

extern  DWORD   cBlocks;

extern  TCHAR   rgchHostName[cchMaxHostName];   /* name of host we're connected to */
extern  TCHAR g_szPortNameOrNo[cchMaxHostName];

extern  int     rgService;
#if  0
extern  char    rgchDbgBfr[80];
#endif

#ifdef TCPTEST
extern UCHAR   DebugBuffer[256];
#endif


extern UCHAR rgchCharSetWorkArea[256];

extern UCHAR rgchNullChars[128];
extern UCHAR rgchJISRomanChars[128];
extern UCHAR rgchJISKanjiChars[128];
extern UCHAR rgchEUCKanjiChars[128];
extern UCHAR rgchDECKanjiChars[128];
extern UCHAR rgchIBMAnsiChars[128];
extern UCHAR rgchGraphicsChars[128];
extern UCHAR rgchKatakanaChars[128];
extern UCHAR rgchDefaultRightChars[128];

extern KANJILIST KanjiList[NUMBER_OF_KANJI];
extern BOOL fHSCROLL;
extern TCHAR szVT100KanjiEmulation[SMALL_STRING + 1];

extern  UCHAR rgchNormalChars[256];
extern  UCHAR rgchAlternateChars[256];
extern  UCHAR rgchSpecialGraphicsChars[256];
extern  UCHAR rgchUKChars[256];

extern CHAR* szUser;
extern BOOL  g_bSendDelAsBackSpace;
extern BOOL  g_bSendBackSpaceAsDel;
extern DWORD g_dwSockErr;

extern HANDLE g_hTelnetPromptConsoleBuffer;
extern HANDLE g_hSessionConsoleBuffer;

int PASCAL WinMain(HINSTANCE, HINSTANCE, LPSTR, int);
int FInitApplication( int argc, TCHAR **argv, WI *pwi );
BOOL FInitInstance(HINSTANCE, int);
LRESULT CALLBACK MainWndProc(HWND, UINT, WPARAM, LPARAM);
#ifdef WIN32
BOOL APIENTRY About(HWND, UINT, WPARAM, LPARAM);
#endif
BOOL APIENTRY Konnect(HWND, UINT, WPARAM, LPARAM);
void CenterDialog(HWND, HWND);
void GetUserSettings(UI *);
void SetUserSettings(UI *);
void CheckEscCharState( USHORT *ptrvkBracket, UINT *ptriRet, WCHAR chEscKey, LPWSTR szEscCharShiftState );
void HandleCharMappings(WI* pWI, INPUT_RECORD* pInputRecord);

HMENU HmenuGetMRUMenu(HWND, UI *);

/* netio.c */

BOOL FCommandPending(WI *);
BOOL FConnectToServer(WI *, LPSTR, LPNETDATA);
int FWriteToNet(WI *, LPSTR addr, int cnt);

void FCloseConnection(HWND hwnd);
BOOL FPostReceive( LPNETDATA );
#ifdef  __NOT_USED
BOOL FStoreData(LPNETDATA, int);
WORD WGetData(LPNETDATA, LPSTR, WORD);
#endif

#ifdef USETCP
void FProcessFDRead(HWND hwnd);
void FProcessFDOOB(HWND hwnd);
void FProcessFDWrite(HWND hwnd);
void FSendSynch(HWND hwnd);
void FSendTelnetCommands(HWND hwnd, char chCommand);
void FSendChars( HWND, WCHAR[], int );
#endif

BOOL FTelXferStart(WI *, int);
BOOL FTelXferEnd(WI *, DWORD);
BOOL FGetFileName(WI *, char *, char *);
DWORD WINAPI SVReceive(SVI *);
BOOL FHangupConnection(WI *, LPNETDATA);
BOOL APIENTRY ConnectAutoRetry(HWND, UINT, WPARAM, LPARAM);
BOOL APIENTRY ConnectFailed(HWND, UINT, WPARAM, LPARAM);

/* mcp.c */
void MarkModeOn(WI *, DWORD);
void MarkModeOff( WI * );
void DoCursorFlicker(HWND, DWORD);
void InvertSelection(HWND, RECT *);
void ExtendSelection(HWND, POINT *, DWORD);
void HandleMCPKeyEvent(HWND, WPARAM, LPARAM);
void HandleMCPMouseEvent(HWND, UINT, WPARAM, LPARAM);
void SetWindowTitle(HWND, DWORD, LPSTR);

/* trmio.c */
void RecalcWindowSize( HWND );
void ReSizeWindow( HWND , long, long );
                                 // was SHORT/SHORT. MohsinA, 10-Dec-96.
void ClearScreen(WI *pwi, TRM *, DWORD);
void DoTermReset(WI *pwi, TRM *);
void DoIBMANSIOutput(WI *, TRM *, DWORD, UCHAR *);
BOOL DoVTNTOutput(WI *, TRM *, int, UCHAR *);
void ClearScreen1(HANDLE hStdout);
//void SetDisplaySize(HWND, DWORD, DWORD *);
void HandleCharEvent(WI *, CHAR, DWORD);
BOOL FHandleKeyDownEvent(WI *, CHAR, DWORD);
void CheckForChangeInWindowSize( );

//RR: BOOL IsDBCSCharPoint(POINT *);
void AlignDBCSPosition(POINT *, BOOL);
void AlignDBCSPosition2(POINT *, LPCSTR , BOOL);
void SetupCharSet(TRM *);
void SetCharSet(TRM *, INT, UCHAR *);
void PushCharSet( TRM *, INT, UCHAR *);
void PopCharSet( TRM *, INT);
void FWriteTextDataToNet(HWND, LPSTR, int);
void SetIMEConvertWindowTimer(HWND, BOOL);
void SetIMEConvertPositionAndFont(HWND, UINT, UINT, BOOL);

void SetEscapeChar( WCHAR );

BOOL InitLogFile( LPTSTR );
BOOL CloseLogging( );

#define GRAPHIC_LEFT    0x00
#define GRAPHIC_RIGHT   0x80


extern HIMC hImeContext;

/* definition for DBCS support */

#define IS_ANY_DBCS_CHARSET( CharSet ) ( ((CharSet) == SHIFTJIS_CHARSET)    ? TRUE :    \
                                         ((CharSet) == HANGEUL_CHARSET)     ? TRUE :    \
                                         ((CharSet) == CHINESEBIG5_CHARSET) ? TRUE :    \
                                         ((CharSet) == GB2312_CHARSET)      ? TRUE : FALSE )


void ErrorMessage(LPCTSTR pStr1, LPCTSTR pStr2);
void ConnectTimeErrorMessage(LPCTSTR pStr1, LPCTSTR pStr2);

/* Owner Notification Messages */
#define NN_RECV         (WM_USER+400)  // wParam is count of current bytes in
                                       //    the buffer.
#define NN_LOST         (WM_USER+401)  // Connection is lost.
#define NN_OVERRUN      (WM_USER+402)  // internal buffer overrun
#define NN_HOSTRESOLVED (WM_USER+403)  // Usage message box

#define MAX_STRING_LENGTH 512

#define MAX_BUFFER_SIZE  2048

#define ARRAY_SIZE(sz) (sizeof(sz)/sizeof((sz)[0]))

#define USER             "USER"
#define WIN32_STRING     "WIN32"
#define SYSTEMTYPE       "SYSTEMTYPE"
#define TELNET_PORT 23

/* Winsock messages */
#define WS_ASYNC_SELECT (WM_USER+500)  // WSAAsyncSelect Occured

#define ALT_PRESSED (LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED)
#define CTRL_PRESSED (LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED)

#define N_BITS_IN_BYTE 8 // fact of life
#define N_BITS_IN_UINT (sizeof(UINT) * N_BITS_IN_BYTE)

// General Purpose Bit Array manipulation macros
#define BitFlagSetON(pBitFlagArray, iBit) (pBitFlagArray[(iBit)/N_BITS_IN_UINT]|=(0x1<<((iBit)%N_BITS_IN_UINT))) 
#define BitFlagSetOFF(pBitFlagArray, iBit) (pBitFlagArray[(iBit)/N_BITS_IN_UINT]&=(~(0x1<<((iBit)%N_BITS_IN_UINT))))
#define BitFlagReverse(pBitFlagArray, iBit) (pBitFlagArray[(iBit)/N_BITS_IN_UINT] ^= (0x1<<((iBit)%N_BITS_IN_UINT)))
#define FBitFlag(pBitFlagArray, iBit) (pBitFlagArray[(iBit)/N_BITS_IN_UINT] & (0x1<<((iBit)%N_BITS_IN_UINT)))

extern UINT gfCodeModeFlags[];
enum
    {
    eCodeModeMin, // This must be present so that eCodeModeMax becomes positive
    eCodeModeFarEast = 0, // The zeroth one can be same as the eCodeModeMin
    eCodeModeVT80,
    eCodeModeIMEFarEast,
    eCodeModeMax // Obviously this must be the last.
    };

#define FGetCodeMode(eCodeMode) FBitFlag(gfCodeModeFlags, eCodeMode)
#define SetCodeModeON(eCodeMode) BitFlagSetON(gfCodeModeFlags, eCodeMode)
#define SetCodeModeOFF(eCodeMode) BitFlagSetOFF(gfCodeModeFlags, eCodeMode)
#define SetCodeMode(eCodeMode, fBool) ((fBool) ? SetCodeModeON(eCodeMode) : SetCodeModeOFF(eCodeMode))

#define TAB_LENGTH      8
#define DEFAULT_ESCAPE_CHAR 0x1D
#define DEFAULT_SHIFT_STATE 2

#define MAX_KEYUPS 7   //This value is out of thin air. 

#define SHIFT_KEY   1
#define CTRL_KEY    2
#define ALT_KEY     4

#define ALT_PLUS    L"ALT+"
#define CTRL_PLUS   L"CTRL+"
#define SHIFT_PLUS  L"SHIFT+"

//Means exnded char. They differ for each code page
#define IS_EXTENDED_CHAR( c ) ( ( c ) >= 129 )

#define ASCII_BACKSPACE  0x08
#define ASCII_DEL        0x7f
#define ASCII_CR         0x0D
#define ASCII_LF         0x0A
#define VT302_NEXT   '6'
#define VT302_PRIOR  '5'
#define VT302_END    '4'
#define VT302_INSERT '2'
#define VT302_HOME   '1'
#define VT302_PAUSE  'P'

#define CHAR_ZERO    '0'
#define CHAR_ONE     '1'
#define CHAR_TWO     '2'
#define CHAR_THREE   '3'
#define CHAR_FOUR    '4'
#define CHAR_FIVE    '5'
#define CHAR_SEVEN   '7'
#define CHAR_EIGHT   '8'
#define CHAR_NINE    '9'

#define CHAR_NUL     0

#define SFUTLNTVER   "SFUTLNTVER"
#define SFUTLNTMODE  "SFUTLNTMODE"

#define DELTA       100

#define KOR_CODEPAGE 949
#define JAP_CODEPAGE 932

#define IS_NUMPAD_DIGIT_KEY( KeyEvent ) \
    ( !( KeyEvent.dwControlKeyState & ENHANCED_KEY ) && \
      ( ( KeyEvent.wVirtualKeyCode == VK_INSERT   ) || \
      ( KeyEvent.wVirtualKeyCode == VK_END      ) || \
      ( KeyEvent.wVirtualKeyCode == VK_DOWN     ) || \
      ( KeyEvent.wVirtualKeyCode == VK_NEXT     ) || \
      ( KeyEvent.wVirtualKeyCode == VK_LEFT     ) || \
      ( KeyEvent.wVirtualKeyCode == VK_CLEAR    ) || \
      ( KeyEvent.wVirtualKeyCode == VK_RIGHT    ) || \
      ( KeyEvent.wVirtualKeyCode == VK_HOME     ) || \
      ( KeyEvent.wVirtualKeyCode == VK_UP       ) || \
      ( KeyEvent.wVirtualKeyCode == VK_PRIOR    ) ) )

#define MAP_DIGIT_KEYS_TO_VAL( wVirtualKeyCode ) \
    ( ( wVirtualKeyCode == VK_INSERT  ? 0 : \
        wVirtualKeyCode == VK_END     ? 1 : \
        wVirtualKeyCode == VK_DOWN    ? 2 : \
        wVirtualKeyCode == VK_NEXT    ? 3 : \
        wVirtualKeyCode == VK_LEFT    ? 4 : \
        wVirtualKeyCode == VK_CLEAR   ? 5 : \
        wVirtualKeyCode == VK_RIGHT   ? 6 : \
        wVirtualKeyCode == VK_HOME    ? 7 : \
        wVirtualKeyCode == VK_UP      ? 8 : \
        wVirtualKeyCode == VK_PRIOR   ? 9 : 0 ) )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\client\wintelsz.h ===
//Copyright (c) Microsoft Corporation.  All rights reserved.

extern TCHAR szTitleBase[];
extern TCHAR szTitleNone[];
extern TCHAR szAppName[];
extern UCHAR szEditMenu[];
extern UCHAR szMarkMode[];
extern UCHAR szMarkModeMouse[];

extern TCHAR szInfoBanner[];
extern TCHAR szEscapeChar[];
extern TCHAR szPrompt[];
extern TCHAR szInvalid[];
extern TCHAR szHelp[];
extern TCHAR szBuildInfo[];

extern TCHAR szClose[];
extern TCHAR szDisplay[];
extern TCHAR szHelpStr[];
extern TCHAR szOpen[];
extern TCHAR szOpenTo[];
extern TCHAR szOpenUsage[];
extern TCHAR szQuit[];
extern TCHAR szSend[];
extern TCHAR szSet[];
extern TCHAR szStatus[];
extern TCHAR szUnset[];

//#if defined(FE_IME)
//extern TCHAR szEnableIMESupport[];
//extern TCHAR szDisableIMESupport[];
//#endif /* FE_IME */

extern TCHAR szWillAuth[];
extern TCHAR szWontAuth[];
extern TCHAR szLocalEchoOn[];
extern TCHAR szLocalEchoOff[];

//#if defined(FE_IME)
//extern TCHAR szEnableIMEOn[];
//#endif /* FE_IME */

extern TCHAR szConnectedTo[];
extern TCHAR szNotConnected[];
extern TCHAR szNegoTermType[];
extern TCHAR szPrefTermType[];

extern TCHAR szSetFormat[];
extern TCHAR szSupportedTerms[];
extern TCHAR szSetHelp[];
extern TCHAR szUnsetFormat[];
extern TCHAR szUnsetHelp[];

//#if defined(FE_IME)
//extern TCHAR szEnableIMEFormat[];
//extern TCHAR szEnableIMEHelp[];
//extern TCHAR szDisableIMEFormat[];
//extern TCHAR szDisableIMEHelp[];
//#endif /* FE_IME */


extern UCHAR szTelXfer[];
extern UCHAR szMenuName[];
extern UCHAR szDefaultFont[];

extern UCHAR szMachineMenuItem[];
extern UCHAR szMachineMenuItem1[];

extern UCHAR szProgressDisplay[];

extern UCHAR szBannerMessage[];
extern UCHAR szInitialProgress[];
extern UCHAR szNewLine[];
extern UCHAR szSendTelEnd[];
extern UCHAR szSendTelError[];

extern UCHAR szAllFiles[];
extern UCHAR szDownloadAs[];

extern TCHAR szConnecting[];
extern TCHAR szVersion[];

extern UCHAR szTextColour[];
extern UCHAR szBackgroundColour[];

/* Error messages */
extern TCHAR szConnectionLost[];
extern UCHAR szNoHostName[];
extern UCHAR szRestrictLines[];
extern TCHAR szConnectFailed[];
extern TCHAR szConnectFailedMsg[];
extern TCHAR szOnPort[];
extern UCHAR szCantOpenFile[];
extern UCHAR szOOM[];
extern UCHAR szNoThread[];
extern UCHAR szAbortDownload[];
extern TCHAR szTooMuchText[];

extern TCHAR szCantInitSockets[];
#ifdef DBCS
extern UCHAR szInproperFont[];
#endif
//extern TCHAR szEscapeCharacter[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\client\wintel.c ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
/****************************************************************************

        PROGRAM: WinTel.c

        PURPOSE: WinTel template for Windows applications

        FUNCTIONS:

                main() - calls initialization function, processes message loop
                InitApplication() - initializes window data and registers window
                InitInstance() - saves instance handle and creates main window
                MainWndProc() - processes messages
                About() - processes messages for "About" dialog box

        COMMENTS:

                Windows can have several copies of your application running at the
                same time.      The variable hInst keeps track of which instance this
                application is so that processing will be to the correct window.

        TABS:

                Set for 4 spaces.

****************************************************************************/

#include <windows.h>      				// required for all Windows applications 
#include <tchar.h>      				// required for all Windows applications 
#pragma warning (disable: 4201)			// disable "nonstandard extension used : nameless struct/union"
#include <commdlg.h>
#pragma warning (default: 4201)
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <lmcons.h>
#include <winbase.h>

#include "urlmon.h"
#include "zone.h"


#ifdef WHISTLER_BUILD
#include <ntverp.h>
#else
#include "solarver.h"
#endif
#include <common.ver>

#pragma warning( disable:4706 )
#pragma warning(disable:4100)

#include <imm.h>
#include <locale.h>

#include "WinTel.h"       				// specific to this program	
#include "debug.h"
#include "trmio.h"

#ifndef NO_PCHECK
#ifndef WHISTLER_BUILD
#include "piracycheck.h"
#endif
#endif

#include "commands.h"
#include "LocResMan.h"


#define MAX_USAGE_LEN	1400
TCHAR szUsage[MAX_USAGE_LEN];

#if 0
OPENFILENAME ofn;
TCHAR buffer[256];
#endif

HANDLE g_hCaptureConsoleEvent = NULL;

HINSTANCE ghInstance;
WI gwi;

HANDLE g_hAsyncGetHostByNameEvent = NULL;
HANDLE g_hControlHandlerEvent = NULL;
HANDLE g_hTelnetPromptConsoleBuffer = NULL;
HANDLE g_hSessionConsoleBuffer = NULL;

/* This event synchronizes the output to g_hTelnetPromptConsoleBuffer
and g_hSessionConsoleBuffer. It prevents session data coming at the prompt 
and viceversa - BUG 2176*/

HANDLE g_hRemoteNEscapeModeDataSync = NULL;

TCHAR   g_szKbdEscape[ SMALL_STRING + 1 ];
BOOL    g_bIsEscapeCharValid = TRUE;

DWORD HandleTelnetSession(WI *pwi);
BOOL StuffEscapeIACs( PUCHAR* ppBufDest, UCHAR bufSrc[], DWORD* pdwSize );
BOOL fPrintMessageToSessionConsole = FALSE;
BOOL fClientLaunchedFromCommandPrompt = FALSE;
BOOL g_fConnectFailed = 0;

void ConvertAndSendVTNTData( LPTSTR pData, int iLen );

extern BOOL bDoVtNTFirstTime;

HIMC hImeContext;
extern VOID SetImeWindow(TRM *ptrm);
extern void WriteMessage( DWORD dwMsgId, WCHAR szEnglishString[] );

DWORD CurrentKanjiSelection = 0;
KANJILIST KanjiList[NUMBER_OF_KANJI] =
{
  /* KanjiID,          KanjiEmulationID, KanjiMessageID, KanjiItemID */
   { fdwSJISKanjiMode, dwSJISKanji,      IDS_KANJI_SJIS, 0, L"\0" },
   { fdwJISKanjiMode,  dwJISKanji,       IDS_KANJI_JIS,  0, L"\0" },
   { fdwJIS78KanjiMode,dwJIS78Kanji,     IDS_KANJI_JIS78,0, L"\0" },
   { fdwEUCKanjiMode,  dwEUCKanji,       IDS_KANJI_EUC,  0, L"\0" },
   { fdwNECKanjiMode,  dwNECKanji,       IDS_KANJI_NEC,  0, L"\0" },
   { fdwDECKanjiMode,  dwDECKanji,       IDS_KANJI_DEC,  0, L"\0" },
   { fdwACOSKanjiMode, dwACOSKanji,      IDS_KANJI_ACOS, 0, L"\0" }
};
BOOL fHSCROLL = FALSE;
TCHAR szVT100KanjiEmulation[SMALL_STRING + 1];

#define NUM_ISO8859_CHARS           3
#define NUM_WINDOWS_CP1252_CHARS    4

UINT gfCodeModeFlags[1+((eCodeModeMax-1)/N_BITS_IN_UINT)];

extern INT GetRequestedTermType( LPTSTR pszTerm );

TCHAR szUserName[ UNLEN + 1 ];

void PrintUsage()
{
    DWORD dwWritten = 0;
	CHAR szStr[MAX_USAGE_LEN] = { 0 };
	MyWriteConsole(g_hSessionConsoleBuffer,szUsage,_tcslen(szUsage));
}

BOOL
FileIsConsole(
    HANDLE fp
    )
{
    unsigned htype;

    htype = GetFileType(fp);
    htype &= ~FILE_TYPE_REMOTE;
    return htype == FILE_TYPE_CHAR;
}

void
MyWriteConsole(
    HANDLE  fp,
    LPWSTR  lpBuffer,
    DWORD   cchBuffer
    )
{
    //
    // Jump through hoops for output because:
    //
    //    1.  printf() family chokes on international output (stops
    //        printing when it hits an unrecognized character)
    //
    //    2.  WriteConsole() works great on international output but
    //        fails if the handle has been redirected (i.e., when the
    //        output is piped to a file)
    //
    //    3.  WriteFile() works great when output is piped to a file
    //        but only knows about bytes, so Unicode characters are
    //        printed as two Ansi characters.
    //

    if (FileIsConsole(fp))
    {
	WriteConsole(fp, lpBuffer, cchBuffer, &cchBuffer, NULL);
    }
    else
    {
        LPSTR  lpAnsiBuffer = (LPSTR) LocalAlloc(LMEM_FIXED, cchBuffer * sizeof(WCHAR));

        if (lpAnsiBuffer != NULL)
        {
            cchBuffer = WideCharToMultiByte(CP_OEMCP,
                                            0,
                                            lpBuffer,
                                            cchBuffer,
                                            lpAnsiBuffer,
                                            cchBuffer * sizeof(WCHAR),
                                            NULL,
                                            NULL);

            if (cchBuffer != 0)
            {
                WriteFile(fp, lpAnsiBuffer, cchBuffer, &cchBuffer, NULL);
            }

            LocalFree(lpAnsiBuffer);
        }
    }
}


void PromptUserForNtlmCredsTransfer()
{
     WCHAR szMsg[MAX_PATH+1];
     WCHAR rgchBuffer[MAX_PATH];        
     DWORD dwLength = 3; //including "\r\n"
     WCHAR szZoneName[MAX_PATH+1];
     DWORD dwZonePolicy = URLPOLICY_CREDENTIALS_SILENT_LOGON_OK; //anything other than anonymous
     ui.bSendCredsToRemoteSite = FALSE;
     ui.bPromptForNtlm = FALSE;
     
     wcscpy( szZoneName, L"" );//no overflow.
     if( !IsTrustedServer( rgchHostName, szZoneName, sizeof(szZoneName)/sizeof(WCHAR), &dwZonePolicy ) )
     {
         if( URLPOLICY_CREDENTIALS_ANONYMOUS_ONLY != dwZonePolicy )
         {   
             LoadString( ghInstance, IDS_NTLM_PROMPT, szMsg, MAX_PATH);

             Write( szMsg, szZoneName, NULL );
 
             rgchBuffer[0] = L'N';
             if( !ReadConsole( gwi.hInput, rgchBuffer, dwLength, &dwLength, NULL ) )
             {
                goto PromptUserIfNtlmAbort;
             }

             
             if( 0 == dwLength ) //when ctrl C is pressed
             {
                 rgchBuffer[0] = L'N';
             }
                        
             if((towupper(rgchBuffer[0])) == L'Y' )
             {
                ui.bSendCredsToRemoteSite = TRUE;
                goto PromptUserIfNtlmAbort;
             }
         } 
     }
     else
     {
        ui.bSendCredsToRemoteSite = TRUE;
     }

PromptUserIfNtlmAbort:
     return;
}

#define MAX_TELNET_COMMANDS     9
//#endif /* FE_IME */


static TelnetCommand sTelnetCommands[MAX_TELNET_COMMANDS];

BOOL PrintHelpStr(LPTSTR szCommand)
{
    DWORD dwWritten;
    WriteConsole(gwi.hOutput, szHelp, _tcslen(szHelp), &dwWritten, NULL);
    return FALSE;
}

//This uses the global variable g_chEsc and forms a global string g_szKbdEscape
void SetEscapeChar( WCHAR chEsc )
{
    USHORT  vkBracket = 0;
    UINT    iRet = 0;
    WCHAR szShiftState[ MAX_STRING_LENGTH ];
    LPWSTR szTmpShiftState = szShiftState;
    
    SfuZeroMemory(g_szKbdEscape, sizeof(g_szKbdEscape));

    CheckEscCharState( &vkBracket, &iRet, chEsc, szTmpShiftState );
    g_chEsc = chEsc;
    if( 0 == iRet )
    {
        wcscpy( szShiftState, L"" );//no overflow.
    }
    //
    // If VirtualKey exists then map it into a character
    //
    if(LOBYTE(vkBracket) != (BYTE)-1)
    {
        
        //
        // If a key does not exist, goto default mapping 
        //
        if( 0 == iRet )
        {
            chEsc   = L']';
            g_chEsc = DEFAULT_ESCAPE_CHAR;
            g_EscCharShiftState = DEFAULT_SHIFT_STATE;                
        }
        else
        {
            chEsc   = LOBYTE( iRet );
        }
        if( isalpha( chEsc ) )
        {
            chEsc = (SHORT) tolower( chEsc );      
        }
    }
    
    _sntprintf(g_szKbdEscape,SMALL_STRING, szEscapeChar, szShiftState, chEsc);
}

void CheckEscCharState( USHORT *ptrvkBracket, UINT *ptriRet, WCHAR chEscKey, LPWSTR szEscCharShiftState )
{
    DWORD dwToCopy = MAX_STRING_LENGTH-1;
    *ptrvkBracket = VkKeyScan(chEscKey);


    *ptriRet = MapVirtualKey(LOBYTE(*ptrvkBracket), 2);
    if( *ptriRet != 0 )
    {
        g_EscCharShiftState  = HIBYTE( *ptrvkBracket );
    }
    

    wcscpy( szEscCharShiftState, ( LPTSTR )L"" );//no overflow.
    if( g_EscCharShiftState & SHIFT_KEY )
    {
        _snwprintf( szEscCharShiftState,dwToCopy,( LPTSTR )L"%s", SHIFT_PLUS );
        szEscCharShiftState+= wcslen( szEscCharShiftState);
        dwToCopy -= wcslen(szEscCharShiftState);
    }
    if( g_EscCharShiftState & ALT_KEY )
    {
        _snwprintf( szEscCharShiftState,dwToCopy,( LPTSTR )L"%s", ALT_PLUS );
        szEscCharShiftState += wcslen( szEscCharShiftState );
        dwToCopy -= wcslen(szEscCharShiftState);        
    }
    if( g_EscCharShiftState & CTRL_KEY )
    {
        _snwprintf( szEscCharShiftState, dwToCopy,( LPTSTR )L"%s", CTRL_PLUS );
    }
}

DWORD g_lExitTelnet  = 0;

DWORD DoTelnetCommands( void* p )
{
#define MAX_COMMAND_LEN 256

    // make the command buffer hold 256 characters and null terminatior. Note that
    // ReadConsole when asked to read 255 characters, will read 254 and the <CR> character
    // and then real <LF> in the next call. Where as if we ask it to read 256, it will still limit no
    // of characters to 254, but this time return both <CR>, <LF>.
    
    TCHAR szCommand[MAX_COMMAND_LEN+1];
    TCHAR *pCmd = NULL;
    DWORD dwRead = ( DWORD ) -1, dwWritten = 0;
    int iBegin = 0, iEnd = 0, iCmd = 0;
    static DWORD dwConsoleMode = 0;

    TCHAR szTmp[MAX_COMMAND_LEN] = { 0 };
    TCHAR szTmp1[81];
    if( dwConsoleMode == 0 )
        GetConsoleMode( gwi.hInput, &dwConsoleMode );

    SetEscapeChar( g_chEsc ); //This forms g_szKbdEscape
    _sntprintf(szTmp,MAX_COMMAND_LEN -1,_T("%s%s%s"),szInfoBanner,g_szKbdEscape,TEXT("\n"));
    WriteConsole( gwi.hOutput, szTmp, _tcslen(szTmp), &dwWritten, NULL);
    // hack to make the command line paramater to work.
    if( rgchHostName[0] )
    {
        //ugly hack due to remnants of old logic
        //by this point, we have already done this kind of stuff once in 
        //FInitApplication()
        TCHAR szCmd[MAX_COMMAND_LEN] = { 0 };

        if( g_szPortNameOrNo[ 0 ] != 0 ) //not a null string
        {
            _sntprintf(szCmd,MAX_COMMAND_LEN -1,TEXT("%s %s"),rgchHostName,g_szPortNameOrNo);
        }
        else
        {
        	_tcsncpy( szCmd, rgchHostName,MAX_COMMAND_LEN -1);
        }
        fPrintMessageToSessionConsole = TRUE;
        fClientLaunchedFromCommandPrompt = TRUE;
        OpenTelnetSession( szCmd );
        if( g_fConnectFailed )
        {
            exit( 0 );
        }
    }
    
    do {
        int iValidCmd = -1;
        int iIndex = 0;
        int iCount = 0;
        BOOL dwStatus = 0;

        if( ui.bPromptForNtlm )
        {
            gwi.hOutput = g_hTelnetPromptConsoleBuffer;
            SetConsoleActiveScreenBuffer( gwi.hOutput );
            PromptUserForNtlmCredsTransfer();
            ui.bPromptForNtlm = FALSE;
            SetEvent( g_hCaptureConsoleEvent );
            gwi.hOutput = g_hSessionConsoleBuffer;
            SetConsoleActiveScreenBuffer( gwi.hOutput );
			SetEvent( g_hRemoteNEscapeModeDataSync );
            HandleTelnetSession(&gwi);            
        }
 
        if( g_lExitTelnet  )
        {
            CloseHandle(g_hTelnetPromptConsoleBuffer );
            CloseHandle( gwi.hInput );
        }


        if( dwRead != 0 )
        {
            SetConsoleMode(gwi.hInput, dwConsoleMode);
            gwi.hOutput = g_hTelnetPromptConsoleBuffer;
            SetConsoleActiveScreenBuffer( gwi.hOutput );
            WriteConsole( gwi.hOutput, szPrompt, _tcslen(szPrompt), &dwWritten, NULL);
            SfuZeroMemory(szCommand, MAX_COMMAND_LEN * sizeof(TCHAR));
        }

        dwRead = ( DWORD ) -1;
        dwStatus = ReadConsole(gwi.hInput, szCommand, MAX_COMMAND_LEN, &dwRead, NULL);
        szCommand[MAX_COMMAND_LEN] = 0; // null terminate for the extreme case.
        

        if( dwStatus == 0 || dwRead == -1 )
        {
            /* When NN_LOST is received, we close gwi.hInput so that we
             * reach here and do equivalent of quit at telnet prompt */
            QuitTelnet( ( LPTSTR )L"" );
            continue;
        }

        if( dwRead == 0 )
        {
            continue;
        }

        // no input ??
        // This is the case when an enter is hit at telnet prompt
        if ( dwRead == 2 ) 
        {
            if( fConnected )
            {
                gwi.hOutput = g_hSessionConsoleBuffer;
                SetConsoleActiveScreenBuffer( gwi.hOutput );
                SetEvent( g_hRemoteNEscapeModeDataSync );
                HandleTelnetSession(&gwi);
            }
            continue;
        }


        ASSERT( dwRead >= 2 );

        // Null Terminate the string and remove the newline characters.
        szCommand[dwRead-1] = 0;
        szCommand[dwRead-2] = 0;

        while( iswspace( szCommand[iIndex] ) )
        {
            iIndex++;
        }
        iCount = iIndex;

        if( iIndex != 0 )
        {
            do
            {
                szCommand[ iIndex - iCount ] = szCommand[ iIndex++ ];
            }
            while( szCommand[ iIndex - 1 ] != _T('\0') );
        }

        if ( *szCommand == _T('?') )
        {
            PrintHelpStr(szCommand);
            continue;
        }


        // do a binary search based on the first character, if that succeeds then
        // see if the typed in command is a substring of the command.
        iBegin = 0; iEnd = MAX_TELNET_COMMANDS - 1;
        while ( iBegin <= iEnd )
        {
            iCmd = (iBegin + iEnd)/2;
            if ( towlower( *szCommand ) == *sTelnetCommands[iCmd].sName )
                break;
            if ( towlower( *szCommand ) > *sTelnetCommands[iCmd].sName )
                iBegin = iCmd+1;
            else
                iEnd = iCmd-1;
        }

        if ( iBegin > iEnd )
        {
invalidCmd:
            WriteConsole(gwi.hOutput, szInvalid, _tcslen(szInvalid), &dwWritten, NULL);
            continue;
        }

        // go back to the command that has the same first char
        while ( iCmd > 0 && towlower( *szCommand ) == *sTelnetCommands[iCmd-1].sName )
            iCmd--;

        pCmd = _tcstok(szCommand, ( LPTSTR )TEXT(" \t"));
        if ( pCmd == NULL )
            pCmd = szCommand;

        while ( iCmd < MAX_TELNET_COMMANDS && towlower( *szCommand ) == *sTelnetCommands[iCmd].sName )
        {
            if ( _tcsstr(sTelnetCommands[iCmd].sName, _tcslwr( pCmd )) == sTelnetCommands[iCmd].sName)
            {
                if( iValidCmd >= 0 )
                {
                    iValidCmd = -1;
                    break;
                }
                else
                {
                    iValidCmd = iCmd;
                }                
            }
            iCmd++;
        }

        //if ( iCmd == MAX_TELNET_COMMANDS )
        if( iValidCmd < 0 )
        {
            goto invalidCmd;
        }

        // process the command.
        pCmd = _tcstok(NULL, ( LPTSTR )TEXT(""));

        if ( (*sTelnetCommands[iValidCmd].pCmdHandler)(pCmd) )
            break;
    } while ( ( TRUE, TRUE ) );

    return 0;
}

void SetCursorShape()
{ 
    CONSOLE_CURSOR_INFO ccInfo = { 0 , 0 };
    GetConsoleCursorInfo( g_hSessionConsoleBuffer, &ccInfo );

    if( ccInfo.dwSize < BLOCK_CURSOR )
    {
        ccInfo.dwSize = BLOCK_CURSOR ;
    }
    else
    {
        ccInfo.dwSize = NORMAL_CURSOR;
    }
    SetConsoleCursorInfo( g_hSessionConsoleBuffer, &ccInfo );

    return;
}

BOOL IsAnEscapeChar( WCHAR wcChar, WI *pwi, DWORD dwEventsRead )
{ 
    PUCHAR destBuf = NULL;
    DWORD dwSize = 0;
    
    // Is it the escape Key !? i.e. ctrl + ] 
    if( wcChar == g_chEsc && g_bIsEscapeCharValid )
    {
#if 0 
        //This special case is no more needed as we simulate key up and down 
        //for each key storke on the server. Lack of this was the cause of losing chars 
        //on the server side

        // this is the really special case where when the user tries
        // to enter ctrl + ], first he presses ctrl. this sends a 
        // ctrl "keydown" input record to the remote side .
        // then we get the ctrl + ] and we switch to local mode.
        // at this time the ctrl "keyup" input record is consumed by
        // us locally. So we have to send a simulated ctrl "keyup" 
        // input record. Test case : when user is in app like 
        // "edit.exe", edit is expecting a ctrl "keyup" to follow
        // a ctrl "keydown". otherwise it gets "stuck" and you can't
        // enter the and letter keys.
        //To solve this we are reading MAX_KEYUPS i/p records and
        //giving them to the application

        
        if( ( pwi->trm.CurrentTermType == TT_VTNT ) )

        {           
            INPUT_RECORD pIR[ MAX_KEYUPS ];
            ReadConsoleInput(pwi->hInput, pIR, MAX_KEYUPS, &dwEventsRead);
            dwSize = sizeof( INPUT_RECORD ) * dwEventsRead;
            if( !StuffEscapeIACs( &destBuf, (PUCHAR) pIR, &dwSize ) )
            {
                FWriteToNet( pwi, ( CHAR* ) pIR, dwSize );
            }
            else
            {
                FWriteToNet(pwi, ( CHAR* )destBuf, dwSize );
                dwSize = 0;
                free( destBuf );
            }
        }
#endif        
        
        //Failure of this is not serious. Just that
        //Remote data may be seen escape mode.
        WaitForSingleObject( g_hRemoteNEscapeModeDataSync, INFINITE );
        ResetEvent( g_hRemoteNEscapeModeDataSync );

        gwi.hOutput = g_hTelnetPromptConsoleBuffer;

        return ( TRUE );
    }

    return ( FALSE );
}

/*
*
* This function does all the characater translations/mappings
* that are required by the client to do. This function has
* to be called after a Key Event has occurred and before
* anything is written onto the socket. All other places
* where the translations/mappings are being done are to be
* removed.
*
* TODO: Right now I am moving delasbs and bsasdel mappings
* only to fix a few bugs. All mappings should eventually be
* moved here for better maintainability - prakashr
*
*/
void HandleCharMappings(WI* pWI, INPUT_RECORD* pInputRecord)
{
    // Do not make a call to ForceJISRomanSend in this function
    // that will be done while sending the data to the network

    // Map backspace to del, in case of 'set bsasdel' setting
    // unless either CTRL or SHIFT or ALT is pressed
    if (g_bSendBackSpaceAsDel && pInputRecord->Event.KeyEvent.uChar.AsciiChar == ASCII_BACKSPACE &&
        !(pInputRecord->Event.KeyEvent.dwControlKeyState & (ALT_PRESSED | CTRL_PRESSED | SHIFT_PRESSED)))
    {
        pInputRecord->Event.KeyEvent.wVirtualKeyCode = VK_DELETE;
        pInputRecord->Event.KeyEvent.uChar.AsciiChar = CHAR_NUL;
        pInputRecord->Event.KeyEvent.dwControlKeyState |= ENHANCED_KEY;
        return;
    }

    // Map del to backspace, in case of 'set delasbs' setting
    // unless either CTRL or SHIFT or ALT is pressed
    if (g_bSendDelAsBackSpace && pInputRecord->Event.KeyEvent.wVirtualKeyCode == VK_DELETE &&
        !(pInputRecord->Event.KeyEvent.dwControlKeyState & (ALT_PRESSED | CTRL_PRESSED | SHIFT_PRESSED)))
    {
        pInputRecord->Event.KeyEvent.uChar.AsciiChar = ASCII_BACKSPACE;
        pInputRecord->Event.KeyEvent.wVirtualKeyCode = ASCII_BACKSPACE;
        pInputRecord->Event.KeyEvent.dwControlKeyState &= ~ENHANCED_KEY;
        return;
    }
}

DWORD HandleTelnetSession(WI *pwi)
{
    PUCHAR destBuf = NULL;
    DWORD dwSize = 0;
    BOOL bBreakFlag = FALSE;

    INPUT_RECORD sInputRecord;
    DWORD dwEventsRead;
    INPUT_RECORD *pInputRecord;
    DWORD dwPrevMode = 0, TelnetConsoleMode;

    GetConsoleMode(pwi->hInput, &dwPrevMode);

    TelnetConsoleMode = dwPrevMode & ~(ENABLE_PROCESSED_INPUT | ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT | FOCUS_EVENT);

    SetConsoleMode(pwi->hInput, TelnetConsoleMode);

    pInputRecord = &sInputRecord; 
    
//    DebugBreak();
    
    while ( fConnected && !bBreakFlag )
    {
        if ( (pwi->trm.CurrentTermType == TT_VTNT) ? 
                ReadConsoleInput(pwi->hInput, pInputRecord, 1, &dwEventsRead) :
                ReadConsoleInputA(pwi->hInput, pInputRecord, 1, &dwEventsRead))
        {
        

            switch ( pInputRecord->EventType )
            {
            case KEY_EVENT:

            if (!FGetCodeMode(eCodeModeFarEast) && !FGetCodeMode(eCodeModeVT80))
                {
                // If ALT key is down and we are not in VTNT mode we check to see if 
                // user wants to enter extended ASCII characters from the OEM character 
                // set or from ANSI character set. Also note that currently in V1 the 
                // SFU server does term type negotiation only after user login. 
                // So the term type will be ANSI until login succeeds eventhough the 
                // user sets the preferred term type to VTNT. Unless this protocol ordering 
                // changes in the server, the below loop will work for VTNT when the 
                // username  or password has extended characters in it.
                //
                if( (pInputRecord->Event.KeyEvent.dwControlKeyState & ALT_PRESSED) &&
                     (pwi->trm.CurrentTermType != TT_VTNT) )
                {
                    char szExtendedCharBuf[5];
                    int idx=0;
                    SfuZeroMemory( szExtendedCharBuf, sizeof(szExtendedCharBuf) );

                    while(fConnected)
                    {
                        ReadConsoleInputA( pwi->hInput, pInputRecord, 1, &dwEventsRead );
                        /*++
                        Continue here ONLY if the client is still connected - which is determined by the 
                        fConnected flag. Otherwise, break from this loop without doing anything.
                        --*/
						if ( FOCUS_EVENT == pInputRecord->EventType 
								&& TRUE == ui.bPromptForNtlm )
						{
							bBreakFlag = TRUE;
							break;
						}
							
                        if( !(pInputRecord->Event.KeyEvent.dwControlKeyState & ALT_PRESSED) 
                            || (pInputRecord->EventType != KEY_EVENT)
                            || !(  ( pInputRecord->Event.KeyEvent.wVirtualKeyCode >= VK_NUMPAD0
                                        && pInputRecord->Event.KeyEvent.wVirtualKeyCode <= VK_NUMPAD9 )
                                   || IS_NUMPAD_DIGIT_KEY( pInputRecord->Event.KeyEvent ) ) )
                                   //The last one is for allowing entering extended 
                                   //chars even when numlock is not on
                        {
                            if( idx == NUM_ISO8859_CHARS )
                            {
                                int extChar;
                                WCHAR wcChar[2] = {0};
                                CHAR  cChar[2] = {0};
                                CHAR cSpace = ' ';
                                BOOL bUsed = 0;
                                
                                szExtendedCharBuf[idx] = '\0';
                                extChar = atoi( szExtendedCharBuf );
                            
                                /* When casting from int to char, it is using
                                 * CP 1252. To make it use 850, the following jugglery */

                                MultiByteToWideChar( GetConsoleCP(), 0, ( LPCSTR )&extChar, 1, &wcChar[0], 1 );
                                wcChar[1] = L'\0';
                                WideCharToMultiByte( GetConsoleCP(), 0, &wcChar[0], 1, &cChar[0], 1, &cSpace, &bUsed );
                                cChar[1] = '\0';
                                if( IsAnEscapeChar( wcChar[0], pwi, dwEventsRead ) )
                                {
                                    // Restore the console mode.
                                    SetConsoleMode( pwi->hInput, dwPrevMode );
                                    return ( 0 );
                                }
                                HandleCharEvent( pwi, cChar[0], pInputRecord->Event.KeyEvent.dwControlKeyState );
                                break;
                            }
                            else if( idx == NUM_WINDOWS_CP1252_CHARS )
                            {
                                int extChar;
                                WCHAR wcChar[2] = {0};
                                CHAR  cChar[2] = {0};
                                CHAR cSpace = ' ';
                                BOOL bUsed = 0;

                                szExtendedCharBuf[idx] = '\0';
                                extChar = atoi( szExtendedCharBuf );
                            
                                MultiByteToWideChar( CP_ACP, 0, ( LPCSTR )&extChar, 1, &wcChar[0], 1 );
                                wcChar[1] = L'\0';
                                WideCharToMultiByte( GetConsoleCP(), 0, &wcChar[0], 1, &cChar[0], 1, &cSpace, &bUsed );
                                cChar[1] = '\0';
                                if( IsAnEscapeChar( wcChar[0], pwi, dwEventsRead ) )
                                {
                                    // Restore the console mode.
                                    SetConsoleMode( pwi->hInput, dwPrevMode );
                                    return ( 0 );
                                }
                                HandleCharEvent( pwi, cChar[0], pInputRecord->Event.KeyEvent.dwControlKeyState );
                                break;
                            }
                            else
                            {
                                if( (pInputRecord->Event.KeyEvent.uChar.AsciiChar != 0)
                                      && (pInputRecord->EventType == KEY_EVENT) 
                                      && (pInputRecord->Event.KeyEvent.bKeyDown) )
                                {
                                    break;
                                }
                                else if( ( ( pInputRecord->Event.KeyEvent.wVirtualKeyCode >= VK_PRIOR
                                    && pInputRecord->Event.KeyEvent.wVirtualKeyCode <= VK_DELETE )
                                    || ( pInputRecord->Event.KeyEvent.wVirtualKeyCode >= VK_F1 
                                    && pInputRecord->Event.KeyEvent.wVirtualKeyCode <= VK_F12 ) )
                                    && pInputRecord->EventType == KEY_EVENT
                                    && pInputRecord->Event.KeyEvent.bKeyDown )
                                {
                                    //This will handle home, end, pageup, pagedown, function keys etc from 
                                    //numeric keypad
                                    break;
                                }
                                else if ( pInputRecord->Event.KeyEvent.dwControlKeyState & ENHANCED_KEY )
                                {
                                    break;
                                }
                                else
                                {
                                    continue;
                                }
                            }
                        }
                        else
                        {
                            if( IS_NUMPAD_DIGIT_KEY( pInputRecord->Event.KeyEvent ) )
                            {
                                INT iDigit = 0;

                                iDigit = MAP_DIGIT_KEYS_TO_VAL( pInputRecord->Event.KeyEvent.wVirtualKeyCode );
                                szExtendedCharBuf[idx++] = ( CHAR ) ( '0' + iDigit );
                            }
                            else
                            {
                                szExtendedCharBuf[idx++] = ( CHAR  )( (pInputRecord->Event.KeyEvent.wVirtualKeyCode - VK_NUMPAD0) + '0' );
                            }

                            ReadConsoleInputA( pwi->hInput, pInputRecord, 1, &dwEventsRead );
                            continue;
                        }
                    }
                    
                }
            }    
                if( pInputRecord->Event.KeyEvent.bKeyDown )
                {
                    if( IsAnEscapeChar( pInputRecord->Event.KeyEvent.uChar.UnicodeChar, pwi, dwEventsRead ) )
                    {
                        // Restore the console mode.
                        SetConsoleMode( pwi->hInput, dwPrevMode );
                        return ( 0 );
                    }
                }

                //
                // After trapping the escape character, do the mappings now
                //
                HandleCharMappings(pwi, pInputRecord);

                if( pwi->trm.CurrentTermType == TT_VTNT )
                {
                    if( pInputRecord->Event.KeyEvent.wVirtualKeyCode == VK_INSERT_KEY &&
                        pInputRecord->Event.KeyEvent.bKeyDown )    
                    {
                        SetCursorShape();
                    }

                    CheckForChangeInWindowSize();

                    dwSize = sizeof( INPUT_RECORD );
                    if( !StuffEscapeIACs( &destBuf, (PUCHAR) pInputRecord, &dwSize ) )
                    {
                        FWriteToNet( pwi, ( CHAR* ) pInputRecord, sizeof( INPUT_RECORD ) );
                    }
                    else
                    {
                        FWriteToNet(pwi, ( CHAR* )destBuf, dwSize );
                        dwSize = 0;
                        free( destBuf );
                    }

                    if( ui.nottelnet || (ui.fDebug & fdwLocalEcho ) )
                    {
                        //if( !DoVTNTOutput(pwi, &pwi->trm, sizeof(INPUT_RECORD),
                        //     (char*)&sInputRecord ) )
                        //{
                            //pwi->trm.CurrentTermType = TT_ANSI;
                            //DoIBMANSIOutput(pwi, &pwi->trm, 
                                //sizeof(INPUT_RECORD), (char*)&sInputRecord );
                        //}
                    }
                    break;
                }
                if ( ! pInputRecord->Event.KeyEvent.bKeyDown )
                    break;

                if ( pInputRecord->Event.KeyEvent.dwControlKeyState & ENHANCED_KEY )
                {
                    FHandleKeyDownEvent(pwi, (CHAR)pInputRecord->Event.KeyEvent.wVirtualKeyCode,
                                pInputRecord->Event.KeyEvent.dwControlKeyState);
                    break;
                }

                if ( pInputRecord->Event.KeyEvent.uChar.AsciiChar == 0 )
                {
                    //The following call is for handling home, end, pageup, pagedown etc from 
                    //numeric keypad and also, function keys
                    FHandleKeyDownEvent(pwi, (CHAR)pInputRecord->Event.KeyEvent.wVirtualKeyCode,
                                pInputRecord->Event.KeyEvent.dwControlKeyState);
                    break;
                }                    
                
                HandleCharEvent(pwi, pInputRecord->Event.KeyEvent.uChar.AsciiChar, 
                                    pInputRecord->Event.KeyEvent.dwControlKeyState);
                break;
            case MOUSE_EVENT:
                break;
            case WINDOW_BUFFER_SIZE_EVENT:
                break;
            case MENU_EVENT:
                break;
            case FOCUS_EVENT:
            	if(TRUE == ui.bPromptForNtlm)
            	{
            		bBreakFlag = TRUE;
            	}
                break;
            default:
                break;
            }

        }
        else
        {
            QuitTelnet( ( LPTSTR )L"" );
        }
    }
	
    gwi.hOutput = g_hTelnetPromptConsoleBuffer;
    bDoVtNTFirstTime = 1;

    // Restore the console mode.
    SetConsoleMode(pwi->hInput, dwPrevMode);

    return 0;
}


BOOL WINAPI ControlHandler(DWORD dwCtrlType)
{
    WCHAR wchCtrl;

    switch ( dwCtrlType )
    {
    case CTRL_C_EVENT:
    case CTRL_BREAK_EVENT:
        if ( !fConnected ) // normal handling while not connected.
        {
            //
            // (a-roopb) Fix to bug1006:telnet client does not connect when a ^C is hit
            // SetEvent( g_hAsyncGetHostByNameEvent );
            //
            PulseEvent( g_hControlHandlerEvent );
            return TRUE;
        }
        else if( gwi.hOutput != g_hSessionConsoleBuffer )
        {
            return TRUE;
        }

        // pass this to the server !!
        if( gwi.trm.CurrentTermType == TT_VTNT )
        {
        	wchCtrl = 0x03;
        	ConvertAndSendVTNTData(&wchCtrl,1);

            if (ui.nottelnet || (ui.fDebug & fdwLocalEcho))
            {
                //if( !DoVTNTOutput( &gwi, &(gwi.trm), sizeof(INPUT_RECORD),
                //    (char*)&sInputRecord ) )
                //{
                    //pwi->trm.CurrentTermType = TT_ANSI;
                    //DoIBMANSIOutput(&gwi, gwi.trm, sizeof(INPUT_RECORD), 
                        // (char*)&sInputRecord );
                //}
            }
        }
        else
        {
            HandleCharEvent(&gwi, (CHAR)VK_CANCEL,  // '0x03' i.e.
                        0);
        }
        break;
    case CTRL_CLOSE_EVENT:
    case CTRL_LOGOFF_EVENT:
    case CTRL_SHUTDOWN_EVENT:
        if ( fConnected )
            FHangupConnection(&gwi, &(gwi.nd));
    default:
        return FALSE;
        break;
    }

    return TRUE;
}

static void InitCodeModeFlags(UINT uConsoleCp)
{
switch (uConsoleCp)
    {
    case 932:
    case 949:
    case 936:
    case 950:
        SetCodeModeON(eCodeModeFarEast);
        SetCodeModeON(eCodeModeIMEFarEast);
        SetCodeModeON(eCodeModeVT80);
        break;
    }
}

void CleanUpMemory()
{

    if( szUser )
    {
        free( szUser );
    }

    if( gwi.nd.lpReadBuffer )
    {
        (void)LocalFree( (HLOCAL)gwi.nd.lpReadBuffer );
        gwi.nd.lpReadBuffer = NULL;
    }
    if( gwi.nd.lpTempBuffer )
    {
        (void)LocalFree( (HLOCAL)gwi.nd.lpTempBuffer );
        gwi.nd.lpTempBuffer = NULL;
    }
    return;
}

// CleanupProcess: 
void DoProcessCleanup()
{
    // first step is to close the Telnet connection if any
    if ( fConnected )
        FHangupConnection(&gwi, &(gwi.nd));

    // next, free the Network resources.
    WSACleanup(); // keithmo: get winsock.

    // Destroy the window that we created.
    DestroyWindow( gwi.hwnd );
    CloseHandle(gwi.hNetworkThread);
    CloseHandle(g_hControlHandlerEvent);
    CloseHandle(g_hAsyncGetHostByNameEvent);
    CloseHandle(g_hTelnetPromptConsoleBuffer );
    CloseHandle(g_hRemoteNEscapeModeDataSync );
    CloseHandle(g_hCaptureConsoleEvent);



    // Cleanup the memory.
    CleanUpMemory();

}


/****************************************************************************

 FUNCTION: main()

 PURPOSE: calls initialization function, processes message loop

 COMMENTS:

         Windows recognizes this function by name as the initial entry point
         for the program.  This function calls the application initialization
         routine, if no other instance of the program is running, and always
         calls the instance initialization routine.      It then executes a message
         retrieval and dispatch loop that is the top-level control structure
         for the remainder of execution.  The loop is terminated when a WM_QUIT
         message is received, at which time this function exits the application
         instance by returning the value passed by PostQuitMessage().

         If this function must abort before entering the message loop, it
         returns the conventional value NULL.

****************************************************************************/

int __cdecl wmain( int argc, TCHAR** argv )
{
    MSG msg;
    int err;
    DWORD dwThreadId;
    HANDLE hStdHandle = INVALID_HANDLE_VALUE;

    setlocale(LC_ALL, "");

    gwi.ichTelXfer = 0;
    hStdHandle = GetStdHandle( STD_INPUT_HANDLE );
    if( hStdHandle == INVALID_HANDLE_VALUE)
    {
    	exit( -1 );
    }
    gwi.hInput = hStdHandle;
    hStdHandle = GetStdHandle( STD_OUTPUT_HANDLE );
    if( hStdHandle == INVALID_HANDLE_VALUE)
    {
    	exit( -1 );
    }
    gwi.hOutput = hStdHandle;
    g_hSessionConsoleBuffer = gwi.hOutput;

    if( GetConsoleScreenBufferInfo( gwi.hOutput, &gwi.sbi ))
    {
        //set the initial console attributes
        //white text on a black background
        gwi.sbi.wAttributes = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;

        // This is so that when we scroll we maintain the
        // background color & text color !!
        gwi.cinfo.Attributes = gwi.sbi.wAttributes;
        gwi.cinfo.Char.AsciiChar = ' ';

        if(( err = FInitApplication( argc, argv, &gwi )))
        {
            exit( err );
        }
    }
    else
    {
        exit( -1 );
    }

    g_hControlHandlerEvent = CreateEvent( NULL, FALSE, FALSE, NULL );   // Auto-Reset event
    g_hAsyncGetHostByNameEvent = CreateEvent( NULL, TRUE, FALSE, NULL ); // Manual-Reset event
    g_hCaptureConsoleEvent = CreateEvent( NULL, TRUE, TRUE, NULL ); // Manual-Reset event


    // Create the thread that Handles the Keyboard and mouse input.
    // The main thread has to keep dispatching the WinSock Messages since
    // we use Non-Blocking sockets.
    gwi.hNetworkThread = CreateThread( NULL, 0, 
        ( LPTHREAD_START_ROUTINE )DoTelnetCommands, ( LPVOID ) &gwi, 0, &dwThreadId );

    /* Acquire and dispatch messages until a WM_QUIT message is received. */

    while ( GetMessage(&msg, gwi.hwnd, 0, 0) )
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }

    SetConsoleCtrlHandler(&ControlHandler, FALSE);

    DoProcessCleanup();

    // Save user settings.
    SetUserSettings(&ui);

    ExitProcess(0);
    return 0;
}

void CreateTelnetPromptConsole()
{
    //create a new console screen buffer. this is to be used for the remote
    //session data
    g_hTelnetPromptConsoleBuffer = CreateConsoleScreenBuffer(
        GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL, CONSOLE_TEXTMODE_BUFFER, NULL );

    if( g_hTelnetPromptConsoleBuffer == INVALID_HANDLE_VALUE )
    {
        exit( -1 );
    }

     SetConsoleScreenBufferSize( g_hTelnetPromptConsoleBuffer, gwi.sbi.dwSize );
    gwi.hOutput = g_hTelnetPromptConsoleBuffer;
}

/****************************************************************************

  FUNCTION: FInitApplication(HINSTANCE)

  PURPOSE: Initializes window data and registers window class

  COMMENTS:

          This function is called at initialization time only if no other
          instances of the application are running.  This function performs
          initialization tasks that can be done once for any number of running
          instances.

          In this case, we initialize a window class by filling out a data
          structure of type WNDCLASS and calling the Windows RegisterClass()
          function.  Since all instances of this application use the same window
          class, we only need to do this when the first instance is initialized.


****************************************************************************/
int
FInitApplication(int argc, TCHAR** argv, WI *pwi)
{
    WNDCLASS  wc;
#ifdef DEBUG
    int       argi;  // for indexing argc.
#endif

    WSADATA             WsaData;
    int                 WsaErr;
    BOOL fServerFound = 0;
    TCHAR rgchTerm[ 25 ]; //term type length is 25 
    
    InitCodeModeFlags(GetConsoleOutputCP());

    /* Set the default user settings */
    SfuZeroMemory(&ui, sizeof(UI));//no overflow. size constant.

    ui.nottelnet = TRUE;    // Assume that is not a telnet server that we would connect to ...

    //Initialize logging related variables
    ui.bLogging = FALSE;
    ui.hLogFile = NULL;

    ui.dwMaxRow = 0;
    ui.dwMaxCol = 0;

    CreateTelnetPromptConsole();
// We really do not care about the success or failure of this function.
		HrLoadLocalizedLibrarySFU(GetModuleHandle(NULL),  ( LPTSTR )L"telnetcr.dll", &ghInstance, NULL);
		
		ASSERT(ghInstance);

#ifndef NO_PCHECK
#ifndef WHISTLER_BUILD
    if ( !IsLicensedCopy() )
    {
        TCHAR g_szErrRegDelete[ MAX_STRING_LENGTH ];
        LoadString(ghInstance, IDS_ERR_LICENSE, g_szErrRegDelete,
                   sizeof(g_szErrRegDelete) / sizeof(TCHAR));
        MessageBox(NULL, g_szErrRegDelete, ( LPTSTR )_T(" "), MB_OK);
        exit( 1 );
    }
#endif
#endif

    LoadString(ghInstance, IDS_APPNAME, (LPTSTR) szAppName, SMALL_STRING);

    GetUserSettings(&ui);

    ui.nCyChar      = 1;        // char height 
    ui.nCxChar      = 1;        // char width 

    WsaErr = WSAStartup( 0x0101, &WsaData ); // make sure winsock is happy - noop for now

    if( WsaErr )
    {
        ErrorMessage(szCantInitSockets, szAppName);
        SetLastError( WsaErr );
        return WsaErr;
    }

    switch (GetConsoleOutputCP())
    {
    case 932:
    case 949:
        SetThreadLocale(
            MAKELCID(
                    MAKELANGID( PRIMARYLANGID(GetSystemDefaultLangID()),
                                SUBLANG_ENGLISH_US),
                    SORT_DEFAULT
                    )
            );
        break;
    case 936:
        SetThreadLocale(
            MAKELCID(
                    MAKELANGID( PRIMARYLANGID(GetSystemDefaultLangID()),
                                SUBLANG_CHINESE_SIMPLIFIED),
                    SORT_DEFAULT
                    )
            );
        break;
    case 950:
        SetThreadLocale(
            MAKELCID(
                    MAKELANGID( PRIMARYLANGID(GetSystemDefaultLangID()),
                                SUBLANG_CHINESE_TRADITIONAL),
                    SORT_DEFAULT
                    )
            );
        break;
    default:
        SetThreadLocale(
            MAKELCID(
                    MAKELANGID( LANG_ENGLISH,
                                SUBLANG_ENGLISH_US ),
                    SORT_DEFAULT
                    )
            );
        break;
    }

    LoadString(ghInstance, IDS_USAGE, (LPTSTR) szUsage, 1399);
    LoadString(ghInstance, IDS_VERSION, (LPTSTR) szVersion, SMALL_STRING);
    LoadString(ghInstance, IDS_CONNECTIONLOST, (LPTSTR) szConnectionLost, 254);
    LoadString(ghInstance, IDS_TITLEBASE, (LPTSTR) szTitleBase, SMALL_STRING);
    LoadString(ghInstance, IDS_TITLENONE, (LPTSTR) szTitleNone, SMALL_STRING);
    LoadString(ghInstance, IDS_TOOMUCHTEXT, (LPTSTR) szTooMuchText, 255);
    LoadString(ghInstance, IDS_CONNECTING, (LPTSTR) szConnecting, SMALL_STRING);
    LoadString(ghInstance, IDS_CONNECTFAILED, (LPTSTR) szConnectFailed, 254);
    LoadString(ghInstance, IDS_CONNECTFAILEDMSG, (LPTSTR) szConnectFailedMsg, 254);
    LoadString(ghInstance, IDS_ONPORT, szOnPort, SMALL_STRING );
    LoadString(ghInstance, IDS_CANT_INIT_SOCKETS, szCantInitSockets, SMALL_STRING );

    LoadString(ghInstance, IDS_INFO_BANNER, szInfoBanner, 511 );
    LoadString(ghInstance, IDS_ESCAPE_CHAR, szEscapeChar, SMALL_STRING );
    LoadString(ghInstance, IDS_PROMPT_STR, szPrompt, SMALL_STRING );
    LoadString(ghInstance, IDS_INVALID_STR, szInvalid, 254 );
    LoadString(ghInstance, IDS_BUILD_INFO, szBuildInfo, 254 );
    
    LoadString(ghInstance, IDS_CLOSE, szClose, SMALL_STRING );
    LoadString(ghInstance, IDS_DISPLAY, szDisplay, SMALL_STRING );
    LoadString(ghInstance, IDS_HELP, szHelpStr, SMALL_STRING );
    LoadString(ghInstance, IDS_OPEN, szOpen, SMALL_STRING );
    LoadString(ghInstance, IDS_OPENTO, szOpenTo, SMALL_STRING );
    LoadString(ghInstance, IDS_OPENUSAGE, szOpenUsage, SMALL_STRING );
    LoadString(ghInstance, IDS_QUIT, szQuit, SMALL_STRING );
    LoadString(ghInstance, IDS_SEND, szSend, SMALL_STRING );
    LoadString(ghInstance, IDS_SET, szSet, SMALL_STRING );
    LoadString(ghInstance, IDS_STATUS, szStatus, SMALL_STRING );
    LoadString(ghInstance, IDS_UNSET, szUnset, SMALL_STRING );
//#if defined(FE_IME)
//    LoadString(ghInstance, IDS_ENABLE_IME_SUPPORT, szEnableIMESupport, SMALL_STRING );
//    LoadString(ghInstance, IDS_DISABLE_IME_SUPPORT, szDisableIMESupport, SMALL_STRING );
//#endif /* FE_IME */
    
    LoadString(ghInstance, IDS_WILL_AUTH, szWillAuth, SMALL_STRING );
    LoadString(ghInstance, IDS_WONT_AUTH, szWontAuth, SMALL_STRING );
    LoadString(ghInstance, IDS_LOCAL_ECHO_ON, szLocalEchoOn, SMALL_STRING );
    LoadString(ghInstance, IDS_LOCAL_ECHO_OFF, szLocalEchoOff, SMALL_STRING );
//#if defined(FE_IME)
//    LoadString(ghInstance, IDS_ENABLE_IME_ON, szEnableIMEOn, SMALL_STRING );
//#endif /* FE_IME */

    LoadString(ghInstance, IDS_CONNECTED_TO, szConnectedTo, SMALL_STRING );
    LoadString(ghInstance, IDS_NOT_CONNECTED, szNotConnected, SMALL_STRING );
    LoadString(ghInstance, IDS_NEGO_TERM_TYPE, szNegoTermType, SMALL_STRING );
    LoadString(ghInstance, IDS_PREF_TERM_TYPE, szPrefTermType, 255 );

    LoadString(ghInstance, IDS_SET_FORMAT, szSetFormat, 254 );
    LoadString(ghInstance, IDS_SUPPORTED_TERMS, szSupportedTerms, 254 );
    LoadString(ghInstance, IDS_UNSET_FORMAT, szUnsetFormat, 254 );
    
    if((GetACP() == JAP_CODEPAGE) && FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80))
    {
        LoadString(ghInstance, IDS_SET_HELP_JAP, szSetHelp, 1023 );
        LoadString(ghInstance, IDS_UNSET_HELP_JAP, szUnsetHelp, 1023 );
        LoadString(ghInstance, IDS_HELP_STR_JAP, szHelp, 1023 );
    }
    else
    {
        LoadString(ghInstance, IDS_SET_HELP, szSetHelp, 1023 );
        LoadString(ghInstance, IDS_UNSET_HELP, szUnsetHelp, 1023 );
        LoadString(ghInstance, IDS_HELP_STR, szHelp, 1023 );
    } 

//#if defined(FE_IME)
//    LoadString(ghInstance, IDS_ENABLE_IME_FORMAT, szEnableIMEFormat, SMALL_STRING );
//    LoadString(ghInstance, IDS_ENABLE_IME_HELP, szEnableIMEHelp, 254 );
//    LoadString(ghInstance, IDS_DISABLE_IME_FORMAT, szDisableIMEFormat, SMALL_STRING );
//    LoadString(ghInstance, IDS_DISABLE_IME_HELP, szDisableIMEHelp, 254 );
//#endif /* FE_IME */

    //LoadString(ghInstance, IDS_ESCAPE_CHARACTER, szEscapeCharacter, 2 );


    SetEnvironmentVariable( TEXT( SFUTLNTVER ), TEXT( "2" ) );

    wcscpy( szUserName, ( LPTSTR )L""); //This is used as a flag to detect presence of
                              // -l -a options.
                              //no overflow.
    wcscpy( g_szLogFile, ( LPTSTR )L"" );//no overflow.
    if(argc > 1)
    {
        INT i = 1;
        while( i < argc )
        {
            if( argv[i][0] == L'-'  ||  argv[i][0] == L'/' )  
            {
                switch( argv[i][ 1 ] )
                {
                    case L'f':
                    case L'F':
                        if( argv[i][2] == L'\0' )
                        {
                            if( ++i >= argc )
                            {
                                //exit with usage message
                                i--;
                                argv[i][0] = L'-';
                                argv[i][1] = L'?';
                                continue;
                            }
                            
                            _tcsncpy( g_szLogFile, argv[i], 
                                min( _tcslen(argv[i]) + 1, MAX_PATH + 1 ) );
                        }
                        else
                        {                            
                            _tcsncpy( g_szLogFile, ( argv[i] + wcslen( ( LPWSTR )L"-f" ) ),
                                    min( _tcslen(argv[i]) + 1, MAX_PATH + 1 )  );
                        }
                        g_szLogFile[ MAX_PATH + 1 ] = L'\0';
                        if( !InitLogFile( g_szLogFile ) )
                        {
                            DWORD dwWritten = 0;
                            TCHAR szMsg[ MAX_STRING_LENGTH ];
                            LoadString( ghInstance, IDS_BAD_LOGFILE, szMsg, MAX_STRING_LENGTH );
                            WriteConsole( g_hSessionConsoleBuffer, szMsg, 
                                          _tcslen(szMsg), &dwWritten, NULL);
                            exit(0);
                        }
                        ui.bLogging = TRUE;
                        break;

                    case L'l':
                    case L'L':
                        if( argv[i][2] == L'\0' )
                        {
                            if( ++i >= argc )
                            {
                                //exit with usage message
                                i--;
                                argv[i][0] = L'-';
                                argv[i][1] = L'?';
                                continue;
                            }
                            
                            _tcsncpy( szUserName, argv[i], 
                                min( _tcslen(argv[i]) + 1, UNLEN ) );
                        }
                        else
                        {
                            //when the term name is given after -t without 
                            //any spaces. 2 accounts for -t.
                            _tcsncpy( szUserName, ( argv[i] + 2 ),
                                    min( _tcslen(argv[i]) - 1, UNLEN ) );
                        }
                        //Will help if a loooong user name is given
                        szUserName[ UNLEN ] = L'\0';
                        break;
                    case L'a':
                    case L'A':
                        if( argv[i][2] == L'\0' )
                        {
                            DWORD dwSize = UNLEN + 1;
                            GetUserName( szUserName, &dwSize ); 
                        }
                        else
                        {
                            argv[i][1] = L'?'; //go back and print usage message
                            i--;
                        }
                        break;

                    case L'e':
                    case L'E':
                        if( argv[i][2] == L'\0' )
                        {
                            if( ++i >= argc )
                            {
                                //exit with usage message
                                i--;
                                argv[i][0] = L'-';
                                argv[i][1] = L'?';
                                continue;
                            }

                            g_chEsc = argv[i][0];  //Get the first char
                        }
                        else
                        {
                            g_chEsc = argv[i][2];  //Get the first char
                        }
                        break;

                    case L't':
                    case L'T':
                        if( argv[i][2] == L'\0' )
                        {
                            if( ++i >= argc )
                            {
                                //exit with usage message
                                i--;
                                argv[i][0] = L'-';
                                argv[i][1] = L'?';
                                continue;
                            }
                            
                            _tcsncpy( rgchTerm, argv[i], 
                                min( _tcslen(argv[i]) + 1, 24 ) );
                        }
                        else
                        {
                            //when the term name is given after -t without 
                            //any spaces. 2 accounts for -t.
                            _tcsncpy( rgchTerm, ( argv[i] + 2 ),
                                    min( _tcslen(argv[i]) - 1, 24 ) );
                        }
                        //This statement is helpful only when term type 
                        //length exceeds 24 chars.
                        rgchTerm[24] = L'\0';
                        gwi.trm.RequestedTermType =  
                            GetRequestedTermType( rgchTerm );
                        if( gwi.trm.RequestedTermType < 0 )
                        {
                            DWORD dwWritten;
                                WriteConsole(g_hSessionConsoleBuffer, szSupportedTerms, 
                                _tcslen(szSupportedTerms), &dwWritten, NULL);
                            exit(0);
                        }
                        break;
                    case L'?':
                    default:
                        PrintUsage();
                        exit(0);
                } 
            }
            else
            {
                if( fServerFound )
                {
                        PrintUsage();
                        exit(0);
                }
                fServerFound = 1;
                _tcsncpy( rgchHostName, argv[i], 
                    min( _tcslen(argv[i]), cchMaxHostName/sizeof(TCHAR) - 
                    sizeof(TCHAR) ));

                g_szPortNameOrNo[ 0 ] = 0;
                if( ++i >= argc )
                {
                    continue;
                }
                if( IsCharAlpha( argv[i][0] ) || 
                       IsCharAlphaNumeric( argv[i][0] ) ) 
                {
                    _tcsncpy( g_szPortNameOrNo, argv[i], 
                        min( _tcslen(argv[i]), cchMaxHostName - 
                        sizeof(TCHAR) ));

                    g_szPortNameOrNo[ cchMaxHostName -1 ] = 0;
        
                }
                else
                {
                    // neither a port number nor a string representing 
                    // a service. need to print usage
                    i--;
                }
            }
            i++;
        }
    }

    //MBSC user name value now available in szUser
    if( wcscmp( szUserName, ( LPTSTR )L"" ) != 0 )    
    {
        DWORD dwNum = 0;

        dwNum = WideCharToMultiByte( GetConsoleCP(), 0, szUserName, -1, NULL, 0, NULL, NULL );
        if(dwNum)
        	szUser = ( CHAR * ) malloc( dwNum * sizeof( CHAR ) );
        else
        	return 0;
        if( !szUser )
        {
            return 0;
        }

        dwNum = WideCharToMultiByte( GetConsoleCP(), 0, szUserName, -1, szUser, dwNum, NULL, NULL );
    }

    sTelnetCommands[0].sName = szClose;
    sTelnetCommands[0].pCmdHandler = CloseTelnetSession;

    sTelnetCommands[1].sName = szDisplay;
    sTelnetCommands[1].pCmdHandler = DisplayParameters;
    
    sTelnetCommands[2].sName = szHelpStr;
    sTelnetCommands[2].pCmdHandler = PrintHelpStr;
    
    sTelnetCommands[3].sName = szOpen;
    sTelnetCommands[3].pCmdHandler = OpenTelnetSession;

    sTelnetCommands[4].sName = szQuit;
    sTelnetCommands[4].pCmdHandler = QuitTelnet;

    sTelnetCommands[5].sName = szSend;
    sTelnetCommands[5].pCmdHandler = SendOptions;
    
    sTelnetCommands[6].sName = szSet;
    sTelnetCommands[6].pCmdHandler = SetOptions;

    sTelnetCommands[7].sName = szStatus;
    sTelnetCommands[7].pCmdHandler = PrintStatus;

    sTelnetCommands[8].sName = szUnset;
    sTelnetCommands[8].pCmdHandler = UnsetOptions;
    
if (FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80))

    {
        int i;

        for( i=0 ; i<NUMBER_OF_KANJI ; i++ )
        {
            LoadString(ghInstance, KanjiList[i].KanjiMessageID,
                        KanjiList[i].KanjiDescription, 255);
        }

        LoadString(ghInstance, IDS_VT100KANJI_EMULATION, szVT100KanjiEmulation, SMALL_STRING);
    }
    
    // Setup the Handle Routine for Ctrl-C etc.
    SetConsoleCtrlHandler(&ControlHandler, TRUE);

    /* Fill in window class structure with parameters that describe the
     * main window.
     */
    wc.style        = CS_VREDRAW | CS_HREDRAW;
    wc.lpfnWndProc  = MainWndProc;

    wc.cbClsExtra   = 0;
    wc.cbWndExtra   = sizeof(HANDLE)+sizeof(SVI *);
    wc.hInstance    = ghInstance;
    wc.hIcon        = NULL;
    wc.hCursor      = NULL;
    wc.hbrBackground= ( HBRUSH )( COLOR_WINDOW + 1 );
    wc.lpszMenuName = NULL;
    wc.lpszClassName= ( LPTSTR )TEXT("TelnetClient");

    /* Register the window class and return success/failure code. */
    if ( RegisterClass(&wc) == 0 )
        return GetLastError();

    pwi->hwnd = CreateWindow( ( LPTSTR )TEXT("TelnetClient"),
            NULL,
            WS_POPUP, // not visible
            0, 0, 0, 0, // not height or width
            NULL, NULL, ghInstance, (LPVOID)pwi);

    if ( pwi->hwnd == NULL )
        return GetLastError();

    g_hRemoteNEscapeModeDataSync = CreateEvent( NULL, TRUE, TRUE, NULL );
    if( !g_hRemoteNEscapeModeDataSync )
    {
        return GetLastError();
    }

    return 0;
}


// maps window messages to their names.

/****************************************************************************

        FUNCTION: MainWndProc(HWND, UINT, WPARAM, LPARAM)

        PURPOSE:  Processes messages

        COMMENTS:

                To process the IDM_ABOUT message, call MakeProcInstance() to get the
                current instance address of the About() function.  Then call Dialog
                box which will create the box according to the information in your
                WinTel.rc file and turn control over to the About() function.   When
                it returns, free the intance address.

****************************************************************************/
LRESULT CALLBACK
MainWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    static HANDLE hInst = NULL;
    static BOOL fInited = FALSE;
    WI *pwi = NULL;
    BOOL fRet = FALSE;

    CHARSETINFO csi;
    DWORD_PTR dw;

    if ( message != WM_CREATE )
        pwi = (WI *)GetWindowLongPtr(hwnd, WL_TelWI);


    switch ( message )
    {
    case WM_CREATE:

        DEBUG_PRINT(("WM_CREATE received\n"));

        hInst = ((LPCREATESTRUCT)lParam)->hInstance;

        pwi = (WI *)((LPCREATESTRUCT)lParam)->lpCreateParams;

        SetWindowLongPtr(hwnd, WL_TelWI, (LONG_PTR)pwi);

        fHungUp = FALSE;

        if( FGetCodeMode(eCodeModeIMEFarEast) )
        {
            if ( ui.fDebug & fdwKanjiModeMask )
            {

                dw = GetACP();

                if (!TranslateCharsetInfo((DWORD*)dw, &csi, TCI_SRCCODEPAGE))
                {
                    csi.ciCharset = ANSI_CHARSET;
                }

                ui.lf.lfCharSet         = (UCHAR)csi.ciCharset;
                ui.lf.lfOutPrecision    = OUT_DEFAULT_PRECIS;
                ui.lf.lfClipPrecision   = CLIP_DEFAULT_PRECIS;
                ui.lf.lfQuality         = DEFAULT_QUALITY;
                ui.lf.lfPitchAndFamily  = FIXED_PITCH | FF_MODERN;


                //
                // Get IME Input Context.
                //
                hImeContext = ImmGetContext(hwnd);

                //
                // Assoicate current font to Input Context.
                //
                ImmSetCompositionFont(hImeContext,&ui.lf);
            }
        }

        if (FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80))
        // (a-roopb) we set this in GetUserSettings()
        // pwi->trm.puchCharSet = rgchCharSetWorkArea;
        // if(!SetConsoleOutputCP(932))
        //  MessageBox(NULL, _T("Failed to load Codepage 932"), _T("ERROR"), MB_OK);
        ;
else
        pwi->trm.puchCharSet = rgchNormalChars;
        
        if (pwi->nd.lpReadBuffer = (LPSTR)LocalAlloc(LPTR, sizeof(UCHAR)*READ_BUF_SZ))
        {
            pwi->nd.SessionNumber = nSessionNone;

            fRet = TRUE;
        }
        else
        {
            DestroyWindow( hwnd );
            break;
        }
        if (!(pwi->nd.lpTempBuffer = (LPSTR)LocalAlloc(LPTR, sizeof(UCHAR)*READ_BUF_SZ)))
        {
            DestroyWindow( hwnd );
            break;
        }

        pwi->nd.cbOld = 0;
        pwi->nd.fRespondedToWillEcho = FALSE;
        pwi->nd.fRespondedToWillSGA  = FALSE;
        pwi->nd.fRespondedToDoAUTH = FALSE;
        pwi->nd.fRespondedToDoNAWS = FALSE;

        //we are making sure that we always have VT100 arrow key support
        ClearVTArrow(&pwi->trm);

        //
        // (a-roopb) We set these in GetUserSettings()
        //ui.fDebug &= ~(fdwVT52Mode|fdwVT80Mode);
        //ClearVT80(&gwi.trm);
        //ClearKanjiStatus(&gwi.trm, CLEAR_ALL);
        //ClearKanjiFlag(&gwi.trm);
        //SetupCharSet(&gwi.trm);
        //

#if 0

    if (FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80))
        {

        if (ui.fDebug & fdwVT80Mode)
        {
               DWORD iMode = (ui.fDebug & fdwKanjiModeMask);
               INT   i;

               SetVT80(&pwi->trm);

               /* set current selection */
               for(i=0 ; i<NUMBER_OF_KANJI ; i++)
               {
                   if(iMode == KanjiList[i].KanjiID) {
                        SetKanjiMode(&pwi->trm,KanjiList[i].KanjiEmulationID);
                        break;
                    }
               }

               if(i == NUMBER_OF_KANJI ) {
               /* set default */
                    SetSJISKanji(&pwi->trm);
                    ui.fDebug &= ~fdwKanjiModeMask;
                    ui.fDebug |= fdwSJISKanjiMode;
               }
         }
         else
         {
                ClearKanjiFlag(&pwi->trm);
                ClearVT80(&pwi->trm);
         }
        }

        if (ui.fDebug & fdwVT100CursorKeys)
        {
            ClearVTArrow(&pwi->trm);
        }
        else
        {
            SetVTArrow(&pwi->trm);
        }

        /* Append the most recently connected machines to the Machine menu */
        hmenu = HmenuGetMRUMenu(hwnd, &ui);

        if (ui.cMachines > 0) {
            AppendMenu(hmenu, MF_SEPARATOR, 0, 0);
        }

        for (i=0; i<ui.cMachines; ++i)
        {
            wsprintf(pchNBBuffer, szMachineMenuItem, (short)(i+1),
                     (BYTE *)(ui.rgchMachine[i]));
            AppendMenu(hmenu, (UINT)(MF_ENABLED | MF_STRING), (UINT)(IDM_MACHINE1+i),
                       (LPCSTR)pchNBBuffer);
        }

        /* Disable maximizing or resizing the main window */
        hmenu = GetSystemMenu(hwnd, FALSE);

        //                EnableMenuItem(hmenu, SC_MAXIMIZE, MF_BYCOMMAND | MF_GRAYED);
        //                EnableMenuItem(hmenu, SC_SIZE, MF_BYCOMMAND | MF_GRAYED);

        DrawMenuBar( hwnd );

#endif

        fInited = TRUE;
        break;

    case WM_CLOSE:
        if (pwi->ichTelXfer != 0)
        {
            if (!FTelXferEnd(pwi, SV_DISCONNECT))
                break;
        }
        break;

    case WM_DESTROY:
        if (pwi != NULL)
        {
            if (pwi->trm.uTimer != 0)
            {
                KillTimer(hwnd, uTerminalTimerID);
                pwi->trm.uTimer = 0;
            }

            if (pwi->ichTelXfer != 0)
            {
                (void)FTelXferEnd(pwi, SV_QUIT);
            }

            /*
             * If in session then cancel current transmission and
             * hangup on the host, close shop and head out of town...
             */

            if (fInited == TRUE)
            {
                SetUserSettings(&ui);
                FCloseConnection(hwnd);
            }
        }

        SetWindowLong(hwnd, WL_TelWI, 0L);
        
        if( FGetCodeMode(eCodeModeIMEFarEast) )
        {
            if ( ui.fDebug & fdwKanjiModeMask )
            {
                //
                // Release input context.
                //
                ImmReleaseContext(hwnd,hImeContext);
            }
        }

        break;
#if 0
    case NN_HOSTRESOLVED:
        if ( WSAGETASYNCERROR(lParam) == 0 )
            pwi->nd.host = (struct hostent *)pwi->nd.szResolvedHost;
        else
        {
            g_dwSockErr = WSAGETASYNCERROR(lParam);
        }

        SetEvent( g_hAsyncGetHostByNameEvent );
        break;
#endif
    case NN_LOST:    /* Connection Lost */

        DEBUG_PRINT(("NN_LOST received\n"));

        if (fConnected && !fHungUp)
        {
            DWORD dwNumWritten;
            WriteConsole(pwi->hOutput, szConnectionLost, _tcslen(szConnectionLost), &dwNumWritten, NULL);
        }

        /*
         * If a connection attempt is made when we already have a
         * connection, we hang up the connection and then attempt
         * to connect to the desired machine. A side effect of the
         * hang up of the previous connection is that we get a
         * NN_LOST notification. So after a
         * connection-hangup-connection, we ignore the first NN_LOST
         * notification.
         */
        if ( fHungUp )
        {
            fHungUp = FALSE;
            break;
        }
        
        if( fClientLaunchedFromCommandPrompt )
        {
            g_lExitTelnet++;
        }
        else
        {
            DWORD dwWritten;
            INPUT_RECORD iRec;
            TCHAR wcChar;
            TCHAR szContinue[ MAX_STRING_LENGTH ];

            LoadString(ghInstance, IDS_CONTINUE, szContinue, 
                                            sizeof(szContinue)/sizeof(TCHAR) );

            SetConsoleActiveScreenBuffer( g_hSessionConsoleBuffer );
            WriteConsole(g_hSessionConsoleBuffer, szContinue, 
                    _tcslen(szContinue), &dwWritten, NULL);
            ReadConsole(pwi->hInput, &wcChar, 1, &dwWritten, NULL );
            SetConsoleActiveScreenBuffer( g_hTelnetPromptConsoleBuffer );
            /*
            We had connection and it broke off. Our ReadConsoleInput is stuck.
            we need to wake it up by writing something to Console Input.
            */
            {
                iRec.EventType = FOCUS_EVENT;
				WriteConsoleInput(pwi->hInput, &iRec, 1, &dwWritten );            
            }

            CloseTelnetSession( NULL );
        }

        if (pwi->ichTelXfer != 0)
        {
           (void)FTelXferEnd(pwi, SV_HANGUP);
        }
        fConnected = FHangupConnection(pwi, &pwi->nd);
        DoTermReset(pwi, &pwi->trm);
        //when the term name is given after -t without 
        //any spaces. 2 accounts for -t.
            
        pwi->nd.cbOld = 0;
        pwi->nd.fRespondedToWillEcho = FALSE;
        pwi->nd.fRespondedToWillSGA  = FALSE;
        pwi->nd.fRespondedToDoAUTH = FALSE;
        pwi->nd.fRespondedToDoNAWS = FALSE;
        pwi->nd.hsd = INVALID_SOCKET;

        break;

#ifdef USETCP
    case WS_ASYNC_SELECT:
#ifdef  TCPTEST
        snprintf(DebugBuffer,sizeof(DebugBuffer)-1, "WS_ASYNC_SELECT(%d) received\n",
                WSAGETSELECTEVENT(lParam));
        OutputDebugString(DebugBuffer);
#endif

        switch (WSAGETSELECTEVENT(lParam)) {
        case FD_READ:
            DEBUG_PRINT(("FD_READ received\n"));

            FProcessFDRead(hwnd);
            break;

        case FD_WRITE:
            DEBUG_PRINT(( "FD_WRITE received\n" ));

            //FProcessFDWrite(hwnd);
            break;

        case FD_CLOSE:
            DEBUG_PRINT(("FD_CLOSE received\n"));

            (void)PostMessage((HWND)hwnd, (UINT)NN_LOST, (WPARAM)0, (LPARAM)(void FAR *)hwnd);
            break;

        case FD_OOB:
            DEBUG_PRINT(("FD_OOB received\n"));

            FProcessFDOOB(hwnd);
            break;
        }

#endif

    default:         /* Passes it on if unprocessed        */
//      defresp:

        //  DEBUG_PRINT(( "<-- MainWndProc()\n" ));
        return (DefWindowProc(hwnd, message, wParam, lParam));
    }


    DEBUG_PRINT(( "<-- MainWndProc() returning 0.\n" ));

    return (0);
}

void
GetUserSettings(UI *pui)
{
    LONG    lErr;
    HKEY    hkey = 0;
    DWORD   dwType;
    DWORD   dwDisp = 0;
    TCHAR    rgchValue[48];
    LCID  lcid;
    DWORD dwMode = ( DWORD )-1;
    DWORD dwSize = 0;
    TCHAR szTlntMode[ SMALL_STRING+1 ];
    BOOL bResetVT80 = TRUE;
    DWORD dwStatus = 0;

    lcid = GetThreadLocale();

    lErr = RegCreateKeyEx(HKEY_CURRENT_USER,TEXT("Software\\Microsoft\\Telnet"),
                          0, NULL, REG_OPTION_NON_VOLATILE,
                          KEY_QUERY_VALUE | KEY_SET_VALUE,
                          NULL, &hkey, &dwDisp);

    if (lErr != ERROR_SUCCESS)
    {
      if ( FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80))
        gwi.trm.puchCharSet = rgchCharSetWorkArea;
        return;
    }

    dwDisp = sizeof(gwi.trm.RequestedTermType);
    if( ERROR_SUCCESS != (RegQueryValueEx(hkey, TEXT("TERMTYPE"), NULL, &dwType, 
                        (LPBYTE)&gwi.trm.RequestedTermType, &dwDisp)))
    {
         gwi.trm.RequestedTermType = TT_ANSI;
    }

    dwDisp = sizeof(DWORD);
    if( ERROR_SUCCESS != (RegQueryValueEx(hkey,TEXT("NTLM"), NULL, &dwType,
                        (LPBYTE)&ui.bWillAUTH, &dwDisp)))
    {
        ui.bWillAUTH = TRUE;
    }

    /* Get the value of the left size of the Window */
    LoadString(ghInstance, IDS_DEBUGFLAGS, rgchValue, sizeof(rgchValue)/sizeof(TCHAR));
    dwDisp = sizeof(pui->fDebug);
    if ( FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80))
    {
        if( ERROR_SUCCESS != RegQueryValueEx(hkey, rgchValue, NULL, &dwType,
                                                        (LPBYTE)&pui->fDebug, &dwDisp)) 
        {
            /* default is VT80/Kanji and Shift-Jis mode */
    
            pui->fDebug |= (fdwVT80Mode | fdwSJISKanjiMode);
        }
    } 
    else
        (void)RegQueryValueEx(hkey, rgchValue, NULL, &dwType,
                                                    (LPBYTE)&pui->fDebug, &dwDisp);


    LoadString(ghInstance, IDS_PROMPTFLAGS, rgchValue, sizeof(rgchValue)/sizeof(TCHAR));
    dwDisp = sizeof(pui->fPrompt);
    (void)RegQueryValueEx(hkey, rgchValue, NULL, &dwType,
                          (LPBYTE)&pui->fPrompt, &dwDisp);

    dwDisp = sizeof(BOOL);
    if( ERROR_SUCCESS != (RegQueryValueEx(hkey, TEXT("BSASDEL"), 0, &dwType, 
                        (LPBYTE)&g_bSendBackSpaceAsDel, &dwDisp )))
    {
        g_bSendBackSpaceAsDel = 0;
    }

    dwDisp = sizeof(BOOL);
    if( ERROR_SUCCESS != (RegQueryValueEx(hkey, TEXT("DELASBS"), 0, &dwType, 
                        (LPBYTE)&g_bSendDelAsBackSpace, &dwDisp )))
    {
         g_bSendDelAsBackSpace = 0;
    }

    dwDisp = sizeof( ui.dwCrLf );
    if( ERROR_SUCCESS != (RegQueryValueEx(hkey, TEXT("CRLF"), 0, &dwType, (LPBYTE)&ui.dwCrLf, &dwDisp )))
    {
        /*++
        The most significant bit in ui.fDebug ( read from HKCU\Software\Microsoft\telnet\DebugFlags)
        corresponds to CRLF setting on w2k. If this bit is 1, then the client sends only CR. 
        If this bit is 0, client sends both CR,LF. When we don't find CRLF value
        in HKCU\Software\Microsoft\telnet, that could mean two things
            1. User has upgraded from w2k : In this case, we should check whether the user had 
                changed CRLF setting and honor that setting. So if MSBit of ui.fDebug is 1, setting is CR
                else it's CR & LF.
            2. Fresh whistler installation : In this case, MSBit of fDebug will be 0 
                so the client will send CR & LF, which is the default.
        --*/
        if(ui.fDebug & fdwOnlyCR)
        {
            ui.dwCrLf = FALSE;
            ClearLineMode( &( gwi.trm ) );
        }
        else //this means that we upgraded from w2k and CRLF was set on w2k so preserve
        {
            ui.dwCrLf = TRUE;
            SetLineMode( &( gwi.trm ) );
        }
            
    }
    else
    {
       	ui.dwCrLf ? SetLineMode(&( gwi.trm )): ClearLineMode(&(gwi.trm));
    }
    dwDisp = MAX_PATH + 1;
    dwStatus = RegQueryValueEx(hkey, TEXT("MODE"), 0, &dwType, (LPBYTE)szTlntMode, &dwDisp );
    if( _tcsicmp( szTlntMode, L"Stream" ) != 0 && _tcsicmp( szTlntMode, L"Console" ) != 0)
    {
        _tcscpy( szTlntMode, L"Console" );//no overflow. Source string is const wchar *.
    }
    SetEnvironmentVariable( TEXT( SFUTLNTMODE ), szTlntMode );


    if ( FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80))
        {
// Bug Emulation in VT100/Kanji(VT80)
// Abnormal AP is mh-e6.2 for PC-UX.
        LoadString(ghInstance, IDS_BUGEMUFLAGS, rgchValue, sizeof(rgchValue)/sizeof(TCHAR));
        dwDisp = sizeof(pui->fBugEmulation);
        if( ERROR_SUCCESS != RegQueryValueEx(hkey, rgchValue, NULL, &dwType,
                                                        (LPBYTE)&pui->fBugEmulation, &dwDisp))
        {
            /* default is non Emulation */
            pui->fBugEmulation = (DWORD)0;
        }

        // ACOS-KANJI Support Flga
        LoadString(ghInstance, IDS_ACOSFLAG, rgchValue, sizeof(rgchValue)/sizeof(TCHAR));
        dwDisp = sizeof(pui->fAcosSupportFlag);
        if( ERROR_SUCCESS != RegQueryValueEx(hkey, rgchValue, NULL, &dwType,
                                                        (LPBYTE)&pui->fAcosSupportFlag, &dwDisp
)) {
            /* Set default support */
#if defined(_X86_)
        /* if NEC_98 */
            if (( FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80)) &&
            (HIBYTE(LOWORD(GetKeyboardType(1))) == 0x0D))
        pui->fAcosSupportFlag = fAcosSupport;
        else
#endif // defined(_X86_)
            pui->fAcosSupportFlag = (DWORD)0;
        }
        if ( !(pui->fAcosSupportFlag & fAcosSupport)
            && ((fdwVT80Mode | fdwACOSKanjiMode) == (pui->fDebug & (fdwVT80Mode | 
                fdwACOSKanjiMode))) ) {
            pui->fDebug &= ~(fdwVT80Mode | fdwACOSKanjiMode);
            pui->fDebug |= (fdwVT80Mode | fdwSJISKanjiMode);
         }

        if( (GetACP() == JAP_CODEPAGE ) && ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("CODESET"), NULL, &dwType, 
                                    (LPBYTE)&dwMode, &dwDisp))
        {
            if( (LONG)dwMode >= 0 )
            {
                int i;

                for( i=0 ; i<NUMBER_OF_KANJI ; ++i )
                {
                    if( dwMode == KanjiList[i].KanjiID )
                    {
                        bResetVT80 = FALSE;
                        SetVT80(&gwi.trm);
                        ui.fDebug &= ~fdwKanjiModeMask;
                        ClearKanjiFlag(&gwi.trm);
                        ui.fDebug |= KanjiList[i].KanjiID;
                        ui.fDebug |= fdwVT80Mode;
                        SetKanjiMode(&gwi.trm,KanjiList[i].KanjiEmulationID);
                        gwi.trm.puchCharSet = rgchCharSetWorkArea;
                        SetupCharSet(&gwi.trm);
                        break;
                    }
                }
            }
        }

        if( bResetVT80 )
        {
            ui.fDebug &= ~(fdwVT52Mode|fdwVT80Mode);
            ui.fDebug &= ~(fdwKanjiModeMask);
            ClearVT80(&gwi.trm);
            ClearKanjiStatus(&gwi.trm, CLEAR_ALL);
            ClearKanjiFlag(&gwi.trm);
            gwi.trm.puchCharSet = rgchCharSetWorkArea;
            SetupCharSet(&gwi.trm);
        }
        
    }
    RegCloseKey( hkey );
}


void
SetUserSettings(UI *pui)
{
    LONG lErr;
    HKEY hkey = 0;
    TCHAR rgchValue[48];
    LCID  lcid;
    DWORD dwMode = ( DWORD )-1;
    DWORD dwSize = 0;
    TCHAR szTlntMode[ SMALL_STRING+1 ];

    lcid = GetThreadLocale();


    lErr = RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Telnet"),
                        0, KEY_SET_VALUE, &hkey);

    if (lErr != ERROR_SUCCESS)
    {
        return;
    }

#ifdef  TCPTEST
    snprintf(DebugBuffer, sizeof(DebugBuffer)-1,"End pui -> text = %lx, back = %lx\n",
            pui->clrText, pui->clrBk);
    OutputDebugString(DebugBuffer);
#endif

    RegSetValueEx(hkey, TEXT("TERMTYPE"), 0, REG_DWORD, 
                        (LPBYTE)&gwi.trm.RequestedTermType, sizeof(DWORD));

    RegSetValueEx(hkey, TEXT("NTLM"), 0, REG_DWORD,
                        (LPBYTE)&ui.bWillAUTH, sizeof(DWORD));

    //Make localecho non-sticky.
    pui->fDebug &= ~fdwLocalEcho;

    LoadString(ghInstance, IDS_DEBUGFLAGS, rgchValue, sizeof(rgchValue)/sizeof(TCHAR));
    (void)RegSetValueEx(hkey, rgchValue, 0, REG_DWORD,
                        (LPBYTE)&pui->fDebug, sizeof(DWORD));

    LoadString(ghInstance, IDS_PROMPTFLAGS, rgchValue, sizeof(rgchValue)/sizeof(TCHAR));
    (void)RegSetValueEx(hkey, rgchValue, 0, REG_DWORD,
                        (LPBYTE)&pui->fPrompt, sizeof(DWORD));

    RegSetValueEx(hkey, TEXT("BSASDEL"), 0, REG_DWORD, 
                        (LPBYTE)&g_bSendBackSpaceAsDel, sizeof(DWORD));
    RegSetValueEx(hkey, TEXT("DELASBS"), 0, REG_DWORD, 
                        (LPBYTE)&g_bSendDelAsBackSpace, sizeof(DWORD));

    RegSetValueEx(hkey, ( LPTSTR )TEXT("CRLF"), 0, REG_DWORD, (LPBYTE)&ui.dwCrLf, sizeof(DWORD));

    dwSize = GetEnvironmentVariable( TEXT( SFUTLNTMODE ), szTlntMode, SMALL_STRING+1 );
    if( dwSize <= 0 )
    {
        wcscpy( szTlntMode, L"Console" );//no overflow. Source string is const wchar *.
    }
    dwSize = 2 * wcslen( szTlntMode );
    RegSetValueEx(hkey,TEXT("MODE"), 0, REG_SZ, (LPBYTE)szTlntMode, dwSize );


    if ( (GetACP() == JAP_CODEPAGE ) && FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80))
        {
// Bug Emulation in VT100/Kanji(VT80)
// Abnormal AP is mh-e6.2 for PC-UX.
        LoadString(ghInstance, IDS_BUGEMUFLAGS, rgchValue, sizeof(rgchValue)/sizeof(TCHAR));
        (void)RegSetValueEx(hkey, rgchValue, 0, REG_DWORD,
                                            (LPBYTE)&pui->fBugEmulation, sizeof(DWORD));
    
// ACOS-KANJI Support Flga
        LoadString(ghInstance, IDS_ACOSFLAG, rgchValue, sizeof(rgchValue)/sizeof(TCHAR));
        (void)RegSetValueEx(hkey, rgchValue, 0, REG_DWORD,
                                   (LPBYTE)&pui->fAcosSupportFlag, sizeof(DWORD));

    if ( ui.fDebug & fdwKanjiModeMask )
    {
        dwMode = ui.fDebug & fdwKanjiModeMask;
    }

    (void)RegSetValueEx(hkey, TEXT("CODESET"), 0, REG_DWORD, (LPBYTE)&dwMode, sizeof(DWORD));
        }


    RegCloseKey( hkey );
}

/*
Description:

  Set SO_EXCLUSIVEADDRUSE on a socket.
Parameters:

  [in] socket
Return Values: On error, returns SOCKET_ERROR.
*/
int SafeSetSocketOptions(SOCKET s)
{
    int iStatus;
    int iSet = 1;
    iStatus = setsockopt( s, SOL_SOCKET, SO_EXCLUSIVEADDRUSE , ( char* ) &iSet,
                sizeof( iSet ) );
    return ( iStatus );
}

void
ErrorMessage(LPCTSTR pStr1, LPCTSTR pStr2)
{
    DWORD dwWritten;

    WriteConsole(gwi.hOutput, pStr1, _tcslen(pStr1), &dwWritten, NULL);
    WriteConsole(gwi.hOutput, ( LPTSTR )TEXT(": "), _tcslen( ( LPTSTR )TEXT(": ")), &dwWritten, NULL);
    WriteConsole(gwi.hOutput, pStr2, _tcslen(pStr2), &dwWritten, NULL);
    WriteConsole(gwi.hOutput, ( LPTSTR )TEXT("\n"), _tcslen( ( LPTSTR )TEXT("\n")), &dwWritten, NULL);
}

void ConnectTimeErrorMessage(LPCTSTR pStr1, LPCTSTR pStr2)
{
    DWORD dwWritten;

    WriteConsole(gwi.hOutput, pStr1, _tcslen(pStr1), &dwWritten, NULL);    
    WriteConsole(gwi.hOutput, ( LPTSTR )TEXT("."), _tcslen( ( LPTSTR )TEXT(".")), &dwWritten, NULL);
    WriteConsole(gwi.hOutput, ( LPTSTR )TEXT("\n"), _tcslen( ( LPTSTR )TEXT("\n")), &dwWritten, NULL);
    WriteConsole(gwi.hOutput, pStr2, _tcslen(pStr2), &dwWritten, NULL);
    WriteConsole(gwi.hOutput, ( LPTSTR )TEXT("\n"), _tcslen( ( LPTSTR )TEXT("\n")), &dwWritten, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\client\wintelsz.c ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
/****************************************************************************

        FILE: WinTelSz.c

        Declares global strings.

        TABS:

                Set for 4 spaces.

****************************************************************************/

#include <windows.h>                    // required for all Windows applications
#pragma warning (disable: 4201)			// disable "nonstandard extension used : nameless struct/union"
#include <commdlg.h>
#pragma warning (default: 4201)
#include "WinTel.h"                     // specific to this program

TCHAR szTitleBase[SMALL_STRING + 1];
TCHAR szTitleNone[SMALL_STRING + 1];

UCHAR szNewLine[] = "\r\n";


TCHAR szConnecting[SMALL_STRING + 1];
TCHAR szVersion[SMALL_STRING + 1];
TCHAR szAppName[SMALL_STRING + 1];

TCHAR szInfoBanner[512];
TCHAR szEscapeChar[SMALL_STRING + 1];
TCHAR szPrompt[SMALL_STRING + 1];
TCHAR szInvalid[255];
TCHAR szHelp[1024];
TCHAR szBuildInfo[255];

TCHAR szClose[SMALL_STRING + 1];
TCHAR szDisplay[SMALL_STRING + 1];
TCHAR szHelpStr[SMALL_STRING + 1];
TCHAR szOpen[SMALL_STRING + 1];
TCHAR szOpenTo[SMALL_STRING + 1];
TCHAR szOpenUsage[SMALL_STRING + 1];
TCHAR szQuit[SMALL_STRING + 1];
TCHAR szSend[SMALL_STRING + 1];
TCHAR szSet[SMALL_STRING + 1];
TCHAR szStatus[SMALL_STRING + 1];
TCHAR szUnset[SMALL_STRING + 1];

//#if defined(FE_IME)
//TCHAR szEnableIMESupport[SMALL_STRING + 1];
//TCHAR szDisableIMESupport[SMALL_STRING + 1];
//#endif /* FE_IME */

TCHAR szWillAuth[SMALL_STRING + 1];
TCHAR szWontAuth[SMALL_STRING + 1];
TCHAR szLocalEchoOn[SMALL_STRING + 1];
TCHAR szLocalEchoOff[SMALL_STRING + 1];

//#if defined(FE_IME)
//TCHAR szEnableIMEOn[SMALL_STRING + 1];
//#endif /* FE_IME */

TCHAR szConnectedTo[SMALL_STRING + 1];
TCHAR szNotConnected[SMALL_STRING + 1];
TCHAR szNegoTermType[SMALL_STRING + 1];
TCHAR szPrefTermType[255];

TCHAR szSetFormat[255];
TCHAR szSupportedTerms[255];
TCHAR szSetHelp[1024];
TCHAR szUnsetFormat[255];
TCHAR szUnsetHelp[1024];

//#if defined(FE_IME)
//TCHAR szEnableIMEFormat[SMALL_STRING + 1];
//TCHAR szEnableIMEHelp[255];
//TCHAR szDisableIMEFormat[SMALL_STRING + 1];
//TCHAR szDisableIMEHelp[255];
//#endif /* FE_IME */

/* Error messages */
TCHAR szConnectionLost[255];
UCHAR szNoHostName[SMALL_STRING + 1];
TCHAR szTooMuchText[255];
TCHAR szConnectFailed[255];
TCHAR szConnectFailedMsg[255];
TCHAR szOnPort[SMALL_STRING + 1];

TCHAR szCantInitSockets[SMALL_STRING + 1];
#ifdef DBCS
UCHAR szInproperFont[255];
#endif

//TCHAR szEscapeCharacter[2];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\client\zone.cpp ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
#include <windows.h>      
#include "zone.h"
#include <urlmon.h>

int __cdecl IsTrustedServer( LPWSTR szServer, LPWSTR szZoneName,  DWORD dwZoneNameLen, DWORD *pdwZonePolicy )
{
    int iRetVal = FALSE;

    if( !szServer || !szZoneName || !pdwZonePolicy )
    {
        goto IsTargetServerAbort0;
    }

    if( IsTargetServerSafeOnProtocol( szServer, szZoneName, dwZoneNameLen, pdwZonePolicy, PROTOCOL_PREFIX_TELNET ) )
    {
        //Should we be getting the name if given ip( and viceversa) to check for zones as well? What happens in the presence of DHCP?
        //Do we need to check for http://machine as well?
        iRetVal = TRUE;
    }

IsTargetServerAbort0:
    return iRetVal;
}


int __cdecl IsTargetServerSafeOnProtocol( LPWSTR szServer, LPWSTR szZoneName,  DWORD dwZoneNameLen, DWORD *pdwZonePolicy, LPWSTR szProtocol )
{
    MULTI_QI qiSecurityMgr[] = {{ &IID_IInternetSecurityManager, NULL, S_OK }}; 
    MULTI_QI qiZoneMgr[]    = {{ &IID_IInternetZoneManager,    NULL, S_OK }};
    IInternetSecurityManager *pSecurityMgr = NULL;    
    IInternetZoneManager    *pZoneMgr = NULL;
    ZONEATTRIBUTES        zaAttribs;
    DWORD                dwTargetServerZone = 0;
    HRESULT               hr = S_FALSE;
    int                     iRetVal = FALSE;
    LPWSTR                lpszTargetServer = NULL;
    DWORD               dwSize = 0;
    bool                bCoInit = false;

    if( !szServer || !szZoneName || !szProtocol || !pdwZonePolicy )
    {
        goto IsTargetServerSafeOnProtocol0;
    }
    
    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if( !SUCCEEDED( hr ) )
    {
        goto IsTargetServerSafeOnProtocol0;
    }
    bCoInit = true;
    hr = CoCreateInstanceEx(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER, NULL, 
                sizeof(qiSecurityMgr) / sizeof(MULTI_QI), qiSecurityMgr );
    if( !SUCCEEDED( hr ) || !SUCCEEDED(qiSecurityMgr[INDEX_SEC_MGR].hr) || 
       !(pSecurityMgr=(IInternetSecurityManager*)qiSecurityMgr[INDEX_SEC_MGR].pItf))
    {
        goto IsTargetServerSafeOnProtocol0;
    }

    dwSize = ( wcslen( szServer ) + wcslen( szProtocol ) + 1 ) ;
    lpszTargetServer = (WCHAR * )malloc( dwSize * sizeof( WCHAR ));
    if( !lpszTargetServer )
    {
        goto IsTargetServerSafeOnProtocol1;        
    }

    wcsncpy( lpszTargetServer, szProtocol, dwSize - 1 );
    lpszTargetServer[dwSize - 1] = L'\0';
    wcsncat( lpszTargetServer, szServer, (dwSize - wcslen(lpszTargetServer) -1));
    
    hr = pSecurityMgr->MapUrlToZone(lpszTargetServer, &dwTargetServerZone, 0);
    if( !SUCCEEDED(hr) )
    {
        goto IsTargetServerSafeOnProtocol2;
    }

    hr = CoCreateInstanceEx(CLSID_InternetZoneManager, NULL, CLSCTX_INPROC_SERVER, NULL, 
                sizeof(qiZoneMgr) / sizeof(MULTI_QI), qiZoneMgr );
    if( !SUCCEEDED( hr ) || !SUCCEEDED(qiZoneMgr[INDEX_ZONE_MGR].hr) || 
       !(pZoneMgr=(IInternetZoneManager*)qiZoneMgr[INDEX_ZONE_MGR].pItf) )  
    {
        goto IsTargetServerSafeOnProtocol2;
    }   

    hr = pZoneMgr->GetZoneAttributes( dwTargetServerZone, &zaAttribs );
    if( SUCCEEDED( hr ) )
    {
        wcsncpy( szZoneName, zaAttribs.szDisplayName, MIN( ( wcslen( zaAttribs.szDisplayName ) + 1 ), dwZoneNameLen ) );
    }
        
        
    hr = pZoneMgr->GetZoneActionPolicy( dwTargetServerZone, URLACTION_CREDENTIALS_USE,  
                                 (BYTE*)pdwZonePolicy, sizeof( *pdwZonePolicy), URLZONEREG_DEFAULT );
    if( !SUCCEEDED( hr ) )
    {
        goto IsTargetServerSafeOnProtocol3;    
    }        

    if((URLPOLICY_CREDENTIALS_SILENT_LOGON_OK == *pdwZonePolicy ) || 
     (URLPOLICY_CREDENTIALS_CONDITIONAL_PROMPT == *pdwZonePolicy && URLZONE_INTRANET == dwTargetServerZone ) )
    {
        iRetVal = TRUE;
    }    

IsTargetServerSafeOnProtocol3:    
    pZoneMgr->Release();
IsTargetServerSafeOnProtocol2:
    free( lpszTargetServer );
IsTargetServerSafeOnProtocol1:
    pSecurityMgr->Release();
IsTargetServerSafeOnProtocol0:    
    if(bCoInit)
    {
        CoUninitialize();
    }
    return iRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\common\activex\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\client\zone.h ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
#ifndef __ZONE_H
#define __ZONE_H

#define INDEX_SEC_MGR   0
#define INDEX_ZONE_MGR   0
#define PROTOCOL_PREFIX_TELNET  L"telnet://" 
//changing this from telnet://. It is observer on IE5.0 that unless telnet://server name is given the mapping from url to zone is not succeeding.


#define MIN(x, y) ((x)<(y)?(x):(y))

#ifdef __cplusplus
extern "C" {
#endif

extern int __cdecl IsTargetServerSafeOnProtocol( LPWSTR szServer, LPWSTR szZoneName, DWORD dwZoneNameLen, DWORD *pdwZonePolicy, LPWSTR szProtocol );
extern int __cdecl IsTrustedServer( LPWSTR szServer, LPWSTR szZoneName, DWORD dwZoneNameLen, DWORD *pdwZonePolicy );

#ifdef __cplusplus
}
#endif


#endif // __ZONE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\common\activex\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dummycom.rc
//
#define IDS_PROJNAME                    100
#define IDR_SFUCOMMON                   101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\common\activex\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__42D1E606_346E_4A95_9EB8_B40ACAD2A8F6__INCLUDED_)
#define AFX_STDAFX_H__42D1E606_346E_4A95_9EB8_B40ACAD2A8F6__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__42D1E606_346E_4A95_9EB8_B40ACAD2A8F6__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\common\inc\locresman.h ===
#ifndef _LOCRESMAN_H_INCLUDED_
#define _LOCRESMAN_H_INCLUDED_

#include <windows.h>

#ifdef __cplusplus
extern "C" 
	{
#endif // __cplusplus
// ************************************************************

HRESULT WINAPI HrLoadLocalizedLibrarySFU  (const HINSTANCE hInstExe,  const WCHAR *pwchDllName, HINSTANCE *phInstLocDll, WCHAR *pwchLoadedDllName);
HRESULT WINAPI HrLoadLocalizedLibrarySFU_A(const HINSTANCE hInstExe,  const char  *pchDllName,  HINSTANCE *phInstLocDll, char  *pchLoadedDllName);
int WINAPI LoadStringCodepage_A(HINSTANCE hInstance,  // handle to module containing string resource
                                UINT uID,             // resource identifier
                                char *lpBuffer,      // pointer to buffer for resource
                                int nBufferMax,        // size of buffer
                                UINT uCodepage       // desired codepage
                               );
HRESULT WINAPI HrConvertStringCodepage(UINT uCodepageSrc, char *pchSrc, int cchSrc, 
                                       UINT uUcodepageTgt, char *pchTgt, int cchTgtMax, int *pcchTgt,
                                       void *pbScratchBuffer, int iSizeScratchBuffer);
                                       
HRESULT WINAPI HrConvertStringCodepageEx(UINT uCodepageSrc, char *pchSrc, int cchSrc, 
                                       UINT uUcodepageTgt, char *pchTgt, int cchTgtMax, int *pcchTgt,
                                       void *pbScratchBuffer, int iSizeScratchBuffer,
                                       char *pchDefaultChar, BOOL *pfUsedDefaultChar);

// ************************************************************
#ifdef __cplusplus
	}
#endif // __cplusplus

#endif // _LOCRESMAN_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\common\activex\sfucommon.cpp ===
// SFUCommon.cpp : Implementation of CSFUCommon
#include "stdafx.h"
#include "sfucom.h"
#include "SFUCommon.h"
#include <winsock.h>
#include <lm.h>
#include <shlwapi.h>
#include <commctrl.h>
#include <OleAuto.h >
#include <windns.h> //For DNS_MAX_NAME_BUFFER_LENGTH definition

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#define WINLOGONNT_KEY  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define NETLOGONPARAMETERS_KEY  TEXT("System\\CurrentControlSet\\Services\\Netlogon\\Parameters")
#define TRUSTEDDOMAINLIST_VALUE TEXT("TrustedDomainList")
#define CACHEPRIMARYDOMAIN_VALUE    TEXT("CachePrimaryDomain")
#define CACHETRUSTEDDOMAINS_VALUE   TEXT("CacheTrustedDomains")
#define DOMAINCACHE_KEY TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\DomainCache")
#define DCACHE_VALUE    TEXT("DCache")
#define WINLOGONNT_DCACHE_KEY    TEXT("DCache")


/////////////////////////////////////////////////////////////////////////////
// CSFUCommon

BOOL Get_Inet_Address(struct sockaddr_in *addr, char *host)
{
    register struct hostent *hp;
    WORD wVersionRequested; //INGR
    WSADATA wsaData; //INGR

    // Start up winsock
    wVersionRequested = MAKEWORD( 1, 1 ); //INGR
    if (WSAStartup(wVersionRequested, &wsaData) != 0) { //INGR
	return (FALSE);
    }

    // Get the address
    memset(addr, 0, sizeof(addr)); 
    //bzero((TCHAR *)addr, sizeof *addr);
    addr->sin_addr.s_addr = (u_long) inet_addr(host);
    if (addr->sin_addr.s_addr == -1 || addr->sin_addr.s_addr == 0) {
      if ((hp = gethostbyname(host)) == NULL) {
        return (FALSE);
      }
      memcpy(&addr->sin_addr,hp->h_addr,  hp->h_length );
      //bcopy(hp->h_addr, (TCHAR *)&addr->sin_addr, hp->h_length);
    }
    addr->sin_family = AF_INET;

    WSACleanup(); //INGR
    return (TRUE);
}

STDMETHODIMP CSFUCommon::IsValidMachine(BSTR bstrMachine,BOOL *fValid)
{
	// TODO: Add your implementation code here
	struct sockaddr_in addr;
	*fValid = false;
	char * nodeName = (char *) malloc(wcslen(bstrMachine)+1);
	if(!nodeName)
		return(E_OUTOFMEMORY);

	int cbMultiByte = WideCharToMultiByte( GetACP(),NULL,bstrMachine,-1,nodeName,
						0,NULL,NULL);

	WideCharToMultiByte( GetACP(),NULL,bstrMachine,-1,nodeName,
						cbMultiByte,NULL,NULL);
			
	if (Get_Inet_Address (&addr, nodeName)) 
		*fValid = TRUE;
	if(nodeName)
		free(nodeName);
	return S_OK;

}

STDMETHODIMP CSFUCommon::IsTrustedDomain(BSTR bstrDomain, BOOL * fValid)
{
	// TODO: Add your implementation code here

	return S_OK;
}


STDMETHODIMP CSFUCommon::ConvertUTCtoLocal(BSTR bUTCYear, BSTR bUTCMonth, BSTR bUTCDayOfWeek, BSTR bUTCDay, BSTR bUTCHour, BSTR bUTCMinute, BSTR bUTCSecond, BSTR * bLocalDate)
{
	// TODO: Add your implementation code here

	SYSTEMTIME UniversalTime, LocalTime;
    DATE  dtCurrent;
    DWORD dwFlags = VAR_VALIDDATE;
	UDATE uSysDate; //local time 
	*bLocalDate = NULL;

    // The values can't be > MAXWORD, so cast away -- BaskarK
      
	UniversalTime.wYear 	    = (WORD) _wtoi(bUTCYear);

    UniversalTime.wMonth 	    = (WORD) _wtoi(bUTCMonth);
	UniversalTime.wDayOfWeek 	= (WORD) _wtoi(bUTCDayOfWeek);
	UniversalTime.wDay 	        = (WORD) _wtoi(bUTCDay);
	UniversalTime.wDay 	        = (WORD) _wtoi(bUTCDay);
	UniversalTime.wMinute       = (WORD) _wtoi(bUTCMinute);
	UniversalTime.wHour 	    = (WORD) _wtoi(bUTCHour);
	UniversalTime.wSecond       = (WORD) _wtoi(bUTCSecond);
	UniversalTime.wMilliseconds	= (WORD) 0;

	SystemTimeToTzSpecificLocalTime(NULL,&UniversalTime,&LocalTime);
	memcpy(&uSysDate.st,&LocalTime,sizeof(SYSTEMTIME));
	if( VarDateFromUdate( &uSysDate, dwFlags, &dtCurrent ) != S_OK )
		goto Error;
    VarBstrFromDate( dtCurrent, 
            MAKELCID( MAKELANGID( LANG_NEUTRAL, SUBLANG_SYS_DEFAULT ), SORT_DEFAULT ), 
            LOCALE_NOUSEROVERRIDE, bLocalDate);
	    	
Error:
	return S_OK;
}

STDMETHODIMP CSFUCommon::get_mode(short * pVal)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CSFUCommon::put_mode(short newVal)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CSFUCommon::LoadNTDomainList()
{
	// TODO: Add your implementation code here
	int dwSize=0, dwType=0;
    DWORD nIndex = 0;
    LPTSTR lpComputer = NULL, lpDomains = NULL, lpPrimary = NULL;
    LPBYTE lpBuffer = NULL;        

    //MessageBoxW(NULL, (LPWSTR)L"LoadNTDomainList", L"LoadNTDomainList1", MB_OK);
    //
    // Add all trusted domains to the list
    //
    dwSize = GetTrustedDomainList(&lpDomains, &lpPrimary);

    //
    // free previous values
    //
    FreeStringList(&m_slNTDomains);
    //
    // initialize list again
    //
    m_slNTDomains.count = 0;
    //
    // two for primary domain
    // and this computer
    // one more in case dwSize is -1
    // hence total is 3
    //
    m_slNTDomains.strings = new LPTSTR[dwSize + 3];
    ATLASSERT(m_slNTDomains.strings != NULL);
    
    ZeroMemory(m_slNTDomains.strings, (dwSize + 3)*sizeof(LPTSTR));

    if((dwSize > 0) && lpDomains)
    {
        LPTSTR ptr = lpDomains;
        //
        // add domains to our list
        //
        while(*ptr)
        {
            ptr = _tcsupr(ptr);
        	m_slNTDomains.strings[m_slNTDomains.count] = new TCHAR[_tcslen(ptr) + 1];
            ATLASSERT(m_slNTDomains.strings[m_slNTDomains.count] != NULL);
            ZeroMemory(m_slNTDomains.strings[m_slNTDomains.count], (_tcslen(ptr) + 1)*sizeof(TCHAR));
            _tcscpy(m_slNTDomains.strings[m_slNTDomains.count], ptr);
            ptr += _tcslen(ptr) + 1;
            m_slNTDomains.count++;
        }
        delete [] lpDomains;
        lpDomains = NULL;
    }

    
    if(lpPrimary && *lpPrimary)
    {
        lpPrimary = _tcsupr(lpPrimary);

        for(nIndex=0;nIndex<m_slNTDomains.count;nIndex++)
        {
            if(!_tcsicmp(lpPrimary, m_slNTDomains.strings[nIndex]))
                break;
        }

        if(nIndex == m_slNTDomains.count)
        {
            // 
            // lpPrimary was not in the list of domains that we
            // got. add it.
            //
        	m_slNTDomains.strings[m_slNTDomains.count] = new TCHAR[_tcslen(lpPrimary) + 1];
            ATLASSERT(m_slNTDomains.strings[m_slNTDomains.count] != NULL);
            ZeroMemory(m_slNTDomains.strings[m_slNTDomains.count], (_tcslen(lpPrimary) + 1)*sizeof(TCHAR));
            _tcscpy(m_slNTDomains.strings[m_slNTDomains.count], lpPrimary);
            m_slNTDomains.count++;
        }
    }

    //
    // Add our computer to be selected if this machine is not the
    // domain controler (which should already be in the list)
    //
    NetServerGetInfo(NULL, 101, &lpBuffer);
    
    if(((LPSERVER_INFO_101)lpBuffer)->sv101_type &
          ((DWORD)SV_TYPE_DOMAIN_CTRL | (DWORD)SV_TYPE_DOMAIN_BAKCTRL))
    {        
        /*
        we got this computer as one of the domains. no need to add it to the 
        list again. just do nothing.
        */
		;
    }
    else
    {
        TCHAR szName[MAX_PATH + 2];
        ZeroMemory(szName, sizeof(szName));
        DWORD dwLen = sizeof(szName);

        if(GetComputerName(szName + 2, &dwLen))
        {
            szName[0] = TEXT('\\');
            szName[1] = TEXT('\\');
            //
            // add this also to our list of domains
            //
        	m_slNTDomains.strings[m_slNTDomains.count] = new TCHAR[_tcslen(szName) + 1];
            ATLASSERT(m_slNTDomains.strings[m_slNTDomains.count] != NULL);
            ZeroMemory(m_slNTDomains.strings[m_slNTDomains.count], (_tcslen(szName) + 1)*sizeof(TCHAR));
            _tcscpy(m_slNTDomains.strings[m_slNTDomains.count], szName);
            m_slNTDomains.count++;
        }
    }

    if(lpBuffer)
    {
        NetApiBufferFree(lpBuffer);
    }

    if(lpPrimary)
    {
        delete [] lpPrimary;
    }

 	return S_OK;
}

int CSFUCommon::GetTrustedDomainList(LPTSTR *list, LPTSTR *primary)
{
    BOOL stat = TRUE;
    DWORD ret=0, size=0, type=0;
    LPTSTR cache = NULL, dcache = NULL, string = NULL, trusted = NULL;
    HKEY hKey=NULL;
    CRegKey key;
	DWORD dwIndex = 0;
	LPTSTR lpValueName = NULL;
	DWORD cbValueName = 0;
	STRING_LIST slValues = {0, NULL};
    

    *list = NULL;

    if(key.Open(HKEY_LOCAL_MACHINE, WINLOGONNT_KEY) == ERROR_SUCCESS)
    {
        size = 0;
        
        if(key.QueryValue(*primary, CACHEPRIMARYDOMAIN_VALUE, &size) == ERROR_SUCCESS)
        {
            *primary = new TCHAR[size+1];           
            ATLASSERT(primary != NULL);

            if(*primary)
            {
                ZeroMemory(*primary, (size+1)*sizeof(TCHAR));

                if(key.QueryValue(*primary, CACHEPRIMARYDOMAIN_VALUE, &size) != ERROR_SUCCESS)
                {
                    delete [] *primary;
                    *primary = NULL;
                    return FALSE;
                }
                else
                {
                    key.Close();
                }
            }
        }
        else
        {
            key.Close();
            return -1;
        }
    }
    else
    {
        return -1;
    }

    //
    // Get trusted domains. In NT40 the CacheTrustedDomains 
    // under winlogon doesn't exist. I did find that Netlogon has a field 
    // called TrustedDomainList which seems to be there in both NT351 and NT40.
    // Winlogon has a field called DCache which seem to cache the trusted
    // domains. I'm going to check Netlogon:TrustedDomainList first. If it
    // fails: Check for Winlogon:CacheTrustedDomains then Winlogon:DCache.
    // Warning -- Winlogon:CacheTrustedDomains is a REG_SZ and
    // Netlogon:TrustedDomainList and Winlogon:DCache are REG_MULTI_SZ.
    // Note -- see 4.0 Resource Kit documentation regarding some of these
    // values
    //
    if(key.Open(HKEY_LOCAL_MACHINE, NETLOGONPARAMETERS_KEY) == ERROR_SUCCESS)
    {
        size = 0;

        if(key.QueryValue(trusted, TRUSTEDDOMAINLIST_VALUE, &size) == ERROR_SUCCESS)
        {
            trusted = new TCHAR[size + 1];
            ATLASSERT(trusted != NULL);

            if(trusted)
            {
                ZeroMemory(trusted, (size+1)*sizeof(TCHAR));
         
                if(key.QueryValue(trusted, TRUSTEDDOMAINLIST_VALUE, &size) != ERROR_SUCCESS)
                {
                    key.Close();
                    delete [] trusted;
                    //trusted = NULL;
                    *list = NULL;
                    //goto ABORT;
                }
                else
                {
                    *list = trusted;
                    key.Close();
                }
            }
            else
            {
                key.Close();
                goto ABORT;
            }
        }
        else
        {
            key.Close();
            *list = NULL;            
        }        
    }
    
    if(!(*list) && (key.Open(HKEY_LOCAL_MACHINE, WINLOGONNT_KEY) == ERROR_SUCCESS))
    {
        size = 0;

        if(key.QueryValue(cache, CACHETRUSTEDDOMAINS_VALUE, &size) == ERROR_SUCCESS)
        {
            cache = new TCHAR[size + 1];
            ATLASSERT(cache != NULL);

            if(cache)
            {
                ZeroMemory(cache, size);

                if(key.QueryValue(cache, CACHETRUSTEDDOMAINS_VALUE, &size) == ERROR_SUCCESS)
                {        
                    //
                    // comma separated list
                    //
                    LPTSTR lpComma = NULL;
                    LPTSTR lpDelim = TEXT(",");

                    lpComma = _tcstok(cache, lpDelim);

                    while(lpComma)
                    {
                        lpComma = _tcstok(NULL, lpDelim);
                    }
                    
                    *list = cache;
                }
                else
                {
                    key.Close();
                    delete [] cache;
                    *list = NULL;
                }
            }
            else
            {
                key.Close();
                goto ABORT;
            }               
        }
        else
        {
            *list = NULL;
            key.Close();
        }
    }
    
    if(!(*list) && (key.Open(HKEY_LOCAL_MACHINE, WINLOGONNT_KEY) == ERROR_SUCCESS))
    {        
        size = 0;

        if(key.QueryValue(trusted, DCACHE_VALUE, &size) == ERROR_SUCCESS)
        {
            trusted = new TCHAR[size + 1];
            ATLASSERT(trusted != NULL);

            if(trusted)
            {
                if(key.QueryValue(trusted, DCACHE_VALUE, &size) == ERROR_SUCCESS)
                {
                    *list = trusted;
                }
                else
                {
                    key.Close();
                    delete [] trusted;
                    *list = NULL;
                }
            }
            else
            {
                key.Close();
                goto ABORT;
            }
        }
        else
        {
           key.Close();
           *list = NULL;            
		    
        }
    }

	if(!(*list) && (key.Open(HKEY_LOCAL_MACHINE, DOMAINCACHE_KEY) == ERROR_SUCCESS))
    {        
        size = 0;
        TCHAR * pszTemp = NULL;
        TCHAR   szTemp[MAX_PATH];
        DWORD   dwNumberOfValues = 0;
        DWORD   dwIndex = 0;
        DWORD   dwCharCount = MAX_PATH;
        HRESULT hrResult = ERROR_SUCCESS;

        hKey = HKEY(key);
        //
        // first find out how many values are present
        //
        hrResult = RegQueryInfoKey(
            hKey, //handle of key to query 
            NULL, // address of buffer for class string 
            NULL, // address of size of class string buffer 
            NULL, // reserved 
            NULL, // address of buffer for number of subkeys 
            NULL, // address of buffer for longest subkey name length 
            NULL, // address of buffer for longest class string length 
            &dwNumberOfValues, // address of buffer for number of value entries 
            NULL, // address of buffer for longest value name length 
            NULL, // address of buffer for longest value data length 
            NULL, // address of buffer for security descriptor length 
            NULL  // address of buffer for last write time 
            ); 
 
        if(hrResult != ERROR_SUCCESS)
            goto ABORT;

        slValues.count = dwNumberOfValues;
        slValues.strings = new LPTSTR[slValues.count];
        ATLASSERT(slValues.strings != NULL);
        if(slValues.strings == NULL)
            goto ABORT;

        ZeroMemory(slValues.strings, slValues.count * sizeof(LPTSTR));

        for(dwIndex = 0;dwIndex<dwNumberOfValues;dwIndex++)
        {
            dwCharCount = MAX_PATH;

            if(RegEnumValue(hKey, dwIndex, szTemp, &dwCharCount, NULL, NULL, NULL, NULL) == ERROR_NO_MORE_ITEMS)
                break;
            
            slValues.strings[dwIndex] = new TCHAR[dwCharCount+1];
            ATLASSERT(slValues.strings[dwIndex] != NULL);
            if(slValues.strings[dwIndex] == NULL)
                goto ABORT;
            ZeroMemory(slValues.strings[dwIndex], (dwCharCount+1) * sizeof(TCHAR));
            _tcscpy(slValues.strings[dwIndex], szTemp);
            // add up the return buffer size
            size += dwCharCount+1;
        }

        if(dwNumberOfValues > 0)
        {
            trusted = new TCHAR[size + 1];
            ATLASSERT(trusted != NULL);

            if(trusted == NULL)
            {
                goto ABORT;
            }
            ZeroMemory(trusted, (size+1)*sizeof(TCHAR));
            pszTemp = trusted;
            for(dwIndex = 0;dwIndex<slValues.count;dwIndex++)
            {
                _tcscpy(pszTemp, slValues.strings[dwIndex]);
                pszTemp += _tcslen(slValues.strings[dwIndex]) + 1;
            }
        }
        *list = trusted;
        size = dwNumberOfValues;
    }

    goto Done;



ABORT:
    if(*primary != NULL)
    {
        delete [] *primary;
        *primary = NULL;
    }
    if(trusted != NULL)
    {
        delete [] trusted;
        trusted = NULL;
    }
    if(cache != NULL)
    {
        delete [] cache;
        cache = NULL;
    }

    return -1;

Done:
    if(hKey != NULL)
    {
        RegCloseKey(hKey);
        hKey = NULL;
        key.m_hKey = NULL;
    }

    FreeStringList(&slValues);

    return size;
}


void CSFUCommon::FreeStringList(PSTRING_LIST pList)
{
    if(pList && pList->count && pList->strings)
    {
        DWORD i;

        for(i=0; i < pList->count; ++i)
        {
            if(pList->strings[i])
                delete [] pList->strings[i];
        }

        delete pList->strings;

        pList->count = 0;
        pList->strings = NULL;
    }
}


STDMETHODIMP CSFUCommon::get_NTDomain(BSTR * pVal)
{
	// TODO: Add your implementation code here
	*pVal = SysAllocString(m_slNTDomains.strings[m_dwEnumNTDomainIndex]);
	return S_OK;
}

STDMETHODIMP CSFUCommon::get_NTDomainCount(DWORD * pVal)
{
	// TODO: Add your implementation code here
	*pVal = m_slNTDomains.count;
	return S_OK;
}

STDMETHODIMP CSFUCommon::moveFirst()
{
	// TODO: Add your implementation code here
	switch(mode)
	{
		case NTDOMAIN :
		{
			m_dwEnumNTDomainIndex = 0;
			m_bstrNTDomain = m_slNTDomains.strings[0];
			break;
		}
	}
	return S_OK;

}

STDMETHODIMP CSFUCommon::moveNext()
{
	// TODO: Add your implementation code here
	switch(mode)
	{
		case NTDOMAIN :
		{
			m_dwEnumNTDomainIndex++;
			break;
		}
	}
	return S_OK;
}

STDMETHODIMP CSFUCommon::get_machine(BSTR *pVal)
{
	*pVal = SysAllocString(m_szMachine);
	
	return S_OK;
}

STDMETHODIMP CSFUCommon::put_machine(BSTR newVal)
{
	m_szMachine = (LPWSTR)malloc (sizeof(WCHAR) * wcslen(newVal) );
	wcscpy(m_szMachine,newVal);
	return S_OK;
}
/*----------------------------------------------------------------
[Comments]: This Function returns the hostname.

Added By: [shyamah]
----------------------------------------------------------------*/
STDMETHODIMP CSFUCommon::get_hostName(BSTR *pbstrhostName)
{
        WORD wVersionRequested; 
	    WSADATA wsaData; 
	    CHAR szHostName[DNS_MAX_NAME_BUFFER_LENGTH];
	    WCHAR *wzStr=NULL;
	    DWORD nLen=0;

    	// Start up winsock
    	wVersionRequested = MAKEWORD( 1, 1 ); 
    	if (0==WSAStartup(wVersionRequested, &wsaData)) 
        { 
    		
   			if(SOCKET_ERROR!=(gethostname(szHostName,DNS_MAX_NAME_BUFFER_LENGTH)))
   			{
   			    nLen=MultiByteToWideChar(GetConsoleCP(),0,szHostName,-1,NULL,NULL);
                wzStr=(wchar_t *) malloc(nLen*sizeof(wchar_t));
                if(wzStr==NULL)
                   return E_OUTOFMEMORY;
                MultiByteToWideChar(GetConsoleCP(), 0, szHostName, -1, wzStr, nLen );
   			    if(NULL==(*pbstrhostName=SysAllocString(wzStr)))
   			    {
   			        free(wzStr);
   			        return E_OUTOFMEMORY;
   			    }
   			    free(wzStr);
   			}
            WSACleanup(); 
    	}
	return S_OK;
}

/*-------------------------------------------------------------------
[Comments]: This finction returns true if a service is installed and a false if a service 
is not installed.

Added By: [Shyamah]
------------------------------------------------------------------*/
STDMETHODIMP CSFUCommon::IsServiceInstalled(BSTR bMachine,BSTR bServiceName,BOOL *fValid)
{
	*fValid = false;
	HRESULT error=S_OK;
	SC_HANDLE scManager=NULL;
	SC_HANDLE serviceHandle= NULL;

	if ((scManager	= OpenSCManager(bMachine,SERVICES_ACTIVE_DATABASE,SC_MANAGER_ENUMERATE_SERVICE))==NULL)
	{
		error = GetLastError();
		goto Error;
	}
	if ((serviceHandle = OpenService(scManager,bServiceName,SERVICE_USER_DEFINED_CONTROL))==NULL)
	{
		error = GetLastError();
		goto Error;
	}
	*fValid = TRUE;
Error :
	if(scManager)
		CloseServiceHandle(scManager);
	if(serviceHandle)
		CloseServiceHandle(serviceHandle);
	return(error);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\common\activex\sfucommon.h ===
// SFUCommon.h : Declaration of the CSFUCommon

#ifndef __SFUCOMMON_H_
#define __SFUCOMMON_H_

#include "resource.h"       // main symbols
#define GROUP 1
#define MEMBER 2
#define NTDOMAIN 3
#define MACHINE 4

typedef struct _STRING_LIST
{
    DWORD count;
    LPTSTR *strings;
} STRING_LIST, *PSTRING_LIST;


/////////////////////////////////////////////////////////////////////////////
// CSFUCommon
class ATL_NO_VTABLE CSFUCommon : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSFUCommon, &CLSID_SFUCommon>,
	public IObjectWithSiteImpl<CSFUCommon>,
	public IDispatchImpl<ISFUCommon, &IID_ISFUCommon, &LIBID_DUMMYCOMLib>
{
public:
	CSFUCommon()
	{
		m_slNTDomains.count = 0;
        m_slNTDomains.strings = NULL;
	    LoadNTDomainList();
		mode = NTDOMAIN;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SFUCOMMON)

BEGIN_COM_MAP(CSFUCommon)
	COM_INTERFACE_ENTRY(ISFUCommon)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY_IMPL(IObjectWithSite)
END_COM_MAP()

// ISFUCommon
private : 
	CComBSTR    m_bstrNTDomain;
	DWORD mode;
	
public:
	STDMETHOD(get_hostName)(BSTR *pszHostNme);
	STDMETHOD(IsServiceInstalled)(BSTR bMachine,BSTR bServiceName,BOOL *fValid);
	STDMETHOD(moveNext)();
	STDMETHOD(moveFirst)();
	STDMETHOD(get_NTDomainCount)(/*[out, retval]*/ DWORD *pVal);
	STDMETHOD(get_NTDomain)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(LoadNTDomainList)();
	STDMETHOD(get_mode)(/*[out, retval]*/ short *pVal);
	STDMETHOD(put_mode)(/*[in]*/ short newVal);
	STDMETHOD(ConvertUTCtoLocal)(BSTR bUTCYear, BSTR bUTCMonth,BSTR bUTCDayOfWeek, BSTR bUTCDay,BSTR bUTCHour,BSTR bUTCMinute, BSTR bUTCSecond,BSTR *bLocalDate);
	STDMETHOD(IsTrustedDomain)(BSTR bstrDomain, BOOL *fValid);
	STDMETHOD(IsValidMachine)(BSTR bstrMachine, BOOL *fValid);
	int GetTrustedDomainList(LPTSTR * list, LPTSTR * primary);
	void FreeStringList(PSTRING_LIST pList);
	DWORD m_dwEnumNTDomainIndex;
	STRING_LIST m_slNTDomains;
    STDMETHOD(get_machine)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_machine)(/*[in]*/ BSTR newVal);
	LPWSTR m_szMachine;
		
};

#endif //__SFUCOMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\common\activex\sfucom.cpp ===
// dummycom.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f dummycomps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "sfucom.h"

#include "sfucom_i.c"

#include "SFUCommon.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_SFUCommon, CSFUCommon)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{

	UnRegisterTypeLib(LIBID_DUMMYCOMLib, 1, 0, LOCALE_NEUTRAL, SYS_WIN32);
    _Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\common\inc\w4warn.h ===
/*----------------------------------------------------------------------------
*  Note that we don't want to use a single line comment before the warning is
*   disabled.
*
*   Microsoft Windows
*   Copyright (C) Microsoft Corporation, 1992 - 1994.
*
*   File:       w4warn.h
*
*   Contents:   #pragmas to adjust warning levels.
*
*---------------------------------------------------------------------------*/

/*
 *   Level 4 warnings to suppress.
 */

#pragma warning(disable:4001) /* nonstandard extension 'extension' was used                            */
#pragma warning(disable:4097) /* typedef name 'type' used as synonym for class 'class'                 */
#pragma warning(disable:4100) /* unreferenced formal parameter                                         */
#pragma warning(disable:4115) /* named type definition in parentheses                                  */
#pragma warning(disable:4134) /* conversion between pointers to members of same class                  */
#pragma warning(disable:4152) /* nonstandard extension, function/data pointer conversion in expression */
#pragma warning(disable:4200) /* nonstandard extension used : zero-sized array in struct/union         */
#pragma warning(disable:4201) /* nonstandard extension used : nameless struct/union                    */
#pragma warning(disable:4204) /* nonstandard extension used : non-constant aggregate initializer       */
#pragma warning(disable:4209) /* nonstandard extension used : benign typedef redefinition              */
#pragma warning(disable:4214) /* nonstandard extension used : bit field types other than int           */
#pragma warning(disable:4505) /* unreferenced local function has been removed                          */
#pragma warning(disable:4511) /* 'class' : copy constructor could not be generated                     */
#pragma warning(disable:4512) /* 'class': assignment operator could not be generated                   */
#pragma warning(disable:4514) /* 'function' : unreferenced inline function has been removed            */
#pragma warning(disable:4705) /* statement has no effect                                               */
#pragma warning(disable:4710) /* function call not expanded                                            */
#pragma warning(disable:4057) /*'const unsigned short *' differs in indirection to slightly different 
                                 base types from 'unsigned shourt []'                                  */
#pragma warning(disable:4211) /* nonstandard extension used : redefined extern to static               */
#pragma warning(disable:4232) /* nonstandard extension used : 'x' :address of dllimport 'y' is not     
                                 static, identity not guaranteed                                       */

/*
 * Warning 4244 is benign more often than not, so if you don't want it then
 * uncomment this to filter out those errors.
 *
 */
#pragma warning(disable:4244) /* conversion from 'type' to 'type', possible loss of data               */

/*
 * This helps to track down "Illegal attempt to instantiate abstract class" messages
 */

#pragma warning(error:4259) /* pure virtual function not defined                                       */

/*
 *   Level 4 warnings that we want treated as level 3 warnings.
 */

#pragma warning(3:4127) /* conditional expression is constant                                          */
#pragma warning(3:4702) /* unreachable code                                                            */
#pragma warning(3:4706) /* assignment within conditional expression                                    */

#pragma warning(disable:4041) /* compiler limit reached: terminating browser output                    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\common\locresman\strman.c ===
/*--------------------------------------------------------------------
Copyright (c) Microsoft Corporation.  All rights reserved.
--------------------------------------------------------------------*/

#include "windows.h"
#include "locresman.h"

#define SIZE_OF_TEMP_BUFFER 2048 // something reasonable.

int WINAPI LoadStringCodepage_A(HINSTANCE hInstance,  // handle to module containing string resource
                                UINT uID,             // resource identifier
                                char *lpBuffer,      // pointer to buffer for resource
                                int nBufferMax,        // size of buffer
                                UINT uCodepage       // desired codepage
                               )
{
int iRetVal = 0;

WCHAR wzBuffer[SIZE_OF_TEMP_BUFFER];
WCHAR *pwchBuffer;
// use the buffer-on-stack if possible
if (nBufferMax > SIZE_OF_TEMP_BUFFER)
	{
	pwchBuffer = (WCHAR *) GlobalAlloc(GPTR, nBufferMax * sizeof(WCHAR));
	if (NULL == pwchBuffer)
		goto L_Return;
	}
else
	pwchBuffer = wzBuffer;

iRetVal = LoadStringW(hInstance, uID, pwchBuffer, nBufferMax);

if (0 == iRetVal)
	goto L_Return;
	
iRetVal = WideCharToMultiByte(uCodepage, 0, pwchBuffer, iRetVal, lpBuffer, nBufferMax, NULL, NULL);
lpBuffer[iRetVal] = 0;
L_Return :;
if ((NULL != pwchBuffer) && (pwchBuffer != wzBuffer))
		GlobalFree(pwchBuffer);
return (iRetVal);
}


HRESULT WINAPI HrConvertStringCodepageEx(UINT uCodepageSrc, char *pchSrc, int cchSrc, 
                                       UINT uUcodepageTgt, char *pchTgt, int cchTgtMax, int *pcchTgt,
                                       void *pbScratchBuffer, int iSizeScratchBuffer,
                                       char *pchDefaultChar, BOOL *pfUsedDefaultChar)
{
HRESULT hr = S_OK;
WCHAR *pbBuffer;
int cch;
pbBuffer = (WCHAR *) pbScratchBuffer;
if ((NULL == pbBuffer) || (iSizeScratchBuffer < (int) (cchSrc * sizeof(WCHAR))))
	{
	pbBuffer = GlobalAlloc(GPTR, (cchSrc + 1)* sizeof(WCHAR));
	if (NULL == pbBuffer)
		{
		hr = E_OUTOFMEMORY;
		goto L_Return;
		}
                ZeroMemory((PVOID)pbBuffer,(cchSrc + 1)* sizeof(WCHAR));
	}
// convert to unicode using the source codepage	
cch = MultiByteToWideChar(uCodepageSrc, 0, pchSrc, cchSrc, (WCHAR *)pbBuffer, cchSrc);
if (cch <= 0)
	{
	hr = E_FAIL;
	goto L_Return;
	}

*pcchTgt = cch = WideCharToMultiByte(uUcodepageTgt, 0, (WCHAR *) pbBuffer, cch, pchTgt, cchTgtMax, pchDefaultChar, pfUsedDefaultChar);

if (cch <= 0)
	hr = E_FAIL;
	
L_Return :;
if ((NULL != pbBuffer) && (pbBuffer != pbScratchBuffer))
	GlobalFree(pbBuffer);
return (hr);
}

HRESULT WINAPI HrConvertStringCodepage(UINT uCodepageSrc, char *pchSrc, int cchSrc, 
                                       UINT uUcodepageTgt, char *pchTgt, int cchTgtMax, int *pcchTgt,
                                       void *pbScratchBuffer, int iSizeScratchBuffer)
{
return HrConvertStringCodepageEx(uCodepageSrc, pchSrc, cchSrc, uUcodepageTgt, 
									pchTgt, cchTgtMax, pcchTgt, 
									pbScratchBuffer, iSizeScratchBuffer,
									NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\common\locresman\ldresdll.c ===
/*--------------------------------------------------------------------
Copyright (c) Microsoft Corporation.  All rights reserved.
--------------------------------------------------------------------*/

#include "windows.h"
#include "locresman.h"

HRESULT WINAPI HrLoadLocalizedLibrarySFU(const HINSTANCE hInstExe,  const WCHAR *pwchDllName, HINSTANCE *phInstLocDll, WCHAR *pwchLoadedDllName)
{
HINSTANCE hInst;
WCHAR wzDllFullPath[MAX_PATH];
WCHAR wzInstallPath[MAX_PATH];
WCHAR wzUILanguage[MAX_PATH];
WCHAR *pwchKey = (WCHAR *)L"SOFTWARE\\Microsoft\\Services For Unix\0";
WCHAR *pwchInstallPath = (WCHAR *)L"InstallPath\0";
WCHAR *pwchUILanguage = (WCHAR *)L"UILanguage\0";
HKEY hKey = NULL;
DWORD dwSizeI, dwSizeU;
DWORD dwType;
HRESULT hr = S_OK;
LANGID lidUI = 0;
int i;
*phInstLocDll = hInstExe;
if(NULL == pwchDllName)
	{
	hr = E_UNEXPECTED;
	goto L_Return;
	}

if(RegOpenKeyExW(HKEY_LOCAL_MACHINE, pwchKey, 0, KEY_QUERY_VALUE, &hKey) != ERROR_SUCCESS)
	{
	hr = E_UNEXPECTED;
	goto L_Return;
	}
dwSizeI = sizeof(wzInstallPath);
if (RegQueryValueExW(hKey, pwchInstallPath, NULL, &dwType, (LPBYTE) wzInstallPath, &dwSizeI) != ERROR_SUCCESS)
	{
	hr = E_UNEXPECTED;
	goto L_Return;
	}
if(dwType != REG_SZ)
	{
	hr = E_UNEXPECTED;
	goto L_Return;
	}
dwSizeU = sizeof(wzUILanguage);
if (RegQueryValueExW(hKey, pwchUILanguage, NULL, &dwType, (LPBYTE) wzUILanguage, &dwSizeU) != ERROR_SUCCESS)
	{
	hr = E_UNEXPECTED;
	goto L_Return;
	}
if(dwType != REG_SZ)
	{
	hr = E_UNEXPECTED;
	goto L_Return;
	}
if ((wcslen(pwchDllName) + dwSizeU + dwSizeI + 2 /* for the backslash and null*/) >= MAX_PATH)
	{
	hr = E_OUTOFMEMORY;
	goto L_Return;
	}
// At this point we assume that the string wzUILanguage will be a lid
// expressed in decimal, i.e. for lid 0x409, we would have a string "1033"
for (i = 0; 0 != wzUILanguage[i]; i++)
	{
	lidUI = (unsigned short) (lidUI * 10 + (wzUILanguage[i] - '0'));
	}
// If we are 0x409, there is nothing to do!	
if (MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT) == lidUI)
	{
	goto L_Return;
	}

wsprintfW(wzDllFullPath, (const WCHAR *)L"%s\\common\\%s", wzInstallPath, pwchDllName);
if (NULL == (hInst = LoadLibraryExW(wzDllFullPath, 0, DONT_RESOLVE_DLL_REFERENCES)))
	{
	hr = E_HANDLE;
	goto L_Return;
	}
*phInstLocDll = hInst;
if (pwchLoadedDllName)
	wcscpy(pwchLoadedDllName, wzDllFullPath);

L_Return:;
if (hKey)
	{
	RegCloseKey(hKey);
	}
return (hr);
}

// 8bit chars. wrapper for the unicode API.
HRESULT WINAPI HrLoadLocalizedLibrarySFU_A(const HINSTANCE hInstExe,  const char *pchDllName, HINSTANCE *phInstLocDll, char *pchLoadedDllName)
{
WCHAR wzDllName[MAX_PATH];
WCHAR *pwchDllName;
WCHAR wzLoadedDllName[MAX_PATH];
int cch;
HRESULT hr = E_FAIL;

if (NULL != pchDllName)
	{
	wzDllName[0] = 0;
	cch = MultiByteToWideChar(CP_ACP, 0, pchDllName, -1, wzDllName, sizeof(wzDllName)/sizeof(WCHAR)-1);
	wzDllName[(sizeof(wzDllName)/sizeof(WCHAR))-1] = 0;
	pwchDllName = wzDllName;
	}
else
	{
    goto end;
	}
	

	
hr = HrLoadLocalizedLibrarySFU(hInstExe,  pwchDllName, phInstLocDll, wzLoadedDllName);

if (SUCCEEDED(hr))
	{
	if (NULL != pchLoadedDllName)
		{
		pchLoadedDllName[0] = 0;
		cch = WideCharToMultiByte(CP_ACP, 0, wzLoadedDllName, -1, pchLoadedDllName, MAX_PATH, NULL, NULL);
		pchLoadedDllName[cch] = 0;
		}
	}
end : 
return (hr);	
}


#ifdef TGT_DLL
#pragma warning( disable : 4100 )

BOOL WINAPI DllMain(HINSTANCE hinstDLL,	DWORD dwReason,	LPVOID lpvReserved)
{
return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\common\dbglogr.h ===
// DbgLogr.h : This file contains the
// Created:  Dec '97
// Author : a-rakeba
// History:
// Copyright (C) 1997 Microsoft Corporation
// All rights reserved.
// Microsoft Confidential 

#if !defined ( _DBGLOGR_H_ )
#define _DBGLOGR_H_

#include "cmnhdr.h"

#include <windows.h>
#include <fstream.h>

#include "DbgLvl.h"

namespace _Utils {

class CDebugLogger {
public:
    static bool Init( DWORD dwDebugLvl = CDebugLevel::TRACE_DEBUGGING, 
                      LPCSTR lpszLogFileName = NULL );
    static void ShutDown();
    static void OutMessage( DWORD dwDebugLvl, LPSTR lpszFmt, ... );
    static void OutMessage( DWORD dwDebugLvl, LPTSTR lpszFmt, ... );
    static void OutMessage( DWORD dwDdebugLvl, DWORD dwLineNum,
    LPCSTR lpszFileName );
    static void OutMessage( LPCSTR lpszLineDesc, LPCSTR lpszFileName, 
                            DWORD dwLineNum, 
                            DWORD dwErrNum );

private:
    enum { BUFF_SIZE = 1024 };
    CDebugLogger();
    ~CDebugLogger();
    
    static void Synchronize( void );
    static void PrintTime( void );
    static void LogToFile( LPCSTR lpszFileName );

    static HANDLE s_hMutex;
    static LPSTR s_lpszLogFileName;
    static ostream* s_pOutput;
};

}
#endif // _DBGLOGR_H_

// Notes:

// CDebugLogger::Init() must be called before any use of this class.

// CDebugLogger::ShutDown() be called when done using the class.

// The private functions have not been made thread-safe, since their 
// purpose in life is to be called by the thread-safe public functions.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\common\cmnhdr.h ===
// cmnhdr.h : This file contains the
// Created:  Dec '97
// Author : a-rakeba
// History:
// Copyright (C) 1997 Microsoft Corporation
// All rights reserved.
// Microsoft Confidential 

#if !defined ( _CMNHDR_H_ )
#define _CMNHDR_H_

// Disabel some warnings so that the code compiles cleanly
// using warning Level 4 (more to do with code in the windows 
// header files )

// nonstandard extension used : nameless struct/union
#pragma warning(disable:4201)

#pragma warning(disable:4514)


// Windows Version Build Option
#ifdef _WIN32_WINNT
#undef _WIN32_WINNT
#endif
#define _WIN32_WINNT 0x0500

// Force all EXEs/DLLs to use STRICT type checking
#ifndef STRICT
#define STRICT
#endif

// Unicode Build Option
#ifndef UNICODE
#define UNICODE
#endif

//When using Unicode Win32 functions, use Unicode C-Runtime functions, too
#ifndef _UNICODE
#ifdef UNICODE
#define _UNICODE
#endif
#endif


#ifdef __cplusplus

extern "C"
{

#endif

extern void *SfuZeroMemory(
        void    *ptr,
        unsigned int   cnt
        );

#ifdef __cplusplus

}

#endif


// Zero Variable Macro
// Zero out a structure. If fInitSize is TRUE, initialize the first
// int to the size of the structure. 
#define chINITSTRUCT(structure, fInitSize)                          \
    (SfuZeroMemory(&(structure), sizeof(structure)),                   \
fInitSize ? (*(int*) &(structure) = sizeof(structure)) : 0)


// Pragma message helper macro

/* When the compiler sees a line like this:
#pragma chMSG(Fix this before shipping)
it  outputs a line like this:
C:\ons\telnet\utils\cmnhdr.h(37):
    Fix this before shipping 

Just click on that output line & VC++ will take you to the
corresponding line in the code
*/

#define chSTR(x) #x
#define chSTR2(x) chSTR(x)
#define chMSG(desc)                                                 \
    message(__FILE__ "(" chSTR2(__LINE__) "): " #desc)

#endif // _CMNHDR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\common\dbglogr.cpp ===
// DbgLogr.cpp : This file contains the
// Created:  Dec '97
// Author : a-rakeba
// History:
// Copyright (C) 1997 Microsoft Corporation
// All rights reserved.
// Microsoft Confidential 

#include "cmnhdr.h"

#include <windows.h>
#include <iostream.h>
#include <stdarg.h>
#include <stdio.h>
#include <sys/timeb.h>
#include <time.h>
#include <assert.h>

#include "DbgLogr.h"
#include <tlntutils.h>


using namespace _Utils;

LPSTR CDebugLogger::s_lpszLogFileName = 0;
HANDLE CDebugLogger::s_hMutex         = 0;
ostream* CDebugLogger::s_pOutput      = 0;


bool 
CDebugLogger::Init
( 
    DWORD dwDebugLvl, 
    LPCSTR lpszLogFileName 
)
{
    Synchronize();

    if (! TlntSynchronizeOn(s_hMutex))
    {
        return false;
    }

    CDebugLevel::TurnOffAll();
    CDebugLevel::TurnOn( dwDebugLvl );
    
    if( lpszLogFileName == NULL )
    {
        if( s_pOutput != &cerr )
        {
            delete s_pOutput;
            s_pOutput = &cerr;
        }

        ReleaseMutex( s_hMutex );
        return ( true );
    }

    LogToFile( lpszLogFileName );

    ReleaseMutex( s_hMutex );
    return ( true );
}


void CDebugLogger::Synchronize( void )
{
    if( s_hMutex != NULL )
        return;

    s_hMutex = TnCreateMutex( NULL, FALSE, 0 );

    assert( s_hMutex != NULL );
}


void CDebugLogger::ShutDown( void )
{
	// WaitForSingleObject( s_hMutex, INFINITE );

    CDebugLevel::TurnOffAll();

    if( s_pOutput != &cerr )
    {
        ( ( ofstream* ) s_pOutput )->close();
        delete (ofstream*)s_pOutput;
    }
    s_pOutput = NULL;

    delete [] s_lpszLogFileName;
    s_lpszLogFileName = NULL;

    TELNET_CLOSE_HANDLE( s_hMutex );
}


void 
CDebugLogger::OutMessage
( 
    DWORD dwDebugLvl, 
    LPSTR lpszFmtStr, 
    ... 
)
{
    if (TlntSynchronizeOn(s_hMutex))
    {
        assert( s_pOutput != NULL );

        if( CDebugLevel::IsCurrLevel( dwDebugLvl ) )
        {
            CHAR *szBuf = new CHAR[ 2 * BUFF_SIZE ];

            if (szBuf)
            {
                va_list	arg;

                va_start( arg, lpszFmtStr );

                vsprintf( szBuf, lpszFmtStr, arg );

                va_end( arg );

                *s_pOutput << "Thread ID : "<< GetCurrentThreadId() << "\n\t" << szBuf 
                    << endl;

                delete [] szBuf;
            }
        }

        ReleaseMutex( s_hMutex );
    }
}

void
CDebugLogger::OutMessage
(
    DWORD dwDebugLvl,
    LPTSTR lpszFmtStr,
    ...
)
{
    if (TlntSynchronizeOn(s_hMutex))
    {
        assert( s_pOutput != NULL );

        if( CDebugLevel::IsCurrLevel( dwDebugLvl ) )
        {
            WCHAR *szBuf = new WCHAR[ 2 * BUFF_SIZE ];

            if( szBuf )
            {
                va_list arg;

                va_start( arg, lpszFmtStr );

                vswprintf( szBuf, lpszFmtStr, arg );

                va_end( arg );

                DWORD dwSize = WideCharToMultiByte( GetConsoleCP(), 0, szBuf, -1, 
                                                    NULL, 0, NULL, NULL );
                CHAR *szStr = new CHAR[ dwSize ] ;

                if (szStr) 
                {
                    WideCharToMultiByte( GetConsoleCP(), 0, szBuf, -1, szStr, dwSize, 
                                         NULL, NULL );

                    *s_pOutput << "Thread ID : "<< GetCurrentThreadId() << "\n\t" << szStr
                        << endl;

                    delete[] szStr;
                }

                delete[] szBuf;
            }
        }

        ReleaseMutex( s_hMutex );
    }
}


void 
CDebugLogger::OutMessage
( 
    DWORD dwDebugLvl, 
    DWORD dwLineNum,
    LPCSTR lpszFileName 
)
{
    if (TlntSynchronizeOn(s_hMutex))
    {
        assert(s_pOutput != NULL);

        if( !CDebugLevel::IsCurrLevel( dwDebugLvl ) )
        {
            ReleaseMutex( s_hMutex );
            return;
        }

        *s_pOutput << "Thread ID : " << GetCurrentThreadId() << "\n\t" 
            << " in File: " << lpszFileName << " at line: " << dwLineNum << endl;

        ReleaseMutex( s_hMutex );
    }
}


void 
CDebugLogger::OutMessage
( 
    LPCSTR lpszLineDesc, 
    LPCSTR lpszFileName, 
    DWORD dwLineNum, 
    DWORD dwErrNum 
)
{
    if (TlntSynchronizeOn(s_hMutex))
    {
        assert( s_pOutput != NULL );

        DWORD dwSize = 0;
        CHAR *szStr = NULL;
        LPTSTR lpBuffer;

        FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL, dwErrNum, LANG_NEUTRAL, ( LPTSTR ) &lpBuffer, 0, NULL );

        if( !lpBuffer )
        {
            goto AbortOutMessage1;
        }


        *s_pOutput << "\nThe following call failed at line"
                   << dwLineNum << " in " << lpszFileName << ":\n\n"
                   << lpszLineDesc << "\n\nReason:"; 

        dwSize = WideCharToMultiByte( GetConsoleCP(), 0, lpBuffer, -1, 
                                            NULL, 0, NULL, NULL );
        szStr = new CHAR[ dwSize ] ;
        if( !szStr )
        {
            goto AbortOutMessage2;
        }

        WideCharToMultiByte( GetConsoleCP(), 0, lpBuffer, -1, szStr, dwSize, 
                             NULL, NULL );
        *s_pOutput << szStr << "\n";
        delete[] szStr;

    AbortOutMessage2:
        LocalFree( lpBuffer );
    AbortOutMessage1:
        ReleaseMutex( s_hMutex );
    }
}


void CDebugLogger::PrintTime( void )
{
    // print the current time

    assert( s_pOutput != NULL );

    struct _timeb timebuffer;   char *timeline;   _ftime( &timebuffer );
    timeline = ctime( & ( timebuffer.time ) );

    CHAR szBuff[256];
    sprintf( szBuff, "The time is %.19s.%hu %s", timeline, timebuffer.millitm,
        &timeline[20] );

    *s_pOutput << szBuff << endl;

    return;
}


void 
CDebugLogger::LogToFile
( 
    LPCSTR lpszFileName 
)
{
    if( s_pOutput != &cerr )
    {
        delete s_pOutput;
        s_pOutput = NULL;
    }

    if( s_lpszLogFileName )
    {
        delete [] s_lpszLogFileName;
        s_lpszLogFileName = NULL;
    }
    s_lpszLogFileName = new CHAR[strlen(lpszFileName)+1];
    if( !s_lpszLogFileName )
    {
        return;
    }

    strcpy( s_lpszLogFileName, lpszFileName );

    s_pOutput = new ofstream( s_lpszLogFileName, ios::app );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\common\dbglvl.h ===
// DbgLvl.h : This file contains the
// Created:  Dec '97
// Author : a-rakeba
// History:
// Copyright (C) 1997 Microsoft Corporation
// All rights reserved.
// Microsoft Confidential 

#if !defined( _DBGLVL_H_ )
#define _DBGLVL_H_

#include "cmnhdr.h"

#include <windows.h>

namespace _Utils {

class CDebugLevel {

    friend class CDebugLogger;

public:
    enum {  TRACE_DEBUGGING = 0x00000001, DBG_RECVD_CHARS = 0x00000002, 
            DBG_SENT_CHARS  = 0x00000004, DBG_NEGOTIATION = 0x00000008, 
            DBG_THREADS     = 0x00000010, TRACE_HANDLE = 0x00000020,
            TRACE_SOCKET = 0x00000040
    };

private:
    static void TurnOn( DWORD dwLvl );
    static void TurnOnAll( void );
    static void TurnOff( DWORD dwLvl );
    static void TurnOffAll( void );
    static bool IsCurrLevel( DWORD dwLvl );

    CDebugLevel();
    ~CDebugLevel();

    static DWORD s_dwLevel;
};

}
#endif // _DBGLVL_H_

// Notes:
// This class is not made thread-safe, since it's purpose in life
// is to be called from thread-safe code in CDebugLogger
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\common\dbglvl.cpp ===
// DbgLvl.cpp : This file contains the
// Created:  Dec '97
// Author : a-rakeba
// History:
// Copyright (C) 1997 Microsoft Corporation
// All rights reserved.
// Microsoft Confidential

#include "DbgLvl.h"
//#include "w4warn.h"

using namespace _Utils;

DWORD CDebugLevel::s_dwLevel = 0;

void 
CDebugLevel::TurnOn
( 
    DWORD dwLvl 
)
{
    s_dwLevel |= dwLvl;
}


void CDebugLevel::TurnOnAll( void )
{
    s_dwLevel = ( DWORD ) -1;
}


void 
CDebugLevel::TurnOff
( 
    DWORD dwLvl 
)
{
    s_dwLevel &= dwLvl ^ -1;
}


void CDebugLevel::TurnOffAll( void )
{
    s_dwLevel = 0;
}


bool 
CDebugLevel::IsCurrLevel
( 
    DWORD dwLvl 
)
{
    if( ( s_dwLevel & dwLvl ) == 0 )
        return ( false );
    else
        return ( true );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\common\dynarray.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dynarray

Abstract:

    This header file implements a Dynamic Array.

Author:

    Doug Barlow (dbarlow) 10/5/1995

Environment:

    Win32

Notes:



--*/

#ifndef _DYNARRAY_H_
#define _DYNARRAY_H_


//
//==============================================================================
//
//  CDynamicArray
//
template <class T>
class CDynamicArray
{
public:

    //  Constructors & Destructor

    CDynamicArray(void)
    { m_Max = m_Mac = 0; m_pvList = NULL; };

    virtual ~CDynamicArray()
    { Clear(); };

    //  Properties
    //  Methods

    void
    Clear(void)
    {
        if (NULL != m_pvList)
        {
            delete[] m_pvList;
            m_pvList = NULL;
            m_Max = 0;
            m_Mac = 0;
        }
    };

    void
    Empty(void)
    { m_Mac = 0; };

    T *
    Set(
        IN int nItem,
        IN T *pvItem);

    T *
    Insert(
        IN int nItem,
        IN T *pvItem);

    T *
    Add(
        IN T *pvItem);

    T * const
    Get(
        IN int nItem)
    const;

    DWORD
    Count(void) const
    { return m_Mac; };


    //  Operators
    T * const
    operator[](int nItem) const
    { return Get(nItem); };


protected:
    //  Properties

    DWORD
        m_Max,          // Number of element slots available.
        m_Mac;          // Number of element slots used.
    T **
        m_pvList;       // The elements.


    //  Methods
};


/*++

Set:

    This routine sets an item in the collection array.  If the array isn't that
    big, it is expanded with NULL elements to become that big.

Arguments:

    nItem - Supplies the index value to be set.
    pvItem - Supplies the value to be set into the given index.

Return Value:

    The value of the inserted value, or NULL on errors.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

template<class T>
inline T *
CDynamicArray<T>::Set(
    IN int nItem,
    IN T * pvItem)
{
    DWORD index;


    //
    // Make sure the array is big enough.
    //

    if ((DWORD)nItem >= m_Max)
    {
        int newSize = (0 == m_Max ? 4 : m_Max);
        while (nItem >= newSize)
            newSize *= 2;
        T **newList = new T*[newSize];
        if (NULL == newList)
            goto ErrorExit;
        for (index = 0; index < m_Mac; index += 1)
            newList[index] = m_pvList[index];
        if (NULL != m_pvList)
            delete[] m_pvList;
        m_pvList = newList;
        m_Max = newSize;
    }


    //
    // Make sure intermediate elements are filled in.
    //

    if ((DWORD)nItem >= m_Mac)
    {
        for (index = m_Mac; index < (DWORD)nItem; index += 1)
            m_pvList[index] = NULL;
        m_Mac = (DWORD)nItem + 1;
    }


    //
    // Fill in the list element.
    //

    m_pvList[(DWORD)nItem] = pvItem;
    return pvItem;

ErrorExit:
    return NULL;
}


/*++

Insert:

    This routine inserts an element in the array by moving all elements above it
    up one, then inserting the new element.

Arguments:

    nItem - Supplies the index value to be inserted.
    pvItem - Supplies the value to be set into the given index.

Return Value:

    The value of the inserted value, or NULL on errors.

Author:

    Doug Barlow (dbarlow) 10/10/1995

--*/

template<class T>
inline T *
CDynamicArray<T>::Insert(
    IN int nItem,
    IN T * pvItem)
{
    DWORD index;
    for (index = nItem; index < m_Mac; index += 1)
        if (NULL == Set(index + 1, Get(index)))
            return NULL;    // Only the first one can fail, so no change
                            // happens on errors.
    return Set(nItem, pvItem);
}


/*++

Add:

    This method adds an element to the end of the dynamic array.

Arguments:

    pvItem - Supplies the value to be added to the list.

Return Value:

    The value of the added value, or NULL on errors.

Author:

    Doug Barlow (dbarlow) 10/10/1995

--*/

template<class T>
inline T *
CDynamicArray<T>::Add(
    IN T *pvItem)
{
    return Set(Count(), pvItem);
}


/*++

Get:

    This method returns the element at the given index.  If there is no element
    previously stored at that element, it returns NULL.  It does not expand the
    array.

Arguments:

    nItem - Supplies the index into the list.

Return Value:

    The value stored at that index in the list, or NULL if nothing has ever been
    stored there.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

template <class T>
inline T * const
CDynamicArray<T>::Get(
    int nItem)
    const
{
    if (m_Mac <= (DWORD)nItem)
        return NULL;
    else
        return m_pvList[nItem];
}

#endif // _DYNARRAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\common\killapps.cpp ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
#include <Windows.h>
#include <TChar.h>

#include <MsgFile.h>
#include <TelnetD.h>
#include <RegUtil.h>
#include <TlntUtils.h>
#include <Debug.h>
#include <KillApps.h>
#include <psapi.h>

#pragma warning(disable:4100)
#pragma warning(disable: 4127)

using namespace _Utils;
using CDebugLevel::TRACE_DEBUGGING;
using CDebugLevel::TRACE_HANDLE;
using CDebugLevel::TRACE_SOCKET;

#define DOWN_WITH_AUTHORITY     {0, 0, 0, 0, 0x6, 0x66} // s-1-666
#define DEMONS          1

PSID  g_psidBgJobGroup = NULL;
DWORD g_dwKillAllApps = DEFAULT_DISCONNECT_KILLALL_APPS;

extern HANDLE       g_hSyncCloseHandle;

bool CreateBgjobSpecificSid()
{
    SID_IDENTIFIER_AUTHORITY AnarchyAuthority = DOWN_WITH_AUTHORITY;

    if( !AllocateAndInitializeSid( &AnarchyAuthority, 1, DEMONS,
            0, 0, 0, 0, 0, 0, 0, &g_psidBgJobGroup ) )
    {
        return false;
    }

    return true;
}

bool IsAclAddedByBgJobPresent( PACL pAcl ) 
{
    ACCESS_DENIED_ACE  *pAce = NULL;
    WORD wIndex        = 0;

    for(  wIndex=0; wIndex<pAcl->AceCount; wIndex++ )
    {
        if( GetAce( pAcl, wIndex, ( PVOID * )&pAce ) )
        {
            if( EqualSid( g_psidBgJobGroup, &( pAce->SidStart ) ) )
            {
                return true;
            }
        }
    }

    return false;
}


//We check if this process's DACL has an ACE added by the BgJob
//ACE is generated from a SID know both to the BgJob and tlntsess.exe

bool IsThisProcessLaunchedFromBgJob( HANDLE hToken ) 
{
    DWORD dwLength = 0;
    TOKEN_DEFAULT_DACL *ptdDacl = NULL;

    if( g_dwKillAllApps )
    {
        return false;
    }

    // Get required buffer size and allocate the Default Dacl buffer.
    if (!GetTokenInformation( hToken, TokenDefaultDacl, NULL, 0, &dwLength ) ) 
    {
        if(GetLastError() != ERROR_INSUFFICIENT_BUFFER ) 
            return false;

        ptdDacl = ( TOKEN_DEFAULT_DACL * ) HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, dwLength);
    }
    if ( ptdDacl  == NULL)
    {
        return false;
    }            

    if ( GetTokenInformation( hToken, TokenDefaultDacl, ptdDacl, dwLength, &dwLength ) ) 
    {
        if( ptdDacl && IsAclAddedByBgJobPresent( ptdDacl->DefaultDacl ) )
        {
            HeapFree( GetProcessHeap(), 0,ptdDacl );
            return ( true );
        }
    }
    HeapFree( GetProcessHeap(), 0,ptdDacl );
    return( false );
}

void EnumSessionProcesses( LUID id, void fPtr ( HANDLE, DWORD, LPWSTR ),
                        ENUM_PURPOSE epWhyEnumerate )
{
    DWORD   rgdwPids[ MAX_PROCESSES_IN_SYSTEM ];
    DWORD   dwActualSizeInBytes = 0;
    DWORD   dwActualNoOfPids    = 0;
    DWORD   dwIndex             = 0;
    HANDLE  hProc               = NULL;
    HANDLE  hAccessToken        = NULL;
    LUID    luidID;

    EnableDebugPriv();

    EnumProcesses( rgdwPids, MAX_PROCESSES_IN_SYSTEM, &dwActualSizeInBytes );
    dwActualNoOfPids = dwActualSizeInBytes / sizeof( DWORD );

    for( dwIndex = 0; dwIndex < dwActualNoOfPids; dwIndex++ )
    {
        SfuZeroMemory( &luidID, sizeof( luidID ) );

        hProc = OpenProcess( PROCESS_ALL_ACCESS, FALSE, rgdwPids[ dwIndex ] );
        if( hProc )
        {
            if( OpenProcessToken( hProc, TOKEN_QUERY, &hAccessToken ))
            {
                if( GetAuthenticationId( hAccessToken, &luidID ) )
                {
                    if( id.HighPart == luidID.HighPart&&
                            id.LowPart == luidID.LowPart )
                    {
                        //this process belongs to our session

                        if( epWhyEnumerate != TO_CLEANUP ||
                           !IsThisProcessLaunchedFromBgJob( hAccessToken ) )
                        {
                            LPTSTR lpszProcessName = NULL;

                            ( fPtr )( hProc, rgdwPids[ dwIndex ], lpszProcessName );

                            _TRACE( TRACE_DEBUGGING, " pid = %d ", rgdwPids[ dwIndex ] );
                        }
                    }
                }
                TELNET_CLOSE_HANDLE( hAccessToken );
            }
            TELNET_CLOSE_HANDLE( hProc );
        }
    }
}

BOOL EnableDebugPriv( VOID )
{
    HANDLE hToken;
    LUID DebugValue;
    TOKEN_PRIVILEGES tkp;

    //
    // Retrieve a handle of the access token
    //
    if (!OpenProcessToken(GetCurrentProcess(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            &hToken)) 
    {
//        printf("OpenProcessToken failed with %d\n", GetLastError());
        return FALSE;
    }

    //
    // Enable the SE_DEBUG_NAME privilege or disable
    // all privileges, depending on the fEnable flag.
    //
    if (!LookupPrivilegeValue((LPTSTR) NULL,
            SE_DEBUG_NAME,
            &DebugValue)) 
    {
        TELNET_CLOSE_HANDLE( hToken );
//        printf("LookupPrivilegeValue failed with %d\n", GetLastError());
        return FALSE;
    }

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Luid = DebugValue;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (!AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tkp,
            sizeof(TOKEN_PRIVILEGES),
            (PTOKEN_PRIVILEGES) NULL,
            (PDWORD) NULL)) 
    {
        TELNET_CLOSE_HANDLE( hToken );
//        printf("AdjustTokenPrivileges failed with %d\n", GetLastError());
        return FALSE;
    }

    TELNET_CLOSE_HANDLE( hToken );
    return TRUE;
}
 
BOOL GetAuthenticationId( HANDLE hToken, LUID* pId ) 
{
    BOOL bSuccess = FALSE;
    DWORD dwLength = 0;
    PTOKEN_STATISTICS pts = NULL;

    // Get required buffer size and allocate the TOKEN_GROUPS buffer.

    if (!GetTokenInformation( hToken, TokenStatistics, (LPVOID) pts, 0, 
        &dwLength )) 
    {
        if(GetLastError() != ERROR_INSUFFICIENT_BUFFER ) 
            goto Cleanup;

        pts = (PTOKEN_STATISTICS) VirtualAlloc(NULL,dwLength,
                 MEM_COMMIT, PAGE_READWRITE);
        
    }
    if( pts == NULL )
        goto Cleanup;

    // Get the token group information from the access token.

    if( !GetTokenInformation( hToken, TokenStatistics, (LPVOID) pts, dwLength,
        &dwLength )) 
        goto Cleanup;

    *pId = pts->AuthenticationId;
    bSuccess = TRUE;


Cleanup: 
    // Free the buffer for the token groups.
    if( pts != NULL )
        VirtualFree( pts, 0, MEM_RELEASE );

    return bSuccess;
}

void KillTheProcess( HANDLE hProc, DWORD dwProcessId, LPWSTR lpszProcessName )
{
    TerminateProcess( hProc, 1 );
    return;
}

bool GetRegValues()
{
    HKEY hk = NULL;
    bool bRetVal = false;

    if( RegOpenKey( HKEY_LOCAL_MACHINE, REG_PARAMS_KEY, &hk ) )
    {
        goto ExitOnError;
    }

    if( !GetRegistryDW( hk, NULL, L"DisconnectKillAllApps", &g_dwKillAllApps,
                                DEFAULT_DISCONNECT_KILLALL_APPS,FALSE ) )
    {
        goto ExitOnError;
    }
    
    bRetVal = true;
    
ExitOnError:
    RegCloseKey( hk );
    return ( bRetVal );
}

BOOL KillProcs( LUID id )
{
    GetRegValues();
    CreateBgjobSpecificSid();
    EnumSessionProcesses( id, KillTheProcess, TO_CLEANUP );
    FreeSid( g_psidBgJobGroup );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\common\debug.h ===
// debug.h : This file contains the
// Created:  Dec '97
// Author : a-rakeba
// History:
// Copyright (C) 1997 Microsoft Corporation
// All rights reserved.
// Microsoft Confidential

#if !defined( _DEBUG_H_ )
#define _DEBUG_H_

#include <stdio.h>

#include "DbgLogr.h"
#include "DbgLvl.h"


namespace _Utils {


#if _DEBUG || DBG

#define _TRACE CDebugLogger::OutMessage
#define _TRACE_POINT(x) CDebugLogger::OutMessage( x, __LINE__, __FILE__ )

#else

#define _TRACE ;
#define _TRACE_POINT(x) ((void)0)

#endif // _DEBUG 

#define _chFAIL( szMSG ) {                                  \
        _TRACE( CDebugLevel::TRACE_DEBUGGING, szMSG );      \
        DebugBreak();                                       \
    }

#define _chASSERTFAIL(file, line, expr) {                                   \
        CHAR sz[256];                                                       \
        sprintf(sz, "File %hs, line %d : %hs", file, line, expr);           \
        _chFAIL(sz);                                                        \
    }

#if _DEBUG || DBG

#define _chASSERT(a) {if (!(a))\
	_chASSERTFAIL(__FILE__, __LINE__, #a);}

#else

#define _chASSERT(a)

#endif // _DEBUG 


// Assert in debug builds, but don't remove the code in retail builds
#if _DEBUG || DBG

#define _chVERIFY1(a) _chASSERT(a)

#else

#define _chVERIFY1(x) (x)

#endif // _DEBUG

// Assert in debug builds, but don't remove the code in retail builds
// This is similar to chVERIFY1 but this is to be used in Win32 calls 
// requiring a call to GetLastError()

#define _chVERIFYFAIL( x, y, z ) {                              \
    CDebugLogger::OutMessage( x, y, z, GetLastError() );        \
}   

#if _DEBUG || DBG

#define _chVERIFY2(a) {if( !( a ) ) \
	_chVERIFYFAIL( #a, __FILE__, __LINE__ );}
	
#else

#define _chVERIFY2(x) (x)

#endif // _DEBUG

}

#endif // _DEBUG_H_

// Intended uses for:
// _TRACE_POINT --> for exact location 
// _TRACE* ---> for tracing, etc
// _chVERFIY1 ---> assert in debug build, code not removed in retail build
// _chVERFIY2 ---> win32 calls requiring GetLastError()
// _chASSERT ---> invariants, pre & post conditions, validity checks

// Notes:
// C++ exception handling avoided for various reasons
// possibly might use WIN32 SEH if necessary

// Hungarian notation as far as posssible but not when deemed overkill

// Win32 SDK data types instead of diresct C++ data types
//		e.g. CHAR vs char , DWORD vs unsigned int

// UNICODE only when absolutely necessary
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\common\killapps.h ===
// killApps.h : This file contains the
// Created:  Feb '98
// Author : a-rakeba
// History:
// Copyright (C) 1998 Microsoft Corporation
// All rights reserved.
// Microsoft Confidential 

#if defined(__cplusplus)
extern "C" {
#endif

typedef enum { TO_CLEANUP, TO_ENUM } ENUM_PURPOSE;

void EnumSessionProcesses( LUID, void fPtr ( HANDLE, DWORD, LPWSTR ), ENUM_PURPOSE );
BOOL EnableDebugPriv( VOID );
BOOL GetAuthenticationId( HANDLE hToken, LUID* pId );
BOOL KillProcs( LUID id );

#if defined(__cplusplus)
}
#endif

#define MAX_PROCESSES_IN_SYSTEM 1000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\common\resource.h ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TlntSvr.rc
//
#define IDS_SERVICENAME                 100
#define IDR_TlntSvr                     100
#define IDS_ENUMTELNETCLIENTSSVR_DESC   101
#define IDR_EnumTelnetClientsSvr        102
#define IDR_LOGONNOTIFICATIONSVR        103
#define IDS_ERR_REG_DELETE              105
#define IDS_ERR_OPEN_SCM                106
#define IDS_ERR_OPEN_SVC                107
#define IDS_ERR_CREATE_SVC              108
#define IDS_ERR_DELETE_SVC              109
#define IDS_MAX_CONNECTIONS_REACHED     110
#define IDS_LICENSE_LIMIT_REACHED       111
#define IDS_SERVICE_PAUSED              112
#define IDS_ERR_NEW_SESS_INIT           113
#define IDS_ERR_CONFIG_SVC              114
#define IDS_MESSAGE_HEADER              115
#define IDS_SERVICE_DESCRIPTION         116
#define IDS_MAX_IPLIMIT_REACHED 117
#define IDS_TELNETCLIENTS_GROUP_COMMENT 118

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\common\regutil.h ===
// regutil.h : This file contains the
// Created:  Mar '98
// History:
// Copyright (C) 1998 Microsoft Corporation
// All rights reserved.
// Microsoft Confidential 

#if !defined(_REGUTIL_H_)
#define _REGUTIL_H_

bool GetRegistryDWORD( HKEY hk, LPTSTR lpszTag, LPDWORD lpdwValue,
    DWORD dwDefault, BOOL fOverwrite );

bool GetRegistrySZ( HKEY hk, LPTSTR tag, LPTSTR* lpszValue, LPTSTR def, BOOL fOverwrite );


#endif // _REGUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\common\tlntutils.cpp ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
#include <CmnHdr.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <windows.h>
#include <TChar.h>

#include <MsgFile.h>
#include <TelnetD.h>
#include <debug.h>
#include <Regutil.h>
#include <Ipc.h>
#include <TlntUtils.h>

#include <stdlib.h>
#include <wincrypt.h>

#pragma warning( disable: 4127 )
#pragma warning( disable: 4706 )

using namespace _Utils;
using CDebugLevel::TRACE_DEBUGGING;
using CDebugLevel::TRACE_HANDLE;
using CDebugLevel::TRACE_SOCKET;

HANDLE g_hSyncCloseHandle;
HCRYPTPROV      g_hProv = { 0 };

PSID         administratorsSid = NULL, 
                    everyoneSid = NULL, 
                    localSystemSid = NULL,
                    localLocalSid = NULL,
                    localNetworkSid = NULL;

void *SfuZeroMemory(
        void    *ptr,
        unsigned int   cnt
        )
{
    volatile char *vptr = (volatile char *)ptr;

    while (cnt)
    {
        *vptr = 0;
        vptr ++;
        cnt --;
    }

    return ptr;
}

bool IsThisMachineDC()
{
    bool bRetVal = false;
    HKEY hkey = NULL;
    DWORD dwRetVal = 0;
    LPWSTR pszProductType = NULL;

    //
    //    Query the registry for the product type.
    //
    dwRetVal = RegOpenKeyEx (HKEY_LOCAL_MACHINE, REG_PRODUCT_OPTION,
                                                  0, KEY_READ, &hkey);
    if(dwRetVal != ERROR_SUCCESS )
    {
        _TRACE( TRACE_DEBUGGING, "Error: RegOpenKeyEx() -- 0x%1x", dwRetVal);
        bRetVal = false;
        goto IsThisMachineDCAbort;
    }
    if( !GetRegistryString( hkey, NULL, L"ProductType", &pszProductType, L"",FALSE ) )
    {
        bRetVal = false;
        goto IsThisMachineDCAbort;
    }

    if( _wcsicmp( pszProductType, L"LanManNT" ) == 0 )
    {
        bRetVal = true;
    }


IsThisMachineDCAbort:
    delete[] pszProductType;
    if(hkey)
    {
        RegCloseKey (hkey);
    }
    return bRetVal;
}


//Before we proceed any further check whether we are hosting the domain
bool GetDomainHostedByThisMc( LPWSTR szDomain )
{
    OBJECT_ATTRIBUTES    obj_attr = { 0 };
    LSA_HANDLE          policy;
    bool                bRetVal = false;
    NTSTATUS            nStatus = STATUS_SUCCESS;

    _chASSERT( szDomain );
    if( !szDomain )
    {
        goto GetDomainHostedByThisMcAbort;
    }

    obj_attr.Length = sizeof(obj_attr);
    szDomain[0]        = L'\0';

    nStatus = LsaOpenPolicy(
                NULL,   // Local machine
                &obj_attr,
                POLICY_VIEW_LOCAL_INFORMATION,
                &policy
                );

    if (NT_SUCCESS(nStatus))
    {
        POLICY_ACCOUNT_DOMAIN_INFO  *info = NULL;

        nStatus = LsaQueryInformationPolicy(
                    policy,
                    PolicyAccountDomainInformation,
                    (PVOID *)&info
                    );

        if (NT_SUCCESS(nStatus)) 
        {
            bRetVal = true;
            wcscpy( szDomain, info->DomainName.Buffer );
            LsaFreeMemory(info);
        }

        LsaClose(policy);
    }

GetDomainHostedByThisMcAbort:
    return bRetVal;
}


bool GetRegistryDW( HKEY hkKeyHandle1, HKEY hkKeyHandle2, LPTSTR szKeyName, 
                    DWORD *pdwVariable, DWORD dwDefaultVal, BOOL fOverwrite )
{
    if( !szKeyName || !pdwVariable )
    {
        _chASSERT( 0 );
        return false;
    }

    if( hkKeyHandle1 ) 
    { 
        if( !GetRegistryDWORD( hkKeyHandle1, szKeyName, pdwVariable, dwDefaultVal, fOverwrite ) ) 
        {  
             RegCloseKey( hkKeyHandle1 );  
             LogEvent( EVENTLOG_ERROR_TYPE, MSG_REGISTRYKEY, szKeyName ); 
             return ( false );  
        } 
    } 
    if( hkKeyHandle2 != NULL ) 
    { 
        if( !GetRegistryDWORD( hkKeyHandle2, szKeyName, pdwVariable, dwDefaultVal, fOverwrite ) ) 
        {  
             RegCloseKey( hkKeyHandle2 ); 
             LogEvent( EVENTLOG_ERROR_TYPE, MSG_REGISTRYKEY, szKeyName );
             return ( false );  
        } 
    }
    
    return( true );
}

bool GetRegistryString( HKEY hkKeyHandle1, HKEY hkKeyHandle2, LPTSTR szKeyName,
                        LPTSTR *pszVariable, LPTSTR szDefaultVal, BOOL fOverwrite ) 
{
    if( !pszVariable || !szKeyName || !szDefaultVal )
    {
        _chASSERT( 0 );
        return false;
    }

    *pszVariable = NULL;

    if( hkKeyHandle1 != NULL ) 
    { 
        if( !GetRegistrySZ( hkKeyHandle1, szKeyName, pszVariable, szDefaultVal,fOverwrite ) ) 
        {  
             RegCloseKey( hkKeyHandle1 );  
             LogEvent( EVENTLOG_ERROR_TYPE, MSG_REGISTRYKEY, szKeyName ); 
             return ( false );   
        } 
    }
    if( hkKeyHandle2 != NULL )                                
    { 
        delete[] *pszVariable;
        if( !GetRegistrySZ( hkKeyHandle2, szKeyName, pszVariable, szDefaultVal,fOverwrite ) ) 
        {  
             RegCloseKey( hkKeyHandle2 );  
             LogEvent( EVENTLOG_ERROR_TYPE, MSG_REGISTRYKEY, szKeyName ); 
             return ( false );   
        }
    }

    return( *pszVariable != NULL );
}


//Allocates memory for the destination buffer and expands the environment strgs
bool AllocateNExpandEnvStrings( LPWSTR strSrc, LPWSTR *strDst)
{
    DWORD expectedSize = 1024;
    DWORD actualSize = 0;

    *strDst = NULL;
    if( !strSrc )
    {
        return false;
    }
    do
    {
        if ( actualSize > expectedSize )
        {
            delete[] ( *strDst );
            expectedSize = actualSize;
        }
        *strDst = new TCHAR[ expectedSize ];
        if( !( *strDst ) )
        {
            return false;
        }
        actualSize = ExpandEnvironmentStrings( strSrc, *strDst, expectedSize );
        if(!actualSize)
        {
            if(*strDst)
            {
                delete[] ( *strDst );
            }
            *strDst = NULL;
            return false;
        }
            
    }
    while( actualSize > expectedSize );

    return true;
}

/* If this Function returns true, lpWideCharStr 
has converted wide  string. */

bool ConvertSChartoWChar(char *pSChar, LPWSTR lpWideCharStr)
{
    if( !pSChar )
    {
        return false;
    }

    //Convert the multibyte string to a wide-character string.
    if( !MultiByteToWideChar( GetConsoleCP(), 0, pSChar, -1, lpWideCharStr,
        MAX_STRING_LENGTH + 1 ) )
    {
        return false;
    }

    return true;
}

/* If this Function returns true, *lpWideCharStr is allocated memory and points
to wide  string. Otherwise it is NULL */

bool ConvertSChartoWChar(char *pSChar, LPWSTR *lpWideCharStr)
{
    int nLenOfWideCharStr;

    *lpWideCharStr = NULL;
    if( !pSChar )
    {
        return false;
    }

    nLenOfWideCharStr = strlen( pSChar ) + 1;
    *lpWideCharStr = new WCHAR[ nLenOfWideCharStr ];
    if( !(*lpWideCharStr) )
    {
        return false;
    }

    //Convert the multibyte string to a wide-character string.
    if( !MultiByteToWideChar( GetConsoleCP(), 0, pSChar, -1, *lpWideCharStr,
        nLenOfWideCharStr ) )
    {
        return false;
    }

    return true;
}



//Allocates and copies a WSTR
bool AllocNCpyWStr(LPWSTR *strDest, LPWSTR strSrc )
{
    DWORD wStrLen;

    if( !strSrc )
    {
        *strDest = NULL;
        return false;
    }
    wStrLen = wcslen( strSrc );
    *strDest = new WCHAR[ wStrLen + 1 ];
    if( *strDest )
    {
       wcscpy( *strDest, strSrc );//no attack. Dest string is allocated from the length of src string.
       return true;
    }
    return false;
}

bool WriteToPipe( HANDLE hWritingPipe, LPVOID lpData, DWORD dwSize, 
                            LPOVERLAPPED lpObj )
{
    DWORD dwNum = 0;
    _chASSERT( hWritingPipe );
    if( hWritingPipe == INVALID_HANDLE_VALUE)
    {
        return false;
    }

    BOOL bRetVal = 0;
    bRetVal = WriteFile( hWritingPipe, lpData, dwSize, &dwNum, lpObj ); 
    if( bRetVal == 0 )
    {
        DWORD dwErr = 0;
        dwErr = GetLastError();
        if( dwErr != ERROR_IO_PENDING )
        {
            if( dwErr != ERROR_NO_DATA ) //we found this error to be not interesting. Fix for bug 6777
            {
                LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, MSG_ERR_WRITEPIPE,
                                   dwErr );
            }
            _TRACE( TRACE_DEBUGGING, "WriteFile: 0x%1x", dwErr );
            goto ExitOnError;
        }
        else 
        {
            bRetVal = 1;
        }
    }
    TlntSynchronizeOn(lpObj->hEvent);

ExitOnError:
    return ( bRetVal != 0 );
}

bool WriteToPipe( HANDLE hWritingPipe, UCHAR ucMsgType, LPOVERLAPPED lpObj )
{
    UCHAR *ucMsg = NULL;
    DWORD dwNum = 0;
    BOOL   bRetVal = 0;
    _chASSERT( hWritingPipe );
    if( hWritingPipe == INVALID_HANDLE_VALUE )
    {
        goto ExitOnError;
    }
    
    ucMsg = new UCHAR[ IPC_HEADER_SIZE ];
    if( !ucMsg )
    {
        goto ExitOnError;
    }

    memcpy( ucMsg,     &ucMsgType, sizeof( UCHAR ) );//no overflow. Size constant.
    SfuZeroMemory( ucMsg + 1, sizeof( DWORD ) );

    bRetVal = WriteToPipe( hWritingPipe, ucMsg, IPC_HEADER_SIZE, lpObj );

    delete[] ucMsg;
ExitOnError:
    return ( bRetVal != 0 );
}

bool StuffEscapeIACs( UCHAR bufDest[], UCHAR *bufSrc, DWORD* pdwSize )
{
    DWORD length;
    DWORD cursorDest = 0;
    DWORD cursorSrc = 0;
    bool found = false;

    //get the location of the first occurrence of TC_IAC
    PUCHAR pDest = (PUCHAR) memchr( bufSrc, TC_IAC, *pdwSize );//Attack ? Size not known.

    while( pDest != NULL )
    {
        //copy data upto and including that point
        //This should not be more than MAX DWORD because we scrape atmost one cmd  at a time
        length = ( DWORD ) ( (pDest - ( bufSrc + cursorSrc)) + 1 );
        memcpy( bufDest + cursorDest, bufSrc + cursorSrc, length );//Attack ? Dest buffer size not known.
        cursorDest += length;

        //stuff another TC_IAC
        bufDest[ cursorDest++ ] = TC_IAC;

        cursorSrc += length;
        pDest = (PUCHAR) memchr( bufSrc + cursorSrc, TC_IAC,
                *pdwSize - cursorSrc );
    }

    //copy remaining data
    memcpy( bufDest + cursorDest, bufSrc + cursorSrc,
        *pdwSize - cursorSrc );//Attack? Dest buffer size not known


    if( cursorDest )
    {
        *pdwSize += cursorDest - cursorSrc;
        found = true;
    }

    return ( found );
}

void
FillProcessStartupInfo( STARTUPINFO *si, HANDLE hStdinPipe, HANDLE hStdoutPipe,
                                         HANDLE hStdError, WCHAR  *Desktop)
{
    _chASSERT( si != NULL );

    SfuZeroMemory(si, sizeof(*si));

    si->cb          = sizeof( STARTUPINFO );
    si->lpDesktop   = Desktop;
    si->dwFlags     = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
    si->hStdInput   = hStdinPipe;
    si->hStdOutput  = hStdoutPipe;
    si->hStdError   = hStdError;
    si->wShowWindow = SW_HIDE;

    return;
}

void
LogToTlntsvrLog( HANDLE  hEventSource, WORD wType, DWORD dwEventID,
                                                    LPCTSTR* pLogString )
{
    _chASSERT( hEventSource );
    if( !hEventSource )
    {
        return;
    }

    // Write to event log.
    switch( wType) {
    case EVENTLOG_INFORMATION_TYPE :
        _chVERIFY2( ReportEvent(hEventSource, EVENTLOG_INFORMATION_TYPE, 0,
            dwEventID, NULL, 1, 0, pLogString,  NULL) );
        break;
    case EVENTLOG_WARNING_TYPE :
        _chVERIFY2( ReportEvent(hEventSource, EVENTLOG_WARNING_TYPE, 0, 
            dwEventID, NULL, 1, 0, pLogString, NULL) );
        break;
    case EVENTLOG_ERROR_TYPE :
        _chVERIFY2( ReportEvent(hEventSource, EVENTLOG_ERROR_TYPE, 0, dwEventID,
            NULL, 1, 0, pLogString, NULL) );
        break;
    case EVENTLOG_AUDIT_SUCCESS :
        _chVERIFY2( ReportEvent(hEventSource, EVENTLOG_AUDIT_SUCCESS, 0, 
            dwEventID , NULL, 1, 0, pLogString, NULL) );
        break;
    case EVENTLOG_AUDIT_FAILURE :
        _chVERIFY2( ReportEvent(hEventSource, EVENTLOG_AUDIT_FAILURE, 0, 
            dwEventID , NULL, 1, 0, pLogString, NULL) );
        break;
    default:
        break;
    }
    return;
}

void
GetErrMsgString( DWORD dwErrNum, LPTSTR *lpBuffer )
{
    DWORD  dwStatus = 0;
    
    _chVERIFY2( dwStatus = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | 
            FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwErrNum, LANG_NEUTRAL, 
            ( LPTSTR )lpBuffer, 0, NULL ) );
    if( !dwStatus )
    {
    	if (lpBuffer) 
    	{
            *lpBuffer = (LPTSTR) LocalAlloc( LPTR, 2 );
            if (*lpBuffer)
        	    (*lpBuffer)[0] = _T('\0');
    	}
    }
    return;
}

bool
DecodeWSAErrorCodes( DWORD dwStatus, ... )
{
    DWORD dwEventId;
    WCHAR szMsg[ 50 ]; //This string is just to hold a 32 bit number
    DWORD dwTelnetPort;
    va_list	pArg;

    va_start(pArg, dwStatus);
    dwTelnetPort = va_arg(pArg, DWORD);
    va_end(pArg);
    switch( dwStatus )
    {
        case WSAEACCES:
            dwEventId = MSG_WSAPORTINUSE;
            break;
        case WSANOTINITIALISED:
            dwEventId = MSG_WSANOTINITIALISED;
            break;
        case WSAENETDOWN:
            dwEventId = MSG_WSAENETDOWN;
            break;
        case WSAENOBUFS:
            dwEventId = MSG_WSAENOBUFS;
            break;
        case WSAEHOSTUNREACH:
            dwEventId = MSG_WSAEHOSTUNREACH;
            break;
        case WSAECONNABORTED:
            dwEventId = MSG_WSAECONNABORTED;
            break;
        case WSAETIMEDOUT:
            dwEventId = MSG_WSAETIMEDOUT;
            break;
        default:
            // if (dwStatus == WSAENOTSOCK) 
            // {
            //     DebugBreak();
            // }
            dwEventId = MSG_WSAGETLASTERROR;
            break;
    }

    if( MSG_WSAGETLASTERROR == dwEventId )
    {
        //wsprintf( szMsg, L"%lu", dwStatus );
        LogFormattedGetLastError(EVENTLOG_ERROR_TYPE,MSG_WSAGETLASTERROR,dwStatus);
    }
    else if( MSG_WSAPORTINUSE == dwEventId )
    {
        _snwprintf( szMsg,(sizeof(szMsg)/sizeof(WCHAR)) - 1, L"%lu", dwTelnetPort );
        LogEvent( EVENTLOG_ERROR_TYPE, dwEventId, szMsg );
    }
    else
    {
        lstrcpyW( szMsg, L" " );//No overflow. Source string is const wchar *.
        LogEvent( EVENTLOG_ERROR_TYPE, dwEventId, szMsg );
    }
    _TRACE( TRACE_DEBUGGING, "WSAGetLastError: 0x%1x", dwStatus );

    return( true );
}

bool
DecodeSocketStartupErrorCodes( DWORD dwStatus )
{
    DWORD dwEventId;
    WCHAR szMsg[ 50 ]; //This string is just to hold a 32 bit number
    switch( dwStatus )
    {
        case WSASYSNOTREADY :
            dwEventId = MSG_WSANOTREADY;
            break;
        case WSAVERNOTSUPPORTED :
            dwEventId = MSG_WSAVERSION;
            break;
        case WSAEINVAL:
            dwEventId = MSG_WSAVERNOTSUPP;
            break;
        case WSAEPROCLIM:
            dwEventId = MSG_WSAEPROCLIM;
            break;
        case WSAEINPROGRESS:
            dwEventId = MSG_WSAEINPROGRESS;
            break;
        default:
            dwEventId = MSG_WSASTARTUPERRORCODE;
            break;
    }
    if( dwEventId == MSG_WSASTARTUPERRORCODE )
    {
        _snwprintf( szMsg,(sizeof(szMsg)/sizeof(WCHAR)) - 1,  L"%lu", dwStatus );  
    }
    else
    {
        lstrcpyW( szMsg, L" " );//no overflow. Source string is const wchar *
    }
    LogEvent( EVENTLOG_ERROR_TYPE, dwEventId, szMsg );
    _TRACE( TRACE_DEBUGGING, "WSAStartup error: 0x%1x", dwStatus );
    return( true );
}

bool
FinishIncompleteIo( HANDLE hIoHandle, LPOVERLAPPED lpoObject, LPDWORD pdwNumBytes )
{
    BOOL  dwStatus;

    if( !( dwStatus = GetOverlappedResult( hIoHandle,
                lpoObject, pdwNumBytes, true ) ) )
    {
        DWORD dwErr = GetLastError();
        LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, 0 , dwErr );
        _TRACE( TRACE_DEBUGGING, "Error: GetOverlappedResult() - 0x%1x",
             dwErr );
        return( false );
    }
    return( true );
}

bool
GetProductType ( LPWSTR *pszProductType )
{
    HKEY hkey;
    DWORD dwRetVal;
    bool ret = false;
    //
    //    Query the registry for the product type.
    //
    dwRetVal = RegOpenKeyEx (HKEY_LOCAL_MACHINE, REG_PRODUCT_OPTION,
                                                        0, KEY_READ, &hkey);
    if(dwRetVal != ERROR_SUCCESS )
    {
        _TRACE( TRACE_DEBUGGING, "Error: RegOpenKeyEx() -- 0x%1x", dwRetVal);
        LogEvent( EVENTLOG_ERROR_TYPE, MSG_REGISTRYKEY, REG_PRODUCT_OPTION );
        goto Done;
    }
    if( !GetRegistryString( hkey, NULL, L"ProductType", pszProductType, L"",FALSE ) )
    {
        goto Done;
    }
    ret = true;
Done:
    if(hkey)
        RegCloseKey (hkey);
    return ret;
}

void LogFormattedGetLastError( WORD dwType, DWORD dwMsg, DWORD dwErr )
{
    LPTSTR lpString = NULL;
    GetErrMsgString( dwErr, &lpString );
    if (NULL != lpString) 
    {
        LogEvent( dwType, dwMsg, lpString );
        LocalFree( lpString );
    }
}

bool
GetWindowsVersion( bool *bNtVersionGTE5 )
{
    _chASSERT( bNtVersionGTE5 );
    if( !bNtVersionGTE5 )
    {
        return( FALSE );
    }

    DWORD dwRetVal;
    HKEY  hk;
    LPWSTR m_pszOsVersion;

    *bNtVersionGTE5 = false;
    if( ( dwRetVal = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_WINNT_VERSION, 0,
         KEY_QUERY_VALUE, &hk ) ) != ERROR_SUCCESS )
    {
        _TRACE( TRACE_DEBUGGING, "Error: RegOpenKeyEx() -- 0x%1x", dwRetVal);
        LogEvent( EVENTLOG_ERROR_TYPE, MSG_REGISTRYKEY, REG_WINNT_VERSION );
        return( FALSE );
    }
    else
    {
        if( !GetRegistryString( hk, NULL, L"CurrentVersion", &m_pszOsVersion, L"",FALSE ) )
        {
            return( FALSE );
        }
        if( wcscmp( m_pszOsVersion, L"5.0" ) >= 0 )
        {
            *bNtVersionGTE5 = true;
        }
        delete[] m_pszOsVersion;
        m_pszOsVersion = NULL;
        RegCloseKey( hk );
   }
   return( TRUE );
}

void InitializeOverlappedStruct( LPOVERLAPPED poObject )
{
    _chASSERT( poObject != NULL );
    if( !poObject )
    {
        return;
    }

    poObject->Internal = 0;
    poObject->InternalHigh = 0;
    poObject->Offset = 0;
    poObject->OffsetHigh = 0;
    _chVERIFY2( poObject->hEvent = CreateEvent( NULL, TRUE, FALSE, NULL) );
    return;
}

bool
CreateReadOrWritePipe ( LPHANDLE lphRead, LPHANDLE lphWrite,
    SECURITY_DESCRIPTOR* lpSecDesc, bool pipeMode )
{
    _chASSERT( lphRead != NULL );
    _chASSERT( lphWrite != NULL ); 
    _chASSERT( ( pipeMode == READ_PIPE ) || ( pipeMode == WRITE_PIPE ) );
    if( !lphRead || !lphWrite || 
            ( ( pipeMode != READ_PIPE ) && ( pipeMode != WRITE_PIPE ) ) )
    {
        return FALSE;
    }

    TCHAR szPipeName[ MAX_PATH ];
    bool bUniqueName = false;

    SECURITY_ATTRIBUTES sa;
    sa.nLength = sizeof( sa );
    sa.lpSecurityDescriptor = lpSecDesc;

    switch( pipeMode )
    {
        case WRITE_PIPE: sa.bInheritHandle = TRUE;
                         break;
        case READ_PIPE:  sa.bInheritHandle = FALSE;
                         break;
    }
    
    bUniqueName = GetUniquePipeName ( &szPipeName[0], &sa );
    if(!bUniqueName)
    {
        _TRACE(TRACE_DEBUGGING, "Error : Could not get a unique pipe name");
        return(FALSE);
    }
    *lphRead = CreateNamedPipe( szPipeName,
        PIPE_ACCESS_INBOUND | FILE_FLAG_OVERLAPPED | 
#ifdef FILE_FLAG_FIRST_PIPE_INSTANCE
            FILE_FLAG_FIRST_PIPE_INSTANCE, // Good, the system supports it, use it for additional security
#else
            0,
#endif
        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT, 1, 
        NET_BUF_SIZ, NET_BUF_SIZ, 0, &sa );

    //_chASSERT( *lphRead != INVALID_HANDLE_VALUE );
    if( INVALID_HANDLE_VALUE == *lphRead )
    {
        return ( FALSE  );
    }

    switch( pipeMode )
    {
        case WRITE_PIPE: sa.bInheritHandle = FALSE;
                         break;
        case READ_PIPE:  sa.bInheritHandle = TRUE;
                         break;
    }

    *lphWrite = CreateFile( szPipeName, GENERIC_WRITE, 0, &sa, OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | FILE_FLAG_WRITE_THROUGH
        |SECURITY_IDENTIFICATION |SECURITY_SQOS_PRESENT,
        NULL );

    _chASSERT( *lphWrite != INVALID_HANDLE_VALUE );
    if( INVALID_HANDLE_VALUE == *lphWrite ) 
    {
        TELNET_CLOSE_HANDLE( *lphRead );
        return ( FALSE );
    }

    return ( TRUE );
}

bool
GetUniquePipeName ( LPTSTR pszPipeName, SECURITY_ATTRIBUTES *sa )
{

/*++
Fix for MSRC issue 567 : 
Upon a telnet session instantiation, the telnet server process (tlntsvr.exe) creates 
two pipes for standard output and input of the command shell.  
These handles are then propagated to tlntsess.exe and cmd.exe.  
However, should the pipe be created prior to the telnet session instantiation, 
the telnet server process will connect to the application which has created the pipe 
rather than the telnet server process as would normally do.
Fix : 
Basically, since the pipename that we were generating before, was easy to guess,
it was possible to create a server side pipe instance even before it's actually created
by the server process. So this function is added which will create a pipe name with
random number appended to the PIPE_NAME_FORMAT_STRING ( earlier it was a 
number which was incremented everytime ). After the name creation, this function
will also check whether pipe with that name already exists. If yes, it'll keep on
generating new names till it finds a name for which the pipe does not exist. This
name will be returned to the calling function. 

--*/
    static BOOL firstTime = TRUE;
    HANDLE hPipeHandle = INVALID_HANDLE_VALUE;
    ULONG ulRandomNumber = 0;
    int iCounter=0;
    if(g_hProv == NULL)
    {
        if (!CryptAcquireContext(&g_hProv,NULL,NULL,PROV_RSA_FULL,CRYPT_VERIFYCONTEXT))
        {
            _TRACE(TRACE_DEBUGGING,L"Acquiring crypt context failed with error %d",GetLastError());
            return (FALSE);
        }
    }

    while ( iCounter++ < MAX_ATTEMPTS )
    {
        CryptGenRandom(g_hProv,sizeof(ulRandomNumber ),(PBYTE)&ulRandomNumber );
        
        _snwprintf( pszPipeName, MAX_PATH-1,PIPE_NAME_FORMAT_STRING, ulRandomNumber );
        hPipeHandle = CreateFile( pszPipeName, MAXIMUM_ALLOWED, 0, 
                                    sa, OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL 
                                    | FILE_FLAG_OVERLAPPED 
                                    | FILE_FLAG_WRITE_THROUGH
                                    | SECURITY_ANONYMOUS 
                                    |SECURITY_SQOS_PRESENT,
                                    NULL 
                                );
        if(INVALID_HANDLE_VALUE == hPipeHandle && GetLastError() == ERROR_FILE_NOT_FOUND)
        	break;
        TELNET_CLOSE_HANDLE(hPipeHandle);
    }
    return(INVALID_HANDLE_VALUE == hPipeHandle);
}


extern "C" void    TlntCloseHandle(
            BOOL            synchronize,
            HANDLE          *handle_to_close
            )
{
    if (synchronize) 
    {
        TlntSynchronizeOn(g_hSyncCloseHandle);
    }

    if ((NULL != *handle_to_close) && (INVALID_HANDLE_VALUE != *handle_to_close))
    {
        CloseHandle (*handle_to_close);
	    *handle_to_close = INVALID_HANDLE_VALUE;
    }

    if (synchronize) 
    {
        ReleaseMutex(g_hSyncCloseHandle);
    }
}

extern "C" bool TlntSynchronizeOn(
    HANDLE          object
    )
{
    if ((INVALID_HANDLE_VALUE == object) || (NULL == object)) 
    {
        return false;
    }

    return (WAIT_OBJECT_0 == WaitForSingleObject(object, INFINITE )) ? true : false;
}


/*
Description:

  Set SO_EXCLUSIVEADDRUSE on a socket.
Parameters:

  [in] socket
Return Values: On error, returns SOCKET_ERROR.
*/

int SafeSetSocketOptions(SOCKET s)
{
    int iStatus;
    int iSet = 1;
    iStatus = setsockopt( s, SOL_SOCKET, SO_EXCLUSIVEADDRUSE , ( char* ) &iSet,
                sizeof( iSet ) );
    return ( iStatus );
}

// The following is copied from sids.c in common\func 
// To get rid of compilation issues all the names of the functions are changed.

/*

    Name:           TnFreeStandardSids

    Function:       freeds the constant SIDS created by TnInitializeStandardSids

    Return:         N/A (void)

    Notes:          This function is a NOP, if it had been successfully called before and/or
                    the TnInitializeStandardSids hasn't been called yet.

    constructor:    call TnInitializeStandardSids when these sids are needed.

*/

VOID    TnFreeStandardSids(void)
{
    if ( NULL != administratorsSid )
    {
        FreeSid(administratorsSid);
        administratorsSid = NULL;
    }
    if ( NULL != localSystemSid )
    {
        FreeSid(localSystemSid);
        localSystemSid = NULL;
    }
    if ( NULL != localLocalSid )
    {
        FreeSid(localLocalSid);
        localLocalSid = NULL;
    }
    if ( NULL != localNetworkSid )
    {
        FreeSid(localNetworkSid);
        localNetworkSid = NULL;
    }
    if ( NULL != everyoneSid )
    {
        FreeSid(everyoneSid);
        everyoneSid = NULL;
    }
}

/*

    Name:           TnInitializeStandardSids

    Function:       Builds the constant SIDS for use by various modules 
                    The sids built are

                    Administrators, Everyone, LocalSystem

    Return:         boolean to indicate success or not

    Notes:          This function is a NOP, if it had been successfully called before and
                    the built sids haven't been freed it.

    Destructor:     call TnFreeStandardSids when these sids are no longer needed

*/

BOOL    TnInitializeStandardSids(void)
{
    SID_IDENTIFIER_AUTHORITY localSystemAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY worldAuthority = SECURITY_WORLD_SID_AUTHORITY;


    if ( (NULL != administratorsSid) &&
         (NULL != everyoneSid) && 
         (NULL != localSystemSid) &&
         (NULL != localLocalSid) &&
         (NULL != localNetworkSid)
          )
    {
        return TRUE;
    }

    TnFreeStandardSids(); // In case only some of them were available

    //Build administrators alias sid
    if ( ! AllocateAndInitializeSid(
                                   &localSystemAuthority,
                                   2, /* there are only two sub-authorities */
                                   SECURITY_BUILTIN_DOMAIN_RID,
                                   DOMAIN_ALIAS_RID_ADMINS,
                                   0,0,0,0,0,0, /* Don't care about the rest */
                                   &administratorsSid
                                   ) )
    {
        goto CLEAN_UP;
    }

    //Build LocalSystem sid
    if ( ! AllocateAndInitializeSid(
                                   &localSystemAuthority,
                                   1, /* there is only two sub-authority */
                                   SECURITY_LOCAL_SYSTEM_RID,
                                   0,0,0,0,0,0,0, /* Don't care about the rest */
                                   &localSystemSid
                                   ) )
    {
        goto CLEAN_UP;
    }

#ifndef SECURITY_LOCAL_SERVICE_RID

#define SECURITY_LOCAL_SERVICE_RID      (0x00000013L)
#define SECURITY_NETWORK_SERVICE_RID    (0x00000014L)

#endif

    //Build LocalLocal sid
    if ( ! AllocateAndInitializeSid(
                                   &localSystemAuthority,
                                   1, /* there is only two sub-authority */
                                   SECURITY_LOCAL_SERVICE_RID,
                                   0,0,0,0,0,0,0, /* Don't care about the rest */
                                   &localLocalSid
                                   ) )
    {
        goto CLEAN_UP;
    }

    //Build LocalSystem sid
    if ( ! AllocateAndInitializeSid(
                                   &localSystemAuthority,
                                   1, /* there is only two sub-authority */
                                   SECURITY_NETWORK_SERVICE_RID,
                                   0,0,0,0,0,0,0, /* Don't care about the rest */
                                   &localNetworkSid
                                   ) )
    {
        goto CLEAN_UP;
    }

    //Build EveryOne alias sid
    if ( ! AllocateAndInitializeSid(
                                   &worldAuthority,
                                   1, /* there is only two sub-authority*/
                                   SECURITY_WORLD_RID,
                                   0,0,0,0,0,0,0, /* Don't care about the rest */
                                   &everyoneSid
                                   ) )
    {
        goto CLEAN_UP;
    }

    return TRUE;

    CLEAN_UP:

    TnFreeStandardSids();

    return FALSE;
}

PSID    TnGetAdministratorsSid(void)
{
    return administratorsSid;
}

PSID    TnGetLocalSystemSid(void)
{
    return localSystemSid;
}

PSID    TnGetLocalLocalSid(void)
{
    return localLocalSid;
}

PSID    TnGetLocalNetworkSid(void)
{
    return localNetworkSid;
}

PSID    TnGetEveryoneSid(void)
{
    return everyoneSid;
}

/*

    Name:           TnCreateFile

    Function:       Creates a file.
                        This will result in the following acls :

                        BUILTIN\Administrators:F
                        NT AUTHORITY\SYSTEM:F

    Return:         HANDLE

*/    

HANDLE TnCreateFile(LPCTSTR lpFileName,
                     DWORD dwDesiredAccess,
                     DWORD dwSharedMode,
                     LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                     DWORD dwCreationDisposition,
                     DWORD dwFlagsAndAttributes,
                     HANDLE hTemplateFile
                     )
{
    BOOL     fCreatedLocally = (lpSecurityAttributes) ? FALSE : TRUE;
    HANDLE handle = TnCreateFileEx(lpFileName,
                         dwDesiredAccess,
                         dwSharedMode,
                         &lpSecurityAttributes,
                         dwCreationDisposition,
                         dwFlagsAndAttributes,
                         hTemplateFile
                         );

    if(fCreatedLocally)
    {
        TnFreeSecurityAttributes(&lpSecurityAttributes);
    }
    return(handle);
}




/*

    Name:           TnCreateFileEx

    Function:       Creates a file.
                        This will result in the following acls :

                        BUILTIN\Administrators:F
                        NT AUTHORITY\SYSTEM:F

    Return:         HANDLE

*/    

HANDLE TnCreateFileEx(LPCTSTR lpFileName,
                     DWORD dwDesiredAccess,
                     DWORD dwSharedMode,
                     LPSECURITY_ATTRIBUTES *lplpSecurityAttributes,
                     DWORD dwCreationDisposition,
                     DWORD dwFlagsAndAttributes,
                     HANDLE hTemplateFile
                     )
{
    //
    //  no parameter checking - we pass on all parameters passed down to the createfile api
    //

    HANDLE handle = INVALID_HANDLE_VALUE;
    BOOL    fCreatedLocally = FALSE;

    if (!lplpSecurityAttributes)
    {
        goto exit;
    }

    if(!(*lplpSecurityAttributes))
    {
        if (!TnCreateDefaultSecurityAttributes(lplpSecurityAttributes))
            goto exit;
        fCreatedLocally = TRUE;        
    }  

    handle = CreateFileW(lpFileName,
                     dwDesiredAccess,
                     dwSharedMode,
                     *lplpSecurityAttributes,
                     dwCreationDisposition,
                     dwFlagsAndAttributes,
                     hTemplateFile
                     );

    if (INVALID_HANDLE_VALUE != handle)
    {
       if ((CREATE_ALWAYS == dwCreationDisposition) && (ERROR_ALREADY_EXISTS == GetLastError()))
       {
            // For CREATE_ALWAYS disposition, for existing files, CreateFile() does not set the 
            // security attributes. So we will do that ourselves specially.

            if (!SetKernelObjectSecurity(handle, 
                        DACL_SECURITY_INFORMATION, 
                        (*lplpSecurityAttributes)->lpSecurityDescriptor))
            {
                // We could not set the security descriptor. Cannot trust this file
                CloseHandle(handle);
                handle = INVALID_HANDLE_VALUE;
            }
        }
    }

   if(INVALID_HANDLE_VALUE == handle)
   {
        if(fCreatedLocally)
        {
            TnFreeSecurityAttributes(lplpSecurityAttributes);
        }
    }
    
exit:
    return(handle);
}


/*

    Name:           TnCreateDirectory

    Function:       Creates a directory.
                        This will result in the following acls :

                        BUILTIN\Administrators:F
                        NT AUTHORITY\SYSTEM:F

    Return:         BOOL
*/    

BOOL TnCreateDirectory(LPCTSTR lpPathName,
                     LPSECURITY_ATTRIBUTES lpSecurityAttributes 
                     )
{
    BOOL fCreatedLocally = (lpSecurityAttributes) ? FALSE : TRUE, 
             fRetVal = TnCreateDirectoryEx(lpPathName,
                         &lpSecurityAttributes
                         );

    if(fCreatedLocally)
    {
        TnFreeSecurityAttributes(&lpSecurityAttributes);
    }
    return(fRetVal);
}




/*

    Name:           TnCreateDirectoryEx

    Function:       Creates a directory.
                        This will result in the following acls :

                        BUILTIN\Administrators:F
                        NT AUTHORITY\SYSTEM:F

    Return:         BOOL

*/    

BOOL TnCreateDirectoryEx(LPCTSTR lpPathName,
                     LPSECURITY_ATTRIBUTES *lplpSecurityAttributes
                     )
{
    //
    //  no parameter checking - we pass on all parameters passed down to the createfile api
    //

    BOOL fCreatedLocally = FALSE, fRetVal = FALSE;

    if (!lplpSecurityAttributes)
    {
        goto exit;
    }

    if(!(*lplpSecurityAttributes))
    {
        if (!TnCreateDefaultSecurityAttributes(lplpSecurityAttributes))
            goto exit;
        fCreatedLocally = TRUE;        
    }

    fRetVal = CreateDirectoryW(lpPathName,
                     *lplpSecurityAttributes
                     );

   if(FALSE == fRetVal)
   {
        if(fCreatedLocally)
        {
            TnFreeSecurityAttributes(lplpSecurityAttributes);
        }
    }
exit:
    return(fRetVal);
}

/*

    Name:           TnCreateMutex

    Function:       Creates a mutex.
                        This will result in the following acls :

                        BUILTIN\Administrators:F
                        NT AUTHORITY\SYSTEM:F

    Return:         HANDLE

*/    

HANDLE TnCreateMutex(LPSECURITY_ATTRIBUTES lpSecurityAttributes, 
                     BOOL bInitialOwner, 
                     LPCTSTR lpName 
                     )
{
    BOOL fCreatedLocally = (lpSecurityAttributes) ? FALSE : TRUE;
    
    HANDLE handle = TnCreateMutexEx(&lpSecurityAttributes,
                     bInitialOwner, 
                     lpName 
                     );

    if(fCreatedLocally)
    {
        TnFreeSecurityAttributes(&lpSecurityAttributes);
    }
    return(handle);
}




/*

    Name:           TnCreateMutexEx

    Function:       Creates a mutex.
                        This will result in the following acls :

                        BUILTIN\Administrators:F
                        NT AUTHORITY\SYSTEM:F

    Return:         HANDLE
*/    

HANDLE TnCreateMutexEx (LPSECURITY_ATTRIBUTES *lplpSecurityAttributes, 
                     BOOL bInitialOwner, 
                     LPCTSTR lpName 
                     )
{
    HANDLE handle = INVALID_HANDLE_VALUE;
    BOOL    fCreatedLocally = FALSE;

    //
    //  no parameter checking - we pass on all parameters passed down to the createfile api
    //
    
    if (!lplpSecurityAttributes)
    {
        goto exit;
    }

    if(!(*lplpSecurityAttributes))
    {
        if (!TnCreateDefaultSecurityAttributes(lplpSecurityAttributes))
            goto exit;
        fCreatedLocally = TRUE;        
    }

    handle = CreateMutexW(*lplpSecurityAttributes,
                     bInitialOwner,
                     lpName
                     );

   if(INVALID_HANDLE_VALUE == handle)
   {
        if(fCreatedLocally)
        {
            TnFreeSecurityAttributes(lplpSecurityAttributes);
        }
    }
exit:
    return(handle);
}




/*

    Name:           TnCreateDefaultSecurityAttributes

    Function:       Creates a default SECURITY_ATTRIBUTES.

    Return:         VOID

*/    

BOOL TnCreateDefaultSecurityAttributes(LPSECURITY_ATTRIBUTES *lplpSecurityAttributes )
{
    PSECURITY_DESCRIPTOR pSecDesc = NULL;
    BOOL                 fCreatedLocally = FALSE;

    if (!lplpSecurityAttributes)
        goto exit;

    if(!(*lplpSecurityAttributes))
    {
        *lplpSecurityAttributes = (LPSECURITY_ATTRIBUTES) malloc( sizeof(SECURITY_ATTRIBUTES));
        fCreatedLocally = TRUE;
    }

    if(!(*lplpSecurityAttributes))
        goto exit;

    if(!TnCreateDefaultSecDesc(&pSecDesc,0))
        goto exit;
    
    // Check on bInheritHandle
    (*lplpSecurityAttributes)->nLength = sizeof(SECURITY_ATTRIBUTES);
    (*lplpSecurityAttributes)->bInheritHandle = FALSE;
    (*lplpSecurityAttributes)->lpSecurityDescriptor = pSecDesc;

    return TRUE;

exit:
    if(pSecDesc)
        free(pSecDesc);
    if(fCreatedLocally && lplpSecurityAttributes && (*lplpSecurityAttributes))
    {
        free(*lplpSecurityAttributes);
        *lplpSecurityAttributes = NULL;
    }

    return FALSE;
}

/*
  Name:           TnFreeSecurityAttributes

*/

VOID TnFreeSecurityAttributes(LPSECURITY_ATTRIBUTES *lplpSecurityAttributes)
{
    if (lplpSecurityAttributes && (*lplpSecurityAttributes))
    {
        if((*lplpSecurityAttributes)->lpSecurityDescriptor)
        {
            free((*lplpSecurityAttributes)->lpSecurityDescriptor);
            (*lplpSecurityAttributes)->lpSecurityDescriptor = NULL;
        }
        free(*lplpSecurityAttributes);
        *lplpSecurityAttributes = NULL;
    }
}

/*
  Name:           TnCreateDefaultSecDesc

    Function:   Creates a self-relative security descriptor 
                          with full access to Administrator and LocalSystem.
                          Access to Everyone is as specified by the caller

    Notes:          The memory for the security descriptor is allocated 
                         within this function and has to be freed with free()

    Return:      TRUE for success, else FALSE       

*/

BOOL TnCreateDefaultSecDesc( PSECURITY_DESCRIPTOR *ppSecDesc,   DWORD EveryoneAccessMask )
{
   BOOL                retVal = FALSE;
   PACL                dacl = NULL;
   DWORD               aclSize = 0, lenSecDesc = 0;
   SECURITY_DESCRIPTOR AbsSecDesc;

   if(! TnInitializeStandardSids())
   {
      return retVal;
   }

   if(EveryoneAccessMask)
   {
     aclSize = sizeof(ACL) + (4* sizeof(ACCESS_ALLOWED_ACE)) + GetLengthSid(TnGetAdministratorsSid()) + GetLengthSid(TnGetLocalSystemSid()) + GetLengthSid(TnGetEveryoneSid()) + GetLengthSid(TnGetLocalLocalSid()) - (4*sizeof(DWORD));
   }
   else
   {
     aclSize = sizeof(ACL) + (3* sizeof(ACCESS_ALLOWED_ACE)) + GetLengthSid(TnGetAdministratorsSid()) + GetLengthSid(TnGetLocalSystemSid()) + GetLengthSid(TnGetLocalLocalSid())  - (3*sizeof(DWORD));
   }

   
   dacl  = (PACL)malloc(aclSize);
   if(!dacl)
    {
      goto Error;
    }
   
   SfuZeroMemory(dacl, sizeof(dacl));
   
   if(!InitializeAcl(dacl, aclSize, ACL_REVISION))
   {
      goto Error;
    }

    if(!AddAccessAllowedAce(dacl, ACL_REVISION, GENERIC_ALL, TnGetAdministratorsSid()))
   {
      goto Error;
   }

   if(!AddAccessAllowedAce(dacl, ACL_REVISION, GENERIC_ALL, TnGetLocalSystemSid()))
   {
      goto Error;
   }
   if(!AddAccessAllowedAce(dacl, ACL_REVISION, GENERIC_ALL, TnGetLocalLocalSid()))
   {
      goto Error;
   }
/*
   if(!AddAccessAllowedAce(dacl, ACL_REVISION, GENERIC_ALL, TnGetLocalNetworkSid()))
   {
      goto Error;
   }
*/

   if(EveryoneAccessMask)
   {
     if(!AddAccessAllowedAce(dacl, ACL_REVISION, EveryoneAccessMask, TnGetEveryoneSid()))
     {
        goto Error;
     }
   }

   if(!InitializeSecurityDescriptor(&AbsSecDesc, SECURITY_DESCRIPTOR_REVISION))
   {
      goto Error;
   }
  
   if(! SetSecurityDescriptorDacl(&AbsSecDesc, TRUE, dacl, FALSE))
   {
     goto Error;
   }

    lenSecDesc = GetSecurityDescriptorLength(&AbsSecDesc);

    *ppSecDesc  = (PSECURITY_DESCRIPTOR)malloc(lenSecDesc);
    if(!*ppSecDesc)
    {
      goto Error;
    }

    SfuZeroMemory(*ppSecDesc, lenSecDesc);
    
    if (!MakeSelfRelativeSD(&AbsSecDesc, *ppSecDesc, &lenSecDesc)) 
    {
      if (*ppSecDesc)
      {
        free(*ppSecDesc);
        *ppSecDesc = NULL;
      }    
      goto Error;
    }

    retVal = TRUE;
    
  Error:

    TnFreeStandardSids();
 
    if (dacl)
    {
      free(dacl);
    }

   return retVal;
}


// The following function is copy/pasted from common func library code
/**********************************************************************
* This function is functionally same as RegCreateKeyEx. But does something more & 
* has one extra parameter e.g., the last parameter DWORD EveryoneAccessMask.
*
* If  lpSecurityAttributes is NULL or lpSecurityAttributes->lpSecurityDescriptor is NULL,
* the fn creates or opens(if already exists) the reg key and apply a security descriptor 
* on that key such that,
*                     System:F, Admin:F and Everyone : as provideded 
*
* If lpSecurityAttributes is not NULL & lpSecurityAttributes->lpSecurityDescriptor is 
* also not NULL then EveryoneAccessMask is simply ignored.
**********************************************************************/ 

LONG TnSecureRegCreateKeyEx(
  HKEY hKey,                                  // handle to open key
  LPCTSTR lpSubKey,                           // subkey name
  DWORD Reserved,                             // reserved
  LPTSTR lpClass,                             // class string
  DWORD dwOptions,                            // special options
  REGSAM samDesired,                          // desired security access
  LPSECURITY_ATTRIBUTES lpSecurityAttributes, // inheritance
  PHKEY phkResult,                            // key handle 
  LPDWORD lpdwDisposition,                  // disposition value buffer
  DWORD EveryoneAccessMask
 )
{
    SECURITY_ATTRIBUTES sa = {0};
    LONG lRetVal;
    DWORD dwDisposition;
    
    // This variable keeps track whether SD is created locally. Coz if created locally we have to free
    // the corresponding mem location later in this function.
    BOOL fCreatedLocally = FALSE;
    
    sa.nLength = sizeof(sa);
    sa.bInheritHandle = lpSecurityAttributes?lpSecurityAttributes->bInheritHandle:FALSE;
    sa.lpSecurityDescriptor = lpSecurityAttributes?lpSecurityAttributes->lpSecurityDescriptor:NULL ;    
        
    if(sa.lpSecurityDescriptor == NULL)
    {
        fCreatedLocally = TRUE;
        if (!TnCreateDefaultSecDesc(&sa.lpSecurityDescriptor, EveryoneAccessMask))
             return -1;	  
    }
    
    // We are opening the key handle with WRITE_DAC access, cos if the key already exists we
    // may require to change the ACL
    lRetVal =  RegCreateKeyEx(
                                         hKey,                                    // handle to open key
                                         lpSubKey,                             // subkey name
                                         Reserved,                             // reserved
                                         lpClass,                                 // class string
                                         dwOptions,                            // special options
                                         samDesired |WRITE_DAC,     // desired security access
                                         &sa,                                       // inheritance
                                         phkResult,                             // key handle 
                                         &dwDisposition                        // disposition value buffer
                                       ); 
    
    if (ERROR_SUCCESS == lRetVal)
    {
        if (lpdwDisposition)
        {
            *lpdwDisposition = dwDisposition;
        }

        // If the key already exists set the ACL properly.
        if (REG_OPENED_EXISTING_KEY == dwDisposition)
        {
            lRetVal =  RegSetKeySecurity(*phkResult, DACL_SECURITY_INFORMATION, sa.lpSecurityDescriptor);
            if (ERROR_SUCCESS != lRetVal)
            {
                RegCloseKey(*phkResult);
                goto cleanup;
            }
        }
        
        lRetVal = RegCloseKey(*phkResult);

        if (ERROR_SUCCESS == lRetVal)
        {
            // Now open the the handle again with user provided samDesired.
            lRetVal =  RegOpenKeyEx(
                                               hKey,         // handle to open key
                                               lpSubKey,  // subkey name
                                               dwOptions,   // reserved
                                               samDesired, // security access mask
                                               phkResult    // handle to open key
                                             );
        }
    }

cleanup:
	
    if (fCreatedLocally)
        free(sa.lpSecurityDescriptor);
    
    return lRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\common\regutil.cpp ===
// regutil.cpp : This file contains the
// Created:  Mar '98
// History:
// Copyright (C) 1998 Microsoft Corporation
// All rights reserved.
// Microsoft Confidential 

#include "cmnhdr.h"
#include "debug.h"

using namespace _Utils;
using CDebugLevel::TRACE_DEBUGGING;
using CDebugLevel::TRACE_HANDLE;
using CDebugLevel::TRACE_SOCKET;

bool 
GetRegistryDWORD
( 
    HKEY hk, 
    LPTSTR lpszTag, 
    LPDWORD lpdwValue,
    DWORD dwDefault,
    BOOL fOverwrite
)
{
    DWORD dwType;
    DWORD dwSize  = sizeof( DWORD );

    if( !fOverwrite && RegQueryValueEx( hk, lpszTag, NULL, &dwType, ( LPBYTE )lpdwValue, 
        &dwSize ) == ERROR_SUCCESS ) 
    {
        if( ( dwType != REG_DWORD ) || ( dwSize != sizeof( DWORD ) ) )
          return ( false );
    } 
    else 
    {
        *lpdwValue = dwDefault;
        dwSize = sizeof( DWORD );
        RegSetValueEx( hk, lpszTag, 0, REG_DWORD, (LPBYTE) lpdwValue, dwSize );
    }
     return ( true );
}


bool 
GetRegistrySZ
( 
    HKEY hk, 
    LPTSTR tag, 
    LPTSTR* lpszValue, 
    LPTSTR def,
    BOOL fOverwrite
)
{
    DWORD dwSize;
    DWORD dwType;
    DWORD dwStatus;
  
    dwSize = 0;
    dwStatus = RegQueryValueEx(hk, tag, NULL, &dwType, (LPBYTE) NULL, &dwSize);
    if( !fOverwrite && (( dwStatus == ERROR_MORE_DATA ) || ( dwStatus == ERROR_SUCCESS )) ) 
    {
        if( ( dwType != REG_EXPAND_SZ ) && ( dwType != REG_SZ ) )
            return ( false );
        
        if( dwSize == 0 )
            dwSize++;
        
        *lpszValue = ( LPTSTR )  new  TCHAR[ dwSize ];

        if (*lpszValue)
        {
            if( RegQueryValueEx( hk, tag, NULL, &dwType, ( LPBYTE ) *lpszValue, 
                &dwSize ) != ERROR_SUCCESS )
            {
                return ( false );
            }
        }
        else
        {
            return (false);
        }

    } 
    else 
    {
        *lpszValue = ( LPTSTR ) new 
                            TCHAR[( wcslen( def )) + 1 ];
        if (*lpszValue)
        {
            wcscpy( *lpszValue, def ); //Attack ? size not known.
            dwSize = ( wcslen( *lpszValue ) + 1 ) * sizeof( TCHAR );
            RegSetValueEx(hk, tag, 0, REG_EXPAND_SZ, (LPBYTE) *lpszValue, dwSize);
        }
        else
        {
            return (false);
        }
    }
    return ( true );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\proxystub\makefile.inc ===
#
# This is the MIDL compile phase of the build process.
#
# The following is where you put the name of your .idl file without
# the .idl extension:
#

IDL_NAME = TlntSvr

CLIENT_TARGETS =   $(O)\$(IDL_NAME)_p.c        \
                   $(O)\$(IDL_NAME).h

SERVER_TARGETS =   $(O)\$(IDL_NAME)_i.c \
                   $(O)\$(IDL_NAME).h

###EXTRN_DEPENDS =    .\$(IDL_NAME).acf

#
# MIDL COMPILE
#

$(SERVER_TARGETS) $(O)\dlldata.c : .\$(IDL_NAME).idl $(EXTRN_DEPENDS)
    midl /Oicf /robust /out $(O) /I $(SDK_INC_PATH) /h $(IDL_NAME).h /newtlb /dlldata dlldata.c /iid $(IDL_NAME)_i.c /proxy $(IDL_NAME)_p.c $(IDL_NAME).idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\common\tlntutils.h ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
#ifndef _MYUTIL_H
#define _MYUTIL_H

#include <winsock2.h>

#define MAX_ROWS 300
#define MAX_COLS 300

#define MAX_STRING_LENGTH 256
#define SUSPEND_THREAD_SUCCESS 0xFFFFFFFF

#define MAX_ATTEMPTS 200

#define INHERITABLE_NULL_DESCRIPTOR_ATTRIBUTE( sa ) \
    sa.nLength = sizeof( SECURITY_ATTRIBUTES ); \
    sa.bInheritHandle = TRUE; \
    sa.lpSecurityDescriptor = NULL;

enum{ READ_PIPE, WRITE_PIPE };

extern HANDLE g_hSyncCloseHandle;
extern PSID         administratorsSid, everyoneSid , localSystemSid ,localLocalSid ,localNetworkSid;

#define SETREGISTRYDW( constVal, keyHandle1, keyHandle2, keyName, val, size )\
    val = constVal ; \
    if( RegSetValueEx( keyHandle2, keyName, 0, REG_DWORD, (LPBYTE)&val, size \
                )  != ERROR_SUCCESS )  \
    {   \
        if(  keyHandle1 ) \
            RegCloseKey(  keyHandle1 ); \
        RegCloseKey(  keyHandle2 ); \
        LogEvent( EVENTLOG_ERROR_TYPE, MSG_REGISTRYKEY, keyName ); \
        return ( false );           \
    }\
        
#define SETREGISTRYSZ( keyHandle1, keyHandle2, keyName, val, size ) \
    if( RegSetValueEx( keyHandle2, keyName, 0, REG_SZ, val, size ) \
            != ERROR_SUCCESS )  \
    {   \
        if(  keyHandle1 ) \
            RegCloseKey(  keyHandle1 ); \
        RegCloseKey(  keyHandle2 ); \
        LogEvent( EVENTLOG_ERROR_TYPE, MSG_REGISTRYKEY, keyName ); \
        return ( false );           \
    }

bool IsThisMachineDC();
bool GetDomainHostedByThisMc( LPWSTR );
bool GetRegistryDW( HKEY, HKEY, LPTSTR, DWORD*, DWORD , BOOL);
bool GetRegistryString( HKEY, HKEY, LPTSTR, LPTSTR *, LPTSTR, BOOL );
bool ConvertSChartoWChar(char *, LPWSTR * );
bool ConvertSChartoWChar(char *, LPWSTR );
bool AllocateNExpandEnvStrings( LPWSTR, LPWSTR * );
bool AllocNCpyWStr(LPWSTR*, LPWSTR );
bool WriteToPipe( HANDLE, UCHAR, LPOVERLAPPED);
bool WriteToPipe( HANDLE, LPVOID, DWORD, LPOVERLAPPED);
bool StuffEscapeIACs( UCHAR bufDest[], UCHAR bufSrc[], DWORD* pdwSize );
void FillProcessStartupInfo( STARTUPINFO *, HANDLE, HANDLE, HANDLE, WCHAR *);
void LogToTlntsvrLog( HANDLE, WORD, DWORD, LPCTSTR* );
void GetErrMsgString( DWORD, LPTSTR * );
bool DecodeWSAErrorCodes( DWORD, ... );
bool DecodeSocketStartupErrorCodes( DWORD );
void LogEvent( WORD, DWORD , LPCTSTR, ... );
bool FinishIncompleteIo( HANDLE, LPOVERLAPPED, LPDWORD );
bool GetProductType ( LPWSTR * );
void LogFormattedGetLastError( WORD, DWORD, DWORD );
bool GetWindowsVersion( bool* );
void InitializeOverlappedStruct( LPOVERLAPPED );
bool CreateReadOrWritePipe ( LPHANDLE, LPHANDLE, SECURITY_DESCRIPTOR*, bool );
bool GetUniquePipeName ( LPTSTR pszPipeName, SECURITY_ATTRIBUTES *sa );
int SafeSetSocketOptions(SOCKET s);

extern "C" void    TlntCloseHandle(
            BOOL            synchronize,
            HANDLE          *handle_to_close
            );

#define TELNET_CLOSE_HANDLE(_Handle_) TlntCloseHandle(FALSE, &(_Handle_))

#define TELNET_SYNC_CLOSE_HANDLE(_Handle_) TlntCloseHandle(TRUE, &(_Handle_))

extern "C" bool TlntSynchronizeOn(
    HANDLE          object
    );
VOID TnFreeStandardSids(void);
BOOL TnInitializeStandardSids(void);
PSID TnGetAdministratorsSid(void);
PSID TnGetLocalSystemSid(void);
PSID TnGetLocalLocalSid(void);
PSID TnGetLocalNetworkSid(void);
PSID TnGetEveryoneSid(void);
HANDLE TnCreateFile(LPCTSTR lpFileName,
                     DWORD dwDesiredAccess,
                     DWORD dwSharedMode,
                     LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                     DWORD dwCreationDisposition,
                     DWORD dwFlagsAndAttributes,
                     HANDLE hTemplateFile
                     );
HANDLE TnCreateFileEx(LPCTSTR lpFileName,
                     DWORD dwDesiredAccess,
                     DWORD dwSharedMode,
                     LPSECURITY_ATTRIBUTES *lplpSecurityAttributes,
                     DWORD dwCreationDisposition,
                     DWORD dwFlagsAndAttributes,
                     HANDLE hTemplateFile
                     );

BOOL TnCreateDirectory(LPCTSTR lpPathName,
                     LPSECURITY_ATTRIBUTES lpSecurityAttributes 
                     );

BOOL TnCreateDirectoryEx(LPCTSTR lpPathName,
                     LPSECURITY_ATTRIBUTES *lplpSecurityAttributes
                     );
HANDLE TnCreateMutex(LPSECURITY_ATTRIBUTES lpSecurityAttributes, 
                     BOOL bInitialOwner, 
                     LPCTSTR lpName 
                     );

HANDLE TnCreateMutexEx (LPSECURITY_ATTRIBUTES *lplpSecurityAttributes, 
                     BOOL bInitialOwner, 
                     LPCTSTR lpName 
                     );

BOOL TnCreateDefaultSecurityAttributes(LPSECURITY_ATTRIBUTES *lplpSecurityAttributes );
VOID TnFreeSecurityAttributes(LPSECURITY_ATTRIBUTES *lplpSecurityAttributes);
BOOL TnCreateDefaultSecDesc ( PSECURITY_DESCRIPTOR *pSecDesc,   DWORD EveryoneAccessMask );
LONG TnSecureRegCreateKeyEx(
  HKEY hKey,                                  // handle to open key
  LPCTSTR lpSubKey,                           // subkey name
  DWORD Reserved,                             // reserved
  LPTSTR lpClass,                             // class string
  DWORD dwOptions,                            // special options
  REGSAM samDesired,                          // desired security access
  LPSECURITY_ATTRIBUTES lpSecurityAttributes, // inheritance
  PHKEY phkResult,                            // key handle 
  LPDWORD lpdwDisposition,                  // disposition value buffer
  DWORD EveryoneAccessMask
 );


#endif //_MYUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsess\fsm.cpp ===
// FSM.cpp : This file contains the Finite State Machine ...
// Created:  Feb '98
// Author : a-rakeba
// History:
// Copyright (C) 1998 Microsoft Corporation
// All rights reserved.
// Microsoft Confidential 

#include "telnet.h"
#include "FSM.h"
#include "RFCProto.h"


FSM_TRANSITION telnetTransTable[] = {
    //  State       Input       Next State      Action
    //  -----       -----       ----------      ------
    {   TS_DATA,    TC_IAC,     TS_IAC,         &CRFCProtocol::NoOp   },
    {   TS_DATA,    TC_ANY,     TS_DATA,        &CRFCProtocol::PutBack},
    {   TS_IAC,     TC_IAC,     TS_DATA,        &CRFCProtocol::PutBack},
    {   TS_IAC,     TC_SB,      TS_SUBNEG,      &CRFCProtocol::NoOp   },

// Telnet Commands
    {   TS_IAC,     TC_NOP,     TS_DATA,        &CRFCProtocol::NoOp    },
    {   TS_IAC,     TC_DM,      TS_DATA,        &CRFCProtocol::DataMark},
    {   TS_IAC,     TC_GA,      TS_DATA,        &CRFCProtocol::GoAhead },
    {   TS_IAC,     TC_EL,      TS_DATA,        &CRFCProtocol::EraseLine},
    {   TS_IAC,     TC_EC,      TS_DATA,        &CRFCProtocol::EraseChar},
    {   TS_IAC,     TC_AYT,     TS_DATA,        &CRFCProtocol::AreYouThere},
    {   TS_IAC,     TC_AO,      TS_DATA,        &CRFCProtocol::AbortOutput},
    {   TS_IAC,     TC_IP,      TS_DATA,        &CRFCProtocol::InterruptProcess},
    {   TS_IAC,     TC_BREAK,   TS_DATA,        &CRFCProtocol::Break},

// Option Negotiation
    {   TS_IAC,     TC_WILL,    TS_WOPT,        &CRFCProtocol::RecordOption},
    {   TS_IAC,     TC_WONT,    TS_WOPT,        &CRFCProtocol::RecordOption},
    {   TS_IAC,     TC_DO,      TS_DOPT,        &CRFCProtocol::RecordOption},
    {   TS_IAC,     TC_DONT,    TS_DOPT,        &CRFCProtocol::RecordOption},
    {   TS_IAC,     TC_ANY,     TS_DATA,        &CRFCProtocol::NoOp   },

// Option Subnegotiation
    {   TS_SUBNEG,  TC_IAC,     TS_SUBIAC,      &CRFCProtocol::NoOp   },
    {   TS_SUBNEG,  TC_ANY,     TS_SUBNEG,      &CRFCProtocol::SubOption},
    {   TS_SUBIAC,  TC_SE,      TS_DATA,        &CRFCProtocol::SubEnd  },
    {   TS_SUBIAC,  TC_ANY,     TS_SUBNEG,      &CRFCProtocol::SubOption},

    {   TS_WOPT,    TO_ECHO,    TS_DATA,        &CRFCProtocol::DoEcho  },
    {   TS_WOPT,    TO_NAWS,    TS_DATA,        &CRFCProtocol::DoNaws  },
    {   TS_WOPT,    TO_SGA,     TS_DATA,        &CRFCProtocol::DoSuppressGA},
    {   TS_WOPT,    TO_TXBINARY,TS_DATA,        &CRFCProtocol::DoTxBinary},
    {   TS_WOPT,    TO_TERMTYPE,TS_DATA,        &CRFCProtocol::DoTermType},
    {   TS_WOPT,    TO_AUTH,    TS_DATA,        &CRFCProtocol::DoAuthentication},
    {   TS_WOPT, TO_NEW_ENVIRON,TS_DATA,        &CRFCProtocol::DoNewEnviron},
    {   TS_WOPT,    TC_ANY,     TS_DATA,        &CRFCProtocol::DoNotSup},

    {   TS_DOPT,    TO_TXBINARY,TS_DATA,        &CRFCProtocol::WillTxBinary},
    {   TS_DOPT,    TO_SGA,     TS_DATA,        &CRFCProtocol::WillSuppressGA},
    {   TS_DOPT,    TO_ECHO,    TS_DATA,        &CRFCProtocol::WillEcho},
    {   TS_DOPT,    TC_ANY,     TS_DATA,        &CRFCProtocol::WillNotSup},

    {   FS_INVALID, TC_ANY,     FS_INVALID,     &CRFCProtocol::Abort},
};


#define NUM_TRANSITIONS (sizeof(telnetTransTable)/sizeof(telnetTransTable[0]))


FSM_TRANSITION subNegTransTable[] = {
    //  State       Input       Next State      Action
    //  -----       -----       ----------      ------
    {   SS_START,   TO_TERMTYPE,SS_TERMTYPE,    &CRFCProtocol::NoOp   },
    {   SS_START,   TO_AUTH,    SS_AUTH1,       &CRFCProtocol::NoOp   },
    {   SS_START,   TO_NAWS,    SS_NAWS,       &CRFCProtocol::NoOp    },
    {   SS_START,   TO_NEW_ENVIRON, SS_NEW_ENVIRON1, &CRFCProtocol::NoOp },
    {   SS_START,   TC_ANY,     SS_END_FAIL,    &CRFCProtocol::NoOp   },
    
    {   SS_NAWS,    TC_ANY,     SS_NAWS,        &CRFCProtocol::SubNaws},

    {   SS_TERMTYPE,TT_IS,      SS_END_SUCC,    &CRFCProtocol::NoOp   },
    {   SS_TERMTYPE,TC_ANY,     SS_END_FAIL,    &CRFCProtocol::NoOp   },

    {   SS_NEW_ENVIRON1,IS,     SS_NEW_ENVIRON2,&CRFCProtocol::SubNewEnvShowLoginPrompt },
    {   SS_NEW_ENVIRON1,INFO,   SS_NEW_ENVIRON2,&CRFCProtocol::NoOp   },
    {   SS_NEW_ENVIRON1,TC_ANY, SS_END_FAIL,    &CRFCProtocol::NoOp   },

    {   SS_NEW_ENVIRON2,VAR,    SS_NEW_ENVIRON3,&CRFCProtocol::NoOp},
    {   SS_NEW_ENVIRON2,USERVAR,SS_NEW_ENVIRON3,&CRFCProtocol::NoOp},    
    {   SS_NEW_ENVIRON2,TC_ANY, SS_END_FAIL,    &CRFCProtocol::NoOp},

    {   SS_NEW_ENVIRON3,VAR,    SS_NEW_ENVIRON3,&CRFCProtocol::NoOp }, 
    {   SS_NEW_ENVIRON3,USERVAR,SS_NEW_ENVIRON3,&CRFCProtocol::NoOp },
    {   SS_NEW_ENVIRON3,VALUE,  SS_NEW_ENVIRON3,&CRFCProtocol::NoOp },
    {   SS_NEW_ENVIRON3,ENV_ESC,SS_NEW_ENVIRON5,&CRFCProtocol::NoOp },
    {   SS_NEW_ENVIRON3,TC_ANY, SS_NEW_ENVIRON4,&CRFCProtocol::SubNewEnvGetString},
    
    {   SS_NEW_ENVIRON4,VAR,    SS_NEW_ENVIRON3,&CRFCProtocol::SubNewEnvGetValue},
    {   SS_NEW_ENVIRON4,USERVAR,SS_NEW_ENVIRON3,&CRFCProtocol::SubNewEnvGetValue},
    {   SS_NEW_ENVIRON4,VALUE,  SS_NEW_ENVIRON3,&CRFCProtocol::SubNewEnvGetVariable},
    {   SS_NEW_ENVIRON4,ENV_ESC,SS_NEW_ENVIRON5,&CRFCProtocol::NoOp},
    {   SS_NEW_ENVIRON4,TC_ANY, SS_NEW_ENVIRON4,&CRFCProtocol::SubNewEnvGetString},
    
    {   SS_NEW_ENVIRON5,TC_ANY, SS_NEW_ENVIRON4,&CRFCProtocol::SubNewEnvGetString},

    {   SS_AUTH1,   AU_IS,      SS_AUTH2,       &CRFCProtocol::NoOp   },
    {   SS_AUTH1,   TC_ANY,     SS_END_FAIL,    &CRFCProtocol::NoOp   },

    {   SS_AUTH2,   TC_ANY,     SS_AUTH2,       &CRFCProtocol::SubAuth},

    {   SS_END_FAIL,TC_ANY,     SS_END_FAIL,    &CRFCProtocol::NoOp   },
    {   SS_END_SUCC,TC_ANY,     SS_END_SUCC,    &CRFCProtocol::SubTermType},
    {   FS_INVALID, TC_ANY,     FS_INVALID,     &CRFCProtocol::Abort   },
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsess\libfuncs.h ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
//This file contains the gloabal declarations for functions pointers to 
//many of userenv.lib functions and other dependent functions. These pointers
//are intiated when the service starts up and the libraries are freed 
//when the service is shut down.

#ifndef _LIBFUNCS_
#define _LIBFUNCS_

#include <CmnHdr.h>
#include <TChar.h>
#include <WinBase.h>
#include <UserEnv.h>
#include <DsGetDc.h>

typedef
DWORD
WINAPI
GETDCNAME ( LPCTSTR, LPCTSTR, GUID *, LPCTSTR, ULONG,
            PDOMAIN_CONTROLLER_INFO * );
typedef
BOOL
WINAPI
LOADUSERPROFILE ( HANDLE, LPPROFILEINFO );

typedef
BOOL
WINAPI
UNLOADUSERPROFILE ( HANDLE, HANDLE );

typedef
BOOL
WINAPI
CREATEENVIRONMENTBLOCK ( LPVOID *, HANDLE, BOOL );

typedef
BOOL
WINAPI
DESTROYENVIRONMENTBLOCK ( LPVOID );

typedef
BOOL
WINAPI
GETUSERPROFILEDIRECTORY ( HANDLE, LPTSTR, LPDWORD );

typedef
BOOL
WINAPI
GETDEFAULTUSERPROFILEDIRECTORY ( LPTSTR, LPDWORD );

//Gloabal variables for library functions
LOADUSERPROFILE                 *fnP_LoadUserProfile                = NULL;
UNLOADUSERPROFILE               *fnP_UnloadUserProfile              = NULL;
GETDCNAME                       *fnP_DsGetDcName                    = NULL;
CREATEENVIRONMENTBLOCK          *fnP_CreateEnvironmentBlock         = NULL;
DESTROYENVIRONMENTBLOCK         *fnP_DestroyEnvironmentBlock        = NULL;
GETUSERPROFILEDIRECTORY         *fnP_GetUserProfileDirectory        = NULL;
GETDEFAULTUSERPROFILEDIRECTORY  *fnP_GetDefaultUserProfileDirectory = NULL;

#endif //_LIBFUNCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsess\rfcproto.h ===
// RFCProto.h : This file contains the
// Created:  Feb '98
// Author : a-rakeba
// History:
// Copyright (C) 1998 Microsoft Corporation
// All rights reserved.
// Microsoft Confidential 

#if !defined( _RFCPROTO_H_ )
#define _RFCPROTO_H_

#include <cmnhdr.h>

#include <windows.h>

#include <vtnt.h>
#include <IoHandlr.h>

#define NUM_TS_STATES 6
#define NUM_CHARS 256
#define NUM_SS_STATES 12
#define VERSION1 "1"
#define VERSION2 "2"
#define STREAM   "stream"
#define CONSOLE  "console"

#define T_INVALID   0xFF    // an invalid transition index

enum {  E_UNDEFINED, E_DEFINED_BUT_NONE };
enum {  E_UNKNOWN, E_USER, E_SFUTLNTVER, E_SFUTLNTMODE };

class CSession;

struct CRFCProtocol {

    friend class CIoHandler;

    UCHAR m_telnetFSM[ NUM_TS_STATES ][ NUM_CHARS ];
    INT   m_telnetState;

    UCHAR m_subNegFSM[ NUM_SS_STATES ][ NUM_CHARS ];
    INT   m_subNegState;

    DWORD m_dwExcludeTerm;
    
    bool m_fPasswordConcealMode;

    bool m_fWaitingForResponseToA_DO_ForTO_ECHO;
    bool m_fWaitingForAResponseToA_WILL_ForTO_ECHO;

    bool m_fWaitingForAResponseToA_DO_ForTO_AUTH;

    bool m_fWaitingForResponseToA_DO_ForTO_NAWS;

    bool m_fWaitingForResponseToA_DO_ForTO_SGA;
    bool m_fWaitingForAResponseToA_WILL_ForTO_SGA;
    
    bool m_fWaitingForResponseToA_DO_ForTO_TXBINARY;
    bool m_fWaitingForAResponseToA_WILL_ForTO_TXBINARY;
    
    bool m_fWaitingForResponseToA_DO_ForTO_TERMTYPE;

    bool m_fWaitingForResponseToA_DO_ForTO_NEWENVIRON;

    CRFCProtocol();
    virtual ~CRFCProtocol();
    
    void Init( CSession * );
    
    bool InitialNegotiation(); 
    void ChangeCurrentTerm();
    void DisAllowVtnt( PUCHAR * );

    void BuildFSMs( void );
    //void FSMInit( UCHAR fSM[][ NUM_CHARS ], FSM_TRANSITION transTable[], 
	void FSMInit( UCHAR fSM[][ NUM_CHARS ], void* transTable, 
            INT numStates );

    CIoHandler::IO_OPERATIONS ProcessDataReceivedOnSocket( LPDWORD lpdwIoSize );
    bool StrToVTNTResponse( LPSTR, DWORD, VOID**, DWORD* );
    void FillVtntHeader( UCHAR*, WORD, WORD, WORD, WORD, WORD, SHORT*, LPTSTR, DWORD );

    void NoOp( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void GoAhead( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void EraseLine( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void EraseChar( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void AreYouThere( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void AbortOutput( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void InterruptProcess( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void Break( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void PutBack( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void RecordOption( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );

    void WillNotSup( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void DoNotSup( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void DoEcho( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void DoNaws( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void DoSuppressGA( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void DoTxBinary( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void DoTermType( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void AskForSendingTermType( PUCHAR* pBuffer );
    void DoAuthentication( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void DoNewEnviron( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );    
    void AskForSendingNewEnviron( PUCHAR* pBuffer );

    //void WillTermType( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void WillTxBinary( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void WillSuppressGA( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void WillEcho( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void WillNTLM( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    
    void SubOption( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void SubTermType( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void SubNaws( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void SubAuth( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void SubEnd( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void DataMark( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void Abort( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void SubNewEnvShowLoginPrompt( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void SubNewEnvGetValue( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void SubNewEnvGetVariable( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void SubNewEnvGetString( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );
    void FindVariable();
    

private:

    bool fSubTermType;
    CHAR m_szPrevTermType[ MAX_PATH + 1 ];
    CHAR m_szCurrentEnvVariable[ MAX_PATH + 1 ];
    bool  m_bIsUserNameProvided;
    bool  m_fSubNewEnv;
    DWORD m_dwWhichVar;
    DWORD m_dwWhatVal;

    bool fSubNaws;
    bool m_fSubNawsFirstTime;
    DWORD m_dwSubNawsByteNumber;

    bool fSubAuth;
    CHAR m_NTLMDataBuffer[ 2048 ];
    WORD m_wNTLMDataBufferIndex;

    BYTE m_optionCmd;
    BYTE m_remoteOptions[ 256 ];
    BYTE m_localOptions[ 256 ];

    CSession *m_pSession;

    CRFCProtocol( const CRFCProtocol& );
    CRFCProtocol& operator=( const CRFCProtocol& );
};

#endif // _RFCPROTO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsess\rfcproto.cpp ===
// RFCProto.cpp : This file contains the
// Created:  Feb '98
// Author : a-rakeba
// History:
// Copyright (C) 1998 Microsoft Corporation
// All rights reserved.
// Microsoft Confidential

#include <CmnHdr.h>
#ifdef WHISTLER_BUILD
#include "ntverp.h"
#else
#include <SolarVer.h>
#endif //WHISTLER_BUILD
#include <Common.ver>
#include <RFCProto.h>
#include <Debug.h>
#include <FSM.h>
#include <TelnetD.h>
#include <Session.h>
#include <Scraper.h>
#include <vtnt.h>

#pragma warning( disable: 4242 )
#pragma warning( disable: 4127 )
#pragma warning(disable: 4100)
#pragma warning(disable: 4244)

extern FSM_TRANSITION telnetTransTable[];
extern FSM_TRANSITION subNegTransTable[];

using namespace _Utils;
using CDebugLevel::TRACE_DEBUGGING;
using CDebugLevel::TRACE_HANDLE;
using CDebugLevel::TRACE_SOCKET;

COORD g_coCurPosOnClient  = { 0, 3 };

CRFCProtocol::CRFCProtocol()
{
    fSubTermType = false;
    m_dwSubNawsByteNumber = 0;
    fSubAuth = false;
    m_wNTLMDataBufferIndex = 0;
    fSubNaws = false;
    m_fSubNawsFirstTime = true;
    
    m_dwExcludeTerm = 0;
    m_pSession = 0;

    SfuZeroMemory( m_remoteOptions, sizeof( m_remoteOptions ) );
    SfuZeroMemory( m_localOptions, sizeof( m_localOptions ) );

    m_fPasswordConcealMode = false;

    //optionCmd = ?
    //m_telnetState = ?
    //m_subNegState = ?

    m_fWaitingForResponseToA_DO_ForTO_ECHO = false;
    m_fWaitingForAResponseToA_WILL_ForTO_ECHO = false;;
    
    m_fWaitingForResponseToA_DO_ForTO_SGA = false;
    m_fWaitingForAResponseToA_WILL_ForTO_SGA = false;
    
    m_fWaitingForResponseToA_DO_ForTO_TXBINARY = false;
    m_fWaitingForAResponseToA_WILL_ForTO_TXBINARY = false;

    m_fWaitingForResponseToA_DO_ForTO_TERMTYPE = false;

    m_fWaitingForAResponseToA_DO_ForTO_AUTH = false;

    m_fWaitingForResponseToA_DO_ForTO_NAWS = false;

    m_bIsUserNameProvided  = false;
    m_fSubNewEnv = false;
    m_dwWhatVal  = E_UNDEFINED;
    m_dwWhichVar = E_UNKNOWN;
    m_szCurrentEnvVariable[0] = 0;
    m_fWaitingForResponseToA_DO_ForTO_NEWENVIRON = false;

    BuildFSMs();
}


CRFCProtocol::~CRFCProtocol()
{

}


void 
CRFCProtocol::Init ( CSession* pSession )
{
    _chASSERT( pSession != 0 );
    m_pSession = pSession;
}


bool 
CRFCProtocol::InitialNegotiation
(
)
{
    UCHAR  puchBuffer[1024];
    PUCHAR pCursor;
    INT     bytes_to_write;

    pCursor = puchBuffer;

    m_pSession->CIoHandler::m_SocketControlState = CIoHandler::STATE_INIT;

    if( m_pSession->m_dwNTLMSetting != NO_NTLM )
    {
        // this is actually the place where we need to figure out if we can do
        // authentication and what kind.  If there atleast one authentication type
        // available then we send the DO AUTH option to the client else we don't.
        // For now this checks for only NTLM auth.  has to be made more generic in V2.
        if ( m_pSession->StartNTLMAuth() )
        {
            m_fWaitingForAResponseToA_DO_ForTO_AUTH = true;

            DO_OPTION( pCursor, TO_AUTH );
            pCursor += 3;
        }
        else
        {
            // since we don't have any security package the registry setting is 
            //meaningless, we should just fall back to the username/password.
            m_pSession->m_dwNTLMSetting = NO_NTLM;
        }
    }
    
    m_fWaitingForAResponseToA_WILL_ForTO_ECHO = true;

    WILL_OPTION( pCursor, TO_ECHO );
    pCursor += 3;


    m_fWaitingForAResponseToA_WILL_ForTO_SGA  = true;
    
    WILL_OPTION( pCursor, TO_SGA );
    pCursor += 3;

    m_fWaitingForResponseToA_DO_ForTO_NEWENVIRON = true;
    
    DO_OPTION( pCursor, TO_NEW_ENVIRON );
    pCursor += 3;

    m_fWaitingForResponseToA_DO_ForTO_NAWS = true;
    
    DO_OPTION( pCursor, TO_NAWS );
    pCursor += 3;

    m_fWaitingForResponseToA_DO_ForTO_TXBINARY = true;

    DO_OPTION( pCursor, TO_TXBINARY );
    pCursor += 3;

    m_fWaitingForAResponseToA_WILL_ForTO_TXBINARY = true;
    WILL_OPTION( pCursor, TO_TXBINARY );
    pCursor += 3;

	if( NO_NTLM == m_pSession->m_dwNTLMSetting )
	{
        m_pSession->CIoHandler::m_SocketControlState = CIoHandler::STATE_BANNER_FOR_AUTH;
    }

    //This is before we start writing anything on to the socket asyncronously.
    //So, writing to m_WriteToSocketBuff does not cause problem
    bytes_to_write = (INT) (pCursor - puchBuffer);

    if (bytes_to_write && 
        ((m_pSession->CIoHandler::m_dwWriteToSocketIoLength + bytes_to_write) < MAX_WRITE_SOCKET_BUFFER))
    {
        memcpy( m_pSession->CIoHandler::m_WriteToSocketBuff, puchBuffer, bytes_to_write);

        m_pSession->CIoHandler::m_dwWriteToSocketIoLength += bytes_to_write;

        return ( true );
    }

    return ( false );
}


// have to keep updating m_WriteToSocketBuffer while in Action() functions
// have to set the IO response to WRITE_TO_SOCKET and somehow convey this
// have to keep updating pButBack
// have to finally update the lpdwIoSize

CIoHandler::IO_OPERATIONS 
CRFCProtocol::ProcessDataReceivedOnSocket
( 
    LPDWORD lpdwIoSize 
)
{

#define TWO_K 2048

    CIoHandler::IO_OPERATIONS ioOpsToPerform = 0;

    LPBYTE pByte;
    LPBYTE pPutBack = m_pSession->CIoHandler::m_pReadFromSocketBufferCursor;

    DWORD dwLength = *lpdwIoSize;

    UCHAR szMsgBuf[TWO_K];
    UCHAR* p = szMsgBuf;
    szMsgBuf[0] = 0;
    
    INT tableIndex;

    for( pByte = m_pSession->CIoHandler::m_pReadFromSocketBufferCursor;
       pByte<(m_pSession->CIoHandler::m_pReadFromSocketBufferCursor + dwLength);
       ++pByte )
    {
       tableIndex = m_telnetFSM[ m_telnetState ][ *pByte ];
       if( (p - szMsgBuf) > TWO_K )
       {
           _TRACE( TRACE_DEBUGGING, "too much data; possible suspicious activity" );
            _chASSERT( 0 );
       }
       else
       {
           (this->*(telnetTransTable[ tableIndex ].pmfnAction))(&pPutBack,&p,*pByte);
       }
       m_telnetState = telnetTransTable[ tableIndex ].uchNextState;
    }

    DWORD dwMsgLen = p - szMsgBuf; 
    if( dwMsgLen > 0 )
    {
        if (dwMsgLen > TWO_K) 
        {
            dwMsgLen = TWO_K;
        }

        m_pSession->CIoHandler::WriteToSocket( szMsgBuf, dwMsgLen);
    
        ioOpsToPerform |= CIoHandler::WRITE_TO_SOCKET;
    }

    *lpdwIoSize = pPutBack - m_pSession->CIoHandler::m_pReadFromSocketBufferCursor;

    return ( ioOpsToPerform ); 

#undef TWO_K
}


void CRFCProtocol::BuildFSMs( void )
{
    
    FSMInit( m_telnetFSM, telnetTransTable, NUM_TS_STATES );
    m_telnetState = TS_DATA;

    FSMInit( m_subNegFSM, subNegTransTable, NUM_SS_STATES );
    m_subNegState = SS_START;
}


void 
CRFCProtocol::FSMInit
( 
    UCHAR fSM[][ NUM_CHARS ],      
	void* transTable1, 
    INT numStates 
)
{
	FSM_TRANSITION* transTable = (FSM_TRANSITION*)transTable1;
    INT s, tableIndex, c;

    for( c = 0; c < NUM_CHARS; ++c)
    {
        for( tableIndex = 0; tableIndex < numStates; ++tableIndex ) 
        {
            fSM[ tableIndex ][ c ] = T_INVALID;
        }
    }


    for( tableIndex = 0; transTable[ tableIndex ].uchCurrState != FS_INVALID; 
        ++tableIndex )
    {
        s = transTable[ tableIndex ].uchCurrState;
        if( transTable[ tableIndex ].wInputChar == TC_ANY )
        {
            for( c = 0; c < NUM_CHARS; ++c )
            {
                if( fSM[ s ][ c ] == T_INVALID )
                {
                    fSM[ s ][ c ] = tableIndex;
                }
            }
        }
        else
        {
            fSM[ s ][ transTable[ tableIndex ].wInputChar ] = tableIndex;
        }
    }


    for( c = 0; c < NUM_CHARS; ++c)
    {
        for( tableIndex = 0; tableIndex < numStates; ++tableIndex ) 
        {
            if( fSM[ tableIndex ][ c ] == T_INVALID )
            {
                fSM[ tableIndex ][ c ] = 32;//tableIndex;
            }
        }
    }

}


void CRFCProtocol::NoOp( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
    _TRACE( TRACE_DEBUGGING, "NoOp()" );
}

void CRFCProtocol::GoAhead( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
    _TRACE( TRACE_DEBUGGING, "GoAhead()" );
}

void CRFCProtocol::EraseLine( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
    _TRACE( TRACE_DEBUGGING, "EraseLine()" );
}

void CRFCProtocol::EraseChar( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
    _TRACE( TRACE_DEBUGGING, "EraseChar()" );
}

#define INCREMENT_ROWS( rows, inc ) \
        { \
            rows += inc; \
            if( rows >= m_pSession->CSession::m_wRows ) \
            { \
                rows = m_pSession->CSession::m_wRows - 1;\
                wTypeOfCoords       = RELATIVE_COORDS;\
            }\
        }

#define INCREMENT_COLS( cols, inc ) \
        { \
            cols += inc;\
            if( cols >= m_pSession->CSession::m_wCols ) \
            {\
                cols = 0;\
            }\
        }

#define IGNORE_0x0A_FOLLOWING_0x0D( dwIndex, dwDataLen ) \
        if( dwIndex < dwDataLen && rgchSessionData[ dwIndex -1 ] == L'\r' && rgchSessionData[ dwIndex] == L'\n' ) \
        { \
            dwIndex++; \
        } 



void CRFCProtocol::FillVtntHeader( UCHAR *pucBlob, WORD wTypeOfCoords, 
                     WORD wNoOfRows, WORD wNoOfCols, 
                     WORD wCurrenRowOnClient, WORD wCurrenColOnClient, 
                     SHORT *psCurrentCol,
                     LPTSTR rgchSessionData, DWORD dwDataLen )
{

    if( !pucBlob )
    {
        return;
    }

    //Fill the header
    VTNT_CHAR_INFO* pVTNTCharInfo = ( VTNT_CHAR_INFO* ) pucBlob;
    //csbi.wAttributes is filled by v2 server with following meaning
    //When a scrolling case is detected, this is set to 1.
    pVTNTCharInfo->csbi.wAttributes = wTypeOfCoords;

    pVTNTCharInfo->coDest.X      = 0;
    pVTNTCharInfo->coDest.Y      = 0;

    pVTNTCharInfo->coSizeOfData.Y = wNoOfRows;
    pVTNTCharInfo->coSizeOfData.X = wNoOfCols;
    
    pVTNTCharInfo->srDestRegion.Left = wCurrenColOnClient;
    pVTNTCharInfo->srDestRegion.Top  = wCurrenRowOnClient;
    pVTNTCharInfo->srDestRegion.Right = pVTNTCharInfo->srDestRegion.Left + pVTNTCharInfo->coSizeOfData.X - 1;
    pVTNTCharInfo->srDestRegion.Bottom = wCurrenRowOnClient + pVTNTCharInfo->coSizeOfData.Y - 1;

    pVTNTCharInfo->coCursorPos.Y = pVTNTCharInfo->srDestRegion.Bottom;


    //Fill char info structs
	//iterate thru each character in the string
	//for each character store the corr. values in CHAR_INFO struct

	PCHAR_INFO pCharInfo = ( PCHAR_INFO )(pucBlob + sizeof( VTNT_CHAR_INFO ));
    DWORD dwIndex = 0;
    DWORD dwCtr = 0;
    DWORD dwSize = wNoOfRows * wNoOfCols;
    WORD  wLastNonSpaceCol = 0;

    while( dwCtr < dwSize )
    {
        if( dwIndex >= dwDataLen )
        {
            if( !wLastNonSpaceCol )
            {
                wLastNonSpaceCol = dwCtr;
            }

            pCharInfo[dwCtr].Char.UnicodeChar = L' ';
        }
        else
        {
            if( rgchSessionData[ dwIndex ] == L'\t' )
            {
                rgchSessionData[ dwIndex ] = L' ';
            }
            else if( rgchSessionData[ dwIndex ] == L'\r' )
            { 
                rgchSessionData[ dwIndex ] = L' ';
                while ( dwCtr < dwSize - 1 && ( ( dwCtr + 1 ) % wNoOfCols != 0 || dwCtr == 0 ) )
                {
                    pCharInfo[dwCtr].Char.UnicodeChar = L' ';
                    pCharInfo[dwCtr].Attributes = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
                    dwCtr++;
                }
           }
           else if( rgchSessionData[ dwIndex ] == L'\n' )
           {
               dwIndex++;
               continue;
           }

           pCharInfo[dwCtr].Char.UnicodeChar = rgchSessionData[ dwIndex ];
        }

        pCharInfo[dwCtr].Attributes = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;

        dwIndex++;
        dwCtr++;
    }

    if( !wLastNonSpaceCol )
    {
        wLastNonSpaceCol = dwCtr;
    }

    pVTNTCharInfo->coCursorPos.X = ( wCurrenColOnClient + wLastNonSpaceCol )  % m_pSession->CSession::m_wCols;
    if( psCurrentCol )
    {
        *psCurrentCol = pVTNTCharInfo->coCursorPos.X;
    }
}


//caller gets data blob and its size 
//this needs to sent to the client 
//caller needs to free memory

/*
The following routine is primarily used for stream mode and vtnt.
cmd outputs a stream of ascii chars. When in vtnt, the client expects VTNT_CHAR_INFO structs. 
The chars should be in the form of rectangles of console screen.
So, This routine does this conversion. For this,
1)We need to keep track of cursor position on client
2)Know For any given bloc of data whether to start on a new row on client or on the current row

We break the data from cmd into two rectangle.
1) rectagle on the current row of breadth 1 ( one row rectangle )
2) rectangle from next row onwards ( second rectangle )
*/

bool 
CRFCProtocol::StrToVTNTResponse
( 
    LPSTR  rgchData,
    DWORD  dwDataSize,
    VOID** ppResponse, 
    DWORD* pdwSize 
)
{
	_TRACE( TRACE_DEBUGGING, "StrToVTNTResponse()" );
    
    DWORD   dwIndex = 0;   
    COORD   coRectSize              = { m_pSession->CSession::m_wCols, 0 }; //size of the rectagular data 
    WORD    wNoOfColsOnCurrentRow   = 0;
    WORD    wSpacesInserted         = 0;
    LPTSTR  rgchSessionData         = 0;
    DWORD   dwDataLen               = 0;

    static  WORD  wTypeOfCoords     = ABSOLUTE_COORDS;

    if( rgchData == NULL || pdwSize == NULL || ppResponse == NULL )
    {
        return ( false );
    }

    dwDataLen = MultiByteToWideChar( GetConsoleCP(), 0, rgchData, dwDataSize, NULL, 0 );

    rgchSessionData = new WCHAR[ dwDataLen ];
    if( !rgchSessionData )
    {
        return false;
    }

    MultiByteToWideChar( GetConsoleCP(), 0, rgchData, dwDataSize, rgchSessionData, dwDataLen );


    //make one pass over the stream from cmd to find the amt of space needed to hold converted VTNT data
    dwIndex = 0;

    //Find number of chars on to the current row. ie; on the one row rectangle
    while( dwIndex < dwDataLen &&                                   //Size of data
           g_coCurPosOnClient.X + ( WORD )dwIndex < coRectSize.X &&   //In a single row on client
           rgchSessionData[ dwIndex ] != L'\r' &&                    //Not new line
           g_coCurPosOnClient.X !=0
         )
    {                
        dwIndex ++;
        IGNORE_0x0A_FOLLOWING_0x0D( dwIndex, dwDataLen );
    }

    wNoOfColsOnCurrentRow = dwIndex;
    if( g_coCurPosOnClient.X !=0 && rgchSessionData[ dwIndex ] == L'\r' )
    {
        dwIndex++;
        IGNORE_0x0A_FOLLOWING_0x0D( dwIndex, dwDataLen );
        wNoOfColsOnCurrentRow = coRectSize.X - g_coCurPosOnClient.X;
        wSpacesInserted       = wNoOfColsOnCurrentRow - ( dwIndex - 1 );
    }
    
    //Find the number of rows 
    while(  dwIndex < dwDataLen )
    {
        WORD wCol = 0;
        while( dwIndex + wCol < dwDataLen && 
               rgchSessionData[ dwIndex + wCol ] != L'\r' && 
               wCol < coRectSize.X )
        {
            wCol++;
        }
        
        dwIndex += wCol;
        dwIndex++;
        coRectSize.Y++;

        IGNORE_0x0A_FOLLOWING_0x0D( dwIndex, dwDataLen );
    }        

    int size = 0;

    if( wNoOfColsOnCurrentRow > 0 )
    {
        //size for one row rectangle
        size += sizeof( VTNT_CHAR_INFO ) + sizeof( CHAR_INFO ) * wNoOfColsOnCurrentRow;
    }

    if( coRectSize.Y > 0 )
    {
      //size for rest of rectangle
      size += sizeof( VTNT_CHAR_INFO ) + sizeof( CHAR_INFO ) * coRectSize.Y * coRectSize.X;
    }

    UCHAR* pucBlob = new UCHAR[ size ];
    UCHAR* pucBlobHead = pucBlob;
    
    if( !pucBlob )
    {
        _chASSERT( 0 );
        goto ExitOnError;
    }

    SfuZeroMemory( pucBlob, size );

    if( wNoOfColsOnCurrentRow > 0 )
    {
        //Fill one row rectangle
        FillVtntHeader( pucBlob, wTypeOfCoords, 
                        1, wNoOfColsOnCurrentRow, 
                        g_coCurPosOnClient.Y, g_coCurPosOnClient.X,
                        NULL,
                        rgchSessionData, wNoOfColsOnCurrentRow ); 

        INCREMENT_COLS( g_coCurPosOnClient.X, wNoOfColsOnCurrentRow );
        pucBlob += sizeof( VTNT_CHAR_INFO ) + sizeof( CHAR_INFO ) * wNoOfColsOnCurrentRow;
    }

    if( coRectSize.Y > 0  )
    {        
        //Fill second rectangle
        
        if( g_coCurPosOnClient.Y != 0 )
        {
            g_coCurPosOnClient.Y++;
        }

        FillVtntHeader( pucBlob, wTypeOfCoords, 
                        coRectSize.Y, coRectSize.X, 
                        g_coCurPosOnClient.Y, 0, 
                        &g_coCurPosOnClient.X,
                        rgchSessionData+wNoOfColsOnCurrentRow-wSpacesInserted, 
                        dwDataLen - ( wNoOfColsOnCurrentRow-wSpacesInserted ) );
         
        INCREMENT_ROWS( g_coCurPosOnClient.Y, coRectSize.Y - 1 );
    }

	*ppResponse = (VOID*) pucBlobHead;
    *pdwSize = size;
    
    delete[] rgchSessionData;
    return ( true );

ExitOnError:
    delete[] rgchSessionData;
    return ( false );
}

void CRFCProtocol::AreYouThere( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
    _TRACE( TRACE_DEBUGGING, "AreYouThere()" );

    if( !m_pSession->CSession::m_bIsStreamMode && 
        m_pSession->CIoHandler::m_SocketControlState == m_pSession->CIoHandler::STATE_SESSION )
    {
        m_pSession->CScraper::WriteMessageToCmd( L"\r\nYES\r\n" );
    }
    else
    {
        if( _strcmpi( VTNT, m_pSession->CSession::m_pszTermType ) == 0 )
        {
            DWORD dwSize = 0;
            PCHAR pResponse = NULL;
            if( !StrToVTNTResponse( " YES ", strlen( " YES " ), (VOID**) &pResponse, &dwSize ) )
            {   
                return; 
            }
            if( !pResponse || (dwSize == 0) )
            {
                return;
            }
            memcpy( *pBuffer, pResponse, dwSize ); // Don't know size of pBuffer, Baskar. Attack ?
            *pBuffer += dwSize;
            delete [] pResponse;                 
        }
        else
        {
            (*pBuffer)[0] = '\r';
            (*pBuffer)[1] = '\n';
            (*pBuffer)[2] = '[';
            (*pBuffer)[3] = 'Y';
            (*pBuffer)[4] = 'e';
            (*pBuffer)[5] = 's';
            (*pBuffer)[6] = ']';
            (*pBuffer)[7] = '\r';
            (*pBuffer)[8] = '\n';
            (*pBuffer)[9] = 0;

            *pBuffer += 9;
        }
    }
}

void CRFCProtocol::AbortOutput( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
    _TRACE( TRACE_DEBUGGING, "AbortOutput()" );
}

void CRFCProtocol::InterruptProcess( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b)
{
    _TRACE( TRACE_DEBUGGING, "InterruptProcess()" );
    _chVERIFY2( GenerateConsoleCtrlEvent( CTRL_C_EVENT, 0 ) );
}

void CRFCProtocol::Break( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
    _TRACE( TRACE_DEBUGGING, "Break()" );
    _chVERIFY2( GenerateConsoleCtrlEvent( CTRL_C_EVENT, 0 ) );
}

void CRFCProtocol::DataMark( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
    // basically a no op for now
    _TRACE( TRACE_DEBUGGING, "DataMark()" );
}


void CRFCProtocol::PutBack( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
    _TRACE( TRACE_DEBUGGING, "PutBack()" );
    *( *ppPutBack ) = b;
    (*ppPutBack)++;
}


void CRFCProtocol::RecordOption( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
    _TRACE( TRACE_DEBUGGING, "RecordOption()" );    
    m_optionCmd = b;
}


void CRFCProtocol::Abort( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
    // basically a no op for now
    _TRACE( TRACE_DEBUGGING, "Abort()" );
}



void CRFCProtocol::WillNotSup( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
    //DO, DONT logic
    _TRACE( TRACE_DEBUGGING, "WillNotSup() - %d ", b );    
    
    if( m_optionCmd == TC_DO )
    {
        if( m_localOptions[ b ] == ENABLED )
        {
        }
        else
        {
            PUCHAR p = *pBuffer;
            WONT_OPTION( p, b );
            *pBuffer += 3;
        }
    }
    else if( m_optionCmd == TC_DONT )
    {
        if( m_localOptions[ b ] == ENABLED )
        {
            m_localOptions[ b ] = DISABLED;
        }
        else
        {
        }
    }
}


void CRFCProtocol::DoNotSup( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
    //WILL, WONT logic
    _TRACE( TRACE_DEBUGGING, "DoNotSup() - %d ", b );    
    
    if( m_optionCmd == TC_WILL )
    {
        if( m_remoteOptions[ b ] == ENABLED )
        {
        }
        else
        {
            PUCHAR p = *pBuffer;
            DONT_OPTION( p, b );
            *pBuffer += 3;
        }
    }
    else if( m_optionCmd == TC_WONT )
    {
        if( m_remoteOptions[ b ] == ENABLED )
        {
            m_remoteOptions[ b ] = DISABLED;
        }
        else
        {
        }
    }

    return;
}


void CRFCProtocol::DoEcho( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
    //WILL, WONT logic
    _TRACE( TRACE_DEBUGGING, "DoEcho()" );

    if( m_optionCmd == TC_WILL )
    {
        if( m_remoteOptions[ b ] == ENABLED )
        {
        }
        else if( m_fWaitingForResponseToA_DO_ForTO_ECHO )
        {
            m_remoteOptions[ b ] = ENABLED;
            m_fWaitingForResponseToA_DO_ForTO_ECHO = false;
        }
        else
        {
            m_remoteOptions[ b ] = ENABLED;
            PUCHAR p = *pBuffer;
            DO_OPTION( p, b );
            *pBuffer += 3;
            m_fWaitingForResponseToA_DO_ForTO_ECHO = true;
        }
    }
    else if( m_optionCmd == TC_WONT )
    {
        if( m_fWaitingForResponseToA_DO_ForTO_ECHO )
        {
            m_fWaitingForResponseToA_DO_ForTO_ECHO = false;
        }
        else if( m_remoteOptions[ b ] == ENABLED )
        {
            m_remoteOptions[ b ] = DISABLED;
        }
        else
        {
        }
    }

    return;
}


void CRFCProtocol::DoNaws( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
    //WILL, WONT logic
    _TRACE( TRACE_DEBUGGING, "DoNaws()" );

    if( m_optionCmd == TC_WILL )
    {
        if( m_remoteOptions[ b ] == ENABLED )
        {
        }
        else if( m_fWaitingForResponseToA_DO_ForTO_NAWS )
        {
            m_remoteOptions[ b ] = ENABLED;
            m_fWaitingForResponseToA_DO_ForTO_NAWS = false;
        }
        else
        {
            PUCHAR p = *pBuffer;
            DO_OPTION( p, b );
            *pBuffer += 3;
            m_fWaitingForResponseToA_DO_ForTO_NAWS = true;
            m_remoteOptions[ b ] = ENABLED;
        }
    }
    else if( m_optionCmd == TC_WONT )
    {
        if( m_fWaitingForResponseToA_DO_ForTO_NAWS )
        {
            m_fWaitingForResponseToA_DO_ForTO_NAWS = false;
        }
        else if( m_remoteOptions[ b ] == ENABLED )
        {
            m_remoteOptions[ b ] = DISABLED;
        }
        else
        {
        }
    }
    return;
}

void CRFCProtocol::DoSuppressGA( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
    //WILL, WONT logic
    _TRACE( TRACE_DEBUGGING, "DoSuppressGA()" );

    if( m_optionCmd == TC_WILL )
    {
        if( m_remoteOptions[ b ] == ENABLED )
        {
        }
        else if( m_fWaitingForResponseToA_DO_ForTO_SGA )
        {
            m_remoteOptions[ b ]  = ENABLED;
            m_fWaitingForResponseToA_DO_ForTO_SGA = false;
        }
        else
        {
            m_remoteOptions[ b ]  = ENABLED;
            PUCHAR p = *pBuffer;
            DO_OPTION( p, b );
            *pBuffer += 3;
            m_fWaitingForResponseToA_DO_ForTO_SGA = true;
        }
    }
    else if( m_optionCmd == TC_WONT )
    {
        if( m_fWaitingForResponseToA_DO_ForTO_SGA )
        {
            m_fWaitingForResponseToA_DO_ForTO_SGA = false;
        }
        else if( m_remoteOptions[ b ] == ENABLED )
        {
            m_remoteOptions[ b ] = DISABLED;
        }
        else
        {
        }
    }
}


void CRFCProtocol::DoTxBinary( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
    //WILL, WONT logic
    _TRACE( TRACE_DEBUGGING, "DoTxBinary()" );    

    if( m_optionCmd == TC_WILL )
    {
        if( m_remoteOptions[ b ] == ENABLED )
        {
        }
        else if( m_fWaitingForResponseToA_DO_ForTO_TXBINARY )
        {
            m_remoteOptions[ b ]  = ENABLED;
            m_fWaitingForResponseToA_DO_ForTO_TXBINARY = false;
        }
        else
        {
            m_remoteOptions[ b ]  = ENABLED;
            PUCHAR p = *pBuffer;
            DO_OPTION( p, b );
            *pBuffer += 3;
            m_fWaitingForResponseToA_DO_ForTO_TXBINARY = true;
        }
    }
    else if( m_optionCmd == TC_WONT )
    {
        if( m_fWaitingForResponseToA_DO_ForTO_TXBINARY )
        {
            m_fWaitingForResponseToA_DO_ForTO_TXBINARY = false;
        }
        else if( m_remoteOptions[ b ] == ENABLED )
        {
            m_remoteOptions[ b ] = DISABLED;
        }
        else
        {
        }
        DisAllowVtnt( pBuffer );
    }
}

void CRFCProtocol::AskForSendingNewEnviron( PUCHAR* pBuffer )
{
    if( m_remoteOptions[ TO_NEW_ENVIRON ] == ENABLED )
    {
        DWORD dwLen = 0;
        //dwLen will be incremented by the macro and will leave 
        //it with exact number of bytes used
        DO_NEW_ENVIRON_SUB_NE( (*pBuffer ), TO_NEW_ENVIRON, dwLen );
        *pBuffer += dwLen; 

        //This is broken into 2 sub negos for supporting linux.
        //When we ask, user, sfutlntvar, sfutlntmode variables in single shot, it
        // is not giving data about even user. So, ask in 2 phases.
        dwLen = 0;
        DO_NEW_ENVIRON_SUB_NE_MY_VARS( (*pBuffer ), TO_NEW_ENVIRON, dwLen );
        *pBuffer += dwLen; 
    }
}

void CRFCProtocol::AskForSendingTermType( PUCHAR* pBuffer )
{
    if( m_remoteOptions[ TO_TERMTYPE ] == ENABLED )
    {
        DO_TERMTYPE_SUB_NE( (*pBuffer ) );
        *pBuffer += 6; 
    }
}


void CRFCProtocol::DoNewEnviron( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
    //WILL, WONT logic
    _TRACE( TRACE_DEBUGGING, "DoNewEnviron()" );    

    if( m_optionCmd == TC_WILL )
    {
        if( m_remoteOptions[ b ] == ENABLED )
        {
        }
        else if( m_fWaitingForResponseToA_DO_ForTO_NEWENVIRON )
        {
            m_remoteOptions[ b ] = ENABLED;
            m_fWaitingForResponseToA_DO_ForTO_NEWENVIRON = false;

            AskForSendingNewEnviron( pBuffer );
        }
        else
        {
            // Some clients are pro active, they tell us that they WILL Terminal type.
            PUCHAR p = *pBuffer;
            DO_OPTION( p, b );
            *pBuffer += 3;
            m_fWaitingForResponseToA_DO_ForTO_NEWENVIRON = true;
            m_remoteOptions[ b ] = ENABLED;
        }
    }
    else if( m_optionCmd == TC_WONT )
    {
        //Give login prompt. No way of getting user name
        SubNewEnvShowLoginPrompt( ppPutBack, pBuffer, b );

        if( m_fWaitingForResponseToA_DO_ForTO_NEWENVIRON )
        {
            m_fWaitingForResponseToA_DO_ForTO_NEWENVIRON = false;
        }
        else if( m_remoteOptions[ b ] == ENABLED )
        {
            m_remoteOptions[ b ] = DISABLED;
        }
        else
        {
        }
    }
    return;
}

void CRFCProtocol::SubNewEnvShowLoginPrompt( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
    m_pSession->CIoHandler::m_bWaitForEnvOptionOver = true;
}

void CRFCProtocol::DoTermType( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
    //WILL, WONT logic
    _TRACE( TRACE_DEBUGGING, "DoTermType()" );    

    if( m_optionCmd == TC_WILL )
    {
        if( m_remoteOptions[ b ] == ENABLED )
        {
        }
        else if( m_fWaitingForResponseToA_DO_ForTO_TERMTYPE )
        {
            m_remoteOptions[ b ]  = ENABLED;
            m_fWaitingForResponseToA_DO_ForTO_TERMTYPE = false;

            AskForSendingTermType( pBuffer );
        }
        else
        {
            // Some clients are pro active, they tell us that they WILL Terminal type.
            PUCHAR p = *pBuffer;
            DO_OPTION( p, b );
            *pBuffer += 3;

            m_remoteOptions[ b ]  = ENABLED;
            m_fWaitingForResponseToA_DO_ForTO_TERMTYPE = false;
        }
    }
    else if( m_optionCmd == TC_WONT )
    {
        if( m_fWaitingForResponseToA_DO_ForTO_TERMTYPE )
        {
            m_fWaitingForResponseToA_DO_ForTO_TERMTYPE = false;

            // we default to vt100.
            strncpy( m_pSession->CSession::m_pszTermType, VT100, (sizeof(m_pSession->CSession::m_pszTermType) - 1));
            m_pSession->CSession::m_bIsStreamMode = true;//Set it to stream mode
            
            // set a flag to continue the telnet session
            m_pSession->CSession::m_bNegotiatedTermType = true;
        }
        else if( m_remoteOptions[ b ] == ENABLED )
        {
            m_remoteOptions[ b ] = DISABLED;
            // theoretically should never happen. because once this option
            // is enabled it should never be disabled.
            _chASSERT(0);
        }
        else
        {
        }
    }
}


void CRFCProtocol::DoAuthentication( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
    //WILL, WONT logic
    _TRACE( TRACE_DEBUGGING, "DoAuthentication()" );    

    if( m_optionCmd == TC_WILL )
    {
        if( m_remoteOptions[ b ] == ENABLED )
        {
        }
        else if( m_fWaitingForAResponseToA_DO_ForTO_AUTH )
        {
            m_remoteOptions[ b ]  = ENABLED;
            if ( m_pSession->CIoHandler::m_SocketControlState == CIoHandler::STATE_INIT )
            {
                m_pSession->CIoHandler::m_SocketControlState = CIoHandler::STATE_NTLMAUTH;              
            }
            
            PUCHAR p = *pBuffer;
            DO_AUTH_SUB_NE_NTLM(p);

            *pBuffer += 8;

            m_fWaitingForAResponseToA_DO_ForTO_AUTH = false;
        }
        else
        {
            //presently, this should not happen
        }
    }
    else if( m_optionCmd == TC_WONT )
    {
        if( m_fWaitingForAResponseToA_DO_ForTO_AUTH )
        {
            m_fWaitingForAResponseToA_DO_ForTO_AUTH = false;

            if( m_pSession->m_dwNTLMSetting == NTLM_ONLY )
            {
                char *p = (char *)*pBuffer;
                sprintf(p, "%s%s", NTLM_ONLY_STR, TERMINATE); // Don't know the size of pbuffer here -- Baskar, Attack ?
                *pBuffer += strlen(p);
                    
                m_pSession->CIoHandler::m_SocketControlState = CIoHandler::STATE_TERMINATE;
                m_pSession->CIoHandler::m_fShutDownAfterIO = true;
            }

            if ( m_pSession->CIoHandler::m_SocketControlState == CIoHandler::STATE_INIT )
            {
                m_pSession->CIoHandler::m_SocketControlState = CIoHandler::STATE_BANNER_FOR_AUTH;
            }

        }
        else if( m_remoteOptions[ b ] == ENABLED )
        {
            m_remoteOptions[ b ] = DISABLED;
            // theoretically should never happen. because once this option
            // is enabled it should never be disabled.  Since server initiates
            // the negotiation and currently our server never re-negotiates.
            _chASSERT(0);
        }
        else
        {
        }
    }
}

void CRFCProtocol::WillTxBinary( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
   // DO, DONT logic
    _TRACE( TRACE_DEBUGGING, "WillTxBinary()" );

    if( m_optionCmd == TC_DO )
    {
        if( m_localOptions[ b ] == ENABLED )
        {
        }
        else if( m_fWaitingForAResponseToA_WILL_ForTO_TXBINARY )
        {
            m_fWaitingForAResponseToA_WILL_ForTO_TXBINARY = false;
            m_localOptions[ b ] = ENABLED;
        }
        else
        {
            //I want to enable this option
            PUCHAR p = *pBuffer;
            WILL_OPTION( p, b );
            *pBuffer += 3;
                       
            m_localOptions[ b ] = ENABLED;
        }
    }
    else if( m_optionCmd == TC_DONT )
    {
        if( m_fWaitingForAResponseToA_WILL_ForTO_TXBINARY )
        {
            m_fWaitingForAResponseToA_WILL_ForTO_TXBINARY = false;
        }
        else if( m_localOptions[ b ] == ENABLED )
        {
            m_localOptions[ b ] = DISABLED;
        }
        else
        {
        }
        DisAllowVtnt( pBuffer );
    }
}

void CRFCProtocol::DisAllowVtnt( PUCHAR *pBuffer )
{
    //Bug:1003 - VTNT no BINARY mode
    //Check if Term type is VTNT. If so, renegotiate termtype.
    //Now that binary is nomore, VTNT is not an option. VTNT needs binary.
    if( !( m_dwExcludeTerm & TERMVTNT ) )
    {
        m_dwExcludeTerm = TERMVTNT;
        if( _strcmpi( m_pSession->CSession::m_pszTermType, VTNT ) == 0 )
        {
            //re negotiation of term type
            AskForSendingTermType( pBuffer );
        }
    }
}

void CRFCProtocol::WillSuppressGA( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
   // DO, DONT logic
    _TRACE( TRACE_DEBUGGING, "WillSuppressGA()" );

    if( m_optionCmd == TC_DO )
    {
        if( m_localOptions[ b ] == ENABLED )
        {
        }
        else if( m_fWaitingForAResponseToA_WILL_ForTO_SGA )
        {
            m_fWaitingForAResponseToA_WILL_ForTO_SGA = false;
            m_localOptions[ b ] = ENABLED;
        }
        else
        {
            //I want to enable this option
            PUCHAR p = *pBuffer;
            WILL_OPTION( p, b );
            *pBuffer += 3;
                       
            m_localOptions[ b ] = ENABLED;
        }
    }
    else if( m_optionCmd == TC_DONT )
    {
        if( m_fWaitingForAResponseToA_WILL_ForTO_SGA )
        {
            m_fWaitingForAResponseToA_WILL_ForTO_SGA = false;
        }
        else if( m_localOptions[ b ] == ENABLED )
        {
            m_localOptions[ b ] = DISABLED;
        }
        else
        {
        }
    }
}


void CRFCProtocol::WillEcho( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
   // DO, DONT logic
    _TRACE( TRACE_DEBUGGING, "WillEcho()" );

    if( m_optionCmd == TC_DO )
    {
        if( m_localOptions[ b ] == ENABLED )
        {
        }
        else if( m_fWaitingForAResponseToA_WILL_ForTO_ECHO )
        {
            m_fWaitingForAResponseToA_WILL_ForTO_ECHO = false;
            m_localOptions[ b ] = ENABLED;
        }
        else
        {
            //I want to enable this option
            PUCHAR p = *pBuffer;
            WILL_OPTION( p, b );
            *pBuffer += 3;
                       
            m_localOptions[ b ] = ENABLED;
        }
    }
    else if( m_optionCmd == TC_DONT )
    {
        if( m_fWaitingForAResponseToA_WILL_ForTO_ECHO )
        {
            m_fWaitingForAResponseToA_WILL_ForTO_ECHO = false;
        }
        else if( m_localOptions[ b ] == ENABLED )
        {
            m_localOptions[ b ] = DISABLED;
        }
        else
        {
        }
    }
}


void CRFCProtocol::SubOption( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
    INT tableIndex = m_subNegFSM[ m_subNegState ][ b ];
    if( subNegTransTable[ tableIndex ].pmfnAction )
    {
        (this->*(subNegTransTable[ tableIndex ].pmfnAction))(ppPutBack, pBuffer, b);
        m_subNegState = subNegTransTable[ tableIndex ].uchNextState;
    }
    else
    {
        /*Should not happen */
        _chASSERT( 0 );
    }
}

void CRFCProtocol::FindVariable()
{
    m_dwWhichVar = E_UNKNOWN;
    if( _strcmpi( m_szCurrentEnvVariable, USER ) == 0 )
    {
        m_dwWhichVar = E_USER;
    }
    else if( _strcmpi( m_szCurrentEnvVariable, SFUTLNTVER ) == 0 )
    {
        m_dwWhichVar = E_SFUTLNTVER;
    }
    else if( _strcmpi( m_szCurrentEnvVariable, SFUTLNTMODE ) == 0 )
    {
        m_dwWhichVar = E_SFUTLNTMODE;
    }
    else
    {            
    }
}

void CRFCProtocol::SubNewEnvGetValue( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
    if( m_dwWhatVal == E_UNDEFINED )
    {
        FindVariable();
        m_szCurrentEnvVariable[0] = 0;
    }

   /* Here, 
   if m_szCurrentEnvVariable[0] != 0, variable has value as in m_szCurrentEnvVariable[0]
   else it has value as in m_dwWhatVal */

    switch( m_dwWhichVar )
    {
        case E_USER:
            {
                m_bIsUserNameProvided = true;
                strncpy(m_pSession->CSession::m_pszUserName, m_szCurrentEnvVariable, (sizeof(m_pSession->CSession::m_pszUserName) - 1));
            }
            break;
        case E_SFUTLNTVER:
            //set by default to current version
            if( _strcmpi( m_szCurrentEnvVariable, VERSION1 ) == 0 )
            {
                ;// version 1
            }
            else if( _strcmpi( m_szCurrentEnvVariable, VERSION2 ) == 0 )
            {
                m_pSession->CSession::m_bIsTelnetVersion2 = true; //version 2
            }

            break;
        case E_SFUTLNTMODE:
            if( _strcmpi( m_szCurrentEnvVariable, STREAM ) == 0 )
            {
                m_pSession->CSession::m_bIsStreamMode = true;//Set it to stream mode 
            }
            break;
    }

    m_dwWhichVar = E_UNKNOWN;
    m_dwWhatVal  = E_UNDEFINED;
    m_szCurrentEnvVariable[0] = 0;
}

void CRFCProtocol::SubNewEnvGetVariable( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
    /*For us, it doesn't matter whether a variable is VAR or USERVAR
    Not bothering about any difference between IS and INFO */

    /* VALUE is present */
    m_dwWhatVal  = E_DEFINED_BUT_NONE;
    
    m_dwWhichVar = E_UNKNOWN;
    if( m_szCurrentEnvVariable[0] != 0 )
    {
        FindVariable();        
    }
    else
    {
        //Should not happen
        _chASSERT( 0 );
    }

    m_szCurrentEnvVariable[0] = 0;
}

void CRFCProtocol::SubNewEnvGetString( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
    static char str[] = " ";
    str[0] = b;
    if( strlen( m_szCurrentEnvVariable ) < MAX_PATH )
    {
        strcat( m_szCurrentEnvVariable, str );    
    }

    m_fSubNewEnv = true;
}

void CRFCProtocol::SubTermType( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
    char str[2];
    str[0] = ( char ) b;
    str[1] = 0;
 
    if( strlen( m_pSession->CSession::m_pszTermType ) < MAX_PATH )
        strcat( m_pSession->CSession::m_pszTermType, str );

    fSubTermType = true;
}

void CRFCProtocol::SubAuth( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
    if( m_wNTLMDataBufferIndex >= 2047 )
    {
        //if this happens, it is likely that somebody is screwing around.
        _TRACE( TRACE_DEBUGGING, "Error: NTLMDataBuffer overflow" );
        _chASSERT( 0 );
    }
    else
    {
        m_NTLMDataBuffer[ m_wNTLMDataBufferIndex++ ] = b;
    }

    fSubAuth = true;
}

#define MAX_ROWS 300
#define MAX_COLS 300

void CRFCProtocol::SubNaws( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
    m_dwSubNawsByteNumber++;

    //we ignore 1st and 3rd bytes because that is too many rows and
    //cols for NT to support

    if( 2 == m_dwSubNawsByteNumber )
    {
        if( b > 0 && b <= MAX_COLS )
            m_pSession->CSession::m_wCols = b;
    }

    if( 4 == m_dwSubNawsByteNumber )
    {
        if( b > 0 && b <= MAX_ROWS )
            m_pSession->CSession::m_wRows = b;
    }
    fSubNaws = true;
}

void CRFCProtocol::ChangeCurrentTerm()
{
    if( !( m_pSession->CScraper::m_dwTerm & TERMVTNT ) )
    {
        m_pSession->CScraper::DeleteCMStrings();
    }
    m_pSession->CSession::InitTerm();
}

void CRFCProtocol::SubEnd( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b )
{
    //other clients might first send DEC-vt100
    //best to follow Assigned Numbers RFC
    //and also change our ( not so compliant ;-) ) GUI telnet client
    if( fSubTermType )
    {   
        if( _strcmpi( VT52, m_pSession->CSession::m_pszTermType ) == 0 ||
            _strcmpi( VT100, m_pSession->CSession::m_pszTermType ) == 0 ||
            _strcmpi( ANSI, m_pSession->CSession::m_pszTermType ) == 0 ||
            ( !( m_dwExcludeTerm & TERMVTNT ) && 
            _strcmpi( VTNT, m_pSession->CSession::m_pszTermType ) == 0 ) )
        {
            // we got a good term type.
            // set a flag to continue the telnet session
            m_pSession->CSession::m_bNegotiatedTermType = true;
            if( m_pSession->CSession::m_dwTerm != 0 )
            {
                ChangeCurrentTerm();
            }
        }
        else
        {
            if( _strcmpi( m_szPrevTermType, 
                m_pSession->CSession::m_pszTermType ) != 0 )
            {
                (*pBuffer)[0] = TC_IAC;
                (*pBuffer)[1] = TC_SB;
                (*pBuffer)[2] = TO_TERMTYPE;
                (*pBuffer)[3] = TT_SEND;
                (*pBuffer)[4] = TC_IAC;
                (*pBuffer)[5] = TC_SE;
                (*pBuffer)[6] = 0;

                *pBuffer += 6;

                strncpy(m_szPrevTermType, m_pSession->CSession::m_pszTermType, (sizeof(m_szPrevTermType) - 1)); 
                m_pSession->CSession::m_pszTermType[0] = 0;
            }
            else
            {
                //the client sent the same term type twice
                //this means that the client has sent the last term type
                //in its list 
                
                // this means that the client supports terminal types
                // but it does not support anything we support;
                // too bad ; either we should default to vt100
                // or we should demand that the client don't do 
                // terminal types and we should go into NVT ASCII (tty) mode

                // The client doesn't support anything that we like, we
                // default to vt100 instead of doing the right thing as described
                // above.
                strncpy( m_pSession->CSession::m_pszTermType, VT100, (sizeof(m_pSession->CSession::m_pszTermType)-1));
                m_pSession->CSession::m_bIsStreamMode = true;//Set it to stream mode

                // set a flag to continue the telnet session
                m_pSession->CSession::m_bNegotiatedTermType = true;
                if( m_pSession->CSession::m_dwTerm != 0 )
                {
                    ChangeCurrentTerm();
                }
            }
        }
        fSubTermType = false;
    }

    if( fSubAuth )
    {
        m_pSession->CIoHandler::DoNTLMAuth( (unsigned char*) m_NTLMDataBuffer, 
            m_wNTLMDataBufferIndex, pBuffer );
        m_wNTLMDataBufferIndex = 0;
        fSubAuth = false;
    }

    if( fSubNaws )
    {
        fSubNaws = false;
        if( !m_fSubNawsFirstTime )
        {
            //For the first time we need to wait till IOHandles are created for 
            //Making following initialization
            if( !m_pSession->CScraper::SetCmdInfo() )
            {
                _chASSERT( 0 );
            }
        }
        else
        {
            m_fSubNawsFirstTime = false;        
        }
        m_dwSubNawsByteNumber = 0;
    }

    if( m_fSubNewEnv )
    {
        SubNewEnvGetValue( ppPutBack, pBuffer, b );
        m_fSubNewEnv = false;
    }

    m_subNegState = SS_START;
}



/*From RFC: 
Specifically careful analysis should be done to determine which variables are "safe" 
to set prior to having the client login. An example of a bad choice would be permitting 
a variable to be changed that allows an intruder to circumvent or compromise the 
login/authentication program itself */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsess\fsm.h ===
// FSM.h : This file contains the Finite State Machine ...
// Created:  Feb '98
// Author : a-rakeba
// History:
// Copyright (C) 1998 Microsoft Corporation
// All rights reserved.
// Microsoft Confidential 

#if !defined( _FSM_H_ )
#define _FSM_H_

#include "cmnhdr.h"
#include <windows.h>

#include <rfcproto.h>

// Telnet Socket-Input FSM States
// just to make it obvious TS_ prefix means Telnet State

#define TS_DATA     0   // normal data processing
#define TS_IAC      1   // have seen IAC
#define TS_WOPT     2   // have seen IAC- { WILL | WONT }
#define TS_DOPT     3   // have seen IAC- { DO | DONT }
#define TS_SUBNEG   4   // have seen IAC-SB
#define TS_SUBIAC   5   // have seen IAC-SB-...-IAC

//#define NUM_TS_STATES 6 // number of TS_* states



//Telnet Option  Subnegotiation FSM States
//just to make it obvious SS_ prefix means Subnegotiation State

#define SS_START    0   // initial state
#define SS_TERMTYPE 1   // TERMINAL_TYPE option subnegotiation
#define SS_AUTH1    2   // AUTHENTICATION option subnegotiation
#define SS_AUTH2    3
#define SS_NAWS     4
#define SS_END_FAIL 5   
#define SS_END_SUCC 6
#define SS_NEW_ENVIRON1     7   //NEW_ENVIRON sub negotiation
#define SS_NEW_ENVIRON2     8   //NEW_ENVIRON sub negotiation
#define SS_NEW_ENVIRON3     9   //NEW_ENVIRON sub negotiation
#define SS_NEW_ENVIRON4     10  //NEW_ENVIRON sub negotiation
#define SS_NEW_ENVIRON5     11  //NEW_ENVIRON sub negotiation

#define FS_INVALID  0xFF    // an invalid state number

#define TC_ANY    (NUM_CHARS+1) // match any character

typedef 
    void (CRFCProtocol::*PMFUNCACTION) 
    ( LPBYTE* ppPutBack, PUCHAR* pBuffer, BYTE b );

//#pragma pack(4)


typedef struct {
    UCHAR uchCurrState;    
    WORD wInputChar;
    //BYTE  pad2[6];
    UCHAR uchNextState;
    //BYTE  pad3[6];
	PMFUNCACTION pmfnAction;
} FSM_TRANSITION;


#endif //_FSM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsess\main.cpp ===
// scraper.cpp : This file contains the
// Created:  Dec '97
// History:
// Copyright (C) 1997 Microsoft Corporation
// All rights reserved.
// Microsoft Confidential

#include <CmnHdr.h>

#include <TChar.h>
#include <New.h>

#include <Debug.h>
#include <MsgFile.h>
#include <TelnetD.h>
#include <TlntUtils.h>
#include <Session.h>
#include <Resource.h>
#include <LocResMan.h>

#pragma warning( disable : 4100 )

using namespace _Utils;
using CDebugLevel::TRACE_DEBUGGING;
using CDebugLevel::TRACE_HANDLE;
using CDebugLevel::TRACE_SOCKET;

HINSTANCE g_hInstRes = NULL;
TCHAR g_szHeaderFormat[ MAX_STRING_LENGTH ];

CSession *pClientSession = NULL;
    
int __cdecl NoMoreMemory( size_t size )
{
    int NO_MORE_MEMORY = 1;
    LogEvent( EVENTLOG_ERROR_TYPE, MSG_NOMOREMEMORY, _T(" ") );
    ExitProcess( 1 );
    _chASSERT(NO_MORE_MEMORY != 1);
    return 0;
}

void Init( )
{
#if _DEBUG || DBG
    CHAR szLogFileName[MAX_PATH];
    _snprintf( szLogFileName, (MAX_PATH-1), "c:\\temp\\scraper%d.log", GetCurrentThreadId() );

    CDebugLogger::Init( TRACE_DEBUGGING, szLogFileName );
#endif
   
    HrLoadLocalizedLibrarySFU(NULL,  L"TLNTSVRR.DLL", &g_hInstRes, NULL);
    LoadString(g_hInstRes, IDS_MESSAGE_HEADER, g_szHeaderFormat, MAX_STRING_LENGTH );

}

void Shutdown()
{
#if _DEBUG || DBG
    CDebugLogger::ShutDown();
#endif
}

void
LogEvent( WORD wType, DWORD dwEventID, LPCTSTR pFormat, ... )
{
    LPCTSTR  lpszStrings[1];

    lpszStrings[0] = pFormat;

    LogToTlntsvrLog( pClientSession->m_hLogHandle, wType, dwEventID,
        (LPCTSTR*) &lpszStrings[0] );

    return;
}

int __cdecl main()
{

//    DebugBreak();

    SetErrorMode(SEM_FAILCRITICALERRORS        | 
                    SEM_NOGPFAULTERRORBOX      |
                    SEM_NOALIGNMENTFAULTEXCEPT |
                    SEM_NOOPENFILEERRORBOX     
                );

    _set_new_handler( NoMoreMemory );

    Init( );

    pClientSession = new CSession;
    if( pClientSession )
    {

        __try
        {
            if( pClientSession->Init() )
            {
                _TRACE( TRACE_DEBUGGING, "new session ..." );
                pClientSession->WaitForIo();
            }
        }
        __finally
        { 
            _TRACE( TRACE_DEBUGGING, "finally block ..." );
            pClientSession->Shutdown(); 
            delete pClientSession;
        }
    }
    
    Shutdown();
    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsess\iohandlr.h ===
// IoHandler.h : This file contains the
// Created:  Feb '98
// Author : a-rakeba
// History:
// Copyright (C) 1998 Microsoft Corporation
// All rights reserved.
// Microsoft Confidential 

#if !defined( _IOHANDLER_H_ )
#define _IOHANDLER_H_

#include <cmnhdr.h>

#include <windows.h>
#include <winsock2.h>
#define SECURITY_WIN32
#include <sspi.h>

#include <TlntUtils.h>
#include <Ipc.h>

#define AVAILABE_BUFFER_SIZE( p, c ) ( sizeof( p ) - ( c - p ) )
#define FOOTER   L"\r\n"
#define NEED_HEADER 1
#define NO_HEADER   0

#define SIZEOF_ARROWKEY_SEQ     3

#define PVA_SUCCESS				0
#define PVA_NODATA				-1
#define PVA_BADFORMAT			-2
#define PVA_GUEST				-3
#define PVA_NOMEMORY			-4
#define PVA_INVALIDACCOUNT		-5
#define PVA_OTHERERROR			-6

class CSession;

class CIoHandler 
{
    public:
    CIoHandler();
    virtual ~CIoHandler();
    
    typedef DWORD  IO_OPERATIONS;
    friend  struct CRFCProtocol;
    friend  class  CScraper;

    private:
    int		ParseAndValidateAccount(void);
    int     AuthenticateUser( void );
    int     CheckLicense( void );
    bool    WriteToServer ( UCHAR, DWORD, LPVOID );
    bool    StartNTLMAuth( void );
    bool    DoNTLMAuth( PUCHAR, DWORD, PUCHAR* );
    bool    IsTimedOut ( );
    bool    GetAndSetSocket ( );
    bool    HandlePipeData ( );
    bool    SendDetailsAndAskForLicense ();
    bool    HandleOperatorMessage();
    bool    GetHeaderMessage( LPWSTR* );
    
    bool    RemoveArrowKeysFromBuffer( PDWORD ,PDWORD);

    bool          ProcessUserDataReadFromSocket( DWORD );
    IO_OPERATIONS ProcessDataFromSocket( DWORD );
    IO_OPERATIONS ProcessCommandLine( PDWORD, PDWORD, IO_OPERATIONS );
    IO_OPERATIONS ProcessAuthenticationLine( PDWORD, PDWORD, IO_OPERATIONS );
    IO_OPERATIONS OnDataFromSocket ( );

    protected:

    typedef enum {
        STATE_INIT,
        STATE_NTLMAUTH,
        STATE_SESSION,
        STATE_BANNER_FOR_AUTH,
        STATE_WAIT_FOR_ENV_OPTION,
        STATE_LOGIN_PROMPT, 
        STATE_AUTH_NAME,
        STATE_AUTH_PASSWORD,
        STATE_CHECK_LICENSE,
        STATE_LICENSE_AVAILABILITY_KNOWN,
        STATE_VTERM_INIT_NEGO,
        STATE_VTERM,
        STATE_TERMINATE } CONTROL_STATE;

    CONTROL_STATE m_SocketControlState;
    enum {  WRITE_TO_SOCKET = 0x00000001, READ_FROM_SOCKET = 0x0000002, 
            LOGON_COMMAND = 0x00000010, LOGON_DATA_UNFINISHED = 0x00000100,
            IO_FAIL = 0x00001000 };

    typedef enum {
        NOT_MEMBER_OF_TELNETCLIENTS_GROUP = 3,
        DENY_LICENSE = 4, 
        ISSUE_LICENSE = 5, 
        WAIT_FOR_SERVER_REPLY = 6,
#if BETA
        LICENSE_EXPIRED
#endif
    } LICENSE_LIMIT;

    CtxtHandle m_hContext;

    OVERLAPPED m_oWriteToSocket;
    UCHAR      m_WriteToSocketBuff[ MAX_WRITE_SOCKET_BUFFER ];
    DWORD      m_dwWriteToSocketIoLength;
    WSAPROTOCOL_INFO m_protocolInfo;
    bool       m_bOnlyOnce;
    bool       m_bWaitForEnvOptionOver;

    OVERLAPPED m_oWriteToPipe;

    OVERLAPPED m_oReadFromSocket;
    UCHAR      m_ReadFromSocketBuffer[ MAX_READ_SOCKET_BUFFER ];
    PUCHAR     m_pReadFromSocketBufferCursor;
    DWORD      m_dwReadFromSocketIoLength;

    OVERLAPPED m_oReadFromPipe;
    UCHAR      m_ReadFromPipeBuffer[ IPC_HEADER_SIZE ];    
    UCHAR      *m_pucReadBuffer;
    DWORD      m_dwReadFromPipeIoLength;
    DWORD      m_dwRequestedSize;
    bool       m_bIpcHeader;

    SOCKET     m_sSocket;
    HANDLE     m_hReadPipe;
    HANDLE     m_hWritePipe;
  
    bool       m_fFirstReadFromPipe;
    bool       m_fShutDownAfterIO;
    BOOL       m_fLogonUserResult;
    bool       m_bNTLMAuthenticated;
    bool       fDoNTLMAuthFirstTime;
    CredHandle m_hCredential;
    PSecPkgInfo  m_pspi;
    CSession   *m_pSession;
    int         m_iResult;

	bool		m_bInvalidAccount;
	
    bool      GetUserName();
    bool      WriteToSocket(PUCHAR, DWORD );
    bool      Init( CSession * );
    void      Shutdown( void );
    bool      IssueReadOnPipe( );
    bool      IssueFirstReadOnPipe ( );
    bool      WriteToClient ( );
    bool      IssueReadFromSocket ( );
    bool      OnReadFromPipeCompletion ( );
    bool      OnReadFromSocketCompletion ( );
    void      DisplayOnClientNow();
    void      SendMessageToClient( LPWSTR, bool );
    void      WriteMessageToClientDirectly( LPWSTR );
    void      SendTerminateString( char *);
    void      UpdateIdleTime( UCHAR );
};

#endif // _IOHANDLER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsess\iohandlr.cpp ===
// Created:  Feb '98
// Author : a-rakeba
// History:
// Copyright (C) 1998 Microsoft Corporation
// All rights reserved.
// Microsoft Confidential
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <CmnHdr.h>

#include <Windows.h>
#include <NtLsApi.h>
#include <LmAccess.h>
#include <LmApiBuf.h>
#include <LmErr.h>
#include <Lm.h>
#include <OleAuto.h>
#include <IpTypes.h>
#ifdef WHISTLER_BUILD
#include "ntverp.h"
#else
#include <SolarVer.h>
#include <PiracyCheck.h>
#endif //WHISTLER_BUILD

#include <Debug.h>
#include <MsgFile.h>
#include <TelnetD.h>

#include <TlntUtils.h>
#include <IoHandlr.h>
#include <Session.h>
#include <killapps.h>

#pragma warning( disable: 4706 )

#define ONE_KB 1024

using namespace _Utils;
using CDebugLevel::TRACE_DEBUGGING;
using CDebugLevel::TRACE_HANDLE;
using CDebugLevel::TRACE_SOCKET;

extern COORD g_coCurPosOnClient;
extern TCHAR g_szHeaderFormat[];
extern HANDLE       g_hSyncCloseHandle;

DWORD g_dwPreSessionStateTimeOut = PRE_SESSION_STATE_TIMEOUT;

BOOLEAN IsTheAccount(
    LPWSTR pszAccount,
    ULONG       rid
    )
{
    SID_NAME_USE        sidAccountType;
    PSID                sid = NULL;
    LPWSTR               pszDomain = NULL;
    DWORD               dwSidSize = 0, dwDomainSize = 0;
    BOOLEAN             fSuccess = FALSE;


    if (!LookupAccountNameW(
            NULL,                       // Default to local machine
            pszAccount,
            NULL,
            &dwSidSize,
            NULL,
            & dwDomainSize,
            & sidAccountType
            ))
    {
         if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
            goto AbortIsTheAccount;
    }
    else
    {
        // No idea how this can succeed, something fishy
        goto AbortIsTheAccount;
    }
    
        

    sid = (PSID) GlobalAlloc(GPTR, dwSidSize);
    if (sid) 
    {
        pszDomain = (WCHAR *) GlobalAlloc(GPTR, dwDomainSize * sizeof(WCHAR));
        if (pszDomain)
        {
            if (LookupAccountNameW(
                    NULL,                       // Default to local machine
                    pszAccount,
                    sid,
                    &dwSidSize,
                    pszDomain,
                    & dwDomainSize,
                    & sidAccountType
                    ))
            {
                PULONG      last_sub_authority;

                last_sub_authority = RtlSubAuthoritySid(sid, ((*RtlSubAuthorityCountSid(sid)) - 1));

                if (*last_sub_authority == rid) 
                {
                    fSuccess = TRUE;
                }
            }

            GlobalFree(pszDomain);
        }

        GlobalFree(sid);
    }

AbortIsTheAccount:
    return fSuccess;
}

CIoHandler::CIoHandler()
{
    m_sSocket = INVALID_SOCKET;
    m_hWritePipe = INVALID_HANDLE_VALUE;
    m_hReadPipe = INVALID_HANDLE_VALUE;
    m_pucReadBuffer = m_ReadFromPipeBuffer;
    m_pReadFromSocketBufferCursor = m_ReadFromSocketBuffer;
    m_hCredential.dwLower = m_hCredential.dwUpper = 0 ;

    InitializeOverlappedStruct( &( m_oReadFromSocket ) );
    InitializeOverlappedStruct( &( m_oWriteToSocket ) );
    InitializeOverlappedStruct( &( m_oWriteToPipe ) );
    InitializeOverlappedStruct( &( m_oReadFromPipe ) );

    m_fFirstReadFromPipe = true;
    m_fShutDownAfterIO = false;
    m_dwWriteToSocketIoLength = 0;
    m_dwReadFromPipeIoLength = 0;
    m_dwRequestedSize = IPC_HEADER_SIZE;
    m_bIpcHeader = true;
    m_fLogonUserResult = 0;
    m_bNTLMAuthenticated = false;
    fDoNTLMAuthFirstTime = true;
    m_pspi = NULL;
    m_iResult = 0;
    m_bOnlyOnce = true;
    m_bWaitForEnvOptionOver = false;

    m_bInvalidAccount = false;
}


CIoHandler::~CIoHandler()
{
    /*++
    Close Handles only if they are not already closed.
    --*/
    TELNET_CLOSE_HANDLE( m_oReadFromSocket.hEvent );
    TELNET_CLOSE_HANDLE( m_oWriteToSocket.hEvent );
    TELNET_CLOSE_HANDLE( m_oWriteToPipe.hEvent );
    TELNET_CLOSE_HANDLE( m_oReadFromPipe.hEvent );
    TELNET_CLOSE_HANDLE( m_hWritePipe );
    TELNET_CLOSE_HANDLE( m_hReadPipe );
    _TRACE( TRACE_DEBUGGING, " ~CIoHandler  --  closesocket : %d  ", (DWORD)m_sSocket);
    if(m_sSocket != INVALID_SOCKET)
    {
        closesocket( m_sSocket );
        m_sSocket = INVALID_SOCKET;
    }

    _chVERIFY2( !WSACleanup() );
}
    

void
CIoHandler::Shutdown()
{
    _TRACE(TRACE_DEBUGGING, "closing down the session...sending SESSION_EXIT to server");
    WriteToServer( SESSION_EXIT, 0, NULL );
    
    //Cancel anyIO pending on handles
    CancelIo( m_hReadPipe );
    shutdown( m_sSocket, SD_BOTH );

    if ( m_bNTLMAuthenticated )
    {
        DeleteSecurityContext( &m_hContext );
    }

    if ( m_pSession->m_dwNTLMSetting != NO_NTLM )
    {
        if( m_hCredential.dwLower != 0 || m_hCredential.dwUpper != 0 )
            FreeCredentialsHandle(&m_hCredential);
        if( m_pspi != NULL )
            FreeContextBuffer( m_pspi );
    }
}

bool 
CIoHandler::Init ( CSession *pSession )
{
    _chASSERT( pSession );
    if( !pSession )
    {
        return( FALSE );
    }
    m_pSession = pSession ;
    m_hReadPipe  = GetStdHandle( STD_INPUT_HANDLE );
    m_hWritePipe = GetStdHandle( STD_OUTPUT_HANDLE );
    if( m_hReadPipe == INVALID_HANDLE_VALUE || m_hWritePipe == INVALID_HANDLE_VALUE)
    {
        return( FALSE );
    }
    
    //The following handles are not to be inherited
    _chVERIFY2( SetHandleInformation( m_hReadPipe, HANDLE_FLAG_INHERIT, 0) );
    _chVERIFY2( SetHandleInformation( m_hWritePipe, HANDLE_FLAG_INHERIT, 0) );
    
    WSADATA WSAData;
    WORD    wVersionReqd = MAKEWORD( 2, 0 );
    DWORD   dwStatus = WSAStartup( wVersionReqd, &WSAData );
    if( dwStatus )
    {
        DecodeSocketStartupErrorCodes( dwStatus ); //It does tracing and logging
        return( FALSE );
    }

    return( TRUE ); 
}

bool 
CIoHandler::WriteToSocket( PUCHAR lpszBuffer, DWORD dwBufSize )
{
    DWORD dwNumBytesWritten = 0;
    DWORD dwMaxNumBytesToCopy = 0;

    if (( (m_dwWriteToSocketIoLength + dwBufSize) >=  MAX_WRITE_SOCKET_BUFFER ) ||
        //Block until Previous Io is finished
        ( !FinishIncompleteIo( ( HANDLE ) m_sSocket, &m_oWriteToSocket, &dwNumBytesWritten ) ))
    {
        return( FALSE );
    }

    dwMaxNumBytesToCopy = min(dwBufSize,(MAX_WRITE_SOCKET_BUFFER - m_dwWriteToSocketIoLength - 1 ));
    memcpy(m_WriteToSocketBuff + m_dwWriteToSocketIoLength, lpszBuffer, 
                            dwMaxNumBytesToCopy);
    m_dwWriteToSocketIoLength += dwMaxNumBytesToCopy;
    return( TRUE );
}

//Ignore some keys during authentication.
bool 
CIoHandler::RemoveArrowKeysFromBuffer( PDWORD pdwLength,PDWORD pdwOffset)
{
    bool bRetVal = false;
    DWORD dwLength = *pdwLength;
    DWORD dwIndex = (DWORD)(m_pReadFromSocketBufferCursor - m_ReadFromSocketBuffer);
    DWORD dwCounter = 0;
    DWORD dwInputSequneceState = IP_INIT;

    for(dwCounter = 0; dwCounter < dwLength; dwCounter++,dwIndex++)
    {
        switch( dwInputSequneceState )
        {
            case IP_INIT:
                if (m_ReadFromSocketBuffer[dwIndex] == ESC)
                {    
                    dwInputSequneceState = IP_ESC_RCVD;
                }
                break;

            case IP_ESC_RCVD:
                if( m_ReadFromSocketBuffer[dwIndex] == '[' )
                {        
                    dwInputSequneceState = IP_ESC_BRACKET_RCVD;
                }
                else
                {
                    dwInputSequneceState = IP_INIT;
                }
                break;


            case IP_ESC_BRACKET_RCVD:        
                switch( m_ReadFromSocketBuffer[dwIndex] )
                {
                    case 'A':
                    case 'B':
                    case 'C':
                    case 'D':
                        /*++
                        You got an escape sequence for arrow keys. Ignore them. Manipulate the buffer length,
                        Position of cursor in the buffer, and Offset in the buffer accordingly.
                        --*/
                        if( (dwLength - (*pdwOffset) - (dwCounter+1) ) > 0)//safety check - don't copy if number of bytes to be copied = 0
                        {
                            memcpy( m_pReadFromSocketBufferCursor+dwCounter-2,
                                m_pReadFromSocketBufferCursor + dwCounter + 1, dwLength - (*pdwOffset) - (dwCounter+1) );
                        }
                        *pdwLength -= SIZEOF_ARROWKEY_SEQ;//manipulate bufferlength
                        bRetVal = true;
                        break;
                    default:
                        break;
                }
                dwInputSequneceState = IP_INIT;
                break;

            default:
                break;
        }
    }
    return bRetVal;
}

CIoHandler::IO_OPERATIONS 
CIoHandler::ProcessCommandLine
( 
    PDWORD pdwInputLength,
    PDWORD pdwOffset,
    IO_OPERATIONS ioOpsToPerform 
)
{
    RemoveArrowKeysFromBuffer( pdwInputLength,pdwOffset);

    for( *pdwOffset; *pdwOffset < *pdwInputLength; ( *pdwOffset )++ )
    {
                        
        switch( *m_pReadFromSocketBufferCursor )
        {
        case ASCII_DELETE:
        case ASCII_BACKSPACE:
            // Test if we are at position zero
            //second condition (m_pReadFromSocketBufferCursor > m_ReadFromSocketBuffer)
            // is guard for excessive ( continuous backspace )
            if( *pdwOffset && (m_pReadFromSocketBufferCursor > m_ReadFromSocketBuffer) )
            {
                /*++
                 MSRC 678 :  Telnet Server Crash/BO with >4300 characters and a backspace
                 Fix : If a backspace is pressed, we want to write only valid characters starting
                 from the current offset till the end of valid data in the m_ReadFromSocketBuffer.
                --*/
                memcpy( m_pReadFromSocketBufferCursor - 1,
                    m_pReadFromSocketBufferCursor + 1, ((*pdwInputLength)-(*pdwOffset) - 1) );
                m_pReadFromSocketBufferCursor--;
                ( *pdwInputLength ) -= 2;
                (*pdwOffset)--;

                UCHAR szTmp[3];
                szTmp[0] = ASCII_BACKSPACE;
                szTmp[1] = ASCII_SPACE;
                szTmp[2] = ASCII_BACKSPACE;

                WriteToSocket( szTmp, 3 );

                ioOpsToPerform |= WRITE_TO_SOCKET;
            }
            else
            {
                memcpy( m_pReadFromSocketBufferCursor, 
                    m_pReadFromSocketBufferCursor + 1, ( *pdwInputLength ) - 1 );
                ( *pdwInputLength )--;
            }
            break;
                
        case ASCII_CARRIAGE:
            if( *pdwOffset < *pdwInputLength )
                if((*(m_pReadFromSocketBufferCursor + 1 ) == ASCII_LINEFEED) ||
                    ( *( m_pReadFromSocketBufferCursor + 1 ) == NULL ) )
                    return ( ioOpsToPerform |= LOGON_COMMAND );
            m_pReadFromSocketBufferCursor++;
            break;

        case NULL:
        case ASCII_LINEFEED:
            if( *pdwOffset )
                if( *( m_pReadFromSocketBufferCursor - 1 ) == ASCII_CARRIAGE )
                    return ( ioOpsToPerform |= LOGON_COMMAND );
            m_pReadFromSocketBufferCursor++;
            break;
        default:

            if( m_pSession->CRFCProtocol::m_fPasswordConcealMode )
            {
                // This results in more than one * being output for things like up-arrow, so don't do it

                 //UCHAR szTmp[1];
                
                 //szTmp[0] = '*';
                 //WriteToSocket( szTmp, 1 );
            }
            else
            {
                UCHAR szTmp[1];

                szTmp[0] = *m_pReadFromSocketBufferCursor;
                WriteToSocket( szTmp, 1 );
            }
            ioOpsToPerform |= WRITE_TO_SOCKET;
            m_pReadFromSocketBufferCursor++;

            break;
        }
    }

    return ( ioOpsToPerform );
}


CIoHandler::IO_OPERATIONS 
CIoHandler::ProcessAuthenticationLine (
    PDWORD pdwInputLength,
    PDWORD pdwOffset,
    IO_OPERATIONS ioOpsToPerform 
)
{
    CHAR    szMessageBuffer[ONE_KB + 1];
    DWORD   dwMessageLength;
    PUCHAR  pEndLine;
    DWORD   dwLineLength = 0;
    CHAR    szTmp[ONE_KB];
    LPVOID lpMsgBuf = NULL;
    LPVOID lpTemp = NULL;

    // Initialize Variables
    szMessageBuffer[0] = 0;

    if( !m_pSession->CRFCProtocol::m_bIsUserNameProvided )
    {   
        pEndLine = (PUCHAR) memchr( m_ReadFromSocketBuffer, '\r', *pdwInputLength);
        if( !pEndLine ) 
            return ( ioOpsToPerform );
        ( *pEndLine ) = 0;
        dwLineLength = (DWORD)(pEndLine - m_ReadFromSocketBuffer + 2);
    }  

    switch( m_SocketControlState )
    {

    case STATE_AUTH_NAME:
        if( !m_pSession->CRFCProtocol::m_bIsUserNameProvided )
        {
            strncpy( m_pSession->CSession::m_pszUserName, 
                ( PCHAR ) m_ReadFromSocketBuffer, 
                (dwLineLength > MAX_PATH) ? MAX_PATH : dwLineLength );
            m_pSession->CSession::m_pszUserName[MAX_PATH] = '\0';
        }
        else
        {
            //Use the -l user name only once.
            m_pSession->CRFCProtocol::m_bIsUserNameProvided = false;
        }

		m_bInvalidAccount = false;
        switch(ParseAndValidateAccount())
        {
        case PVA_INVALIDACCOUNT:
        	m_bInvalidAccount = true;	// Fall through to take the password, no break ...
        case PVA_SUCCESS:
            g_coCurPosOnClient.Y++;  //Hack. needed for keeping track of rows for VTNT and stream
            lstrcpyA( szMessageBuffer, PASS_REQUEST );
            m_pSession->CRFCProtocol::m_fPasswordConcealMode  = true;
            m_SocketControlState = STATE_AUTH_PASSWORD;
            break;
            
        case PVA_NODATA:
			g_coCurPosOnClient.Y++;  //Hack. needed for keeping track of rows for VTNT and stream
			lstrcatA( szMessageBuffer, LOGIN_REQUEST );
			break;
			
        case PVA_BADFORMAT:
            g_coCurPosOnClient.Y += 3;  //Hack. needed for keeping track of rows for VTNT and stream
            lstrcatA( szMessageBuffer, BAD_USERNAME_STR );
            lstrcatA( szMessageBuffer, LOGIN_REQUEST );
            break;
            
        case PVA_GUEST:
            g_coCurPosOnClient.Y += 3;  //Hack. needed for keeping track of rows for VTNT and stream
            lstrcatA( szMessageBuffer, NO_GUEST_STR );
            lstrcatA( szMessageBuffer, LOGIN_REQUEST );
            break;
            
        default:    // PVA_OTHERERROR as of now and any other unless a handler is added above ...
        	goto AbortProcessAuthenticationLine;
        }
	    break;

    case STATE_AUTH_PASSWORD:
        strncpy( m_pSession->CSession::m_pszPassword, 
            ( PCHAR ) m_ReadFromSocketBuffer, 
            (dwLineLength > MAX_PATH) ? MAX_PATH : dwLineLength );
        
        BOOL fResult;
        fResult = m_bInvalidAccount ? false : AuthenticateUser();
        if(fResult)
        {
            // Authentication was success so we proceed to license
            // verification
            m_SocketControlState = STATE_CHECK_LICENSE;
        }
        else 
        {
            DWORD dwError = GetLastError();
            int iRet = 0;
            if( dwError == ERROR_FILENAME_EXCED_RANGE || m_bInvalidAccount)
            {
                dwError = ERROR_LOGON_FAILURE;
            }

            //
            // If not Japanese codepage (932) then use LANG_NEUTRAL to retrieve
            // system error message in host language. For Japanese, the
            // error must be in English because they have different codesets
            // and encodings and we cannot know what codeset the client is
            // running.
            //
            if( GetACP() != 932 )
            {
            
                FormatMessageA(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL, dwError,
                    MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
                    ( LPSTR ) &lpTemp, 0, NULL );
                if(!lpTemp)
                {
                    goto Error;
                }
                lpMsgBuf = (LPSTR) LocalAlloc(LPTR,strlen((LPSTR)lpTemp)+1);
                if(!lpMsgBuf)
                {
                    goto Error;
                }
                if(!CharToOemA((LPCSTR)lpTemp,(LPSTR)lpMsgBuf))
                {
                    goto Error;
                }
            }
            else
            {
                FormatMessageA(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL, dwError,
                    MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
                    (LPSTR)&lpMsgBuf, 0, NULL );
            }
            if( !lpMsgBuf )
            {
                goto Error;
            }

            if (_snprintf( szMessageBuffer, ONE_KB, "\r\n%s", lpMsgBuf ) < 0)
            {
                szMessageBuffer[ONE_KB] = '\0';
            }

            m_pSession->CRFCProtocol::m_fPasswordConcealMode  = false;

            if( ( ++( m_pSession->CSession::m_wNumFailedLogins ) ) <
                       m_pSession->m_dwMaxFailedLogins )
            {
                g_coCurPosOnClient.Y += 5;  //Hack. needed for keeping track of rows for VTNT nd stream
                if (_snprintf( 
                        szMessageBuffer + strlen( szMessageBuffer ),
                        ONE_KB - strlen(szMessageBuffer),
                        "%s%s", 
                        LOGIN_FAIL, 
                        LOGIN_REQUEST 
                        ) < 0)
                {
                    szMessageBuffer[ONE_KB] = '\0';
                }
                m_SocketControlState = STATE_AUTH_NAME;
            }
            else 
            {
                if (_snprintf( 
                        szMessageBuffer + strlen( szMessageBuffer ), 
                        ONE_KB - strlen(szMessageBuffer),
                        "%s%s",
                        LOGIN_FAIL, 
                        TERMINATE
                        ) < 0)
                {
                    szMessageBuffer[ONE_KB] = '\0';
                }
                m_SocketControlState = STATE_TERMINATE;
                CIoHandler::m_fShutDownAfterIO = true;
            }
        }
#ifdef LOGGING_ENABLED        
        if( !fResult )
        {
            m_pSession->LogIfOpted( FAIL, LOGON );
        }
#endif
Error:
        if(lpMsgBuf)
        {
            LocalFree( lpMsgBuf );
            lpMsgBuf = NULL;
        }
        if(lpTemp)
        {
            LocalFree(lpTemp);
            lpTemp = NULL;
        }
        break;

    default:
        strncpy( szMessageBuffer, "\r\n", (ONE_KB -1)); // NO BO attack here - Baskar
        break;
    }

    //
    // Remove Line From Read Socket buffer if there is more IO
    //
    if( dwLineLength < *pdwInputLength )
    {
        ( *pdwInputLength ) -= dwLineLength;
        memcpy( m_ReadFromSocketBuffer, m_ReadFromSocketBuffer + dwLineLength,
            ( *pdwInputLength ) );
        ioOpsToPerform |= LOGON_DATA_UNFINISHED;
    }
    ( *pdwOffset ) = 0;
    m_pReadFromSocketBufferCursor = m_ReadFromSocketBuffer;

    //
    // Send notification string; if required
    //
    dwMessageLength = strlen( szMessageBuffer );
    WriteToSocket( (PUCHAR)szMessageBuffer, dwMessageLength);

    ioOpsToPerform |= WRITE_TO_SOCKET;
    
AbortProcessAuthenticationLine:

    if(lpMsgBuf)
    {
        LocalFree( lpMsgBuf );
        lpMsgBuf = NULL;
    }
    if(lpTemp)
    {
        LocalFree(lpTemp);
        lpTemp = NULL;
    }
    return ( ioOpsToPerform );
}

int CIoHandler::ParseAndValidateAccount()
{
	CHAR *pPos=NULL;
	int nRet = PVA_OTHERERROR;
	bool bDefaultDomain = true;
    WCHAR lpszDomainOfMac[MAX_DOMAIN_NAME_LEN + 1];
    int iRetVal = PVA_OTHERERROR;
    BOOLEAN bIsGuest = FALSE;
    LPWSTR lpszJoinedDomain = NULL;     // Will be allocated by NetGetJoin...
    int iStatus = 0;
    LPWSTR lpwszUserNDomain = NULL;
    DWORD dwSize = 0;


	if(m_pSession->CSession::m_pszUserName[0] == 0)
		return PVA_NODATA;

	m_pSession->CSession::m_szUser[0] = L'\0';
	
    // Copy the default domain initially, if the user has supplied a domain, then use it
	wcsncpy(m_pSession->CSession::m_szDomain, m_pSession->CSession::m_pszDefaultDomain, MAX_DOMAIN_NAME_LEN);
    m_pSession->CSession::m_szDomain[MAX_DOMAIN_NAME_LEN] = L'\0';
	ConvertSChartoWChar(m_pSession->CSession::m_pszUserName, m_pSession->CSession::m_szUser);

	// User parsing and validity checks
	if((pPos = strchr(m_pSession->CSession::m_pszUserName, '\\')))
	{
		if(pPos == m_pSession->CSession::m_pszUserName)
			return PVA_BADFORMAT;
		if(strchr(pPos+1, '\\'))
			return PVA_BADFORMAT;
		*pPos++ = '\0';
		if (*pPos == '\0')
			return PVA_BADFORMAT;
		
		bDefaultDomain = false;

		strcpy(m_pSession->CSession::m_pszDomain, m_pSession->CSession::m_pszUserName);
		strcpy(m_pSession->CSession::m_pszUserName, pPos);
		
		ConvertSChartoWChar(m_pSession->CSession::m_pszUserName, m_pSession->CSession::m_szUser);
		ConvertSChartoWChar(m_pSession->CSession::m_pszDomain, m_pSession->CSession::m_szDomain);
	}

    if (! GetDomainHostedByThisMc(lpszDomainOfMac))
    {
        iRetVal = PVA_OTHERERROR;
        goto End;
    }

	// Domain validity checks
	if((_wcsicmp(m_pSession->CSession::m_szDomain, L".") == 0) ||
	    (_wcsicmp(m_pSession->CSession::m_szDomain, L"localhost") == 0) ||
       (_wcsicmp(m_pSession->CSession::m_szDomain, lpszDomainOfMac) == 0))
	{
        wcscpy(m_pSession->CSession::m_szDomain, lpszDomainOfMac);
	}
	else if(!m_pSession->m_dwAllowTrustedDomain)    // If not local machine, then check for domain trusts
	{
		
		/*
		    If AllowTrustedDomain is 0 then
		        check if the domain is same as the domain hosted by this machine
		        or same as the domain to which this machine is joined
		            If yes proceed
		            If not,
                        if the domain we got is from default domain setting
                            (user has not typed the domain name), then fall back to the local
                            machine
                        else
                            bail out

		    If the machine is joined to a workgroup instead of a domain, then the fall back should
		    be to the domain hosted by this machine.
		*/

        // NetGetJoinInformation is unfortunately not available in versions prior to w2k, so check whether it is available
        {
            HMODULE     dll = NULL;
            FARPROC     proc = NULL;
            TCHAR       szDllPath[MAX_PATH*2] = { 0 };
            UINT        iRet = 0;

            typedef NET_API_STATUS
            (NET_API_FUNCTION *OUR_NET_GET_JOIN_INFORMATION)(
                IN   LPCWSTR                lpServer OPTIONAL,
                OUT  LPWSTR                *lpNameBuffer,
                OUT  PNETSETUP_JOIN_STATUS  BufferType
                );
            BOOL        net_api_found = FALSE;

            iRet = GetSystemDirectory(szDllPath,(MAX_PATH*2)-1);
            if(iRet == 0 || iRet >= (MAX_PATH*2))
            {
                iRetVal = PVA_OTHERERROR;
                goto End;
            }
            _tcsncpy(szDllPath+iRet,TEXT("\\NETAPI32.DLL"),(MAX_PATH*2)-iRet-1);

            dll = LoadLibrary(szDllPath);

            if (! dll)
            {
                iRetVal = PVA_OTHERERROR;
                goto End;
            }

            proc = GetProcAddress(dll, "NetGetJoinInformation");

            if (proc ) 
            {
                NETSETUP_JOIN_STATUS dwStatus;

                if (NERR_Success == (*((OUR_NET_GET_JOIN_INFORMATION)proc))(NULL, &lpszJoinedDomain, &dwStatus))
                {
                    if (dwStatus != NetSetupDomainName)     // Not joined to a domain
                    {
                        NetApiBufferFree(lpszJoinedDomain); 
                        lpszJoinedDomain = NULL;
                    }
                    net_api_found = TRUE;
                }
                else
                {
                    lpszJoinedDomain = NULL;
                }
            }
            else
            {
                HKEY    win_logon;
                LONG    error;
                DWORD   needed = 0, value_type = REG_SZ;

                error = RegOpenKeyEx(
                            HKEY_LOCAL_MACHINE, 
                            TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"), 
                            0,  // Reserved
                            KEY_QUERY_VALUE | MAXIMUM_ALLOWED,
                            &win_logon
                            );
                if (error == ERROR_SUCCESS) 
                {
                    RegQueryValueExW(win_logon, L"CachePrimaryDomain", 0, &value_type, NULL, &needed); // This will return the size

                    lpszJoinedDomain = (WCHAR *)GlobalAlloc(GPTR, needed);
                    if (lpszJoinedDomain) 
                    {
                        if (ERROR_SUCCESS != RegQueryValueExW(win_logon, L"CachePrimaryDomain", 0, &value_type, (LPBYTE)lpszJoinedDomain, &needed))
                        {
                            GlobalFree(lpszJoinedDomain);
                            lpszJoinedDomain = NULL;
                        }
                    }

                    RegCloseKey(win_logon);
                }
            }

			if  (lpszJoinedDomain && (_wcsicmp(m_pSession->CSession::m_szDomain, lpszJoinedDomain) == 0))
            {
                ;   // Nothing to do here the account is from a valid domain
            }
            else
			{
				if (bDefaultDomain) wcscpy(m_pSession->CSession::m_szDomain, lpszDomainOfMac);
				else m_bInvalidAccount = true;
			}

            if (lpszJoinedDomain)
            {
                if (net_api_found) 
                {
                    NetApiBufferFree(lpszJoinedDomain); 
                }
                else
                {
                    GlobalFree(lpszJoinedDomain);
                }
            }
        }

		if (m_bInvalidAccount) return PVA_INVALIDACCOUNT;
	}
	dwSize = wcslen(m_pSession->CSession::m_szDomain) +
                                        wcslen(m_pSession->CSession::m_szUser) + 2;
	lpwszUserNDomain = new WCHAR[dwSize];   // 2 for '\\' and '\0'
	if (!lpwszUserNDomain) 
	{
	    iRetVal = PVA_NOMEMORY;
	    goto End;
	}

    _snwprintf(lpwszUserNDomain,dwSize -1,L"%s\\%s",m_pSession->CSession::m_szDomain,m_pSession->CSession::m_szUser);
    lpwszUserNDomain[dwSize -1] = L'\0';
    
	bIsGuest = IsTheAccount(lpwszUserNDomain, DOMAIN_USER_RID_GUEST);

    _chVERIFY2( iStatus = WideCharToMultiByte( GetConsoleCP(), 0, m_pSession->CSession::m_szDomain, 
    -1, m_pSession->m_pszDomain, MAX_PATH , NULL, NULL ) );
    _TRACE(TRACE_DEBUGGING,"Domain:%s",m_pSession->m_pszDomain);
	delete[] lpwszUserNDomain;
	return bIsGuest ? PVA_GUEST : PVA_SUCCESS;
End:
	m_pSession->CSession::m_szDomain[0] = L'\0';
	m_pSession->CSession::m_szUser[0] = L'\0';
	//PREFIX reports error - leaking memory. But we are correctly freeing all the memory. Won't fix.
	return iRetVal;
}

int 
CIoHandler::AuthenticateUser( void )
{
    LPWSTR szPassWd = NULL;
    
    ConvertSChartoWChar( m_pSession->CSession::m_pszPassword, &szPassWd );

    /* when LogonUserA is given user name etc as per code page differen from 
     * 1252, it was not succeding. May be the conversion from say 850 to
     * unicode is not happening. It is assuming The i/p is as per 1252.
     * Is it possible? 
     * So, Converting everything to UNICODE */

    m_fLogonUserResult = LogonUser( m_pSession->CSession::m_szUser,
    					m_pSession->CSession::m_szDomain, szPassWd,
                        LOGON32_LOGON_INTERACTIVE, LOGON32_PROVIDER_DEFAULT,
                        &(m_pSession->CSession::m_hToken) ) ;
    
    SfuZeroMemory(szPassWd, sizeof(WCHAR)*lstrlenW(szPassWd));

    delete[] szPassWd;
    
    //scratch out the password
    SfuZeroMemory( m_pSession->CSession::m_pszPassword, 
        strlen( m_pSession->CSession::m_pszPassword ));
    if (m_pSession->CSession::m_szUser[0]!= L'\0')
    {
        SfuZeroMemory( m_pSession->CSession::m_szUser, 
            wcslen( m_pSession->CSession::m_szUser)*sizeof(WCHAR));
    }
    return ( m_fLogonUserResult );
} 

//When this message is received by the server, it will check for license
//and replies
bool
CIoHandler::SendDetailsAndAskForLicense()
{
    bool bRetVal = true;

    if( !GetAuthenticationId( m_pSession->CSession::m_hToken,
        &m_pSession->CSession::m_AuthenticationId ) )
    {
        return ( FALSE );
    }

    //GetUserName(); //For NTLM 

    DWORD dwDomainLength = strlen( m_pSession->m_pszDomain ) + 1;
    DWORD dwUserLength   = strlen( m_pSession->m_pszUserName ) + 1;
    DWORD dwPeerLength   = strlen( m_pSession->m_szPeerHostName ) + 1;
    DWORD dwAuthIdLength = sizeof( m_pSession->m_AuthenticationId );
    DWORD dwTotal        = dwDomainLength + dwUserLength + dwPeerLength + 
                           dwAuthIdLength;

    UCHAR *lpData = NULL;
    UCHAR *lpPtrData = NULL;

    lpData = new UCHAR[ IPC_HEADER_SIZE + dwTotal ];
    if( !lpData )
    {
        return ( FALSE );
    }
    
    lpPtrData = lpData;

    lpPtrData[ 0 ] = SESSION_DETAILS;
    lpPtrData++;
    memcpy( lpPtrData, &dwTotal, sizeof( DWORD ) );
    lpPtrData += sizeof( DWORD );
    memcpy( lpPtrData, m_pSession->m_pszDomain, dwDomainLength );
    lpPtrData += dwDomainLength;
    memcpy( lpPtrData, m_pSession->m_pszUserName, dwUserLength );
    lpPtrData += dwUserLength;
    memcpy( lpPtrData, m_pSession->m_szPeerHostName, dwPeerLength );
    lpPtrData += dwPeerLength;
    memcpy( lpPtrData, &( m_pSession->m_AuthenticationId ), dwAuthIdLength );
    
    dwTotal += IPC_HEADER_SIZE;
    //As a response to this server indicates the availability of License
    bRetVal = WriteToServer( SESSION_DETAILS, dwTotal, lpData );
    delete[] lpData;

    return( bRetVal );
}

int 
CIoHandler::CheckLicense()
{
    bool fIsAdmin = false;
    bool fIsMemberOfTelnetClients = false;
    if( !( m_pSession->CheckGroupMembership( &fIsAdmin, 
                        &fIsMemberOfTelnetClients ) ) )
    {
        return ( FALSE );    
    }
    
    if( !fIsAdmin && !fIsMemberOfTelnetClients )
    {
        return ( NOT_MEMBER_OF_TELNETCLIENTS_GROUP );
    }
    if( !SendDetailsAndAskForLicense() )
    {
        return( FALSE );
    }
    return( WAIT_FOR_SERVER_REPLY );
}

/*++
    Sends a termination string to the client.
--*/
void 
CIoHandler::SendTerminateString(char *pszMessageBuffer)
{
    m_SocketControlState = STATE_TERMINATE;
    CIoHandler::m_fShutDownAfterIO = true;
    
    WriteToSocket( ( PUCHAR ) pszMessageBuffer, strlen( pszMessageBuffer ) );
}

#define HALF_K 512

bool
CIoHandler::IsTimedOut ( )
{
    //because we entered this function, we already know that we are not
    //in STATE_SESSION. the next block of code checks whether more than 
    //PRE_SESSION_STATE_TIMEOUT seconds has elapsed since the telnet client
    //first connected to us. if so, we deem that the client was given enough
    //time for 1) reasonable negotiation, 2) entering name & password, but 
    //STATE_SESSION was not reached.

    if (0 == g_dwPreSessionStateTimeOut)
    {
        return false;
    }

    char szMessageBuffer[HALF_K + 1];

    if (_snprintf( szMessageBuffer, HALF_K, "\r\n%s\r\n%s", TIMEOUT_STR, TERMINATE ) < 0)
    {
        szMessageBuffer[HALF_K] = '\0';
    }

    if( GetTickCount() - m_pSession->CSession::m_dwTickCountAtLogon > 
        g_dwPreSessionStateTimeOut )
    {
        SendTerminateString(szMessageBuffer);
        return ( true );
    }  
    return( false );
}

CIoHandler::IO_OPERATIONS 
CIoHandler::ProcessDataFromSocket ( DWORD dwIoSize )
{
    char szMessageBuffer[HALF_K + 1];
    IO_OPERATIONS ioOpsToPerform = 0;
    DWORD dwCurrentOffset;
    DWORD dwInputLength;
    bool bContinue;

    // Initialize Data
    dwCurrentOffset = (DWORD)(m_pReadFromSocketBufferCursor - m_ReadFromSocketBuffer);
    dwInputLength = dwIoSize + dwCurrentOffset;
    if(dwInputLength >= sizeof( m_ReadFromSocketBuffer ) )
    {
    /*++
        MSRC 678 : Telnet Server Crash/BO with >4300 characters and a backspace.
        Fix : If Input length reaches it's limit, we terminate the session giving a message :
            The Input Line is too long.
    --*/
        if (_snprintf( szMessageBuffer, HALF_K, "\r\n%s",LONG_SESSION_DATA) < 0)
        {
            szMessageBuffer[HALF_K] = '\0';
        }
        SendTerminateString(szMessageBuffer);
        ioOpsToPerform |= WRITE_TO_SOCKET;
        return ( ioOpsToPerform );

    }

    m_ReadFromSocketBuffer[ dwInputLength ] = '\0';

    ioOpsToPerform = READ_FROM_SOCKET;  
    if( IsTimedOut() )
    {
        ioOpsToPerform |= WRITE_TO_SOCKET;
        return ( ioOpsToPerform );
    }

    do {
        // we break unless someone is sure that we should continue.
        bContinue = false;

        switch ( m_SocketControlState )
        {
        case STATE_INIT:
            // we are not in a position to consume anything yet, so
            // make sure we save the stuff for later on !!
            dwCurrentOffset = dwInputLength;
            m_pReadFromSocketBufferCursor += dwIoSize;
            break;

        case STATE_NTLMAUTH: 
            break;

        case STATE_CHECK_LICENSE:
            m_iResult = CheckLicense();
            m_SocketControlState = STATE_LICENSE_AVAILABILITY_KNOWN;
            
            if( m_iResult == FALSE ) 
            {
                m_iResult = DENY_LICENSE;
            }
            else if ( m_iResult == WAIT_FOR_SERVER_REPLY )
            {
               do
               {
                   //We will have to get a reply from server regarding license
                   TlntSynchronizeOn(m_oReadFromPipe.hEvent);
                   OnReadFromPipeCompletion(); 
               }
               while( m_iResult == WAIT_FOR_SERVER_REPLY );
            }

            bContinue = true;
            break;

        case STATE_LICENSE_AVAILABILITY_KNOWN:
            if( m_iResult != ISSUE_LICENSE )
            {
                //We should not log at the time of logging off.
                m_pSession->m_fLogonUserResult = 0;
            }
            if( m_iResult )
            {
                switch( m_iResult ) {
                case ISSUE_LICENSE:
                    szMessageBuffer[0] = 0;
                    m_pSession->CRFCProtocol::m_fPasswordConcealMode  = false;
                    m_SocketControlState = STATE_VTERM_INIT_NEGO;
                    bContinue = true;
#ifdef LOGGING_ENABLED                            
                    m_pSession->LogIfOpted( SUCCESS, LOGON );
#endif
                    break;
#if BETA
                case LICENSE_EXPIRED:
                    m_pSession->CRFCProtocol::m_fPasswordConcealMode  = false;
                    if (_snprintf( szMessageBuffer, HALF_K, "%s%s", LICENSE_EXPIRED_STR, 
                        TERMINATE ) < 0)
                    {
                        szMessageBuffer[HALF_K] = '\0';
                    }
                    m_SocketControlState = STATE_TERMINATE;
                    CIoHandler::m_fShutDownAfterIO = true;
                    break;
#endif
                case NOT_MEMBER_OF_TELNETCLIENTS_GROUP:
                    m_pSession->CRFCProtocol::m_fPasswordConcealMode  = false;
                    if (_snprintf( szMessageBuffer, HALF_K, "%s%s", 
                            NOT_MEMBER_OF_TELNETCLIENTS_GROUP_STR, TERMINATE) < 0)
                    {
                        szMessageBuffer[HALF_K] = '\0';
                    }
                    m_SocketControlState = STATE_TERMINATE;
                    CIoHandler::m_fShutDownAfterIO = true;
                    break;

                case DENY_LICENSE:
                    szMessageBuffer[0] = 0;
                    m_pSession->CRFCProtocol::m_fPasswordConcealMode  = false;
                    m_SocketControlState = STATE_TERMINATE;
                    CIoHandler::m_fShutDownAfterIO = true;
                    break;
                }

                if ( *szMessageBuffer )
                {
                    WriteToSocket((PUCHAR)szMessageBuffer, strlen(szMessageBuffer));
                    ioOpsToPerform |= WRITE_TO_SOCKET ;
                }
            }
            break;

        case STATE_VTERM_INIT_NEGO:

            {
                // kick off the term type negotiation.
                // Term Type negotiation happens after login for several reasons.

                int nBytesToWrite = 0;

                m_SocketControlState = STATE_VTERM;

                // Some clients are proactive and send us WILL TERMTYPE, in that
                // case we already know the Client can do term type and we start
                // the subnegotiation. else we ask if start the whole termtype process.
                if ( m_pSession->CRFCProtocol::m_remoteOptions[ TO_TERMTYPE ] )
                {
                    DO_TERMTYPE_SUB_NE( szMessageBuffer );
                    nBytesToWrite = 6;
                }
                else
                {
                    m_pSession->CRFCProtocol::m_fWaitingForResponseToA_DO_ForTO_TERMTYPE = true;
                    DO_OPTION( szMessageBuffer, TO_TERMTYPE );
                    nBytesToWrite = 3;
                }

                WriteToSocket((PUCHAR)szMessageBuffer, nBytesToWrite);
                ioOpsToPerform |= WRITE_TO_SOCKET ;
            }
            break;


        case STATE_VTERM:
            // We Wait here until we know what term type to use. This is a
            // no return point - after this the User can't change the term type.
            if( m_pSession->CSession::m_bNegotiatedTermType )
            {
                m_SocketControlState = STATE_SESSION;

                if( !m_pSession->CShell::StartUserSession( ) )
                {
                    m_SocketControlState = STATE_TERMINATE;
                    CIoHandler::m_fShutDownAfterIO = true;
                    if (_snprintf( szMessageBuffer, HALF_K, "%s%s", SESSION_INIT_FAIL, 
                            TERMINATE) < 0)
                    {
                        szMessageBuffer[HALF_K] = '\0';
                    }
                    WriteToSocket((PUCHAR)szMessageBuffer, 
                                        strlen( szMessageBuffer ) );
                    ioOpsToPerform |= WRITE_TO_SOCKET ;
                }
                m_pSession->FreeInitialVariables();
            }

            break;

        case STATE_BANNER_FOR_AUTH:
            CHAR szTmp[ MAX_PATH + 1]; 
            strncpy(szTmp, LOGIN_BANNER, MAX_PATH);
            szTmp[MAX_PATH] = '\0';

            WriteToSocket( ( PUCHAR )szTmp, strlen( szTmp ) );
            ioOpsToPerform |= WRITE_TO_SOCKET ;
            m_SocketControlState = STATE_WAIT_FOR_ENV_OPTION;
            bContinue = true;
            break;

        case STATE_WAIT_FOR_ENV_OPTION:
            if( m_bWaitForEnvOptionOver )
            {
                m_SocketControlState = STATE_LOGIN_PROMPT;
                bContinue = true;
            }
            break;

        case STATE_LOGIN_PROMPT:
            if( !m_pSession->CRFCProtocol::m_bIsUserNameProvided && m_bOnlyOnce )
            {
                m_bOnlyOnce = false;
                WriteToSocket( ( PUCHAR )LOGIN_REQUEST, strlen( LOGIN_REQUEST ) );
                ioOpsToPerform |= WRITE_TO_SOCKET ;
            }

            m_SocketControlState = STATE_AUTH_NAME;            

        case STATE_AUTH_NAME:   //fall thru                
        case STATE_AUTH_PASSWORD:
            do
            {
                // Processing of Command Input
                if( ioOpsToPerform & LOGON_DATA_UNFINISHED ) 
                    ioOpsToPerform ^= LOGON_DATA_UNFINISHED;

                ioOpsToPerform = ProcessCommandLine( &dwInputLength, 
                    &dwCurrentOffset, ioOpsToPerform );

                if( m_pSession->CRFCProtocol::m_bIsUserNameProvided )
                {
                    ioOpsToPerform |= LOGON_COMMAND;
                }

                // If there is a completed command line; deal with it
                if( ioOpsToPerform & LOGON_COMMAND )  
                {
                    ioOpsToPerform = ProcessAuthenticationLine( &dwInputLength, 
                            &dwCurrentOffset, ioOpsToPerform );
                    ioOpsToPerform  ^= LOGON_COMMAND;
                }

            } while( ioOpsToPerform & LOGON_DATA_UNFINISHED );
            
            if ( m_SocketControlState != STATE_AUTH_NAME && 
                m_SocketControlState != STATE_AUTH_PASSWORD )
            {
                bContinue = true;
            }

            break;
        default:
            break;
        }

    } while ( bContinue );

    return ( ioOpsToPerform );
}

bool
CIoHandler::ProcessUserDataReadFromSocket ( DWORD dwIoSize )
{
    DWORD dwCurrentOffset;
    DWORD dwInputLength;

    if( _strcmpi( m_pSession->m_pszTermType, "VTNT" ) != 0 )
    {
        dwCurrentOffset = (DWORD)(m_pReadFromSocketBufferCursor- m_ReadFromSocketBuffer);
        dwInputLength = dwIoSize + dwCurrentOffset;
        if(dwInputLength >= sizeof( m_ReadFromSocketBuffer ) )
        {
            dwInputLength = sizeof( m_ReadFromSocketBuffer ) - 1;
        }        
        m_ReadFromSocketBuffer[ dwInputLength ] = '\0';
        m_pReadFromSocketBufferCursor = m_ReadFromSocketBuffer;


        if( dwIoSize >= sizeof( m_ReadFromSocketBuffer ) )
        {
           dwIoSize =  sizeof( m_ReadFromSocketBuffer ) -1;
        }
        m_ReadFromSocketBuffer[ dwIoSize ] = '\0';
    } 

    if( !m_pSession->CScraper::EmulateAndWriteToCmdConsoleInput() )
    {
        return( FALSE );
    }
    
    return ( TRUE );
}


CIoHandler::IO_OPERATIONS 
CIoHandler::OnDataFromSocket ( )
{
    IO_OPERATIONS ioOpsToPerform1 = 0;
    IO_OPERATIONS ioOpsToPerform2 = 0;

    // filter the data at the RFCProtocol handler 
    ioOpsToPerform1 = m_pSession->CRFCProtocol::
                    ProcessDataReceivedOnSocket( &m_dwReadFromSocketIoLength );

    if( m_SocketControlState != STATE_SESSION )
    {
        ioOpsToPerform2 = ProcessDataFromSocket( m_dwReadFromSocketIoLength ); 
    }
    else
    {
        if( m_dwReadFromSocketIoLength )
        {
            if( !ProcessUserDataReadFromSocket( m_dwReadFromSocketIoLength ) )
            {
                ioOpsToPerform2 |= IO_FAIL;
            }
        }
    }
    return ( ioOpsToPerform1 | ioOpsToPerform2 );
}


bool
CIoHandler::WriteToServer ( UCHAR ucMsg, DWORD dwMsgSize, LPVOID lpData )
{
    if( lpData )
    {
        //The whole record should be available with the header.
        //Otherwise, unnecessary allocations have to be done
        if( !WriteToPipe( m_hWritePipe, lpData, dwMsgSize, &m_oWriteToPipe ) )
        {
            return( FALSE );
        }
    }
    else
    {
        if( !WriteToPipe( m_hWritePipe, ucMsg, &m_oWriteToPipe ) )
        {
            return( FALSE );
        }
    }

    return( TRUE );
}

bool 
CIoHandler::IssueReadOnPipe()
{
    _chASSERT( m_pucReadBuffer );
    if( m_hReadPipe == INVALID_HANDLE_VALUE || !m_pucReadBuffer)
    {
        return ( FALSE );
    }    

    if( !ReadFile( m_hReadPipe, m_pucReadBuffer, m_dwRequestedSize, 
                &m_dwReadFromPipeIoLength, &m_oReadFromPipe ) )
    {
        DWORD dwError = GetLastError( );
        if ( ( dwError != ERROR_MORE_DATA ) && ( dwError != ERROR_IO_PENDING ) )
        {
            LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, MSG_ERR_READPIPE, dwError );
            _TRACE( TRACE_DEBUGGING, " Error: ReadFile ( IssueReadOnPipe) -- 0x%1x ", dwError );
            return ( FALSE );
        }
    }
    return( TRUE );
}

bool
CIoHandler::IssueFirstReadOnPipe ( )
{
    if( m_hReadPipe == INVALID_HANDLE_VALUE )
    {
        return ( FALSE );
    }

    if( !ReadFile( m_hReadPipe, &m_protocolInfo, sizeof( m_protocolInfo ), 
                &m_dwReadFromPipeIoLength, &m_oReadFromPipe ) )
    {
        DWORD dwError = GetLastError( );
        if( dwError != ERROR_IO_PENDING ) 
        {
            LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, MSG_ERR_READPIPE, dwError );
            _TRACE( TRACE_DEBUGGING, " Error: ReadFile ( IssueFirstReadOnPipe ) -- 0x%1x ", dwError );
            return ( FALSE );
        }
    }
    return( TRUE );
}

bool 
CIoHandler::GetAndSetSocket ( )
{
    int iAddressFamily = m_protocolInfo.iAddressFamily;
    m_sSocket = WSASocket( iAddressFamily, SOCK_STREAM, 0, &m_protocolInfo, 
                                                NULL, NULL);
    if( INVALID_SOCKET == m_sSocket )
    {
        DecodeWSAErrorCodes( WSAGetLastError() );//It logs and traces
        return ( FALSE );
    }
    _chVERIFY2( SetHandleInformation( ( HANDLE ) m_sSocket, 
                0, HANDLE_FLAG_INHERIT ) );

    //mark the socket non-blocking
    unsigned long ulNonBlocked = 1;
    if( ioctlsocket( m_sSocket, FIONBIO, (u_long FAR*) &ulNonBlocked ) ==
        SOCKET_ERROR )
    {
        _TRACE( TRACE_DEBUGGING, "Error: ioctlsocket() -- 0x%1x", 
                WSAGetLastError() );
        return ( FALSE );
    }

    INT     izero = 0;
    DWORD   dwStatus;

    {
        BOOL        value_to_set = TRUE;

        setsockopt(
            m_sSocket, 
            SOL_SOCKET, 
            SO_DONTLINGER, 
            ( char * )&value_to_set, 
            sizeof( value_to_set )
            );
    }

    dwStatus = SafeSetSocketOptions(m_sSocket);
    if(dwStatus == SOCKET_ERROR)
    {
        _TRACE( TRACE_DEBUGGING, "Error: setsockopt() : %lu", GetLastError() );
        return ( FALSE );
    }

    //Set send buffer size to zero
    dwStatus = setsockopt( m_sSocket, SOL_SOCKET, SO_SNDBUF, ( char* ) &izero,
                sizeof( izero ) );
    if( dwStatus == SOCKET_ERROR )
    {
        _TRACE( TRACE_DEBUGGING, "Error: setsockopt() : %lu", GetLastError() );
        return ( FALSE );
    }

    //This needs to be removed when we start handling urgent data as per RFC
    //Make OOB inline
    izero = TRUE;
    dwStatus = setsockopt( m_sSocket, SOL_SOCKET, SO_OOBINLINE, ( char* ) &izero,
                sizeof( izero ) );
    if( dwStatus == SOCKET_ERROR )
    {
        _TRACE( TRACE_DEBUGGING, "Error: setsockopt() : %lu", GetLastError() );
        return ( FALSE );
    }

    return( TRUE );
}

void
CIoHandler::DisplayOnClientNow()
{
    if( m_pSession->CScraper::m_dwPollInterval != INFINITE )
    {
        //Scraper has been initialized;
        m_pSession->CScraper::OnWaitTimeOut();
    }
}

void
CIoHandler::SendMessageToClient( LPWSTR szMsg, bool bNeedHeader )
{
    _chASSERT( szMsg );

    if( !szMsg )
    {
        return;
    }

    LPTSTR szHeader = NULL;

    if( bNeedHeader )
    {
        GetHeaderMessage( &szHeader );
    }

    if( m_pSession->CSession::m_bIsStreamMode || m_SocketControlState != STATE_SESSION )
    {
        DWORD dwNumBytesWritten = 0;

        if( szHeader && bNeedHeader )
        {
            WriteMessageToClientDirectly( szHeader );
            FinishIncompleteIo( ( HANDLE ) m_sSocket, &m_oWriteToSocket, &dwNumBytesWritten );
        }

        WriteMessageToClientDirectly( szMsg );
        FinishIncompleteIo( ( HANDLE ) m_sSocket, &m_oWriteToSocket, &dwNumBytesWritten );

    }
    else
    {
        if( szHeader && bNeedHeader )
        {
            m_pSession->CScraper::WriteMessageToCmd( szHeader );
        }

        m_pSession->CScraper::WriteMessageToCmd( szMsg );
        DisplayOnClientNow();
    }
    
    delete[] szHeader;
}

bool
CIoHandler::HandlePipeData ( )
{
    bool bRetVal = TRUE;

    m_dwRequestedSize = IPC_HEADER_SIZE; //How much data to read in the 
                                                // next call
    switch( m_ReadFromPipeBuffer[0] )
    {
        case TLNTSVR_SHUTDOWN: 
            SendMessageToClient( SERVER_SHUTDOWN_MSG, NEED_HEADER );
            return( FALSE ); //This should take us out of loop in 
                                    //WaitForIo

        case GO_DOWN:
            SendMessageToClient( GO_DOWN_MSG, NO_HEADER );
            return( FALSE );

        case SYSTEM_SHUTDOWN:
            SendMessageToClient( SYSTEM_SHUTDOWN_MSG, NEED_HEADER );            
            return( FALSE );

        case LICENSE_AVAILABLE:
            m_iResult = ISSUE_LICENSE; 
            break;
            
        case LICENSE_NOT_AVAILABLE:
            m_iResult = DENY_LICENSE;
            break;
            
        case OPERATOR_MESSAGE:
            if( !HandleOperatorMessage() )
            {
                bRetVal = FALSE;
            }

            break; 
        default:
            break;
    }

    return ( bRetVal );
}

/* Generally we read data on pipe into a IPC_HEADER_SIZE buffer of m_ReadFromPipeBuffer.
When, it is an operator message we issue async read into a specially allocated block and free on 
actual reception */

bool
CIoHandler::HandleOperatorMessage()
{
    bool bRetVal = TRUE;

    if ( m_bIpcHeader )
    {
        m_bIpcHeader = false;
        memcpy( &m_dwRequestedSize, m_ReadFromPipeBuffer + sizeof( UCHAR ), sizeof( DWORD ) );
        m_pucReadBuffer = new UCHAR[ m_dwRequestedSize + wcslen( FOOTER ) + 2 ];
        if( !m_pucReadBuffer )
        {
            bRetVal = FALSE;
        }
    }
    else
    {

        wcscat( ( LPWSTR )m_pucReadBuffer, FOOTER );
        SendMessageToClient( ( LPWSTR )m_pucReadBuffer, NEED_HEADER );
        delete[] m_pucReadBuffer;
        m_pucReadBuffer = m_ReadFromPipeBuffer;
        m_bIpcHeader = true;
    }
    
    return( bRetVal );
}

bool
CIoHandler::OnReadFromPipeCompletion ( )
{
    bool bRetVal = FALSE;

    if( m_fFirstReadFromPipe )
    {
        m_fFirstReadFromPipe = false;
        if( GetAndSetSocket() )
        {
            m_pSession->CollectPeerInfo();
            m_pSession->CRFCProtocol::InitialNegotiation();
            //The negotiation leaves the data in the buffer
            if( WriteToClient( ) )
            {
                bRetVal = TRUE;
                m_pSession->AddHandleToWaitOn( m_oReadFromSocket.hEvent );
                IssueReadFromSocket();
            }
        }
    }
    else
    {
        bRetVal = HandlePipeData();
    }
    if( bRetVal == TRUE )
    {
        bRetVal = IssueReadOnPipe( );
    }
        
    return ( bRetVal );
}

bool
CIoHandler::WriteToClient ( )
{
    DWORD dwBytesWritten;
    if( m_dwWriteToSocketIoLength > 0 && (!WriteFile( ( HANDLE ) m_sSocket, m_WriteToSocketBuff, 
                m_dwWriteToSocketIoLength, &dwBytesWritten, &m_oWriteToSocket )))
    {
        DWORD dwErr;
        if( ( dwErr = GetLastError( ) ) != ERROR_IO_PENDING )
        {
            if( dwErr != ERROR_NETNAME_DELETED ) 
            {
                LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, MSG_ERR_WRITESOCKET, dwErr );
                _TRACE( TRACE_DEBUGGING, "Error: WriteFile(WriteToClient) -- 0x%1x", dwErr );
            }
            return( FALSE );
        }

    }        

    m_dwWriteToSocketIoLength = 0;

    if( m_fShutDownAfterIO )
    {
        return( FALSE ); //This Should lead to exit from WaitForIo loop
    }
    return ( TRUE );
}

bool
CIoHandler::IssueReadFromSocket ( )
{

    DWORD dwRequestedIoSize = AVAILABE_BUFFER_SIZE( m_ReadFromSocketBuffer,
                                m_pReadFromSocketBufferCursor );
    if( !ReadFile( ( HANDLE ) m_sSocket, m_pReadFromSocketBufferCursor, 
        dwRequestedIoSize, &m_dwReadFromSocketIoLength, &m_oReadFromSocket ) )
    {
        DWORD dwError = GetLastError( );
        //ERROR_NETNAME_DELETED results when the client aborts the connection
        if( ( dwError != ERROR_MORE_DATA ) && ( dwError != ERROR_IO_PENDING ) )
        {
            if( dwError != ERROR_NETNAME_DELETED)
            {
                LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, MSG_ERR_READSOCKET, dwError );
                _TRACE( TRACE_DEBUGGING, " Error: ReadFile(IssueReadFromSocket) -- 0x%1x ", dwError );
            }
            return ( FALSE );
        }
    }
    
    return( TRUE );
}

bool 
CIoHandler::OnReadFromSocketCompletion ( )
{
    IO_OPERATIONS   ioOpsToPerform = 0;
    BOOL            dwStatus = 0;

    _chVERIFY2( dwStatus = GetOverlappedResult( ( HANDLE )m_sSocket, 
                &m_oReadFromSocket, &m_dwReadFromSocketIoLength, FALSE ) );
    if( !dwStatus )
    {
        return( FALSE );
    }

    if( m_dwReadFromSocketIoLength == 0 )
    {
        return( FALSE );
    }

    ioOpsToPerform = OnDataFromSocket( );

    if( ( ioOpsToPerform & WRITE_TO_SOCKET ) )
    {
        if( !WriteToClient( ) )
        {
            return( FALSE );
        }
    }

    if( ioOpsToPerform & IO_FAIL )
    {
        _chASSERT( 0 );

        WriteMessageToClientDirectly( TEXT( BUGGY_SESSION_DATA ) );
        WriteToClient( );

        return( FALSE );
    }
    
    return ( IssueReadFromSocket() );
}

/*There are 2 ways to send data to client.
1. Write to cmd. Let scraper send it.
2. Write to socket directly. The following is the implementation.
*/
void 
CIoHandler::WriteMessageToClientDirectly( LPWSTR szMsg )
{
    LPSTR szBuf = NULL;
    DWORD dwSize = 0;
    DWORD dwNumBytesWritten = 0;
    int iRet = 0;

    _chASSERT( szMsg );
    if( !szMsg )
    {
        goto End;
    }


    _chVERIFY2( dwSize = WideCharToMultiByte( GetConsoleCP(), 0, szMsg, -1, NULL, 0, NULL, NULL ) );
    szBuf = new CHAR[ dwSize ];
    if( szBuf )
    {
        iRet = WideCharToMultiByte( GetConsoleCP(), 0, szMsg, -1, szBuf, dwSize, NULL, NULL );
        _chVERIFY2(iRet);
        if(!iRet)
        {
            goto End;
        }
        if( !FinishIncompleteIo( ( HANDLE ) m_sSocket, &( m_oWriteToSocket ), &dwNumBytesWritten ) )
        {
            goto End;
        }

        StuffEscapeIACs( m_WriteToSocketBuff, ( PUCHAR )szBuf, &dwSize );
        m_dwWriteToSocketIoLength = dwSize;
        WriteToClient( );
    }
End:
    if(szBuf)
    {
        delete[] szBuf;
    }
    return;
}

void
CIoHandler::UpdateIdleTime( UCHAR ucChangeIdleTime )
{
    WriteToServer( ucChangeIdleTime, 0, NULL );
}

//caller has to free *szHeader
bool CIoHandler::GetHeaderMessage( LPWSTR *szHeader )
{
    bool bRetVal = false;
    UDATE uSysDate; //local time
    DATE  dtCurrent;
    DWORD dwSize = 0;
    BSTR  szDate    = NULL;
    WCHAR szMachineName[ MAX_COMPUTERNAME_LENGTH + 1];

    _chASSERT( g_szHeaderFormat );
    if( !szHeader )
    {
        _chASSERT( szHeader );
        goto ExitOnError;
    }

    *szHeader = NULL;
    GetLocalTime( &uSysDate.st );
    if( VarDateFromUdate( &uSysDate, VAR_VALIDDATE, &dtCurrent ) != S_OK )
    {
        goto ExitOnError;
    }

    if( VarBstrFromDate( dtCurrent,
            MAKELCID( MAKELANGID( LANG_NEUTRAL, SUBLANG_SYS_DEFAULT ), SORT_DEFAULT ),
            LOCALE_NOUSEROVERRIDE, &szDate ) != S_OK )
    {
        goto ExitOnError;
    }

    *szHeader = new WCHAR[ wcslen( g_szHeaderFormat ) + wcslen( szDate ) +
                        MAX_COMPUTERNAME_LENGTH + 1 ];
    if( !*szHeader )
    {
        goto ExitOnError;
    }

    //Get Computer name
    dwSize = sizeof( szMachineName )/sizeof(WCHAR);
    szMachineName[0] = L'\0';
    if( !GetComputerName( szMachineName, &dwSize ) )
    {
        szMachineName[0] = L'\0';
    }

    //Form the message
    wsprintf( *szHeader, g_szHeaderFormat, szMachineName, szDate );
    bRetVal = true;

ExitOnError:
    SysFreeString( szDate );
    return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsess\scraper.cpp ===
// scraper.cpp : This file contains the
// Created:  Dec '97
// History:
// Copyright (C) 1997 Microsoft Corporation
// All rights reserved.
// Microsoft Confidential

#include <windows.h>
#include <wincon.h>
#include <msgFile.h>
#include <telnetd.h>
#include <debug.h>
#include <regutil.h>
#include <TermCap.h>
#include <Scraper.h>
#include <Session.h>
#include <TlntUtils.h>
#include <Ipc.h>
#include <vtnt.h>

#define ONE_KB 1024

#pragma warning( disable: 4706 )
#pragma warning( disable: 4127 )

using namespace _Utils;
using CDebugLevel::TRACE_DEBUGGING;
using CDebugLevel::TRACE_HANDLE;
using CDebugLevel::TRACE_SOCKET;

WORD wRows;
WORD wCols;
COORD coExpectedCursor = { ~0, ~0 };

extern HANDLE       g_hSyncCloseHandle;

CTermCap* pTermCap = 0;
LPSTR lpszCMStr1 = 0;
LPSTR lpszCMStr2 = 0;

CHAR szSGRStr[25]; //the string is of the form <ESC>[ Ps m
bool fNegativeImage = false, fBold = false;
WORD wExistingAttributes = 0;
WORD wDefaultAttributes  = 0;
    
static  PUCHAR  g_pucSendBuffer = 0;
static  DWORD   g_dwSendBufferSize = 0;
static  PUCHAR  g_pucSendInsertPoint = 0;

void
CScraper::DeleteCMStrings()
{
    delete[] lpszCMStr1;
    delete[] lpszCMStr2;
}
void
CScraper::LoadStrings()
{
    //ce --> String to clear from the cursor to the end of the line
    lpszCMStr1 = pTermCap->GetString( "ce" );

    //cm --> String to position the cursor at row r, column c
    lpszCMStr2 = pTermCap->GetString( "cm" );
}

CScraper::CScraper()
{
    pLastSeen = NULL;
    pCurrent = NULL;
    m_dwHowLongIdle = 0;
    m_bCheckForScrolling = 1;
    m_dwTerm = 0; 
    m_hConBufIn  = NULL;
    m_hConBufOut = NULL;
}

CScraper::~CScraper()
{
    // Cleanup before exit  
    TELNET_CLOSE_HANDLE( m_hConBufIn );
    delete [] pCurrent;
    delete [] pLastSeen;
    delete [] g_pucSendBuffer;
    DeleteCMStrings();
    delete pTermCap;
}

bool 
CScraper::InitializeNonVtntTerms()
{
    if( !pTermCap->LoadEntry( m_pSession->m_pszTermType ) )
    {
        LPWSTR szTermType = NULL;
        _TRACE( TRACE_DEBUGGING, "TermCap LoadEntry() failed : %s", 
                                        m_pSession->m_pszTermType );
        ConvertSChartoWChar( m_pSession->m_pszTermType, &szTermType );
        LogEvent( EVENTLOG_ERROR_TYPE, MSG_NOENTRY_IN_TERMCAP, szTermType );

        if( !pTermCap->LoadEntry( VT100 ) )
        {
            _TRACE( TRACE_DEBUGGING, "TermCap LoadEntry() failed" );
            LogEvent( EVENTLOG_ERROR_TYPE, MSG_ERROR_READING_TERMCAP, _T("") );
            return( FALSE ); 
        }

        _TRACE( TRACE_DEBUGGING, "TermType is vt100");
    }

    LoadStrings();

    if( ( lpszCMStr1 == NULL ) || ( lpszCMStr2 == NULL )  )
    {
        DeleteCMStrings();
        if( !pTermCap->LoadEntry( VT100 ) )
        {
            _TRACE( TRACE_DEBUGGING, "TermCap LoadEntry() failed" );
            LogEvent( EVENTLOG_ERROR_TYPE, MSG_ERROR_READING_TERMCAP, _T("") );
        }
        else
        {
            _TRACE( TRACE_DEBUGGING, "TermType is vt100");
            LogEvent( EVENTLOG_ERROR_TYPE, MSG_NOENTRY_IN_TERMCAP, _T("") );
            LoadStrings();
        }
    }  

    pTermCap->ProcessString( &lpszCMStr1 );
    pTermCap->ProcessString( &lpszCMStr2 );

    if( m_pSession->CSession::m_bIsStreamMode )
    {
        //ask for crlf for an enter when in stream mode

        //Set new line mode for the virtual terminal
        CHAR szLNMString[ SMALL_ARRAY + 1];

        _snprintf( szLNMString, SMALL_ARRAY, "%c[%dh", VT_ESC, LNM );
        szLNMString[SMALL_ARRAY] = '\0';

        SendString( szLNMString );
    }

    return( TRUE );
}

bool AllocateSendBuffer( )
{
    g_dwSendBufferSize = DEFAULT_SEND_BUFFER_SIZE;
    g_pucSendBuffer = new UCHAR[g_dwSendBufferSize];
    g_pucSendInsertPoint = g_pucSendBuffer;
    if( !g_pucSendBuffer )
    {
        return( FALSE );
    }
    SfuZeroMemory((LPVOID)g_pucSendBuffer, g_dwSendBufferSize);
    return( TRUE );
}

bool
CScraper::InitTerm()
{
    //The following is just to avoid recurring string comparisions
    m_dwTerm = TERMVT100;
    if( _stricmp( m_pSession->m_pszTermType, VTNT ) == 0 )
    {
        m_dwTerm = TERMVTNT;
    }
    else if ( _stricmp( m_pSession->m_pszTermType, VT52 ) == 0 )
    {
        m_dwTerm = TERMVT52;
    }
    else if ( _stricmp( m_pSession->m_pszTermType, VT100 ) == 0 )
    {
        m_dwTerm = TERMVT100;
    }
    else if ( _stricmp( m_pSession->m_pszTermType, VT80 ) == 0 )
    {
        m_dwTerm = TERMVT80;
    }
    else if ( _stricmp( m_pSession->m_pszTermType, ANSI ) == 0 )
    {
        m_dwTerm = TERMANSI;
    }
                
    if( !( m_dwTerm & TERMVTNT ) )
    {
        if( !InitializeNonVtntTerms() )
        {
            return( FALSE );
        }
    }

    SfuZeroMemory( &LastCSBI, sizeof( LastCSBI ) );

    if( g_pucSendBuffer == NULL ) 
    {
        if( !AllocateSendBuffer() )
        {
            return ( FALSE );
        }
    }

    return( TRUE );
}

bool
CScraper::SetWindowInfo()
{
    //No Security Attrs needed. 
    _chVERIFY2( m_hConBufOut = CreateFile( TEXT("CONOUT$"), GENERIC_READ |
        GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL, 0 ) );

    if( INVALID_HANDLE_VALUE == m_hConBufOut)
    {
        //Could be an application that does not share its screen buffer
        return ( TRUE );
    }

    SMALL_RECT sr;    

    sr.Top = 0;
    sr.Bottom = ( WORD )( m_pSession->CSession::m_wRows - 1 );
    sr.Right = ( WORD ) ( m_pSession->CSession::m_wCols - 1 );
    sr.Left = 0;

    COORD coordSize;
    coordSize.X = m_pSession->CSession::m_wCols;
    coordSize.Y = m_pSession->CSession::m_wRows;

    CONSOLE_SCREEN_BUFFER_INFO csbi;
    _chVERIFY2( GetConsoleScreenBufferInfo( m_pSession->CScraper::m_hConBufOut,
                                &csbi) );

    // Logic:  If the Old Window Size is less than the new Size then we set
    // the Screen Buffer Size first and then set the Window Size.
    // If the Old Window Size is Greater than the new Size then we set the
    // window Size first and then the Screen Buffer.

    // The above is because the Buffer Size always has to be greater than or
    // equal to the Window Size.
    if ( (csbi.dwSize.X < coordSize.X) || (csbi.dwSize.Y < coordSize.Y) )
    {
        COORD coordTmpSize = { 0, 0 };

        coordTmpSize .X = ( csbi.dwSize.X < coordSize.X ) ? coordSize.X  : csbi.dwSize.X;
        coordTmpSize .Y = ( csbi.dwSize.Y < coordSize.Y ) ? coordSize.Y  : csbi.dwSize.Y;

        _chVERIFY2( SetConsoleScreenBufferSize
                    ( m_pSession->CScraper::m_hConBufOut, coordTmpSize ) );
        _chVERIFY2( SetConsoleWindowInfo
                    ( m_pSession->CScraper::m_hConBufOut, TRUE, &sr ) );
        _chVERIFY2( SetConsoleScreenBufferSize
                    ( m_pSession->CScraper::m_hConBufOut, coordSize ) );
    }
    else  
    {
        _chVERIFY2( SetConsoleWindowInfo( m_pSession->CScraper::m_hConBufOut,
                                        TRUE, &sr ) );
        _chVERIFY2( SetConsoleScreenBufferSize( m_pSession->CScraper::
                                        m_hConBufOut, coordSize ) );
    }
    TELNET_CLOSE_HANDLE( m_hConBufOut );
    return( TRUE );
}

bool
CScraper::SetCmdInfo()
{
    if( !SetWindowInfo() )
    {
        return( FALSE );
    }

    wRows = m_pSession->m_wRows;
    wCols = m_pSession->m_wCols;
 
    if( pLastSeen )
    {
        delete[] pLastSeen;
    }
    if( pCurrent )
    {
        delete[] pCurrent;
    }

    pLastSeen = ( PCHAR_INFO ) new char[wRows * wCols * sizeof( CHAR_INFO )];
    pCurrent  = ( PCHAR_INFO ) new char[wRows * wCols * sizeof( CHAR_INFO )];

    if( !pLastSeen || !pCurrent )
    {
        return ( FALSE );
    }

    SfuZeroMemory( pLastSeen, wRows * wCols * sizeof( CHAR_INFO ) );

    return( TRUE );
}

void
CScraper::Init( CSession *pSession )
{
    _chASSERT( pSession );
    m_pSession = pSession;
    m_dwCurrentCodePage = GetACP();
}

bool
CScraper::InitSession()
{
    wRows = m_pSession->m_wRows;
    wCols = m_pSession->m_wCols;    

    CONVERT_TO_MILLI_SECS( m_pSession->CSession::m_dwIdleSessionTimeOut );

    m_dwPollInterval = MIN_POLL_INTERVAL;
    GetRegistryValues( );
    
    //Load the term cap entry 
    pTermCap = _Utils::CTermCap::Instance();
    if( !pTermCap )
    {
        return( FALSE );
    }
    
    pLastSeen = NULL;
    pCurrent  = NULL;

    m_dwInputSequneceState  = IP_INIT;
    m_dwDigitInTheSeq       = 0;

    if( !InitTerm() )
    {
        return( FALSE );
    }

    if( !SetCmdInfo() )
    {
        return( FALSE );
    }

    //
    // If Japanese NT use VT80 scraping loop
    //
    return( TRUE ); 
}

void
CScraper::Shutdown()
{
}
        
bool
CScraper::OnWaitTimeOut()
{                             
    bool bRetVal = TRUE;
    bool fDifferenceFound = false;

    if( m_pSession->CSession::m_bIsStreamMode )
    {
        //No scraping. 
        if( g_pucSendInsertPoint != g_pucSendBuffer ) 
        {
            fDifferenceFound = true;
		    CScraper::Transmit();        
        }
    }
    else
    {
        //  Time to check the screen
        if( ( m_dwTerm & TERMVTNT ) != 0 )
        {
             bRetVal = CompareAndUpdateVTNT( wRows, wCols, pCurrent, pLastSeen, 
                                    &CSBI, &LastCSBI, &fDifferenceFound );
        }
        else 
        {
             bRetVal = COMPARE_AND_UPDATE ( wRows, wCols, pCurrent, 
                                     pLastSeen, &CSBI, &LastCSBI, &fDifferenceFound );
        }
    }

    if( fDifferenceFound )
    {
        m_dwPollInterval = MIN_POLL_INTERVAL;
    }
    else
    {
        m_dwPollInterval = MAX_POLL_INTERVAL;
    }

    return( bRetVal );
}

bool
CScraper::IsSessionTimedOut()
{
    if( m_dwPollInterval == MAX_POLL_INTERVAL )
    {
        m_dwHowLongIdle += MAX_POLL_INTERVAL;
        m_pSession->CIoHandler::UpdateIdleTime( UPDATE_IDLE_TIME );
        if( m_dwHowLongIdle > m_pSession->CSession::m_dwIdleSessionTimeOut &&
            !ISSESSION_TIMEOUT_DISABLED( m_pSession->CSession::m_dwIdleSessionTimeOut) )
        {               
            LPWSTR szMsg = NULL;
            szMsg = new WCHAR[ 2 * wcslen( _T( "\r\n" ) ) + wcslen( _T( TIMEOUT_STR ) ) + wcslen( _T( TERMINATE  ) ) + 1];
            if( szMsg )
            {
                wcscpy( szMsg, _T( "\r\n" ) );
                wcscat( szMsg, _T( TERMINATE  ) );
                wcscat( szMsg, _T( TIMEOUT_STR ) );
                wcscat( szMsg, _T( "\r\n" ) );
                m_pSession->CIoHandler::SendMessageToClient( szMsg, NO_HEADER );
                delete[] szMsg;
            }
            return( true ); //This will take us out of WaitForIo
        }
    }
    else
    {
        if( m_dwHowLongIdle != 0 )
        {
            m_pSession->CIoHandler::UpdateIdleTime( RESET_IDLE_TIME );
        }

        m_dwHowLongIdle = 0;
    }
    return( false );
}

void CScraper::EchoVtntCharToClient( INPUT_RECORD *pIR )
{
    _chASSERT( pIR );
    CHAR rgchInput;

    if( !pIR )
    {
        return;
    }

    DWORD dwSize = 0;
    PUCHAR pResponse = NULL;
    rgchInput = pIR->Event.KeyEvent.uChar.AsciiChar;
    m_pSession->CRFCProtocol::StrToVTNTResponse( &( rgchInput ), 1, ( VOID **)&pResponse, &dwSize );
    SendBytes( pResponse, dwSize );
    delete[] pResponse;
}

inline void
CScraper::EchoCharBackToClient( UCHAR ucChar )
{
    SendChar( ucChar );
}

bool
CScraper::EmulateAndWriteToCmdConsoleInput()
{
    CHAR         cPrevChar;
    DWORD        dwCount;
    SHORT        vk;
    BYTE         vkcode;
    DWORD        dwShiftcode;
    WORD         wScanCode;
    DWORD        i;
    BOOL         dwStatus = 0;
    DWORD        dwBytesTransferred = 0;

    cPrevChar = '\0';

    dwBytesTransferred = m_pSession->CIoHandler::m_dwReadFromSocketIoLength;

    m_dwPollInterval = MIN_POLL_INTERVAL;

    if( ( m_dwTerm & TERMVTNT ) != 0 )
    {          
        DWORD       dwBytesRemaining = 0;
        DWORD       dwBytesProcessed = 0;
        INPUT_RECORD* pIR = (INPUT_RECORD*) m_pSession->CIoHandler::
                                            m_ReadFromSocketBuffer;
        dwBytesTransferred += (DWORD)(m_pSession->CIoHandler::m_pReadFromSocketBufferCursor - m_pSession->CIoHandler::m_ReadFromSocketBuffer);

        if( m_pSession->CSession::m_bIsStreamMode &&
            pIR->EventType == KEY_EVENT && 
            pIR->Event.KeyEvent.bKeyDown &&
            pIR->Event.KeyEvent.uChar.AsciiChar
          )
        {         
            EchoVtntCharToClient( pIR );
        }

        if( pIR->Event.KeyEvent.uChar.AsciiChar != '\r' )
        {
            m_bCheckForScrolling = 0 ;
        }

        if( (pIR->EventType == KEY_EVENT)  && 
            pIR->Event.KeyEvent.uChar.AsciiChar == CTRLC )
        {
            DWORD dwMode = 0;
            _chVERIFY2( GetConsoleMode( m_hConBufIn, &dwMode ) );
            if( ( ( dwMode &  ENABLE_PROCESSED_INPUT ) &&  pIR->Event.KeyEvent.bKeyDown ) 
                || pIR->Event.KeyEvent.wVirtualKeyCode == VKEY_CTRL_BREAK )              
            {
                _chVERIFY2( GenerateConsoleCtrlEvent( CTRL_C_EVENT, 0));
                return( TRUE );
            }
        }
        
        if( dwBytesRemaining = (dwBytesTransferred % sizeof(INPUT_RECORD)) )
        {
            dwBytesProcessed = dwBytesTransferred - dwBytesRemaining;
        }
        else
        {
            dwBytesProcessed=dwBytesTransferred;
        }

        _chVERIFY2( dwStatus = WriteConsoleInput( m_hConBufIn, 
            pIR, dwBytesProcessed/sizeof(INPUT_RECORD), &dwCount));   
        if( !dwStatus )
        {
            LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, 
                    MSG_ERR_WRITE_CONSOLE, GetLastError() );
            return ( FALSE );
        }
        
        if( dwBytesRemaining > 0 )
        {
            memmove( (void *)m_pSession->CIoHandler::m_ReadFromSocketBuffer, (void *)(m_pSession->CIoHandler::m_ReadFromSocketBuffer+dwBytesProcessed), dwBytesRemaining);
        }
        m_pSession->CIoHandler::m_pReadFromSocketBufferCursor = (PUCHAR)(m_pSession->CIoHandler::m_ReadFromSocketBuffer + dwBytesRemaining);
    }
    else 
    {
        m_bCheckForScrolling = 1;
        if( dwBytesTransferred == 1 )                        
        {
            if( m_pSession->CIoHandler::m_ReadFromSocketBuffer[0] != '\r' )
            {
                m_bCheckForScrolling = 0;
            }
        }

        for( i=0;  i < dwBytesTransferred; i++ )
        {
            if( m_pSession->CSession::m_bIsStreamMode )
            {
                EchoCharBackToClient( m_pSession->CIoHandler::
                                         m_ReadFromSocketBuffer[i] );
            }
            
            if( ProcessEnhancedKeys( m_pSession->CIoHandler::
                        m_ReadFromSocketBuffer[i], &cPrevChar, 
                        dwBytesTransferred == 1) )
            {                
                m_bCheckForScrolling = 0;
                continue;
            }

            if( cPrevChar != '\r' || m_pSession->CIoHandler::
                    m_ReadFromSocketBuffer[i] != '\n' )
            {
                if( m_pSession->CIoHandler::m_ReadFromSocketBuffer[i] == CTRLC )
                {
                    //The follwing is the observed behaviour of CTRL C
                    //When ENABLE_PROCESSED_INPUT mode is not enabled, pass CTRL C as
                    //input to the console input buffer.
                    //When ENABLE_PROCESSED_INPUT mode is enabled, generate CTTRL C signal
                    //and also unblock any ReadConsoleInput. This behaviour is what is observed
                    // and not from any documentation.
                    DWORD dwMode = 0;
                    _chVERIFY2( GetConsoleMode( m_hConBufIn, &dwMode ) );
                    if( dwMode &  ENABLE_PROCESSED_INPUT )
                    {
                        _chVERIFY2( GenerateConsoleCtrlEvent( CTRL_C_EVENT, 0));
                        continue;
                    }
                } 
                vk = VkKeyScan( m_pSession->CIoHandler::
                        m_ReadFromSocketBuffer[i] );
                if( vk != 0xffff )
                {
                    vkcode = LOBYTE( vk );
                    wScanCode = ( WORD )MapVirtualKey( vkcode, 0 );
                    dwShiftcode = 0;
                    if( HIBYTE( vk ) & 1 )
                        dwShiftcode |= SHIFT_PRESSED;
                    if( HIBYTE( vk ) & 2 )
                        dwShiftcode |= LEFT_CTRL_PRESSED;
                    if( HIBYTE( vk ) & 4 )
                        dwShiftcode |= LEFT_ALT_PRESSED;

                    dwStatus = WriteAKeyToCMD( vkcode, wScanCode, 
                                               m_pSession->CIoHandler::m_ReadFromSocketBuffer[i], 
                                               dwShiftcode );

                    if( !dwStatus )
                    {
                        LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, 
                                MSG_ERR_WRITE_CONSOLE, GetLastError() );
                        return ( FALSE );
                    }
                }
            }
            cPrevChar = m_pSession->CIoHandler::m_ReadFromSocketBuffer[i];
        }
    }
    return( TRUE );
}

DWORD 
CScraper::WriteAKeyToCMD( WORD wVKCode, WORD wVSCode, CHAR cChar, DWORD dwCKState )
{
    DWORD dwStatus = 0;
    DWORD dwCount  = 0;
    INPUT_RECORD input;

    SfuZeroMemory( &input, sizeof( INPUT_RECORD ) );

    input.EventType = KEY_EVENT;
    input.Event.KeyEvent.bKeyDown = TRUE;
    input.Event.KeyEvent.wRepeatCount = 1;
    
    input.Event.KeyEvent.wVirtualKeyCode = wVKCode;
    input.Event.KeyEvent.wVirtualScanCode = wVSCode;
    input.Event.KeyEvent.uChar.AsciiChar = cChar;
    input.Event.KeyEvent.dwControlKeyState = dwCKState;
    _chVERIFY2 ( dwStatus = WriteConsoleInputA( m_hConBufIn, &input, 1, &dwCount ) );

    if( !IsDBCSLeadByte(cChar) )
    {
        input.Event.KeyEvent.bKeyDown = FALSE;
        _chVERIFY2 ( dwStatus = WriteConsoleInputA( m_hConBufIn, &input, 1, &dwCount ) );
    }   

    return dwStatus;
}


bool 
CScraper::ProcessEnhancedKeys( unsigned char cCurrentChar, char* pchPrevChar, bool fSingleByte )
{
    bool bRetVal = true;

    *pchPrevChar = cCurrentChar;

    switch( m_dwInputSequneceState )
    {
    case IP_INIT:
        if( cCurrentChar == m_pSession->m_dwAltKeyMapping )
        {
            WriteAKeyToCMD( VK_MENU, VS_MENU, cCurrentChar, ENHANCED_KEY );
        }
        else if( cCurrentChar == ASCII_DELETE )         //vt100 delete key
        {
            WriteAKeyToCMD( VK_DELETE, VS_DELETE, 0, ENHANCED_KEY );
        }
        else if( cCurrentChar == ESC )
        {    
            if( fSingleByte )
            {
                WriteAKeyToCMD( VK_ESCAPE, VS_ESCAPE, ESC, ENHANCED_KEY );
            }
            else
            {
                m_dwInputSequneceState = IP_ESC_RCVD;
            }
        }else
        {
            //Not any special char
            bRetVal = false;
        }
        break;

    case IP_ESC_RCVD:
        if( cCurrentChar == '[' )
        {        
            m_dwInputSequneceState = IP_ESC_BRACKET_RCVD;
        }
        else if( cCurrentChar == 'O' )
        {
            m_dwInputSequneceState = IP_ESC_O_RCVD;
        }
        else
        {
            //Write already received escape as it is and return false
            WriteAKeyToCMD( VK_ESCAPE, VS_ESCAPE, ESC, ENHANCED_KEY );
            bRetVal = false;
            m_dwInputSequneceState = IP_INIT;
        }
        break;

    case IP_ESC_O_RCVD:
        m_dwInputSequneceState = IP_INIT;
        switch( cCurrentChar )
        {
        case 'P':
            WriteAKeyToCMD( VK_F1, VS_F1, 0, ENHANCED_KEY );
            break;
        case 'Q':
            WriteAKeyToCMD( VK_F2, VS_F2, 0, ENHANCED_KEY );
            break;
        case 'R':
            WriteAKeyToCMD( VK_F3, VS_F3, 0, ENHANCED_KEY );
            break;
        case 'S':
            WriteAKeyToCMD( VK_F4, VS_F4, 0, ENHANCED_KEY );
            break;
        default:
            //Write already received escape as it is and return false which 
            //will make the current char also to be written to the cmd
            WriteAKeyToCMD( VK_ESCAPE, VS_ESCAPE, ESC, ENHANCED_KEY );
            WriteAKeyToCMD( 'O', VS_O, 'O', CAPSLOCK_ON ); //write O
            bRetVal = false;
        }
        break;

    case IP_ESC_BRACKET_RCVD:        
        m_dwInputSequneceState = IP_INIT;
        switch( cCurrentChar )
        {
        case 'A':
            WriteAKeyToCMD( VK_UP, VS_UP, 0, ENHANCED_KEY );                    
            break;

        case 'B':
            WriteAKeyToCMD( VK_DOWN, VS_DOWN, 0, ENHANCED_KEY );
            break;

        case 'C':
            WriteAKeyToCMD( VK_RIGHT, VS_RIGHT, 0, ENHANCED_KEY );
            break;

        case 'D':
            WriteAKeyToCMD( VK_LEFT, VS_LEFT, 0, ENHANCED_KEY );
            break;
        case VT302_PAUSE:  //'P'
            WriteAKeyToCMD( VK_PAUSE, VS_PAUSE, 0, ENHANCED_KEY );
            break;

        default:
            if( isdigit( cCurrentChar ) )
            {
                m_dwInputSequneceState = IP_ESC_BRACKET_DIGIT_RCVD;
                m_dwDigitInTheSeq = cCurrentChar - '0';
            }
            else
            {
                WriteAKeyToCMD( VK_ESCAPE, VS_ESCAPE, ESC, ENHANCED_KEY );            
                WriteAKeyToCMD( VK_OEM_4, VS_OEM_4, '[', 0 );
                bRetVal = false;
            }
            break;
        }
        break;

    case IP_ESC_BRACKET_DIGIT_RCVD:
        m_dwInputSequneceState = IP_INIT;
        if( isdigit( cCurrentChar ) )
        {
            m_dwDigitInTheSeq = m_dwDigitInTheSeq * 10 + ( cCurrentChar - '0' ) ;
            m_dwInputSequneceState = IP_ESC_BRACKET_DIGIT_RCVD;
        }
        else if( cCurrentChar == '~' )
        {
            switch( m_dwDigitInTheSeq )
            {
            case VT302_NEXT:
                WriteAKeyToCMD( VK_NEXT, VS_NEXT, 0, ENHANCED_KEY );
                break;
            case VT302_PRIOR:
                WriteAKeyToCMD( VK_PRIOR, VS_PRIOR, 0, ENHANCED_KEY );
                break;
            case VT302_END:
                WriteAKeyToCMD( VK_END, VS_END, 0, ENHANCED_KEY );
                break;
            case VT302_INSERT:
                WriteAKeyToCMD( VK_INSERT, VS_INSERT, 0, ENHANCED_KEY );
                break;
            case VT302_HOME:
                WriteAKeyToCMD( VK_HOME, VS_HOME, 0, ENHANCED_KEY );
                break;
            case VT302_F5:
                WriteAKeyToCMD( VK_F5, VS_F5, 0, ENHANCED_KEY );
                break;
            case VT302_F6:                
                WriteAKeyToCMD( VK_F6, VS_F6, 0, ENHANCED_KEY );
                break;
            case VT302_F7:
                WriteAKeyToCMD( VK_F7, VS_F7, 0, ENHANCED_KEY );
                break;
            case VT302_F8:
                WriteAKeyToCMD( VK_F8, VS_F8, 0, ENHANCED_KEY );
                break;
            case VT302_F9:
                WriteAKeyToCMD( VK_F9, VS_F9, 0, ENHANCED_KEY );
                break;
            case VT302_F10:
                WriteAKeyToCMD( VK_F10, VS_F10, 0, ENHANCED_KEY );
                break;
            case VT302_F11:
                WriteAKeyToCMD( VK_F11, VS_F11, 0, ENHANCED_KEY );
                break;
            case VT302_F12:
                WriteAKeyToCMD( VK_F12, VS_F12, 0, ENHANCED_KEY );
                break;
            default:
                WriteAKeyToCMD( VK_ESCAPE, VS_ESCAPE, ESC, ENHANCED_KEY );            
                WriteAKeyToCMD( VK_OEM_4, VS_OEM_4, '[', 0 );
                _chASSERT( 0 );
                bRetVal = false;
            }
        }
        else
        {
                WriteAKeyToCMD( VK_ESCAPE, VS_ESCAPE, ESC, ENHANCED_KEY );            
                WriteAKeyToCMD( VK_OEM_4, VS_OEM_4, '[', 0 );
                _chASSERT( 0 );
                bRetVal = false;
        }
        break;

    default:
        //Should not happen
        _chASSERT( 0 );
    }
       
    return bRetVal;
}

void 
CScraper::SendChar( char ch )
{
    SendBytes( ( PUCHAR )&ch, 1 );
}

void 
CScraper::SendBytes( PUCHAR pucBuf, DWORD dwLength )
{
    bool bSuccess=false;
    bool bTransmitDone = false;
    if( pucBuf == NULL )
        return;

    if( g_pucSendBuffer == NULL ) 
    {
        return;
    }
    else
    {
        if( g_dwSendBufferSize >= MAX_SOCKET_BUFFER_SIZE )
        {
            bSuccess = Transmit();
            bTransmitDone = true;
        }
        if( ((bTransmitDone&&bSuccess)||(!bTransmitDone))&&( g_pucSendInsertPoint + dwLength ) > ( g_pucSendBuffer + g_dwSendBufferSize ) ) 
        {

            // do realloc
            DWORD dwOffset = (DWORD)( g_pucSendInsertPoint - g_pucSendBuffer );
            DWORD dwTmpBufSize = dwLength + dwOffset; 
            PUCHAR pTmpBuf = new UCHAR[dwTmpBufSize];
            if( !pTmpBuf )
            {
                return;
            }

            memcpy( pTmpBuf, g_pucSendBuffer, dwOffset );  // No attack, calculated allocation already. Baskar.
            delete [] g_pucSendBuffer;
            g_pucSendBuffer = pTmpBuf;

            g_dwSendBufferSize = dwTmpBufSize;
        
            g_pucSendInsertPoint = g_pucSendBuffer + dwOffset;
        }
    }
    if(g_pucSendInsertPoint)
   	{
	    memcpy( g_pucSendInsertPoint, pucBuf, dwLength ); // No size info for destination, Baskar - Attack ?
	    g_pucSendInsertPoint += dwLength;
    }
}

void 
CScraper::SendString( LPSTR pszString )
{
    if( pszString == 0 )
        return;

    SendBytes( ( PUCHAR )pszString,  strlen( pszString ) );    
}


void 
CScraper::SendFmt( LPSTR fmt, ... )
{
    va_list arg;
    CHAR szBuffer[ONE_KB + 1] = { 0 };

    va_start( arg,fmt );

    _vsnprintf( szBuffer, ONE_KB, fmt, arg );
    
    va_end( arg );

    SendString( szBuffer );
}

bool 
CScraper::Transmit( )
{
    if( g_pucSendInsertPoint != g_pucSendBuffer ) 
    {
        if( !TransmitBytes( g_pucSendBuffer, (DWORD)( g_pucSendInsertPoint - g_pucSendBuffer ) ) )
        {
            return( FALSE );
        }

        //We need to tune this DEFAULT_SEND_BUFFER_SIZE
        if( g_dwSendBufferSize > DEFAULT_SEND_BUFFER_SIZE )
        {
            //Don't keep if it is a huge buffer
            delete [] g_pucSendBuffer;
            g_dwSendBufferSize = 0;
            if( !AllocateSendBuffer() )
            {
                return( FALSE );
            }
        }

        g_pucSendInsertPoint = g_pucSendBuffer;
    }

    return( TRUE );
}

bool 
CScraper::TransmitBytes( PUCHAR pSendBuffer, DWORD dwSize)
{
    bool  bRetVal = TRUE;
    
    DWORD dwCurrentPacket = 0;
    DWORD dwTotalBytesSent = 0;

    //StuffEsacapeIACs may put some escape chars. I am expecting atmost 
    //DELTA such chars. Typically there will be none. With out this, we 
    //have to make pass over the pOutBuf once just to find the right number 
    //in a routine that may be executed once every 100ms.

    while( dwTotalBytesSent < dwSize )
    {
        ( ( dwSize - dwTotalBytesSent ) > 
          ( MAX_WRITE_SOCKET_BUFFER - DELTA ) )?
            dwCurrentPacket = ( MAX_WRITE_SOCKET_BUFFER - DELTA ):
            dwCurrentPacket = dwSize - dwTotalBytesSent;

        DWORD dwNumBytesWritten = 0;

        //Block until Previous Io is finished
        if( !FinishIncompleteIo( (HANDLE) m_pSession->CIoHandler::m_sSocket,
             &( m_pSession->CIoHandler::m_oWriteToSocket ),  &dwNumBytesWritten ) ) 
        {
            bRetVal = FALSE ;
            break;
        }

        DWORD dwCountWithEscapes = dwCurrentPacket;
        StuffEscapeIACs( m_pSession->CIoHandler::m_WriteToSocketBuff,
                pSendBuffer + dwTotalBytesSent, &dwCountWithEscapes );
        m_pSession->CIoHandler::m_dwWriteToSocketIoLength=dwCountWithEscapes;
        if( !m_pSession->CIoHandler::WriteToClient( ) )
        {
            bRetVal = FALSE ;
            break;
        }
        dwTotalBytesSent += dwCurrentPacket;
    }

    return( bRetVal );
}

void 
CScraper::SendColorInfo( WORD wAttributes ) 
{
    if( wAttributes & BACKGROUND_INTENSITY )
    {
        //do nothing.
        //There is no equivalent capability on vt100
    }
    if( wAttributes & FOREGROUND_INTENSITY )
    {
        if( !fBold )
        {
            _snprintf(szSGRStr, (sizeof(szSGRStr) - 1), "%c[%dm", 27,  1 ); //Bold
            SendString( szSGRStr );
            fBold = true;
        }
    } 
    else
    {
        if( fBold )
        {
            _snprintf(szSGRStr, (sizeof(szSGRStr) - 1), "%c[%dm", 27,  22 ); //Bold off
            SendString( szSGRStr );
            fBold = false;
        }
    }
    WORD wColor = 0;
    if( wAttributes & FOREGROUND_BLUE )
    {
        wColor = ( WORD )(  wColor | 0x0004 );
    } 
    if( wAttributes & FOREGROUND_GREEN )
    {
        wColor = ( WORD )( wColor | 0x0002 );
    } 
    if( wAttributes & FOREGROUND_RED )
    {
        wColor = ( WORD )( wColor | 0x0001 );
    } 
    wColor += 30;   //Base value for foreground colors
    _snprintf(szSGRStr, (sizeof(szSGRStr) - 1), "%c[%dm", 27,  wColor );
    SendString( szSGRStr );

    //WORD wColor = 0;
    wColor = 0;
    if( wAttributes & BACKGROUND_BLUE )
    {
        wColor = ( WORD )( wColor | 0x0004 );
    } 
    if( wAttributes & BACKGROUND_GREEN )
    {
        wColor = ( WORD )( wColor | 0x0002 );
    }    
    if( wAttributes & BACKGROUND_RED )
    {
        wColor = ( WORD )( wColor | 0x0001 );
    } 
    wColor += 40;   //Base value for Background colors
    _snprintf(szSGRStr, (sizeof(szSGRStr) - 1), "%c[%dm", 27,  wColor );
    SendString( szSGRStr );
}

#define COMPARE_ROWS(currentRow, lastSeenRow, result) \
    for(i = 0; i < wCols; ++i ) \
    { \
        if( pCurrent[ ( currentRow ) * wCols + i].Char.AsciiChar != \
            pLastSeen[ ( lastSeenRow ) * wCols + i].Char.AsciiChar ) \
        {\
            (result) = 0; \
            break;\
        } \
        if( ( wDefaultAttributes != pCurrent[ ( currentRow ) * wCols + i]. \
              Attributes ) && \
              ( pCurrent[ ( currentRow ) * wCols + i].Attributes !=  \
              pLastSeen[ ( lastSeenRow ) * wCols + i].Attributes ) ) \
        { \
           (result) = 0; \
           break; \
        } \
    } 

#define GET_DEFAULT_COLOR \
    if( wDefaultAttributes == 0 ) \
    { \
        wDefaultAttributes  = pCurrent[ 0 ].Attributes; \
        wExistingAttributes = pCurrent[ 0 ].Attributes; \
    }

//row, column are over the wire should be w.r.t screen. 
//So, +1 for both row, column
#define POSITION_CURSOR( row, column ) \
    { \
        LPSTR lpszCMStr3 = pTermCap->CursorMove( lpszCMStr2, \
            ( WORD ) ( ( row ) + 1 ),  \
            ( WORD ) ( ( column ) + 1 ) ); \
        SendString( lpszCMStr3 ); \
        delete [] lpszCMStr3; \
    }


#define SEND_ROW( row, begin, end ) \
    for(LONG c = ( begin ); c < ( end ); ++c ) \
    { \
        if( wExistingAttributes != pCurrent[( row ) * wCols + c].Attributes ) \
        { \
           wExistingAttributes = pCurrent[ ( row ) * wCols + c].Attributes; \
           wDefaultAttributes  = ( WORD )~0; \
           SendColorInfo( wExistingAttributes ); \
        } \
        SendChar( pCurrent[ ( row ) * wCols + c].Char.AsciiChar ); \
    } 

#define IS_BLANK( row, col ) \
    ( pCurrent[ ( row ) * wCols + ( col ) ].Char.AsciiChar == ' ' )

#define IS_DIFFERENT_COLOR( row, col, attribs ) \
    ( pCurrent[ ( row ) * wCols + ( col ) ].Attributes != ( attribs ) )

#define IS_CHANGE_IN_COLOR( row, col ) \
    ( pCurrent[ ( row ) * wCols + ( col ) ].Attributes != \
    pLastSeen[ ( row ) * wCols + ( col ) ].Attributes )

#define IS_CHANGE_IN_CHAR( row, col ) \
    ( pCurrent[ ( row ) * wCols + ( col ) ].Char.AsciiChar != \
    pLastSeen[ ( row ) * wCols + ( col )].Char.AsciiChar )
 

bool 
CScraper::CompareAndUpdateVT100( WORD wRows, WORD wCols, PCHAR_INFO pCurrent,
                                      PCHAR_INFO pLastSeen,
                                      PCONSOLE_SCREEN_BUFFER_INFO pCSBI,
                                      PCONSOLE_SCREEN_BUFFER_INFO pLastCSBI,
                                      bool *pfDifferenceFound )
{
    _TRACE( TRACE_DEBUGGING, "CompareAndUpdateVT100()" );

    INT   i;
    WORD  wRow, wCol;
    INT   iStartCol,iEndCol;
    bool  fBlankLine;

    COORD coordDest;
    COORD coordOrigin;
    
    SMALL_RECT srSource;
    
    coordDest.X = wCols;
    coordDest.Y = wRows;
    coordOrigin.X = 0;
    coordOrigin.Y = 0;
    srSource.Left = 0;
    srSource.Top = 0;
    srSource.Right = ( WORD ) ( wCols - 1 );
    srSource.Bottom = ( WORD ) ( wRows - 1 );

    _chASSERT( pfDifferenceFound )

    *pfDifferenceFound = false;
    _chVERIFY2( m_hConBufOut = CreateFile( TEXT("CONOUT$"), GENERIC_READ |
                GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL, 0 ) );

    if( INVALID_HANDLE_VALUE == m_hConBufOut)
    {
        //Could be an application that does not share its screen buffer
        return ( TRUE );
    }

    BOOL dwStatus = 0;
    _chVERIFY2( dwStatus = ReadConsoleOutputA( m_hConBufOut, pCurrent, coordDest,
                coordOrigin, &srSource ) );
    if( !dwStatus )
    {
        LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, MSG_ERR_READ_CONSOLE, GetLastError() );
        TELNET_CLOSE_HANDLE( m_hConBufOut );
        return ( FALSE );
    }

    // Read the current cursor position
    _chVERIFY2( dwStatus = GetConsoleScreenBufferInfo( m_hConBufOut, pCSBI ) );
    if( !dwStatus )
    {
        LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, MSG_ERR_READ_CONSOLE, GetLastError() );
        TELNET_CLOSE_HANDLE( m_hConBufOut );
    	return ( FALSE );
    }    
        
    TELNET_CLOSE_HANDLE( m_hConBufOut );

    GET_DEFAULT_COLOR;

    //Check if the text was scrolled
    LONG currentBuffBottom, lastSeenBuffBottom, currentBuffTop, lastSeenBuffTop;
    LONG lastRow, currentRow;
    bool checkRestOfBuffer;
    bool isScrolled = 0;

    currentBuffBottom = lastSeenBuffBottom = wRows - 1;
    currentBuffTop = lastSeenBuffTop = 0;

    //The following check is to prevent scrolling when the user hasn't pressed
    //ENTER. This case is reproduced by typing the same command (for eg: dir in     
    //a directory with not too many files) many times until the screen is filled
    //and then type one char extra or less for that command (For "dir", it is
    //"di" or "dir /" ) then the screen scrolls
    //The solution is to see if the only change since the last scraping is
    //only one key stroke( one byte ), if so don't scroll.
    //This may lead to the case that it may scroll when you press up arrow key
    //( 3 bytes ). 
    //Note: This is may lead to scrolling when you press a single 
    //key stroke on a japanese machine. Multi byte chars etc.
    
    if( !m_bCheckForScrolling  )
    {
        isScrolled = 1;
    }
    m_bCheckForScrolling = 1;
  
    //
    //When scrolling occurs because of coincidental matching of blank lines at 
    //the bottom of the text in the cmd, it creates problems when clearing the 
    //screen. repro steps: goto last but one line in the client window. 
    //change directory.  now list files. try clearing screen.
    if( !( ( pLastCSBI->dwCursorPosition.Y == pCSBI->dwCursorPosition.Y ) &&
        ( pCSBI->dwCursorPosition.Y == pCSBI->srWindow.Bottom ) ) )
    {
        isScrolled = 1; //just to skip the following loop
    }
    while( currentBuffBottom >= currentBuffTop && !isScrolled )
    {
        checkRestOfBuffer = 1;
        COMPARE_ROWS(currentBuffBottom, lastSeenBuffBottom, checkRestOfBuffer );
        if ( checkRestOfBuffer )
        {
            isScrolled = 1;
            if( currentBuffBottom > 0 )
            {
                //need not compare the same line again. Decrement by one.
                currentRow = currentBuffBottom - 1;
                lastRow = lastSeenBuffBottom - 1;

                while( currentRow >= currentBuffTop && isScrolled )
                {
                    COMPARE_ROWS(currentRow, lastRow, isScrolled );
                    currentRow--;
                    lastRow--;
                }
            }
        }

        currentBuffBottom--;
    }
    currentBuffBottom++;

    //Patch to make this work for ONE blank line at the top
    //Without this patch, screen scrolls for each char typed after "cls"
    if( currentBuffBottom == currentBuffTop )
    {
        //check if it is a blank line. Then it is not scrolling.
           for(i = 0; i < wCols; ++i ) 
        {
            if( !IS_BLANK( currentBuffTop , i ) )
            {
                break;
            }
            isScrolled = 0;
        }

    }

    //if it is the same screen
    if( currentBuffBottom + 1 >= wRows )
    {
        isScrolled = 0;
    }
    if( isScrolled )
    {  
        //Now Send all the lines from currentBuffBottom
        //till the end of the buffer

        *pfDifferenceFound = true;

        _TRACE( TRACE_DEBUGGING, "About to send from:%d till:%d", 
                currentBuffBottom + 1, wRows);
        WORD lastChar = wCols;

        for(LONG r = currentBuffBottom + 1; r < wRows ; r++)
        {
            SendChar( 0x0D );
            SendChar( 0x0A );

            lastChar = wCols;
            while( lastChar > 0 && IS_BLANK( r, lastChar - 1 ) && 
                 !IS_DIFFERENT_COLOR( r, lastChar - 1, wExistingAttributes ) )
            {
                lastChar--;
            }

            SEND_ROW( r, 0, lastChar );

            if( lastChar < wCols )
            {
                SendString( lpszCMStr1 );
            }
        }
        //
        //Do line by line scraping only if it was not scrolling
        goto next;
    }

    _TRACE( TRACE_DEBUGGING, "NO scrolling");
    // Search both the two-dimensional arrays for differences.
    wRow = wCol = 0;
    
    while( wRow < wRows ) 
    {
        if( memcmp( &pCurrent[wRow * wCols], &pLastSeen[wRow * wCols],
                    wCols * sizeof( CHAR_INFO ) ) != 0 ) 
        {
//            _TRACE( TRACE_DEBUGGING, "difference found in row %d\n", wRow );
            *pfDifferenceFound = true;

            iStartCol = -1;
            iEndCol = -1;
            fBlankLine = true;
            
            for(i = 0 ; i < wCols; ++i )
            {
                if( IS_DIFFERENT_COLOR( wRow, i, wDefaultAttributes ) && 
                      IS_CHANGE_IN_COLOR( wRow, i ) )
                {
                   if( iStartCol == -1 )
                   {
                       iStartCol = i;
                   }
                   iEndCol = i;
                   fBlankLine = false;                   
                }
                if( IS_CHANGE_IN_CHAR( wRow, i ) ) 
                {
                   if( iStartCol == -1 )
                   {
                       iStartCol = i;
                   }
                   iEndCol = i;
                }
                if( fBlankLine && !IS_BLANK( wRow, i ) )
                {
                   fBlankLine = false;
                }
            }

            if( fBlankLine )
            {
                POSITION_CURSOR( wRow, 0 );
                SendString( lpszCMStr1 );

                coExpectedCursor.Y  = wRow;
                coExpectedCursor.X  = 0;
            }
            else if( iStartCol != -1 ) 
            {
                if( wRow != coExpectedCursor.Y || iStartCol != coExpectedCursor.X ) 
                {
                    POSITION_CURSOR( wRow, iStartCol );

                    coExpectedCursor.X  = ( SHORT )iStartCol;
                    coExpectedCursor.Y  = wRow;
                }

                SEND_ROW( wRow, iStartCol, iEndCol+1 );    
            
                coExpectedCursor.X = ( SHORT ) ( coExpectedCursor.X + 
                                                 iEndCol - iStartCol + 1 );
           }    
        }
        ++wRow;            
    }     
        
next :
    if( ( pCSBI->dwCursorPosition.X != coExpectedCursor.X ||
        pCSBI->dwCursorPosition.Y != coExpectedCursor.Y ) && 
        ( memcmp( &pCSBI->dwCursorPosition, &pLastCSBI->dwCursorPosition, 
        sizeof( COORD ) ) != 0 || g_pucSendInsertPoint != g_pucSendBuffer ) )
    {
        POSITION_CURSOR( pCSBI->dwCursorPosition.Y, 
                         pCSBI->dwCursorPosition.X );
        *pfDifferenceFound = true;

        coExpectedCursor.X  = pCSBI->dwCursorPosition.X;
        coExpectedCursor.Y  = pCSBI->dwCursorPosition.Y;
    }

    if( *pfDifferenceFound )
    {
        _TRACE( TRACE_DEBUGGING, "difference found: %d \n", m_dwPollInterval );
        // Copy pCurrent onto pLastSeen
        memcpy( pLastSeen, pCurrent, wCols * wRows * sizeof( CHAR_INFO ) );
        memcpy( pLastCSBI, pCSBI, sizeof( CONSOLE_SCREEN_BUFFER_INFO ) );
        if( !Transmit( ) )
        {
            return( FALSE );
        }
    }
    else
    {
        _TRACE( TRACE_DEBUGGING, "NO difference found: %d \n", m_dwPollInterval  );
    }

    return( TRUE );
}

bool 
CScraper::CompareAndUpdateVT80( WORD wRows, WORD wCols, 
                                     PCHAR_INFO pCurrent, PCHAR_INFO pLastSeen,
                                     PCONSOLE_SCREEN_BUFFER_INFO pCSBI,
                                     PCONSOLE_SCREEN_BUFFER_INFO pLastCSBI,
                                     bool *pfDifferenceFound )
{
    _TRACE( TRACE_DEBUGGING, "CompareAndUpdateVT80()" );

    WORD  i, j;
    WORD  wRow, wCol;
    SHORT iStartCol,iEndCol;
    bool  fBlankLine;
    bool  fMatching;
    
    COORD coordDest;
    COORD coordOrigin;
    
    SMALL_RECT srSource;

    *pfDifferenceFound = false;
    
    coordDest.X = wCols;
    coordDest.Y = wRows;
    coordOrigin.X = 0;
    coordOrigin.Y = 0;
    srSource.Left = 0;
    srSource.Top = 0;
    srSource.Right = ( WORD )( wCols - 1 );
    srSource.Bottom = ( WORD )( wRows - 1 );

    
    _chVERIFY2( m_hConBufOut = CreateFile( TEXT("CONOUT$"), GENERIC_READ |
                GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL, 0 ) );

    if( INVALID_HANDLE_VALUE == m_hConBufOut)
    {
        //Could be an application that does not share its screen buffer
        return ( TRUE );
    }

    BOOL dwStatus = 0;
    _chVERIFY2( dwStatus = ReadConsoleOutput( m_hConBufOut, pCurrent, coordDest,
                coordOrigin, &srSource ) );
    if( !dwStatus )
    {
        LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, MSG_ERR_READ_CONSOLE, GetLastError() );
        TELNET_CLOSE_HANDLE( m_hConBufOut );
        return ( FALSE );
    }

    // Read the current cursor position
    _chVERIFY2( dwStatus = GetConsoleScreenBufferInfo( m_hConBufOut, pCSBI ) );
    if( !dwStatus )
    {
        LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, MSG_ERR_READ_CONSOLE, GetLastError() );
        TELNET_CLOSE_HANDLE( m_hConBufOut );
	     return ( FALSE );
    }

    TELNET_CLOSE_HANDLE( m_hConBufOut );

    // Search both the two-dimensional arrays for differences.
    fMatching = true;
    wRow = wCol = 0;
    
    bool bCurrentClippedLeadByte = false, bLastSeenClippedLeadByte = false;

    while( wRow < wRows )
    {
        if( memcmp( &pCurrent[wRow * wCols], &pLastSeen[wRow * wCols],
                    wCols * sizeof( CHAR_INFO ) ) != 0 ) 
        {
            _TRACE( TRACE_DEBUGGING, "difference found in row %d\n", wRow );
            *pfDifferenceFound = true;

            iStartCol = -1;
            iEndCol = -1;
            fBlankLine = true;

            for( i = 0, j = 0; (i < wCols) && (j < wCols); NULL )
            {
                if( (i == 0) && bCurrentClippedLeadByte )
                {
                    ++i;
                    bCurrentClippedLeadByte = false;
                    continue;
                }

                if( (j==0) && bLastSeenClippedLeadByte )
                {
                    ++j;
                    bLastSeenClippedLeadByte = false;
                    continue;
                }

                if( pCurrent[wRow * wCols + i].Char.UnicodeChar != 
                         pLastSeen[wRow * wCols + j].Char.UnicodeChar ) 
                {
                    if( iStartCol == -1 )
                    {
                        iStartCol = i;
                        }
                        
                        iEndCol = i;
                }

                if( (pCurrent[wRow * wCols + i].Char.UnicodeChar != L' ') )
                {
                    fBlankLine = false;
                }

                if( pCurrent[wRow * wCols + i].Attributes & COMMON_LVB_LEADING_BYTE )
                {
                    i += 2;
                }
                else
                {
                    ++i;
                }

                if( pLastSeen[wRow * wCols + j].Attributes & COMMON_LVB_LEADING_BYTE )
                {
                    j += 2;
                }
                else
                {
                    ++j;
                }

                if( (j >= wCols) && (i < wCols) )
                {
                    (i == wCols) ? (i = ( WORD ) (wCols-1)) : NULL;

                    if( iStartCol == -1 )
                    {
                        iStartCol = i;
                    }
                    iEndCol = ( WORD ) ( wCols - 1 );
                    
                    break;
                }
            }

            if( pCurrent[wRow * wCols + (wCols - 1)].Attributes & COMMON_LVB_LEADING_BYTE )
            {
                bCurrentClippedLeadByte = true;
            }

            if( pLastSeen[wRow * wCols + (wCols - 1)].Attributes & COMMON_LVB_LEADING_BYTE )
            {
                bLastSeenClippedLeadByte = true;
            }


            if( fBlankLine ) 
            {
                LPSTR lpszCMStr3 = pTermCap->CursorMove( lpszCMStr2, 
                                                  ( WORD )( wRow + 1 ), 1 );
                SendString( lpszCMStr3 );
                delete [] lpszCMStr3;
                
                SendString( lpszCMStr1 );
            } 
            else 
            {
                if( iStartCol != -1 ) 
                {
                    LPSTR lpszCMStr3 = pTermCap->CursorMove( lpszCMStr2, 
                                         ( WORD ) ( wRow + 1 ) , 
                                         ( WORD ) ( iStartCol + 1 ) );
                    SendString( lpszCMStr3 );
                    delete [] lpszCMStr3;

                    for( wCol = iStartCol; wCol <= iEndCol; ++wCol )
                    {
                        CHAR mbCurrent[5];
                        int ret, xy;
                        WCHAR wcBuf[2];
                        
                        wcBuf[0] = pCurrent[wRow * wCols + wCol].Char.UnicodeChar;
                        wcBuf[1] = L'\0';

                        ret = WideCharToMultiByte( CP_ACP, 0, wcBuf, -1, mbCurrent, 4, NULL, NULL );

                        if( (ret != 0) )
                        {
                            //if( pCurrent[ wRow * wCols + wCol].Char.AsciiChar > 31 )
                            //SendChar( pCurrent[wRow * wCols + wCol].Char.AsciiChar );
                            for( xy=0; xy < ret; ++xy)
                            {
                                SendChar( mbCurrent[xy] );
                            }
                        }

                        if( pCurrent[wRow * wCols + wCol].Attributes & COMMON_LVB_LEADING_BYTE )
                        {
                            ++wCol;
                        }
                    }
                }    
            }
        }
        ++wRow;            
    }    

    if( memcmp( &pCSBI->dwCursorPosition, &pLastCSBI->dwCursorPosition,
                sizeof( COORD ) ) != 0 || g_pucSendInsertPoint != g_pucSendBuffer )
    {
        LPSTR lpszCMStr3 = pTermCap->CursorMove( lpszCMStr2, 
                                    ( WORD ) ( pCSBI->dwCursorPosition.Y + 1 ), 
                                    ( WORD ) ( pCSBI->dwCursorPosition.X + 1 ));
        SendString( lpszCMStr3 );
        delete [] lpszCMStr3;
     
        *pfDifferenceFound = true;
    }

    if( *pfDifferenceFound )
    {
        // Copy pCurrent onto pLastSeen
        memcpy( pLastSeen, pCurrent, wCols * wRows * sizeof( CHAR_INFO ) );
        memcpy( pLastCSBI, pCSBI, sizeof( CONSOLE_SCREEN_BUFFER_INFO ) );
        if( !Transmit( ) )
        {
            return( FALSE );
        }
    }
    else
    {
        _TRACE( TRACE_DEBUGGING, "NO difference found\n" );
    }
    return( TRUE );
}

bool 
CScraper::GetRegistryValues( void )
{
    HKEY hk;
    bool    success;
    DWORD dwDisp = 0;
    
    if ( TnSecureRegCreateKeyEx( HKEY_LOCAL_MACHINE, REG_PARAMS_KEY, NULL, NULL, 
                        REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED , NULL, &hk, &dwDisp, 0) ) 
    {
        LogEvent( EVENTLOG_ERROR_TYPE, MSG_REGISTRYKEY, REG_PARAMS_KEY );
        return( FALSE );
    }
        
    HKEY hk1;
    LPTSTR lpszTelnetInstallPath = NULL;
    if( !TnSecureRegCreateKeyEx( HKEY_LOCAL_MACHINE, REG_SERVICE_KEY, NULL, NULL, 
                        REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED , NULL, &hk1, &dwDisp, 0 ) ) 
    {
        success = GetRegistryString( hk1, NULL, L"ImagePath", &lpszTelnetInstallPath,
               L"",FALSE );
        RegCloseKey( hk1 );

        if (! success)
        {
            RegCloseKey(hk);
            return( FALSE );
        }
    }
    else
    {
        RegCloseKey(hk);
        LogEvent( EVENTLOG_ERROR_TYPE, MSG_REGISTRYKEY, REG_SERVICE_KEY );
        return (FALSE);
    }

    WCHAR *pLastBackSlash = wcsrchr( lpszTelnetInstallPath, L'\\' );
    if( pLastBackSlash != NULL )
    {
        *pLastBackSlash = 0;
    }
    LPWSTR lpszDefaultTermcapFullPathName = 
        new WCHAR[ ( wcslen( lpszTelnetInstallPath ) + 
        wcslen( DEFAULT_TERMCAP ) + 2 ) ];
    if( !lpszDefaultTermcapFullPathName )
    {
        RegCloseKey(hk);
        return( FALSE );
    }

    wcscpy( lpszDefaultTermcapFullPathName, lpszTelnetInstallPath );
    wcscat( lpszDefaultTermcapFullPathName, L"\\" );
    wcscat( lpszDefaultTermcapFullPathName, DEFAULT_TERMCAP );
    LPWSTR pszFileName;
    success = GetRegistryString( hk, NULL, L"Termcap", &pszFileName, 
            lpszDefaultTermcapFullPathName,FALSE );

    RegCloseKey(hk);

    if (! success)
    {
        return( FALSE );
    }

    WCHAR szCmdBuf[ONE_KB];
    ExpandEnvironmentStrings( pszFileName, szCmdBuf, (sizeof(szCmdBuf)/sizeof(szCmdBuf[0])) );

    delete [] lpszDefaultTermcapFullPathName;
    delete [] lpszTelnetInstallPath;
    delete [] pszFileName;

    CTermCap::m_pszFileName = new CHAR[ wcslen(szCmdBuf) +1];
    if( !CTermCap::m_pszFileName )
    {
        return( FALSE );
    }

    _snprintf( CTermCap::m_pszFileName, ONE_KB -1 ,"%lS", szCmdBuf ); // No attack, we allocate the necesary buffer here - Baskar.
    return ( TRUE );
}

bool 
CScraper::CompareAndUpdateVTNT ( WORD wRows, WORD wCols, PCHAR_INFO pCurrent,
                             PCHAR_INFO pLastSeen,
                             PCONSOLE_SCREEN_BUFFER_INFO pCSBI,
                             PCONSOLE_SCREEN_BUFFER_INFO pLastCSBI,
                             bool *pfDifferenceFound )

{
    _TRACE( TRACE_DEBUGGING, "CompareAndUpdateVTNT()" );

    INT result;

    COORD coordDest;
    COORD coSize;
    
    SMALL_RECT srSource;

    *pfDifferenceFound = false;
    
    coordDest.X = wCols;
    coordDest.Y = wRows;
    
    coSize.X = 0;
    coSize.Y = 0;

    srSource.Left = 0;
    srSource.Top  = 0;
    srSource.Right = ( WORD ) ( wCols - 1 );
    srSource.Bottom = ( WORD ) ( wRows - 1 );

    
    SHORT loop1; 
    SHORT loop2;
    DWORD dwLineSize;
    LPSTR lpCurrentWindow;
    LPSTR lpLastSeenWindow;
    LPSTR lpCurrentFirstLine;  
    LPSTR lpLastSeenFirstLine;  
    
    _chVERIFY2( m_hConBufOut = CreateFile( TEXT("CONOUT$"), GENERIC_READ | 
                GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 
                FILE_ATTRIBUTE_NORMAL, 0 ) );

    if( INVALID_HANDLE_VALUE == m_hConBufOut) 
    {
        //Could be an application that does not share its screen buffer
        return ( TRUE );
    }
     
    BOOL dwStatus = 0;
    _chVERIFY2( dwStatus = ReadConsoleOutput( m_hConBufOut, pCurrent, coordDest,
                coSize, &srSource ) ); 
    if( !dwStatus )
    {
        LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, MSG_ERR_READ_CONSOLE, GetLastError() );
        TELNET_CLOSE_HANDLE( m_hConBufOut );
       	return ( FALSE );
    }
    
    _chVERIFY2( dwStatus = GetConsoleScreenBufferInfo( m_hConBufOut, pCSBI ) );
    if( !dwStatus )
    {
        LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, MSG_ERR_READ_CONSOLE, GetLastError() );
        TELNET_CLOSE_HANDLE( m_hConBufOut );
    	return ( FALSE );
    }
  
    TELNET_CLOSE_HANDLE( m_hConBufOut );
    
    dwLineSize  = wCols * sizeof( CHAR_INFO ) ;

    //VERSION2 : to optimize we can compare the whole window 
    //and if no change, return     

    LONG currentBuffBottom, lastSeenBuffBottom, currentBuffTop, lastSeenBuffTop;
    LONG lastRow, currentRow;
    bool checkRestOfBuffer;
    bool isScrolled = 0;
    int  i = 0;

    currentBuffBottom = lastSeenBuffBottom = wRows - 1;
    currentBuffTop = lastSeenBuffTop = 0;

    //The following check is to prevent scrolling when the user hasn't pressed
    //ENTER. This case is reproduced by typing the same command (for eg: dir in     
    //a directory with not too many files) many times until the screen is filled
    //and then type one char extra or less for that command (For "dir", it is
    //"di" or "dir /" ) then the screen scrolls
    //The solution is to see if the only change since the last scraping is
    //only one key stroke( one byte ), if so don't scroll.
    //This may lead to the case that it may scroll when you press up arrow key
    //( 3 bytes ). 

    if( !m_bCheckForScrolling  )
    {
        isScrolled = 1;
    }
    m_bCheckForScrolling = 1;

    if( !m_pSession->CSession::m_bIsTelnetVersion2 )
    {
        //This will make it a non scrolling case.
        isScrolled = 1;
    }
  
    while( currentBuffBottom >= currentBuffTop && !isScrolled )
    {
        checkRestOfBuffer = 1;

        lpCurrentWindow = ( LPSTR ) ( pCurrent + wCols * currentBuffBottom  ) ;
        lpLastSeenWindow = ( LPSTR ) ( pLastSeen + wCols * lastSeenBuffBottom ) ;

        if( memcmp( lpCurrentWindow, lpLastSeenWindow, dwLineSize ) != 0 )
        {
            checkRestOfBuffer = 0;
        }  
        
        if ( checkRestOfBuffer )
        {
            isScrolled = 1;
            if( currentBuffBottom > 0 )
            {
                //need not compare the same line again. Decrement by one.
                currentRow = currentBuffBottom - 1;
                lastRow = lastSeenBuffBottom - 1;

                while( currentRow >= currentBuffTop && isScrolled )
                {
                    lpCurrentWindow = ( LPSTR ) ( pCurrent + wCols * currentRow  ) ;
                    lpLastSeenWindow = ( LPSTR ) ( pLastSeen + wCols * lastRow ) ;

                    if( memcmp( lpCurrentWindow, lpLastSeenWindow, dwLineSize ) != 0 )
                    {
                        isScrolled = 0;
                    }                    
                    currentRow--;
                    lastRow--;
                }
            }
        }

        currentBuffBottom--;
    }
    currentBuffBottom++;

    //Patch to make this work for ONE blank line at the top
    //Without this patch, screen scrolls for each char typed after "cls"
    if( currentBuffBottom == currentBuffTop )
    {
        //check if it is a blank line. Then it is not scrolling.
           for(i = 0; i < wCols; ++i ) 
        {
            if( !IS_BLANK( currentBuffTop , i ) )
            {
                break;
            }
            isScrolled = 0;
        }
    }

    //if it is the same screen
    if( currentBuffBottom + 1 >= wRows )
    {
        isScrolled = 0;
    }
    if( isScrolled )
    {  
        //Now Send all the lines from currentBuffBottom
        //till the end of the buffer

        COORD coordSaveCursorPos = {0,0};
        *pfDifferenceFound = true;

        _TRACE( TRACE_DEBUGGING, "About to send from:%d till:%d", 
                currentBuffBottom + 1, wRows);
        WORD lastChar = wCols;


        // Determine size of changes
        coSize.X = wCols;
        coSize.Y = ( SHORT ) ( ( wRows - 1 ) - currentBuffBottom );

        coordSaveCursorPos.X = pCSBI->dwCursorPosition.X;
        coordSaveCursorPos.Y = pCSBI->dwCursorPosition.Y;

        SendVTNTData( RELATIVE_COORDS, coordSaveCursorPos, coSize, 
                      &srSource, pCurrent + (currentBuffBottom+1) * wCols );

        //
        //Do line by line scraping only if it was not scrolling
        goto next1;
    }

    _TRACE( TRACE_DEBUGGING, "NO scrolling");

    // Compare all lines
    lpCurrentWindow = ( LPSTR ) pCurrent;
    lpLastSeenWindow = ( LPSTR ) pLastSeen;
      
    for( loop1 = 0 ; loop1 < wRows; ) 
    {
         result = memcmp( lpCurrentWindow, lpLastSeenWindow, dwLineSize );
            
         loop1++;
         
         lpCurrentFirstLine = lpCurrentWindow;
         lpLastSeenFirstLine = lpLastSeenWindow;
         
         lpLastSeenWindow += dwLineSize;
         lpCurrentWindow += dwLineSize;

         if( !result )
            continue;

        *pfDifferenceFound = true;

        for( loop2 = loop1 ; loop2 < wRows ; loop2++ ) 
        {
            if( !memcmp ( lpLastSeenWindow, lpCurrentWindow, dwLineSize ) )
               break ;
                  
            lpLastSeenWindow += dwLineSize;
            lpCurrentWindow += dwLineSize;
        }

        if( loop2 == wRows ) 
        {
            lpLastSeenWindow += dwLineSize ;   
            lpCurrentWindow += dwLineSize ;
        }

        // Determine size of changes
        coSize.X = wCols;
        coSize.Y = ( WORD ) ( loop2 - loop1 + 1 );

        srSource.Left = 0;
        srSource.Top  = ( WORD )( 0 + loop1 - 1 );
        srSource.Right = ( WORD )( wCols - 1 );
        srSource.Bottom = ( WORD ) ( srSource.Top + coSize.Y - 1 );

        _TRACE( TRACE_DEBUGGING, "Scrape rom row %d to row %d", loop1, loop2 );
        if( !SendVTNTData( ABSOLUTE_COORDS, pCSBI->dwCursorPosition, coSize, 
                &srSource, ( PCHAR_INFO ) lpCurrentFirstLine ) )
        {
            return( FALSE );
        }
         
        loop1 = loop2 ;
    }

next1:
    if( !( *pfDifferenceFound ) )
    {
        if( memcmp( &pCSBI->dwCursorPosition, &pLastCSBI->dwCursorPosition,
                    sizeof( COORD ) ) != 0 )
        {
     
            *pfDifferenceFound = true;

            //sending no data; only pCSBI->dwCursorPosition are valid 
            //(useful)
            coSize.X = coSize.Y = 0;
            srSource.Top = srSource.Bottom = srSource.Left = srSource.Right = 0;
            if( !SendVTNTData( ABSOLUTE_COORDS, pCSBI->dwCursorPosition, coSize,
                &srSource, NULL ) )
            {
                return( FALSE );
            }
        }
    }

    if( *pfDifferenceFound )
    {
        if( !Transmit() ) 
        {
            return( FALSE );
        }

        // Copy pCurrent onto pLastSeen
        memcpy( pLastSeen, pCurrent, wCols * wRows * sizeof( CHAR_INFO ) );
        memcpy( pLastCSBI, pCSBI, sizeof( CONSOLE_SCREEN_BUFFER_INFO ) );
        
    }
    else
    {
        _TRACE( TRACE_DEBUGGING, "NO difference found\n" );
    }
    return( TRUE );
}

bool 
CScraper::SendVTNTData( WORD wCoordType, 
    COORD coCursor, COORD coRegionSize,
    SMALL_RECT* lpScreenRegion, CHAR_INFO* lpScreenRegionCharInfo  )
{
    bool bRetVal = TRUE;
    VTNT_CHAR_INFO pOutCharInfo;
    DWORD dwSize = sizeof( VTNT_CHAR_INFO ) + 
        ( coRegionSize.X * coRegionSize.Y * sizeof( CHAR_INFO ) );
    SfuZeroMemory(&pOutCharInfo,sizeof(VTNT_CHAR_INFO));
    //csbi.wAttributes is filled by v2 server with following meaning
    //When a scrolling case is detected, this is set to 1.
    pOutCharInfo.csbi.wAttributes = wCoordType;
    pOutCharInfo.coDest.X      = 0;
    pOutCharInfo.coDest.Y      = 0;
    pOutCharInfo.coCursorPos   = coCursor;
    pOutCharInfo.coSizeOfData  = coRegionSize;
    pOutCharInfo.srDestRegion  = *lpScreenRegion;

    SendBytes( ( PUCHAR ) &pOutCharInfo, sizeof( VTNT_CHAR_INFO ) );
    SendBytes( ( PUCHAR ) lpScreenRegionCharInfo, dwSize - sizeof( VTNT_CHAR_INFO) );

    return( bRetVal );
}

void
CScraper::WriteMessageToCmd( WCHAR szMsg[] )
{
    DWORD dwWritten = 0;
 
    if( m_pSession->CIoHandler::m_SocketControlState == m_pSession->CIoHandler::STATE_SESSION )
    {
        _chVERIFY2( m_hConBufOut = CreateFile( TEXT("CONOUT$"), GENERIC_READ |
                    GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, 0 ) );

        if( INVALID_HANDLE_VALUE == m_hConBufOut)
        {
            LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, MSG_ERRCONSOLE, GetLastError() );
            return;
        }

        _chVERIFY2( WriteConsole( m_hConBufOut, szMsg, wcslen( szMsg ), &dwWritten, NULL ) );
        TELNET_CLOSE_HANDLE( m_hConBufOut );
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsess\shell.h ===
// Shell.h : This file contains the
// Created:  Feb '98
// Author : a-rakeba
// History:
// Copyright (C) 1998 Microsoft Corporation
// All rights reserved.
// Microsoft Confidential 

#if !defined( _SHELL_H_ )
#define _SHELL_H_

#include <CmnHdr.h>
#include <TChar.h>

#define LENGTH_OF_PATH_EQUALS 5

class CSession;

class CShell 
{
    CSession* m_pSession;

    HANDLE    m_hCurrUserKey;
    LPVOID    m_lpEnv;
    HANDLE    m_hTempProcess;
    HANDLE    m_hProcess;
    //handles for library modules
    HINSTANCE hUserEnvLib;

    bool       m_bIsLocalHost;
    UCHAR      *m_pucDataFromCmd;
    OVERLAPPED m_oReadFromCmd;
    DWORD      m_dwDataSizeFromCmd;
    HANDLE     m_hReadFromCmd;
    HANDLE     m_hWriteByCmd;


    LPWSTR pHomeDir;
    LPWSTR pHomeDrive;
    LPWSTR pLogonScriptPath;
    LPWSTR pProfilePath;
    LPWSTR pServerName;

    LPWSTR m_pwszAppDataDir;

    bool GetDomainController( LPWSTR, LPWSTR );
    BOOL AreYouHostingTheDomain( LPTSTR , LPTSTR );
    bool CreateIOHandles();
    void DoFESpecificProcessing();
    void GetScriptName( LPWSTR *, LPWSTR * );
#ifdef ENABLE_LOGON_SCRIPT
    void GetUserScriptName( LPWSTR *, LPWSTR );
#endif
    bool StartProcess();
    void LoadLibNGetProc( );
    bool LoadTheProfile();
    bool GetNFillUserPref(LPWSTR, LPWSTR );
    bool GetUsersHomeDirectory( LPWSTR );
    bool GetNameOfTheComputer();
    bool CancelNetConnections();
    void ExportEnvVariables();
    void GetEnvVarData();

    void SetEnvVariables();
#ifdef ENABLE_LOGON_SCRIPT
    BOOL InjectUserScriptPathIntoPath( TCHAR [] );
#endif
    bool GetSystemDrive();
    bool GetTheSystemDirectory( LPWSTR * );
    bool IssueReadFromCmd();
    
    protected:
    void Init( CSession * );
    bool StartUserSession();
    void Shutdown();
    void FreeInitialVariables();
    bool OnDataFromCmdPipe();

    public:
    CShell();
    virtual ~CShell();
    
};

#define DC_LOGON_SCRIPT_PATH           L"\\NetLogon\\"
#define LOCALHOST_LOGON_SCRIPT_PATH    L"\\repl\\import\\scripts\\"
#define AND                            L"&&"
#define QUOTE_AND_SPACE                L"\" "
#define EXIT_CMD                       L"exit"

#define ENV_HOMEPATH                    L"HOMEPATH="
#define ENV_HOMEDRIVE                   L"HOMEDRIVE="
#define ENV_TERM                        L"TERM="
#define ENV_APPDATA                     L"APPDATA="
#define ENV_USERNAME                    L"USERNAME="
#define ENV_USERDOMAIN                  L"USERDOMAIN="
#define ENV_USERPROFILE                 L"USERPROFILE="

#define UNICODE_STR_SIZE(x)             ((sizeof(x) - sizeof(WCHAR)) / sizeof(WCHAR))

void PutStringInEnv( LPTSTR lpStr, LPTSTR *lpSrcEnv, LPTSTR *lpDstEnv, bool bOverwrite);

#endif // _SHELL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsess\session.cpp ===
// Session.cpp : This file contains the
// Created:  Feb '98
// Author : a-rakeba
// History:
// Copyright (C) 1998 Microsoft Corporation
// All rights reserved.
// Microsoft Confidential

#include <cmnhdr.h>
#include <debug.h>

#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>
#include <lmwksta.h>

#include <MsgFile.h>
#include <Telnetd.h>
#include <Session.h>
#include <TlntUtils.h>
#include <RegUtil.h>


#pragma warning( disable: 4127 )
#pragma warning( disable: 4706 )

using namespace _Utils;
using CDebugLevel::TRACE_DEBUGGING;
using CDebugLevel::TRACE_HANDLE;
using CDebugLevel::TRACE_SOCKET;

extern HANDLE       g_hSyncCloseHandle;

CSession::CSession() : CIoHandler(), CRFCProtocol(), CShell(), CScraper()
{
    m_bNtVersionGTE5 = false;
    m_dwTickCountAtLogon = 0;
    m_wNumFailedLogins = 0;
    m_bContinueSession = true;
    m_dwHandleCount = 0;
    m_wIsAnAdmin = DONT_KNOW;
    
    m_bIsStreamMode = false; 
    m_bIsTelnetClientsGroupMember = false;

    m_hLogHandle = NULL;
    m_hToken = NULL;

    m_bIsTelnetVersion2 = false;
    m_AuthenticationId.HighPart = m_AuthenticationId.LowPart = 0;
    m_pszTermType[0] = 0;
    m_bNegotiatedTermType = false;
    m_wCols = DEFAULT_COLS;
    m_wRows = DEFAULT_ROWS;

    m_dwAllowTrustedDomain = DEFAULT_ALLOW_TRUSTED_DOMAIN;
    m_dwIdleSessionTimeOut = DEFAULT_IDLE_SESSION_TIME_OUT;
    m_pszDefaultDomain      = NULL;
    m_pszDefaultShell = NULL;
    m_pszDifferentShell = NULL;
    m_pszSwitchToKeepShellRunning = NULL;
    m_pszSwitchForOneTimeUseOfShell = NULL;
    m_pszLoginScript  = NULL;
    m_dwNTLMSetting   = DEFAULT_SECURITY_MECHANISM;
    m_dwMaxFailedLogins = DEFAULT_MAX_FAILED_LOGINS;
    m_dwSysAuditing =  DEFAULT_SYSAUDITING;
    m_dwLogEvents   =  DEFAULT_LOGEVENTS;
    m_dwLogAdmin    =  DEFAULT_LOGADMIN;
    m_dwLogFailures =  DEFAULT_LOGFAILURES;
    m_dwLogToFile   =  DEFAULT_LOGTOFILE;

    m_pszUserName[0] = 0;
    m_szMachineName[0] = 0;
    m_szPeerHostName[0] = 0;
    m_szUser[0] = L'\0';
    m_szDomain[0] = L'\0';

    administrators = pTelnetClientsSid = NULL;
}

void
CSession::FreeInitialVariables()
{
    CShell::FreeInitialVariables();
    
    delete [] m_pszDifferentShell;
    delete [] m_pszDefaultDomain;
    delete [] m_pszDefaultShell;
    delete [] m_pszSwitchForOneTimeUseOfShell;
    delete [] m_pszSwitchToKeepShellRunning;
    delete [] m_pszLoginScript;

    m_pszDefaultDomain              = NULL;
    m_pszSwitchForOneTimeUseOfShell = NULL;
    m_pszDefaultShell               = NULL;
    m_pszSwitchToKeepShellRunning   = NULL;
    m_pszLoginScript                = NULL;
    m_pszDifferentShell             = NULL;

}

CSession::~CSession()
{
    FreeInitialVariables();
    FreeSid(administrators);
    delete pTelnetClientsSid;
    TELNET_CLOSE_HANDLE( m_hToken );
}

bool
CSession::Init()
{
    // get a handle to log events with
    _chVERIFY2( m_hLogHandle = RegisterEventSource(NULL, L"TlntSvr" ) );
    //Get the registry values from HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\TelnetServer
    if( !GetRegistryValues( ) )
    {
        return( FALSE );
    }

    if( !CIoHandler::Init( this ) )
    {
        return( FALSE ); 
    }

    CShell::Init( this );
    CRFCProtocol::Init( this );
    CScraper::Init( this );

    SetLastError( 0 );

    AddHandleToWaitOn( CIoHandler::m_oReadFromPipe.hEvent );
    if( !CIoHandler::IssueFirstReadOnPipe() )
    {
        return( FALSE );
    }

    CScraper::m_dwPollInterval = PRE_SESSION_STATE_TIMEOUT;
    
    return ( TRUE );
}

void
CSession::AddHandleToWaitOn( HANDLE hNew )
{
    _chASSERT( m_dwHandleCount < MAX_HANDLES );
    _chASSERT( hNew );

    m_rghHandlestoWaitOn[ m_dwHandleCount ] = hNew;
    m_dwHandleCount++;
}

#define HALF_K 512

void
CSession::WaitForIo()
{
    DWORD dwRetVal = WAIT_FAILED;
    char szMessageBuffer[HALF_K + 1];   
    while( m_bContinueSession )
    {
        dwRetVal = WaitForMultipleObjects(m_dwHandleCount, 
                m_rghHandlestoWaitOn, FALSE, CScraper::m_dwPollInterval );

        switch( dwRetVal )
        {
            case PIPE_READ :
                            m_bContinueSession = 
                                CIoHandler::OnReadFromPipeCompletion(); 
                            break;
            case SOCKET_READ:
                            m_bContinueSession = 
                                CIoHandler::OnReadFromSocketCompletion();
                            break;
            case CMD_KILLED:
                            m_bContinueSession = false;
                            break;
            case READ_FROM_CMD :
                            m_dwPollInterval = MIN_POLL_INTERVAL;                            
                            m_bContinueSession = CShell::OnDataFromCmdPipe();
                            break;
            case WAIT_TIMEOUT:
                            if( CIoHandler::m_SocketControlState == STATE_AUTH_NAME
                                || CIoHandler::m_SocketControlState == STATE_AUTH_PASSWORD )
                            {
                                DWORD dwNumBytesWritten = 0;
                                _snprintf( szMessageBuffer, HALF_K, "\r\n%s\r\n%s", TIMEOUT_STR, TERMINATE );
                                CIoHandler::SendTerminateString(szMessageBuffer);
                                CIoHandler::WriteToClient( );
			                       FinishIncompleteIo( ( HANDLE ) CIoHandler::m_sSocket, 
                                    &( CIoHandler::m_oWriteToSocket) , &dwNumBytesWritten );
                                m_bContinueSession = false;
                            }
                            else 
                            {
                                m_bContinueSession = CScraper::OnWaitTimeOut();
                                if( m_bContinueSession )
                                {
                                    m_bContinueSession = ( CScraper::IsSessionTimedOut() == false );
                                }
                            }
                            break;
            default:
                            //incase WAIT_FAILED, call GetLastError()
                             _chVERIFY2( dwRetVal != WAIT_FAILED );
                             m_bContinueSession = false;
        }
    }
    return;
}

void
CSession::CollectPeerInfo ()
{
    m_dwTickCountAtLogon = GetTickCount();
    INT len = sizeof( m_ssPeerAddress );
    TCHAR szDebugString[500];
    if( getpeername(CIoHandler::m_sSocket, (struct sockaddr *) &m_ssPeerAddress, 
                &len) == SOCKET_ERROR )
    {
        _TRACE( TRACE_DEBUGGING, "Error: getpeername() : %lu", GetLastError() );
    }
    if( getnameinfo((SOCKADDR*)&m_ssPeerAddress, len, CSession::m_szPeerHostName, sizeof(CSession::m_szPeerHostName)-1,
        NULL, 0, NI_NUMERICHOST)
      )
    {
        _TRACE( TRACE_DEBUGGING, "Error: getnameinfo() : %d", (DWORD)GetLastError() );
    }
    else
    {
        _TRACE(TRACE_DEBUGGING, "getnameinfo() : %s",CSession::m_szPeerHostName);
    }
  	
    if(getnameinfo((SOCKADDR*)&m_ssPeerAddress, len, m_szMachineName, sizeof(m_szMachineName)-1,
        NULL, 0, 0)
      )
    {
        _TRACE( TRACE_DEBUGGING, "Error: getnameinfo() - machinename : %d", (DWORD)GetLastError() );
        strcpy( m_szMachineName, "" ); // No Attack :-) Baskar
    }
    else
    {
        _TRACE(TRACE_DEBUGGING, "getnameinfo() - machinename : %s",m_szMachineName);
    }

    return;
}

bool 
CSession::GetRegistryValues()
{
    DWORD dwRetVal;
    HKEY hk  = NULL;
    DWORD dwDisp = 0;

    if( dwRetVal = TnSecureRegCreateKeyEx( HKEY_LOCAL_MACHINE, REG_PARAMS_KEY, NULL, NULL, 
                        REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED , NULL, &hk, &dwDisp, 0) )
    {
        _TRACE( TRACE_DEBUGGING, "Error: RegCreateKey() -- 0x%1x", dwRetVal);
        LogEvent( EVENTLOG_ERROR_TYPE, MSG_REGISTRYKEY, REG_PARAMS_KEY );
        return ( FALSE );
    }

    if( !GetRegistryDW( hk, NULL, L"MaxFailedLogins", &m_dwMaxFailedLogins,
                        DEFAULT_MAX_FAILED_LOGINS,FALSE ) )
    {
        return false;
    }

    if( !GetRegistryDW( hk, NULL, L"AllowTrustedDomain", &m_dwAllowTrustedDomain,
                        DEFAULT_ALLOW_TRUSTED_DOMAIN,FALSE ) )
    {
        return false;
    }
    if( !GetRegistryDW( hk, NULL, L"SecurityMechanism", &m_dwNTLMSetting, 
                        DEFAULT_SECURITY_MECHANISM,FALSE ) )
    {
        return false;
    }
    if( !GetRegistryDW( hk, NULL, L"LogToFile", &m_dwLogToFile,
                        DEFAULT_LOGTOFILE,FALSE ) )
    {
        return false;
    }
    if( !GetRegistryDW( hk, NULL, L"EventLoggingEnabled", &m_dwSysAuditing,
                         DEFAULT_SYSAUDITING,FALSE ) )
    {
        return false;
    }
    if( !GetRegistryDW( hk, NULL, L"LogNonAdminAttempts", &m_dwLogEvents,
                        DEFAULT_LOGEVENTS,FALSE ) )
    {
        return false;
    }
    if( !GetRegistryDW( hk, NULL, L"LogAdminAttempts", &m_dwLogAdmin,
                        DEFAULT_LOGADMIN,FALSE ) )
    {
        return false;
    }
    if( !GetRegistryDW( hk, NULL, L"LogFailures", &m_dwLogFailures,
                        DEFAULT_LOGFAILURES,FALSE ) )
    {
        return false;
    }

    DWORD dwModeOfOperation = DEFAULT_MODE_OF_OPERATION;
    DWORD dwKillAllApps;
    if( !GetRegistryDW( hk, NULL, L"AltKeyMapping",  &m_dwAltKeyMapping,
                        DEFAULT_ALT_KEY_MAPPING,FALSE ) )
    {
        return false;
    }
    if( !GetRegistryDW( hk, NULL, L"IdleSessionTimeOut", &m_dwIdleSessionTimeOut,
                        DEFAULT_IDLE_SESSION_TIME_OUT,FALSE ) )
    {
        return false;
    }
    if( !GetRegistryDW( hk, NULL, L"DisconnectKillAllApps", &dwKillAllApps,
                        DEFAULT_DISCONNECT_KILLALL_APPS,FALSE ) )
    {
        return false;
    }
    if( !GetRegistryDW( hk, NULL, L"ModeOfOperation", &dwModeOfOperation,
                        DEFAULT_MODE_OF_OPERATION,FALSE ) )
    {
        return false;
    }

    m_bIsStreamMode = false;
    if( dwModeOfOperation == STREAM_MODE )
    {
        m_bIsStreamMode = true;    
    }

    if( !GetRegistryString( hk, NULL, L"DefaultShell", &m_pszDefaultShell,
                        DEFAULT_SHELL,FALSE ) )
    {
        return false;
    }
    if( !GetRegistryString( hk, NULL, SWITCH_TO_KEEP_SHELL_RUNNING,  
                   &m_pszSwitchToKeepShellRunning, 
                   DEFAULT_SWITCH_TO_KEEP_SHELL_RUNNING ,FALSE) )
    {
        return false;
    }
    if( !GetRegistryString( hk, NULL, SWITCH_FOR_ONE_TIME_USE_OF_SHELL,  
                   &m_pszSwitchForOneTimeUseOfShell, 
                   DEFAULT_SWITCH_FOR_ONE_TIME_USE_OF_SHELL,FALSE ) )
    {
        return false;
    }

    if( !GetRegistryString( hk, NULL, L"Shell", &m_pszDifferentShell, L"",FALSE ) )
    {
        return false;
    }

    //When server comes up it creates all keys. So, assume they are available.
    //Default values need not be correct as in the case of following.
    if( !GetRegistryString( hk, NULL, L"LoginScript", &m_pszLoginScript, L"",FALSE ) )
    {
        return false;
    }
    if( !GetRegistryString( hk, NULL, L"DefaultDomain", &m_pszDefaultDomain,
                       DEFAULT_DOMAIN,FALSE ) )
    {
        return false;
    }

    RegCloseKey( hk );

    if( !GetWindowsVersion( &m_bNtVersionGTE5 ) )
    {
        return( FALSE );
    }
    return( TRUE );
}

#ifdef LOGGING_ENABLED        
//This function logs the logon/logoff details as opted by the user.
//This function can be furthur optimized by using the values calculated at logon
//at the time of logoff.
void 
CSession::LogIfOpted( BOOL result, LOGEVENT logon, BOOL bNTLMAuth )
{
    
    LPWSTR wideLogStr;
    UCHAR *logStr;
    BOOL isAdmin = false;

    if( result == LOGOFF &&  !m_dwLogFailures )
    {
        return;
    }
    if ( result == LOGON && !m_dwLogAdmin && !m_dwLogEvents)
    {
        return;
    }
    if ( result == LOGON && ( m_dwLogAdmin || m_dwLogEvents ) )
    {
        if( m_wIsAnAdmin == DONT_KNOW )
        {
            IsAnAdminstratorOrMember();
        }
        ( m_wIsAnAdmin == ADMIN) ? isAdmin = true : isAdmin = false;

        if ( !isAdmin && !m_dwLogEvents )
        {
            return;
        }
        if( isAdmin &&  !m_dwLogAdmin )
        {
            return;
        }
    }

    if (!result && bNTLMAuth)
    {
        DWORD dwSize = strlen(NTLM_LOGON_FAILED) + 
                       strlen(CSession::m_szPeerHostName) +
                       strlen(CSession::m_szMachineName) + 1;
        logStr = new UCHAR[IPC_HEADER_SIZE + dwSize];
        if (!logStr)
        {
            return;
        }
        SfuZeroMemory(logStr, IPC_HEADER_SIZE + dwSize);
        logStr[0] = AUDIT_CLIENT;
        memcpy(logStr + 1, &dwSize, sizeof(DWORD)); // No Attack :-), Baskar
        _snprintf((LPSTR)(logStr + IPC_HEADER_SIZE), (dwSize - 1), NTLM_LOGON_FAILED, CSession::m_szPeerHostName,
                                                                      CSession::m_szMachineName);
        if (m_dwSysAuditing)
        {
            ConvertSChartoWChar( ( LPSTR )( logStr+IPC_HEADER_SIZE ), &wideLogStr );
            LogEvent(EVENTLOG_AUDIT_FAILURE, 0, wideLogStr);
        }

        if (m_dwLogToFile)
        {
            WriteToPipe(CIoHandler::m_hWritePipe, (LPVOID)logStr,
                    IPC_HEADER_SIZE + dwSize, &(CIoHandler::m_oWriteToPipe));
        }
        delete[] logStr;

        return;
    }

    DWORD dwRestOfMsgLen =  strlen( ADMINISTRATOR ) + 
                            strlen( CSession::m_pszDomain) +
                            strlen( BLANK ) +
                            strlen( CSession::m_pszUserName ) + 
                            strlen( BLANK ) +
                            strlen( FAILED_TO_LOG ) +
                            strlen( BLANK ) +
                            strlen( OFF ) +
                            strlen( BLANK ) +
                            strlen( FROM ) +
                            strlen( BLANK ) +
                            strlen( CSession::m_szPeerHostName ) +
                            strlen( BLANK ) +
                            strlen( CSession::m_szMachineName ) + 1 ;

    logStr = new UCHAR[ IPC_HEADER_SIZE + dwRestOfMsgLen ];
    if( !logStr )
    {
        return;
    }

    logStr[0] = AUDIT_CLIENT;
    memcpy( logStr+1, &dwRestOfMsgLen, sizeof( DWORD ) ); // No Attack, Baskar :-)
    _snprintf( ( LPSTR )( logStr+IPC_HEADER_SIZE ), (dwRestOfMsgLen - 1), "%s%s\\%s %s %s %s %s %s",
                    isAdmin ? ADMINISTRATOR : "",
                    CSession::m_pszDomain,
                    CSession::m_pszUserName,
                    result ? LOGGED : FAILED_TO_LOG,
                    logon ? ON : OFF,
                    FROM,
                    CSession::m_szPeerHostName,
                    CSession::m_szMachineName );

    if( m_dwSysAuditing )
    {
        ConvertSChartoWChar( ( LPSTR )( logStr+IPC_HEADER_SIZE ), &wideLogStr );
        LogEvent( result ? ( WORD )EVENTLOG_AUDIT_SUCCESS: 
                ( WORD )EVENTLOG_AUDIT_FAILURE, 0, wideLogStr );
        delete[] wideLogStr;
    }

    if( m_dwLogToFile )
    {
        WriteToPipe( CIoHandler::m_hWritePipe, ( LPVOID )logStr, 
            IPC_HEADER_SIZE + dwRestOfMsgLen, &( CIoHandler::m_oWriteToPipe ) );
    }

    delete[] logStr;
}
#endif

bool
CSession::IsAnAdminstratorOrMember()
{
    TOKEN_GROUPS    *buffer = NULL;
    DWORD           needed_length = 0;
    BOOL            success = FALSE;
    ULONG           x;
    TCHAR           szDomain[ MAX_PATH + 1 ];
    DWORD           dwDomainLen = MAX_PATH + 1;
    SID_NAME_USE    sidNameUse;


    m_wIsAnAdmin = NON_ADMIN;
    m_bIsTelnetClientsGroupMember = false;

    if (NULL == administrators)
    {
        SID_IDENTIFIER_AUTHORITY local_system_authority = SECURITY_NT_AUTHORITY;

        if (! AllocateAndInitializeSid(
                &local_system_authority,
                2, /* there are only two sub-authorities */
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0,0,0,0,0,0, /* Don't care about the rest */
                &administrators
                ))
        {
            administrators = NULL;
            return false;
        }
    }

    if (NULL == pTelnetClientsSid) 
    {
        needed_length   = 0;
        DWORD dwErr     = 0;

        LookupAccountName( NULL, TELNETCLIENTS_GROUP_NAME, pTelnetClientsSid, &needed_length, 
                           szDomain, &dwDomainLen, &sidNameUse );
        pTelnetClientsSid  = ( PSID ) new UCHAR[ needed_length ];

        //Even if if allocation fails just go ahead.

        success = LookupAccountName( NULL, TELNETCLIENTS_GROUP_NAME, pTelnetClientsSid, &needed_length, 
                           szDomain, &dwDomainLen, &sidNameUse );
        if( !success ) 
        {
            if (pTelnetClientsSid) 
            {
                delete pTelnetClientsSid;
                pTelnetClientsSid = NULL;
            }
            //return false;
            //We should not return back if TelnetClients group does not exist
        }
    }

    /* We are making the first call to GetTokenInformation to get the size of
       the memory required for the group data */

    _chVERIFY2( success = GetTokenInformation( m_hToken, TokenGroups, buffer, 
                        0, &needed_length) );

    buffer = (TOKEN_GROUPS *)GlobalAlloc(GPTR, needed_length);
    if (buffer == NULL)
    {
        return false;
    }

    _chVERIFY2( success = GetTokenInformation( m_hToken, TokenGroups, buffer,
                needed_length, & needed_length) );
    if (! success)
    {
        _TRACE(TRACE_DEBUGGING,L"GetTokenInformation failed");
        GlobalFree(buffer);
        return false;
    }
    _TRACE(TRACE_DEBUGGING,L"GetTokenInformation succeeded Token = 0x%lx", m_hToken);
    success = FALSE;

    for (x = 0; x < buffer->GroupCount; x ++)
    {
        if (EqualSid(buffer->Groups[x].Sid, administrators) &&
            (buffer->Groups[x].Attributes & SE_GROUP_ENABLED) && 
            (!(buffer->Groups[x].Attributes & SE_GROUP_USE_FOR_DENY_ONLY))
          )
        {
            m_bIsTelnetClientsGroupMember = true;
            m_wIsAnAdmin = ADMIN;
            break;
        }

        if( pTelnetClientsSid && !m_bIsTelnetClientsGroupMember )
        {
            if ( EqualSid(buffer->Groups[x].Sid, pTelnetClientsSid ))
            {
                m_bIsTelnetClientsGroupMember = true;
                break;
            }
        }
    }

    GlobalFree(buffer);
    
    return ( success ? true : false );
}


void
CSession::Shutdown()
{
#ifdef LOGGING_ENABLED        
    if( m_fLogonUserResult )
    {
        LogIfOpted( SUCCESS, LOGOFF );
    }
#endif    
    CScraper::Shutdown();
    CIoHandler::Shutdown();
    CShell::Shutdown();
    _chVERIFY2( DeregisterEventSource( m_hLogHandle ) );
}

bool
CSession::CheckGroupMembership ( bool *fIsAdmin, bool *pfIsTelnetClientsMember)
{
    *pfIsTelnetClientsMember = false;
    *fIsAdmin = false;

    if( m_wIsAnAdmin == DONT_KNOW )
    {
        IsAnAdminstratorOrMember();
    }
    if( m_wIsAnAdmin == ADMIN) 
    {
        *fIsAdmin = true;
        *pfIsTelnetClientsMember = true; //All admins are default members.
                                         // As defined by US :-)))
    }

   *pfIsTelnetClientsMember = m_bIsTelnetClientsGroupMember;

    return( true );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsess\security.cpp ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
/*
security.cpp
*/
#ifdef WHISTLER_BUILD
#include "ntverp.h"
#else
#include <solarver.h>
#endif //WHISTER_BUILD

#include <stddef.h>

#include <common.ver>

#include <debug.h>
#include <TlntUtils.h>
#include <iohandlr.h>
#include <issperr.h>
#include <TelnetD.h>
#include <Session.h>

using namespace _Utils;
using CDebugLevel::TRACE_DEBUGGING;
using CDebugLevel::TRACE_HANDLE;
using CDebugLevel::TRACE_SOCKET;

#pragma warning( disable: 4127 )
#pragma warning( disable: 4706 )

extern HANDLE       g_hSyncCloseHandle;

bool CIoHandler::StartNTLMAuth()
{
    TimeStamp  tsExpiry;
    SECURITY_STATUS secStatus;

    m_hContext.dwLower = m_hContext.dwUpper = 0 ;
	m_hCredential.dwLower = m_hCredential.dwUpper = 0 ;

    if ( SEC_E_OK != (secStatus = AcquireCredentialsHandle(
                            NULL,  // name of principal
                            L"NTLM", // name of package
                            SECPKG_CRED_BOTH,  // flags indicating use
                            NULL, //PLUID pvLogonID,       // pointer to logon identifier
                            NULL, //PVOID pAuthData,       // package-specific data
                            NULL, //PVOID pGetKeyFn,       // pointer to GetKey function
                            NULL, //PVOID pvGetKeyArgument,  // value to pass to GetKey
                            &m_hCredential,  // credential handle
                            &tsExpiry) ) )  // life time of the returned credentials);
    {
        return false;
    }

    secStatus = QuerySecurityPackageInfo(L"NTLM", &m_pspi);

    if ( secStatus != SEC_E_OK )
    {
        return false;
    }
    
    
    return true;
}



bool
CIoHandler::DoNTLMAuth( PUCHAR pBuffer, DWORD dwSize, PUCHAR* pBuf )
{
    m_SocketControlState = CIoHandler::STATE_NTLMAUTH;

	SECURITY_STATUS secStatus;
	SecBufferDesc   InBuffDesc;
	SecBuffer       InSecBuff;
	SecBufferDesc   OutBuffDesc;
	SecBuffer       OutSecBuff;
	ULONG fContextAttr;
	TimeStamp tsExpiry;

    __try
	{
		OutSecBuff.pvBuffer = NULL;

		// if we are getting nothing then we fail.
		if( dwSize == 0 )
		{
			goto error;
		}

		// make sure we get only NTLM now - thats the only thing we support
		if( *pBuffer != AUTH_TYPE_NTLM )
		{
			goto error;
		}

		if( dwSize < ( 3 + sizeof( SecBuffer ) )) 
		{
			goto error;
		}

		// get past the auth type and the modifier byte and the Auth scheme.
		pBuffer += 3;
		dwSize -= 3;


		//
		//  Prepare our Input buffer - Note the server is expecting the client's
		//  negotiation packet on the first call
		//

		InBuffDesc.ulVersion = SECBUFFER_VERSION;
		InBuffDesc.cBuffers  = 1;
		InBuffDesc.pBuffers  = &InSecBuff;

        // Copy the 1st two fields of SecBuffer from pBuffer to pInSecBuffer. Use memcpy because
        // pBuffer is not guaranteed to be an aligned pointer.
        memcpy((PVOID)&InSecBuff, (PVOID)pBuffer, offsetof(SecBuffer, pvBuffer)); // NO Attack here, Baskar.
        
		// if we don't have enough buffer then let this call return
		if( dwSize < InSecBuff.cbBuffer )
		{
			//m_pReadFromSocketBufferCursor += dwSize;
			return false;
		}

		InSecBuff.pvBuffer = (PVOID)(pBuffer + offsetof(SecBuffer, pvBuffer));

		//
		//  Prepare our output buffer.  We use a temporary buffer because
		//  the real output buffer will most likely need to be uuencoded
		//

		OutBuffDesc.ulVersion = SECBUFFER_VERSION;
		OutBuffDesc.cBuffers  = 1;
		OutBuffDesc.pBuffers  = &OutSecBuff;

		OutSecBuff.cbBuffer   = m_pspi->cbMaxToken;
		OutSecBuff.BufferType = SECBUFFER_TOKEN;
		OutSecBuff.pvBuffer   = new WCHAR[m_pspi->cbMaxToken];
		if( !OutSecBuff.pvBuffer )
		{
			return false;
		}

		SfuZeroMemory( OutSecBuff.pvBuffer, m_pspi->cbMaxToken );

		secStatus = AcceptSecurityContext(
									&m_hCredential,  // handle to the credentials
									((fDoNTLMAuthFirstTime) ? NULL: &m_hContext),     // handle of partially formed context
									&InBuffDesc,     // pointer to the input buffers
									ASC_REQ_REPLAY_DETECT |
									ASC_REQ_MUTUAL_AUTH |
									ASC_REQ_DELEGATE,         // required context attributes
									SECURITY_NATIVE_DREP,       // data representation on the target
									&m_hContext,  // receives the new context handle
									&OutBuffDesc,    // pointer to the output buffers
									&fContextAttr,      // receives the context attributes
									&tsExpiry       // receives the life span of the security context
											);
	}
	__except( EXCEPTION_EXECUTE_HANDLER )
	{
		secStatus = SEC_E_LOGON_DENIED;
	}
 
    switch ( secStatus ) {
    case SEC_E_OK:
        m_bNTLMAuthenticated = true;

        // done with the authentication, we need to send an accept to the client.
        (*pBuf)[0] = TC_IAC;
        (*pBuf)[1] = TC_SB;
        (*pBuf)[2] = TO_AUTH;
        (*pBuf)[3] = AU_REPLY;
        (*pBuf)[4] = AUTH_TYPE_NTLM;
        (*pBuf)[5] = AUTH_CLIENT_TO_SERVER | AUTH_HOW_ONE_WAY;
        (*pBuf)[6] = NTLM_ACCEPT;
      
        (*pBuf)[7] = TC_IAC;
        (*pBuf)[8] = TC_SE;
        *pBuf += 9;

        m_SocketControlState = CIoHandler::STATE_CHECK_LICENSE;

        if( m_bNTLMAuthenticated )
        {
            GetUserName(); 
            //Needed for logging at logging off
            m_pSession->m_fLogonUserResult = SUCCESS; 
        }

        break;

    case SEC_I_COMPLETE_NEEDED: 
    case SEC_I_COMPLETE_AND_CONTINUE:
        // these two return values should never be returned for NTLM.
        // so we treat them as if we need a continue.  we send the data to the client
        // and wait for something to come back.
    case SEC_I_CONTINUE_NEEDED:

        fDoNTLMAuthFirstTime = false;

        (*pBuf)[0] = TC_IAC;
        (*pBuf)[1] = TC_SB;
        (*pBuf)[2] = TO_AUTH;
        (*pBuf)[3] = AU_REPLY;
        (*pBuf)[4] = AUTH_TYPE_NTLM;
        (*pBuf)[5] = AUTH_CLIENT_TO_SERVER | AUTH_HOW_ONE_WAY;
        (*pBuf)[6] = NTLM_CHALLENGE;
        *pBuf += 7;
        
        {        
        DWORD dwResultSize = sizeof( OutSecBuff ) - sizeof( LPSTR );
        StuffEscapeIACs( *pBuf, ( PUCHAR ) &OutSecBuff, &dwResultSize );

        *pBuf += dwResultSize;

        dwResultSize = OutSecBuff.cbBuffer;
        StuffEscapeIACs( *pBuf, ( PUCHAR ) OutSecBuff.pvBuffer, &dwResultSize );
        *pBuf += dwResultSize;
        }

        *(*pBuf) = TC_IAC;
        *pBuf +=1;
        *(*pBuf) = TC_SE;
        *pBuf +=1;
        break;


    default:
#ifdef LOGGING_ENABLED                
        m_pSession->LogIfOpted( FAIL, LOGON, true ); 
#endif
        // AcceptSecurityContext returned a value which we don't like.
        // We Reject the NTLM authentication and then continue with the clear text user name
        // and password.
        (*pBuf)[0] = TC_IAC;
        (*pBuf)[1] = TC_SB;
        (*pBuf)[2] = TO_AUTH;
        (*pBuf)[3] = AU_REPLY;
        (*pBuf)[4] = AUTH_TYPE_NTLM;
        (*pBuf)[5] = AUTH_CLIENT_TO_SERVER | AUTH_HOW_ONE_WAY;
        (*pBuf)[6] = NTLM_REJECT;
      
        (*pBuf)[7] = TC_IAC;
        (*pBuf)[8] = TC_SE;
        *pBuf += 9;

        strncpy( (char *)*pBuf, NTLM_LOGON_FAIL,MAX_READ_SOCKET_BUFFER); // No Attack, internal Baskar ?
        *pBuf += strlen(NTLM_LOGON_FAIL);

        switch( secStatus )
        {
            case SEC_E_INVALID_TOKEN:
            case SEC_E_INVALID_HANDLE:
            case SEC_E_INTERNAL_ERROR:
                strncpy( (char *)*pBuf, INVALID_TOKEN_OR_HANDLE,MAX_READ_SOCKET_BUFFER); // No Attack, internal Baskar ? 
                *pBuf += strlen(INVALID_TOKEN_OR_HANDLE);
                break;
            case SEC_E_LOGON_DENIED:
                strncpy( (char *)*pBuf, LOGON_DENIED,MAX_READ_SOCKET_BUFFER); // No Attack, internal Baskar ? 
                *pBuf += strlen(LOGON_DENIED);
                break;
            case SEC_E_NO_AUTHENTICATING_AUTHORITY:
                strncpy( (char *)*pBuf, NO_AUTHENTICATING_AUTHORITY,MAX_READ_SOCKET_BUFFER); // No Attack, internal Baskar ? 
                *pBuf += strlen(NO_AUTHENTICATING_AUTHORITY);
                break;
            default:
                strncpy( (char *)*pBuf, NTLM_REJECT_STR,MAX_READ_SOCKET_BUFFER); // No Attack, internal Baskar ? 
                *pBuf += strlen(NTLM_REJECT_STR);
                break;
        }
        strncpy( (char *)*pBuf, USE_PASSWD,MAX_READ_SOCKET_BUFFER); // No Attack, internal Baskar ? 
        *pBuf += strlen(USE_PASSWD);
error:
        char* p = (char*)*pBuf;

        if( m_pSession->m_dwNTLMSetting == NTLM_ONLY )
        {
            sprintf(p, "%s%s", NTLM_ONLY_STR, TERMINATE); // No Attack, internal Baskar ? 
            *pBuf += strlen(p);

            m_SocketControlState = CIoHandler::STATE_TERMINATE;
            m_pSession->CIoHandler::m_fShutDownAfterIO = true;
        }
        else
        {
            m_SocketControlState = CIoHandler::STATE_BANNER_FOR_AUTH;
        }
    }

    if ( OutSecBuff.pvBuffer != NULL )
        delete [] OutSecBuff.pvBuffer;

    return true;
}

bool
CIoHandler::GetUserName()
{
    bool    success = false;
    int  iStatus = 0;

    if ( m_pSession->CIoHandler::m_bNTLMAuthenticated )
    {
        HANDLE hToken = NULL;
        HANDLE hTempToken = NULL;

        if (SEC_E_OK == ImpersonateSecurityContext(&m_pSession->CIoHandler::m_hContext))
        {
            if (OpenThreadToken(
                    GetCurrentThread(),
                    TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY,
                    FALSE, 
                    &hTempToken
                    ))
            {
                if (DuplicateTokenEx(
                            hTempToken,
                            MAXIMUM_ALLOWED, //TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE | TOKEN_QUERY, 
                            NULL,
                            SecurityImpersonation,
                            TokenPrimary,
                            &hToken
                            ))
                {
                    DWORD dwSizeReqd;
                    TOKEN_USER *tokenData;

                    GetTokenInformation( 
                                hToken, 
                                TokenUser, 
                                NULL, 
                                0, 
                                &dwSizeReqd 
                                );  // This call must fail with insufficient buffer

                    tokenData = (TOKEN_USER*) new BYTE[dwSizeReqd];

                    //allocate that memory
                    if (NULL != tokenData)
                    {
                        //actually get the user info
                        if (0 != GetTokenInformation( 
                                    hToken, 
                                    TokenUser, 
                                    (LPVOID)tokenData, 
                                    dwSizeReqd,
                                    &dwSizeReqd 
                                    ))
                        {
                            //convert user SID into a name and domain
                            SID_NAME_USE sidType;
                            DWORD dwStrSize1 = MAX_PATH + 1;
                            DWORD dwStrSize2 = MAX_PATH + 1;

                            WCHAR szUser [ MAX_PATH + 1 ];
                            WCHAR szDomain [ MAX_PATH + 1 ];

                            if(LookupAccountSid( NULL, tokenData->User.Sid,
                                szUser, &dwStrSize1,
                                szDomain, &dwStrSize2, &sidType ) )
                            {
                                dwStrSize2++; //To account for null char at the end
                                dwStrSize1++;

                                //LookupAccountSid seems to return data as per 1252. Convert accordingly
                                _chVERIFY2( iStatus = WideCharToMultiByte( GetConsoleCP(), 0, szUser, 
                                    -1, m_pSession->m_pszUserName, dwStrSize1, NULL, NULL ) );

                                _chVERIFY2( iStatus = WideCharToMultiByte( GetConsoleCP(), 0, szDomain, 
                                    -1, m_pSession->m_pszDomain, dwStrSize2, NULL, NULL ) );

                                wcscpy(m_pSession->m_szDomain,szDomain);

                                success = true;
                            }
                            else
                            {
                                _TRACE( TRACE_DEBUGGING, "Error: LookupAccountSid()" );
                            }
                        }
                        else
                        {
                            _TRACE( TRACE_DEBUGGING, "Error: GetTokenInformation()" );
                        }

                        delete [] tokenData;
                    }

                    m_pSession->m_hToken = hToken;

                }
                else
                {
                    _TRACE( TRACE_DEBUGGING, "Error: DuplicateTokenEx() - 0x%lx", 
                            GetLastError());
                    _chASSERT( 0 );
                }

                TELNET_CLOSE_HANDLE(hTempToken);
            }
            else
            {
                _TRACE( TRACE_DEBUGGING, "Error: OpenThreadToken() - 0x%lx", 
                        GetLastError());
                _chASSERT( 0 );
            }

            if(SEC_E_OK != RevertSecurityContext( &m_pSession->CIoHandler::m_hContext ))
            {
                _TRACE( TRACE_DEBUGGING, "Error: RevertSecurityContext() - "
                        "0x%lx", GetLastError());
                _chASSERT(  0  );
            }
        }
        else
        {
            _TRACE( TRACE_DEBUGGING, "Error: ImpersonateSecurityContext() - "
                    "0x%lx", GetLastError());
            _chASSERT( 0 );
        }
    }

    return success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsess\scraper.h ===
// scraper.cpp : This file contains the
// Created:  Dec '97
// History:
// Copyright (C) 1997 Microsoft Corporation
// All rights reserved.
// Microsoft Confidential

#ifndef __SCRAPER__H__
#define __SCRAPER__H__

//#define IS_CONTROL_CHAR( ucChar ) ( ( ucChar ) < 32 )

#define MAX_SOCKET_BUFFER_SIZE  ( 8 * 1024 )

#define DEFAULT_SEND_BUFFER_SIZE ( 4 * 1024 )
#define SMALL_ARRAY         64
#define LNM                 20
#define VT_ESC              0x1B

#define DEFAULT_TERMCAP     L"termcap"
#define POLL_INTERVAL       1000 //Milli Secs
#define MIN_POLL_INTERVAL   100 //Milli Secs
#define CONVERT_TO_MILLI_SECS( dwNum )  ( dwNum ) = ( dwNum ) * 1000

#define CTRLC               0x03
#define ESC                 '\033'
#define VTNT                "vtnt"
#define VT100               "vt100"
#define VT52                "vt52"
#define VT80                "vt80"
#define ANSI                "ansi"
#define DELTA               100

#define TERMVT52            0x0001
#define TERMVT100           0x0002
#define TERMVT80            0x0004
#define TERMVTNT            0x0008
#define TERMANSI            0x0010

#define VS_O                24
#define VKEY_CTRL_BREAK     0x03
#define VS_MENU             56
#define VS_DELETE           83
#define VS_ESCAPE           1
#define VS_UP               72
#define VS_DOWN             80
#define VS_LEFT             75
#define VS_RIGHT            77
#define VS_OEM_4            26
#define VS_NEXT             81      
#define VS_PRIOR            33 
#define VS_END              79 
#define VS_INSERT           82 
#define VS_HOME             76 
#define VS_PAUSE            69 
#define VS_F1               59
#define VS_F2               60
#define VS_F3               61
#define VS_F4               62
#define VS_F5               63
#define VS_F6               64
#define VS_F7               65
#define VS_F8               66
#define VS_F9               67
#define VS_F10              68
#define VS_F11              87
#define VS_F12              88


#define VT302_NEXT          6
#define VT302_PRIOR         5
#define VT302_END           4
#define VT302_INSERT        2
#define VT302_HOME          1
#define VT302_PAUSE         'P'
#define VT302_F5            15
#define VT302_F6            17
#define VT302_F7            18
#define VT302_F8            19
#define VT302_F9            20
#define VT302_F10           21 
#define VT302_F11           23 
#define VT302_F12           24 

typedef struct {
    UINT   dwInputTimerId;
    HANDLE hTimerExpired;
} TimerContext;

#define COMPARE_AND_UPDATE( wRows, wCols, pCurrent,pLastSeen,CSBI,LastCSBI,fDiff)  \
           (m_dwCurrentCodePage == 932 ||m_dwCurrentCodePage == 949 || m_dwCurrentCodePage == 950 || m_dwCurrentCodePage == 936) ? \
           CompareAndUpdateVT80(wRows,wCols,pCurrent,pLastSeen,CSBI,LastCSBI,fDiff) : \
           CompareAndUpdateVT100(wRows,wCols,pCurrent,pLastSeen,CSBI,LastCSBI,fDiff)

enum { IP_INIT, IP_ESC_RCVD, IP_ESC_BRACKET_RCVD, IP_ESC_O_RCVD, IP_ESC_BRACKET_DIGIT_RCVD };

#define ISSESSION_TIMEOUT_DISABLED( dwIdleSessionTimeOut ) ( dwIdleSessionTimeOut == ~0 )

class CSession;

class CScraper 
{

    CSession *m_pSession;

    PCHAR_INFO   pLastSeen;
    PCHAR_INFO   pCurrent;
    
    CONSOLE_SCREEN_BUFFER_INFO CSBI;
    CONSOLE_SCREEN_BUFFER_INFO LastCSBI;

    DWORD m_dwCurrentCodePage;
    DWORD m_bCheckForScrolling;
    DWORD m_dwInputSequneceState;
    DWORD m_dwDigitInTheSeq;

    bool CompareAndUpdateVT80(  WORD, WORD, PCHAR_INFO, PCHAR_INFO,
                           PCONSOLE_SCREEN_BUFFER_INFO,
                           PCONSOLE_SCREEN_BUFFER_INFO,
						   bool * );

    bool CompareAndUpdateVT100( WORD, WORD, PCHAR_INFO, PCHAR_INFO,
                           PCONSOLE_SCREEN_BUFFER_INFO,
                           PCONSOLE_SCREEN_BUFFER_INFO,
						   bool * );

    bool CompareAndUpdateVTNT( WORD, WORD, PCHAR_INFO, PCHAR_INFO,
                           PCONSOLE_SCREEN_BUFFER_INFO,
                           PCONSOLE_SCREEN_BUFFER_INFO,
						   bool * );

    bool SendVTNTData( WORD, COORD, COORD, SMALL_RECT* , CHAR_INFO* );

    void SendChar( char );
    void SendString( LPSTR );
    void SendFmt( LPSTR , ... );
    bool ProcessEnhancedKeys( unsigned char, char*, bool );
    bool GetRegistryValues( void );
    void SendColorInfo( WORD );
    inline void EchoCharBackToClient( UCHAR );
    void EchoVtntCharToClient( INPUT_RECORD * );

    void LoadStrings( void );
    bool InitializeNonVtntTerms( void );
    bool SetWindowInfo();


    protected:
    DWORD  m_dwPollInterval;
    DWORD  m_dwHowLongIdle;
    DWORD  m_dwTerm; 

    HANDLE m_hConBufIn;
    HANDLE m_hConBufOut;
    
    void        Init( CSession * );
    bool        InitSession( void );
    bool        OnWaitTimeOut();
    bool        EmulateAndWriteToCmdConsoleInput();
    DWORD       WriteAKeyToCMD( WORD, WORD, CHAR, DWORD );
    void        Shutdown();
    void        DeleteCMStrings( void );
    bool        InitTerm( void );
    void        SendBytes( PUCHAR, DWORD );
    bool        TransmitBytes( PUCHAR, DWORD );
    bool        Transmit( );
    bool        IsSessionTimedOut( void );
    bool        SetCmdInfo( void );
    
    public:
    void        WriteMessageToCmd( WCHAR [] );
    CScraper();
    virtual ~CScraper();
};

void DeleteCMStrings();
void LoadStrings();


#endif __SCRAPER__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsess\session.h ===
// Session.h : This file contains the
// Created:  Feb '98
// Author : a-rakeba
// History:
// Copyright (C) 1998 Microsoft Corporation
// All rights reserved.
// Microsoft Confidential 

#if !defined( _SESSION_H_ )
#define _SESSION_H_

#include <cmnhdr.h>

#include <TChar.h>
#include <ntlsapi.h>

#include <IoHandlr.h>
#include <RfcProto.h>
#include <Shell.h>
#include <Scraper.h>

#ifdef WHISTLER_BUILD
#include <ws2tcpip.h>
#else
#include "..\tlntsvr\ws2tcpip.h"
#endif
#include <IpTypes.h>

#define MAX_HANDLES 4

typedef enum { LOGOFF, LOGON } LOGEVENT;
typedef enum { FAIL = 0, SUCCESS } LOGEVENT_RESULT;
typedef enum { ADMIN = 0, NON_ADMIN, DONT_KNOW };

#define DEFAULT_COLS    80
#define DEFAULT_ROWS    25

#define BLANK " "
#define FROM  "from"
#define ADMINISTRATOR   "Administrator "
#define LOGGED          "logged"
#define FAILED_TO_LOG   "failed to log"
#define ON              "on"
#define OFF             "off"
// Logon auditing is not internationalized. So we do not intend to do that now.
#define NTLM_LOGON_FAILED   "An attempt to logon to Telnet Server through NTLM Authentication from the computer %s (%s) failed. To see the details of the user, turn on Logon Auditing and view the details in the Security Log."

class CSession : private CIoHandler, private CRFCProtocol, private CShell,
                 private CScraper
{

    friend class  CShell;
    friend class  CIoHandler;
    friend struct CRFCProtocol;
    friend class  CScraper;

    enum { PIPE_READ = WAIT_OBJECT_0, SOCKET_READ, CMD_KILLED, READ_FROM_CMD };

    struct      sockaddr_storage m_ssPeerAddress;
    CHAR       m_szMachineName[ MAX_PATH + 1 ];
    CHAR       m_szPeerHostName[ MAX_PATH + 1 ];
    CHAR       m_pszUserName[ MAX_PATH + 1 ];
    CHAR       m_pszPassword[ MAX_PATH + 1 ];
    CHAR       m_pszDomain[ MAX_PATH + 1 ];
    
    WCHAR     m_szUser[MAX_PATH+1];
    WCHAR		m_szDomain[MAX_DOMAIN_NAME_LEN+1];
    
    LUID        m_AuthenticationId;
    CHAR        m_pszTermType[ MAX_PATH + 1 ];
    bool        m_bNegotiatedTermType;
    bool        m_bIsTelnetClientsGroupMember;
    WORD        m_wCols; 
    WORD        m_wRows;

    bool        m_bNtVersionGTE5;
    DWORD       m_dwTickCountAtLogon;
    WORD        m_wNumFailedLogins;
    bool        m_bContinueSession;
    DWORD       m_dwHandleCount;
    WORD        m_wIsAnAdmin;
    bool        m_bIsStreamMode;
    bool        m_bIsTelnetVersion2;

                //1. Read pipe event 2. Socket Read event 3. cmd
    HANDLE      m_rghHandlestoWaitOn[ MAX_HANDLES ]; 
    HANDLE      m_hToken;

    DWORD       m_dwAltKeyMapping;
    DWORD       m_dwIdleSessionTimeOut;
    DWORD       m_dwAllowTrustedDomain;
    LPWSTR      m_pszDifferentShell;
    LPWSTR      m_pszDefaultDomain;
    LPWSTR      m_pszDefaultShell;
    LPWSTR      m_pszSwitchToKeepShellRunning;
    LPWSTR      m_pszSwitchForOneTimeUseOfShell;
    LPWSTR      m_pszLoginScript;
    DWORD       m_dwNTLMSetting;
    DWORD       m_dwMaxFailedLogins;
    DWORD       m_dwLogToFile;
    DWORD       m_dwSysAuditing;
    DWORD       m_dwLogEvents;
    DWORD       m_dwLogAdmin;
    DWORD       m_dwLogFailures;
    PSID        administrators;
    PSID        pTelnetClientsSid;
#ifdef LOGGING_ENABLED        
    void        LogIfOpted( BOOL result, LOGEVENT logon, BOOL bNTLMAuth = false );
#endif
    void        CollectPeerInfo();
    bool        GetRegistryValues();
    bool        IsAnAdminstratorOrMember();
    bool        CheckGroupMembership( bool*, bool* );
    void        FreeInitialVariables();
    
    //Just to get rid of warnings
    CSession( const CSession& );
    CSession& operator=( const CSession& );

public:
    CSession();
    virtual     ~CSession();
    
    bool        Init();
    void        WaitForIo();
    void        Shutdown();
    void        AddHandleToWaitOn( HANDLE );

    HANDLE      m_hLogHandle;
    
};

void LogEvent( WORD wType, DWORD dwEventID, LPCTSTR pFormat, ... );
#endif // _SESSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsess\termcap.h ===
// TermCap.h : This file contains the
// Created:  Dec '97
// History:
// Copyright (C) 1997 Microsoft Corporation
// All rights reserved.
// Microsoft Confidential

#ifndef _TERMCAP_H_
#define _TERMCAP_H_

#include "cmnhdr.h"

#include <windows.h>

namespace _Utils { 

class CTermCap {
public:
	virtual ~CTermCap();

	static CTermCap* Instance();
	
	bool LoadEntry( LPSTR lpszTermName );
	//WORD GetNumber( LPCSTR lpszCapabilityName );
	bool CheckFlag( LPCSTR lpszCapabilityName );
	LPSTR GetString( LPCSTR lpszCapabilityName );
	LPSTR CursorMove( LPSTR lpszCursMotionStr, WORD wHorPos, WORD wVertPos );
    void ProcessString( LPSTR* lpszStr );
    
    static PCHAR m_pszFileName;


private:
	static CTermCap* m_pInstance;
	static int m_iRefCount;
	enum { BUFF_SIZE1 = 128, BUFF_SIZE2 = 256, BUFF_SIZE3 = 1024 };
	PCHAR m_lpBuffer;
	HANDLE m_hFile;
    

	bool FindEntry( LPSTR lpszTermName );
	bool LookForTermName( LPSTR lpszTermName );
	LPSTR ParseString( LPSTR lpStr);
	PCHAR SkipToNextField( PCHAR lpBuf );
    	
	CTermCap();
	CTermCap(const CTermCap&);
	CTermCap& operator=( const CTermCap& rhs );
};

}
#endif // _TERMCAP_H_

// Notes:

// This is a Singleton class.

// LoadEntry() must be called before calling any other
// functions (of course, except Instance()).

// User must delete the instance pointer obtained from
// Instance() when done.

// It is recommended that a user of this class understand
// the structure and content of the "termcap" file.

// Note :  At present, this class doesn't support the
//		  concept of padding dummy characters to handle
//		  different speeds of transmission
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsess\shell.cpp ===
// Shell.cpp : This file contains the
// Created:  Feb '98
// Author : a-rakeba
// History:
// Copyright (C) 1998 Microsoft Corporation
// All rights reserved.
// Microsoft Confidential


extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntsam.h>
}

#include <cmnhdr.h>

#include <Windows.h>
#include <LmAccess.h>
#include <LmApiBuf.h>
#include <LmErr.h>
#include <LmWkSta.h>
#include <WinBase.h>
#include <IpTypes.h>
#include <shfolder.h>

#include <Debug.h>
#include <MsgFile.h>
#include <TlntUtils.h>
#include <Shell.h>
#include <LibFuncs.h>
#include <KillApps.h>
#include <Session.h>
#include <Telnetd.h>
#include <wincrypt.h>
#include <sddl.h>

#pragma warning(disable:4706)
#pragma warning(disable: 4127)

using namespace _Utils;
using CDebugLevel::TRACE_DEBUGGING;
using CDebugLevel::TRACE_HANDLE;
using CDebugLevel::TRACE_SOCKET;

extern HANDLE       g_hSyncCloseHandle;
extern HCRYPTPROV      g_hProv;

LPWSTR wideHomeDir = NULL;

BOOL create_desktop_for_this_session(
    HANDLE          client_token,
    LPTSTR          *desktop_name
    )
{
#define NO_OF_SIDS  4

    BOOL                    success = FALSE;
    DWORD                   win32error = NO_ERROR;
    PSID                    administrators_sid = NULL, 
                            client_sid = NULL,
                            local_system_sid = NULL,
                            network_service_sid = NULL,
                            local_service_sid = NULL;
    PACL                    new_acl = NULL;
    SECURITY_DESCRIPTOR     sd = { 0 };
    SECURITY_INFORMATION    sec_i = DACL_SECURITY_INFORMATION;
    BYTE                    client_sid_buffer[256] = { 0 };
    HDESK               desktop = NULL;

    /*
        We are going to set the following entries for the Desktop

        1. System Full Control
        2. Administrators FullControl
        3. client FullControl
        4. Localservice full control
        //5. Network service full control

    */

    {
        SID_IDENTIFIER_AUTHORITY local_system_authority = SECURITY_NT_AUTHORITY;

        if (! AllocateAndInitializeSid(
                                      &local_system_authority,
                                      2, /* there are only two sub-authorities */
                                      SECURITY_BUILTIN_DOMAIN_RID,
                                      DOMAIN_ALIAS_RID_ADMINS,
                                      0,0,0,0,0,0, /* Don't care about the rest */
                                      &administrators_sid
                                      ))
        {
            goto CLEANUP_AND_GET_OUT;
        }

        if (! AllocateAndInitializeSid(
                                      &local_system_authority,
                                      1, /* there is only two sub-authority */
                                      SECURITY_LOCAL_SYSTEM_RID,
                                      0,0,0,0,0,0,0, /* Don't care about the rest */
                                      &local_system_sid
                                      ))
        {
            goto CLEANUP_AND_GET_OUT;
        }
#ifndef SECURITY_LOCAL_SERVICE_RID

#define SECURITY_LOCAL_SERVICE_RID      (0x00000013L)
//#define SECURITY_NETWORK_SERVICE_RID    (0x00000014L)

#endif

        //Build LocalLocal sid
        if ( ! AllocateAndInitializeSid(
                                       &local_system_authority,
                                       1, /* there is only two sub-authority */
                                       SECURITY_LOCAL_SERVICE_RID,
                                       0,0,0,0,0,0,0, /* Don't care about the rest */
                                       &local_service_sid
                                       ) )
        {
            goto CLEANUP_AND_GET_OUT;
        }
/*
        //Build LocalSystem sid
        if ( ! AllocateAndInitializeSid(
                                       &local_system_authority,
                                       1, /* there is only two sub-authority /
                                       SECURITY_NETWORK_SERVICE_RID,
                                       0,0,0,0,0,0,0, /* Don't care about the rest /
                                       &network_service_sid
                                       ) )
        {
            goto CLEANUP_AND_GET_OUT;
        }
*/
        
    }
    {
        DWORD   required = 0;

        if (! GetTokenInformation(
                client_token,
                TokenUser,
                (LPVOID)client_sid_buffer,
                sizeof(client_sid_buffer),
                &required
                ))
        {
            goto CLEANUP_AND_GET_OUT;
        }

        client_sid = ((TOKEN_USER *)client_sid_buffer)->User.Sid;
    }
    {
        DWORD       aclSize;

        // Add Identical settings both for desktop and for windowstation 

        aclSize = sizeof(ACL) + 
                      (NO_OF_SIDS * sizeof(ACCESS_ALLOWED_ACE)) + 
                      GetLengthSid(administrators_sid) +
                      GetLengthSid(client_sid)+ 
                      GetLengthSid(local_system_sid) +
                      GetLengthSid(local_service_sid) -
                      //GetLengthSid(network_service_sid) - 
                      (NO_OF_SIDS * sizeof(DWORD));

        new_acl  = (PACL) new BYTE[aclSize];
        if (NULL == new_acl)
        {
            goto CLEANUP_AND_GET_OUT;
        }

        if (!InitializeAcl(new_acl, aclSize, ACL_REVISION))
        {
            goto CLEANUP_AND_GET_OUT;
        }
    }

    if (!AddAccessAllowedAce(
            new_acl, 
            ACL_REVISION,
            GENERIC_ALL,
            local_system_sid
            ))
    {
        goto CLEANUP_AND_GET_OUT;
    }

    if (!AddAccessAllowedAce(
            new_acl, 
            ACL_REVISION,
            GENERIC_ALL,
            administrators_sid
            ))
    {
        goto CLEANUP_AND_GET_OUT;
    }

    if (!AddAccessAllowedAce(
            new_acl, 
            ACL_REVISION,
            GENERIC_ALL,
            client_sid
            ))
    {
        goto CLEANUP_AND_GET_OUT;
    }
    if(!AddAccessAllowedAce(
            new_acl,
            ACL_REVISION,
            GENERIC_ALL,
            local_service_sid
            ))
    {
        goto CLEANUP_AND_GET_OUT;
    }
/*
    if(!AddAccessAllowedAce(
            new_acl,
            ACL_REVISION,
            GENERIC_ALL,
            network_service_sid
            ))
    {
        goto CLEANUP_AND_GET_OUT;
    }
*/
    if ( !InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION ) )
    {
        goto CLEANUP_AND_GET_OUT;
    }
    if ( !SetSecurityDescriptorDacl(&sd, TRUE, new_acl, FALSE) )
    {
        goto CLEANUP_AND_GET_OUT;
    }
    {
        SECURITY_ATTRIBUTES         sa = { 0 };
        if(!ConvertSidToStringSid(client_sid,&(*desktop_name)))
        {
            *desktop_name = NULL;
            goto CLEANUP_AND_GET_OUT;
        }
        sa.nLength = sizeof(sa);
        sa.lpSecurityDescriptor = &sd;
        desktop = CreateDesktop(
                                *desktop_name, 
                                NULL,
                                NULL, 
                                0,
                                MAXIMUM_ALLOWED,
                                &sa);

        if (NULL == desktop)
        {
            goto CLEANUP_AND_GET_OUT;
        }
        SetThreadDesktop(desktop);
        CloseDesktop(desktop);

        success = TRUE;
    }

    CLEANUP_AND_GET_OUT:

        if (! success)
        {
            win32error = GetLastError();

            _TRACE(TRACE_DEBUGGING,L"Creation and setting of windowstation/desktop failed with %d",win32error);

            LogFormattedGetLastError(EVENTLOG_ERROR_TYPE, TELNET_MSG_ERROR_CREATE_DESKTOP_FAILURE, win32error);
            if(*desktop_name)
            {
                LocalFree(*desktop_name);
                *desktop_name = NULL;
            }
            if(desktop)
            {
                CloseDesktop(desktop);
            }

        }

        if ( administrators_sid != NULL )
        {
            FreeSid (administrators_sid );
        }
        if ( local_system_sid!= NULL )
        {
            FreeSid (local_system_sid);
        }
        if( local_service_sid != NULL )
        {
            FreeSid (local_service_sid);
        }
/*
        if( network_service_sid != NULL )
        {
            FreeSid (network_service_sid );
        }
*/

        if (new_acl)
            delete [] new_acl;

    return( success );

#undef NO_OF_SIDS
}

VOID    CleanupClientToken(
            HANDLE          token
            )
{
   TOKEN_PRIVILEGES     *tp = NULL;
   DWORD                needed_length = 0;

   // DbgUserBreakPoint();

   // Currently, we find that all the privileges enabled in the token obtained via ntlm logon so 
   // Disable everything except SeChangeNotifyPrivilege

   if (GetTokenInformation(
        token,
        TokenPrivileges,
        NULL,
        0,
        &needed_length
        ))
   {
        // No way this can be a success, so just return

       DbgPrint("TLNTSESS: How did GetTokenInformation succeed?\n");

       return;
   }

   tp = (TOKEN_PRIVILEGES *)GlobalAlloc(GPTR, needed_length);

   if (tp) 
   {
       if (GetTokenInformation(
            token,
            TokenPrivileges,
            tp,
            needed_length,
            &needed_length
            ))
       {
           DWORD                x;
           LUID                 change_notify = RtlConvertUlongToLuid(SE_CHANGE_NOTIFY_PRIVILEGE);

           for (x = 0; x < tp->PrivilegeCount; x ++) 
           {
               if ((! RtlEqualLuid(&(tp->Privileges[x].Luid), &change_notify)) && 
                   (tp->Privileges[x].Attributes & SE_PRIVILEGE_ENABLED)
                  ) 
               {
                   tp->Privileges[x].Attributes &= ~(SE_PRIVILEGE_ENABLED_BY_DEFAULT | SE_PRIVILEGE_ENABLED);
               }
           }

           if (! AdjustTokenPrivileges(
                token,
                FALSE,          // Don't disable all
                tp,
                needed_length,
                NULL,           // Don't need the prior state & length
                NULL
                ))
           {
               DbgPrint("TLNTSESS: AdjustTokenPrivileges failed with %u\n", GetLastError());
           }
       }
       else
       {
           DbgPrint("TLNTSESS: GetTokInfo failed with %u\n", GetLastError());
       }

       GlobalFree(tp);
   }
}

CShell::CShell()
{
    m_pSession = NULL;

    m_bIsLocalHost = false;
    
    m_hCurrUserKey = NULL;
    m_lpEnv        = NULL;
    m_hProcess     = NULL;
    m_hTempProcess = NULL;
    hUserEnvLib = NULL;

    pHomeDir = NULL;
    pHomeDrive = NULL;
    pLogonScriptPath = NULL;
    pProfilePath = NULL;
    pServerName = NULL;

    m_pwszAppDataDir = NULL;

    m_pucDataFromCmd = NULL;
    m_dwDataSizeFromCmd =0;

    m_hReadFromCmd = NULL;
    m_hWriteByCmd  = NULL;

}

void
CShell::FreeInitialVariables()
{
    delete[] pHomeDir;
    delete[] pHomeDrive;
    delete[] pLogonScriptPath;
    delete[] pProfilePath;
    delete[] pServerName; 
    delete[] m_pwszAppDataDir;

    pHomeDir         = NULL;
    pHomeDrive       = NULL;
    pLogonScriptPath = NULL;
    pProfilePath     = NULL;
    pServerName      = NULL;
    m_pwszAppDataDir = NULL;
}

CShell::~CShell()
{
    if( m_pSession->m_bNtVersionGTE5 )
    {
        //Free libraries
        FreeLibrary( hUserEnvLib );
    }
    
   FreeInitialVariables(); 
   if( m_pSession->CSession::m_bIsStreamMode ) 
   {
       delete[] m_pucDataFromCmd;
       TELNET_CLOSE_HANDLE( m_oReadFromCmd.hEvent );
       TELNET_CLOSE_HANDLE( m_hReadFromCmd );
       TELNET_CLOSE_HANDLE( m_hWriteByCmd );
   }
}

void
CShell::Init ( CSession *pSession )
{
    _chASSERT( pSession != 0 );
    m_pSession = pSession;
}


bool 
CShell::StartUserSession ( )
{
    LoadLibNGetProc( );
    LoadTheProfile();
    //
    // If Japanese NT then we need to set the console fonts to TrueType
    //
    DWORD dwCodePage = GetACP();
    if(dwCodePage == 932||dwCodePage == 936||dwCodePage == 949||dwCodePage == 950)
    {
        DoFESpecificProcessing();
    }
    
    if( !StartProcess( ) )
    {
        return ( FALSE );
    }

    m_pSession->AddHandleToWaitOn( m_hProcess );

    if( m_pSession->CSession::m_bIsStreamMode )
    {
        m_pSession->CSession::AddHandleToWaitOn( m_oReadFromCmd.hEvent );
        if( !IssueReadFromCmd() )
        {
            return( FALSE );
        }
    }
    
    //Start the scraper
    if( !m_pSession->CScraper::InitSession() )
    {
        return ( FALSE );
    }

    return ( TRUE );
}

bool
CShell::CreateIOHandles()
{
    BOOL dwStatus = 0;

    _chVERIFY2( dwStatus = FreeConsole() );
    if( !dwStatus )
    {
        LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, 0, GetLastError() );
    }

    _chVERIFY2( dwStatus = AllocConsole() );
    if( !dwStatus )
    {
        LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, 0, GetLastError() );
    }
    //Fix for HANDLE LEAK
   	TELNET_CLOSE_HANDLE(m_pSession->CScraper::m_hConBufIn);
   	TELNET_CLOSE_HANDLE(m_pSession->CScraper::m_hConBufOut);
    SECURITY_ATTRIBUTES sa;

    INHERITABLE_NULL_DESCRIPTOR_ATTRIBUTE( sa );
    _chVERIFY2( ( m_pSession->CScraper::m_hConBufIn = 
                CreateFileA( "CONIN$", GENERIC_READ | GENERIC_WRITE , 
                0, &sa, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL ) ) !=
                INVALID_HANDLE_VALUE );

    if( INVALID_HANDLE_VALUE == m_pSession->CScraper::m_hConBufIn)
    {
        LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, MSG_ERRCONSOLE, GetLastError() );
        goto ExitOnError;
    }

     _chVERIFY2( ( m_pSession->CScraper::m_hConBufOut = 
                CreateFileA( "CONOUT$", GENERIC_READ|GENERIC_WRITE, 0, &sa,
                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL ) ) !=
                INVALID_HANDLE_VALUE );

    if( INVALID_HANDLE_VALUE == m_pSession->CScraper::m_hConBufOut )
    {
        LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, MSG_ERRCONSOLE, GetLastError() );
        goto ExitOnError;
    }
    return (TRUE);
ExitOnError :    
	TELNET_CLOSE_HANDLE(m_pSession->CScraper::m_hConBufIn);
	TELNET_CLOSE_HANDLE(m_pSession->CScraper::m_hConBufOut);
    return( FALSE );
}


void
CShell::DoFESpecificProcessing()
{
    UCHAR InfoBuffer[ 1024 ];
    DWORD cbInfoBuffer = 1024;

    BOOL bSuccess = GetTokenInformation( m_pSession->CSession::m_hToken,
        TokenUser, InfoBuffer, cbInfoBuffer, &cbInfoBuffer );
    if(!bSuccess)
    {
        if(GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            //
            // Though we need to alloc buffer and try GetTokenInformation()
            // again, actually it is highly unlikely; so we return false;
            //
            return; 
        }
        else
        {
            _TRACE( TRACE_DEBUGGING, "Error: error getting token info");
            return ;
        }
    }
    CHAR szPathName[MAX_PATH] = { 0 };
    LPSTR lpszKey = NULL;   
    DWORD dwFontSize = 0;
    DWORD dwFaceNameSize = 0 ;
    DWORD dwSize = 0;
    DWORD dwVal = 54;
    LPSTR szTextualSid       = NULL; // allocated textual Sid
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwCounter;
    DWORD dwSidSize;
    DWORD dwCodePage = GetACP();
    LONG lRet=-1;

    /*++
        To support CHS, CHT, KOR alongwith JPN, we need to change the FaceName Value 
        to the True Type font for that particular language. 
        Copying the string directly into the variable doesn't work. 
        It copies high order ASCII characters in the string instead of the DBCS characters.
        So we need to set the UNICODE byte values corresponding to the 
        DBCS characters for the TT Font Names.
        These TT fonts are the ones which are present in Cmd.exe-Properties-Font. 
        For US locale, the TT font is Lucida Console. 
        But we don't need to set it on US locale. Raster Font works fine there. 
        For FE languages, the TT fonts need to be set.
    --*/
    const TCHAR szJAPFaceName[] = { 0xFF2D ,0xFF33 ,L' ' ,0x30B4 ,0x30B7 ,0x30C3 ,0x30AF ,L'\0' };
    const TCHAR szCHTFaceName[] = { 0x7D30 ,0x660E ,0x9AD4 ,L'\0'};
    const TCHAR szKORFaceName[] = { 0xAD74 ,0xB9BC ,0xCCB4 ,L'\0'};
    const TCHAR szCHSFaceName[] = { 0x65B0 ,0x5B8B ,0x4F53 ,L'\0' };
    TCHAR szFaceNameDef[MAX_STRING_LENGTH];

        switch (dwCodePage)
        {
            case JAP_CODEPAGE:
            	_tcscpy(szFaceNameDef, szJAPFaceName); //On JAP, set the FaceName to "MS Gothic"
                dwFontSize = JAP_FONTSIZE;
                break;
            case CHT_CODEPAGE:
            	_tcscpy(szFaceNameDef, szCHTFaceName); //On CHT, set the FaceName to "MingLiU"
                dwFontSize = CHT_FONTSIZE;
                break;
            case KOR_CODEPAGE:
            	_tcscpy(szFaceNameDef, szKORFaceName);//On KOR, set the FaceName to "GulimChe"
                dwFontSize = KOR_FONTSIZE;
                break;
            case CHS_CODEPAGE:
            	_tcscpy(szFaceNameDef, szCHSFaceName);//On CHS, set the FaceName to "NSimSun"
                dwFontSize = CHS_FONTSIZE;
                break;
            default:
                _tcscpy(szFaceNameDef,L"\0");
                break;
        }

        dwFaceNameSize = ( _tcslen( szFaceNameDef ) + 1 ) * sizeof( TCHAR );


        //
        // Convert the SID to textual form, which is used to load
        // the registry hive associated with that user
        //

        //
        // Test if Sid is valid
        //
        if( !IsValidSid( ( ( PTOKEN_USER ) InfoBuffer )->User.Sid ) )
        {
            _TRACE( TRACE_DEBUGGING, "Error: IsValidSid()");
            return;
        }

        //
        // Get SidIdentifierAuthority
        //
        psia = GetSidIdentifierAuthority( ( ( PTOKEN_USER )InfoBuffer )->User.Sid );

        //
        // Get sidsubauthority count
        //
        dwSubAuthorities = *GetSidSubAuthorityCount( ( ( PTOKEN_USER ) InfoBuffer )->User.Sid );

        //
        // Compute buffer length
        // S- + SID_REVISION- + identifierauthority- + subauthorities- + NULL
        //
        dwSidSize = ( 20 + 12 + ( 12 * dwSubAuthorities ) + 1 ) * sizeof( CHAR );

        szTextualSid=( LPSTR ) new CHAR[dwSidSize];
        
        if( szTextualSid == NULL ) 
        {
            return;
        }

        //
        // Prepare S-SID_REVISION-
        //
        dwSidSize = sprintf( szTextualSid, "s-%lu-", SID_REVISION ); // NO Overflow, Baskar

        //
        // Prepare SidIdentifierAuthority
        //
        if( ( psia->Value[0] != 0 ) || ( psia->Value[1] != 0 ) ) 
        {
            dwSidSize += sprintf( szTextualSid + dwSidSize,
                                 "0x%02lx%02lx%02lx%02lx%02lx%02lx",
                                 ( USHORT )psia->Value[0],
                                 ( USHORT )psia->Value[1],
                                 ( USHORT )psia->Value[2],
                                 ( USHORT )psia->Value[3],
                                 ( USHORT )psia->Value[4],
                                 ( USHORT )psia->Value[5] );  // NO Overflow, Baskar
        } 
        else 
        {
            dwSidSize += sprintf( szTextualSid + dwSidSize,
                                 "%lu",
                                 ( ULONG )( psia->Value[5]       )   +
                                 ( ULONG )( psia->Value[4] <<  8 )   +
                                 ( ULONG )( psia->Value[3] << 16 )   +
                                 ( ULONG )( psia->Value[2] << 24 )   );  // NO Overflow, Baskar
        }

        //
        // Copy each SidSubAuthority
        //
        for( dwCounter = 0 ; dwCounter < dwSubAuthorities ; dwCounter++ ) 
        {
            dwSidSize += sprintf( szTextualSid + dwSidSize, "-%lu",
                                 *GetSidSubAuthority( ( ( PTOKEN_USER )InfoBuffer )->User.Sid, dwCounter ) ); // NO Overflow, Baskar
        }

        //
        // Check to see if a hive for the specified user is already loaded
        //
        HKEY hK3 = NULL;

        lRet = RegOpenKeyExA(
                            HKEY_USERS,
                            szTextualSid,
                            0,
                            KEY_QUERY_VALUE,
                            &hK3
                            );

        //
        // ERROR_ACCESS_DENIED probably means the user hive is already loaded
        //    
        if( ( lRet != ERROR_SUCCESS ) && ( lRet != ERROR_ACCESS_DENIED ) ) 
        {
            if( hK3 != NULL )
            {
                RegCloseKey( hK3 );
            }
        
            //
            // User hive is not loaded. Attempt to locate and load hive
            //
            LPCSTR szProfileList = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\";
            LPSTR szSubKey     = NULL;
            HKEY hKey = NULL;
            CHAR szPath[MAX_PATH];
            DWORD cbPath = MAX_PATH;
            CHAR szExpandedPath[MAX_PATH];

            lRet = ERROR_SUCCESS;
            //
            // Allocate storage for ProfileList + TextualSid + NULL
            //
            szSubKey = (LPSTR) new CHAR[( strlen( szProfileList ) + strlen( szTextualSid ) + 1)];

            if( szSubKey == NULL ) 
            {
                delete [] szTextualSid;
                return;
            }

            //
            // Prepare SubKey path by concatinating the fixed+variable paths
            //
            strcpy( szSubKey, szProfileList ); // Already correct size allocated based on strlen, no overflow/Attack.
            strcat( szSubKey, szTextualSid );

            lRet = RegOpenKeyExA(
                                HKEY_LOCAL_MACHINE,
                                szSubKey,
                                0,
                                KEY_QUERY_VALUE,
                                &hKey
                                );

            if( lRet != ERROR_SUCCESS )
            {
                delete [] szTextualSid;
                delete [] szSubKey;
                return;
            }

            //
            // Get ProfileImagePath
            //
            lRet = RegQueryValueExA(
                                    hKey,
                                    "ProfileImagePath",
                                    NULL,
                                    NULL,
                                    ( LPBYTE )szPath,
                                    &cbPath
                                    );

            if( lRet != ERROR_SUCCESS )
            {
                delete [] szTextualSid;
                delete [] szSubKey;
                return;
            }

            //
            // Expand ProfileImagePath
            //
            if( ExpandEnvironmentStringsA( szPath, szExpandedPath, MAX_PATH ) == 0 )
            {
                delete [] szTextualSid;
                delete [] szSubKey;
                RegCloseKey( hKey );
                return;
            }


            //
            // Enable SeRestorePrivilege for RegLoadKey
            //
        #if 0
            SetCurrentPrivilege( SE_RESTORE_NAME, TRUE );
        #endif

            //
            // Load the users registry hive
            //
            lRet = RegLoadKeyA( HKEY_USERS, szTextualSid, szExpandedPath );

            if( lRet != ERROR_SUCCESS )
            {
                delete [] szTextualSid;
                delete [] szSubKey;
                RegCloseKey( hKey );
                return;
            }

            //
            // Disable SeRestorePrivilege
            //
        #if 0
            SetCurrentPrivilege( SE_RESTORE_NAME, FALSE );
        #endif

            //
            // Free resources
            //
            if( hKey != NULL ) 
            {
                RegCloseKey( hKey );
            }

            if( szSubKey != NULL ) 
            {
                delete [] szSubKey;
            }
        }
        else
        {
            if( hK3 != NULL )
            {
                RegCloseKey( hK3 );
            }
        }

        //
        // Get path name to tlntsvr.exe
        //
        if( !GetModuleFileNameA( NULL, szPathName, MAX_PATH-1 ) )
        {
            delete [] szTextualSid;
            return;
        }

        //
        // Nuke the trailing "tlntsvr.exe"
        //
        LPSTR pSlash = strrchr( szPathName, '\\' );

        if( pSlash == NULL )
        {
            delete [] szTextualSid;
            return;
        }
        else
        {
            *pSlash = '\0';
        }

        LPSTR szTlntsess = "tlntsess.exe";
        int ch = '\\';
        LPSTR pBackSlash;

        //
        // Replace all '\\' with '_' This format is required for the console to
        // interpret the key.
        //
        while ( 1 )
        {
            pBackSlash = strchr( szPathName, ch );

            if( pBackSlash == NULL )
            {
                break;
            }
            else
            {
                *pBackSlash = '_';
            }
        }

        //
        // Append "tlntsess.exe" to the path
        //
        strcat( szPathName, "_" );
        strcat( szPathName, szTlntsess );

        HKEY hk2;

        //
        // The key we need to create is of the form:
        // HKEY_USERS\S-1-5-21-2127521184-1604012920-1887927527-65937\Console\C:_SFU_Telnet_tlntsess.exe
        //
        unsigned int nBytes = ( strlen( szTextualSid ) + strlen( "Console" ) + strlen( szPathName ) + 3 ) * sizeof( CHAR );

        lpszKey = (LPSTR) new CHAR[nBytes];
        if( !lpszKey )
        {
            delete[] szTextualSid;
            return;
        }

        SfuZeroMemory(lpszKey, nBytes);

        strcpy( lpszKey, szTextualSid );
        strcat( lpszKey, "\\" );
        strcat( lpszKey, "Console" );
        strcat( lpszKey, "\\" );
        strcat( lpszKey, szPathName );

        //
        //
        // Freeup TextualSid
        delete [] szTextualSid;

        //Need to set this in order to be able to display on Non-Jap FE machines

        HKEY hk;

        lRet = RegOpenKeyEx(
                            HKEY_USERS,
                            _T(".DEFAULT\\Console"),
                            0,
                            KEY_SET_VALUE,
                            &hk
                            );


        if( lRet != ERROR_ACCESS_DENIED || lRet == ERROR_SUCCESS ) 
        {
            
            //
            // Add STRING value "FaceName " under the key HKEY_USERS\.Default\Console
            //
            if( (lRet=RegSetValueEx( hk, _T("FaceName"), 0, REG_SZ, (LPBYTE) szFaceNameDef, dwFaceNameSize )) != ERROR_SUCCESS )
            {
                RegCloseKey( hk );
                return;
            }
            RegCloseKey( hk );
        }


        //
        // Attempt to create this key
        //
        if( !RegCreateKeyA( HKEY_USERS, lpszKey, &hk2 ) )
        {
            dwSize = sizeof( DWORD );
            
            //
            // Add DWORD value "FontFamily = 54" under the key
            //
            if( RegSetValueEx( hk2, _T("FontFamily"), 0, REG_DWORD, (LPBYTE) &dwVal, dwSize ) != ERROR_SUCCESS )
            {
                RegCloseKey( hk2 );
                delete [] lpszKey;
                return;
            }

            
            //
            // Add DWORD value "CodePage " under the key
            //
            if( RegSetValueEx( hk2, _T("CodePage"), 0, REG_DWORD, (LPBYTE) &dwCodePage, dwSize ) != ERROR_SUCCESS )
            {
                RegCloseKey( hk2 );
                delete [] lpszKey;
                return;
            }

            //
            // Add DWORD value "Font Size " under the key
            //
            if( RegSetValueEx( hk2, _T("FontSize"), 0, REG_DWORD, (LPBYTE) &dwFontSize, dwSize ) != ERROR_SUCCESS )
            {
                RegCloseKey( hk2 );
                delete [] lpszKey;
                return;
            }

            dwVal = 400;

            //
            // Add DWORD value "FontWeight = 400" under the key
            //
            if( RegSetValueEx( hk2, _T("FontWeight"), 0, REG_DWORD, (LPBYTE) &dwVal, dwSize ) != ERROR_SUCCESS )
            {
                RegCloseKey( hk2 );
                delete [] lpszKey;
                return;
            }

            dwVal = 0;

            //
            // Add DWORD value "HistoryNoDup = 0" under the key
            //
            if( RegSetValueEx( hk2, _T("HistoryNoDup"), 0, REG_DWORD, (LPBYTE) &dwVal, dwSize ) != ERROR_SUCCESS )
            {
                RegCloseKey( hk2 );
                delete [] lpszKey;
                return;
            }

            //
            // Add STRING value "FaceName" under the key
            //
            if( RegSetValueEx( hk2, _T("FaceName"), 0, REG_SZ, (LPBYTE) szFaceNameDef, dwFaceNameSize ) != ERROR_SUCCESS )
            {
                RegCloseKey( hk2 );
                delete [] lpszKey;
                return;
            }

            RegCloseKey( hk2 );
        }

        if(lpszKey != NULL)
        {
            delete [] lpszKey;
        }
        return;
}

#ifdef ENABLE_LOGON_SCRIPT
void
CShell::GetUserScriptName( LPWSTR *szArgBuf, LPWSTR szUserScriptPath )
{
    _chASSERT( szUserScriptPath != NULL );
    _chASSERT( szArgBuf != NULL );
    _chASSERT( pServerName != NULL );

    DWORD  dwSize  = 0; 
    LPWSTR expandedScript = NULL;
    LPWSTR shellName = NULL;
    LPWSTR szTmp = NULL;

    wcscpy( szUserScriptPath, L"" );
    if( !AllocateNExpandEnvStrings( pLogonScriptPath, &expandedScript ) )
    {
        return;
    }

    dwSize =  wcslen( pServerName ) + wcslen( DC_LOGON_SCRIPT_PATH) +
             wcslen( LOCALHOST_LOGON_SCRIPT_PATH ) + wcslen( expandedScript ) +
             + 1;

    *szArgBuf = new WCHAR[ dwSize ];
    if( !*szArgBuf )
    {
        return;
    }
	
    SfuZeroMemory( *szArgBuf, dwSize );

    if( m_bIsLocalHost && !IsThisMachineDC() )
    {
        LPWSTR szSysDir = NULL;
        if( GetTheSystemDirectory( &szSysDir ) )
        {
            //logon script path
            wsprintf( szUserScriptPath, L"%s%s", szSysDir, LOCALHOST_LOGON_SCRIPT_PATH ); // NO size info, Baskar. Attack ?

            wsprintf( *szArgBuf, L"%s%s%s",
                                 szSysDir, LOCALHOST_LOGON_SCRIPT_PATH, expandedScript );  // NO size info, Baskar. Attack ?
        }
        delete[] szSysDir;
    }
    else
    {
        //When NTLM authenticated, we are unable to access the logon script on the net share.
        //This gives "access denied error" in the session. To avoid this, don't exec logon script....
        if( !m_pSession->CIoHandler::m_bNTLMAuthenticated )
        {
            //logon script path
            wsprintf( szUserScriptPath, L"%s%s", pServerName, DC_LOGON_SCRIPT_PATH ); // NO size info, Baskar. Attack ?

            wsprintf( *szArgBuf, L"%s%s%s",
                               pServerName, DC_LOGON_SCRIPT_PATH, expandedScript ); // NO size info, Baskar. Attack ?
        }
    }

    wcscat( szUserScriptPath, expandedScript );
    szTmp = wcsrchr( szUserScriptPath, L'\\' );
    if( szTmp )
    {
        *szTmp = L'\0';
    }
    else
    {
	szUserScriptPath[0] = 0;
    }

    delete[] expandedScript;
    delete[] shellName;
}
#endif

void
CShell::GetScriptName( LPWSTR *szShell, LPWSTR *szArgBuf )
{
    _chASSERT( szArgBuf );
    _chASSERT( szShell  );
 
    TCHAR  szUserScriptPath[ MAX_PATH + 1 ];
    LPWSTR szUserScriptCmd = NULL;
    DWORD  dwSize = 0;
    LPWSTR script1 = NULL;

    *szShell  = NULL;
    *szArgBuf = NULL;

    if( !AllocateNExpandEnvStrings( m_pSession->m_pszDefaultShell, szShell ) )
    {
        goto GetScriptNameAbort;
    }
    _TRACE(TRACE_DEBUGGING,L"szShell = %s",*szShell);

    if( !AllocateNExpandEnvStrings( m_pSession->m_pszLoginScript, &script1 ) )
    {
        goto GetScriptNameAbort;
    }
    _TRACE(TRACE_DEBUGGING,L"script1l = %s",script1);
    
#ifdef ENABLE_LOGON_SCRIPT
    if( pLogonScriptPath && ( wcscmp( pLogonScriptPath, L"" ) != 0 ) )
    {
        //User specific logon script is present. Execute this in a separate cmd.
        //Get the shell, its commandline and also path for user script
        GetUserScriptName( &szUserScriptCmd, szUserScriptPath  );  
        if( !szUserScriptCmd )
        {
            goto GetScriptNameAbort;
        }
        _TRACE(TRACE_DEBUGGING,L"szUserScriptCmd = %s",szUserScriptCmd);

        //This would update m_lpEnv if it is not null or the environment of current 
        //process for inheritance
        if(FALSE == InjectUserScriptPathIntoPath( szUserScriptPath ))
        {
        	goto GetScriptNameAbort;
        }

        dwSize +=  wcslen( AND )              +
                   wcslen( szUserScriptCmd );
    }
#endif

    if( m_pSession->CSession::m_pszDifferentShell && m_pSession->CSession::m_pszDifferentShell[0] != L'\0' )
    {
        dwSize += wcslen( AND )              +
                  wcslen( m_pSession->CSession::m_pszDifferentShell ) + 
                  wcslen( AND ) +
                  wcslen( EXIT_CMD );
    }

    /* the arg is of the form :/q /k c:\sfu\telnet\userlogin.cmd *///&&c:\sfu\telnet\telnetlogin.cmd
    dwSize +=      wcslen(m_pSession->CSession::m_pszSwitchToKeepShellRunning) +
                   wcslen(L" ") +
                   wcslen( script1 )            +
                   1;
    *szArgBuf = new WCHAR[ dwSize ];
    if( !*szArgBuf )
    {
        goto GetScriptNameAbort;
    }
    wsprintf(*szArgBuf,L"%s%s",m_pSession->CSession::m_pszSwitchToKeepShellRunning,L" "); // NO size info, Baskar. Attack ?
    
#ifdef ENABLE_LOGON_SCRIPT
    if( pLogonScriptPath && ( wcscmp( pLogonScriptPath, L"" ) != 0 ) )
    {
        wcscat( *szArgBuf, szUserScriptCmd );
        wcscat( *szArgBuf, AND );
    }
#endif

    _TRACE(TRACE_DEBUGGING,L"szArgBuf became = %s",*szArgBuf);

    wcscat( *szArgBuf, script1 );

    if( m_pSession->CSession::m_pszDifferentShell && m_pSession->CSession::m_pszDifferentShell[0] != L'\0' )
    {
        wcscat( *szArgBuf, AND );
        wcscat( *szArgBuf, m_pSession->CSession::m_pszDifferentShell );
        wcscat( *szArgBuf, AND );
        wcscat( *szArgBuf, EXIT_CMD );
    }

GetScriptNameAbort:
    
#ifdef ENABLE_LOGON_SCRIPT
	if(szUserScriptCmd)
	{
		delete[] szUserScriptCmd;
	}
#endif

	if(script1)
	{
		delete[] script1;
	}
    _TRACE( TRACE_DEBUGGING, L"Argument for Shell: %s", *szArgBuf );
    _TRACE( TRACE_DEBUGGING, L"Command Shell: %s", *szShell );
}

/*Mem allocated by the function; to be released by the caller */
bool
CShell::GetTheSystemDirectory( LPWSTR *szDir )
{
    WORD  wSize = MAX_PATH;
    DWORD dwErr = 0;
    DWORD dwStatus = 0;

retry:
    *szDir = new WCHAR[ wSize ];
    if( !*szDir )
    {
        return( FALSE );
    }

    dwStatus = GetSystemDirectory( *szDir, wSize );

    if( !dwStatus )
    {
       delete[] ( *szDir );
       dwErr = GetLastError(); 
       if( dwErr != ERROR_INSUFFICIENT_BUFFER )
       {
           LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, 0, dwErr );
           return( FALSE );
       }
       wSize += MAX_PATH;
       goto retry;
    }

    return ( TRUE );
}

bool
CShell::GetSystemDrive()
{
    if( GetTheSystemDirectory( &wideHomeDir ) )
    {
        DWORD i=0;
        while( wideHomeDir[ i ] != L'\0' && wideHomeDir[ i++ ] != L':' )
        {
                //Do nothing
        }
    
        wideHomeDir[ i++ ] = L'\\';
        wideHomeDir[ i ] = L'\0';
        return( TRUE );
    }

    return( FALSE );
}

bool
CShell::OnDataFromCmdPipe()
{
    // Sendit over socket.       

    DWORD dwNumBytesRead = 0;
    FinishIncompleteIo( m_hReadFromCmd, &m_oReadFromCmd, &dwNumBytesRead );

    if( m_pSession->CScraper::m_dwTerm & TERMVTNT )
    {
        PUCHAR pVtntChars = NULL;
        DWORD dwSize     = 0;
        m_pSession->CRFCProtocol::StrToVTNTResponse( ( CHAR * )m_pucDataFromCmd, dwNumBytesRead, 
                                                     ( VOID ** )&pVtntChars, &dwSize );
        m_pSession->CScraper::SendBytes( pVtntChars, dwSize );
        delete[] pVtntChars;
    }
    else
    {
        m_pSession->CScraper::SendBytes( m_pucDataFromCmd, dwNumBytesRead );
    }

    if( !IssueReadFromCmd() )
    {
        return( FALSE );
    }

    return( TRUE );
}

bool
CShell::IssueReadFromCmd()
{
    DWORD dwRequestedIoSize = MAX_WRITE_SOCKET_BUFFER;
    if( !ReadFile( m_hReadFromCmd, m_pucDataFromCmd, 
        dwRequestedIoSize, &m_dwDataSizeFromCmd, &m_oReadFromCmd  ) )
    {
        DWORD dwError = GetLastError( );
        if( ( dwError == ERROR_MORE_DATA ) || ( dwError != ERROR_IO_PENDING ) )
        {
            LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, MSG_ERR_READCMD, dwError );
            _TRACE( TRACE_DEBUGGING, " Error: ReadFile -- 0x%1x ", dwError );
            return ( FALSE );
        }
    }
    
    return( TRUE );
}

bool 
CShell::StartProcess ( )
{
    DWORD dwStatus;
    LPWSTR szArgBuf = NULL;
    LPWSTR szShell  = NULL;
    PROCESS_INFORMATION pi, temp_pi;
    STARTUPINFO si, temp_si;
    bool bTryOnceAgain = true;
    bool bRetVal = TRUE;
    bool impersonating_client = FALSE;
    HANDLE hStdError = NULL;
    HANDLE hHandleToDuplicate = NULL;
    DWORD dwExitCode = 0;
    PSECURITY_DESCRIPTOR psd = NULL;
    LPTSTR desktop_name = NULL;
    LPTSTR winsta_name = NULL;
    LPTSTR winsta_desktop = NULL;
    HWINSTA winsta_service = NULL;
    DWORD required = 0;
    
    /*++                                    
    MSRC issue 567.
    To generate random numbers, use Crypt...() functions. Acquire a crypt context at the beginning of 
    ListenerThread and release the context at the end of the thread. If acquiring the context fails,
    the service fails to start since we do not want to continue with weak pipe names.
    initialize the random number generator
    --*/
    if (!CryptAcquireContext(&g_hProv,NULL,NULL,PROV_RSA_FULL,CRYPT_VERIFYCONTEXT))
    {
        _TRACE(TRACE_DEBUGGING,L"Acquiring crypt context failed with error %d",GetLastError());
        return FALSE;
    }

    if( !CreateIOHandles() )
    {
        return( FALSE );
    }

    if( m_pSession->CSession::m_bIsStreamMode )
    {
        TELNET_CLOSE_HANDLE( m_pSession->CScraper::m_hConBufOut );

        InitializeOverlappedStruct( &m_oReadFromCmd );
        m_pucDataFromCmd = new UCHAR[ MAX_WRITE_SOCKET_BUFFER ];
        if( !m_pucDataFromCmd )
        {
            return( FALSE );
        }
        m_hReadFromCmd = NULL;
        m_hWriteByCmd = NULL;
        if(!TnCreateDefaultSecDesc(&psd, GENERIC_ALL& 
                                        ~(WRITE_DAC | WRITE_OWNER | DELETE)))
        {
            return(FALSE);
        }
        if( !CreateReadOrWritePipe( &m_hReadFromCmd, &m_hWriteByCmd, (SECURITY_DESCRIPTOR *)psd, READ_PIPE ) )
        {
            if(psd)
            {
                free(psd);
            }
            return( FALSE );
        }

        //The following is for aesthetics
        if( !m_pSession->CIoHandler::m_bNTLMAuthenticated )
        { 
            DWORD dwNumWritten = 0;
            UCHAR pBuf[] = { '\r', '\n', '\r', '\n' };
            _chVERIFY2( WriteFile( m_hWriteByCmd, pBuf, sizeof( pBuf ), &dwNumWritten, NULL ) );
        }

        hHandleToDuplicate = m_hWriteByCmd;        
    }
    else
    {
        hHandleToDuplicate = m_pSession->CScraper::m_hConBufOut;
    }
    
    if( !DuplicateHandle( GetCurrentProcess(), hHandleToDuplicate,
                   GetCurrentProcess(), &hStdError,0,
                   TRUE, DUPLICATE_SAME_ACCESS) )
    {
        hStdError = m_pSession->CScraper::m_hConBufOut;
    }
    if (! 
	create_desktop_for_this_session(m_pSession->CSession::m_hToken, &desktop_name))
    {
       bRetVal = FALSE;
        goto ExitOnError;
    }
    winsta_service = GetProcessWindowStation();
    if(winsta_service == NULL)
    {
        bRetVal = FALSE;
        goto ExitOnError;
    }
    //bound to fail the first time. Get the size required by the winsta_name
    GetUserObjectInformation( winsta_service,
                                UOI_NAME,
                                winsta_name,
                                0,
                                &required);
    winsta_name = (LPTSTR) malloc (required);
    if(winsta_name == NULL)
    {
        bRetVal = FALSE;
        goto ExitOnError;
    }
    if(!GetUserObjectInformation( winsta_service,
                                UOI_NAME,
                                winsta_name,
                                required,
                                &required))
    {
        bRetVal = FALSE;
        goto ExitOnError;
    }
    required = _tcslen(winsta_name)+_tcslen(desktop_name)+2; //+2 - 1 for '\\' and 1 for NULL
    winsta_desktop = (LPTSTR) malloc(required*sizeof(TCHAR));
    if(winsta_desktop == NULL)
    {
        bRetVal = FALSE;
        goto ExitOnError;
    }

    _sntprintf(winsta_desktop,required,TEXT("%s\\%s"),winsta_name,desktop_name);
    FillProcessStartupInfo( &si, m_pSession->CScraper::m_hConBufIn, 
            hHandleToDuplicate, hStdError, winsta_desktop );
    SfuZeroMemory((void *)&temp_si, sizeof(temp_si));
    temp_si.cb          = sizeof( STARTUPINFO );
    temp_si.lpDesktop   = winsta_desktop;
    temp_si.wShowWindow = SW_HIDE;

    AllocNCpyWStr( &wideHomeDir, pHomeDir ); 
    if( !wideHomeDir || wcscmp( wideHomeDir, L"" ) == 0  )
    {
        if ( wideHomeDir )
            delete[] wideHomeDir;
        GetSystemDrive( );
    }
    else
    {
        //Is it a network drive??
        if( memcmp(L"\\\\", wideHomeDir, 4 ) == 0 ) 
        {
            GetUsersHomeDirectory( wideHomeDir );
        }
    }

    m_lpEnv = NULL;
    if( m_pSession-> m_bNtVersionGTE5 && fnP_CreateEnvironmentBlock )
    {
        if(!ImpersonateLoggedOnUser(m_pSession->CSession::m_hToken))
        {
            bRetVal = FALSE;
            goto ExitOnError;
        }
        if( !fnP_CreateEnvironmentBlock( &( m_lpEnv ), 
            m_pSession->CSession::m_hToken, FALSE ) )  
        {

             _TRACE( TRACE_DEBUGGING, "Error: CreateEnvironmentBlock()"
                " - 0x%lx", GetLastError());
             m_lpEnv = NULL;
        }
        if(!RevertToSelf())
        {
            bRetVal = FALSE;
            goto ExitOnError;
        }
    }


    //This function will insert some new variables in to the env
    GetEnvVarData();
    if( m_lpEnv )
    {
        ExportEnvVariables();
    }
    else
    {
        // Let the cmd inherit
        SetEnvVariables();
    }
    GetScriptName( &szShell, &szArgBuf );
    CleanupClientToken(m_pSession->CSession::m_hToken); // We don't care whether it succeeded or not
    SetConsoleCtrlHandler( NULL, FALSE );
    //call CreateProcessWithTokenW() CREATE_SUSPENDED on a dummy process.  This will effectively load the profile for you.  
    //Save this process handle away
    //service will use CreateProcessAsUser(), as it has in the past.
    //call TerminateProcess() on the dummy process when the real process launched by 
    //CreateProcessAsUser() dies. This had to be done since
    //CreateProcessWithTokenW() did not work as expected. There were some problems
    //in associating the input output redirection handles with cmd.exe

    if(!CreateProcessWithTokenW(m_pSession->CSession::m_hToken,
                            LOGON_WITH_PROFILE,
                            szShell,
                            szArgBuf,
                            CREATE_UNICODE_ENVIRONMENT |  CREATE_SUSPENDED,
                            m_lpEnv,
                            NULL,
                            &temp_si,
                            &temp_pi)
      )
    {
        DWORD dwLastError;
        dwLastError = GetLastError(); 
        LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, MSG_ERRCMD, dwLastError );
        _TRACE( TRACE_DEBUGGING, "Error: CreateProcessWithToken() - 0x%lx", 
            dwLastError );
        _chASSERT( 0 );
        bRetVal = FALSE;
        SetConsoleCtrlHandler( NULL, TRUE );
        goto ExitOnError;
    }
    else
    {
        m_hTempProcess = temp_pi.hProcess;
        TELNET_CLOSE_HANDLE( temp_pi.hThread );
    }
    //You need to impersonate around CreateProcessAsUserA. Otherwise, 
    //if lpCurrentDir parameter is a network resource, the call will fail in the 
    //context of system account. Could not access the remote drive when the process 
    //is called with CreateProcessA alone. Don't know why??
    if( !ImpersonateLoggedOnUser(m_pSession->CSession::m_hToken))
    {
        bRetVal = false;
        goto ExitOnError;
    }
    impersonating_client = true;
try_again:
    if( !CreateProcessAsUser( m_pSession->CSession::m_hToken, szShell,
            szArgBuf, 
            NULL, NULL, TRUE, 
            CREATE_UNICODE_ENVIRONMENT | CREATE_SEPARATE_WOW_VDM, 
            m_lpEnv, NULL, &si, &pi ) )
    {
        DWORD dwLastError;
        dwLastError = GetLastError(); 
        if( dwLastError == ERROR_DIRECTORY && bTryOnceAgain )
        {
            bTryOnceAgain = false;
            delete[] wideHomeDir;
            GetSystemDrive( );
            goto try_again;
        }
        LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, MSG_ERRCMD, dwLastError );
        _TRACE( TRACE_DEBUGGING, "Error: CreateProcessAsUserA() - 0x%lx", 
            dwLastError );
        _chASSERT( 0 );
        bRetVal = FALSE;
        SetConsoleCtrlHandler( NULL, TRUE );
        goto ExitOnError;
    }

    _chVERIFY2( GetExitCodeProcess( pi.hProcess, &dwExitCode ) );
    if( dwExitCode != STILL_ACTIVE )
    {
        bRetVal = FALSE;
        goto ExitOnError;
    }

    m_hProcess = pi.hProcess;
    TELNET_CLOSE_HANDLE( pi.hThread );
    SetConsoleCtrlHandler( NULL, TRUE );

ExitOnError:

    TELNET_CLOSE_HANDLE( hStdError );
    TELNET_CLOSE_HANDLE( m_pSession->CScraper::m_hConBufOut );
    if(winsta_service)
    {
        CloseWindowStation(winsta_service);
    }
    if(impersonating_client && (! RevertToSelf()))
    {
        LogFormattedGetLastError(EVENTLOG_ERROR_TYPE, TELNET_MSG_REVERTSELFFAIL, GetLastError());
        bRetVal = false;
    }

    if(psd)
    {
        free(psd);
    }

    if(desktop_name)
    {
        LocalFree(desktop_name);
    }
    if(winsta_name)
    {
        free(winsta_name);
    }
    if(winsta_desktop)
    {
        free(winsta_desktop);
    }
        
    delete[] wideHomeDir;
    delete[] szShell;
    delete[] szArgBuf;
    return ( bRetVal );
}


//Set "homedir" to the home directory of the user. Make a net connection if the //home directory is remote.
//System account can't access the network resources. You need to impersonate.

bool CShell::GetUsersHomeDirectory( LPWSTR homedir )
{
    LPWSTR wsPathName = NULL;
    LPWSTR wsNetName = NULL;
    NETRESOURCE NetResource;
    LPWSTR p;
    int i, count, NthBackSlash;
    bool result = true;
    DWORD dwAddError = ERROR_SUCCESS;
    LPWSTR szSaveHomeDir = NULL;
    _TRACE( TRACE_DEBUGGING, "GetUsersHomeDirectory()");
    _chASSERT( homedir != NULL );

    // it is a network share
    // mount it and return drive:path

    if( !ImpersonateLoggedOnUser(m_pSession->CSession::m_hToken) )
    {
        wcscpy( homedir, L"C:\\" );
        _TRACE( TRACE_DEBUGGING, "Error: ImpersonateLoggedonUser() --" 
            "0x%1x \n", GetLastError() );
        return false;
    }

    if( !AllocNCpyWStr( &( wsPathName ), homedir) )
    {
        goto ExitOnError;
    }
    if( !AllocNCpyWStr( &( wsNetName ), homedir) )
    {
        goto ExitOnError;
    }
    if( !AllocNCpyWStr( &( szSaveHomeDir ), homedir) )
    {
        goto ExitOnError;
    }

    // find the fourth backslash - everything from there on is pathname
    // This approach is sufficient for SMB. But, In NFS, \ is a valid char
    // inside a share name. So, by trial and error, connect to the exact share 
    // name. 
    NthBackSlash = 4;
    do
    {
        dwAddError = ERROR_SUCCESS;
        for( i=0,count = 0, p =homedir; *p; ++p, ++i ) 
        {
            if( *p==L'\\' )
            {
                if( ++count == NthBackSlash )
                     break;
            }
            wsNetName[ i ] = homedir[ i ];
        }
        wsNetName[i] = L'\0';
        i=0;
        while( *p )
        {
            wsPathName[ i++ ] = *p++;
        }
        wsPathName[ i ] = L'\0';

        if( count == NthBackSlash )
        {
            _snwprintf( homedir,(wcslen(pHomeDrive)+wcslen(wsPathName)),L"%s%s", pHomeDrive, 
                wsPathName ); // NO size info, Baskar. Attack ?
        }
        else
        {
            _snwprintf( homedir,wcslen(pHomeDrive),L"%s\\", pHomeDrive ); // NO size info, Baskar. Attack ?
        }

        NetResource.lpRemoteName = wsNetName;
        NetResource.lpLocalName = pHomeDrive;
        NetResource.lpProvider = NULL;
        NetResource.dwType = RESOURCETYPE_DISK;

        if( WNetAddConnection2( &NetResource, NULL, NULL, 0 ) != NO_ERROR )
        {
            dwAddError = GetLastError();
            if( dwAddError == ERROR_ALREADY_ASSIGNED) 
            {
            }
            else
            {
                if( dwAddError == ERROR_BAD_NET_NAME && count == NthBackSlash )
                {
                    wcscpy( homedir, szSaveHomeDir );
                }
                else
                {
                    wcscpy( homedir, L"C:\\" );
                    _TRACE( TRACE_DEBUGGING, "Error: WNetAddConnection2() --"
                           " 0x%1x", dwAddError );
                    result = false;
                    dwAddError = ERROR_SUCCESS; //Get out of the loop
                }
            }
        }
        NthBackSlash++; // It may be NFS share and \ may be part of share name.
    }
    //ERROR_BAD_NET_NAME: The network name cannot be found
    while( dwAddError == ERROR_BAD_NET_NAME);

ExitOnError:        
    if(! RevertToSelf())
    {
        LogFormattedGetLastError(EVENTLOG_ERROR_TYPE, TELNET_MSG_REVERTSELFFAIL, GetLastError());
        result = false;
        _TRACE( TRACE_DEBUGGING, "Error: RevertToSelf() -- 0x%1x", 
            GetLastError() );
    }

    delete[] szSaveHomeDir;
    delete[] wsPathName;
    delete[] wsNetName;
    return result;
}


//Get the user preference related info 
bool CShell::GetNFillUserPref(LPWSTR serverName, LPWSTR user)
{
    LPBYTE bufPtr = NULL;
    LPUSER_INFO_3  userInfo3;
    DWORD  dwStatus = 0;
    bool   bRetVal = false;
    BOOL bReturn = FALSE;

    bReturn = ImpersonateLoggedOnUser( m_pSession->CSession::m_hToken );
    if(!bReturn)
    {
        bRetVal = false;
        goto Done;
    }
    if( ( dwStatus = NetUserGetInfo( serverName, user, 3, &bufPtr ) )== NERR_Success )
    {
        userInfo3 = ( LPUSER_INFO_3 ) bufPtr;

        if( !AllocNCpyWStr( &pProfilePath, userInfo3->usri3_profile ) )
        {
            goto ExitOnError;
        }
        if( !AllocNCpyWStr( &pLogonScriptPath, userInfo3->usri3_script_path ) )
        {
            goto ExitOnError;
        }
        if( !AllocNCpyWStr( &pHomeDir, userInfo3->usri3_home_dir ) )
        {
            goto ExitOnError;
        }
        if( !AllocNCpyWStr( &pHomeDrive, userInfo3->usri3_home_dir_drive ) )
        {
            goto ExitOnError;
        }
ExitOnError:
        NetApiBufferFree( bufPtr );
        bRetVal =  true;
    }
    else if(dwStatus == ERROR_ACCESS_DENIED && m_pSession->CIoHandler::m_bNTLMAuthenticated)
    {
        bRetVal = true;
    }
    else
    {
        _TRACE( TRACE_DEBUGGING, "Error: NetUserGetInfo() code : %d",dwStatus);
    }

    if(!RevertToSelf())
    {
        LogFormattedGetLastError(EVENTLOG_ERROR_TYPE, TELNET_MSG_REVERTSELFFAIL, GetLastError());
        bRetVal = false;
    }
Done:    
    return bRetVal;
}

bool
CShell::GetNameOfTheComputer()
{ 
    LPWSTR lpBuffer = NULL;
    bool bRetVal = false;
    DWORD size = MAX_COMPUTERNAME_LENGTH + 3; //one for NULL and two for '\\'.

    lpBuffer = new WCHAR[ size ];
    if( !lpBuffer )
    {
        goto Done;
    }

    if( !GetComputerName( lpBuffer, &size ) )
    {
        _TRACE( TRACE_DEBUGGING, "Error: GetComputerName() -- 0x%1x", 
                GetLastError() );
        goto Done;
    }
    else
    {
        size++;
        size+= strlen("\\\\");
        pServerName = new WCHAR[ size ];
        if( NULL == pServerName)
        {
            goto Done;
        }
        SfuZeroMemory((void *)pServerName,size*sizeof(WCHAR));
        _snwprintf( pServerName, size -1,L"%s%s", L"\\\\", lpBuffer ); // NO overflow, calculated size already.
    }
    bRetVal = true;
 Done:
    if(lpBuffer)
        delete[] lpBuffer;
    return( bRetVal );
}

/* 
    AreYouHostingTheDomain opens the local LSA and finds out the domain hosted.
    It then checks that agains the domain passed and returns TRUE/FALSE as appropriate.
*/
 
BOOL CShell::AreYouHostingTheDomain(
    LPTSTR lpDomain, 
    LPTSTR lpServer
    )
{
    OBJECT_ATTRIBUTES               obj_attr = { 0 };
    LSA_HANDLE                      policy;
    NTSTATUS                        nStatus;
    BOOL                            found = FALSE;
    LSA_UNICODE_STRING              name, *name_ptr = NULL;
 
    obj_attr.Length = sizeof(obj_attr);
 
    if (lpServer) 
    {
        RtlInitUnicodeString(& name, lpServer);
 
        name_ptr = & name;
    }
 
    nStatus = LsaOpenPolicy(
                name_ptr,
                &obj_attr,
                POLICY_VIEW_LOCAL_INFORMATION | MAXIMUM_ALLOWED,
                & policy
                );
 
    if (NT_SUCCESS(nStatus))
    {
        POLICY_ACCOUNT_DOMAIN_INFO  *info;
 
        nStatus = LsaQueryInformationPolicy(
                    policy,
                    PolicyAccountDomainInformation,
                    (PVOID *)&info
                    );
 
        LsaClose(policy);
 
        if (NT_SUCCESS(nStatus)) 
        {
            UNICODE_STRING      ad_name;
 
            RtlInitUnicodeString(& ad_name, lpDomain);
 
            found = RtlEqualUnicodeString(& ad_name, & (info->DomainName), TRUE); // case insensitive check
 
            LsaFreeMemory(info);
        }
    }
 
    return found;
}

 
bool CShell::GetDomainController(LPTSTR lpDomain, LPTSTR lpServer)
{
    NTSTATUS        nStatus;
    TCHAR           *sz1stDCName = NULL;
    TCHAR           *sz2ndDCName = NULL;
    bool            bRetVal = false;
 
    if(lpDomain == NULL || lpServer == NULL || lstrlenW(lpDomain) <= 0)
    {
        bRetVal = false;
        goto Done;
    }
 
    // initialize the return parameter
    lpServer[0] = _T('\0');
 
    /* 
        Before we proceed any further check whether we are hosting the domain
    */
 
    if (AreYouHostingTheDomain(lpDomain, NULL))
    {
        DWORD           length = MAX_COMPUTERNAME_LENGTH + 3; //one for NULL and two for '\\'
 
        /* Yes we are hosting the domain, so get computer name and get out */
 
        if(!GetNameOfTheComputer())
        {
            lpServer[0] = _T('\0');
            bRetVal = false;
            goto Done;
        }
        if(pServerName)
            _tcsncpy(lpServer,pServerName,length);
        bRetVal = true;
        goto Done;
    }
 
    /*
        Get a domain controller for the domain we are joined to 
    */
 
    nStatus = NetGetAnyDCName( NULL, NULL, ( LPBYTE * )&sz1stDCName );
    if(nStatus == NERR_Success )
    {
        /* The domain we want is that the one we are joined to ? */
 
        if (AreYouHostingTheDomain(lpDomain, sz1stDCName) )
        {
            lstrcpy(lpServer, sz1stDCName); // No BO - BaskarK
            NetApiBufferFree( sz1stDCName );
 
            bRetVal = true;
            goto Done;
        }
 
        /* 
           Since the domain we are joined to is not the one we want, let us find out whether it is in any
           of the trusted list in the forest/enterprise
        */
 
        nStatus = NetGetAnyDCName( sz1stDCName, lpDomain, ( LPBYTE * )&sz2ndDCName);
        if(nStatus == NERR_Success )
        {
            lstrcpy(lpServer, sz2ndDCName ); // No BO - BaskarK
            NetApiBufferFree( sz2ndDCName );
            bRetVal = true;
        }
 
        NetApiBufferFree( sz1stDCName );
    }
Done:
    return bRetVal;
}

 
//Locate and get the user info needed to load his/her profile.
bool CShell::LoadTheProfile()
{
    PROFILEINFO profile = { 0 };
    bool result = true;
    DWORD userPathSize = MAX_PATH+1, defPathSize = MAX_PATH+1;
    LPWSTR lpWideDomain = NULL ;
    PDOMAIN_CONTROLLER_INFO dcInfo = NULL;
    BOOL fnResult = FALSE;

    _TRACE( TRACE_DEBUGGING, "LoadTheProfile()");

    profile.dwSize        = sizeof( profile );
    profile.dwFlags       = PI_NOUI;

    /*
    * Fill the server name and the user name to pass to the
    * GetNFillUserPref function
    */
    ConvertSChartoWChar(m_pSession->CSession::m_pszUserName, &( profile.lpUserName ) );

    profile.lpServerName = NULL;
    if( !AllocNCpyWStr( &pServerName,  L"") )
    {
        return false;
    }  

    ConvertSChartoWChar(m_pSession->CSession::m_pszDomain, &lpWideDomain);
    profile.lpServerName = new WCHAR[MAX_STRING_LENGTH];
    if(profile.lpServerName == NULL)
    {
        result = false;
        goto Done;
    }
    if( strcmp( m_pSession->CSession::m_pszDomain, "." ) != 0 )
    {
        if( GetDomainController( lpWideDomain, profile.lpServerName ) )
        {
            delete[] pServerName;
            AllocNCpyWStr( &pServerName, profile.lpServerName );
        }
    }
    else
    {
        m_bIsLocalHost = true;
        GetNameOfTheComputer();
    }
        
    profile.lpProfilePath = NULL;
    if(!GetNFillUserPref(profile.lpServerName, profile.lpUserName ))
    {
        result = false;
        goto Done;
    }
    if( pProfilePath && wcscmp( pProfilePath, L"" ) != 0 ) 
    {
        AllocNCpyWStr( &( profile.lpProfilePath ), pProfilePath );
    }
    else
    {
        do
        {
            profile.lpProfilePath =  new TCHAR[ userPathSize ];
            if( !profile.lpProfilePath )
            {
                break;
            }
            if( !fnP_GetUserProfileDirectory )
            {
                break;
            }

            fnResult = fnP_GetUserProfileDirectory ( m_pSession->CSession::
                    m_hToken, profile.lpProfilePath, &userPathSize );
            if (!fnResult)
            {
                DWORD err;
                if ( ( err = GetLastError() ) != ERROR_INSUFFICIENT_BUFFER )
                {
                    fnResult = TRUE;
                    _TRACE( TRACE_DEBUGGING, "Error: GetUserProfileDirecto"
                        "ry() -- 0x%1x", err );
                }
                delete[] profile.lpProfilePath;
                profile.lpProfilePath = NULL;
            }
        } while ( !fnResult );

    }

    /*
    * pHomeDir and pHomeDrive will be empty unless it is explicity set
    * in the AD for domain users and Local User Manager for local users.
    * So assign the profile directory as home directory if it is empty.
    * Explorer does the same thing
    */
    if (pHomeDir && wcscmp(pHomeDir, L"") == 0)
    {
        if (profile.lpProfilePath && wcscmp(profile.lpProfilePath, L"") != 0)
        {
            delete[] pHomeDir;
            AllocNCpyWStr(&pHomeDir, profile.lpProfilePath);
        }
    }

    do
    {
        profile.lpDefaultPath =  new TCHAR[ defPathSize ];
        if( profile.lpDefaultPath == NULL)
        {
            break;
        }
        if( !fnP_GetDefaultUserProfileDirectory )
        {
            break;
        }

        fnResult = fnP_GetDefaultUserProfileDirectory( profile.lpDefaultPath, 
                &defPathSize );
        if (!fnResult)
        {
            DWORD err;
            err = GetLastError();
            if ( err != ERROR_INSUFFICIENT_BUFFER )
            {
                fnResult = TRUE;
                _TRACE( TRACE_DEBUGGING, "Error: GetDefaultUserProfile"
                    "Directory() -- 0x%1x", err );
            }
            delete[] profile.lpDefaultPath;
            profile.lpDefaultPath = NULL;
        }
    } while ( !fnResult );

    profile.lpPolicyPath  = NULL;

    if( fnP_LoadUserProfile )
    {
       if( fnP_LoadUserProfile(m_pSession->CSession::m_hToken, &profile) )
        {
            //assign the handle to a member from the session structure
            //so that it can be unloaded.

            m_hCurrUserKey = profile.hProfile;
            result = true;
        }
        else
        {
            _TRACE( TRACE_DEBUGGING, "Error: LoadUserProfile() -- 0x%1x", 
                GetLastError() );
            result = false;
        }
    }

    /*
    * Read the APPDATA folder. We need to pass this onto the environment
    * variables. For a user who is logged onto the system, this variable is
    * available when environment is imported. Otherwise this has to be read
    * and explicitly set. Are there more of this kind?? - Investigate.
    * Use CSIDL_FLAG_CREATE to have the folder created in case of a user
    * who logs onto the machine for the first time ever
    */
    m_pwszAppDataDir = new TCHAR[MAX_PATH + 1];
    if (!m_pwszAppDataDir)
    {
        result = false;
    }
    else
    {
        if (ImpersonateLoggedOnUser(m_pSession->CSession::m_hToken))
        {
            if (!SUCCEEDED(SHGetFolderPath(NULL, CSIDL_APPDATA | CSIDL_FLAG_CREATE,
                       m_pSession->m_bNtVersionGTE5 ? m_pSession->CSession::m_hToken : NULL,
                       // For systems earlier than Win2K this must be NULL, else you can
                       // pass the access token that can be used to represent a particular user
                       0, m_pwszAppDataDir)))
            {
                _TRACE(TRACE_DEBUGGING, "Error: Reading APPDATA path -- 0x%1x\n", GetLastError());
                result = false;
            }
            if(!RevertToSelf())
            {
                LogFormattedGetLastError(EVENTLOG_ERROR_TYPE, TELNET_MSG_REVERTSELFFAIL, GetLastError());
                result = false;
                _TRACE(TRACE_DEBUGGING, "Error: RevertToSelf() -- 0x%1x", GetLastError());
            }
        }
    }
Done:
    if(profile.lpUserName)
        delete[] profile.lpUserName;
    if(profile.lpServerName)
        delete[] profile.lpServerName;
    if(profile.lpDefaultPath)
        delete[] profile.lpDefaultPath;
    if(profile.lpProfilePath)
        delete[] profile.lpProfilePath;
    if(lpWideDomain)
        delete[] lpWideDomain;

    return result;
}

bool
CShell::CancelNetConnections ( )
{
    DWORD dwRetVal;

    if (NULL == m_pSession->CSession::m_hToken)
    {
        // Nothing to do here, perhaps the session was quit in an unauthenticated state
        // or authentication failed

        return true;
    }
    _chVERIFY2( dwRetVal = ImpersonateLoggedOnUser( 
                            m_pSession->CSession::m_hToken ) );
    if( !dwRetVal )
    {
        return ( false );
    }

    DWORD dwResult;
    HANDLE hEnum;
    DWORD cbBuffer = 16384;
    DWORD cEntries = 0xFFFFFFFF;
    LPNETRESOURCE lpnrDrv;
    DWORD i;
    
    dwResult = WNetOpenEnum( RESOURCE_CONNECTED, RESOURCETYPE_ANY, 0, NULL,
                               &hEnum );
    if(dwResult != NO_ERROR)      
    {
        _TRACE( TRACE_DEBUGGING, "\nCannot enumerate network drives.\n" );         
        if(! RevertToSelf( ) )
        {
            LogFormattedGetLastError(EVENTLOG_ERROR_TYPE, TELNET_MSG_REVERTSELFFAIL, GetLastError());
        }
        return ( false );
    } 
   
    do{
        lpnrDrv = (LPNETRESOURCE) GlobalAlloc( GPTR, cbBuffer );
        if( !lpnrDrv )
        {
            if(! RevertToSelf( ) )
            {
                LogFormattedGetLastError(EVENTLOG_ERROR_TYPE, TELNET_MSG_REVERTSELFFAIL, GetLastError());
            }
            return( false );
        }
        dwResult = WNetEnumResource( hEnum, &cEntries, lpnrDrv, &cbBuffer   );
        if (dwResult == NO_ERROR)         
        {
            for( i = 0; i < cEntries; i++ )            
            {
               if( lpnrDrv[i].lpLocalName != NULL )               
               {
                  //printf( "%s\t%s\n", lpnrDrv[i].lpLocalName,
                  //                    lpnrDrv[i].lpRemoteName );
                  WNetCancelConnection2( lpnrDrv[i].lpLocalName, 
                                CONNECT_UPDATE_PROFILE, FALSE );
               }
            }
        }
        else if( dwResult != ERROR_NO_MORE_ITEMS )
        {   
            _TRACE( TRACE_DEBUGGING,  "Cannot complete network drive enumeration" );
            GlobalFree( (HGLOBAL) lpnrDrv );
            break;         
        }

        GlobalFree( (HGLOBAL) lpnrDrv );
    } while( dwResult != ERROR_NO_MORE_ITEMS );

    WNetCloseEnum(hEnum);

    if(! RevertToSelf( ) )
    {
        LogFormattedGetLastError(EVENTLOG_ERROR_TYPE, TELNET_MSG_REVERTSELFFAIL, GetLastError());
        return( false );
    }
    return ( true );
}

void 
CShell::Shutdown ( )
{
    
    _TRACE( TRACE_DEBUGGING, "0x%p CTelnetClient::Shutdown() \n", this );
    if(g_hProv)
    {
        CryptReleaseContext(g_hProv,0);
        g_hProv = NULL;
    }

    if( !CancelNetConnections())
    {
        _TRACE( TRACE_DEBUGGING, "Error: CancelNetConnections()" );
    }

    //expect a exception in debug builds.  
    //cmd is killed by now in general case.  
    //This should be before cleanup. Otherwise this is an open handle to cmd.

    if ((m_hProcess != INVALID_HANDLE_VALUE) && (m_hProcess != NULL)) 
    {
        TerminateProcess(m_hProcess, 0); // Don't care whether it succeeded or not.
        TELNET_CLOSE_HANDLE( m_hProcess ); 
    }
    if ((m_hTempProcess != INVALID_HANDLE_VALUE) && (m_hTempProcess != NULL)) 
    {
        TerminateProcess(m_hTempProcess , 0); // Don't care whether it succeeded or not.
        TELNET_CLOSE_HANDLE( m_hTempProcess ); 
    }
    
    LUID id = m_pSession->CSession::m_AuthenticationId;
       
    //clean up potentially abandoned proceses
    //this slows down the thread a lot

    if( ( id.HighPart !=0 ) || ( id.LowPart != 0 ) )
        KillProcs( id );

    if( fnP_UnloadUserProfile && m_hCurrUserKey )
    {
        if( !fnP_UnloadUserProfile(m_pSession->CSession::m_hToken, m_hCurrUserKey) )
        {
            _TRACE( TRACE_DEBUGGING, "Error: UnloadUserProfile() - %1x", GetLastError() );
        }
    }

    if(m_lpEnv)
        delete[] ( UCHAR * )m_lpEnv;   
    m_lpEnv = NULL;
        
    FreeConsole();
}

void
CShell::LoadLibNGetProc( )
{
    CHAR szDllPath[MAX_PATH*2] = { 0 };
    UINT iRet = 0;
    //Dynamicallly load userenv.lib
    iRet = GetSystemDirectoryA(szDllPath,(MAX_PATH*2)-1);
    if(iRet == 0 || iRet >= (MAX_PATH*2))
    {
        goto End;
    }
    strncpy(szDllPath+iRet,"\\userenv.dll",(MAX_PATH*2)-iRet-1);
    _chVERIFY2( hUserEnvLib  =  LoadLibraryA( szDllPath ) ); 
    if( hUserEnvLib  )
    {
        _chVERIFY2( fnP_LoadUserProfile = ( LOADUSERPROFILE * ) GetProcAddress
                ( hUserEnvLib, "LoadUserProfileW" ) ); 
        
        _chVERIFY2( fnP_UnloadUserProfile = ( UNLOADUSERPROFILE * )
            GetProcAddress ( hUserEnvLib, "UnloadUserProfile" ) );
        
        _chVERIFY2( fnP_CreateEnvironmentBlock = ( CREATEENVIRONMENTBLOCK * )
            GetProcAddress( hUserEnvLib, "CreateEnvironmentBlock" ) );
        
        _chVERIFY2( fnP_DestroyEnvironmentBlock = ( DESTROYENVIRONMENTBLOCK *)
            GetProcAddress( hUserEnvLib, "DestroyEnvironmentBlock" ) );
        
        _chVERIFY2( fnP_GetUserProfileDirectory = ( GETUSERPROFILEDIRECTORY * )
            GetProcAddress( hUserEnvLib, "GetUserProfileDirectoryW" ) ); 

        _chVERIFY2( fnP_GetDefaultUserProfileDirectory =
            ( GETDEFAULTUSERPROFILEDIRECTORY * )
            GetProcAddress( hUserEnvLib, "GetDefaultUserProfileDirectoryW" ));
    }
End:
    return;
}

void CopyRestOfEnv( LPTSTR *lpSrcEnv, LPTSTR *lpDstEnv )
{
    DWORD dwEnvSize = 0;
    LPTSTR lpTmp = *lpSrcEnv;
    DWORD dwStringLen = 0;

    while( *( *lpSrcEnv ) )
    {
        dwStringLen = ( wcslen( *lpSrcEnv ) + 1 );
        dwEnvSize += dwStringLen;
        *lpSrcEnv  += dwStringLen;
    }

    //Copy L'\0' at the end of the block also
    memcpy( *lpDstEnv, lpTmp, (dwEnvSize+1 )*2 ); // NO size info for Dest, Attack ? - Baskar
}

void PutStringInEnv( LPTSTR lpStr, LPTSTR *lpSrcEnv, LPTSTR *lpDstEnv, bool bOverwrite)
{
    DWORD dwEnvSize = 0;
    LPTSTR lpTmp = *lpSrcEnv;
    DWORD dwStringLen = 0;
    LPTSTR lpSrcTmp = NULL;
    wchar_t *wcCharPos = NULL;
    wchar_t *wcCharPosSrc = NULL;
    bool bCopyString = true;
    int nOffset, nOffsetSrc,nOffsetTemp;
    
    wcCharPos = wcschr(lpStr, L'=');
    if (NULL == wcCharPos)
    {
        _TRACE(TRACE_DEBUGGING, "Error: TLNTSESS: The syntax of an env string is VAR=VALUE\n");
        return;
    }
    nOffset = (int)(wcCharPos - lpStr);
    
    wcCharPosSrc = wcschr(*lpSrcEnv, L'=');
    if (NULL == wcCharPos)
    {
        _TRACE(TRACE_DEBUGGING, "Error: TLNTSESS: The syntax of an env string is VAR=VALUE\n");
        return;
    }
    nOffsetTemp = (int)(wcCharPosSrc - (*lpSrcEnv));
    nOffsetSrc = max(nOffset,nOffsetTemp);

    while(*(*lpSrcEnv) && _wcsnicmp(*lpSrcEnv, lpStr, nOffsetSrc) < 0)
    {
        dwStringLen = wcslen(*lpSrcEnv) + 1;
        dwEnvSize += dwStringLen;
        *lpSrcEnv += dwStringLen;
        wcCharPosSrc = wcschr(*lpSrcEnv, L'=');
        if (NULL == wcCharPosSrc)
        {
            _TRACE(TRACE_DEBUGGING, "Error: TLNTSESS: The syntax of an env string is VAR=VALUE\n");
            return;
        }
        nOffsetTemp = (int)(wcCharPosSrc - (*lpSrcEnv));
        nOffsetSrc = max(nOffset,nOffsetTemp);
    }

    if (*(*lpSrcEnv) )
    {
        int iRet = -1;
        iRet = _wcsnicmp(*lpSrcEnv, lpStr, nOffsetSrc);
        if(iRet == 0)
        {
            dwStringLen = wcslen(*lpSrcEnv) + 1;
            *lpSrcEnv += dwStringLen;
            if (!bOverwrite)
            {
                dwEnvSize += dwStringLen;   // Copy this env variable too, so offset the size
                bCopyString = false;        // Because we found a match and we shouldn't overwrite
            }
        }
    }

    memcpy( *lpDstEnv, lpTmp, dwEnvSize*2 ); // No size info ? - Baskar
    *lpDstEnv += dwEnvSize;

    if (!bCopyString)
    {
        return;
    }

    dwStringLen =  wcslen ( lpStr ) + 1 ;
    memcpy( *lpDstEnv, lpStr, dwStringLen*2 ); // No size info ? - Baskar
    *lpDstEnv += dwStringLen;
}

//This will break an absolute path into drive and relative path.
//Relative path is returned through szHomePath
void GetRelativePath( LPWSTR *szHomePath )
{
    _chASSERT( szHomePath );
    _chASSERT( *szHomePath );

    while( *( *szHomePath ) != L'\0' && *( *szHomePath ) != L':' )
    {
        ( *szHomePath) ++;
    }

    if( *( *szHomePath ) == L':' )
    {
        ( *szHomePath) ++;
    }
    *( *szHomePath ) = L'\0';
    
    ( *szHomePath)++;
}

//It returns the size in terms of WCHARS
void FindSizeOfEnvBlock( DWORD *dwEnvSize, LPVOID lpTmpEnv  )
{
    _chASSERT( dwEnvSize );
    _chASSERT( lpTmpEnv );

    //The Environment block has set of strings and ends with L'\0'
    while( ( *( ( UCHAR * )lpTmpEnv ) ) )
    {
        DWORD dwStringLen = wcslen( ( LPTSTR )lpTmpEnv ) + 1;
        *dwEnvSize += dwStringLen ; 
        lpTmpEnv  = ( TCHAR * )lpTmpEnv + dwStringLen;
    }

    *dwEnvSize += 1; //Accounting for L'\0' at the end of block
}

// do this so that the cmd.exe
// gets the environment with following variables set
void
CShell::ExportEnvVariables()
{
    TCHAR  szHomeDirectoryPath[ MAX_PATH + 1 ];
    TCHAR  *szHomePath = NULL;
    LPVOID lpTmpEnv = NULL;
    LPVOID lpTmpOldEnv = NULL;
    LPVOID lpNewEnv = NULL;
    DWORD  dwEnvSize = 0;
    TCHAR  szTmp[] = L"\\";
    DWORD  dwIndex = 0;

    if(m_lpEnv == NULL)
        return;
    
    wcsncpy( szHomeDirectoryPath, wideHomeDir , MAX_PATH);
    szHomePath = szHomeDirectoryPath;
    GetRelativePath( &szHomePath );

    TCHAR szHomeVar[ MAX_PATH + UNICODE_STR_SIZE(ENV_HOMEPATH) ] = { 0 };
    TCHAR szHomeDirVar[ MAX_PATH + 1]= { 0 };
    TCHAR szTermVar[ MAX_PATH + 1 ]= { 0 };
    TCHAR szAppDataDirVar[MAX_PATH + UNICODE_STR_SIZE(ENV_APPDATA)]= { 0 };
    TCHAR szUserName[MAX_PATH+1+ UNICODE_STR_SIZE(ENV_USERNAME)]= { 0 };
    LPWSTR szUserDomain = NULL;
    DWORD domainsize = wcslen(m_pSession->CSession::m_szDomain) +1 +UNICODE_STR_SIZE(ENV_USERDOMAIN);
    LPWSTR szUserProfile = NULL;
    DWORD profilesize = wcslen(pProfilePath)+1+UNICODE_STR_SIZE(ENV_USERPROFILE);
    LPWSTR pszUserName = NULL;
    
	TCHAR *szTempTerm = NULL;
    TCHAR *szTerm = NULL;

    szUserDomain = new WCHAR[domainsize];
    if(szUserDomain == NULL)
    {
        lpTmpOldEnv = m_lpEnv;
        m_lpEnv = NULL;
    	goto ExitOnError;
    }
    szUserProfile = new WCHAR[profilesize];
    if(szUserProfile == NULL)
    {
        lpTmpOldEnv = m_lpEnv;
        m_lpEnv = NULL;
    	goto ExitOnError;
    }
    
    wcscpy( szHomeVar,       ENV_HOMEPATH );
    wcscpy( szHomeDirVar,    ENV_HOMEDRIVE );
    wcscpy( szTermVar,       ENV_TERM );
    wcscpy( szAppDataDirVar, ENV_APPDATA );
    wcscpy(szUserName, ENV_USERNAME);
    wcscpy(szUserDomain, ENV_USERDOMAIN);
    wcscpy(szUserProfile, ENV_USERPROFILE);

    if(!ConvertSChartoWChar( m_pSession->CSession::m_pszTermType, &szTerm ))
    {
        lpTmpOldEnv = m_lpEnv;
        m_lpEnv = NULL;
    	goto ExitOnError;
    }

    // Convert term type to lower case, so that UNIX programs can work...
    for( szTempTerm = szTerm; *szTempTerm; szTempTerm++)
    {
        *szTempTerm = towlower(*szTempTerm);
    }

   while( ( dwIndex < MAX_PATH + 1 ) && szHomePath[ dwIndex ]  )
    {
        if( szHomePath[ dwIndex ] == L'\\' || szHomePath[ dwIndex ] == L'/' )
        {
            szTmp[0] = szHomePath[ dwIndex ];
            break;
        }

        dwIndex++;
    }

    if(!ConvertSChartoWChar(m_pSession->CSession::m_pszUserName, &pszUserName))
    {
        lpTmpOldEnv = m_lpEnv;
        m_lpEnv = NULL;
    	goto ExitOnError;
    }

    wcsncat( szHomeVar, szTmp, 1 );
    wcsncat( szHomeVar, szHomePath, MAX_PATH );

    wcsncat( szHomeDirVar, szHomeDirectoryPath, MAX_PATH );
    wcsncat( szTermVar, szTerm, MAX_PATH );
    wcsncat( szAppDataDirVar, m_pwszAppDataDir, MAX_PATH );
    wcsncat( szUserName, pszUserName, MAX_PATH);
    wcsncat( szUserDomain,m_pSession->CSession::m_szDomain,domainsize -1);
    wcsncat( szUserProfile,pProfilePath, profilesize -1); 

    szUserDomain[domainsize -1] = L'\0';
    szUserProfile[profilesize -1] = L'\0';

    FindSizeOfEnvBlock( &dwEnvSize, m_lpEnv );
    
    dwEnvSize += ( wcslen( szHomeVar ) + 2 );
    dwEnvSize += ( wcslen( szHomeDirVar ) + 2 );
    dwEnvSize += ( wcslen( szTermVar ) + 2 );
    dwEnvSize += ( wcslen( szAppDataDirVar ) + 2 );
    dwEnvSize += ( wcslen( szUserName ) + 2 );
    dwEnvSize += ( wcslen( szUserDomain ) + 2 );
    dwEnvSize += ( wcslen( szUserProfile ) + 2 );
    
    lpTmpEnv  = m_lpEnv;
    lpTmpOldEnv = m_lpEnv;
    m_lpEnv   = ( VOID * ) new UCHAR[ dwEnvSize * 2 ];
    if( !m_lpEnv )
    {
        goto ExitOnError;
    }
    lpNewEnv = m_lpEnv;

    /*
    * Make calls to PutStringInEnv alphabetically. This function moves the lpTmpEnv
    * variable and only searches forward. So if the calls aren't alphabetical, then
    * you wouldn't find a match even if there is one
    */
    PutStringInEnv( szAppDataDirVar, (LPTSTR *)&lpTmpEnv, ( LPTSTR * )&lpNewEnv, false);
    PutStringInEnv( szHomeDirVar, ( LPTSTR * )&lpTmpEnv, ( LPTSTR * )&lpNewEnv, false);
    PutStringInEnv( szHomeVar, ( LPTSTR * )&lpTmpEnv, ( LPTSTR * )&lpNewEnv, false);
    PutStringInEnv( szTermVar, ( LPTSTR * )&lpTmpEnv, ( LPTSTR * )&lpNewEnv, true);
    PutStringInEnv( szUserDomain, ( LPTSTR * )&lpTmpEnv, ( LPTSTR * )&lpNewEnv, true);
    PutStringInEnv( szUserName, ( LPTSTR * )&lpTmpEnv, ( LPTSTR * )&lpNewEnv, true);
    PutStringInEnv( szUserProfile, ( LPTSTR * )&lpTmpEnv, ( LPTSTR * )&lpNewEnv, true);
    CopyRestOfEnv( ( LPTSTR * )&lpTmpEnv, ( LPTSTR * )&lpNewEnv );

ExitOnError:    
    delete[] szTerm;
    if(pszUserName)
        delete [] pszUserName;
    if(szUserDomain)
        delete [] szUserDomain;
    if(szUserProfile)
        delete [] szUserProfile;

    if( fnP_DestroyEnvironmentBlock )
    {
        fnP_DestroyEnvironmentBlock( lpTmpOldEnv );
    }
}


//Load the profile path for setting in the environment variable. Currently
//Telnet session exports APPDATA, HOMEDRIVE, HOMEPATH, USERNAME,
//USERDOMAIN,USERPROFILE env variables to the newly created cmd.exe
//If any more environment variables need to be exported, corresponding
//Global variables should be loaded in this function.
void
CShell::GetEnvVarData()
{
    BOOL fnResult = FALSE;
    LPTSTR szProfilePath = NULL;
    DWORD userPathsize = MAX_PATH +1;
    do
    {
        szProfilePath =  new TCHAR[ userPathsize ];
        if( !szProfilePath )
        {
            break;
        }
        if( !fnP_GetUserProfileDirectory )
        {
            break;
        }

        fnResult = fnP_GetUserProfileDirectory ( m_pSession->CSession::m_hToken, 
                                            szProfilePath, &userPathsize);
        if (!fnResult)
        {
            DWORD err;
            if ( ( err = GetLastError() ) != ERROR_INSUFFICIENT_BUFFER )
            {
                fnResult = TRUE;
                _TRACE( TRACE_DEBUGGING, "Error: GetUserProfileDirecto"
                    "ry() -- 0x%1x", err );
            }
            delete[] szProfilePath;
            szProfilePath = NULL;
        }
        else
        {
            if(pProfilePath)
            {
                delete [] pProfilePath;
            }
            AllocNCpyWStr(&pProfilePath, szProfilePath);
        }
            
    } while ( !fnResult );

    if(szProfilePath)
        delete [] szProfilePath;

}
//This is only on NT4 where there is no LoadUserProfile()
void
CShell::SetEnvVariables()
{
    TCHAR szHomeDirectoryPath[ MAX_PATH + 1 ] = { 0 };
    TCHAR *szHomePath = NULL;
    UINT_PTR     space_left;
    DWORD dwIndex = 0;
    WCHAR szTmp[] = L"\\";
    TCHAR szHomeVar[ MAX_PATH + UNICODE_STR_SIZE(ENV_HOMEPATH) ] = { 0 };
    TCHAR szHomeDirVar[ MAX_PATH + 1]= { 0 };

    wcsncpy( szHomeDirectoryPath, wideHomeDir, MAX_PATH );
    szHomePath = szHomeDirectoryPath;

    GetRelativePath( &szHomePath );

    _chVERIFY2( SetEnvironmentVariableW( L"HOMEDRIVE", szHomeDirectoryPath ) );
    while( ( dwIndex < MAX_PATH + 1 ) && szHomePath[ dwIndex ]  )
    {
        if( szHomePath[ dwIndex ] == L'\\' || szHomePath[ dwIndex ] == L'/' )
        {
            szTmp[0] = szHomePath[ dwIndex ];
            break;
        }

        dwIndex++;
    }
    wcsncat( szHomeVar, szTmp, 1 );
    space_left = MAX_PATH - (szHomePath - szHomeDirectoryPath);

    wcsncat( szHomePath, L"\\", space_left );
    wcsncat( szHomeVar, szHomePath, MAX_PATH );


    _chVERIFY2( SetEnvironmentVariableW( L"HOMEPATH", szHomeVar ) );
    _chVERIFY2( SetEnvironmentVariableA( "TERM", m_pSession->CSession::m_pszTermType ) );
    SetEnvironmentVariableA("USERNAME",m_pSession->CSession::m_pszUserName);
    SetEnvironmentVariableW(L"USERPROFILE",pProfilePath);
    SetEnvironmentVariableW(L"USERDOMAIN",m_pSession->CSession::m_szDomain);
}

#ifdef ENABLE_LOGON_SCRIPT
BOOL
CShell::InjectUserScriptPathIntoPath( TCHAR szUserScriptPath[] )
{
    DWORD dwSize = 0;
    TCHAR *szNewPath = NULL;
    DWORD dwRetVal = 0;
    BOOL bRetVal = FALSE;

    if (NULL == szUserScriptPath )
    {
    	bRetVal = TRUE;
        goto ExitOnError;
    }

    if( wcslen( szUserScriptPath ) == 0 )
    {
    	bRetVal = TRUE;
        goto ExitOnError;
    }

    if( m_lpEnv )
    {
        DWORD  dwEnvSize = 0;
        LPVOID     lpTmpOldEnv = NULL;
        LPVOID     lpTmpEnv = NULL;
        TCHAR      *szVar = NULL;

        FindSizeOfEnvBlock( &dwEnvSize, m_lpEnv );

        dwSize = ( wcslen( szUserScriptPath ) + wcslen( L";" ) + 1);

        lpTmpEnv = ( VOID * ) new TCHAR[ ( dwEnvSize + dwSize ) ];
        if( lpTmpEnv )
        {
            bool bEndSearch = false;

            lpTmpOldEnv = m_lpEnv;            
            memcpy( lpTmpEnv, m_lpEnv, dwEnvSize * sizeof(TCHAR) );
            szVar = ( TCHAR * )lpTmpEnv;
            m_lpEnv = lpTmpEnv;
            
            do
            {
                if( _tcsnicmp( szVar, L"PATH=", LENGTH_OF_PATH_EQUALS )  == 0 )
                {
                    TCHAR *szVarNextToPath = NULL;

                    bEndSearch = true;
                    szVarNextToPath = szVar + wcslen( szVar ) + 1; //points to variable next to path

                    szVar += LENGTH_OF_PATH_EQUALS; //Move past PATH=
                    wcscat( szVar, L";" );
                    wcscat( szVar, szUserScriptPath );
                    szVar += ( wcslen( szVar ) + 1  ); //Move past value of path

                    DWORD dwOffset = (DWORD)( szVarNextToPath - ( TCHAR *)m_lpEnv );

                    //copy restof the env block 
                    memcpy( szVar, (( ( TCHAR * )lpTmpOldEnv )+ dwOffset) , (dwEnvSize*sizeof(szVar[0]) - dwOffset) );
                    break;  //we are done with our job.
                }

                szVar    = wcschr( ( TCHAR * )lpTmpEnv, L'\0' ) ; //look for L'\0'
                if( szVar )
                {
                    szVar++; //move past L'\0'
                }
                else
                {
                    //Should not happen
                    _chASSERT( 0 );
                    break;
                }

                lpTmpEnv = szVar;
            }
            while( *szVar != L'\0' );
            
            delete[] ( ( UCHAR * )lpTmpOldEnv  );
        }
    }
    else
    {
        dwSize = GetEnvironmentVariable( L"PATH", NULL, 0 );

        dwSize += ( wcslen( szUserScriptPath ) + wcslen( L";" ) ); //find future length of path

        szNewPath = new TCHAR[ dwSize + 1 ];
        if( szNewPath )
        {
            dwRetVal = GetEnvironmentVariable( L"PATH", szNewPath, dwSize );
            if(dwRetVal == 0 || dwRetVal > dwSize )
            	goto ExitOnError;
            wcscat( szNewPath, L";" );
            wcscat( szNewPath, szUserScriptPath );
            if(!SetEnvironmentVariable( L"PATH", szNewPath ) )
            	goto ExitOnError;
        }
        else
        {
        	goto ExitOnError;
        }
    }
    bRetVal = TRUE;
ExitOnError:
	if(szNewPath)
	{
    	delete[] szNewPath;
	}
	return(bRetVal);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsess\termcap.cpp ===
// TermCap.cpp : This file contains the
// Created:  Dec '97
// Author : a-rakeba
// History:
// Copyright (C) 1997 Microsoft Corporation
// All rights reserved.
// Microsoft Confidential


#include <StdLib.h>
#include <Debug.h>
#include <DbgLvl.h>
#include <TermCap.h>
#include <w4warn.h>
#include <TelnetD.h>
#include <TlntUtils.h>


using namespace _Utils;
using CDebugLevel::TRACE_DEBUGGING;
using CDebugLevel::TRACE_HANDLE;
using CDebugLevel::TRACE_SOCKET;

CTermCap* CTermCap::m_pInstance = 0;
int CTermCap::m_iRefCount = 0;
PCHAR CTermCap::m_pszFileName = 0;

extern HANDLE       g_hSyncCloseHandle;

// makes sure that there is only one instance of CTermCap created
CTermCap* CTermCap::Instance()
{
    if( 0 == m_pInstance )
    {
        m_pInstance = new CTermCap;
        m_iRefCount ++;
    }
    return m_pInstance;
}


CTermCap::CTermCap()
{
    m_lpBuffer = new CHAR[BUFF_SIZE3];
}


CTermCap::~CTermCap()
{
    delete [] m_pszFileName;
    delete [] m_lpBuffer;
    if(0 == (m_iRefCount --))
    {
    	delete [] m_pInstance;
    }
}

//
// This function sits on top of FindEntry so that we have the 
// flexibility (in future) to look for the TERMCAP entry in 
// areas other than the "termcap" file
//
bool CTermCap::LoadEntry( LPSTR lpszTermName )
{
    bool bReturn = false;
    
    if( 0 == lpszTermName )
        return ( false );
#if 0    
    // try to move m_hFile's file pointer to the beginning
    LONG lDistance = 0;
    DWORD dwPointer = SetFilePointer( m_hFile, lDistance, NULL, FILE_BEGIN );
    
    // if we failed ... 
    if( dwPointer == 0xFFFFFFFF ) 
    {      
        // obtain the error code 
        DWORD dwError = GetLastError() ;
       
        // deal with that failure
        _TRACE( TRACE_DEBUGGING, "SetFilePointer() failed %d" , dwError );
    } 
#endif    

    m_hFile = CreateFileA( m_pszFileName, GENERIC_READ, FILE_SHARE_READ, NULL, 
                                      OPEN_EXISTING, 
                                      FILE_ATTRIBUTE_NORMAL, 
                                      NULL);

    if ( m_hFile == INVALID_HANDLE_VALUE )
        return false ;

    //Fix for HANDLE LEAK : close the handle in the caller function.

    bReturn = FindEntry( lpszTermName);
    
    TELNET_CLOSE_HANDLE(m_hFile);
	
    return bReturn;
}


//
// This function reads blocks of data from the termcap file.
// Then it looks at each character. If it is a new line
// preceded by a '\' then it continues reading the characters.
// Else, it knows that it has successfully read a complete 
// termcap "entry" ( which is stored in m_lpBuffer). 
// Then it calls LookForTermName(). If LookForTermName() 
// is successful, then the job is done and we have the correct
// "entry" in the m_lpBuffer. Else, ie. if LookForTermName()
// fails, then we repeat the whole process again by reading
// the next block of data in the termcap file.
//
bool CTermCap::FindEntry(LPSTR lpszTermName)
{
    if(0 == lpszTermName)
    {
        return ( false );
    }

    _chASSERT( m_lpBuffer != 0 );

    PCHAR lpBuf;
    WORD c;
    WORD i = 0;
    DWORD dwBytesRead = 0;
    PCHAR lpInBuffer = new CHAR[BUFF_SIZE3];
    BOOL fResult;
    bool ret=false;

    if( !lpInBuffer )
    {
        return false;
    }

    SfuZeroMemory(lpInBuffer,BUFF_SIZE3);
    for(;;)
    {
        lpBuf = m_lpBuffer;
        for(;;)
        {
            if( i >= dwBytesRead ) 
            {
                fResult = ReadFile( m_hFile, lpInBuffer, BUFF_SIZE3, 
                                    &dwBytesRead,
                                    NULL );
                if( fResult &&  dwBytesRead == 0 )  
                {
                    ret = false;
                    goto _cleanup;
                }
                i = 0;
            }
            
            c = lpInBuffer[i++];

            if( '\r' == c )
                c = lpInBuffer[i++];

            if( '\n' == c ) 
            {
                if( lpBuf > m_lpBuffer && lpBuf[-1] == '\\' )
                {
                    lpBuf--;
                    continue;
                }
                break;
            }
            //if( lpBuf >= m_lpBuffer + BUFF_SIZE3 ) 
            if( (lpBuf - m_lpBuffer) >= BUFF_SIZE3 ) 
            {
                _TRACE(CDebugLevel::TRACE_DEBUGGING, "error: TERMCAP entry is way too big");
                dwBytesRead =0;
                i = 0;
                break;
            } 
            else
                *lpBuf++ = (CHAR)c;
        }
        
        *lpBuf = 0;

        if( LookForTermName( lpszTermName ))
        {
            ret = true;
            goto _cleanup;
        }
    }

_cleanup:
    delete [] lpInBuffer;
    return ( ret );
}


bool CTermCap::LookForTermName( LPSTR lpszTermName )
{
    if( 0 == lpszTermName )
        return ( false );

    _chASSERT( m_lpBuffer != 0 );

    PCHAR lpName;
    PCHAR lpBuf = m_lpBuffer;

    if('#' == *lpBuf)
        return (  false );

    for(;;)
    {
        for( lpName = lpszTermName; 
                *lpName && toupper( *lpBuf ) == toupper( *lpName ); 
                lpBuf++, lpName++ )
        {
            continue;
        }
        if(*lpName == 0 && (*lpBuf == '|' || *lpBuf == ':' || *lpBuf == 0))
        {
            return ( true );
        }
        while(*lpBuf && *lpBuf != ':' && *lpBuf != '|')
        {
            lpBuf++;
        }
        if(*lpBuf == 0 || *lpBuf == ':')
        {
            return ( false );
        }
        lpBuf++;
    }
}

#if 0
WORD CTermCap::GetNumber( LPCSTR lpszCapabilityName )
{
    if( 0 == lpszCapabilityName )
        return ( ( WORD ) -1 );

    _chASSERT( m_lpBuffer != 0 );

    PCHAR lpBuf = m_lpBuffer;

    for(;;)
    {
        lpBuf = SkipToNextField( lpBuf );
        if( NULL == lpBuf )
            return ( ( WORD ) -1 );
        if( *lpBuf++ != lpszCapabilityName[0] || *lpBuf == 0 || 
            *lpBuf++ != lpszCapabilityName[1])
        {
            continue;
        }
        if( *lpBuf != '#' )
            return ( ( WORD ) -1 );
        
        lpBuf++;
        
        WORD i = 0;
        
        while( isdigit( *lpBuf ))
        {
            i = i*10 + *lpBuf - '0';
            lpBuf++;
        }
        return ( i );
    }
}
#endif

bool CTermCap::CheckFlag(LPCSTR lpszCapabilityName)
{
    if( NULL == lpszCapabilityName )
        return ( false );

    // _chASSERT( m_lpBuffer != 0 );

    PCHAR lpBuf = m_lpBuffer;

    for(;lpBuf;)
    {
        lpBuf = SkipToNextField( lpBuf );
        if( !*lpBuf )
        {
            break;
        }

        if( *lpBuf++ == lpszCapabilityName[0] && *lpBuf != 0 && 
            *lpBuf++ == lpszCapabilityName[1] ) 
        {
            if(!*lpBuf || *lpBuf == ':')
            {
                return ( true );
            }
            else 
            {
                break;
            }
        }
    }

    return false;
}


PCHAR CTermCap::SkipToNextField( PCHAR lpBuf )
{
    if( NULL == lpBuf )
        return ( NULL );

    while( *lpBuf && *lpBuf != ':' )
        lpBuf++;
    if( *lpBuf == ':' )
        lpBuf++;
    return ( lpBuf );
}

LPSTR CTermCap::GetString( LPCSTR lpszCapabilityName )
{
    if( NULL == lpszCapabilityName )
        return ( NULL  );

    // _chASSERT( m_lpBuffer != 0 );

    PCHAR pBuf = m_lpBuffer;

    for(;pBuf;)
    {
        pBuf = SkipToNextField( pBuf );
        if( !*pBuf )
            return ( NULL );
        if( *pBuf++ != lpszCapabilityName[0] || *pBuf == 0 || 
            *pBuf++ != lpszCapabilityName[1] )
        {
            continue;
        }
        if( *pBuf != '=' )
            return ( NULL );
        pBuf++;

        return ( ParseString( pBuf ));
    }
    return ( NULL );
}


LPSTR CTermCap::ParseString( PCHAR pBuf )
{
    if( NULL == pBuf )
        return ( NULL );

    LPSTR lpszStr = new CHAR[25];
    PCHAR p = lpszStr;
    WORD c;
    if( !lpszStr )
    {
        return ( NULL );
    }

    if( *pBuf != '^' )
    {
        for(  c = *pBuf++; ( c && c != ':' );  c = *pBuf++)
        {
            *p++ = (CHAR)c;
        }
    }
    else
    {
        //Single control character. 
        pBuf++;
        *p++ = *pBuf - '@' ;    
    }
    *p++ = 0;
    return ( lpszStr );
}


// Notes: take care of other options, escapes, codes.
//

LPSTR CTermCap::CursorMove( LPSTR lpszCursMotionStr, WORD wHorPos, 
                            WORD wVertPos )
{
    if( NULL == lpszCursMotionStr ) 
        return ( NULL );

    PCHAR pCms = lpszCursMotionStr;
    LPSTR lpszCmsResult = new CHAR[BUFF_SIZE1];
    PCHAR pCmsResult = lpszCmsResult;
    WORD c, wNum = 0;
    
    bool fIsColumn = false;
    WORD wPos = wHorPos;

    if( !lpszCmsResult )
    {
        return NULL;
    }

    for( c = *pCms++;  c ; c = *pCms++ )
    {
        if( c != '%' ) 
        {
            *pCmsResult++ = (CHAR)c;
            continue;
        }

        switch( c = *pCms++ ) {

        case 'd':

            _itoa( wPos, pCmsResult, 10 );
	    while( *pCmsResult != '\0' )
            {
              pCmsResult++;
            }

            fIsColumn = !fIsColumn;

            wPos = fIsColumn ? wVertPos : wHorPos;
            continue;
            break;

        case '+':
            /*     %.    output value as in printf %c
             *     %+x    add x to value, then do %. */

            wNum = ( wPos - 1 ) + *pCms++;
            sprintf( pCmsResult, "%c", wNum ); // NO BO here - BaskarK
            pCmsResult += strlen( pCmsResult );
            wPos = wVertPos;
            break;

        case 'i':
            //wHorPos++;
            //wVertPos++;
            continue;

        default:
            delete [] lpszCmsResult;
            return NULL;
        }
    }
    *pCmsResult = 0;
    
    return ( lpszCmsResult );
}

//this funtion is sort a of a kludge
//if and when we decide to support
//padding then we need to revisit this
//piece of code.
//we assume that the string sent in
//conatins a padding number followed 
//by \E
//it basically strips the padding
//number in the string.
//It also substitutes \033 for \E
void CTermCap::ProcessString( LPSTR* lplpszStr )
{
    LPSTR lpszStr = *lplpszStr;
    if(lpszStr == NULL)
    {
        return;
    }
    
    PCHAR pStr = new char[ strlen( lpszStr ) + 2 ];
    if( !pStr )
    {
        return;
    }

    strcpy( pStr, "\033" ); // NO BO - Baskar
    
    PCHAR pChar = lpszStr;
    
    //strip padding
    while( (*pChar != '\0') && isdigit( *pChar ) )
    {
        pChar++;
    }

    //strip \E
    if(*pChar != '\0' )
    {
        pChar++;
        if (*pChar != '\0' )
            pChar++;
    }

    strcat( pStr, pChar );

    delete [] lpszStr;

    *lplpszStr = pStr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsvr\enumdata.h ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
// EnumData.h: interface for the CEnumData class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ENUMDATA_H__FE9E48A8_A014_11D1_855C_00A0C944138C__INCLUDED_)
#define AFX_ENUMDATA_H__FE9E48A8_A014_11D1_855C_00A0C944138C__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

struct PIdNode
{
    PIdNode *pNextPId;
    WCHAR *lpszProcessName;
    DWORD dwPId;
    
    PIdNode(DWORD dwId, WCHAR *lpszName ) : pNextPId( NULL )
    {
        dwPId =  dwId;
        lpszProcessName = new WCHAR [ lstrlenW( lpszName ) + 1 ];
        if (lpszProcessName) 
        {
            lstrcpyW( lpszProcessName, lpszName ); // Size already calculated.
        }
    }
    ~PIdNode()
    {
        if (lpszProcessName) 
        {
            delete [] lpszProcessName;
        }
    }
};


class CEnumData  
{
public:
    CEnumData();
    virtual ~CEnumData();
    void Add( LPWSTR lpszName, LPWSTR lpszDom, LPWSTR lpszPeerHostName, SYSTEMTIME lgnTime, LONG lId ); 
    void Add( LONG lId, DWORD dwId, WCHAR *lpszName );

    struct CNode
    {
        CNode* pNext;
        WCHAR* lpszUserName;
        WCHAR* lpszDomain;
        WCHAR* lpszPeerHostName;
        SYSTEMTIME logonTime;
        LONG lUniqueId;
        PIdNode *pProcessesHead;
        PIdNode *pProcessesTail;
        CNode( LPWSTR,  LPWSTR, LPWSTR, SYSTEMTIME, LONG ); 
        ~CNode();
    };

    //bool GetNext( LPWSTR* lplpszName );
    bool GetNext( CNode** );
    void Reset();

private:
    CNode* m_pPosition;
    CNode* m_pHead;
};

#endif // !defined(AFX_ENUMDATA_H__FE9E48A8_A014_11D1_855C_00A0C944138C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsvr\clientinfo.h ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
#ifndef _ClientInfo_h_
#define _ClientInfo_h_

#include <cmnhdr.h>

#include <ntlsapi.h> 
#include <winsock2.h>

#include <debug.h>
#include <Ipc.h> 
#include <TelnetD.h>
#include <TelntSrv.h> 
#include <TlntUtils.h>

#define INVALID_LICENSE_HANDLE  (0U - 1U)

using namespace _Utils;
using CDebugLevel::TRACE_DEBUGGING;
using CDebugLevel::TRACE_HANDLE;
using CDebugLevel::TRACE_SOCKET;

static DWORD l =1;
extern HANDLE       g_hSyncCloseHandle;
class CClientInfo
{
    HANDLE hInPipe;
    HANDLE hOutPipe;

public:
    SOCKET sSocket;
    DWORD dwPid;
    HANDLE hWritingPipe;
    HANDLE hReadingPipe; 
    CHAR   *szUserName;
    CHAR   *szDomain;
    CHAR   *szRemoteMachine;
    LPSYSTEMTIME lpLogonTime;
    LUID    *pAuthId;
    UCHAR  *m_ReadFromPipeBuffer;
    DWORD  m_dwPosition;
    DWORD  m_dwRequestedSize;
    bool   bLicenseIssued;
    LS_HANDLE m_hLicense;
    DWORD  m_dwIdleTime;
    HWINSTA window_station;
    HDESK   desktop;

    CClientInfo( 
        HANDLE hR, 
        HANDLE hW, 
        HANDLE hIn, 
        HANDLE hOut, 
        SOCKET sSok, 
        DWORD dPid, 
        HWINSTA winsta,
        HDESK   dsktp
        ) : 
    hReadingPipe( hR ), hWritingPipe( hW ), hInPipe( hIn ), 
    hOutPipe( hOut ), sSocket( sSok ), dwPid( dPid ), szUserName( NULL ), 
    m_dwPosition( 0 ), szDomain( NULL ), szRemoteMachine( NULL ), 
    lpLogonTime( NULL ), pAuthId( NULL ), m_hLicense( INVALID_LICENSE_HANDLE ), 
    window_station(winsta), desktop(dsktp)
    {
        m_ReadFromPipeBuffer = new UCHAR[ IPC_HEADER_SIZE ];
        m_dwRequestedSize = IPC_HEADER_SIZE;
        bLicenseIssued = false;
        m_dwIdleTime = 0;
    }

    virtual ~CClientInfo()
    {
        TELNET_SYNC_CLOSE_HANDLE( hReadingPipe );
        TELNET_SYNC_CLOSE_HANDLE( hWritingPipe );
        TELNET_SYNC_CLOSE_HANDLE( hInPipe );
        TELNET_SYNC_CLOSE_HANDLE( hOutPipe );

        if (desktop)
        {
            CloseDesktop(desktop);
            desktop = NULL;
        }

        if (window_station)
        {
            CloseWindowStation(window_station);
            window_station = NULL;
        }

        if (INVALID_SOCKET != sSocket)
        {
            _TRACE( TRACE_DEBUGGING, "~CClientInfo -- closesocket -- %p ", 
                    sSocket );
            closesocket( sSocket );
            sSocket = INVALID_SOCKET;
        }

        if (m_ReadFromPipeBuffer)
            delete[] m_ReadFromPipeBuffer;
        delete[] szUserName;
        delete[] szDomain;
        delete[] szRemoteMachine;
        delete   lpLogonTime;
        delete   pAuthId;
        if (INVALID_LICENSE_HANDLE != m_hLicense)
        {
            NtLSFreeHandle( m_hLicense );
            m_hLicense = INVALID_LICENSE_HANDLE;
        }
    }

    void CloseClientSocket()
    {
        _TRACE( TRACE_DEBUGGING, "CloseClientSocket -- closesocket -- %d ",
                (DWORD)sSocket );
        if (INVALID_SOCKET != sSocket)
        {
            closesocket( sSocket );
            sSocket = INVALID_SOCKET;
        }
        return;
    }
};

#endif _ClientInfo_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsess\vtnt.h ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
//Headers required for term type VTNT

#ifndef __VTNT_H
#define __VTNT_H

//To provide scrolling, we need a new field to tell whether the given data is 
//to be put w.r.t ( top, left ) of the screen or to be appended at the bottom 
//of the screen. Since, this field can't be added without breaking 
//V1, we use csbi.wAttributes for this purpose.

typedef struct {

//The following is not used in the v1 client. Hence, in V2, we are using
//csbi.wAttributes 
    CONSOLE_SCREEN_BUFFER_INFO csbi;

//Screen( and not buffer ) cursor position. ( top, left ) = ( 0, 0 )
    COORD                      coCursorPos;        

//The following is not really needed. It is filled always as ( 0, 0 ) at the 
//server end. Keeping it for v1 compatability.
    COORD                      coDest;

    COORD coSizeOfData;       //Size of data as coords

//Destination rectangle w.r.t screen ( and not buffer )
    SMALL_RECT srDestRegion;  

} VTNT_CHAR_INFO;

#define RELATIVE_COORDS     1
#define ABSOLUTE_COORDS     0

#endif //__VTNT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsvr\enclisvr.h ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
// EnCliSvr.h: Definition of the CEnumTelnetClientsSvr class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ENCLISVR_H__FE9E48A5_A014_11D1_855C_00A0C944138C__INCLUDED_)
#define AFX_ENCLISVR_H__FE9E48A5_A014_11D1_855C_00A0C944138C__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <resource.h>       // main symbols
#include <ClientInfo.h>

#define MAX_STRING_FROM_itow    ( 33 + 1 ) //1 for null char

#ifdef ENUM_PROCESSES
#define SIZE_OF_ONE_SESSION_DATA ( MAX_STRING_FROM_itow*9 + 2 + MAX_PATH * 3 + 5 * MAX_PATH )
#else
#define SIZE_OF_ONE_SESSION_DATA ( MAX_STRING_FROM_itow*9 + 2 + MAX_PATH * 3 )
#endif

/////////////////////////////////////////////////////////////////////////////
// CEnumTelnetClientsSvr

class  CEnumTelnetClientsSvr : 
        public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CEnumTelnetClientsSvr,&CLSID_EnumTelnetClientsSvr>,
	public IObjectWithSiteImpl<CEnumTelnetClientsSvr>,
	public IGetEnumClients,
	public IEnumClients,
        public IDispatchImpl<IManageTelnetSessions, &IID_IManageTelnetSessions, &LIBID_TLNTSVRLib>
{
public:
    CEnumTelnetClientsSvr() { m_pEnumeration = NULL; }

BEGIN_COM_MAP(CEnumTelnetClientsSvr)
    COM_INTERFACE_ENTRY(IGetEnumClients)
    COM_INTERFACE_ENTRY(IEnumClients)    
    COM_INTERFACE_ENTRY(IManageTelnetSessions)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//DECLARE_NOT_AGGREGATABLE(CEnumTelnetClientsSvr) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_EnumTelnetClientsSvr)

public:
// IEnumClients
	STDMETHOD(Clone)(/*[out]*/ IEnumClients** ppenum);
	STDMETHOD(Reset)();
	STDMETHOD(Skip)(/*[in]*/ ULONG celt);
	STDMETHOD(Next)(/*[in]*/ ULONG celt,
        /*[out, string]*/ TELNET_CLIENT_INFO** rgelt,
        /*[out]*/ ULONG* pceltFetched);

// IGetEnumClients
	STDMETHOD(GetEnumClients)(/*[out, retval]*/ IEnumClients** ppretval);

//IManageTelnetSessions
    STDMETHOD(GetTelnetSessions)( /*[out, retval]*/ BSTR* );
    STDMETHOD(SendMsgToASession)( DWORD, BSTR );

//IManageTelnetSessions &&  IEnumClients
    STDMETHOD(TerminateSession)( DWORD );

private:
    bool SendMsg( DWORD, BSTR );
    bool EnumClients( CEnumData* pEnumData );
    CEnumData* m_pEnumeration;
    bool InformTheSession( CClientInfo *, WCHAR [] );
    bool AskTheSessionItsDetails( CClientInfo* );
    bool AskTheSessionToQuit( CClientInfo* );

public:
//CComObjectRoot overrrides
    void FinalRelease();
};

#endif // !defined(AFX_ENCLISVR_H__FE9E48A5_A014_11D1_855C_00A0C944138C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsvr\enumdata.cpp ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
// EnumData.cpp: implementation of the CEnumData class.
//
//////////////////////////////////////////////////////////////////////

//#include ""
#include <tchar.h>
#include "TlntSvr.h"
#include "EnumData.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
//#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CEnumData::CNode::CNode( LPWSTR lpszName,  LPWSTR lpszDom , 
        LPWSTR lpszPeerHostname, SYSTEMTIME lgnTime, LONG lId ) : pNext( NULL )
{
       lpszUserName = new WCHAR [ wcslen( lpszName ) + 1 ];
       if (lpszUserName) 
       {
           wcscpy( lpszUserName, lpszName );    // Skip this functon, no bo here... Baskar
       }
       lpszDomain = new WCHAR [ wcslen( lpszDom ) + 1 ];
       if (lpszDomain) 
       {
           wcscpy( lpszDomain, lpszDom );
       }
       lpszPeerHostName = new WCHAR [ wcslen( lpszPeerHostname ) + 1 ];
       if (lpszPeerHostName) 
       {
           wcscpy( lpszPeerHostName, lpszPeerHostname );
       }
       logonTime = lgnTime;
       lUniqueId = lId;
       pProcessesHead = NULL;
       pProcessesTail = NULL;
}

CEnumData::CNode::~CNode( )
{
    if (lpszUserName) 
    {
        delete [] lpszUserName;
        lpszUserName = NULL;
    }
    if (lpszDomain) 
    {
        delete [] lpszDomain;
        lpszDomain = NULL;
    }
    if (lpszPeerHostName) 
    {
        delete [] lpszPeerHostName;
        lpszPeerHostName = NULL;
    }
}

CEnumData::CEnumData()
    : m_pPosition( NULL ), m_pHead( NULL )
{

}


CEnumData::~CEnumData()
{
    while( m_pHead )
    {
        m_pPosition = m_pHead->pNext;

        //delete the list of PIDs, Names.
        while( m_pHead->pProcessesHead )
        {
            m_pHead->pProcessesTail = m_pHead->pProcessesHead->pNextPId;
            delete m_pHead->pProcessesHead;
            m_pHead->pProcessesHead = m_pHead->pProcessesTail;
        }

        delete m_pHead;

        m_pHead = m_pPosition;
    }
}


void 
CEnumData::Add
(
    LPWSTR lpszName,
    LPWSTR lpszDom,
    LPWSTR lpszPeerHostName, 
    SYSTEMTIME lgnTime,
    LONG lId 
)
{
    CNode* pNewNode = new CNode( lpszName, lpszDom, lpszPeerHostName, lgnTime, lId );

    if (NULL != pNewNode) 
    {
        if( NULL == m_pHead )
        {
            m_pHead = pNewNode;
        }
        else
        {
            m_pPosition->pNext = pNewNode;
        }
        m_pPosition = pNewNode;
    }
}

void 
CEnumData::Add
( 
    LONG lId, 
    DWORD dwId, 
    WCHAR *lpszName 
)
{
    PIdNode *pPIdNode;
    CNode *pCNode;
    pCNode = m_pHead;    
    if ( !pCNode )
        return;
    
    pPIdNode = new PIdNode( dwId, lpszName );

    while( pCNode && pCNode->lUniqueId != lId )
    {
        pCNode = pCNode->pNext;
    }

    if (pPIdNode && pCNode && (pCNode->lUniqueId == lId) )
    {
        if ( !pCNode->pProcessesHead )
        {
            pCNode->pProcessesHead = pPIdNode;
        }
        else
        {
            pCNode->pProcessesTail->pNextPId = pPIdNode;
        }
        pCNode->pProcessesTail = pPIdNode;
    }
    else
    {
        delete pPIdNode;
    }
}

void CEnumData::Reset()
{
    m_pPosition = m_pHead;
}


bool 
CEnumData::GetNext
( 
    CEnumData::CNode** ppNode 
)
{
    PIdNode *pPIdNode = NULL;

    if( NULL == ppNode )
    {
        return ( false );

    }
    if( NULL == m_pPosition )
    {
        SYSTEMTIME lgnTime;
        ZeroMemory( &lgnTime, sizeof( SYSTEMTIME ) );
        *ppNode = new CNode( L"", L"", L"", lgnTime, 0 );
        return ( false );
    }

    *ppNode = new CNode( m_pPosition->lpszUserName, m_pPosition->lpszDomain,
        m_pPosition->lpszPeerHostName, m_pPosition->logonTime, m_pPosition->lUniqueId );  
    if (NULL == *ppNode) 
    {
        return (false);
    }

    if( m_pPosition->pProcessesHead )
    {
        pPIdNode = m_pPosition->pProcessesHead;
        ( *ppNode )->pProcessesHead = new 
            PIdNode( pPIdNode->dwPId, pPIdNode->lpszProcessName );

        if (NULL == (*ppNode)->pProcessesHead) 
        {
            delete *ppNode;
            *ppNode = NULL;
            return false;
        }

        ( *ppNode )->pProcessesTail = ( *ppNode )->pProcessesHead;

        pPIdNode = pPIdNode->pNextPId;
        while(  pPIdNode )
        {
            ( *ppNode )->pProcessesTail->pNextPId = new 
                PIdNode( pPIdNode->dwPId, pPIdNode->lpszProcessName );
            ( *ppNode )->pProcessesTail =
                ( *ppNode )->pProcessesTail->pNextPId;

            pPIdNode = pPIdNode->pNextPId;
        }
    }
    
    m_pPosition = m_pPosition->pNext;

    return ( true );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsvr\queue.cpp ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    queue.cpp

Abstract:

    Implementation of CQueue class.


Revision History:

    06 Dec 2000 manishap
        Created.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#include <Queue.h>

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CQueue Implementation                                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
CQueue::CQueue(
		
    )

/*++

Routine Description:

    Constructor for CQueue class.    

Arguments:

    None.

Return Values:

    None.


--*/
{
    HKEY hk = NULL;
	DWORD dwType = 0,dwSize = 0;
	m_pHead = NULL;
	m_pTail = NULL;
    DWORD dwDisp = 0;

	if( !TnSecureRegCreateKeyEx( HKEY_LOCAL_MACHINE, REG_PARAMS_KEY, NULL, NULL, 
                        REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED , NULL, &hk, &dwDisp, 0) ) 
    {
        if( RegQueryValueEx( hk, L"MaxConnections", NULL, &dwType, 
		( LPBYTE )& m_dwMaxUnauthenticatedConnections,&dwSize)
     	 )
	    {
    	    m_dwMaxUnauthenticatedConnections = DEFAULT_MAX_CONNECTIONS;
	    }
    }
	else
	{
		m_dwMaxUnauthenticatedConnections = DEFAULT_MAX_CONNECTIONS;
	}
    

	m_dwNumOfUnauthenticatedConnections = 0;
	m_dwMaxIPLimit = 4;

    __try
    {
        InitializeCriticalSection(&m_csQModification);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        ; // Nothing to do, just don't die.... BaskarK
    }
}

CQueue::~CQueue(
    )

/*++

Routine Description:

    Destructor for CQueue class.    

Arguments:

    None.

Return Values:

    None.

--*/

{
	if(m_pHead != NULL && m_pTail != NULL )
	{
		PQ_LIST_ENTRY pTmp=m_pHead;
		while( m_pHead != m_pTail )
		{
			pTmp = m_pHead;
			m_pHead = m_pHead->pQNext;
			delete pTmp;
		}
		delete m_pHead;
	}
	m_pHead = NULL;
	m_pTail = NULL;

	DeleteCriticalSection(&m_csQModification);
}

/*++

Routine Description:

    Checks whether queue is full. i.e. if the number of entries are equal
    to maximum number of unauthenticated connections allowed.    

Arguments:

    None.

Return Values:

    Returns TRUE on success.

--*/

bool
CQueue::IsQFull()
{   bool    result;
    bool    bCSOwned = true;
    do
    {
        __try 
        {
            EnterCriticalSection(&m_csQModification); 
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            Sleep(1);
            bCSOwned = false;
        }
    }
    while(!bCSOwned);
    result = (m_dwNumOfUnauthenticatedConnections  >= m_dwMaxUnauthenticatedConnections) ? true : false;
    LeaveCriticalSection(&m_csQModification);
    return result;
}

bool
CQueue::FreeEntry(DWORD dwPid)

/*++
Routine Description:

    Frees a particular entry in the queue.
	Also modifies the MaxNumOfUnauthenticatedConn.
	
Arguments:

    [in]pId whose entry is to be removed.

Return Values:

    Returns TRUE on success.

--*/

{
	bool bFound = FALSE;
    bool    bCSOwned = true;
    do
    {
        __try 
        {
            EnterCriticalSection(&m_csQModification); 
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            Sleep(1);
            bCSOwned = false;
        }
    }
    while(!bCSOwned);
	PQ_LIST_ENTRY pTmp=m_pHead;
	while(!bFound && pTmp )
	{
		if( pTmp->dwPid == dwPid )
		{
			bFound = TRUE;
		}
		else if( pTmp != m_pTail )
		{
			pTmp = pTmp->pQNext;
		}
		else
		{
			break;
		}
	}
	if(bFound)
	{
		if(pTmp == m_pHead )
		{
			if(m_pHead->pQNext)
			{
				m_pHead = m_pHead->pQNext;
				m_pHead->pQPrev = NULL;	
			}
			else
			{
				m_pHead = NULL;
				m_pTail = NULL;
			}
		}
		else if ( pTmp == m_pTail )
		{
			m_pTail = m_pTail->pQPrev;
			m_pTail->pQNext = NULL;
		}
		else
		{
			(pTmp->pQPrev)->pQNext = pTmp->pQNext;
			(pTmp->pQNext)->pQPrev = pTmp->pQPrev;
		}
		m_dwNumOfUnauthenticatedConnections--;
		delete pTmp;

	}
   	LeaveCriticalSection(&m_csQModification);
	return (bFound);	
}


bool
CQueue::Pop(HANDLE *phWritePipe)

/*++

Routine Description:

    Frees a head entry in the queue.

Arguments:

    Stores the pid and pipe handle. [out]pId, [out]PipeHandle.

Return Values:

    Returns TRUE on success.

--*/

{
	bool bRet = FALSE;
    bool    bCSOwned = true;
    do
    {
        __try 
        {
            EnterCriticalSection(&m_csQModification); 
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            Sleep(1);
            bCSOwned = false;
        }
    }
    while(!bCSOwned);
   	*phWritePipe = m_pHead->hWritePipe;
   	bRet = FreeEntry(m_pHead->dwPid);
    LeaveCriticalSection(&m_csQModification);
	return (bRet);
}

/*++

Routine Description:

    Checks whether new entry can be added to the queue. New entry will
    be denied when it comes from an IP Address for which the maximum
    number of entries allowed per IP Address are already present in the queue 
    or when the queue is full.
    In normal case, when new entry is to be added and the queue is not full, 
    entry is added at the tail position.
    In case of IPLimit Reached, and QueueFull, the bool variable bSendMessage
    is set to TRUE, which will be passed back to the caller function, which in turn
    will send a message to the session that it ( the session ) has been terminated.

Arguments:

    [in]pId ,[in]IP Address , [in/out]PipeHandle of an entry to be added [out]SendMessage. On Input,
    it takes the values to be added in the queue. On output, it sends the values of removed
    entry in case of IPLimitReached or QueueFull. [out]bSendMessage is set to true if
    the queue is full or if the IPlimit is reached. This
    flag will be used to notify that particular session that it should terminate.

Return Values:

    Returns TRUE if the entry gets added to the queue successfully.

--*/

bool
CQueue::WasTheClientAdded(DWORD dwPid, IP_ADDR *pchIPAddr,  HANDLE *phWritePipe, bool *pbSendMessage)
{
	bool bRet = FALSE;
	HANDLE hHeadWritePipe=NULL;
    bool    bCSOwned = true;
    do
    {
        __try 
        {
            EnterCriticalSection(&m_csQModification); 
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            Sleep(1);
            bCSOwned = false;
        }
    }
    while(!bCSOwned);
    *pbSendMessage = true;    

	if((! IsQFull()) && (! IsIPLimitReached(pchIPAddr)))
	{
	    if (Push(dwPid, phWritePipe, pchIPAddr)) // This could fail in low memory
        {
            bRet = TRUE;
            *pbSendMessage = false;
        }
	}
    LeaveCriticalSection(&m_csQModification);

	return (bRet);
}

bool
CQueue::OkToProceedWithThisClient(IP_ADDR *pchIPAddr)
{
	bool bRet = TRUE;
    bool    bCSOwned = true;
    do
    {
        __try 
        {
            EnterCriticalSection(&m_csQModification); 
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            Sleep(1);
            bCSOwned = false;
        }
    }
    while(!bCSOwned);
	if (
        (IsQFull()) ||  
        (IsIPLimitReached(pchIPAddr))
       )
	{
	    bRet = false;
	}
    LeaveCriticalSection(&m_csQModification);
	return (bRet);
}


/*++

Routine Description:

    Checks if the maximum number of entries for a particular IP Address are already 
    present.

Arguments:

    IP address of new entry to be added in the queue.

Return Values:

    Returns TRUE if maximum number of entries for a particular IP Address are 
    already present.

--*/

bool
CQueue::IsIPLimitReached(IP_ADDR *pchIPAddr)
{
	bool bReached = FALSE;
	DWORD dwCount = 0;
	// Request ownership of the critical section.
    bool    bCSOwned = true;
    do
    {
        __try 
        {
            EnterCriticalSection(&m_csQModification); 
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            Sleep(1);
            bCSOwned = false;
        }
    }
    while(!bCSOwned);
	PQ_LIST_ENTRY pTmp = m_pHead;
	while( pTmp )
	{
		if(strcmp (pTmp->chIPAddr, pchIPAddr) == 0 )
		{
			dwCount ++;
			if(dwCount == m_dwMaxIPLimit)
			{
				bReached = TRUE;
				break;
			}
		}
		pTmp = pTmp->pQNext;
	}
        // Release ownership of the critical section.
   	LeaveCriticalSection(&m_csQModification);
	return (bReached);
}

bool
CQueue::Push(DWORD dwPid, HANDLE *phWritePipe, IP_ADDR *pchIPAddr)

/*++

Routine Description:

    Allocates memory for an entry and adds it in the queue.
    Also modifies the MaxNumOfUnauthenticatedConn.

Arguments:

    [in]pId and [in]PipeHandle [in]IP Address of an entry to be added.

Return Values:

    Returns TRUE on success.

--*/

{
	PQ_LIST_ENTRY pNode;
	bool bRet = FALSE;
	// Request ownership of the critical section.
    bool    bCSOwned = true;
    do
    {
        __try 
        {
            EnterCriticalSection(&m_csQModification); 
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            Sleep(1);
            bCSOwned = false;
        }
    }
    while(!bCSOwned);
	pNode = (PQ_LIST_ENTRY) new Q_LIST_ENTRY;

    if (pNode) 
    {
        pNode->pQNext = NULL;
        pNode->pQPrev= NULL;

        if(NULL == m_pHead )
        {
            m_pHead = pNode;
            m_pTail = pNode;
        }
        else
        {
            m_pTail->pQNext = pNode;
            pNode->pQPrev = m_pTail;
            m_pTail = pNode;
        }
        m_pTail->dwPid = dwPid;
        m_pTail->hWritePipe = (*phWritePipe);
        strncpy(m_pTail->chIPAddr, pchIPAddr, SMALL_STRING - 1);
        bRet = TRUE;
        m_dwNumOfUnauthenticatedConnections++;
    }
    // Release ownership of the critical section.
  	LeaveCriticalSection(&m_csQModification);
	return (bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsvr\ipc.h ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
#ifndef _IPC_H_
#define _IPC_H_


#define IPC_HEADER_SIZE             ( sizeof( UCHAR ) + sizeof( DWORD ) )

//These messages are from session to server
#define SESSION_EXIT                '0'
#define SOCKET_HANDOVER_COMPLETE    '1'
#define AUDIT_CLIENT                '2'
#define SESSION_DETAILS             '3'
#define LICENSE_AVAILABLE           '4'
#define LICENSE_NOT_AVAILABLE       '5'
#define TLNTSVR_SHUTDOWN            '6'
#define SYSTEM_SHUTDOWN             '7'
#define OPERATOR_MESSAGE            '8'
#define UPDATE_IDLE_TIME            '9'
#define RESET_IDLE_TIME             'A'

//These messages are from server to session

#define GO_DOWN                     '0'

//The following is a message sent by service call back thread to IPC handling
//thread

#define MAX_PIPE_BUFFER 1024
#define NET_BUF_SIZ 2048
#define MAX_WRITE_SOCKET_BUFFER 4096
#define MAX_READ_SOCKET_BUFFER  1024

#endif _IPC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsvr\enclisvr.cpp ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
// EnCliSvr.cpp : Implementation of CTlntSvrApp and DLL registration.

#include <stdafx.h>
#include <oleauto.h>

#include <Debug.h>
#include <KillApps.h>
#include <TlntSvr.h>
#include <TelntSrv.h>
#include <EnumData.h>
#include <EnCliSvr.h>
#include <TlntUtils.h>
#include <Ipc.h>
#include <w4warn.h>

// Don't even think about changing the two strings -- BaskarK, they NEED to be in sync with tnadmin\tnadmutl.cpp
// the separators used to identify various portions of a session as well as session begin/end

WCHAR   *session_separator = L",";
WCHAR   *session_data_separator = L"\\";

boolean called_by_an_admin()
{
    static  PSID    administrators = NULL;
    boolean         an_admin = false;
    HANDLE          token;

    if (NULL == administrators) 
    {
        SID_IDENTIFIER_AUTHORITY local_system_authority = SECURITY_NT_AUTHORITY;

        //Build administrators alias sid
        if (! AllocateAndInitializeSid(
                &local_system_authority,
                2, /* there are only two sub-authorities */
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0,0,0,0,0,0, /* Don't care about the rest */
                &administrators
                ))
        {
            return false;
        }
    }

    if (OpenThreadToken(
            GetCurrentThread(), 
            TOKEN_QUERY | MAXIMUM_ALLOWED, 
            TRUE, 
            & token
            ))
    {
        TOKEN_GROUPS            *tg = NULL;
        DWORD                   required = 2048;    // 2K should be good enough for starters
        DWORD                   error = NO_ERROR;


        for (;;) 
        {
            tg = (TOKEN_GROUPS *) new BYTE[required];
            if (! tg) 
            {
                break;
            }

            if (GetTokenInformation(token, TokenGroups, (LPVOID) tg, required, & required))
            {
                error = NO_ERROR;
                break;
            }
            else
            {
                error = GetLastError();

                if (ERROR_INSUFFICIENT_BUFFER != error)
                {
                    break;
                }
            }

            delete [] tg;
        }

        if (tg && (NO_ERROR == error)) 
        {
            DWORD           x;

            for (x = 0; x < tg->GroupCount; x ++) 
            {
                if (EqualSid(administrators, & (tg->Groups[x].Sid)) &&
                          (tg->Groups[x].Attributes & SE_GROUP_ENABLED) && 
                          (!(tg->Groups[x].Attributes & SE_GROUP_USE_FOR_DENY_ONLY))
                  ) 
                {
                    an_admin = true;
                    break;
                }
            }
        }

        if (tg) 
        {
            delete [] tg;
        }

        CloseHandle(token);
    }

    return an_admin;
}

void AddSeparator( LPWSTR *pszSessionData, LPWSTR szString, INT *iSizeOfBuffer )
{
    _chASSERT( pszSessionData );
    _chASSERT( szString );
    _chASSERT( iSizeOfBuffer );

    if( !szString )
    {
        szString = L"";
    }

    _chVERIFY2( *iSizeOfBuffer >= ( INT ) ( wcslen( szString ) + 1 ) );

    DWORD dwLen = 0;
    if(  *iSizeOfBuffer >= ( INT )( wcslen( szString ) + 1 ) )
    {
        dwLen = wcslen( szString );
        wcsncpy( *pszSessionData, szString, dwLen );

        *pszSessionData  += ( dwLen );        
        *iSizeOfBuffer  -= ( dwLen );
    }

    return;
}

void WCopyInt( LPWSTR *pszSessionData, INT iNum, INT *iSizeOfBuffer )
{
    _chASSERT( pszSessionData );
    _chASSERT( iSizeOfBuffer );
    _chVERIFY2( *iSizeOfBuffer >= MAX_STRING_FROM_itow );

    _itow( iNum, *pszSessionData, 10 );
    *iSizeOfBuffer  -= wcslen( *pszSessionData );
    *pszSessionData += wcslen( *pszSessionData );
    
    AddSeparator( pszSessionData, session_data_separator, iSizeOfBuffer );
}        

void WCopyMbcsString( LPWSTR *pszSessionData, CHAR *szString, INT *iSizeOfBuffer )
{
    _chASSERT( pszSessionData );
    _chASSERT( szString );
    _chASSERT( iSizeOfBuffer );

    if( !szString )
    {
        szString = "";
    }

    _chVERIFY2( *iSizeOfBuffer >= ( INT )( strlen( szString ) + 1 ) );

    DWORD dwLen = 0;
    dwLen = MultiByteToWideChar( GetOEMCP(), 0, szString, -1, *pszSessionData,  *iSizeOfBuffer );
    if( dwLen > 0 ) 
    {
        *pszSessionData  += ( dwLen - 1 );        
        *iSizeOfBuffer   -= ( dwLen - 1 );

        AddSeparator( pszSessionData, session_data_separator, iSizeOfBuffer );
    } 
    return;
}

void WCopyUnicodeString( LPWSTR *pszSessionData, LPWSTR szString, INT *iSizeOfBuffer )
{
    _chASSERT( pszSessionData );
    _chASSERT( szString );
    _chASSERT( iSizeOfBuffer );

    if( !szString )
    {
        szString = L"";
    }

    _chVERIFY2( *iSizeOfBuffer >= ( INT ) ( wcslen( szString ) + 1 ) );

    DWORD dwLen = 0;
    if(  *iSizeOfBuffer >= ( INT )( wcslen( szString ) + 1 ) )
    {
        dwLen = wcslen( szString );
        wcsncpy( *pszSessionData, szString, dwLen );

        *pszSessionData  += dwLen;        
        *iSizeOfBuffer   -= dwLen;

        AddSeparator( pszSessionData, session_data_separator, iSizeOfBuffer );
    }

    return;
}

/////////////////////////////////////////////////////////////////////////////
//

extern CTelnetService* g_pTelnetService;

//Global variables used to pass data b/n GetSessionProcesses and EnumClients
CEnumData* g_pEnumData = NULL;
LONG lUniqueSessionNumber;


//Global variables used to pass data b/n GetTelnetSessionProcesses and GetTelnetSessions
BSTR    g_szSessionData = NULL;
INT     g_iSizeOfBuffer    = 0; 

#ifdef ENUM_PROCESSES
void
GetTelnetSessionProcesses
(
    HANDLE hProc,
    DWORD dwProcessId,
    LPWSTR lpszProcessName
)
{
    WCopyInt( &g_szSessionData, dwProcessId, &g_iSizeOfBuffer );
    WCopyUnicodeString( &g_szSessionData, lpszProcessName, &g_iSizeOfBuffer );    
}
#endif

//memory is allocated by this method ( GetTelnetSessions ) and to be freed by the client( telnet admin ).
//It returns data about each session as a BSTR formatted as below.
//Each feild is separated by wide char ':'. Each session is separated by ','
//First entry is count of sessions and only this feild is separated by comma from the rest. This is followed by,
//dwPid,szDomain,szUserName,szRemoteMachine, wYear, wMonth, wDayOfWeek, wDay, 
//wHour, wMinute, wSecond, wMilliseconds;  and pairs of process id, process name.


STDMETHODIMP 
CEnumTelnetClientsSvr::GetTelnetSessions
(
    BSTR *pszRetVal
)
{   
    DWORD dwCount = 0;
    CClientInfo *pClientInfo = NULL;
    DWORD dwStatus = S_OK;
    DWORD dwLen = 0;
    INT   iBytesToBeAllocated = 0;
    bool  bIsDomainCopied = false;

    // if (! called_by_an_admin()) 
    // {
    //     return S_FALSE;
    // }

//    DebugBreak();
    if( g_pTelnetService == NULL  || pszRetVal == NULL )
    {
        return S_FALSE;
    }

    if( WaitForSingleObject( g_pTelnetService->m_hSyncAllClientObjAccess,
            WAIT_TIME ) != WAIT_OBJECT_0 )
    {
        return S_FALSE;
    }
    
    DWORD dwSessionsWithData = 0;
    DWORD dwSaveCount = 0;

    dwCount = client_list_Count();   
    dwSaveCount  = dwCount;

    while( dwCount > 0 )
    {
        pClientInfo = (CClientInfo *)client_list_Get( --dwCount );
        if( pClientInfo && pClientInfo->szUserName )
        {
            //Only if szUserName is non null, the object has session data.
            //Otherwise, still in the process of getting that info
            dwSessionsWithData++;
        }
    }    

    //Restore the count
    dwCount  = dwSaveCount;

    g_iSizeOfBuffer     =  MAX_STRING_FROM_itow;
    if( dwSessionsWithData > 0 )
    {
        g_iSizeOfBuffer +=  dwSessionsWithData * SIZE_OF_ONE_SESSION_DATA;
    }

    iBytesToBeAllocated =  g_iSizeOfBuffer * sizeof( WCHAR );
    *pszRetVal = SysAllocStringLen( NULL, iBytesToBeAllocated );

    g_szSessionData = *pszRetVal;

    if( g_szSessionData == NULL )
    {
        dwStatus = ( DWORD )S_FALSE;
        goto ExitOnError;
    }

    WCopyInt( &g_szSessionData, dwSessionsWithData, &g_iSizeOfBuffer );

    //Remove wide null char from g_szSessionData
    g_iSizeOfBuffer += 1;
    g_szSessionData -= 1;
    AddSeparator( &g_szSessionData, session_separator, &g_iSizeOfBuffer );

    while( dwCount > 0 )
    {
        pClientInfo = (CClientInfo *)client_list_Get( --dwCount );

        if( pClientInfo && pClientInfo->szUserName )
        {
            WCopyInt( &g_szSessionData, pClientInfo->dwPid, &g_iSizeOfBuffer );

            bIsDomainCopied = false;
            if( strcmp( pClientInfo->szDomain, "." ) == 0 )
            {
                if( g_pTelnetService->m_szDomainName[0] )
                {
                    WCopyUnicodeString( &g_szSessionData, g_pTelnetService->m_szDomainName, &g_iSizeOfBuffer );
                    bIsDomainCopied = true;
                }
            }

            if( !bIsDomainCopied )
            {
                WCopyMbcsString( &g_szSessionData, pClientInfo->szDomain,           &g_iSizeOfBuffer );
            }

            WCopyMbcsString( &g_szSessionData, pClientInfo->szUserName,         &g_iSizeOfBuffer );
            WCopyMbcsString( &g_szSessionData, pClientInfo->szRemoteMachine,    &g_iSizeOfBuffer );

            WCopyInt( &g_szSessionData, pClientInfo->lpLogonTime->wYear,        &g_iSizeOfBuffer );
            WCopyInt( &g_szSessionData, pClientInfo->lpLogonTime->wMonth,       &g_iSizeOfBuffer );
            WCopyInt( &g_szSessionData, pClientInfo->lpLogonTime->wDayOfWeek,   &g_iSizeOfBuffer );
            WCopyInt( &g_szSessionData, pClientInfo->lpLogonTime->wDay,         &g_iSizeOfBuffer );
            WCopyInt( &g_szSessionData, pClientInfo->lpLogonTime->wHour,        &g_iSizeOfBuffer );
            WCopyInt( &g_szSessionData, pClientInfo->lpLogonTime->wMinute,      &g_iSizeOfBuffer );
            WCopyInt( &g_szSessionData, pClientInfo->lpLogonTime->wSecond,      &g_iSizeOfBuffer );
            WCopyInt( &g_szSessionData, pClientInfo->lpLogonTime->wMilliseconds,&g_iSizeOfBuffer );
            WCopyInt( &g_szSessionData, pClientInfo->m_dwIdleTime/1000,         &g_iSizeOfBuffer );

    #ifdef ENUM_PROCESSES
            //g_szSessionData, g_iSizeOfBuffer needs to be global for following reason
            //This will add the processes to the list                       
            EnumSessionProcesses( *( pClientInfo->pAuthId ), GetTelnetSessionProcesses, TO_ENUM );
    #endif
            //To indicate end of a session: ',' indicates end of a session data
            AddSeparator( &g_szSessionData, session_separator, &g_iSizeOfBuffer );    
        }
    }

ExitOnError:
    _chVERIFY2( ReleaseMutex( g_pTelnetService->m_hSyncAllClientObjAccess ) ); 
    
    return ( dwStatus );
}

STDMETHODIMP 
CEnumTelnetClientsSvr::GetEnumClients
(
    IEnumClients * * ppretval
)
{
     *ppretval = ( IEnumClients* ) this;
     ( *ppretval )->AddRef();

    //Initialize the Telnet Clients list
    if( m_pEnumeration )
        delete m_pEnumeration;
    m_pEnumeration = new CEnumData;
    if( !m_pEnumeration )
    {
        return (S_FALSE);
    }

    if( !EnumClients( m_pEnumeration ) )
        return (S_FALSE);

    return ( S_OK );
}

void
GetSessionProcesses
(
    HANDLE hProc,
    DWORD dwProcessId,
    LPWSTR lpszProcessName
)
{
    g_pEnumData->Add( lUniqueSessionNumber, dwProcessId, lpszProcessName );
    return;
}

bool 
CEnumTelnetClientsSvr::EnumClients
( 
    CEnumData* pEnumData 
)
{
    WCHAR szUserName[ MAX_STRING_LENGTH + 1 ];
    WCHAR szDomain[ MAX_STRING_LENGTH + 1 ];
    WCHAR szPeer[ MAX_STRING_LENGTH + 1 ];

    DWORD dwStatus = 0;
    if( g_pTelnetService == NULL || pEnumData == NULL )
        return false;

    DWORD dwCount = 0;
    CClientInfo *pClientInfo = NULL;

    dwStatus = WaitForSingleObject( 
            g_pTelnetService->m_hSyncAllClientObjAccess, WAIT_TIME );
    if( dwStatus != WAIT_OBJECT_0 )
    {
        return false;
    }

    if( ( dwCount = client_list_Count() ) != 0 )
    {
        while( dwCount > 0 )
        {
            pClientInfo = (CClientInfo *)client_list_Get( --dwCount );
            if( pClientInfo )
            {
                if( !ConvertSChartoWChar( pClientInfo->szUserName, szUserName ) 
                   || !ConvertSChartoWChar( pClientInfo->szDomain, szDomain ) ||
                   !ConvertSChartoWChar( pClientInfo->szRemoteMachine, szPeer ))
                {
                    continue;
                }
                pEnumData->Add( szUserName, szDomain, szPeer, 
                    *( pClientInfo->lpLogonTime ), (LONG) pClientInfo->dwPid );

                //This will add the processes to the list
                LUID authId = *( pClientInfo->pAuthId );
                g_pEnumData = pEnumData;
                lUniqueSessionNumber = pClientInfo->dwPid;
                EnumSessionProcesses( authId, GetSessionProcesses, TO_ENUM );
            }
        }
    }
    _chVERIFY2( ReleaseMutex( g_pTelnetService->m_hSyncAllClientObjAccess ) ); 

    return ( true );
}

STDMETHODIMP 
CEnumTelnetClientsSvr::Next
(
    ULONG celt,  
    TELNET_CLIENT_INFO** rgelt, 
    ULONG * pceltFetched
)
{
    ULONG ulNumReturned = 0;
    if( NULL == pceltFetched )
    {
        if( celt != 1 )
            return ( S_FALSE );
    }
    else
        *pceltFetched = 0;

    if( NULL == rgelt )
        return ( E_POINTER );

    typedef CEnumData::CNode* PNODE;
    PNODE* ppcopy = new PNODE [ celt ];

    if( NULL == ppcopy )
    {
        return ( S_FALSE );
    }

    ULONG total = celt;

    for (celt = 0; celt < total; celt ++)
    {
        ppcopy[celt] = NULL;

        if (m_pEnumeration->GetNext(&ppcopy[celt]))
        {
            ulNumReturned++;
        }
        else
        {
            break;
        }
    }

    celt = 0;

    while( celt < ulNumReturned )
    {
        rgelt[ celt ] = 
            (TELNET_CLIENT_INFO*) CoTaskMemAlloc( sizeof(TELNET_CLIENT_INFO));
        if(! rgelt[ celt ] )
        {
            goto CLEANUP_AND_GET_OUT;
        }
    
        lstrcpyW( (*(rgelt[ celt ])).username, ppcopy[ celt ]->lpszUserName ); // Cleared by Prefast - Baskar
        lstrcpyW( (*(rgelt[ celt ])).domain, ppcopy[ celt ]->lpszDomain );
        lstrcpyW( (*(rgelt[ celt ])).peerhostname, ppcopy[ celt ]->lpszPeerHostName );

        (*(rgelt[ celt ])).logonTime = ppcopy[ celt ]->logonTime;
        (*(rgelt[ celt ])).uniqueId = ppcopy[ celt ]->lUniqueId;

        PIdNode *pPId = ppcopy[ celt ]->pProcessesHead;
        DWORD dwNoOfProcesses = 0;
        while( pPId )
        {
            dwNoOfProcesses++;
            pPId = pPId->pNextPId;
        }
        (*(rgelt[ celt ])).NoOfPids = dwNoOfProcesses;
        (*(rgelt[ celt ])).pId = ( DWORD * ) CoTaskMemAlloc ( sizeof( DWORD ) *
                                                 ( dwNoOfProcesses + 10 ) );

        if( !(*(rgelt[ celt ])).pId )
        {
            goto CLEANUP_AND_GET_OUT;
        }

        (*(rgelt[ celt ])).processName =  (WCHAR(*)[256]) CoTaskMemAlloc ( sizeof(WCHAR) * dwNoOfProcesses * 256);

        if( !(*(rgelt[ celt ])).processName )
        {
            goto CLEANUP_AND_GET_OUT;
        }

        INT ctr = 0;
        pPId = ppcopy[ celt ]->pProcessesHead;
        while( pPId )
        {
            (*(rgelt[ celt ])).pId[ ctr ] = pPId->dwPId;
            lstrcpyW( (*(rgelt[ celt ])).processName[ ctr ], pPId->lpszProcessName ); // Cleared by Prefast - Baskar
            ctr++;
            pPId = pPId->pNextPId;
        }

        (*(rgelt[ celt ])).pId[ ctr ] = ( DWORD )-1; //Indicates end of processes.
    
        celt++;
    }
    {
        ULONG       index;

        for (index = 0; index < total; index ++) 
        {
            if (ppcopy[index]) 
            {
                delete ppcopy[index];
            }
        }

        delete [] ppcopy;
    }

    if( pceltFetched != NULL )
        *pceltFetched = ulNumReturned;

    if( ulNumReturned == 0 )
        return ( S_FALSE );

    return ( S_OK );

    CLEANUP_AND_GET_OUT:

    {
        ULONG       index;

        for (index = 0; index < total; index ++) 
        {
            if (ppcopy[index]) 
            {
                delete ppcopy[index];
            }
        }

        delete [] ppcopy;

        for (index = 0; index < total; index ++) 
        {
            CoTaskMemFree( (*(rgelt[ index ])).pId );
            CoTaskMemFree( (*(rgelt[ index ])).processName );
            CoTaskMemFree( rgelt[ index ] );
        }
    }

    return ( S_FALSE );
}


STDMETHODIMP 
CEnumTelnetClientsSvr::Skip
(
    ULONG celt
)
{
    //return ( S_OK );
    return ( E_NOTIMPL );
}


STDMETHODIMP CEnumTelnetClientsSvr::Reset()
{
    m_pEnumeration->Reset();
    return ( S_OK );
}


STDMETHODIMP CEnumTelnetClientsSvr::Clone(IEnumClients * * ppenum)
{
    //return S_OK;
    return ( E_NOTIMPL );
}


STDMETHODIMP CEnumTelnetClientsSvr::TerminateSession( DWORD dwUniqueId )
{
    if( g_pTelnetService == NULL )
        return S_FALSE;

    LONG  dwRetStatus = S_FALSE;
    DWORD dwCount = 0;
    CClientInfo *pClientInfo = NULL;
    DWORD dwStatus = 0;
    dwStatus = WaitForSingleObject( g_pTelnetService->m_hSyncAllClientObjAccess,
            WAIT_TIME );
    if( dwStatus != WAIT_OBJECT_0 )
    {
        return S_FALSE;
    }
    
    if( ( dwCount = client_list_Count() ) != 0 )
    {
        while( dwCount > 0 )
        {
            pClientInfo = (CClientInfo *)client_list_Get( --dwCount );
            if(pClientInfo == NULL)
            	goto Done;
            if( pClientInfo->dwPid == dwUniqueId )
            {
                if( AskTheSessionToQuit( pClientInfo ) )
                {
                    dwRetStatus = S_OK;
                    goto Done;
                }
            }
        }
    }
Done:
    _chVERIFY2( ReleaseMutex( g_pTelnetService->m_hSyncAllClientObjAccess ) ); 
    return dwRetStatus;
}

bool CEnumTelnetClientsSvr::InformTheSession( CClientInfo *pClientInfo, 
                                                WCHAR szMsg[] ) 
{
    UCHAR *szMsgToSend = NULL;

    DWORD dwLen = 2* ( wcslen( szMsg ) + 1 );
    szMsgToSend = new UCHAR[ IPC_HEADER_SIZE + dwLen ];
    if( !szMsgToSend )
    {
        return false;
    }

    szMsgToSend[0] = OPERATOR_MESSAGE;
    memcpy( szMsgToSend + 1, &dwLen, sizeof( DWORD ) ); // No size info here - Attack ? Baskar
    memcpy( szMsgToSend + IPC_HEADER_SIZE, szMsg, dwLen );

    if( WriteToPipe( pClientInfo->hWritingPipe, (LPVOID) szMsgToSend, 
        IPC_HEADER_SIZE + dwLen, &( g_pTelnetService->m_oWriteToPipe ) ) )
    {
        delete[] szMsgToSend;
        return true;
    }

    delete[] szMsgToSend;
    g_pTelnetService->StopServicingClient( pClientInfo, (BOOL)TRUE );
    return false;
}

STDMETHODIMP CEnumTelnetClientsSvr::SendMsgToASession( DWORD dwUniqueId, BSTR szMsgToBeSent )
{
    if( !SendMsg( dwUniqueId, szMsgToBeSent ) )
    {
        return S_FALSE;
    }

    return S_OK;
}

bool CEnumTelnetClientsSvr::SendMsg( DWORD dwUniqueId, BSTR szMsg )
{
    bool  bRetStatus = false;
    DWORD dwCount = 0;
    CClientInfo *pClientInfo = NULL;
    DWORD dwStatus = 0;

    if( g_pTelnetService == NULL || szMsg == NULL )
    {
        return bRetStatus;
    }
    
    if( SysStringLen( szMsg ) <= 0 )
    {
        return bRetStatus;
    }

    dwStatus = WaitForSingleObject( g_pTelnetService->m_hSyncAllClientObjAccess, WAIT_TIME );
    if( dwStatus != WAIT_OBJECT_0 )
    {
        return bRetStatus;
    }

    if( ( dwCount = client_list_Count() ) != 0 )
    {
        while( dwCount > 0 && !bRetStatus )
        {
            pClientInfo = (CClientInfo *)client_list_Get( --dwCount );
            if(pClientInfo == NULL)
            	goto Done;
            if( pClientInfo->dwPid == dwUniqueId )
            {
                if( InformTheSession( pClientInfo, szMsg ) )
                {
                    bRetStatus = true;
                }
            }
        }
    }
Done:
    _chVERIFY2( ReleaseMutex( g_pTelnetService->m_hSyncAllClientObjAccess ) );
    return bRetStatus;
}

void CEnumTelnetClientsSvr::FinalRelease()
{
    delete m_pEnumeration;
    m_pEnumeration = NULL;
    CComObjectRootEx<CComMultiThreadModel>::FinalRelease();
}

bool CEnumTelnetClientsSvr::AskTheSessionToQuit( CClientInfo *pClientInfo )
{
    bool bRetVal = false;
    BOOL delete_the_class = FALSE;
    DWORD dwRetVal = 0, dwAvail = 0, dwLeft = 0;
    CHAR *szBuffer = NULL;
    if(!PeekNamedPipe(pClientInfo->hReadingPipe,szBuffer,0,&dwRetVal,&dwAvail,&dwLeft))
    {
        dwRetVal = GetLastError();
        if(dwRetVal == ERROR_INVALID_HANDLE)
        {
            delete_the_class = TRUE;
        }
    }
    else if( WriteToPipe( pClientInfo->hWritingPipe, GO_DOWN, 
                            & ( g_pTelnetService->m_oWriteToPipe ) ) )
    {
        bRetVal = true;
    }

    g_pTelnetService->StopServicingClient( pClientInfo, delete_the_class );
    return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsvr\queue.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       queue.h
//
//--------------------------------------------------------------------------

#if !defined( _QUEUE_H_ )
#define _QUEUE_H_
#define SMALL_STRING 64

#include <tchar.h>
#include <cmnhdr.h>
#include <windows.h>
#include <winsock2.h>
#include <TlntUtils.h>
#include <Telnetd.h>

class CQueue;

typedef char IP_ADDR;

typedef struct Q_LIST_ENTRY  {
	struct Q_LIST_ENTRY *pQPrev;
	struct Q_LIST_ENTRY *pQNext;
	IP_ADDR chIPAddr[SMALL_STRING];
	DWORD dwPid;
	HANDLE hWritePipe;
} Q_LIST_ENTRY, *PQ_LIST_ENTRY;

class CQueue
{
	PQ_LIST_ENTRY	m_pHead;
    PQ_LIST_ENTRY	m_pTail;
	CRITICAL_SECTION m_csQModification;

public:

    DWORD   m_dwNumOfUnauthenticatedConnections;
	DWORD   m_dwMaxUnauthenticatedConnections;
	DWORD	m_dwMaxIPLimit;

    // constructor
    CQueue();

    // destructor
    ~CQueue();

	bool IsQFull();
    // Allocates memory for an entry and adds it in the queue.
    bool Push(DWORD dwPid, HANDLE *phWritePipe, IP_ADDR *pchIPAddr);

    // Frees a head entry in the queue.
    bool Pop(HANDLE *phWritePipe);

    // Frees a particular entry in the queue.
    bool FreeEntry(DWORD dwPid);

	//See if allowed to add to the queue.

    bool OkToProceedWithThisClient(IP_ADDR *pchIPAddr);

    //Check whether the client was added to our queue or not

	bool WasTheClientAdded(DWORD dwPid, IP_ADDR *pchIPAddr,  HANDLE *phWritePipe, bool *pbSendMessage);

	//See if per IP limit is reached
	bool IsIPLimitReached(IP_ADDR *pchIPAddr);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsvr\stdafx.cpp ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#pragma warning (disable : 4100)	// unreferenced formal parameter
#pragma warning (disable : 4505)	// unreferenced local function has been removed 
#include <statreg.cpp>
#pragma warning (default: 4100)
#pragma warning (default: 4505)
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsvr\stdafx.h ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__FE9E4899_A014_11D1_855C_00A0C944138C__INCLUDED_)
#define AFX_STDAFX_H__FE9E4899_A014_11D1_855C_00A0C944138C__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define _ATL_APARTMENT_THREADED


#include <cmnhdr.h>
#pragma warning( disable:4127 ) // warning C4127: conditional expression is constant
#include <atlbase.h>
#pragma warning( default:4127 ) // warning C4127: conditional expression is constant

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

class CServiceModule : public CComModule
{
public:
	HRESULT RegisterServer(BOOL bRegTypeLib, BOOL bService);
	HRESULT UnregisterServer();
	void Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID);
    void Start();
	void ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    void Handler(DWORD dwOpcode);
    void Run();
    BOOL IsInstalled();
    BOOL Install(LPWSTR pszAccount, LPWSTR pszPassword);
    BOOL Uninstall();
	LONG Unlock();
    void SetServiceStatus(DWORD dwState);
    void SetupAsLocalServer();

//Implementation
private:
	static void WINAPI _ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    static void WINAPI _Handler(DWORD dwOpcode);

// data members
public:
    TCHAR m_szServiceName[256];
    SERVICE_STATUS_HANDLE m_hServiceStatus;
    SERVICE_STATUS m_status;
	DWORD dwThreadID;
	BOOL m_bService;
    HANDLE m_hEventSource;
};

extern CServiceModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__FE9E4899_A014_11D1_855C_00A0C944138C__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsvr\telnet.h ===
// telnet.h : This file contains the
// Created:  Feb '98
// Author : a-rakeba
// History:
// Copyright (C) 1998 Microsoft Corporation
// All rights reserved.
// Microsoft Confidential 

#if !defined( _TELNET_H_ )
#define _TELNET_H_


//TELNET Command codes
//just to make it obvious the TC_ prefix means Telnet Command
 
#define TC_IAC  (UCHAR)255      // Interpret As Command 
#define TC_DONT (UCHAR)254      // Request NOT To Do Option 
#define TC_DO   (UCHAR)253      // Request To Do Option 
#define TC_WONT (UCHAR)252      // Refusal To Do Option
#define TC_WILL (UCHAR)251      // Desire / Confirm Will Do Option
#define TC_SB   (UCHAR)250      // Start Subnegotiation 

#define TC_GA   (UCHAR)249      // "Go Ahead" Function(you may reverse the line)
                                // The line turn-around signal for half-duplex 
                                // data transfer

#define TC_EL   (UCHAR)248      // Requests that the previous line ( from the
                                // current character back to the last newline )
                                // be erased from the data stream

#define TC_EC   (UCHAR)247      // Requests that the previous character be erased
                                // from the data stream

#define TC_AYT  (UCHAR)246      // "Are You There?" Function
                                // Requests a visible or audible signal that 
                                // the remote side is still operating

#define TC_AO   (UCHAR)245      // Requests that the current user process be
                                // be allowed to run to completion, but that
                                // no more output be sent to the NVT "printer"

#define TC_IP   (UCHAR)244      // Requests that the current user process be 
                                // interrupted permanently 

#define TC_BREAK (UCHAR)243     // NVT character BRK. This code is to provide
                                // a signal outside the ASCII character set to
                                // indicate the Break or Attention signal 
                                // available on many systems

#define TC_DM   (UCHAR)242      // Data Mark ( for Sync ). A Stream 
                                // synchronizing character for use with the
                                // Sync signal

#define TC_NOP  (UCHAR)241      // No Operation
#define TC_SE   (UCHAR)240      // End Of Subnegotiation 


// Telnet Option Codes
// just to make it obvious the TO_ prefix means Telnet Option

#define TO_TXBINARY (UCHAR)0    // TRANSMIT-BINARY option , to use 8-bit binary 
                                // (unencoded) character transmission instead of 
                                // NVT encoding. ( 8-bit data path )

#define TO_ECHO     (UCHAR)1    // Echo Option
#define TO_SGA      (UCHAR)3    // Suppress Go-Ahead Option
#define TO_TERMTYPE (UCHAR)24   // Terminal-Type Option
#define TO_NAWS     (UCHAR)31   // Negotiate About Window Size
#define TO_LFLOW    (UCHAR)33   // remote flow-control

#define TO_NEW_ENVIRON  (UCHAR)39  //NEW_ENVIRON option. RFC 1572
#define TO_ENVIRON      (UCHAR)36  //ENVIRON_OPTION.  RFC 1408
#define VAR             0          //predeined variable
#define VALUE           1          //value of variable
#define ENV_ESC             2          //esacape char
#define USERVAR         3          //any non-rfc-predefined variable
#define IS              0        
#define SEND            1
#define INFO            2


#define TO_AUTH     (UCHAR)37
#define AU_IS    0
#define AU_SEND  1
#define AU_REPLY 2

//Authentication Types
#define AUTH_TYPE_NULL    0
#define AUTH_TYPE_NTLM    15

//Modifiers
#define AUTH_WHO_MASK   1
#define AUTH_CLIENT_TO_SERVER   0

#define AUTH_HOW_MASK   2
#define AUTH_HOW_MUTUAL         2

// sub-suboption commands for NTLM authentication scheme
#define NTLM_AUTH           0
#define NTLM_CHALLENGE      1
#define NTLM_RESPONSE       2       
#define NTLM_ACCEPT         3
#define NTLM_REJECT         4

// Option Subnegotiation Constants
#define TT_IS   0   // TERMINAL-TYPE option "IS" command
#define TT_SEND 1   // TERMINAL-TYPE option "SEND" command


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsvr\telntsrv.h ===
// TelntSrv.h : This file contains the
// Created:  Jan '98
// Author : a-rakeba
// History:
// Copyright (C) 1998 Microsoft Corporation
// All rights reserved.
// Microsoft Confidential

#ifndef _TELNTSRV_H_
#define _TELNTSRV_H_

#include <tchar.h>
#include <winsock2.h>
#ifdef WHISTLER_BUILD
#include <ws2tcpip.h>
#else
#include "ws2tcpip.h"
#endif
#include <IpTypes.h>

#include <TlntDynamicArray.h>
#include <TlntSvr.h>
#include <EnumData.h>
#include <EncliSvr.h>
#include <ClientInfo.h>
#include <Queue.h>


#define WAIT_TIME      5000

DWORD WINAPI  DoIPCWithClients( LPVOID );

typedef struct _FAMILY {
    int       iFamily;
    socklen_t iSocklen;

    SOCKET    sListenSocket;       // the socket that listens for ever
    WSAEVENT  SocketAcceptEvent;
} FAMILY;

#define NUM_FAMILIES 2


class CTelnetService 
{
public:
    virtual ~CTelnetService();

    static  CTelnetService* Instance();

    CQueue *CQList;
    bool    Shutdown( void );
    bool    Pause( void );
    bool    Resume( void );
    void    SystemShutdown( void );
    DWORD   NeedAudit( void );
    
    friend  class CEnumTelnetClientsSvr;
    friend  DWORD WINAPI  DoIPCWithClients( LPVOID );
    bool    ListenerThread( );
private:
    CTelnetService();

    enum{ SOCKET_CLOSE_EVENT = WAIT_OBJECT_0, FD_ACCEPT_EVENT_0, 
        REG_CHANGE_EVENT, FD_ACCEPT_EVENT_1 };
    enum{ SERVER_PAUSED, SERVER_RUNNING };

    bool    Init( void );
    void    InitializeOverlappedStruct( LPOVERLAPPED );
    void    GetPathOfTheExecutable( PCHAR * );
    void    GetPathOfTheExecutable( LPTSTR * );
    PCHAR   GetDefaultLoginScriptFullPath( void );
    bool    GetRegistryValues( void );
    bool    GetLicenseForWorkStation( SOCKET );
    bool    CheckLicense( bool *, CClientInfo * );
    bool    IssueLicense( bool, CClientInfo *);
    bool    StartThreads( void );
    bool    CreateClient( SOCKET , DWORD *, HANDLE *, CClientInfo **);
    bool    SendSocketToClient( HANDLE, SOCKET, DWORD );
    bool    HandleInProcMessages( DWORD );
    bool    IPCDataDriver( CClientInfo* );
    bool    HandleFarEastSpecificRegKeys( void );
    bool    CreateSessionProcess( HANDLE, HANDLE, DWORD*, HANDLE *, HWINSTA *, HDESK * );
    

    bool    ExitTheSession( CClientInfo * );
    bool    AskSessionToShutdown( HANDLE, UCHAR );
    bool    SendSessionIdToClient( HANDLE, LONG );
    bool    InformTheClient( SOCKET, LPSTR );
    bool    StopServicingClient( CClientInfo *, BOOL );
    void    HandleSessionDetailsMessage( CClientInfo * );

    bool    WatchRegistryKeys( void );
    bool    HandleChangeInRegKeys( void );
    bool    SetNewRegKeyValues( DWORD, DWORD, DWORD, LPWSTR, LPWSTR, DWORD );
    bool    RegisterForNotification( void );
    
    bool    GetInAddr( INT, SOCKADDR_STORAGE *, socklen_t * );
    bool    CreateSocket( INT );
    bool    InitTCPIP( void );        

    bool    CreateNewIoCompletionPort( DWORD );
    bool    AssociateDeviceWithCompletionPort ( HANDLE, HANDLE, DWORD_PTR );
    bool    IssueReadFromPipe( CClientInfo* );
    bool    OnCompletionPacket( CClientInfo*, LPOVERLAPPED );
    bool    IssueReadAgain( CClientInfo* );
    
    DWORD   m_dwTelnetPort;
    DWORD   m_dwMaxConnections;
    bool    m_fLogToFile;
    LPWSTR  m_pszIpAddrToListenOn;
    

    static  CTelnetService* s_instance;
    DWORD   m_dwNumOfActiveConnections;
    LONG    m_lServerState;
    WCHAR   m_szDomainName[ MAX_DOMAIN_NAME_LEN + 4 ]; //This may be of form \\solar-dc-01
    bool    m_bIsWorkStation;
    SOCKADDR_STORAGE *m_pssWorkstationList;
    DWORD   m_dwNoOfWorkstations;

    HANDLE  m_hRegChangeEvent;
    HKEY    m_hReadConfigKey;
    HANDLE  m_hSyncAllClientObjAccess;
    FAMILY  m_sFamily[ NUM_FAMILIES ];
    HANDLE  m_hCompletionPort;
    HWINSTA m_hOldWinSta;
    HANDLE  m_hIPCThread;
    
    WSAEVENT m_SocketAcceptEvent;
    HANDLE   m_hSocketCloseEvent;
    
    OVERLAPPED m_oReadFromPipe;
    OVERLAPPED m_oWriteToPipe;
    OVERLAPPED m_oPostedMessage;
};

void LogEvent ( WORD wType, DWORD dwEventID, LPCTSTR pFormat, ... );
void WriteAuditedMsgsToFile( LPSTR );

void   CloseLogFile( LPWSTR *, HANDLE * );
bool   InitializeLogFile( LPWSTR, HANDLE * );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsvr\telntsrv.cpp ===
// TelnSrv.cpp : This file contains the
// Created:  Jan '98
// Author : a-rakeba
// History:
// Copyright (C) 1998 Microsoft Corporation
// All rights reserved.
// Microsoft Confidential

#include <StdAfx.h>

#include <TChar.h>

#include <Debug.h>
#include <MsgFile.h>
#include <RegUtil.h>
#include <TelnetD.h>
#include <TlntUtils.h>
#include <TlntDynamicArray.h>
#include <TelntSrv.h>
#include <Ipc.h>
#include <Resource.h>

#include <wincrypt.h>

#pragma warning( disable: 4706 )

using namespace _Utils;
using CDebugLevel::TRACE_DEBUGGING;
using CDebugLevel::TRACE_HANDLE;
using CDebugLevel::TRACE_SOCKET;

extern TCHAR        g_szMaxConnectionsReached[ MAX_STRING_LENGTH ];
extern HINSTANCE    g_hInstRes;
extern LPWSTR       g_pszTelnetInstallPath;
extern HANDLE       *g_phLogFile;
extern LPWSTR       g_pszLogFile;
extern LONG         g_lMaxFileSize;
extern bool         g_fLogToFile;
extern HANDLE       g_hSyncCloseHandle;
extern CTelnetService* g_pTelnetService;
extern HCRYPTPROV      g_hProv;

#define WINSTA_ALL (WINSTA_ACCESSCLIPBOARD  | WINSTA_ACCESSGLOBALATOMS | \
   WINSTA_CREATEDESKTOP    | WINSTA_ENUMDESKTOPS      | \
   WINSTA_ENUMERATE        | WINSTA_EXITWINDOWS       | \
   WINSTA_READATTRIBUTES   | WINSTA_READSCREEN        | \
   WINSTA_WRITEATTRIBUTES  | DELETE                   | \
   READ_CONTROL            | WRITE_DAC                | \
   WRITE_OWNER)


bool SetWinstaSecurity()
{
    bool                    bStatus = FALSE;
    BOOL                    bRetVal = FALSE;
    DWORD                   dwErrCode = 0;
    PSID                    pSidAdministrators = NULL, pSidLocalSystem = NULL, pSidLocalService = NULL, pSidNetworkService = NULL, pSidTelnetClients = NULL;
    PACL                    newACL = NULL;
    SECURITY_DESCRIPTOR     sd = { 0 };
    HWINSTA                 window_station = NULL;
    SECURITY_ATTRIBUTES     sa = { 0 };
    SECURITY_INFORMATION    sec_i = DACL_SECURITY_INFORMATION;
    DWORD   aclSize;
    SID_IDENTIFIER_AUTHORITY local_system_authority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY worldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    ACCESS_ALLOWED_ACE      *pace = NULL;


    //Build administrators alias sid
    if (! AllocateAndInitializeSid(
                                  &local_system_authority,
                                  2, /* there are only two sub-authorities */
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0,0,0,0,0,0, /* Don't care about the rest */
                                  &pSidAdministrators
                                  ))
    {
        goto ExitOnError;
    }

    //Build LocalSystem sid
    if (! AllocateAndInitializeSid(
                                  &local_system_authority,
                                  1, /* there is only one sub-authority */
                                  SECURITY_LOCAL_SYSTEM_RID,
                                  0,0,0,0,0,0,0, /* Don't care about the rest */
                                  &pSidLocalSystem
                                  ))
    {
        goto ExitOnError;
    }
#ifndef SECURITY_LOCAL_SERVICE_RID

#define SECURITY_LOCAL_SERVICE_RID      (0x00000013L)
#define SECURITY_NETWORK_SERVICE_RID    (0x00000014L)

#endif

    //Build LocalLocal sid
    if ( ! AllocateAndInitializeSid(
                                   &local_system_authority,
                                   1, /* there is only one sub-authority */
                                   SECURITY_LOCAL_SERVICE_RID,
                                   0,0,0,0,0,0,0, /* Don't care about the rest */
                                   &pSidLocalService
                                   ) )
    {
        goto ExitOnError;
    }
/*
    //Build LocalSystem sid
    if ( ! AllocateAndInitializeSid(
                                   &local_system_authority,
                                   1, /* there is only one sub-authority /
                                   SECURITY_NETWORK_SERVICE_RID,
                                   0,0,0,0,0,0,0, /* Don't care about the rest /
                                   &pSidNetworkService
                                   ) )
    {
        goto ExitOnError;
    }
*/
    {
        DWORD needed_length   = 0;
        DWORD dwErr     = 0, dwDomainLen = 0;
        SID_NAME_USE    sidNameUse;
        TCHAR           szDomain[ MAX_PATH + 1 ];
        BOOL        success = FALSE;
        TCHAR           szComputerName[MAX_COMPUTERNAME_LENGTH + 1 + 14] = { 0 }; //+14 for '\TelnetClients'
        DWORD           dwNameLen = MAX_COMPUTERNAME_LENGTH + 1;
        success = GetComputerName(szComputerName, &dwNameLen);
        if(success)
        {
            _sntprintf(szComputerName+dwNameLen,(MAX_COMPUTERNAME_LENGTH + 14) - dwNameLen,_T("\\%s"),TELNETCLIENTS_GROUP_NAME);
        }
        LookupAccountName( NULL, szComputerName, pSidTelnetClients, &needed_length, 
                           szDomain, &dwDomainLen, &sidNameUse );
        pSidTelnetClients  = ( PSID ) new UCHAR[ needed_length ];

        //Even if if allocation fails just go ahead.
        success = LookupAccountName( NULL, szComputerName, pSidTelnetClients, &needed_length, 
                           szDomain, &dwDomainLen, &sidNameUse );
        if( !success ) 
        {
            if (pSidTelnetClients) 
            {
                delete pSidTelnetClients;
                pSidTelnetClients = NULL;
            }
        }

        
    }
    if(pSidTelnetClients == NULL)
    {    //Allocate size for 4 ACEs.
        aclSize = sizeof(ACL) + 
                (3* sizeof(ACCESS_ALLOWED_ACE)) + 
                GetLengthSid(pSidAdministrators) + 
                GetLengthSid(pSidLocalSystem) + 
                GetLengthSid(pSidLocalService) + 
                //GetLengthSid(pSidNetworkService) -
                (3*sizeof(DWORD));
    }
    else
    {   //Allocate size for 5 ACEs. TelnetClients group is present and we should provide access to 
        //members of telnetclients group
        aclSize = sizeof(ACL) +
                (4* sizeof(ACCESS_ALLOWED_ACE)) + 
                GetLengthSid(pSidAdministrators) + 
                GetLengthSid(pSidLocalSystem) + 
                GetLengthSid(pSidLocalService) + 
                //GetLengthSid(pSidNetworkService) +
                GetLengthSid(pSidTelnetClients) -
                (4*sizeof(DWORD));
    }
    newACL  = (PACL) new BYTE[aclSize];
    if (newACL == NULL)
    {
        goto ExitOnError;
    }


    if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
    {
        goto ExitOnError;
    }
    if(pSidTelnetClients != NULL)
    {
        pace = (ACCESS_ALLOWED_ACE *)HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pSidTelnetClients) -sizeof(DWORD));
        if (pace == NULL)
    	{
    		goto ExitOnError;
    	}
        pace->Header.AceType  = ACCESS_ALLOWED_ACE_TYPE;
        pace->Header.AceFlags = CONTAINER_INHERIT_ACE |
                                 OBJECT_INHERIT_ACE;
        pace->Header.AceSize  = sizeof(ACCESS_ALLOWED_ACE) +
                             (WORD)GetLengthSid(pSidTelnetClients) - sizeof(DWORD);
        pace->Mask            = WINSTA_ALL & 
                                    ~(WRITE_DAC | 
                                    WRITE_OWNER | 
                                    WINSTA_CREATEDESKTOP | 
                                    DELETE);
        if (!CopySid(GetLengthSid(pSidTelnetClients), &pace->SidStart, pSidTelnetClients))
    	{
    		goto ExitOnError;
    	}
        if (!AddAce(newACL,ACL_REVISION,MAXDWORD,(LPVOID)pace,pace->Header.AceSize))
        {
    		goto ExitOnError;
    	}
    }
    if (!AddAccessAllowedAce(newACL, ACL_REVISION, GENERIC_ALL , pSidAdministrators))
    {
        goto ExitOnError;
    }
    if (!AddAccessAllowedAce(newACL, ACL_REVISION, GENERIC_ALL, pSidLocalSystem))
    {
        goto ExitOnError;
    }
    if (!AddAccessAllowedAce(newACL, ACL_REVISION, GENERIC_ALL , pSidLocalService))
    {
        goto ExitOnError;
    }
/*
    if (!AddAccessAllowedAce(newACL, ACL_REVISION, GENERIC_ALL , pSidNetworkService))
    {
        goto ExitOnError;
    }
*/
    if ( !InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION ) )
    {
        goto ExitOnError;
    }

    if ( !SetSecurityDescriptorDacl(&sd, TRUE, newACL, FALSE) )
    {
        goto ExitOnError;
    }

    window_station = GetProcessWindowStation(); // Will this always have WRITE_DAC, we're the owner

    if (NULL == window_station)
    {
        goto ExitOnError;
    }

    if (! SetUserObjectSecurity(window_station, &sec_i, &sd))
    {
        goto ExitOnError;
    }


    bStatus = TRUE;
    goto Done;

ExitOnError:

    dwErrCode = GetLastError();
    _TRACE(TRACE_DEBUGGING,L"Creation and setting of windowstation/desktop failed with %d",dwErrCode);
    LogFormattedGetLastError(EVENTLOG_ERROR_TYPE, TELNET_MSG_ERROR_CREATE_DESKTOP_FAILURE, dwErrCode);

Done:
    if (window_station)
    {
        CloseWindowStation(window_station);
    }

    if ( pSidAdministrators != NULL )
    {
        FreeSid (pSidAdministrators );
    }
    if ( pSidLocalSystem!= NULL )
    {
        FreeSid (pSidLocalSystem);
    }
    if ( pSidLocalService!= NULL )
    {
        FreeSid (pSidLocalService);
    }
    if ( pSidNetworkService!= NULL )
    {
        FreeSid (pSidNetworkService);
    }
    if(pace)
        HeapFree(GetProcessHeap(), 0, (LPVOID)pace);
    if (pSidTelnetClients) 
    {
        delete pSidTelnetClients;
        pSidTelnetClients = NULL;
    }
    
    if (newACL)
        delete [] newACL;

    return( bStatus );
}

CTelnetService* CTelnetService::s_instance = NULL;

CTelnetService* 
CTelnetService::Instance()
{
    if ( s_instance == NULL )
    {
        s_instance = new CTelnetService();
        _chASSERT( s_instance != NULL );
    }

    return( s_instance );
}

void
CTelnetService::InitializeOverlappedStruct( LPOVERLAPPED poObject )
{
    _chASSERT( poObject != NULL );
    if ( !poObject )
    {
        return;
    }

    poObject->Internal = 0;
    poObject->InternalHigh = 0;
    poObject->Offset = 0;
    poObject->OffsetHigh = 0;
    poObject->hEvent = NULL;
    return;
}

CTelnetService::CTelnetService()
{
    m_dwTelnetPort = DEFAULT_TELNET_PORT;
    m_dwMaxConnections = 0;
    m_pszIpAddrToListenOn = NULL;
    m_hReadConfigKey = NULL;

    m_dwNumOfActiveConnections = 0;
    m_lServerState           = SERVER_RUNNING;

    SfuZeroMemory(m_sFamily, sizeof(m_sFamily));
    m_sFamily[IPV4_FAMILY].iFamily = AF_INET;
    m_sFamily[IPV4_FAMILY].iSocklen = sizeof(SOCKADDR_IN);
    m_sFamily[IPV4_FAMILY].sListenSocket = INVALID_SOCKET;
    m_sFamily[IPV6_FAMILY].iFamily = AF_INET6;
    m_sFamily[IPV6_FAMILY].iSocklen = sizeof(SOCKADDR_IN6);
    m_sFamily[IPV6_FAMILY].sListenSocket = INVALID_SOCKET;
    m_hCompletionPort = INVALID_HANDLE_VALUE;
    m_hIPCThread = NULL;

    InitializeOverlappedStruct( &m_oReadFromPipe );
    InitializeOverlappedStruct( &m_oWriteToPipe );
    InitializeOverlappedStruct( &m_oPostedMessage );

    client_list_mutex = TnCreateMutex(NULL, FALSE, NULL);
    CQList = new CQueue;
    _chASSERT( client_list_mutex );

    _chVERIFY2( m_hSyncAllClientObjAccess = TnCreateMutex( NULL, FALSE, NULL ) );
    // DebugBreak();
    _chVERIFY2( m_hSocketCloseEvent = CreateEvent( NULL, TRUE, FALSE, NULL ) );
    _chVERIFY2( m_hRegChangeEvent = CreateEvent( NULL, TRUE, FALSE, NULL ) );
    _chVERIFY2( g_hSyncCloseHandle = TnCreateMutex(NULL,FALSE,NULL));

    m_bIsWorkStation = false;;
    m_pssWorkstationList = NULL;
    m_dwNoOfWorkstations = 0;
}

CTelnetService::~CTelnetService()
{
    delete[] m_pszIpAddrToListenOn;
    delete[] m_pssWorkstationList; 
    TELNET_CLOSE_HANDLE(g_hSyncCloseHandle);
    TELNET_CLOSE_HANDLE(client_list_mutex);

    //All the cleanup is happening in Shutdown() 
}

bool
CTelnetService::WatchRegistryKeys()
{
    DWORD dwStatus = 0;
    DWORD dwDisp = 0;
    if ( dwStatus = TnSecureRegCreateKeyEx( HKEY_LOCAL_MACHINE, READ_CONFIG_KEY, NULL, NULL, 
                        REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED , NULL,
                                  &m_hReadConfigKey, &dwDisp, 0 ) )
    {
        return( FALSE );
    }
    if ( !RegisterForNotification() )
    {
        return( FALSE );
    }
    return( TRUE );
}

bool
CTelnetService::RegisterForNotification()
{
    DWORD dwStatus = 0;
    if ( dwStatus = RegNotifyChangeKeyValue( m_hReadConfigKey, TRUE, 
                                             REG_NOTIFY_CHANGE_LAST_SET|REG_NOTIFY_CHANGE_NAME, 
                                             m_hRegChangeEvent, TRUE ) != ERROR_SUCCESS )
    {
        LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, MSG_ERR_REGNOTIFY, dwStatus );
        return( FALSE );
    }
    return( TRUE );
}

bool 
CTelnetService::Init( void )  
{
    if ( !m_hSyncAllClientObjAccess || !m_hSocketCloseEvent || !m_hRegChangeEvent )
    {
        return( FALSE);
    }

    if ( !GetRegistryValues() )
    {
        return( FALSE );
    }

    if ( !WatchRegistryKeys() )
    {
        return( FALSE );
    }

    if ( !InitTCPIP() )
    {
        return( FALSE );
    }

    if( !SetWinstaSecurity())
    {
        return ( FALSE );
    }

    m_szDomainName[0] = L'\0';
    if ( !GetDomainHostedByThisMc( m_szDomainName ) )
    {
        m_szDomainName[0] = 0;
    }

    LPWSTR szProductType = NULL;    
    if ( !GetProductType( &szProductType ) )
    {
        return( FALSE);
    }

    m_bIsWorkStation = ( _wcsicmp(szProductType, TEXT("WinNT")) == 0 );
    delete[] szProductType;

    if ( m_bIsWorkStation )
    {
        m_pssWorkstationList = new SOCKADDR_STORAGE[ DEFAULT_LICENSES_FOR_NTWKSTA ];
        if ( !m_pssWorkstationList )
        {
            return( FALSE);
        }
    }

    return( TRUE );
}


bool 
CTelnetService::Pause( void )
{

    InterlockedExchange( &m_lServerState, SERVER_PAUSED );
    return( TRUE );
}

bool 
CTelnetService::Resume( void )
{
    InterlockedExchange( &m_lServerState, SERVER_RUNNING );
    return( TRUE );
}

void
CTelnetService::SystemShutdown( void )
{
    //We have just 20 secs left to finish this routine
    if(m_hCompletionPort && m_hCompletionPort != INVALID_HANDLE_VALUE)
        PostQueuedCompletionStatus( m_hCompletionPort, 0, TLNTSVR_SHUTDOWN, 
                                  &m_oPostedMessage ); //This should lead to IPC thread exit if
                                                     //it is present.

    if (TlntSynchronizeOn(m_hSyncAllClientObjAccess))
    {
        DWORD dwCount = client_list_Count();

        while ( dwCount-- > 0 )
        {
            CClientInfo *pClient = (CClientInfo *)client_list_Get( dwCount );
            if ( pClient )
            {
                WriteToPipe( pClient->hWritingPipe, SYSTEM_SHUTDOWN, 
                             &( m_oWriteToPipe ) );
            }
        }

        ReleaseMutex( m_hSyncAllClientObjAccess );
    }

    return;
}

bool
CTelnetService::AskSessionToShutdown( HANDLE hWritingPipe, UCHAR ucMsgType )
{
    if ( !WriteToPipe( hWritingPipe, ucMsgType, &( m_oWriteToPipe ) ) )
    {
        return( FALSE );
    }
    return( TRUE );
}

bool 
CTelnetService::Shutdown( void )
{
    shutdown( m_sFamily[IPV4_FAMILY].sListenSocket, SD_BOTH );  //NO more data on socket
    shutdown( m_sFamily[IPV6_FAMILY].sListenSocket, SD_BOTH );  //NO more data on socket
    if(m_hCompletionPort && m_hCompletionPort != INVALID_HANDLE_VALUE)
	    PostQueuedCompletionStatus( m_hCompletionPort, 0, TLNTSVR_SHUTDOWN, 
       	                         &m_oPostedMessage );
    if (TlntSynchronizeOn(m_hSyncAllClientObjAccess))
    {
        _Module.SetServiceStatus( SERVICE_STOP_PENDING );

        while ( client_list_Count() > 0 )
        {
            CClientInfo *pClient = (CClientInfo *)client_list_Get( 0 );
            if ( !pClient )
            {
                break;
            }
            AskSessionToShutdown( pClient->hWritingPipe, TLNTSVR_SHUTDOWN );
            StopServicingClient( pClient, (BOOL)TRUE );
        }
        ReleaseMutex( m_hSyncAllClientObjAccess );
    }

    _Module.SetServiceStatus( SERVICE_STOP_PENDING );
    TELNET_SYNC_CLOSE_HANDLE( m_hSyncAllClientObjAccess );

    if ((NULL != m_hIPCThread) && (INVALID_HANDLE_VALUE != m_hIPCThread))
    {
        // WaitForSingleObject(m_hIPCThread, INFINITE);
        TerminateThread(m_hIPCThread, 0);
        TELNET_CLOSE_HANDLE( m_hIPCThread );
    }
    SetEvent( m_hSocketCloseEvent );//This should lead to listener thread exit 

    return( TRUE );
}

bool
CTelnetService::GetInAddr( INT iFamIdx, SOCKADDR_STORAGE *ssS_addr, socklen_t *iSslen )
{
    bool bContinue = false;
    if ( wcscmp( m_pszIpAddrToListenOn, DEFAULT_IP_ADDR ) == 0 )
    {
        // Bind to "any"
        _TRACE(TRACE_DEBUGGING,"Into GetInAddr, bind to ANY");
        *iSslen = m_sFamily[iFamIdx].iSocklen;
        SfuZeroMemory(ssS_addr, *iSslen);
        ssS_addr->ss_family = (short)m_sFamily[iFamIdx].iFamily;
        bContinue = true;
    }
    else
    {
        DWORD dwSize = 0, dwResult;
        PCHAR  szIpAddr = NULL;

        struct addrinfo *ai, hints;

        dwSize = WideCharToMultiByte( GetOEMCP(), 0, m_pszIpAddrToListenOn, -1, NULL, 0, NULL, NULL );
        _TRACE(TRACE_DEBUGGING,L"m_pszIpAddr : %s",m_pszIpAddrToListenOn);
        szIpAddr = new CHAR[ dwSize ];
        if ( !szIpAddr )
        {
            return FALSE;
        }

        WideCharToMultiByte( GetOEMCP(), 0, m_pszIpAddrToListenOn, -1, szIpAddr, dwSize, NULL, NULL );
        _TRACE(TRACE_DEBUGGING,"szIpAddr : %s",szIpAddr);
        SfuZeroMemory(&hints, sizeof(hints));
        hints.ai_flags = AI_NUMERICHOST;
        dwResult = getaddrinfo(szIpAddr, NULL, &hints, &ai);
        if ( dwResult != NO_ERROR )
        {
            //Log error 
            LogEvent( EVENTLOG_ERROR_TYPE, MSG_FAILEDTO_BIND, m_pszIpAddrToListenOn );
            _TRACE(TRACE_DEBUGGING,"getaddrinfo failed : %d ",dwResult);
            delete[] szIpAddr;
            return FALSE;
        }
        else
        {
            switch ( ai->ai_family)
            {
                case AF_INET:
                    if (iFamIdx == IPV4_FAMILY)
                    {
                        _TRACE(TRACE_DEBUGGING,"IPV4 family and IPV4 address");
                        bContinue = true;
                    }
                    else
                    {
                        _TRACE(TRACE_DEBUGGING,"IPV4 family and IPV6 address...continue");
                        SetLastError(ERROR_SUCCESS);
                    }
                    break;
                case AF_INET6:
                    if (iFamIdx == IPV6_FAMILY)
                    {
                        _TRACE(TRACE_DEBUGGING,"IPV6 family and IPV6 address");
                        bContinue = true;
                    }
                    else
                    {
                        _TRACE(TRACE_DEBUGGING,"IPV6 family and IPV4 address...continue");
                        SetLastError(ERROR_SUCCESS);
                    }
                    break;
                default:
                    _TRACE(TRACE_DEBUGGING,"none of the two ??");
                    break;
            }
            if (bContinue)
            {
                *iSslen = ai->ai_addrlen;
                CopyMemory(ssS_addr, ai->ai_addr, ai->ai_addrlen);
            }
        }
        delete[] szIpAddr;
    }
    return( bContinue ? TRUE : FALSE );
}

bool
CTelnetService::CreateSocket( INT iFamIdx )
{
    INT     iSize = 1, iSslen;
    DWORD dwCode = 0;
    struct sockaddr_storage ss;

    _chVERIFY2( SetHandleInformation( ( HANDLE ) m_sFamily[iFamIdx].SocketAcceptEvent, 
                                      HANDLE_FLAG_INHERIT, 0 ) ); 
    _TRACE(TRACE_DEBUGGING,"Into CreateSocket");

    if ( !GetInAddr(iFamIdx, &ss, &iSslen ) )
    {
        _TRACE(TRACE_DEBUGGING,"GetInAddr failed");
        goto ExitOnError;
    }

    SS_PORT(&ss) = htons( ( u_short ) m_dwTelnetPort );

    m_sFamily[iFamIdx].sListenSocket = socket( m_sFamily[iFamIdx].iFamily, SOCK_STREAM, 0 );
    if ( INVALID_SOCKET == m_sFamily[iFamIdx].sListenSocket )
    {
        _TRACE(TRACE_DEBUGGING,"socket failed");
        goto ExitOnError;
    }

    {
        BOOL        value_to_set = TRUE;

        if (SOCKET_ERROR == setsockopt(
                                      m_sFamily[iFamIdx].sListenSocket, 
                                      SOL_SOCKET, 
                                      SO_DONTLINGER, 
                                      ( char * )&value_to_set, 
                                      sizeof( value_to_set )
                                      )
           )
        {
            goto CloseAndExitOnError;
        }
        if(SOCKET_ERROR == SafeSetSocketOptions(m_sFamily[iFamIdx].sListenSocket))
        {
            goto CloseAndExitOnError;
        }
    }
    _TRACE(TRACE_DEBUGGING,"Scope id is : %ul",((sockaddr_in6 *)&ss)->sin6_scope_id);
    if ( bind( m_sFamily[iFamIdx].sListenSocket, ( struct sockaddr * ) &ss, iSslen ) == SOCKET_ERROR )
    {
        _TRACE(TRACE_DEBUGGING,"bind failed");
        goto CloseAndExitOnError;
    }

    if ( listen( m_sFamily[iFamIdx].sListenSocket, SOMAXCONN ) == SOCKET_ERROR )
    {
        _TRACE(TRACE_DEBUGGING,"listen failed");
        goto CloseAndExitOnError;
    }

//We are making it non-inheritable here
    _chVERIFY2( SetHandleInformation( ( HANDLE ) m_sFamily[iFamIdx].sListenSocket, 
                                      HANDLE_FLAG_INHERIT, 0 ) ); 

    if ( ( WSAEventSelect( m_sFamily[iFamIdx].sListenSocket, m_sFamily[iFamIdx].SocketAcceptEvent, FD_ACCEPT ) 
           == SOCKET_ERROR  ) )
    {
        _TRACE(TRACE_DEBUGGING,"eventselect failed");
        goto CloseAndExitOnError;
    }

    return( TRUE );

    CloseAndExitOnError:
    _TRACE(TRACE_DEBUGGING,"closing listen socket");
    closesocket( m_sFamily[iFamIdx].sListenSocket );
    m_sFamily[iFamIdx].sListenSocket = INVALID_SOCKET;
    ExitOnError:
    dwCode = WSAGetLastError();
    if (dwCode != ERROR_SUCCESS )
    {
        _TRACE(TRACE_DEBUGGING,L"Error in CreateSocket : %d ",dwCode);
        DecodeWSAErrorCodes( dwCode , m_dwTelnetPort );
    }
    return( FALSE );
}

bool 
CTelnetService::InitTCPIP( void )
{
    WSADATA WSAData;
    DWORD   dwStatus;
    WORD    wVersionReqd;
    bool    bOkay4 = false, bOkay6 = false;

    DWORD dwSize = 0, dwResult;
    PCHAR  szIpAddr = NULL;
    struct addrinfo *ai, hints;
    char buff[MAX_STRING_LENGTH];

    wVersionReqd = MAKEWORD( 2, 0 );
    dwStatus = WSAStartup( wVersionReqd, &WSAData );
    if ( dwStatus )
    {
        DecodeSocketStartupErrorCodes( dwStatus ); //It does tracing and loggin
        return FALSE;
    }

    if ( ( m_sFamily[IPV4_FAMILY].SocketAcceptEvent = WSACreateEvent() ) == WSA_INVALID_EVENT )
    {
        goto ExitOnError;
    }

    if ( ( m_sFamily[IPV6_FAMILY].SocketAcceptEvent = WSACreateEvent() ) == WSA_INVALID_EVENT )
    {
        goto ExitOnError;
    }

    SfuZeroMemory(&hints, sizeof(hints));
    hints.ai_flags = AI_PASSIVE;
    _ltoa(m_dwTelnetPort,buff,10);
    dwResult = getaddrinfo(NULL,buff , &hints, &ai);
    if (dwResult)
    {
        _TRACE(TRACE_DEBUGGING,L"Error in getaddrinfo() : %d",dwResult);
        goto ExitOnError;
    }
    while (ai)
    {
        switch (ai->ai_family)
        {
            case AF_INET:
                if (!bOkay4)
                {
                    bOkay4 = CreateSocket(IPV4_FAMILY);
                    _TRACE(TRACE_DEBUGGING,L"Creating IPV4 socket. bOkay4 = %d ",(int)bOkay4);
                }
                break;
            case AF_INET6:
                if (!bOkay6)
                {
                    bOkay6 = CreateSocket(IPV6_FAMILY);
                    _TRACE(TRACE_DEBUGGING,L"Creating IPV6 socketb. bOkay6 = %d ",(int)bOkay6);
                }
                break;
            default:
                _TRACE(TRACE_DEBUGGING,L"Error : Returned none of the families");
                break;
        }
        ai= ai->ai_next;
    }
    if ( !bOkay4 && !bOkay6 )
    {
        return( FALSE );
    }

    return( TRUE );

    ExitOnError:
    DecodeWSAErrorCodes( WSAGetLastError() );
    return( FALSE );
}


bool 
CTelnetService::CreateNewIoCompletionPort( DWORD cSimultaneousClients )
{
    _chVERIFY2( m_hCompletionPort = CreateIoCompletionPort(
                                                          INVALID_HANDLE_VALUE, NULL, 1, cSimultaneousClients ) );
    return( m_hCompletionPort != NULL );
}

bool 
CTelnetService::AssociateDeviceWithCompletionPort ( HANDLE hCompPort, 
                                                    HANDLE hDevice, 
                                                    DWORD_PTR dwCompKey 
                                                  )
{

    _chASSERT( hCompPort != NULL );
    _chASSERT( hDevice != NULL );
    if ( ( hCompPort == NULL ) || ( hDevice == NULL ) )
    {
        return FALSE;
    }

    HANDLE h = NULL;
    _chVERIFY2( h = CreateIoCompletionPort( hDevice, hCompPort, dwCompKey, 1 ));

    if ( h != hCompPort)
    {
        DWORD dwErr = GetLastError();
        _TRACE( TRACE_DEBUGGING, "AssociateDeviceWithCompletionPort() -- 0x%1x",  dwErr );
        LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, MSG_FAILASSOCIATEPORT,  dwErr );
    }

    return( h == hCompPort );
}

bool 
CTelnetService::StartThreads( void ) 
{
    DWORD dwThreadId;

    if ( !CreateNewIoCompletionPort( 1 ) )
    {
        return( FALSE );
    }

    // if( m_hIPCThread != NULL )
    // {
    //     TELNET_SYNC_CLOSE_HANDLE( m_hIPCThread );
    //     m_hIPCThread = NULL;
    // }

    _chVERIFY2( m_hIPCThread = CreateThread( NULL, 0, DoIPCWithClients, ( LPVOID ) g_pTelnetService, 0, &dwThreadId ) );
    if ( !m_hIPCThread  )
    {
        return( FALSE );
    }

    return( TRUE );
}

bool 
CTelnetService::GetRegistryValues( void )
{
    HKEY hk = NULL;
    DWORD dwDisp = 0;

    if ( TnSecureRegCreateKeyEx( HKEY_LOCAL_MACHINE, REG_PARAMS_KEY, NULL, NULL, 
                        REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED , NULL, &hk, &dwDisp, 0 ) )
    {
        return( FALSE );
    }

    if ( !GetRegistryDW( hk, NULL, L"MaxConnections", &m_dwMaxConnections,
                         DEFAULT_MAX_CONNECTIONS,FALSE ) )
    {
        return( FALSE );
    }
    else
    {
        CQList->m_dwMaxUnauthenticatedConnections = m_dwMaxConnections;
    }

    if ( !GetRegistryDW( hk, NULL, L"TelnetPort", &m_dwTelnetPort,
                         DEFAULT_TELNET_PORT,FALSE ) )
    {
        return( FALSE );
    }

    if ( !GetRegistryString( hk, NULL, L"ListenToSpecificIpAddr", &m_pszIpAddrToListenOn, 
                             DEFAULT_IP_ADDR,FALSE ) )
    {
        return( FALSE );
    }

    RegCloseKey( hk );
    return( TRUE );
}

bool
CTelnetService::HandleChangeInRegKeys( )
{
    HKEY hk = NULL;
    DWORD dwNewTelnetPort = 0;
    DWORD dwNewMaxConnections = 0;
    DWORD dwMaxFileSize = 0;
    DWORD dwLogToFile = 0;
    LPWSTR pszNewLogFile = NULL;
    LPWSTR pszNewIpAddr  = NULL;
    DWORD dwDisp = 0;

    if ( TnSecureRegCreateKeyEx( HKEY_LOCAL_MACHINE, REG_PARAMS_KEY, NULL, NULL, 
                        REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED , NULL, &hk, &dwDisp, 0 ) )
    {
        return( FALSE );
    }

    if ( !GetRegistryDW( hk, NULL, L"TelnetPort", &dwNewTelnetPort,
                         DEFAULT_TELNET_PORT,FALSE ) )
    {
        return( FALSE );
    }

    if ( !GetRegistryDW( hk, NULL, L"MaxConnections", &dwNewMaxConnections,
                         DEFAULT_MAX_CONNECTIONS,FALSE ) )
    {
        return( FALSE );
    }


    if ( !GetRegistryDW( hk, NULL, LOGFILESIZE, &dwMaxFileSize, DEFAULT_LOGFILESIZE,FALSE ) )
    {
        return( FALSE );
    }

    if ( !GetRegistryDW( hk, NULL, L"LogToFile", &dwLogToFile, DEFAULT_LOGTOFILE,FALSE ) )
    {
        return( FALSE );
    }

    if ( !GetRegistryString( hk, NULL, L"LogFile", &pszNewLogFile, DEFAULT_LOGFILE,FALSE ) )
    {
        return( FALSE );
    }

    if ( !GetRegistryString( hk, NULL, L"ListenToSpecificIpAddr", &pszNewIpAddr, 
                             DEFAULT_IP_ADDR,FALSE ) )
    {
        return( FALSE );
    }

    SetNewRegKeyValues( dwNewTelnetPort, dwNewMaxConnections, 
                        dwMaxFileSize, pszNewLogFile, pszNewIpAddr, dwLogToFile );

    RegCloseKey( hk );
    return( TRUE );
}

//------------------------------------------------------------------------------
//this is the thread which waits on the telnet port for any new connections
//and also for any change in the reg keys
//------------------------------------------------------------------------------

bool
CTelnetService::ListenerThread( )
{
    BOOL           bContinue = true;
    HANDLE         eventArray[ 4 ];
    DWORD          dwWaitRet = 0;
    SOCKET         sSocket = INVALID_SOCKET;
    INT             iFamIdx =IPV4_FAMILY;

    //DebugBreak();
    /*++                                    
    MSRC issue 567.
    To generate random numbers, use Crypt...() functions. Acquire a crypt context at the beginning of 
    ListenerThread and release the context at the end of the thread. If acquiring the context fails,
    the service fails to start since we do not want to continue with weak pipe names.
    initialize the random number generator
    --*/
    if (!CryptAcquireContext(&g_hProv,NULL,NULL,PROV_RSA_FULL,CRYPT_VERIFYCONTEXT))
    {
        _TRACE(TRACE_DEBUGGING,L"Acquiring crypt context failed with error %d",GetLastError());
        return FALSE;
    }

    if ( !Init() )
    {
        LogEvent( EVENTLOG_ERROR_TYPE, MSG_FAILEDTOINITIALIZE, _T("") );
        return FALSE;
    }
    // BaskarK: Set the error mode for this process to "do not disturb" so that all our children will inherit and will
    //          not stop the stresss, dead on its tracks...

    SetErrorMode(
                SEM_FAILCRITICALERRORS     |
                SEM_NOGPFAULTERRORBOX      |         
                SEM_NOALIGNMENTFAULTEXCEPT |         
                SEM_NOOPENFILEERRORBOX);

    eventArray[ SOCKET_CLOSE_EVENT ] = g_pTelnetService->m_hSocketCloseEvent;
    eventArray[ FD_ACCEPT_EVENT_0 ]  = g_pTelnetService->m_sFamily[IPV4_FAMILY].SocketAcceptEvent;
    eventArray[ REG_CHANGE_EVENT ]   = g_pTelnetService->m_hRegChangeEvent;
    eventArray[ FD_ACCEPT_EVENT_1 ]  = g_pTelnetService->m_sFamily[IPV6_FAMILY].SocketAcceptEvent;

    _Module.SetServiceStatus(SERVICE_RUNNING);
    _TRACE( TRACE_DEBUGGING, "ListenerThread() -- Enter" );

    while ( bContinue )
    {
        //Refer to doc on select for FD_ZERO, FD_SET etc.
        iFamIdx = IPV4_FAMILY;
        dwWaitRet = WaitForMultipleObjects ( 4, eventArray, FALSE, INFINITE );

        switch (dwWaitRet)
        {
            case FD_ACCEPT_EVENT_1:
                iFamIdx = IPV6_FAMILY;
                // fall through

            case FD_ACCEPT_EVENT_0:


                // NOTE: ***********************************************

                //      The only exit point out of this case statement should be
                //      through FD_ACCEPT_EVENT_CLEANUP only. Otherwise, you will
                //      cause serious leak of sockets inthe tlntsvr - BaskarK

                {
                    INT            iSize;
                    struct         sockaddr_storage ss;
                    WSANETWORKEVENTS wsaNetEvents;
                    bool bSendMessage = false;
                    struct sockaddr_storage saddrPeer;
                    char szIPAddr[ SMALL_STRING ];
                    DWORD           dwPid = 0;
                    HANDLE          hWritePipe = NULL;

                    // _TRACE( TRACE_DEBUGGING, " FD_ACCEPT_EVENT " );

                    wsaNetEvents.lNetworkEvents = 0;                 
                    if ( WSAEnumNetworkEvents( g_pTelnetService->m_sFamily[iFamIdx].sListenSocket, g_pTelnetService->m_sFamily[iFamIdx].SocketAcceptEvent, 
                                               &wsaNetEvents ) == SOCKET_ERROR )
                    {
                        DWORD dwErr = WSAGetLastError();
                        _TRACE( TRACE_DEBUGGING, " Error -- WSAEnumNetworkEvents-- 0x%x ", dwErr);
                        DecodeWSAErrorCodes( dwErr );
                        goto FD_ACCEPT_EVENT_CLEANUP;
                    }

                    if ( wsaNetEvents.lNetworkEvents & FD_ACCEPT )
                    {
                        if (sSocket != INVALID_SOCKET)
                        {
                            // shutdown(sSocket, SD_BOTH);
                            closesocket(sSocket);
                            sSocket = INVALID_SOCKET;
                        }

                        iSize = sizeof(ss);
                        __try
                        {
                            sSocket = accept( g_pTelnetService->m_sFamily[iFamIdx].sListenSocket,(struct sockaddr*) &ss, &iSize );
                        }
                        __except(EXCEPTION_EXECUTE_HANDLER)
                        {
                            sSocket = INVALID_SOCKET;
                            WSASetLastError(WSAEFAULT);
                        }

                        if (sSocket == INVALID_SOCKET)
                        {
                            DWORD dwErr = WSAGetLastError();
                            _TRACE( TRACE_DEBUGGING, " Error -- accept -- %d ", dwErr);

                            switch (dwErr)
                            {
                                case WSAEWOULDBLOCK: // non blocking socket so just loop back to the wait again

                                    WSASetEvent( g_pTelnetService->m_sFamily[iFamIdx].SocketAcceptEvent );
                                    break;

                                default:
                                    // DebugBreak();
                                    DecodeWSAErrorCodes( dwErr );
                            }
                        }
                        else
                        {
                            CClientInfo     *new_client = NULL;

                            _TRACE( TRACE_DEBUGGING, "accept succeded... sSocket = %d",(DWORD)sSocket );

                            // Set the option to don't linger around 
                            // Similarly, not to reuse address;
                            {
                                int        value_to_set = FALSE;

                                setsockopt(
                                          sSocket, 
                                          SOL_SOCKET, 
                                          SO_LINGER, 
                                          ( char * )&value_to_set, 
                                          sizeof( value_to_set )
                                          );

                                value_to_set = TRUE;

                                setsockopt(
                                          sSocket, 
                                          SOL_SOCKET, 
                                          SO_EXCLUSIVEADDRUSE,
                                          ( char * )&value_to_set, 
                                          sizeof( value_to_set )
                                          );
                            }
                            if (g_pTelnetService->m_sFamily[iFamIdx].SocketAcceptEvent == WSA_INVALID_EVENT)
                            {
                                goto FD_ACCEPT_EVENT_CLEANUP;
                            }
                            //Disassociate the default association to the event
                            _chVERIFY2( WSAEventSelect( sSocket, 
                                                        g_pTelnetService->m_sFamily[iFamIdx].SocketAcceptEvent, 0 ) != SOCKET_ERROR );
                            LONG  lSrvStat = SERVER_RUNNING;
                            lSrvStat = InterlockedCompareExchange( &g_pTelnetService->m_lServerState, 
                                                                   SERVER_PAUSED, SERVER_PAUSED );
                            if ( lSrvStat == SERVER_PAUSED )
                            {
                                CHAR szMessageBuffer[ MAX_STRING_LENGTH + 1 ]; 

                                if (LoadStringA( g_hInstRes, IDS_SERVICE_PAUSED, szMessageBuffer, MAX_STRING_LENGTH))
                                {
                                    InformTheClient( sSocket, szMessageBuffer ); 
                                }

                                shutdown( sSocket, SD_BOTH );
                                goto FD_ACCEPT_EVENT_CLEANUP;
                            }
                            else
                            {
                                /*++
                                Get IP address of the client which requested the connection. This will
                                also be stored in a queue entry. We put a limit on maximum number
                                of unauthenticated connections that can be created from one IP address.
                                --*/
                                iSize = sizeof( saddrPeer );
                                SfuZeroMemory( &saddrPeer, iSize );
                                if ( getpeername( sSocket, ( struct sockaddr * ) &saddrPeer, &iSize ) == SOCKET_ERROR )
                                {
                                    _TRACE(TRACE_DEBUGGING, "getpeername error : %d",GetLastError());
                                    goto FD_ACCEPT_EVENT_CLEANUP;
                                }
                                getnameinfo((SOCKADDR*)&saddrPeer, iSize, szIPAddr, SMALL_STRING,
                                            NULL, 0, NI_NUMERICHOST);
                                _TRACE(TRACE_DEBUGGING, "getpeername : %s",szIPAddr);

                                if (! CQList->OkToProceedWithThisClient(szIPAddr))
                                {
                                    CHAR szMessageBuffer[ MAX_STRING_LENGTH + 1 ]; 

                                    //Denying connection due to limit on maximum number of
                                    //unauthenticated connections per IP
                                    _TRACE( TRACE_DEBUGGING, "Max Unauthenticated connections reached" );
                                    _TRACE(TRACE_DEBUGGING, "%s, %d cannot be added",szIPAddr, dwPid);
                                    if (LoadStringA( g_hInstRes, IDS_MAX_IPLIMIT_REACHED, szMessageBuffer, MAX_STRING_LENGTH ))
                                    {
                                        InformTheClient( sSocket, szMessageBuffer ); // Don't care about its success, continue
                                        _TRACE(TRACE_DEBUGGING, "shutting down socket for pid %d, socket %d", dwPid,(DWORD)sSocket);
                                    }

                                    shutdown(sSocket, SD_BOTH);

                                    goto FD_ACCEPT_EVENT_CLEANUP;
                                }

                                /*++
                                CreateClient will return pid and pipehandle of the session
                                process that is created. this will be used by the queue object,
                                which stores information about all the sessions that are in
                                unauthenticated state.
                                Whenever a new session is created, it's info will be stored as
                                a queue entry in CQList.
                                --*/
                                if ( !CreateClient( sSocket, &dwPid, &hWritePipe, &new_client) )
                                {
                                    CHAR szMessageBuffer[ MAX_STRING_LENGTH + 1 ]; 

                                    _TRACE( TRACE_DEBUGGING, "new Telnet Client failed" );

                                    if (LoadStringA( g_hInstRes, IDS_ERR_NEW_SESS_INIT, szMessageBuffer, MAX_STRING_LENGTH ))
                                    {
                                        InformTheClient( sSocket, szMessageBuffer ); // Don't care if this fails, we have to continue
                                    }

                                    goto FD_ACCEPT_EVENT_CLEANUP;
                                }
                                else
                                {
                                    sSocket = INVALID_SOCKET; // From now onwards, we will reference this through the new_client class.
                                }

                                // hWritePipe will be NULL if IssueReadFromPipe fails in the CreateClient
                                // and hence we do StopServicingClient, so don't need to add the entry in a 
                                // queue.

                                if (!hWritePipe)
                                    goto FD_ACCEPT_EVENT_CLEANUP;

                                _TRACE( TRACE_DEBUGGING, "CreateClient success : %d",dwPid);

                                /*++
                                Add the session's information to the queue. CanIAdd will return FALSE
                                when the number of unauthenticated connections from the IP address
                                have already reached the limit, or when the queue is full.
                                In these cases, we notify the requesting client 
                                that no more connections can be added. Otherwise, the new connection request
                                entry is added into the queue and CanIAdd returns TRUE.
                                In case of IPLimitReached or QueueFull,
                                we send the PipeHandle for that session back here so that we
                                can notify that session and tell that session to terminate itself. In these cases,
                                the flag bSendFlag is set to TRUE.
                                --*/

                                if (!CQList->WasTheClientAdded(dwPid,szIPAddr, &hWritePipe, &bSendMessage))
                                {
                                    //Denying connection due to limit on maximum number of
                                    //unauthenticated connections per IP
                                    CHAR szMessageBuffer[ MAX_STRING_LENGTH + 1 ]; 
                                    _TRACE( TRACE_DEBUGGING, "Max Unauthenticated connections reached" );
                                    _TRACE(TRACE_DEBUGGING, "%s, %d cannot be added",szIPAddr, dwPid);
                                    if (LoadStringA( g_hInstRes, IDS_MAX_IPLIMIT_REACHED, szMessageBuffer, MAX_STRING_LENGTH ))
                                    {
                                        InformTheClient( new_client->sSocket, szMessageBuffer ); // Don't care about its success, continue
                                        _TRACE(TRACE_DEBUGGING, "shutting down socket for pid %d, socket %d", dwPid,(DWORD)new_client->sSocket);
                                    }
                                }

                                if (bSendMessage)
                                {
                                    //send message to session telling it to terminate itself
                                    bSendMessage = false;
                                    _TRACE(TRACE_DEBUGGING, "Asking the session %d to shutdown on socket %d",dwPid, (DWORD)sSocket);
                                    CQList->FreeEntry(dwPid);
                                    AskSessionToShutdown(hWritePipe, GO_DOWN);

                                    // shutdown(sSocket, SD_BOTH);
                                }

                                // FALL back to FD_ACCEPT_EVENT_CLEANUP will clean/close the socket..

                                TELNET_CLOSE_HANDLE(hWritePipe);
                            }
                        }
                    }

                }

                FD_ACCEPT_EVENT_CLEANUP: ;

                if (sSocket != INVALID_SOCKET)
                {
                    // shutdown(sSocket, SD_BOTH);
                    closesocket(sSocket);
                    sSocket = INVALID_SOCKET;
                }
                break;
            case SOCKET_CLOSE_EVENT:
                _TRACE( TRACE_DEBUGGING, " SOCKET_CLOSE_EVENT " );
                bContinue = false;
                break;
            case REG_CHANGE_EVENT:
                _TRACE( TRACE_DEBUGGING, " REG_CHANGE_EVENT " );
                HandleChangeInRegKeys( );
                ResetEvent( g_pTelnetService->m_hRegChangeEvent );
                RegisterForNotification();
                break;
            default:
                _TRACE( TRACE_DEBUGGING, " Error -- WaitForMultipleObjects " );
                // DebugBreak();
                if ( dwWaitRet == WAIT_FAILED )
                {
                    LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, 0, GetLastError() );
                }
                // bContinue = false; don't breakout of the loop, 
                //                    reject invalid requests (due to DOS attacks) keep continuing -- BaskarK
                break;
        }
    }

    if (g_pTelnetService->m_hReadConfigKey)
        RegCloseKey( g_pTelnetService->m_hReadConfigKey );
    TELNET_CLOSE_HANDLE( g_pTelnetService->m_hRegChangeEvent );
    //Socket related clean up
    if (g_pTelnetService->m_sFamily[IPV4_FAMILY].sListenSocket != INVALID_SOCKET)
    {
        closesocket( g_pTelnetService->m_sFamily[IPV4_FAMILY].sListenSocket );
        g_pTelnetService->m_sFamily[IPV4_FAMILY].sListenSocket = INVALID_SOCKET;
    }
    if (g_pTelnetService->m_sFamily[IPV6_FAMILY].sListenSocket != INVALID_SOCKET)
    {
        closesocket( g_pTelnetService->m_sFamily[IPV6_FAMILY].sListenSocket );
        g_pTelnetService->m_sFamily[IPV6_FAMILY].sListenSocket = INVALID_SOCKET;
    }
    TELNET_CLOSE_HANDLE( g_pTelnetService->m_hSocketCloseEvent );
    if (m_sFamily[IPV4_FAMILY].SocketAcceptEvent)
    {
        WSACloseEvent( m_sFamily[IPV4_FAMILY].SocketAcceptEvent );
    }
    if (m_sFamily[IPV6_FAMILY].SocketAcceptEvent)
    {
        WSACloseEvent( m_sFamily[IPV6_FAMILY].SocketAcceptEvent );
    }
    if(g_hProv)
    {
        CryptReleaseContext(g_hProv,0);
        g_hProv = NULL;
    }
    WSACleanup();
    return( TRUE ); 
}

bool
CTelnetService::IssueLicense( bool bIsIssued, CClientInfo *pClient )
{
    UCHAR ucMsg = LICENSE_NOT_AVAILABLE;

    if ( bIsIssued  )
    {
        ucMsg = LICENSE_AVAILABLE;
    }
    if ( !WriteToPipe( pClient->hWritingPipe, ucMsg, &( m_oWriteToPipe ) ) )
    {
        return( FALSE );
    }

    return( TRUE );
}
bool
CTelnetService::GetLicenseForWorkStation( SOCKET sSocket )
{
    DWORD dwIndex = 0;
    bool bRetVal = FALSE;
    struct sockaddr_storage saddrPeer;
    socklen_t slSize = sizeof( saddrPeer );
    SfuZeroMemory( &saddrPeer, slSize );
    if ( getpeername( sSocket, ( struct sockaddr * ) &saddrPeer, &slSize ) == SOCKET_ERROR )
    {
        goto GetLicenseForWorkStationAbort;
    }

    // Don't compare ports
    SS_PORT(&saddrPeer) = 0;

    for ( dwIndex = 0; dwIndex < m_dwNoOfWorkstations; dwIndex++ )
    {
        if ( !memcmp(&m_pssWorkstationList[ dwIndex ], &saddrPeer, slSize ))
        {
            bRetVal = TRUE;
            goto GetLicenseForWorkStationAbort;
        }
    }

    if ( m_dwNoOfWorkstations < DEFAULT_LICENSES_FOR_NTWKSTA )
    {
        m_pssWorkstationList[ m_dwNoOfWorkstations++ ] = saddrPeer;
        bRetVal = TRUE;
    }
    GetLicenseForWorkStationAbort:
    return( bRetVal );
}

bool
CTelnetService::CheckLicense( bool *bIsIssued, CClientInfo *pClient )
{
#if DBG

    CHAR szDebug[MAX_STRING_LENGTH * 3];

#endif

    bool bSuccess = false;

    *bIsIssued = false; //Not issued

    if ( !pClient )
    {
        return( FALSE );
    }

    _TRACE(TRACE_DEBUGGING,L"In CheckLicense");

    if ( m_dwNumOfActiveConnections >= m_dwMaxConnections )
    {
        static  CHAR        ansi_g_szMaxConnectionsReached[ MAX_STRING_LENGTH ] = { 0};

        if ('\0' == ansi_g_szMaxConnectionsReached[0])
        {
            wsprintfA( ansi_g_szMaxConnectionsReached, "%lS", g_szMaxConnectionsReached ); // NO over flow here, Baskar
        }

        LogEvent( EVENTLOG_INFORMATION_TYPE, MSG_MAXCONNECTIONS, _T(" ") );

        _TRACE(TRACE_DEBUGGING,L"CheckLicense : Max Conn reached. Freeing entry for %d",pClient->dwPid);

        if ( InformTheClient( pClient->sSocket, ansi_g_szMaxConnectionsReached ) )
        {
            bSuccess = true;
        }

        goto FREE_ENTRY_AND_GET_OUT;
    }

    //if it is an NT Workstation
    if ( m_bIsWorkStation )
    {
        _TRACE(TRACE_DEBUGGING,L"CheckLicense : Getting license for workstation");

        if ( !GetLicenseForWorkStation( pClient->sSocket ) )
        {
            static  CHAR        wksta_error_msg[ sizeof(NTWKSTA_LICENSE_LIMIT) + sizeof(TERMINATE) + 1] = { 0};

            if ('\0' == wksta_error_msg[0])
            {
                wsprintfA( wksta_error_msg, "%s%s", NTWKSTA_LICENSE_LIMIT, TERMINATE); // NO over flow here, Baskar
            }

            if ( InformTheClient( pClient->sSocket, wksta_error_msg ) )
            {
                bSuccess = true;
            }

            goto FREE_ENTRY_AND_GET_OUT;
        }
        else
        {
            bSuccess=true;
        }
    }
    else
    {
        NT_LS_DATA          NtLSData = { 0};
        CHAR                usrnam[2*MAX_PATH + 1+ 1] = { 0}; // User + domain + \ + NULL
        LS_STATUS_CODE      Status = { 0};


        _TRACE(TRACE_DEBUGGING,L"CheckLicense : License for server");

        _snprintf(usrnam, 2*MAX_PATH + 1, "%s\\%s", pClient->szDomain, pClient->szUserName);

        _TRACE(TRACE_DEBUGGING,L"CheckLicense : user name is %s",usrnam);

        NtLSData.DataType = NT_LS_USER_NAME;
        NtLSData.Data = usrnam;
        NtLSData.IsAdmin = FALSE;

        {
            static CHAR    szVersion[16] = { 0};
            {
                static OSVERSIONINFO osVersionInfo = { 0};

                osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
                if (0 == szVersion[0])
                {
                    if ( !GetVersionEx( &osVersionInfo ) )
                    {
                        _TRACE( TRACE_DEBUGGING, "Error: GetVersionEx()" );
                    }

                    _snprintf( szVersion, (sizeof(szVersion) - 1), "%d.%d", osVersionInfo.dwMajorVersion,
                               osVersionInfo.dwMinorVersion );
                }
            }

            Status = NtLicenseRequestA( "SMBServer", szVersion, &( pClient->m_hLicense), &NtLSData);
        }

#if DBG
        sprintf(szDebug,"License is %d. Status is %d \n",(DWORD)pClient->m_hLicense,Status);
        OutputDebugStringA(szDebug);
#endif

        switch ( Status)
        {
            case LS_SUCCESS :
                // go ahead and do what you want
                _TRACE(TRACE_DEBUGGING,L"CheckLicense : acquired license %d",(DWORD)pClient->m_hLicense);
                bSuccess = true;
                break;

                // case LS_INSUFFICIENT_UNITS :
                // case LS_RESOURCES_UNAVAILABLE:
            default :

                pClient->m_hLicense = INVALID_LICENSE_HANDLE;

                {
                    static  CHAR        server_error_msg[ sizeof(NTSVR_LICENSE_LIMIT) + sizeof(TERMINATE) + 1] = { 0};

                    if ('\0' == server_error_msg[0])
                    {
                        wsprintfA( server_error_msg, "%s%s", NTSVR_LICENSE_LIMIT, TERMINATE); // NO over flow here, Baskar
                    }

                    _TRACE(TRACE_DEBUGGING,L"Error in acquiring a license");

                    if (InformTheClient( pClient->sSocket, server_error_msg ) )
                    {
                        bSuccess = true;
                    }
                }

                goto FREE_ENTRY_AND_GET_OUT;
        }
    }

    if (bSuccess)
    {
        *bIsIssued = true;

        //An active session is allowed now

        m_dwNumOfActiveConnections++ ;

        pClient->bLicenseIssued = true;
    }

    FREE_ENTRY_AND_GET_OUT:

    CQList->FreeEntry(pClient->dwPid); // this client shoudl no longer be in the unauth list.

    _TRACE(TRACE_DEBUGGING,L"CheckLicense : Freeing entry for %d",pClient->dwPid);

    return( bSuccess );
}

void
CTelnetService::GetPathOfTheExecutable( LPTSTR *szCmdBuf )
{
    DWORD length_required = wcslen( g_pszTelnetInstallPath ) + wcslen( DEFAULT_SCRAPER_PATH ) + 2; // One for \ and one more for NULL termination
    LPTSTR lpszDefaultScraperFullPathName = new TCHAR[ length_required ];

    *szCmdBuf = NULL;    // First init this to NULL, so upon a failure the caller can check on this ptr != NULL; this function is a void returnee

    if ( !lpszDefaultScraperFullPathName )
        return;

    _snwprintf(lpszDefaultScraperFullPathName, length_required - 1, L"%s\\%s", g_pszTelnetInstallPath, DEFAULT_SCRAPER_PATH);
    lpszDefaultScraperFullPathName[length_required-1] = 0; // When the buffer is full snwprintf could return non-null terminated string

    AllocateNExpandEnvStrings( lpszDefaultScraperFullPathName, szCmdBuf );

    delete [] lpszDefaultScraperFullPathName;

    return;
}

bool
CTelnetService::CreateSessionProcess( HANDLE hStdinPipe, HANDLE hStdoutPipe,
                                      DWORD *dwProcessId, HANDLE *hProcess,
                                      HWINSTA *window_station, HDESK *desktop)
{
    PROCESS_INFORMATION pi = { 0};
    STARTUPINFO         si = { 0};
    LPWSTR              szCmdBuf = NULL;
    BOOL                fStatus = FALSE;
    bool                bRetVal = false;

    *hProcess = INVALID_HANDLE_VALUE;
    *dwProcessId = MAXDWORD;

    si.cb = sizeof(si);

    GetPathOfTheExecutable( &szCmdBuf );

    if (szCmdBuf) // => GetPathXxx succeeded.
    {
        //Let the tlntsess.exe get created on Default desktop. We will create the new desktops
        //in the session
        FillProcessStartupInfo( &si, hStdinPipe, hStdoutPipe, hStdoutPipe, NULL);

        fStatus = CreateProcess(
                    NULL, 
                    szCmdBuf, 
                    NULL, 
                    NULL, 
                    TRUE,
                    CREATE_NEW_PROCESS_GROUP | CREATE_NEW_CONSOLE, 
                    NULL, 
                    NULL, 
                    &si, 
                    &pi 
                    );

        _chVERIFY2(fStatus) ;

        if ( !fStatus )
        {
#if DBG
            OutputDebugStringA("BASKAR: CreateProcess fails for TlntSess.exe\n");
#endif
            LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, MSG_ERR_CREATEPROCESS, 
                                      GetLastError() );

            goto Done;
        }
    }
    else
    {
#if DBG
        OutputDebugStringA("BASKAR: GetPathOfTheExecutable, tlntsess.exe failed\n");
#endif
        LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, MSG_ERR_CREATEPROCESS, 
                                  ERROR_NOT_ENOUGH_MEMORY );

        goto Done;
    }

    *hProcess = pi.hProcess;
    *dwProcessId = pi.dwProcessId;
    bRetVal = true;
Done:
    
    TELNET_CLOSE_HANDLE( pi.hThread );
    if(szCmdBuf)
        delete [] szCmdBuf;    // no longer needed

    return( bRetVal);
}

bool
CTelnetService::CreateClient(
                            SOCKET sSocket , 
                            DWORD *pdwPid, 
                            HANDLE *phWritePipe,
                            CClientInfo **newClientInfo
                            )
{
    HANDLE hProcess = INVALID_HANDLE_VALUE;
    bool bRetVal = FALSE;
    DWORD dwErr = 0;
    DWORD dwProcessId;

    HANDLE hStdinPipe = NULL;
    HANDLE hStdoutPipe = NULL;
    HANDLE hPipeRead = NULL;
    HANDLE hPipeWrite = NULL;
    HWINSTA window_station = NULL;
    HDESK   desktop = NULL;
    bool bSuccess = false;
    DWORD dwExitCode = 0;
    bool    release_mutex = false;
    PSECURITY_DESCRIPTOR psd = NULL;

    *newClientInfo = NULL;

    _chASSERT( sSocket );
    if ( sSocket == NULL )
    {
        goto Done;
    }


    *phWritePipe = NULL;
    if(!TnCreateDefaultSecDesc(&psd, GENERIC_ALL & 
                                ~(WRITE_DAC | WRITE_OWNER | DELETE)))
    {
        goto Done;
    }
    if ( !CreateReadOrWritePipe( &hPipeRead, &hStdoutPipe, (SECURITY_DESCRIPTOR *)psd, READ_PIPE ) ||
         !CreateReadOrWritePipe( &hStdinPipe, &hPipeWrite, (SECURITY_DESCRIPTOR *)psd, WRITE_PIPE ) )
    {
        goto ExitOnError;
    }

    if ( !( CreateSessionProcess( hStdinPipe, hStdoutPipe, &dwProcessId, 
                                  &hProcess, &window_station, &desktop ) ) )
    {
        InformTheClient( sSocket, CREATE_TLNTSESS_FAIL_MSG );
        goto ExitOnError;
    }

    *pdwPid = dwProcessId;
    _TRACE( TRACE_DEBUGGING, "new Telnet Client -- socket : %d , pid : %d", ( DWORD ) sSocket , dwProcessId);

    //Make the following handles non-inheritable
    _chVERIFY2( SetHandleInformation( hStdinPipe, HANDLE_FLAG_INHERIT, 0 ) ); 
    _chVERIFY2( SetHandleInformation( hStdoutPipe, HANDLE_FLAG_INHERIT, 0 ) ); 
    _chVERIFY2( SetHandleInformation( ( HANDLE ) sSocket, HANDLE_FLAG_INHERIT, 0 ) ); 

    if ( !SendSocketToClient( hPipeWrite, sSocket, dwProcessId ) )
    {
        // Fix for HANDLE LEAK - close all handles
        goto ExitOnError;
    }

    //The following is needed so that Count() and add() operations happen atomically 

    //HANDLE LEAK - maintain a bool to see if you acquired mutex - release at the end of the function???
    dwErr = WaitForSingleObject( m_hSyncAllClientObjAccess, WAIT_TIME );
    if ( dwErr != WAIT_OBJECT_0 )
    {
        //fix for HANDLE LEAK close all handles
        if ( dwErr == WAIT_FAILED )
        {
            dwErr = GetLastError();
        }
        _TRACE(TRACE_DEBUGGING, "Error: WaitForSingleObject - 0x%1x", dwErr );
        goto ExitOnError;
    }

    release_mutex = true;

    _TRACE(TRACE_DEBUGGING, "Count of the ClientArray - %d, Count of sessions - %d", client_list_Count() , CQList->m_dwNumOfUnauthenticatedConnections + m_dwNumOfActiveConnections);

    if ((NULL == m_hIPCThread) || (INVALID_HANDLE_VALUE == m_hIPCThread))
    {
        if (! StartThreads())
        {
            _TRACE(TRACE_DEBUGGING, "IPC Thread startup failed ?  ");
            goto ExitOnError;
        }
    }

    *newClientInfo = new CClientInfo( hPipeRead, hPipeWrite,
                                      hStdinPipe, hStdoutPipe, 
                                      sSocket, dwProcessId, 
                                      window_station, desktop);
    if ( !*newClientInfo )
    {
        _TRACE(TRACE_DEBUGGING, "Failed to allocate memory for new client ");
        goto ExitOnError;
    }

    // Once the handles are given to newClientInfo, its destructor will close them

    hPipeRead = hPipeWrite = hStdinPipe = hStdoutPipe = INVALID_HANDLE_VALUE; // So we don't close these...

    if ( !AssociateDeviceWithCompletionPort(
                                           m_hCompletionPort, (*newClientInfo)->hReadingPipe, ( DWORD_PTR ) *newClientInfo ) )
    {
        goto ExitOnError;
    }

    if ( !client_list_Add( (PVOID)*newClientInfo ) )
    {
        _TRACE(TRACE_DEBUGGING, "Failed to add a new CClientInfo object ");
        goto ExitOnError;
    }
    //We have succeeded.. if the IssueReadFromPipe() call fails, we clean up the clientinfo array and return SUCCESS
    //if it succeeds, ONLY then we need to add this entry in the queue of unauthenticated connections. This check is 
    //made in the caller function ListenerThread(), where if pipehandle = NULL, we do not add the entry in the queue.
    bRetVal=TRUE;
    if ( IssueReadFromPipe( *newClientInfo ) )
    {
        if ( !DuplicateHandle( GetCurrentProcess(),(*newClientInfo)->hWritingPipe,
                               GetCurrentProcess(), phWritePipe,0,
                               FALSE, DUPLICATE_SAME_ACCESS) )
        {
            goto ExitOnError;
        }
    }
    else
    {
        StopServicingClient( *newClientInfo, (BOOL)FALSE );
        goto ExitOnError;  // cleanup everything but the socket passed. by falling through
    }
    goto Done;

    ExitOnError:

    if (*newClientInfo)
    {
        (*newClientInfo)->sSocket = INVALID_SOCKET; // So that the destructor below doesn't close this and cause accept to blow-up in listener thread - VadimE's dll found this, Baskar
        delete *newClientInfo;
        *newClientInfo = NULL;
    }
    else
    {
        TELNET_SYNC_CLOSE_HANDLE(hStdinPipe);
        TELNET_SYNC_CLOSE_HANDLE(hStdoutPipe);
        TELNET_SYNC_CLOSE_HANDLE(hPipeRead);
        TELNET_SYNC_CLOSE_HANDLE(hPipeWrite);
    }

    Done:
    if (release_mutex)
    {
        ReleaseMutex( m_hSyncAllClientObjAccess );
    }
    if(psd)
    {
        free(psd);
    }

    TELNET_CLOSE_HANDLE( hProcess ); 
    return(bRetVal);
}

bool
CTelnetService::IssueReadAgain( CClientInfo *pClientInfo )
{
    if (!pClientInfo->m_ReadFromPipeBuffer)
    {
        return(FALSE);
    }
    UCHAR *pucReadBuffer = pClientInfo->m_ReadFromPipeBuffer;

    if ( !pucReadBuffer )
    {
        return( FALSE );
    }

    pucReadBuffer++;    //Move past the message type
    //Extract Size of rest of the meesage 
    memcpy( &( pClientInfo->m_dwRequestedSize ), pucReadBuffer, 
            sizeof( DWORD ) );  // NO overflow, Baskar

    pucReadBuffer =  new UCHAR[ pClientInfo->m_dwRequestedSize 
                                + IPC_HEADER_SIZE ];
    if ( !pucReadBuffer )
    {
        return( FALSE );
    }

    memcpy( pucReadBuffer, ( pClientInfo->m_ReadFromPipeBuffer ), 
            IPC_HEADER_SIZE );  // No overflow, Baskar

    delete[] ( pClientInfo->m_ReadFromPipeBuffer );
    pClientInfo->m_ReadFromPipeBuffer = NULL;

    pClientInfo->m_ReadFromPipeBuffer = pucReadBuffer;        
    //position the pointer so that rest of the message is read in to 
    //proper place
    pClientInfo->m_dwPosition = IPC_HEADER_SIZE;

    return( IssueReadFromPipe( pClientInfo ) );
}


//Even if Read file finishes synchronously, we are intimated through the IO
// completion port. So no need to handle that case

bool 
CTelnetService::IssueReadFromPipe( CClientInfo *pClientInfo )
{

    bool bRetVal = TRUE;
    DWORD dwReceivedDataSize;

    if ( !pClientInfo->hReadingPipe || !pClientInfo->m_ReadFromPipeBuffer )
    {
        return( FALSE );
    }

    UCHAR *pucReadBuffer = pClientInfo->m_ReadFromPipeBuffer +
                           pClientInfo->m_dwPosition;

    if ( !ReadFile( pClientInfo->hReadingPipe, pucReadBuffer, 
                    pClientInfo->m_dwRequestedSize, &dwReceivedDataSize, 
                    &m_oReadFromPipe ) )
    {
        DWORD dwError = 0;
        dwError = GetLastError( );
        if ( dwError == ERROR_MORE_DATA )
        {
            //We reach here just in case it synchronously finishes 
            //with this error. 
        }
        else if ( dwError != ERROR_IO_PENDING )
        {
            _TRACE( TRACE_DEBUGGING, " Error: ReadFile -- 0x%1x ", dwError );
            bRetVal = FALSE;
        }
    }
    else
    {
        //Read is completed synchronously by chance. It was actually 
        //an async call. All synchronously completed calls are also reported
        //through the IO completion port
    }
    return bRetVal;
}

bool
CTelnetService::SendSocketToClient( HANDLE hPipeWrite, 
                                    SOCKET sSocket, DWORD dwPId )
{
    _chASSERT( sSocket );
    _chASSERT( hPipeWrite );
    if ( !sSocket || !hPipeWrite )
    {
        return FALSE;
    }

    WSAPROTOCOL_INFO protocolInfo;
    if ( WSADuplicateSocket( sSocket, dwPId, &protocolInfo ) )
    {
        DecodeWSAErrorCodes( WSAGetLastError() );
        return( FALSE );
    }
    if ( !WriteToPipe( hPipeWrite, &protocolInfo, sizeof( WSAPROTOCOL_INFO ), 
                       &( m_oWriteToPipe ) ) )
    {
        return( FALSE );
    }
    return TRUE;
}

bool
CTelnetService::InformTheClient( SOCKET sSocket, LPSTR pszMsg )
{
    _chASSERT( pszMsg );
    _chASSERT( sSocket );
    if ( !sSocket || !pszMsg )
    {
        return( FALSE );
    }

    DWORD dwLen = strlen( pszMsg ) + 1;
    OVERLAPPED m_oWriteToSock;
    InitializeOverlappedStruct( &m_oWriteToSock );
    if ( !WriteFile( ( HANDLE ) sSocket, pszMsg, dwLen, &dwLen, &m_oWriteToSock))
    {
        DWORD dwErr;
        if ( ( dwErr  = GetLastError( ) ) != ERROR_IO_PENDING )
        {
            if ( dwErr != ERROR_NETNAME_DELETED )
            {
                LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, MSG_ERR_WRITESOCKET, dwErr );
                _TRACE( TRACE_DEBUGGING, "Error: WriteFile(InformTheClient) -- 0x%1x", dwErr );
                _TRACE( TRACE_DEBUGGING, "Error writing to socket %d", (DWORD)sSocket);
            }
            return( FALSE );
        }
    }
    TlntSynchronizeOn(m_oWriteToSock.hEvent);
    TELNET_CLOSE_HANDLE( m_oWriteToSock.hEvent );

    return( TRUE );
}

//------------------------------------------------------------------------------
//this is the function which the worker threads execute.
//------------------------------------------------------------------------------

DWORD WINAPI
DoIPCWithClients( LPVOID lpContext ) 
{
    _chASSERT( lpContext != NULL );
    if ( !lpContext )
    {
        return( FALSE );
    }

    BOOL          bSuccess = FALSE;
    DWORD         dwIoSize = 0;
    LPOVERLAPPED  lpOverlapped = NULL;
    CClientInfo   *pClientInfo = NULL;
    bool          bRetVal = TRUE;
    bool          bContinue = true;
    CTelnetService *ctService = NULL;

    ctService = ( CTelnetService *)lpContext;
    while ( TRUE )
    {
        bSuccess = GetQueuedCompletionStatus( ctService->m_hCompletionPort,
                                              &dwIoSize, ( PULONG_PTR ) &pClientInfo, &lpOverlapped, INFINITE );

        if ( bSuccess == 0 )
        {
            if ( lpOverlapped == NULL )
            {
                DWORD dwErr = GetLastError();

                // This could happen during a stop service call....
                _TRACE( TRACE_DEBUGGING, "Error: GetQueuedCompletionStatus -- 0x%1x", dwErr );
                // LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, MSG_FAILGETQ, dwErr );
                // _chASSERT( lpOverlapped != NULL );
                bRetVal = FALSE;
                break;
            }
            else
            {
                DWORD dwErr = GetLastError();
                if ( dwErr == ERROR_MORE_DATA )
                {
                    //Some data is read and more is to be read for this Message

                    ctService->IssueReadAgain( pClientInfo );
                }
                else
                {
                    //When a session exits abruptly, whenever
                    //we try to write to it, we fail. As a result, We delete 
                    //the object. Then, the async read posted on that pipe 
                    //gets cancelled with the error code ERRO_BROKEN_PIPE.
                    //We should not access already deleted object. So....
                    if ( dwErr != ERROR_BROKEN_PIPE )
                    {
                        ctService->StopServicingClient( pClientInfo, (BOOL)TRUE ); 
                    }
                } 
            }
        }
        else
        {
            ctService->OnCompletionPacket( pClientInfo, lpOverlapped );
        }

    }

    TELNET_SYNC_CLOSE_HANDLE( g_pTelnetService->m_hCompletionPort );

    return( bRetVal );
} 

bool
CTelnetService::StopServicingClient( CClientInfo *pClientInfo, BOOL delete_the_class )
{
    _chASSERT( pClientInfo );

    bool  bRetVal = TRUE;
    DWORD dwErr = 0;
    DWORD dwRetVal = 0,dwAvail = 0, dwLeft = 0;
    CHAR *szBuffer = NULL;

    if (! TlntSynchronizeOn(m_hSyncAllClientObjAccess))
    {
        _TRACE( TRACE_DEBUGGING, "Failed to get access to mutex. Did not "
                " remove the client" );
        return(bRetVal);
    }
    if(!PeekNamedPipe(pClientInfo->hReadingPipe,szBuffer,0,&dwRetVal,&dwAvail,&dwLeft))
    {
        dwRetVal = GetLastError();
        if(dwRetVal == ERROR_INVALID_HANDLE)
        {
            bRetVal = FALSE;
            ReleaseMutex(m_hSyncAllClientObjAccess);
            return(bRetVal);
        }
    }
    if ( !pClientInfo )
    {
        if ( client_list_Count() == 0 )
        {
            bRetVal = FALSE;
        }
        ReleaseMutex(m_hSyncAllClientObjAccess);
        return( bRetVal );
    }

    //Number of active connections decreses by one only if it was given license
    if ( pClientInfo->bLicenseIssued )
    {
        if(m_dwNumOfActiveConnections>0)
            m_dwNumOfActiveConnections--;
    }
    _TRACE( TRACE_DEBUGGING,"removing element from pclientinfo : pid : %d, socket : %d ", pClientInfo->dwPid,(DWORD)pClientInfo->sSocket);
    if ( !client_list_RemoveElem( pClientInfo ) )
    {
        _TRACE( TRACE_DEBUGGING, "Could not delete the client", 
                pClientInfo->dwPid );
    }

    if (delete_the_class)
    {
        delete pClientInfo;
    }

    //If there are no more clients to service, exit the thread
    if ( client_list_Count() == 0 )
    {
        bRetVal = FALSE;
    }
    ReleaseMutex( m_hSyncAllClientObjAccess );

    return bRetVal;
}

bool 
CTelnetService::OnCompletionPacket( CClientInfo   *pClientInfo, 
                                    LPOVERLAPPED lpoObject )
{
    _chASSERT( lpoObject != NULL );
    _chASSERT( pClientInfo != NULL );

    bool  bRetVal = TRUE;

    if ( !lpoObject || !pClientInfo )
    {
        if ( client_list_Count() == 0 )
        {
            bRetVal = FALSE;
        }
        return( bRetVal );
    }

    if ( lpoObject == &m_oReadFromPipe )
    {
        //Asynchronous read from the pipe has finished.
        bRetVal = IPCDataDriver( pClientInfo );
    }
    else if ( lpoObject == &m_oPostedMessage )
    {
        //We should reach here on messages from other threads sent through 
        //PostQueuedCompletionStatus

        bRetVal = HandleInProcMessages( TLNTSVR_SHUTDOWN );
    }
    else
    {
        _chASSERT( 0 );
    }

    return bRetVal;
}

bool 
CTelnetService::SetNewRegKeyValues( DWORD dwNewTelnetPort, 
                                    DWORD dwNewMaxConnections, 
                                    DWORD dwNewMaxFileSize, 
                                    LPWSTR pszNewLogFile, LPWSTR pszNewIpAddr, DWORD dwLogToFile )
{
    bool bIPV4 = false;
    bool bIPV6 = false;
    if ( wcscmp( pszNewIpAddr, m_pszIpAddrToListenOn ) || dwNewTelnetPort != m_dwTelnetPort )
    {
        if (m_sFamily[IPV4_FAMILY].sListenSocket && m_sFamily[IPV4_FAMILY].sListenSocket != INVALID_SOCKET)
        {
            _TRACE(TRACE_DEBUGGING,"IPV4 socket closure");
            closesocket( m_sFamily[IPV4_FAMILY].sListenSocket );
            m_sFamily[IPV4_FAMILY].sListenSocket = INVALID_SOCKET;
            bIPV4 = true;
        }
        if (m_sFamily[IPV6_FAMILY].sListenSocket && m_sFamily[IPV6_FAMILY].sListenSocket != INVALID_SOCKET )
        {
            _TRACE(TRACE_DEBUGGING,"IPV6 socket closure");
            closesocket( m_sFamily[IPV6_FAMILY].sListenSocket );
            m_sFamily[IPV6_FAMILY].sListenSocket = INVALID_SOCKET;
            bIPV6 = true;
        }
        delete[] m_pszIpAddrToListenOn;

        m_pszIpAddrToListenOn = pszNewIpAddr;
        m_dwTelnetPort = dwNewTelnetPort;
        if (bIPV4)
        {
            WSAResetEvent( m_sFamily[IPV4_FAMILY].SocketAcceptEvent );
            _TRACE(TRACE_DEBUGGING,"IPV4 socket creation");
            CreateSocket(IPV4_FAMILY);
        }
        if (bIPV6)
        {
            WSAResetEvent( m_sFamily[IPV6_FAMILY].SocketAcceptEvent );
            CreateSocket(IPV6_FAMILY);
            _TRACE(TRACE_DEBUGGING,"IPV6 socket creation");
        }
    }

    if ( dwNewMaxConnections != m_dwMaxConnections )
    {
        /*++
        If the registry value for MaxConnections get modified, we should also
        modify the maximum number of unauthenticated connections allowed.
        --*/
        InterlockedExchange( (PLONG)&m_dwMaxConnections, dwNewMaxConnections );
        InterlockedExchange( (PLONG)&(CQList->m_dwMaxUnauthenticatedConnections), dwNewMaxConnections );
    }

    if ( dwNewMaxFileSize != (DWORD)g_lMaxFileSize )
    {
        InterlockedExchange( &g_lMaxFileSize, dwNewMaxFileSize );
    }

    if ( wcscmp( pszNewLogFile, g_pszLogFile ) != 0 )
    {
        HANDLE *phNewLogFile = NULL;
        HANDLE *phOldLogFile   = g_phLogFile;

        phNewLogFile = new HANDLE;
        if ( !phNewLogFile )
        {
            return false;
        }

        InitializeLogFile( pszNewLogFile, phNewLogFile );
        InterlockedExchangePointer( ( PVOID * )&g_phLogFile, phNewLogFile );
        CloseLogFile( &g_pszLogFile, phOldLogFile );
        g_pszLogFile = pszNewLogFile;
        //Don't delete pszNewLogFile
    }

    //Now onwards log to file
    if ( dwLogToFile && !g_fLogToFile )
    {
        g_fLogToFile = true;
        InitializeLogFile( g_pszLogFile, g_phLogFile );
    }
    else
    {
        //Now onwards don't log to file
        if ( !dwLogToFile && g_fLogToFile )
        {
            g_fLogToFile = false;
            TELNET_CLOSE_HANDLE( *g_phLogFile );
            *g_phLogFile = NULL;
        }
    }

    return( TRUE );
}

bool
CTelnetService::HandleInProcMessages( DWORD dwMsg )
{
    bool bRetVal = TRUE;

    if ( dwMsg == TLNTSVR_SHUTDOWN )
    {
        //Make the thread return
        bRetVal = FALSE;
    }

    return bRetVal;
}


//Each IPC packet  is to be decoded in the following manner:
//UCHAR Message : indicating type of message
//DWORD Size    : size of the following message if any
//UCHAR *Data   : data if any for the given message
//When a message indicates that it is may have variable size, The first element 
//Data points is of a DWORD indicating size and then the data.
//This is not true for the initial socket handover where only protocol structure
//is sent.

bool 
CTelnetService::IPCDataDriver( CClientInfo *pClientInfo )
{
    _chASSERT( pClientInfo );

    bool  bRetVal = true;

    if ( !pClientInfo )
    {
        if ( client_list_Count() == 0 )
        {
            bRetVal = false;
        }
        return bRetVal;
    }

    UCHAR *pBuff = NULL;

    //Don't do a delete on pBuff by mistake 
    pBuff =  pClientInfo->m_ReadFromPipeBuffer;
    bool  bStopService = false;
    bool bIsLicenseIssued = false;
    DWORD dwPid=0;

    switch ( *pBuff++ )
    {
        case RESET_IDLE_TIME:
            pClientInfo->m_dwIdleTime  = 0;
            break;
        case UPDATE_IDLE_TIME:
            pClientInfo->m_dwIdleTime  += MAX_POLL_INTERVAL;
            break;
        case SESSION_EXIT:
            dwPid = (DWORD)pClientInfo->dwPid;
            bRetVal = ExitTheSession( pClientInfo );
            _TRACE(TRACE_DEBUGGING,"Deleting session pid : %d",dwPid);
            CQList->FreeEntry(dwPid);
            goto FinishTheThread;

        case AUDIT_CLIENT :
            //The data is expected exactly in the form used
            //to be written in the file

            pBuff += sizeof( DWORD ); //Move past message size

            if ( *g_phLogFile )
            {
                WriteAuditedMsgsToFile( ( CHAR * )pBuff );
            }

            //delete the message. Such a big amt of memory
            //is no more needed

            delete[] (pClientInfo->m_ReadFromPipeBuffer);
            pClientInfo->m_ReadFromPipeBuffer =  new UCHAR[
                                                          IPC_HEADER_SIZE ];
            if (!pClientInfo->m_ReadFromPipeBuffer )
            {
                bStopService = true;
            }
            pClientInfo->m_dwRequestedSize = IPC_HEADER_SIZE;
            break;

        case SESSION_DETAILS:
            HandleSessionDetailsMessage( pClientInfo );
            _TRACE(TRACE_DEBUGGING,L"In session_details");
            //delete the message. Such a big amt of memory
            //is no more needed
            if (pClientInfo->m_ReadFromPipeBuffer )
            {
                _TRACE(TRACE_DEBUGGING,L"deleting ReadFromPipeBuffer");
                delete[] ( pClientInfo->m_ReadFromPipeBuffer );
                pClientInfo->m_ReadFromPipeBuffer = NULL;
            }

            pClientInfo->m_ReadFromPipeBuffer = 
            new UCHAR[ IPC_HEADER_SIZE ];
            if ( !pClientInfo->m_ReadFromPipeBuffer )
            {
                bStopService = true;
                pClientInfo->m_dwRequestedSize = 0;
                _TRACE(TRACE_DEBUGGING,L"new failed for ReadFromPipeBuffer");
                goto ExitOnErrorInDetails;
            }
            else
            {
                pClientInfo->m_dwRequestedSize = IPC_HEADER_SIZE;

                if ( !CheckLicense( &bIsLicenseIssued, pClientInfo ) )
                {
                    bStopService = true;
                    _TRACE(TRACE_DEBUGGING,L"checklicense failed");
                    goto ExitOnErrorInDetails;
                }
                if ( !IssueLicense( bIsLicenseIssued, pClientInfo ) )
                {
                    bStopService = true;
                    _TRACE(TRACE_DEBUGGING,L"issue license failed");
                    goto ExitOnErrorInDetails;
                }
            }
            //Close the session soc handle
            ExitOnErrorInDetails:
            pClientInfo->CloseClientSocket() ;


            break;
        default:
            _TRACE( TRACE_DEBUGGING, "Unknown IPC message:%uc", 
                    pClientInfo->m_ReadFromPipeBuffer[0] );
    }

    //Reset where to read -- Begining of the buffer
    pClientInfo->m_dwPosition = 0;

    //Issue a read call again
    if ( bStopService || !IssueReadFromPipe( pClientInfo ) )
    {
        bRetVal = StopServicingClient( pClientInfo, (BOOL)TRUE );
    }

    FinishTheThread:
    return( bRetVal );
}

void
CTelnetService::HandleSessionDetailsMessage( CClientInfo *pClientInfo )
{
    UCHAR *pBuff = NULL;
    if (!pClientInfo->m_ReadFromPipeBuffer)
    {
        return;
    }

    //Don't do a delete on pBuff by mistake 
    pBuff =  pClientInfo->m_ReadFromPipeBuffer;

    pBuff++;  // Move past  Message type
    pBuff += sizeof( DWORD ); //Move past message size

    DWORD dwStrLen = 0;

    //Domain 
    dwStrLen = strlen( ( LPCSTR ) pBuff ) + 1;
    pClientInfo->szDomain = new CHAR[ dwStrLen ];
    if ( !pClientInfo->szDomain )
    {
        return;
    }

    memcpy( pClientInfo->szDomain, pBuff, dwStrLen );   // No BO in this Baskar
    pBuff += dwStrLen;

    //Username
    dwStrLen = strlen( ( LPCSTR ) pBuff ) + 1;
    pClientInfo->szUserName = new CHAR[ dwStrLen ];
    if ( !pClientInfo->szUserName )
    {
        return;
    }
    memcpy( pClientInfo->szUserName, pBuff, dwStrLen ); // No BO in this Baskar 
    pBuff += dwStrLen;

    //Remote machine
    dwStrLen = strlen( ( LPCSTR ) pBuff ) + 1;
    pClientInfo->szRemoteMachine = new CHAR[ dwStrLen ];
    if ( !pClientInfo->szRemoteMachine )
    {
        return;
    }
    memcpy( pClientInfo->szRemoteMachine, pBuff, dwStrLen );    // No BO in this Baskar 
    pBuff += dwStrLen;

    //Logon identifier
    pClientInfo->pAuthId = new LUID;
    if ( !pClientInfo->pAuthId )
    {
        return;
    }
    memcpy( pClientInfo->pAuthId, pBuff, sizeof( LUID ) );  // No BO in this Baskar 

    pClientInfo->lpLogonTime = new SYSTEMTIME;
    if ( !pClientInfo->lpLogonTime )
    {
        return;
    }
    GetSystemTime( pClientInfo->lpLogonTime );
}

bool
CTelnetService::ExitTheSession( CClientInfo *pClientInfo )
{
    bool bRetVal = TRUE;

    _TRACE( TRACE_DEBUGGING, "ExitTheSession -- pid : %d, socket :%d", 
            pClientInfo->dwPid,( DWORD ) pClientInfo->sSocket );
    bRetVal = StopServicingClient( pClientInfo, (BOOL)TRUE );

    return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsvr\telnetd.h ===
// telnetd.h : This file contains the
// Created:  Jan '98
// Author : a-rakeba
// History:
// Copyright (C) 1998 Microsoft Corporation
// All rights reserved.
// Microsoft Confidential

#ifndef _TELNETD_H_
#define _TELNETD_H_

#include <Telnet.h>

//FOR XPSP1. If the message ids are not defined, hardcode them using the range specified by
//xpsp1msg.mc
#ifndef TELNET_MSG_ERROR_CREATE_DESKTOP_FAILURE
#define TELNET_MSG_ERROR_CREATE_DESKTOP_FAILURE           6001
#endif
#ifndef TELNET_MSG_REVERTSELFFAIL
#define TELNET_MSG_REVERTSELFFAIL                         6002
#endif


#define SERVICE_DISPLAY_NAME _T("Telnet")
#define APPID _T("{FE9E4896-A014-11D1-855C-00A0C944138C}")

#define REG_SERVER_KEY     L"Software\\Microsoft\\TelnetServer"
#define REG_PARAMS_KEY     L"Software\\Microsoft\\TelnetServer\\1.0"
#define READ_CONFIG_KEY    L"Software\\Microsoft\\TelnetServer\\1.0\\ReadConfig"
#define REG_DEFAULTS_KEY   L"Software\\Microsoft\\TelnetServer\\Defaults"
#define REG_SERVICE_KEY    L"System\\CurrentControlSet\\Services\\TlntSvr"
#define REG_WINNT_VERSION  L"Software\\Microsoft\\Windows NT\\CurrentVersion"
#define REG_PRODUCT_OPTION L"System\\CurrentControlSet\\Control\\ProductOptions"
#define REG_CONSOLE_KEY    L".DEFAULT\\Console"
#define REG_LOCALSERVICE_CONSOLE_KEY L"Console"
#define SWITCH_TO_KEEP_SHELL_RUNNING L"SwitchToKeepShellRunning"
#define SWITCH_FOR_ONE_TIME_USE_OF_SHELL L"SwitchForOneTimeUseOfShell"
#define WINDOW_STATION_NAME L"MicrosoftTelnetSrvWinSta"

#define PRE_SESSION_STATE_TIMEOUT 100000
#define NO_NTLM  4           //Old Val 0
#define NTLM_ELSE_OR_LOGIN 6 //Old val 1
#define NTLM_ONLY 2          //Old val 2

#define LATEST_TELNET_VERSION 5

#define DEFAULT_ALLOW_TRUSTED_DOMAIN 1
#define DEFAULT_DOMAIN L"." 
#define DEFAULT_TELNET_PORT 23
#define DEFAULT_SHELL  L"%SYSTEMROOT%\\System32\\cmd.exe"
#define DEFAULT_SWITCH_TO_KEEP_SHELL_RUNNING L"/q /k"
#define DEFAULT_SWITCH_FOR_ONE_TIME_USE_OF_SHELL L"/q /c"
#define DEFAULT_LOGIN_SCRIPT  L"login.cmd"
#define DEFAULT_SCRAPER_PATH  L"tlntsess.exe"
#ifdef WHISTLER_BUILD
#define DEFAULT_MAX_CONNECTIONS    2      
#else
#define DEFAULT_MAX_CONNECTIONS    63      
#endif
#define DEFAULT_MAX_FAILED_LOGINS    3      
#define DEFAULT_LICENSES_FOR_NTWKSTA 10
#define DEFAULT_SYSAUDITING 1
#define DEFAULT_LOGFILE L""
#define DEFAULT_LOGTOFILE 0
#define DEFAULT_LOGEVENTS 0 
#define DEFAULT_LOGADMIN 1
#define DEFAULT_LOGFAILURES 0
#define DEFAULT_ALT_KEY_MAPPING 0x01
#define ALT_KEY_MAPPING_ON 1
#define ALT_KEY_MAPPING_OFF 0
#define DEFAULT_IDLE_SESSION_TIME_OUT 60*60 // One hour
#define DEFAULT_DISCONNECT_KILLALL_APPS 1
#define DEFAULT_SECURITY_MECHANISM 6 //old value 1
#define DEFAULT_IP_ADDR _T("INADDR_ANY")
#define DEFAULT_SERVICE_DEPENDENCY _T("RPCSS\000TCPIP\000NTLMSSP\000")

#define CONSOLE_MODE   1
#define STREAM_MODE    2

#define IPV4_FAMILY 0
#define IPV6_FAMILY 1

#define DEFAULT_MODE_OF_OPERATION CONSOLE_MODE

#define DEFAULT_LOGFILESIZE       5   // MB
#define LOGFILESIZE               L"LogFileSize"

#define PIPE_NAME_FORMAT_STRING  L"\\\\.\\pipe\\telnetd\\%08x"

//The following messages are present in a .h file and should not be moved to .rc file.
//These messages should not be localized since they are passed from server to a client machine
//and both these machines can be in different locales which would create problems for displaying 
//the localized messages. The messages should be in English.
#define LOGIN_BANNER    "Welcome to Microsoft Telnet Service \r\n"
#define LOGIN_REQUEST   "\n\rlogin: "
#define PASS_REQUEST    "\n\rpassword: "
#define LOGIN_FAIL      "\r\nLogin Failed\r\n"
#define LOGIN_SUCC      "\r\nLogin Successful\r\n"
#define TERMINATE       "\r\nTelnet Server has closed the connection\r\n"
#define LONG_SESSION_DATA "\r\nThe Input line is too long.\r\n"
#define NTWKSTA_LICENSE_LIMIT "\r\nWorkstation allows only 10 simultaneous telnet connections.\r\n"
#define NTSVR_LICENSE_LIMIT   "\r\nNo server licenses are available for connecting to the telnet server."
#define TELNETCLIENTS_GROUP_NAME L"TelnetClients"
#define NOT_MEMBER_OF_TELNETCLIENTS_GROUP_STR "\r\nAccess Denied: Specified user is not a member of TelnetClients group.\r\nServer administrator must add this user to the above group.\r\n"
#define NTLM_ONLY_STR       "\r\nTelnet Server is configured to use NTLM authentication only.\r\nContact your administrator to enable username/password authentication.\r\n"
#define TIMEOUT_STR       "Session timed out."
#define NTLM_REJECT_STR     "\r\nNTLM Authentication failed due to insufficient credentials."
#define USE_PASSWD   "\r\nLogin using username and password\r\n\r\n"
#define NO_GUEST_STR       "\r\nTelnet connection not allowed to the Guest account\r\n"
#define BAD_USERNAME_STR "\r\nBad format for username. Use 'username' or 'domain\\username' format to login.\r\n"
#define CREATE_TLNTSESS_FAIL_MSG  "\r\nTelnet Server failed to initialize a Telnet Session.Please contact your system administrator for assistance.\r\n"
#define BUGGY_SESSION_DATA "\r\nSession data from client is not as expected\r\n"

#if BETA

#define LICENSE_EXPIRED_STR "\r\nThe Microsoft Telnet Service License has expired.\r\n"

#endif //BETA

//The following bunch of msgs are for session only. Move them to its rc 
#define LICENSE_LIMIT_REACHED  L"Denying new connections. Maximum number of allowed connections are currently in use."
#define SERVER_SHUTDOWN_MSG  L"Telnet server is shutting down......\r\n"
#define GO_DOWN_MSG          L"Administrator on the server has terminated this session......\r\n"
#define SYSTEM_SHUTDOWN_MSG  L"\r\nThe computer is shutting down......\r\n"
#define SESSION_INIT_FAIL    "\r\nFailure in initializing the telnet session. Shell process may not have been launched.\r\n"
#define NTLM_LOGON_FAIL      "\r\nTelnet server could not log you in using NTLM authentication."
#define NO_AUTHENTICATING_AUTHORITY "\r\nServer was unable to contact your domain controller"
#define INVALID_TOKEN_OR_HANDLE "\\r\nIf this error persists, contact your system administrator."
#define LOGON_DENIED "\r\nYour password may have expired."


// Ascii/ANSI Codes
#define ASCII_BACKSPACE     8
#define ASCII_LINEFEED      10
#define ASCII_CARRIAGE      13
#define ASCII_SPACE         32
#define ASCII_DELETE        127


#define WILL_OPTION(p, c) { p[0] = TC_IAC; p[1] = TC_WILL; p[2] = c; p[3] = NULL; }
#define WONT_OPTION(p, c) { p[0] = TC_IAC; p[1] = TC_WONT; p[2] = c; p[3] = NULL ; }
#define DO_OPTION(p, c)   { p[0] = TC_IAC; p[1] = TC_DO; p[2] = c; p[3] = NULL;}
#define DONT_OPTION(p, c) { p[0] = TC_IAC; p[1] = TC_DONT; p[2] = c; p[3] = NULL;}

#define AUTH_WHO_MASK         1
#define AUTH_CLIENT_TO_SERVER 0
#define AUTH_SERVER_TO_CLIENT 1

#define AUTH_HOW_MASK       2
#define AUTH_HOW_ONE_WAY    0
#define AUTH_HOW_MUTUAL     2

#define DO_AUTH_SUB_NE_NTLM(p)  {\
            p[0] = TC_IAC;\
            p[1] = TC_SB;\
            p[2] = TO_AUTH;\
            p[3] = AU_SEND;\
            p[4] = AUTH_TYPE_NTLM;\
            p[5] = AUTH_CLIENT_TO_SERVER | AUTH_HOW_ONE_WAY; \
            p[6] = TC_IAC;\
            p[7] = TC_SE; }

#define DO_TERMTYPE_SUB_NE(p)  {\
            p[0] = TC_IAC;\
            p[1] = TC_SB;\
            p[2] = TO_TERMTYPE;\
            p[3] = TT_SEND;\
            p[4] = TC_IAC;\
            p[5] = TC_SE; }

#define     USER        "USER"
#define     SFUTLNTVER  "SFUTLNTVER"
#define     SFUTLNTMODE "SFUTLNTMODE"

#define DO_NEW_ENVIRON_SUB_NE_MY_VARS( p, TelnetOption, Index ) {\
            p[ Index++ ] = TC_IAC;\
            p[ Index++ ] = TC_SB;\
            p[ Index++ ] = TelnetOption;\
            p[ Index++ ] = SEND;\
            p[ Index++ ] = USERVAR;\
            /* NO issue, Baskar */strcpy( ( char *)p+Index, SFUTLNTVER );\
            Index += strlen( SFUTLNTVER );\
            p[ Index++ ] = USERVAR;\
            /* No Issue, Baskar */strcpy( ( char *)p+Index, SFUTLNTMODE );\
            Index += strlen( SFUTLNTMODE );\
            p[ Index++ ] = TC_IAC;\
            p[ Index++ ] = TC_SE; }

#define DO_NEW_ENVIRON_SUB_NE( p, TelnetOption, Index ) {\
            p[ Index++ ] = TC_IAC;\
            p[ Index++ ] = TC_SB;\
            p[ Index++ ] = TelnetOption;\
            p[ Index++ ] = SEND;\
            p[ Index++ ] = TC_IAC;\
            p[ Index++ ] = TC_SE; }

#define DISABLED 0
#define ENABLED 1
//Add other FAREAST languages
#define JAP_CODEPAGE 932
#define CHS_CODEPAGE 936
#define KOR_CODEPAGE 949
#define CHT_CODEPAGE 950
#define JAP_FONTSIZE 786432
#define CHT_FONTSIZE 917504
#define KOR_FONTSIZE 917504
#define CHS_FONTSIZE 917504
#define NEW_LINE "\r\n"

#define MAX_POLL_INTERVAL   2000 //Milli Secs
#define ONE_MB 1024*1024

#endif _TELNETD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsvr\tlntdynamicarray.cpp ===
//Copyright (c) Microsoft Corporation.  All rights reserved.

#include <windows.h>

#include ".\tlntdynamicarray.h"

CLIENT_LIST *client_list_head = NULL;

HANDLE  client_list_mutex = NULL;

#ifdef DBG

CHAR        scratch[1024];

#endif

BOOL client_list_Add( PVOID client_class_ptr ) 
{
	DWORD mutex_obtained;
    BOOL    success = FALSE;

#ifdef DBG

    wsprintfA(scratch, "BASKAR: Add : 0x%x : ", client_class_ptr);
    OutputDebugStringA(scratch);

#endif

    if (NULL != client_class_ptr) 
    {
        mutex_obtained = WaitForSingleObject( client_list_mutex, INFINITE );   
        if ( mutex_obtained == WAIT_OBJECT_0 )
        {
            CLIENT_LIST     *node = new CLIENT_LIST;

            if (node) 
            {
                node->some_class_pointer = client_class_ptr;

                node->next = client_list_head;
                client_list_head = node;

                success = TRUE;
            }

            ReleaseMutex(client_list_mutex);
        } 
    }

#ifdef DBG

    wsprintfA(scratch, "%s\n", success ? "SUCCESS" : "FAILURE");
    OutputDebugStringA(scratch);

#endif

    return (success);
}


PVOID client_list_Get( int client_index )
{
    PVOID client_class_found = NULL;
	DWORD mutex_obtained;

#ifdef DBG

    wsprintfA(scratch, "BASKAR: Get : 0x%d : ", client_index);
    OutputDebugStringA(scratch);

#endif

    if (client_index >= 0) 
    {
        mutex_obtained = WaitForSingleObject( client_list_mutex, INFINITE );   
        if ( mutex_obtained == WAIT_OBJECT_0 )
        {
            CLIENT_LIST     *node = client_list_head;
            int             i;

            for (i = 0; (i < client_index) && node; i ++) 
            {
                node = node->next;
            }

            if ((i == client_index) && node) 
            {
                client_class_found = node->some_class_pointer;     
            }

            ReleaseMutex(client_list_mutex);
        } 
    }

#ifdef DBG

    wsprintfA(scratch, "%s\n", (NULL != client_class_found) ? "SUCCESS" : "FAILURE");
    OutputDebugStringA(scratch);

#endif

    return client_class_found;
}

BOOL client_list_RemoveElem(PVOID client_class_ptr)
{
    DWORD   mutex_obtained;
    BOOL    success = FALSE;

#ifdef DBG

    wsprintfA(scratch, "BASKAR: Remove : 0x%x : ", client_class_ptr);
    OutputDebugStringA(scratch);

#endif

    if (NULL != client_class_ptr) 
    {
        mutex_obtained = WaitForSingleObject( client_list_mutex, INFINITE );
        if ( mutex_obtained == WAIT_OBJECT_0 )
        {
            CLIENT_LIST         *node = NULL;
            CLIENT_LIST         *prev = NULL;

            for (
                    node = client_list_head; 
                    node; 
                    prev = node, node = node->next 
                )
            {
                if( node->some_class_pointer == client_class_ptr )
                {
                    if (prev) 
                    {
                        prev->next = node->next; // detach the node from middle
                    }
                    else
                    {
                        // It has got to be the head of the list
                        client_list_head = node->next;
                    }

                    delete node;

                    success = TRUE;

                    break;
                }
            }

            ReleaseMutex(client_list_mutex);
        }
    }

#ifdef DBG

    wsprintfA(scratch, "%s\n", success ? "SUCCESS" : "FAILURE");
    OutputDebugStringA(scratch);

#endif

    return success;     
}


int client_list_Count( void )
{
    int count = 0;
	DWORD mutex_obtained;

#ifdef DBG

    OutputDebugStringA("BASKAR: Count = ");

#endif

    mutex_obtained = WaitForSingleObject( client_list_mutex, INFINITE );   
    if ( mutex_obtained == WAIT_OBJECT_0 )
    {
        CLIENT_LIST     *node = client_list_head;

        for (node = client_list_head; node; node = node->next) 
        {
            count ++;
        }

        ReleaseMutex(client_list_mutex);
    } 

#ifdef DBG

    wsprintfA(scratch, "0x%d\n", count);
    OutputDebugStringA(scratch);

#endif

    return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsvr\tlntdynamicarray.h ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
#ifndef _TlntDynamicArray_h_
#define _TlntDynamicArray_h_

#ifdef __cplusplus
extern "C"
{
#endif

typedef struct __CLIENT_LIST
{
    struct __CLIENT_LIST    *next;
    PVOID                   some_class_pointer;
}
CLIENT_LIST;

extern CLIENT_LIST *client_list_head;

extern HANDLE  client_list_mutex;

extern BOOL client_list_Add( PVOID pvItem );
extern PVOID client_list_Get( int nItem );
extern BOOL client_list_RemoveElem(PVOID tElem);
extern int client_list_Count( void );

#ifdef __cplusplus
}
#endif

#endif _TlntDynamicArray_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\tftpd\debug.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module contains functions to output debug messages
    for tracing and error conditions.  It is only available
    in checked builds.

Author:

    Jeffrey C. Venable, Sr. (jeffv) 01-Jun-2001

Revision History:

--*/

#include "precomp.h"

#if (DBG)

#include <stdio.h>


void __cdecl
TftpdOutputDebug(ULONG flag, CHAR *format, ...) {
    
    CHAR buffer[1024];
    va_list args;

    if (!(flag & globals.parameters.debugFlags))
        return;

    va_start(args, format);
    sprintf(buffer, "[%04X] ", GetCurrentThreadId());
    vsprintf(buffer + 7, format, args);
    va_end(args);

    OutputDebugString(buffer);

} // TftpdOutputDebug()

#endif // (DBG)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\tftpd\log.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    log.c

Abstract:

    This module contains functions to generate event log
    entries for the service.

Author:

    Jeffrey C. Venable, Sr. (jeffv) 01-Jun-2001

Revision History:

--*/

#include "precomp.h"


void
TftpdLogEvent(WORD type, DWORD request, WORD numStrings) {

    // Register the event source if necessary.
    if (globals.service.hEventLogSource == NULL) {

/*
        UCHAR szBuf[80];
        DWORD dwData;
        HKEY key;

        // Create the event-source registry keys if necessary
        if (RegCreateKey(HKEY_LOCAL_MACHINE,
                         "SYSTEM\\CurrentControlSet\\Services\\"
                         "EventLog\\Application\\Tftpd", &key))
            return;

        // Set the name of the message file.
        strcpy(szBuf, "%SystemRoot%\\System\\SamplApp.dll");

        // Add the name to the EventMessageFile subkey.
        if (RegSetValueEx(key,            // subkey handle
                "EventMessageFile",       // value name
                0,                        // must be zero
                REG_EXPAND_SZ,            // value type
                (LPBYTE) szBuf,           // pointer to value data
                strlen(szBuf) + 1))       // length of value data
            return;

        // Set the supported event types in the TypesSupported subkey.
        dwData = (EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE);

        if (RegSetValueEx(key,     // subkey handle
                "TypesSupported",  // value name
                0,                 // must be zero
                REG_DWORD,         // value type
                (LPBYTE) &dwData,  // pointer to value data
                sizeof(DWORD)))    // length of value data
            return;

        RegCloseKey(key);

*/
        globals.service.hEventLogSource = RegisterEventSource(NULL, "NLA");

    } // if (globals.service.hEventLogSource == NULL)

    // If registration failed, we don't own the process, and can't
    // report errors anyways ... silent failure.
    if (globals.service.hEventLogSource == NULL)
        return;

    ReportEvent(globals.service.hEventLogSource, type, 0,
                request, NULL, numStrings, 0, NULL, NULL);

} // TftpdLogEvent()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\tftpd\io.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    io.c

Abstract:

    This module contains functions to manage all socket I/O
    between the server and clients, including socket management
    and overlapped completion indication.  It also contains
    buffer management.

Author:

    Jeffrey C. Venable, Sr. (jeffv) 01-Jun-2001

Revision History:

--*/

#include "precomp.h"


void
TftpdIoFreeBuffer(PTFTPD_BUFFER buffer) {

    PTFTPD_SOCKET socket = buffer->internal.socket;

    TFTPD_DEBUG((TFTPD_TRACE_IO,
                 "TftpdIoFreeBuffer(buffer = %p).\n",
                 buffer));

    HeapFree(globals.hServiceHeap, 0, buffer);

    if ((InterlockedDecrement((PLONG)&socket->numBuffers) == -1) &&
        (socket->context != NULL))
        HeapFree(globals.hServiceHeap, 0, socket);

    if (InterlockedDecrement(&globals.io.numBuffers) == -1)
        TftpdServiceAttemptCleanup();

} // TftpdIoFreeBuffer()


PTFTPD_BUFFER
TftpdIoAllocateBuffer(PTFTPD_SOCKET socket) {

    PTFTPD_BUFFER buffer;

    TFTPD_DEBUG((TFTPD_TRACE_IO,
                 "TftpdIoAllocateBuffer(socket = %s).\n",
                 ((socket == &globals.io.master) ? "master" :
                 ((socket == &globals.io.def)    ? "def"    :
                 ((socket == &globals.io.mtu)    ? "mtu"    :
                 ((socket == &globals.io.max)    ? "max"    :
                 "private")))) ));

    buffer = (PTFTPD_BUFFER)HeapAlloc(globals.hServiceHeap, 0,
                                      socket->buffersize);
    if (buffer == NULL) {
        TFTPD_DEBUG((TFTPD_DBG_IO,
                     "TftpdIoAllocateBuffer(socket = %s): "
                     "HeapAlloc() failed, error 0x%08X.\n",
                     ((socket == &globals.io.master) ? "master" :
                     ((socket == &globals.io.def)    ? "def"    :
                     ((socket == &globals.io.mtu)    ? "mtu"    :
                     ((socket == &globals.io.max)    ? "max"    :
                     "private")))), GetLastError()));
        return (NULL);
    }
    ZeroMemory(buffer, sizeof(buffer->internal));

    InterlockedIncrement(&globals.io.numBuffers);
    InterlockedIncrement((PLONG)&socket->numBuffers);

    buffer->internal.socket = socket;
    buffer->internal.datasize = socket->datasize;

    if (globals.service.shutdown) {
        TftpdIoFreeBuffer(buffer);
        buffer = NULL;
    }

    return (buffer);

} // TftpdIoAllocateBuffer()


PTFTPD_BUFFER
TftpdIoSwapBuffer(PTFTPD_BUFFER buffer, PTFTPD_SOCKET socket) {

    PTFTPD_BUFFER tmp;

    ASSERT((buffer->message.opcode == TFTPD_RRQ) ||
           (buffer->message.opcode == TFTPD_WRQ));

    // Allocate a buffer for the new socket.
    tmp = TftpdIoAllocateBuffer(socket);

    // Copy information we need to retain.
    if (tmp != NULL) {

        tmp->internal.context = buffer->internal.context;
        tmp->internal.io.peerLen = buffer->internal.io.peerLen;
        CopyMemory(&tmp->internal.io.peer,
                   &buffer->internal.io.peer,
                   buffer->internal.io.peerLen);
        CopyMemory(&tmp->internal.io.msg,
                   &buffer->internal.io.msg,
                   sizeof(tmp->internal.io.msg));
        CopyMemory(&tmp->internal.io.control,
                   &buffer->internal.io.control,
                   sizeof(tmp->internal.io.control));

    } // if (tmp != NULL)

    TFTPD_DEBUG((TFTPD_TRACE_IO,
                 "TftpdIoCompletionCallback(buffer = %p): "
                 "new buffer = %p.\n",
                 buffer, tmp));

    // Return the original buffer.
    TftpdIoPostReceiveBuffer(buffer->internal.socket, buffer);

    return (tmp);

} // TftpdIoSwapBuffer()


void
TftpdIoCompletionCallback(DWORD dwErrorCode,
                          DWORD dwBytes,
                          LPOVERLAPPED overlapped) {

    PTFTPD_BUFFER  buffer  = CONTAINING_RECORD(overlapped, TFTPD_BUFFER,
                                               internal.io.overlapped);
    PTFTPD_CONTEXT context = buffer->internal.context;
    PTFTPD_SOCKET  socket  = buffer->internal.socket;

    TFTPD_DEBUG((TFTPD_TRACE_IO,
                 "TftpdIoCompletionCallback(buffer = %p): bytes = %d.\n",
                 buffer, dwBytes));

    if (context == NULL)
        InterlockedDecrement((PLONG)&socket->postedBuffers);

    switch (dwErrorCode) {

        case STATUS_SUCCESS :

            if (context == NULL) {

                if (dwBytes < TFTPD_MIN_RECEIVED_DATA)
                    goto exit_completion_callback;

                buffer->internal.io.bytes = dwBytes;
                buffer = TftpdProcessReceivedBuffer(buffer);

            } // if (context == NULL)
            break;

        case STATUS_PORT_UNREACHABLE :

            TFTPD_DEBUG((TFTPD_TRACE_IO,
                         "TftpdIoCompletionCallback(buffer = %p, context = %p): "
                         "STATUS_PORT_UNREACHABLE.\n",
                         buffer, context));
            // If this was a write operation, kill the context.
            if (context != NULL) {
                TftpdProcessError(buffer);
                context = NULL;
            }
            goto exit_completion_callback;

        case STATUS_CANCELLED :

            // If this was a write operation, kill the context.
            if (context != NULL) {
                TFTPD_DEBUG((TFTPD_TRACE_IO,
                             "TftpdIoCompletionCallback(buffer = %p, context = %p): "
                             "STATUS_CANCELLED.\n",
                             buffer, context));
                TftpdProcessError(buffer);
                context = NULL;
            }

            TftpdIoFreeBuffer(buffer);
            buffer = NULL;

            goto exit_completion_callback;

        default :

            TFTPD_DEBUG((TFTPD_DBG_IO,
                         "TftpdIoCompletionCallback(buffer = %p): "
                         "dwErrorcode = 0x%08X.\n",
                         buffer, dwErrorCode));
            goto exit_completion_callback;

    } // switch (dwErrorCode)

exit_completion_callback :

    if (context != NULL) {

        // Do we bother reposting the buffer?
        if (context->state & TFTPD_STATE_DEAD) {
            TftpdIoFreeBuffer(buffer);
            buffer = NULL;
        }

        // Release the overlapped send reference.
        TftpdContextRelease(context);

    } // if (context != NULL)

    if (buffer != NULL)
        TftpdIoPostReceiveBuffer(buffer->internal.socket, buffer);

} // TftpdIoCompletionCallback()


void CALLBACK
TftpdIoReadNotification(PTFTPD_SOCKET socket, BOOLEAN timeout) {

    TFTPD_DEBUG((TFTPD_TRACE_IO,
                 "TftpdIoReadNotification(socket = %s).\n",
                 ((socket == &globals.io.master) ? "master" :
                 ((socket == &globals.io.def)    ? "def"    :
                 ((socket == &globals.io.mtu)    ? "mtu"    :
                 ((socket == &globals.io.max)    ? "max"    :
                 "private")))) ));

    // If this fails, the event triggering this callback will stop signalling
    // due to a lack of a successful WSARecvFrom() ... this will likely occur
    // during low-memory/stress conditions.  When the system returns to normal,
    // the low water-mark buffers will be reposted, thus receiving data and
    // re-enabling the event which triggers this callback.
    while (!globals.service.shutdown)
        if (TftpdIoPostReceiveBuffer(socket, NULL) >= socket->lowWaterMark)
            break;

} // TftpdIoReadNotification()


DWORD
TftpdIoPostReceiveBuffer(PTFTPD_SOCKET socket, PTFTPD_BUFFER buffer) {

    DWORD postedBuffers = 0, successfulPosts = 0;
    int error;

    TFTPD_DEBUG((TFTPD_TRACE_IO,
                 "TftpdIoPostReceiveBuffer(buffer = %p, socket = %s).\n",
                 buffer,
                 ((socket == &globals.io.master) ? "master" :
                 ((socket == &globals.io.def)    ? "def"    :
                 ((socket == &globals.io.mtu)    ? "mtu"    :
                 ((socket == &globals.io.max)    ? "max"    :
                 "private")))) ));

    postedBuffers = InterlockedIncrement((PLONG)&socket->postedBuffers);

    //
    // Attempt to post a buffer:
    //

    while (TRUE) {

        WSABUF buf;

        if (globals.service.shutdown ||
            (postedBuffers > globals.parameters.highWaterMark))
            goto exit_post_buffer;

        // Allocate the buffer if we're not reusing one.
        if (buffer == NULL) {

            buffer = TftpdIoAllocateBuffer(socket);
            if (buffer == NULL) {
                TFTPD_DEBUG((TFTPD_DBG_IO,
                             "TftpdIoPostReceiveBuffer(buffer = %p): "
                             "TftpdIoAllocateBuffer() failed.\n",
                             buffer));
                goto exit_post_buffer;
            }
            TFTPD_DEBUG((TFTPD_TRACE_IO,
                         "TftpdIoPostReceiveBuffer(buffer = %p).\n",
                         buffer));

        } else {
        
            if (socket->s == INVALID_SOCKET)
                goto exit_post_buffer;

            ASSERT(buffer->internal.socket == socket);
            ZeroMemory(buffer, sizeof(buffer->internal));
            buffer->internal.socket = socket;
            buffer->internal.datasize = socket->datasize;

        } // if (buffer == NULL)

        buf.buf = ((char *)buffer + FIELD_OFFSET(TFTPD_BUFFER, message.opcode));
        buf.len = (FIELD_OFFSET(TFTPD_BUFFER, message.data.data) -
                   FIELD_OFFSET(TFTPD_BUFFER, message.opcode) +
                   socket->datasize);

        error = NO_ERROR;

        if (socket == &globals.io.master) {

            DWORD bytes = 0;
            buffer->internal.io.msg.lpBuffers = &buf;
            buffer->internal.io.msg.dwBufferCount = 1;
            buffer->internal.io.msg.name = (LPSOCKADDR)&buffer->internal.io.peer;
            buffer->internal.io.msg.namelen = sizeof(buffer->internal.io.peer);
            buffer->internal.io.peerLen = sizeof(buffer->internal.io.peer);
            buffer->internal.io.msg.Control.buf = (char *)&buffer->internal.io.control;
            buffer->internal.io.msg.Control.len = sizeof(buffer->internal.io.control);
            buffer->internal.io.msg.dwFlags = 0;
            if (globals.fp.WSARecvMsg(socket->s, &buffer->internal.io.msg, &bytes,
                                      &buffer->internal.io.overlapped, NULL) == SOCKET_ERROR)
                error = WSAGetLastError();

        } else {

            DWORD bytes = 0;
            buffer->internal.io.peerLen = sizeof(buffer->internal.io.peer);
            if (WSARecvFrom(socket->s, &buf, 1, &bytes, &buffer->internal.io.flags,
                            (PSOCKADDR)&buffer->internal.io.peer, &buffer->internal.io.peerLen,
                            &buffer->internal.io.overlapped, NULL) == SOCKET_ERROR)
                error = WSAGetLastError();

        } // if (socket == &globals.io.master)

        switch (error) {

            case NO_ERROR :
                if (successfulPosts < 10) {
                    successfulPosts++;
                    postedBuffers = InterlockedIncrement((PLONG)&socket->postedBuffers);
                    buffer = NULL;
                    continue;
                } else {
                    return (postedBuffers);
                }

            case WSA_IO_PENDING :
                return (postedBuffers);

            case WSAECONNRESET :
                TFTPD_DEBUG((TFTPD_DBG_IO,
                             "TftpdIoPostReceiveBuffer(buffer = %p): "
                             "%s() failed for TID = <%s:%d>, WSAECONNRESET.\n",
                             buffer,
                             (socket == &globals.io.master) ? "WSARecvMsg" : "WSARecvFrom",
                             inet_ntoa(buffer->internal.io.peer.sin_addr),
                             ntohs(buffer->internal.io.peer.sin_port)));
                TftpdProcessError(buffer);
                continue;

            default :
                TFTPD_DEBUG((TFTPD_DBG_IO,
                             "TftpdIoPostReceiveBuffer(buffer = %p): "
                             "WSARecvMsg/From() failed, error 0x%08X.\n",
                             buffer, error));
                goto exit_post_buffer;

        } // switch (error)

    } // while (true)

exit_post_buffer :

    postedBuffers = InterlockedDecrement((PLONG)&socket->postedBuffers);
    if (buffer != NULL)
        TftpdIoFreeBuffer(buffer);

    return (postedBuffers);

} // TftpdIoPostReceiveBuffer()


void
TftpdIoSendErrorPacket(PTFTPD_BUFFER buffer, TFTPD_ERROR_CODE error, char *reason) {

    DWORD bytes = 0;
    WSABUF buf;

    TFTPD_DEBUG((TFTPD_TRACE_IO,
                 "TftpdIoSendErrorPacket(buffer = %p): %s\n",
                 buffer, reason));

    // Build the error message.
    buffer->message.opcode = htons(TFTPD_ERROR);
    buffer->message.error.code = htons(error);
    strncpy(buffer->message.error.error, reason, buffer->internal.datasize);
    buffer->message.error.error[buffer->internal.datasize - 1] = '\0';

    // Send it non-blocking only.  If it fails, who cares, let the client deal with it.
    buf.buf = (char *)&buffer->message.opcode;
    buf.len = (FIELD_OFFSET(TFTPD_BUFFER, message.error.error) -
               FIELD_OFFSET(TFTPD_BUFFER, message.opcode) +
               (strlen(buffer->message.error.error) + 1));
    if (WSASendTo(buffer->internal.socket->s, &buf, 1, &bytes, 0,
                  (PSOCKADDR)&buffer->internal.io.peer, sizeof(SOCKADDR_IN),
                  NULL, NULL) == SOCKET_ERROR) {
        TFTPD_DEBUG((TFTPD_DBG_IO,
                     "TftpdIoSendErrorPacket(buffer = %p): WSASendTo() failed, error = %d.\n",
                     buffer, WSAGetLastError()));
    }

} // TftpdIoSendErrorPacket()


PTFTPD_BUFFER
TftpdIoSendPacket(PTFTPD_BUFFER buffer) {

    PTFTPD_CONTEXT context = buffer->internal.context;
    DWORD bytes = 0;
    WSABUF buf;

    // NOTE: 'context' must be referenced before this call!
    ASSERT(context != NULL);
    ASSERT(context->reference >= 1);
    ASSERT(buffer->internal.socket != NULL);

    TFTPD_DEBUG((TFTPD_TRACE_IO,
                 "TftpdIoSendPacket(buffer = %p, context = %p): bytes = %d.\n",
                 buffer, context, buffer->internal.io.bytes));

    // First try sending it non-blocking.
    buf.buf = (char *)&buffer->message.opcode;
    buf.len = buffer->internal.io.bytes;
    if (WSASendTo(context->socket->s, &buf, 1, &bytes, 0,
                  (PSOCKADDR)&context->peer, sizeof(SOCKADDR_IN),
                  NULL, NULL) == SOCKET_ERROR) {

        if (WSAGetLastError() == WSAEWOULDBLOCK) {

            // Keep an overlapped-operation reference to the context.
            TftpdContextAddReference(context);

            // Send it overlapped.  When completion occurs, we'll know it was a send
            // when buffer->internal.context is non-NULL.
            if (WSASendTo(context->socket->s, &buf, 1, &bytes, 0,
                          (PSOCKADDR)&context->peer, sizeof(SOCKADDR_IN),
                          &buffer->internal.io.overlapped, NULL) == SOCKET_ERROR) {

                if (WSAGetLastError() != WSA_IO_PENDING) {
                    TFTPD_DEBUG((TFTPD_TRACE_IO,
                                 "TftpdIoSendPacket(buffer = %p, context = %p): "
                                 "overlapped send failed.\n",
                                 buffer, context));
                    // Release the overlapped-operation reference to the context.
                    TftpdContextRelease(context);
                    goto exit_send_packet;
                }

            } // if (WSASendTo(...) == SOCKET_ERROR)

            buffer = NULL; // Tell the caller not to recycle a buffer.

        } // if (WSAGetLastError() == WSAEWOULDBLOCK)

        goto exit_send_packet;

    } // if (WSASendTo(...) == SOCKET_ERROR)

    //
    // Non-blocking send succeeded.
    //

exit_send_packet :

    return (buffer);

} // TftpdIoSendPacket()


void
TftpdIoLeakSocketContext(PTFTPD_SOCKET socket) {

    PLIST_ENTRY entry;
    
    EnterCriticalSection(&globals.reaper.socketCS); {

        // If shutdown is occuring, we're in trouble anyways.
        // Just let it go.
        if (globals.service.shutdown) {
            LeaveCriticalSection(&globals.reaper.socketCS);
            return;
        }

        TFTPD_DEBUG((TFTPD_TRACE_CONTEXT,
                     "TftpdIoLeakSocketContext(context = %p).\n",
                     socket));

        // Is the socket already in the list?
        for (entry = globals.reaper.leakedSockets.Flink;
             entry != &globals.reaper.leakedSockets;
             entry = entry->Flink) {

            if (CONTAINING_RECORD(entry, TFTPD_SOCKET, linkage) == socket) {
                LeaveCriticalSection(&globals.reaper.socketCS);
                return;
            }

        }

        InsertHeadList(&globals.reaper.leakedSockets, &socket->linkage);
        globals.reaper.numLeakedSockets++;

    } LeaveCriticalSection(&globals.reaper.socketCS);

} // TftpdIoLeakSocketContext()


PTFTPD_SOCKET
TftpdIoAllocateSocketContext() {

    PTFTPD_SOCKET socket = NULL;

    if (globals.reaper.leakedSockets.Flink != &globals.reaper.leakedSockets) {

        BOOL failAllocate = FALSE;

        // Try to recover leaked contexts.
        EnterCriticalSection(&globals.reaper.socketCS); {

            PLIST_ENTRY entry;
            while ((entry = RemoveHeadList(&globals.reaper.leakedSockets)) !=
                   &globals.reaper.leakedSockets) {

                PTFTPD_SOCKET s = CONTAINING_RECORD(entry, TFTPD_SOCKET, linkage);

                globals.reaper.numLeakedSockets--;
                if (!TftpdIoDestroySocketContext(s)) {
                    TftpdIoLeakSocketContext(s);
                    failAllocate = TRUE;
                    break;
                }

            }

        } LeaveCriticalSection(&globals.reaper.socketCS);

        if (failAllocate)
            goto exit_allocate_context;

    } // if (globals.reaper.leakedSockets.Flink != &globals.reaper.leakedSockets)

    socket = (PTFTPD_SOCKET)HeapAlloc(globals.hServiceHeap,
                                      HEAP_ZERO_MEMORY,
                                      sizeof(TFTPD_SOCKET));

exit_allocate_context :

    return (socket);

} // TftpdIoAllocateSocketContext()


void
TftpdIoInitializeSocketContext(PTFTPD_SOCKET socket, PSOCKADDR_IN addr, PTFTPD_CONTEXT context) {

    BOOL one = TRUE;

    TFTPD_DEBUG((TFTPD_TRACE_IO,
                 "TftpdIoInitializeSocketContext(socket = %s): TID = <%s:%d>.\n",
                 ((socket == &globals.io.master) ? "master" :
                 ((socket == &globals.io.def)    ? "def"    :
                 ((socket == &globals.io.mtu)    ? "mtu"    :
                 ((socket == &globals.io.max)    ? "max"    : "private")))),
                 inet_ntoa(addr->sin_addr), ntohs(addr->sin_port)));

    // NOTE: Do NOT zero-out 'socket', it has been initialized with some
    //       values we need to work with.

    // Create the socket.
    socket->s = WSASocket(AF_INET, SOCK_DGRAM, 0, NULL, 0, WSA_FLAG_OVERLAPPED);
    if (socket->s == INVALID_SOCKET) {
        TFTPD_DEBUG((TFTPD_DBG_IO,
                     "TftpdIoInitializeSocketContext: "
                     "WSASocket() failed, error 0x%08X.\n",
                     GetLastError()));
        SetLastError(WSAGetLastError());
        goto fail_create_context;
    }

    // Ensure that we will exclusively own our local port so nobody can hijack us.
    if (setsockopt(socket->s,
                   SOL_SOCKET,
                   SO_EXCLUSIVEADDRUSE,
                   (const char *)&one,
                   sizeof(one)) == SOCKET_ERROR) {
        TFTPD_DEBUG((TFTPD_DBG_IO,
                     "TftpdIoInitializeSocketContext: "
                     "setsockopt(SO_EXCLUSIVEADDRUSE) failed, error 0x%08X.\n",
                     GetLastError()));
        SetLastError(WSAGetLastError());
        goto fail_create_context;
    }

    // Bind the socket on the correct port.
    if (bind(socket->s, (PSOCKADDR)addr, sizeof(SOCKADDR)) == SOCKET_ERROR) {
        TFTPD_DEBUG((TFTPD_DBG_IO,
                     "TftpdIoInitializeSocketContext: "
                     "bind() failed, error 0x%08X.\n",
                     GetLastError()));
        SetLastError(WSAGetLastError());
        goto fail_create_context;
    }

    // Register for completion callbacks on the socket.
    if (!BindIoCompletionCallback((HANDLE)socket->s, TftpdIoCompletionCallback, 0)) {
        TFTPD_DEBUG((TFTPD_DBG_IO,
                     "TftpdIoInitializeSocketContext: "
                     "BindIoCompletionCallback() failed, error 0x%08X.\n",
                     GetLastError()));
        goto fail_create_context;
    }

    // Indicate that we want WSARecvMsg() to fill-in packet information.
    // Note we only do this on the master-socket only where we can receive TFTPD_RECV and
    // TFTPD_WRITE requests, and we need to determine which socket to set the context to.
    if (socket == &globals.io.master) {

        // Obtain the WSARecvMsg() extension API pointer.
        GUID g = WSAID_WSARECVMSG;
        int opt = TRUE;
        DWORD len;

        if (WSAIoctl(socket->s, SIO_GET_EXTENSION_FUNCTION_POINTER, &g, sizeof(g),
                     &globals.fp.WSARecvMsg, sizeof(globals.fp.WSARecvMsg),
                     &len, NULL, NULL) == SOCKET_ERROR) {
            TFTPD_DEBUG((TFTPD_DBG_IO,
                         "TftpdIoInitializeSocketContext: "
                         "WSAIoctl() failed, error 0x%08X.\n",
                         WSAGetLastError()));
            goto fail_create_context;
        }

        // Indicate that we want WSARecvMsg() to fill-in packet information.
        if (setsockopt(socket->s, IPPROTO_IP, IP_PKTINFO, 
                       (char *)&opt, sizeof(opt)) == SOCKET_ERROR) {
            TFTPD_DEBUG((TFTPD_DBG_IO,
                         "TftpdIoInitializeSocketContext: "
                         "setsockopt() failed, error 0x%08X.\n",
                         WSAGetLastError()));
            goto fail_create_context;
        }

    } // if (socket == &globals.io.master)

    // Record the port used for this context.
    CopyMemory(&socket->addr, addr, sizeof(socket->addr));

    if (context == NULL) {

        // Select the socket for read and write notifications.
        // Read so when we know to get data, write so when we know
        // whether to do send operations non-blocking or overlapped.
        if ((socket->hSelect = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL) {
            TFTPD_DEBUG((TFTPD_DBG_IO,
                         "TftpdIoInitializeSocketContext: "
                         "CreateEvent() failed, error 0x%08X.\n",
                         GetLastError()));
            goto fail_create_context;
        }

        if (WSAEventSelect(socket->s, socket->hSelect, FD_READ) == SOCKET_ERROR) {
            TFTPD_DEBUG((TFTPD_DBG_IO,
                         "TftpdIoInitializeSocketContext: "
                         "WSAEventSelect() failed, error 0x%08X.\n",
                         GetLastError()));
            SetLastError(WSAGetLastError());
            goto fail_create_context;
        }

        // Register for FD_READ notification on the socket.
        if (!RegisterWaitForSingleObject(&socket->wSelectWait,
                                         socket->hSelect,
                                         (WAITORTIMERCALLBACK)TftpdIoReadNotification,
                                         socket,
                                         INFINITE,
                                         WT_EXECUTEINWAITTHREAD)) {
            TFTPD_DEBUG((TFTPD_DBG_IO,
                         "TftpdIoInitializeSocketContext: "
                         "RegisterWaitForSingleObject() failed, error 0x%08X.\n",
                         GetLastError()));
            goto fail_create_context;
        }

        // Prepost the low water-mark number of receive buffers.
        // If the FD_READ event signals on the master socket before we're done, we'll
        // exceed the low water-mark here but that's harmless as the excess buffers
        // will be freed upon completion.
        if (!socket->lowWaterMark)
            socket->lowWaterMark = 1;
        if (!socket->highWaterMark)
            socket->highWaterMark = 1;

        SetEvent(socket->hSelect);

    } else {

        // Is this a private socket (ie, not master, def, mtu, or max).
        // If so, it will be destroyed when it's one and only one owning context is destroyed.
        socket->context = context;

        // Initialize read notification variables to NULL.
        socket->hSelect = NULL;
        socket->wSelectWait = NULL;
        socket->lowWaterMark = 1;

        TftpdIoPostReceiveBuffer(socket, NULL);

    } // if (context == NULL)

    return;

fail_create_context :

    if (socket->s != INVALID_SOCKET)
        closesocket(socket->s), socket->s = INVALID_SOCKET;
    if (socket->hSelect != NULL)
        CloseHandle(socket->hSelect), socket->hSelect = NULL;

} // TftpdIoInitializeSocketContext()


BOOL
TftpdIoAssignSocket(PTFTPD_CONTEXT context, PTFTPD_BUFFER buffer) {

    SOCKADDR_IN addr;
    DWORD len = 0;

    TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                 "TftpdIoAssignSocket(context = %p, buffer = %p).\n",
                 context, buffer));

    if (!(buffer->internal.io.msg.dwFlags & MSG_BCAST)) {

        PWSACMSGHDR header;
        IN_PKTINFO *packetInfo;

        // Determine if routing problems force us to use a private socket so we can corrrectly
        // send datagrams to the requesting client.  First, get the best interface address for
        // responding to the requesting client.
        ZeroMemory(&addr, sizeof(addr));

        // Make the ioctl call.
        WSASetLastError(NO_ERROR);
        if ((WSAIoctl(globals.io.master.s, SIO_ROUTING_INTERFACE_QUERY,
                      &buffer->internal.io.peer, buffer->internal.io.peerLen,
                      &addr, sizeof(SOCKADDR_IN),
                      &len, NULL, NULL) == SOCKET_ERROR) ||
            (len != sizeof(SOCKADDR_IN))) {
            TFTPD_DEBUG((TFTPD_DBG_PROCESS,
                         "TftpdIoAssignSocket(): "
                         "WSAIoctl(SIO_ROUTING_INTERFACE_QUERY) failed, error = %d.\n",
                         WSAGetLastError()));
            TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_UNDEFINED,
                                   "Failed to initialize network endpoint.");
            return (FALSE);
        }

        // Loop through the control (ancillary) data looking for our packet info.
        header = WSA_CMSG_FIRSTHDR(&buffer->internal.io.msg);
        packetInfo = NULL;
        while (header) {

            if ((header->cmsg_level == IPPROTO_IP) && (header->cmsg_type == IP_PKTINFO)) {
                packetInfo = (IN_PKTINFO *)WSA_CMSG_DATA(header);
                break;
            }

            header = WSA_CMSG_NXTHDR(&buffer->internal.io.msg, header);

        } // while (header)

        // Check to see if the best interface we obtained is not the one the client sent the message to.
        if ((packetInfo != NULL) &&
            (addr.sin_addr.s_addr != packetInfo->ipi_addr.s_addr)) {

            TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                         "TftpdIoAssignSocket(context = %p, buffer = %p):\n"
                         "\tRemote client TID = <%s:%d>\n",
                         context, buffer,
                         inet_ntoa(buffer->internal.io.peer.sin_addr),
                         ntohs(buffer->internal.io.peer.sin_port) ));
            TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                         "\tRequest issued to local IP = <%s>\n",
                         inet_ntoa(packetInfo->ipi_addr) ));
            TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                         "\tDefault route is over IP = <%s>\n",
                         inet_ntoa(addr.sin_addr) ));

            // We need to create a private socket for this client.
            context->socket = TftpdIoAllocateSocketContext();
            if (context->socket == NULL) {
                TFTPD_DEBUG((TFTPD_DBG_PROCESS,
                             "TftpdIoAssignSocket(): "
                             "TftpdIoAllocateSocketContext() failed.\n"));
                TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_UNDEFINED,
                                       "Out of memory");
                return (FALSE);
            }
            context->socket->s          = INVALID_SOCKET;
            context->socket->buffersize = (TFTPD_BUFFER_SIZE)
                                          (FIELD_OFFSET(TFTPD_BUFFER, message.data.data) +
                                           context->blksize);
            context->socket->datasize   = (TFTPD_DATA_SIZE)context->blksize;

            if (!(buffer->internal.io.msg.dwFlags & MSG_BCAST)) {
                ZeroMemory(&addr, sizeof(addr));
                addr.sin_family      = AF_INET;
                addr.sin_addr.s_addr = packetInfo->ipi_addr.s_addr;
            }

            TftpdIoInitializeSocketContext(context->socket, &addr, context);
            if (context->socket->s == INVALID_SOCKET) {
                TFTPD_DEBUG((TFTPD_DBG_PROCESS,
                             "TftpdIoAssignSocket(): "
                             "TftpdIoInitializeSocketContext() failed.\n"));
                TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_UNDEFINED,
                                       "Failed to initialize network endpoint.");
                HeapFree(globals.hServiceHeap, 0, context->socket);
                context->socket = NULL;
                return (FALSE);
            }

#if defined(DBG)
            InterlockedIncrement((PLONG)&globals.performance.privateSockets);
#endif // defined(DBG)

            return (TRUE);

        } // if ((packetInfo != NULL) && ...)

    } else {
        
        TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                     "TftpdIoAssignSocket(context = %p, buffer = %p):\n"
                     "\tRemote client TID = <%s:%d> issued broadcast request.\n",
                     context, buffer,
                     inet_ntoa(buffer->internal.io.peer.sin_addr), ntohs(buffer->internal.io.peer.sin_port) ));

    } // if (!(buffer->internal.io.msg.dwFlags & MSG_BCAST))

    ZeroMemory(&addr, sizeof(addr));
    addr.sin_family      = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port        = 0;

    // Figure out which socket to use for this request (based on blksize).
    if (context->blksize <= TFTPD_DEF_DATA) {

        if (globals.io.def.s == INVALID_SOCKET) {

            EnterCriticalSection(&globals.io.cs); {

                if (globals.service.shutdown) {
                    TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_UNDEFINED, "TFTPD service is stopping.");
                    LeaveCriticalSection(&globals.io.cs);
                    return (FALSE);
                }

                TftpdIoInitializeSocketContext(&globals.io.def, &addr, NULL);

                if (globals.io.def.s != INVALID_SOCKET) {
                    context->socket = &globals.io.def;
                } else {
                    context->socket = &globals.io.master;
                    if (context->options) {
                        TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                                     "TftpdIoAssignSocket(): Removing requested blksize = %d "
                                     "option since we failed to create the MTU-size socket.\n",
                                     context->blksize));
                        context->options &= ~TFTPD_OPTION_BLKSIZE;
                    }
                }

            } LeaveCriticalSection(&globals.io.cs);

        } else {

            context->socket = &globals.io.def;

        } // if (globals.io.def.s == INVALID_SOCKET)

    } else {

        if (context->blksize <= TFTPD_MTU_DATA) {

            if (globals.io.mtu.s == INVALID_SOCKET) {

                EnterCriticalSection(&globals.io.cs); {

                    if (globals.service.shutdown) {
                        TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_UNDEFINED, "TFTPD service is stopping.");
                        LeaveCriticalSection(&globals.io.cs);
                        return (FALSE);
                    }

                    TftpdIoInitializeSocketContext(&globals.io.mtu, &addr, NULL);

                    if (globals.io.mtu.s != INVALID_SOCKET) {
                        context->socket = &globals.io.mtu;
                    } else {
                        context->socket = &globals.io.master;
                        if (context->options) {
                            TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                                         "TftpdIoAssignSocket(): Removing requested blksize = %d "
                                         "option since we failed to create the MTU-size socket.\n",
                                         context->blksize));
                            context->options &= ~TFTPD_OPTION_BLKSIZE;
                        }
                    }

                } LeaveCriticalSection(&globals.io.cs);

            } else {

                context->socket = &globals.io.mtu;

            } // if (globals.io.mtu.s == INVALID_SOCKET)

        } else if (context->blksize <= TFTPD_MAX_DATA) {

            if (globals.io.max.s == INVALID_SOCKET) {

                EnterCriticalSection(&globals.io.cs); {

                    if (globals.service.shutdown) {
                        TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_UNDEFINED, "TFTPD service is stopping.");
                        LeaveCriticalSection(&globals.io.cs);
                        return (FALSE);
                    }

                    TftpdIoInitializeSocketContext(&globals.io.max, &addr, NULL);

                    if (globals.io.max.s != INVALID_SOCKET) {
                        context->socket = &globals.io.max;
                    } else {
                        context->socket = &globals.io.master;
                        if (context->options) {
                            TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                                         "TftpdIoAssignSocket(): Removing requested blksize = %d "
                                         "option since we failed to create the MAX-size socket.\n",
                                         context->blksize));
                            context->options &= ~TFTPD_OPTION_BLKSIZE;
                        }
                    }

                } LeaveCriticalSection(&globals.io.cs);

            } else {

                context->socket = &globals.io.max;

            } // if (globals.io.max.s == INVALID_SOCKET)

        }

    } // (context->blksize <= TFTPD_DEF_DATA)

    return (TRUE);

} // TftpdIoAssignSocket()


BOOL
TftpdIoDestroySocketContext(PTFTPD_SOCKET socket) {

    NTSTATUS status;
    SOCKET s;

    if (socket->s == INVALID_SOCKET)
        return (TRUE);

    TFTPD_DEBUG((TFTPD_TRACE_IO,
                 "TftpdIoDestroySocketContext(socket = %s).\n",
                 ((socket == &globals.io.master) ? "master" :
                 ((socket == &globals.io.def)    ? "def"    :
                 ((socket == &globals.io.mtu)    ? "mtu"    :
                 ((socket == &globals.io.max)    ? "max"    :
                 "private")))) ));

    // Disable further buffer posting.
    socket->lowWaterMark = 0;
    
    if (socket->context == NULL) {

        if (!UnregisterWait(socket->wSelectWait)) {
            DWORD error;
            if ((error = GetLastError()) != ERROR_IO_PENDING) {
                TFTPD_DEBUG((TFTPD_DBG_IO,
                             "TftpdIoDestroySocketContext: "
                             "UnregisterWait() failed, error 0x%08X.\n",
                             error));
                TftpdIoLeakSocketContext(socket);
                return (FALSE);
            }
        }
        socket->wSelectWait = NULL;

        CloseHandle(socket->hSelect);
        socket->hSelect = NULL;

    } // if (socket->context == NULL)

    // Kill the socket.  This will disable the FD_READ and FD_WRITE
    // event select, as well as cancel all pending overlapped operations
    // on it.  Add a buffer reference here so after we close the
    // socket we can test if there were never any buffers posted
    // which would cancel above in TftpdIoCompletionCallback so
    // we should deallocate socket here.

    // Kill it.
    InterlockedIncrement((PLONG)&socket->numBuffers);
    s = socket->s;
    socket->s = INVALID_SOCKET;
    if (closesocket(s) == SOCKET_ERROR) {
        TFTPD_DEBUG((TFTPD_DBG_IO,
                     "TftpdIoDestroySocketContext: "
                     "closesocket() failed, error 0x%08X.\n",
                     GetLastError()));
        socket->s = s;
        InterlockedDecrement((PLONG)&socket->numBuffers);
        TftpdIoLeakSocketContext(socket);
        return (FALSE);
    }
    if (InterlockedDecrement((PLONG)&socket->numBuffers) == -1)
        HeapFree(globals.hServiceHeap, 0, socket);

    return (TRUE);

} // TftpdIoDestroySocketContext()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\tftpd\process.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    process.c

Abstract:

    This module contains functions to handle processing of
    incoming datagrams and route them to the appropriate
    handlers.

Author:

    Jeffrey C. Venable, Sr. (jeffv) 01-Jun-2001

Revision History:

--*/

#include "precomp.h"


BOOL
TftpdProcessComplete(PTFTPD_BUFFER buffer) {

    PTFTPD_CONTEXT context = buffer->internal.context;
    DWORD state;

    TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                 "TftpdProcessComplete(context = %p).\n",
                 context));
    ASSERT(context->state & TFTPD_STATE_BUSY);

    // Reset the timer.
    if (!TftpdContextUpdateTimer(context)) {

        TftpdContextKill(context);
        TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_UNDEFINED, "Out of memory");
        return (FALSE);

    } // if (!TftpdContextUpdateTimer(context, buffer))

    // Clear the busy state.
    do {

        state = context->state;
        
        if (state & TFTPD_STATE_DEAD) {

            if (context->type == TFTPD_WRQ)
                return (TRUE);

            return (FALSE);

        }

    } while (InterlockedCompareExchange(&context->state,
                                        (state & ~TFTPD_STATE_BUSY),
                                        state) != state);

    return (TRUE);

} // TftpdProcessComplete()


void CALLBACK
TftpdProcessTimeout(PTFTPD_CONTEXT context, BOOLEAN timedOut) {

    PTFTPD_BUFFER buffer = NULL;
    LONG reference;

    //
    // The timer's reference to the context is a special case becase
    // the context cannot cleanup until the timer is successfully
    // cancelled; if we're running here, that means cleanup must wait
    // for us.  However, if cleanup is active (TFTPD_STATE_DEAD), the
    // reference count might be zero; if so we just want to bail
    // because decrementing it back to zero causes double-delete.
    //

    do {
        if ((reference = context->reference) == 0)
            return;
    } while (InterlockedCompareExchange(&context->reference,
                                        reference + 1,
                                        reference) != reference);


    // Aquire busy-sending state.
    if (InterlockedCompareExchange(&context->state, TFTPD_STATE_BUSY, 0) != 0)
        goto exit_timer_callback;

    TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                 "TftpdProcessTimeout(context = %p).\n",
                 context));

#if defined(DBG)
    InterlockedIncrement((PLONG)&globals.performance.timeouts);
#endif // defined(DBG)

    // Allocate a buffer to either retry the previous DATA/ACK we last sent,
    // or to send an ERROR packet if we've reached max-retries.
    buffer = TftpdIoAllocateBuffer(context->socket);
    if (buffer == NULL)
        goto exit_timer_callback;
    CopyMemory(&buffer->internal.io.peer, &context->peer,
               sizeof(buffer->internal.io.peer));

    if (++context->retransmissions >= globals.parameters.maxRetries) {
#if defined(DBG)
        InterlockedIncrement((PLONG)&globals.performance.drops);
#endif // defined(DBG)
        TftpdContextKill(context);
        TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_UNDEFINED, "Timeout");
        goto exit_timer_callback;
    }

    buffer->internal.context = context;
    if (context->type == TFTPD_RRQ)
        buffer = TftpdReadResume(buffer);
    else
        buffer = TftpdWriteSendAck(buffer);

exit_timer_callback :

    if (buffer != NULL)
        TftpdIoPostReceiveBuffer(buffer->internal.socket, buffer);

    TftpdContextRelease(context);

} // TftpdProcessTimeout()


void
TftpdProcessError(PTFTPD_BUFFER buffer) {

    PTFTPD_CONTEXT context = NULL;

    context = TftpdContextAquire(&buffer->internal.io.peer);
    if (context == NULL)
        return;

    TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                 "TftpdProcessError(buffer = %p, context = %p).\n",
                 buffer, context));

    TftpdContextKill(context);
    TftpdContextRelease(context);

} // TftpdProcessError()


PTFTPD_BUFFER
TftpdProcessReceivedBuffer(PTFTPD_BUFFER buffer) {

    TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                 "TftpdProcessReceivedBuffer(buffer = %p).\n",
                 buffer));

    buffer->message.opcode = ntohs(buffer->message.opcode);

    switch (buffer->message.opcode) {

        //
        // Sending files to a client:
        //

        case TFTPD_RRQ :
            buffer = TftpdReadRequest(buffer);
            break;

        case TFTPD_ACK :
            buffer->message.ack.block = ntohs(buffer->message.ack.block);
            buffer = TftpdReadAck(buffer);
            break;

        //
        // Receiving files from a client:
        //

        case TFTPD_WRQ :
            buffer = TftpdWriteRequest(buffer);
            break;

        case TFTPD_DATA :
            buffer->message.data.block = ntohs(buffer->message.data.block);
            buffer = TftpdWriteData(buffer);
            break;

        //
        // Other:
        //

        case TFTPD_ERROR :
            TftpdProcessError(buffer);
            break;

        default :
            // Just drop the packet.  Somehow we received a bogus datagram
            // that's not TFTP protocol (possibly a broadcast).
            break;

    } // switch (buffer->message.opcode)

    return (buffer);
    
} // TftpdProcessReceivedBuffer()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\tftpd\context.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    context.c

Abstract:

    This module contains functions to manage contexts for TFTP
    sessions with remote clients.

Author:

    Jeffrey C. Venable, Sr. (jeffv) 01-Jun-2001

Revision History:

--*/

#include "precomp.h"


void
TftpdContextLeak(PTFTPD_CONTEXT context) {

    PLIST_ENTRY entry;
    
    EnterCriticalSection(&globals.reaper.contextCS); {

        // If shutdown is occuring, we're in trouble anyways.  Just let it go.
        if (globals.service.shutdown) {
            LeaveCriticalSection(&globals.reaper.contextCS);
            if (InterlockedDecrement(&globals.io.numContexts) == -1)
                TftpdServiceAttemptCleanup();
            return;
        }

        TFTPD_DEBUG((TFTPD_TRACE_CONTEXT, "TftpdContextLeak(context = %p).\n", context));

        // Is the context already in the list?
        for (entry = globals.reaper.leakedContexts.Flink;
             entry != &globals.reaper.leakedContexts;
             entry = entry->Flink) {
            if (CONTAINING_RECORD(entry, TFTPD_CONTEXT, linkage) == context) {
                LeaveCriticalSection(&globals.reaper.contextCS);
                return;
            }
        }

        InsertHeadList(&globals.reaper.leakedContexts, &context->linkage);
        globals.reaper.numLeakedContexts++;
        TftpdContextAddReference(context);

    } LeaveCriticalSection(&globals.reaper.contextCS);

} // TftpdContextLeak()


BOOL
TftpdContextFree(
    PTFTPD_CONTEXT context
);

    
void CALLBACK
TftpdContextTimerCleanup(PTFTPD_CONTEXT context, BOOLEAN timeout) {

    TFTPD_DEBUG((TFTPD_TRACE_CONTEXT,
                 "TftpdContextTimerCleanup(context = %p).\n",
                 context));

    context->hTimer = NULL;
    if (!UnregisterWait(context->wWait)) {
        DWORD error;
        if ((error = GetLastError()) != ERROR_IO_PENDING) {
            TFTPD_DEBUG((TFTPD_DBG_CONTEXT,
                         "TftpdContextTimerCleanup(context = %p): "
                         "UnregisterWait() failed, error 0x%08X.\n",
                         context,
                         error));
            TftpdContextLeak(context);
            return;
        }
    }
    context->wWait = NULL;

    TftpdContextFree(context);

} // TftpdContextTimerCleanup()


BOOL
TftpdContextFree(PTFTPD_CONTEXT context) {

    DWORD numContexts;
    NTSTATUS status;

    TFTPD_DEBUG((TFTPD_TRACE_CONTEXT,
                 "TftpdContextFree(context = %p).\n",
                 context));

    if (context->wWait != NULL) {
        if (!UnregisterWait(context->wWait)) {
            DWORD error;
            if ((error = GetLastError()) != ERROR_IO_PENDING) {
                TFTPD_DEBUG((TFTPD_DBG_CONTEXT,
                             "TftpdContextFree(context = %p): "
                             "UnregisterWait() failed, error 0x%08X.\n",
                             context,
                             error));
                TftpdContextLeak(context);
                return (FALSE);
            }
        }
        context->wWait = NULL;
    }
    
    if (context->hTimer != NULL) {

        HANDLE hTimer;
        BOOL reset;

        TFTPD_DEBUG((TFTPD_TRACE_CONTEXT,
                     "TftpdContextFree(context = %p): "
                     "Deleting timer.\n",
                     context));

        // WriteFile() or ReadFile() may have signalled this event if they
        // last completed immediately.
        reset = ResetEvent(context->hWait);
        ASSERT(reset);
        ASSERT(context->wWait == NULL);
        if (!RegisterWaitForSingleObject(&context->wWait,
                                         context->hWait,
                                         (WAITORTIMERCALLBACKFUNC)TftpdContextTimerCleanup,
                                         context,
                                         INFINITE,
                                         (WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE))) {
            TFTPD_DEBUG((TFTPD_DBG_CONTEXT,
                         "TftpdContextFree(context = %p): "
                         "RegisterWaitForSingleObject() failed, error 0x%08X.\n",
                         context, GetLastError()));
            TftpdContextLeak(context);
            return (FALSE);
        }

        if (!DeleteTimerQueueTimer(globals.io.hTimerQueue,
                                   context->hTimer,
                                   context->hWait)) {
            DWORD error;
            if ((error = GetLastError()) != ERROR_IO_PENDING) {
                TFTPD_DEBUG((TFTPD_DBG_CONTEXT,
                             "TftpdContextFree(context = %p): "
                             "DeleteTimerQueueTimer() failed, error 0x%08X.\n",
                             context,
                             error));
                // The next call to TftpdContextFree() to recover this context from the
                // leak list will deregister the wait for us.
                TftpdContextLeak(context);
                return (FALSE);
            }
        }

        return (TRUE);

    } // if (context->hTimer != NULL)

    ASSERT(context->wWait == NULL);

    // If a private socket was used, destroy it.
    if ((context->socket != NULL) && context->socket->context)
        TftpdIoDestroySocketContext(context->socket);

    // Cleanup everything else.
    if (context->hFile != NULL)
        CloseHandle(context->hFile);
    if (context->hWait != NULL)
        CloseHandle(context->hWait);
    if (context->filename != NULL)
        HeapFree(globals.hServiceHeap, 0, context->filename);

    numContexts = InterlockedDecrement(&globals.io.numContexts);

    HeapFree(globals.hServiceHeap, 0, context);

    TFTPD_DEBUG((TFTPD_TRACE_CONTEXT,
                 "TftpdContextFree(context = %p): ### numContexts = %d.\n",
                 context, numContexts));
    if (numContexts == -1)
        TftpdServiceAttemptCleanup();

    return (TRUE);

} // TftpdContextFree()


DWORD
TftpdContextAddReference(PTFTPD_CONTEXT context) {

    DWORD result;
    
    result = InterlockedIncrement(&context->reference);
    TFTPD_DEBUG((TFTPD_TRACE_CONTEXT,
                 "TftpdContextAddReference(context = %p): reference = %d.\n",
                 context, result));

    return (result);

} // TftpdContextAddReference()


PTFTPD_CONTEXT
TftpdContextAllocate() {

    PTFTPD_CONTEXT context = NULL;
    DWORD numContexts;
    
    TFTPD_DEBUG((TFTPD_TRACE_CONTEXT, "TftpdContextAllocate().\n"));

    if (globals.reaper.leakedContexts.Flink != &globals.reaper.leakedContexts) {

        BOOL failAllocate = FALSE;

        // Try to recover leaked contexts.
        EnterCriticalSection(&globals.reaper.contextCS); {

            PLIST_ENTRY entry;
            while ((entry = RemoveHeadList(&globals.reaper.leakedContexts)) !=
                   &globals.reaper.leakedContexts) {

                globals.reaper.numLeakedContexts--;
                if (!TftpdContextFree(CONTAINING_RECORD(entry, TFTPD_CONTEXT, linkage))) {
                    // If the free failed, the context is readded to the leak list.
                    // Free the reference from it having already been on the leak list.
                    TftpdContextRelease(context);
                    failAllocate = TRUE;
                    break;
                }

            }

        } LeaveCriticalSection(&globals.reaper.contextCS);

        if (failAllocate)
            goto exit_allocate_context;

    } // if (globals.reaper.leakedContexts.Flink != &globals.reaper.leakedContexts)

    context = (PTFTPD_CONTEXT)HeapAlloc(globals.hServiceHeap, HEAP_ZERO_MEMORY, sizeof(TFTPD_CONTEXT));
    if (context == NULL) {
        TFTPD_DEBUG((TFTPD_DBG_CONTEXT,
                     "TftpdContextAllocate(): HeapAlloc() failed, error = 0x%08X.\n",
                     GetLastError()));
        return (NULL);
    }

    InitializeListHead(&context->linkage);
    context->sorcerer = -1;

    numContexts = InterlockedIncrement(&globals.io.numContexts);
    TFTPD_DEBUG((TFTPD_TRACE_CONTEXT, "TftpdContextAllocate(): ### numContexts = %d.\n", numContexts));

    if (globals.service.shutdown)
        TftpdContextFree(context), context = NULL;

exit_allocate_context :

    return (context);

} // TftpdContextAllocate()


DWORD
TftpdContextHash(PSOCKADDR_IN addr) {

    return ((addr->sin_addr.s_addr + addr->sin_port) % globals.parameters.hashEntries);

} // TftpdContextHash()


BOOL
TftpdContextAdd(PTFTPD_CONTEXT context) {

    PLIST_ENTRY entry;
    DWORD index;

    TFTPD_DEBUG((TFTPD_TRACE_CONTEXT, "TftpdContextAdd(context = %p).\n", context));

    index = TftpdContextHash(&context->peer);

    EnterCriticalSection(&globals.hash.table[index].cs); {

        if (globals.service.shutdown) {
            LeaveCriticalSection(&globals.hash.table[index].cs);
            return (FALSE);
        }

        // Is the context already in the table?
        for (entry = globals.hash.table[index].bucket.Flink;
             entry != &globals.hash.table[index].bucket;
             entry = entry->Flink) {

            PTFTPD_CONTEXT c = CONTAINING_RECORD(entry, TFTPD_CONTEXT, linkage);
            if ((c->peer.sin_addr.s_addr == context->peer.sin_addr.s_addr) &&
                (c->peer.sin_port == context->peer.sin_port)) {
                TFTPD_DEBUG((TFTPD_DBG_CONTEXT,
                             "TftpdContextAdd(context = %p): TID already exists.\n",
                             context));
                LeaveCriticalSection(&globals.hash.table[index].cs);
                return (FALSE);
            }

        }

        TftpdContextAddReference(context);
        InsertHeadList(&globals.hash.table[index].bucket, &context->linkage);

#if defined(DBG)
        {
            DWORD numEntries, maxClients;
            numEntries = InterlockedIncrement((PLONG)&globals.hash.numEntries);
            InterlockedIncrement((PLONG)&globals.hash.table[index].numEntries);
            while (numEntries > (maxClients = globals.performance.maxClients))
                InterlockedCompareExchange((PLONG)&globals.performance.maxClients, numEntries, maxClients);
        }
#endif // defined(DBG)

    } LeaveCriticalSection(&globals.hash.table[index].cs);

    return (TRUE);

} // TftpdContextAdd()


void
TftpdContextRemove(PTFTPD_CONTEXT context) {

    PLIST_ENTRY entry;
    DWORD index;
    
    TFTPD_DEBUG((TFTPD_TRACE_CONTEXT, "TftpdContextRemove(context = %p).\n", context));

    index = TftpdContextHash(&context->peer);

    EnterCriticalSection(&globals.hash.table[index].cs); {

        // Validate that the context is still in the bucket and
        // wasn't already removed by another thread.
        for (entry = globals.hash.table[index].bucket.Flink;
             entry != &globals.hash.table[index].bucket;
             entry = entry->Flink) {

            PTFTPD_CONTEXT c;

            c = CONTAINING_RECORD(entry, TFTPD_CONTEXT, linkage);

            if (c == context) {

                // Pull the context out of the hash-table.
                RemoveEntryList(&context->linkage);
                TftpdContextRelease(context);

#if defined(DBG)
                InterlockedDecrement((PLONG)&globals.hash.numEntries);
                InterlockedDecrement((PLONG)&globals.hash.table[index].numEntries);
#endif // defined(DBG)

                break;

            } // if (c == context)

        }

    } LeaveCriticalSection(&globals.hash.table[index].cs);

} // TftpdContextRemove()


void
TftpdContextKill(PTFTPD_CONTEXT context) {

    // Set the dead flag in the context state.
    while (TRUE) {
        DWORD state = context->state;
        if (state & TFTPD_STATE_DEAD)
            return;
        if (InterlockedCompareExchange(&context->state, (state | TFTPD_STATE_DEAD), state) == state)
            break;
    }

    TFTPD_DEBUG((TFTPD_TRACE_CONTEXT, "TftpdContextKill(context = %p).\n", context));

    // Add a reference count to the context for ourselves so it won't free
    // itself from under us as we close the file below.
    TftpdContextAddReference(context);

    // Remove it from the hash-table.
    TftpdContextRemove(context);

    // Close the file.  This will force any outstanding overlapped read or write operations
    // to complete immediately, deregister their waits, and decrement their reference
    // to this context.
    if (context->hFile != NULL) {
        CloseHandle(context->hFile);
        context->hFile = NULL;
    }

    // Release our kill reference.
    TftpdContextRelease(context);

} // TftpdContextKill()


BOOL
TftpdContextUpdateTimer(PTFTPD_CONTEXT context) {

    ULONG timeout = context->timeout;

    ASSERT(context->state & TFTPD_STATE_BUSY);

    if (!timeout) {
        unsigned int x;
        timeout = 1000;
        for (x = 0; x < context->retransmissions; x++)
            timeout *= 2;
        if (timeout > 10000)
            timeout = 10000;
    }

    // Update the retransmission timer.
    return (ChangeTimerQueueTimer(globals.io.hTimerQueue, context->hTimer, timeout, 720000));

} // TftpdContextUpdateTimer()


PTFTPD_CONTEXT
TftpdContextAquire(PSOCKADDR_IN addr) {

    PTFTPD_CONTEXT context = NULL;
    PLIST_ENTRY entry;
    DWORD index;

    if (globals.service.shutdown)
        goto exit_acquire;

    index = TftpdContextHash(addr);

    EnterCriticalSection(&globals.hash.table[index].cs); {

        if (!globals.service.shutdown) {

            for (entry = globals.hash.table[index].bucket.Flink;
                 entry != &globals.hash.table[index].bucket;
                 entry = entry->Flink) {

                PTFTPD_CONTEXT c;
                
                c = CONTAINING_RECORD(entry, TFTPD_CONTEXT, linkage);

                if ((c->peer.sin_addr.s_addr == addr->sin_addr.s_addr) &&
                    (c->peer.sin_port == addr->sin_port)) {
                    context = c;
                    TftpdContextAddReference(context);
                    break;
                }

            }

        } // if (!globals.service.shutdown)

    } LeaveCriticalSection(&globals.hash.table[index].cs);

    if ((context != NULL) && (context->state & TFTPD_STATE_DEAD)) {
        TftpdContextRelease(context);
        context = NULL;
    }

exit_acquire :
    
    TFTPD_DEBUG((TFTPD_TRACE_CONTEXT,
                 "TftpdContextAquire(TID = %s:%d): context = %p.\n",
                 inet_ntoa(addr->sin_addr), addr->sin_port, context));

    return (context);

} // TftpdContextAquire()


DWORD
TftpdContextRelease(PTFTPD_CONTEXT context) {

    DWORD reference;

    TFTPD_DEBUG((TFTPD_TRACE_CONTEXT, "TftpdContextRelease(context = %p).\n", context));

    // When a context is killable, only its retransmit timer will have a reference to it.
    reference = InterlockedDecrement(&context->reference);
    if (reference == 0)
        TftpdContextFree(context);

    return (reference);

} // TftpdContextRelease()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\server\tlntsvr\tlntsvr.cpp ===
// TlntSvr.cpp : This file contains the
// Created:  Feb '98
// History:
// Copyright (C) 1998 Microsoft Corporation
// All rights reserved.
// Microsoft Confidential

// TlntSvr.cpp : Implementation of WinMain


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f TlntSvrps.mk in the project directory.

#include <Stdafx.h>

#include <Stdio.h>
#include <stdlib.h>
#include <time.h>
#include <WinError.h>
#include <TChar.h>
#include <New.h>
#include <OleAuto.h>

#include <Resource.h>
#include <Debug.h>
#include <MsgFile.h>
#include <TlntUtils.h>
#include <regutil.h>
#include <TlntSvr.h>
#ifdef WHISTLER_BUILD
#include "tlntsvr_i.c"
#else
#ifndef NO_PCHECK
#include <PiracyCheck.h>
#endif
#endif
#include <TelnetD.h>
#include <TelntSrv.h>
#include <EnumData.h>
#include <EnCliSvr.h>

#include "locresman.h"
#include <lm.h>
#include <lmaccess.h>

#pragma warning(disable:4100)

#define heapalloc(x) (HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, x))
#define heapfree(x)  (HeapFree(GetProcessHeap(), 0, x))

CTelnetService* g_pTelnetService = 0;
HANDLE  *g_phLogFile = NULL;
LPWSTR  g_pszTelnetInstallPath = NULL;
LPWSTR  g_pszLogFile = NULL;
LONG    g_lMaxFileSize = 0;
bool    g_fIsLogFull = false;
bool    g_fLogToFile = false;

#ifdef WHISTLER_BUILD
DWORD g_dwStartType = SERVICE_DISABLED;
#else
DWORD g_dwStartType = SERVICE_AUTO_START;
#endif

HINSTANCE g_hInstRes = NULL;

void LogEvent ( WORD wType, DWORD dwEventID, LPCTSTR pFormat, ... );

using namespace _Utils;
using CDebugLevel::TRACE_DEBUGGING;
using CDebugLevel::TRACE_HANDLE;
using CDebugLevel::TRACE_SOCKET;

TCHAR g_szErrRegDelete[ MAX_STRING_LENGTH ];
TCHAR g_szErrOpenSCM  [ MAX_STRING_LENGTH ];
TCHAR g_szErrOpenSvc  [ MAX_STRING_LENGTH ];
TCHAR g_szErrCreateSvc[ MAX_STRING_LENGTH ];
TCHAR g_szErrDeleteSvc[ MAX_STRING_LENGTH ];
TCHAR g_szMaxConnectionsReached[ MAX_STRING_LENGTH ];
TCHAR g_szLicenseLimitReached  [ MAX_STRING_LENGTH ];
extern PSID localLocalSid;


/////////////////////////////////////////////////////////////////////////////
//

LPWSTR
GetDefaultLoginScriptFullPath( )
{
    HKEY hk;
    DWORD dwDisp = 0;

    if( TnSecureRegCreateKeyEx( HKEY_LOCAL_MACHINE, REG_SERVICE_KEY, NULL, NULL, 
                        REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED , NULL, &hk, &dwDisp, 0 ) )
    {
        return NULL;
    }

    if( !GetRegistryString( hk, NULL, L"ImagePath", &g_pszTelnetInstallPath, L"",FALSE ) )
    {
        return NULL;
    }

    RegCloseKey( hk );

    if( !g_pszTelnetInstallPath )
    {
        //ImagePath key was not created.
        return NULL;
    }

    LPWSTR pLastBackSlash = wcsrchr( g_pszTelnetInstallPath, L'\\' );
    if( pLastBackSlash != NULL )
    {
        //Nuke the trailing "tlntsvr.exe"
        *pLastBackSlash = 0;
    }

    DWORD   length_required = wcslen( g_pszTelnetInstallPath ) + wcslen( DEFAULT_LOGIN_SCRIPT ) + 2; // one for \ and one more for NULL in the end

    LPWSTR lpszDefaultLoginScriptFullPathName = new WCHAR[ length_required ];
    if( !lpszDefaultLoginScriptFullPathName )
    {
        return NULL;
    }

    _snwprintf(lpszDefaultLoginScriptFullPathName, length_required - 1, L"%s\\%s", g_pszTelnetInstallPath, DEFAULT_LOGIN_SCRIPT);
    lpszDefaultLoginScriptFullPathName[length_required-1] = 0; // When the buffer is full snwprintf could return non-null terminated string

    return lpszDefaultLoginScriptFullPathName;
}

/*Mem allocation by this function.
To be deleted by the caller.
It just forms the reg key as required by console.
See comments for HandleJapSpecificRegKeys */
bool
FormTlntSessKeyForCmd( LPWSTR *lpszKey )
{

    WCHAR   szPathName[MAX_PATH + 1 ] = { 0 };
    WCHAR   session_path[MAX_PATH*2];

    if( !GetModuleFileName( NULL, szPathName, MAX_PATH ) )
    {
        return ( FALSE );
    }

    //
    // Nuke the trailing "tlntsvr.exe"
    //
    LPTSTR pSlash = wcsrchr( szPathName, L'\\' );

    if( pSlash == NULL )
    {
        return ( FALSE );
    }
    else
    {
        *pSlash = L'\0';
    }

    wint_t ch = L'\\';
    LPTSTR pBackSlash = NULL;

    //
    // Replace all '\\' with '_' This format is required for the console to
    // interpret the key.
    //
    while ( 1 )
    {
        pBackSlash = wcschr( szPathName, ch );

        if( pBackSlash == NULL )
        {
            break;
        }
        else
        {
            *pBackSlash = L'_';
        }
    }

    _snwprintf(session_path, MAX_PATH*2 - 1, L"%s_tlntsess.exe", szPathName);
    session_path[MAX_PATH*2 - 1] = L'\0'; // snwprintf could return non-null terminated string, if the buffer size is an exact fit

    DWORD length_required = wcslen( REG_LOCALSERVICE_CONSOLE_KEY ) + wcslen( session_path ) + 2;
    *lpszKey = new WCHAR[ length_required ];

    if( *lpszKey == NULL )
    {
        return( FALSE );
    }

    _snwprintf(*lpszKey, length_required - 1, L"%s\\%s", REG_LOCALSERVICE_CONSOLE_KEY, session_path );
    (*lpszKey)[length_required - 1] = L'\0'; // snwprintf could return non-null terminated string, if the buffer size is an exact fit

    return ( TRUE );
}

//
// If Japanese codepage, then we need to verify 3 registry settings for
// console fonts:
//  HKEY_USERS\.DEFAULT\Console\FaceName :REG_SZ:lr SVbN
//          where the FaceName is "MS gothic" written in Japanese full widthKana
//  HKEY_USERS\.DEFAULT\Console\FontFamily:REG_DWORD:0x36
//  HKEY_USERS\.DEFAULT\Console\C:_SFU_Telnet_tlntsess.exe\FontFamily:REG_DWORD: 0x36
//  where the "C:" part is the actual path to SFU installation
//
//
bool
HandleFarEastSpecificRegKeys( void )
{
    HKEY hk;
    DWORD dwFontSize = 0;
    const TCHAR szJAPFaceName[] = { 0xFF2D ,0xFF33 ,L' ' ,0x30B4 ,0x30B7 ,0x30C3 ,0x30AF ,L'\0' };
    const TCHAR szCHTFaceName[] = { 0x7D30 ,0x660E ,0x9AD4 ,L'\0'};
    const TCHAR szKORFaceName[] = { 0xAD74 ,0xB9BC ,0xCCB4 ,L'\0'};
    const TCHAR szCHSFaceName[] = { 0x65B0 ,0x5B8B ,0x4F53 ,L'\0' };
    TCHAR szFaceNameDef[MAX_STRING_LENGTH];
    DWORD dwCodePage = GetACP();
    DWORD dwFaceNameSize = 0;
    DWORD dwFontFamily = 54;
    DWORD dwFontWeight = 400;
    DWORD dwHistoryNoDup = 0;
    DWORD dwSize = 0;


    switch (dwCodePage)
    {
        case JAP_CODEPAGE:
        	_tcscpy(szFaceNameDef, szJAPFaceName); //On JAP, set the FaceName to "MS Gothic"
            dwFontSize = JAP_FONTSIZE;
            break;
        case CHT_CODEPAGE:
        	_tcscpy(szFaceNameDef, szCHTFaceName); //On CHT, set the FaceName to "MingLiU"
            dwFontSize = CHT_FONTSIZE;
            break;
        case KOR_CODEPAGE:
        	_tcscpy(szFaceNameDef, szKORFaceName);//On KOR, set the FaceName to "GulimChe"
            dwFontSize = KOR_FONTSIZE;
            break;
        case CHS_CODEPAGE:
        	_tcscpy(szFaceNameDef, szCHSFaceName);//On CHS, set the FaceName to "NSimSun"
            dwFontSize = CHS_FONTSIZE;
            break;
        default:
            _tcscpy(szFaceNameDef,L"\0");
            break;
    }

    dwFaceNameSize = ( _tcslen( szFaceNameDef ) + 1 ) * sizeof( TCHAR );

    if( !RegOpenKeyEx( HKEY_CURRENT_USER, REG_LOCALSERVICE_CONSOLE_KEY, 0, KEY_SET_VALUE, &hk ) )
    {
        RegSetValueEx( hk, L"FaceName", 0, REG_SZ, (LPBYTE) szFaceNameDef, 
        	dwFaceNameSize );

        DWORD dwVal;
        dwSize = sizeof( DWORD );
        SETREGISTRYDW( dwFontFamily, NULL, hk, L"FontFamily", dwVal,dwSize );
        
        RegCloseKey( hk );
        return ( TRUE );
    }

    return ( FALSE );

}

bool
CreateRegistryEntriesIfNotPresent( void )
{
    HKEY hk = NULL;
    HKEY hkDef = NULL;
    HKEY hkReadConf = NULL;
    DWORD dwCreateInitially;
    LPWSTR pszCreateInitially = NULL;
    LPWSTR lpszDefaultLoginScriptFullPathName = NULL;

    DWORD dwType;
    DWORD dwSize  = sizeof( DWORD );
    DWORD dwValue = NULL;
    DWORD dwDisp = 0;
    DWORD dwSecurityMechanism = DEFAULT_SECURITY_MECHANISM;
    BOOL fFound = FALSE;

    if( TnSecureRegCreateKeyEx( HKEY_LOCAL_MACHINE, REG_PARAMS_KEY, NULL, NULL, 
                        REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED , NULL, &hk, &dwDisp, 0 ) )
    {
        return ( FALSE );
    }

    /*++
        When the telnet server is getting modified from w2k telnet, there'll be NTLM value present
        under HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\TelnetServer\1.0
        This is treated as a gateway for updating the registry. Since this value is present,
        we are updating from win2k telnet to any upper version ( Garuda or whistler ). In that case,
        we need to map the data contained by this value into the corresponding data for
        "SecurityMechanism". 
        If we are upgrading from win2k, the HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\TelnetServer\Defaults
        key is deleted and created again. According to the telnet spec, all the values under this key
        should be overwritten by the default values. So instead of checking all values, deleting the key -
        which will create all the values with the defaults in them.
        After updating all the values, we create a new value called UpdateTo and put data '3' in that.
        This is defined by TELNET_LATEST_VERSION. Next version should be modifying this to the proper
        value.
        After the values are once modified, we need not go through the whole procedure again. 
        Now the open issue here is : 
            What if admin changes the registry value after once they are updated ?
            Well, no one is supposed to edit the registry. So the service would not start properly
            if the registry values are changed with invalid data in them.

        Once the UpdatedTo value is created, the registry will never be changed. Few values need to be
        read because some global variables are initialized with them. 
        This is done at the end of the function.
    --*/
    if( ERROR_SUCCESS == (RegQueryValueEx( hk, L"UpdatedTo", NULL, &dwType, ( LPBYTE )(&dwValue), 
        &dwSize )))
    {
        if(dwValue == LATEST_TELNET_VERSION )
        {
            goto Done;
        }
    }

    dwDisp=0;
    //ignore the failure... since we are immediately doing RegCreateKey(). If RegDeleteKey() fails due to
    //some permission problems, RegCreateKey() will also fail. In other cases, we should continue.
    RegDeleteKey(HKEY_LOCAL_MACHINE, REG_DEFAULTS_KEY);
    
    if( TnSecureRegCreateKeyEx( HKEY_LOCAL_MACHINE, REG_DEFAULTS_KEY, NULL, NULL, 
                        REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED , NULL, &hkDef, &dwDisp , 0 ))
    {
        return(FALSE);
    }

    if( ERROR_SUCCESS == (RegQueryValueEx( hk, L"NTLM", NULL, &dwType, ( LPBYTE )(&dwValue), 
        &dwSize )))
    {
        fFound = TRUE;
        switch (dwValue)
        {
            case 0:
                dwValue = NO_NTLM;
                break;
            case 1:
                dwValue = NTLM_ELSE_OR_LOGIN;
                break;
            case 2:
                dwValue = NTLM_ONLY;
                break;
            default:
                //should never happen
                _TRACE(TRACE_DEBUGGING,"ERROR: NTLM contains unexpected data");
                return(FALSE);
        }
        dwSecurityMechanism = dwValue;
        if( !GetRegistryDW( hk, NULL, L"SecurityMechanism", &dwCreateInitially,
                            dwSecurityMechanism ,fFound) )
        {
            return ( FALSE );
        }
        
        if(ERROR_SUCCESS != RegDeleteValue(hk,L"NTLM"))
        {
            _TRACE(TRACE_DEBUGGING,"CreateRegistryEntries : RegDelete failed");
            return(FALSE);
        }
        if(ERROR_SUCCESS!=RegDeleteKey(hk,L"Performance"))
        {
            _TRACE(TRACE_DEBUGGING,"CreateRegistryEntries : RegDeleteKey failed");
            return(FALSE);
        }
    }
   
    dwDisp = 0;
    if( TnSecureRegCreateKeyEx( HKEY_LOCAL_MACHINE, READ_CONFIG_KEY, NULL, NULL, 
                        REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED , NULL, &hkReadConf, &dwDisp, 0 ) )
    {
        return( FALSE );
    }

    if(!GetRegistryDWORD(hkReadConf,L"Defaults",&dwCreateInitially,1,TRUE))
    {
        return(FALSE);
    }
    
    RegCloseKey( hkReadConf );

    if( !GetRegistryDW( hk, hkDef, L"MaxConnections", &dwCreateInitially,
                        DEFAULT_MAX_CONNECTIONS,FALSE) )
    {
        return ( FALSE );
    }

    if( !GetRegistryDW( hk, hkDef, L"TelnetPort", &dwCreateInitially,
                        DEFAULT_TELNET_PORT,FALSE) )
    {
        return ( FALSE );
    }

    if( !GetRegistryString( hk, hkDef, L"DefaultShell", &pszCreateInitially,
                        DEFAULT_SHELL,fFound ) )
    {
        return ( FALSE );
    }

    delete[] pszCreateInitially;
    pszCreateInitially = NULL;

    if( !GetRegistryString( hk, hkDef, L"ListenToSpecificIpAddr", &pszCreateInitially,
                        DEFAULT_IP_ADDR,fFound ) )
    {
        return ( FALSE );
    }

    delete[] pszCreateInitially;
    pszCreateInitially = NULL;

    if( !GetRegistryString( hk, hkDef, SWITCH_TO_KEEP_SHELL_RUNNING, &pszCreateInitially,
                        DEFAULT_SWITCH_TO_KEEP_SHELL_RUNNING,fFound ) )
    {
        return ( FALSE );
    }

    delete[] pszCreateInitially;
    pszCreateInitially = NULL;

    if( !GetRegistryString( hk, hkDef, SWITCH_FOR_ONE_TIME_USE_OF_SHELL, 
                        &pszCreateInitially,
                        DEFAULT_SWITCH_FOR_ONE_TIME_USE_OF_SHELL,fFound ) )
    {
        return ( FALSE );
    }

    delete[] pszCreateInitially;
    pszCreateInitially = NULL;

    if( !GetRegistryString( hk, hkDef, L"DefaultDomain", &pszCreateInitially,
                        DEFAULT_DOMAIN,FALSE) )
    {
        return ( FALSE );
    }

    delete[] pszCreateInitially;
    pszCreateInitially = NULL;

    if( !GetRegistryString( hk, NULL, L"Shell", &pszCreateInitially, L"",fFound ) )
    {
        return false;
    }
    delete[] pszCreateInitially;
    pszCreateInitially = NULL;

    if( !GetRegistryDW( hk, hkDef, L"AllowTrustedDomain", &dwCreateInitially,
                        DEFAULT_ALLOW_TRUSTED_DOMAIN,FALSE) )
    {
        return ( FALSE );
    }

    if( !GetRegistryDW( hk, hkDef, L"MaxFailedLogins", &dwCreateInitially,
                        DEFAULT_MAX_FAILED_LOGINS,FALSE) )
    {
        return ( FALSE );
    }

    if( !GetRegistryDW( hk, hkDef, L"SecurityMechanism", &dwCreateInitially,
                            DEFAULT_SECURITY_MECHANISM ,FALSE) )
    {
        return ( FALSE );
    }
    
    if( !GetRegistryDW( hk, hkDef, L"EventLoggingEnabled", &dwCreateInitially,
                        DEFAULT_SYSAUDITING,fFound ) )
    {
        return ( FALSE );
    }

    if( !GetRegistryDW( hk, hkDef, L"LogNonAdminAttempts", &dwCreateInitially,
                        DEFAULT_LOGEVENTS,fFound ) )
    {
        return ( FALSE );
    }

    if( !GetRegistryDW( hk, hkDef, L"LogAdminAttempts", &dwCreateInitially,
                        DEFAULT_LOGADMIN,fFound ) )
    {
        return ( FALSE );
    }

    if( !GetRegistryDW( hk, hkDef, L"LogFailures", &dwCreateInitially,
                        DEFAULT_LOGFAILURES,fFound ) )
    {
        return ( FALSE );
    }

    //In SFU2.0, AltKeyMapping has 1 for TRUE and 2 for FALSE where as now we have
    // 1 for TRUE and 0 for FALSE. So if 'AltKeyMapping' value is found, we need to map it
    // to the correct data.
    if( ERROR_SUCCESS == (RegQueryValueEx( hk, L"AltKeyMapping", NULL, &dwType, ( LPBYTE )(&dwValue), 
        &dwSize )))
    {
        switch (dwValue)
        {
            case 1://In sfu2.0 and Garuda, AltKeyMapping ON = 1
                dwValue = ALT_KEY_MAPPING_ON;
                break;
            case 2: //In SFU 2.0, AltKeyMapping off = 2. In garuda, it's 0.
                dwValue = ALT_KEY_MAPPING_OFF;
                break;
            default:
                dwValue = ALT_KEY_MAPPING_ON;
                _TRACE(TRACE_DEBUGGING,"ERROR: AltKeyMapping contains unexpected data");
        }
    }
    else
    {
        dwValue = DEFAULT_ALT_KEY_MAPPING;
    }
    if( !GetRegistryDW( hk, hkDef, L"AltKeyMapping", &dwCreateInitially,
                        dwValue,TRUE) )
    {
        return ( FALSE );
    }

    if( !GetRegistryDW( hk, hkDef, L"IdleSessionTimeOut", &dwCreateInitially,
                        DEFAULT_IDLE_SESSION_TIME_OUT,fFound ) )
    {
        return ( FALSE );
    }

    if( !GetRegistryDW( hk, hkDef, L"IdleSessionTimeOutBkup", &dwCreateInitially,
                        DEFAULT_IDLE_SESSION_TIME_OUT,fFound ) )
    {
        return ( FALSE );
    }


    if( !GetRegistryDW( hk, hkDef, L"DisconnectKillAllApps", &dwCreateInitially,
                        DEFAULT_DISCONNECT_KILLALL_APPS,fFound ) )
    {
        return ( FALSE );
    }

    if( !GetRegistryDW( hk, hkDef, L"ModeOfOperation", &dwCreateInitially,
                        DEFAULT_MODE_OF_OPERATION,fFound ) )
    {
        return ( FALSE );
    }

    //Delete the Termcap entry. It will exist only when you are upgrading.
    //It will get created when the first session connects to the server.
    RegDeleteValue(hk,L"Termcap");

    if( !GetRegistryDW( hk, hkDef, L"UpdatedTo", &dwCreateInitially,
                        LATEST_TELNET_VERSION,TRUE) )
    {
        return ( FALSE );
    }

Done:
    /*++
        These things are needed to be done everytime at the net start because
        they initialize some global variables.
    --*/
    dwCreateInitially = 0;
    if( !GetRegistryDW( hk, hkDef, L"LogToFile", &dwCreateInitially,
                        DEFAULT_LOGTOFILE,fFound ) )
    {
        return ( FALSE );
    }

    if( dwCreateInitially )
    {
        g_fLogToFile = true;
    }

    if( !( lpszDefaultLoginScriptFullPathName
                = GetDefaultLoginScriptFullPath() ) )
    {
        return ( FALSE );
    }

    if( !GetRegistryString( hk, hkDef, L"LoginScript", &pszCreateInitially,
                        lpszDefaultLoginScriptFullPathName,FALSE) )
    {
        delete[] lpszDefaultLoginScriptFullPathName; 
        return ( FALSE );
    }

    delete[] pszCreateInitially;
    pszCreateInitially = NULL;
    delete[] lpszDefaultLoginScriptFullPathName; 

    if( !GetRegistryString( hk, hkDef, L"LogFile", &g_pszLogFile,
                        DEFAULT_LOGFILE,fFound ) )
    {
        return ( FALSE );
    }

    if( !GetRegistryDW( hk, hkDef, LOGFILESIZE, (DWORD *)&g_lMaxFileSize,
                        DEFAULT_LOGFILESIZE,fFound ) )
    {
        return ( FALSE );
    }

    RegCloseKey( hkDef );
    RegCloseKey( hk );

    return ( TRUE );
}

void CloseLogFile( LPWSTR *pszLogFile, HANDLE *hLogFile )
{
    delete[] ( *pszLogFile );
    *pszLogFile = NULL;
    if( *hLogFile ) // global variable
    TELNET_CLOSE_HANDLE( *hLogFile );    
    delete hLogFile;
}

void CloseAnyGlobalObjects()
{
    delete[] g_pszTelnetInstallPath;

   CloseLogFile( &g_pszLogFile, g_phLogFile );
}

bool InitializeLogFile( LPWSTR szLogFile, HANDLE *hLogFile )
{
    //open logfile handle
    //

    _chASSERT( hLogFile != NULL );
    _chASSERT( szLogFile != NULL );

    *hLogFile = NULL;
    LPWSTR szExpandedLogFile = NULL;
    
    if( !g_fLogToFile )
    {
        return ( TRUE );
    }

    if( wcscmp( szLogFile, L"" ) != 0 )
    {
        LONG lDistanceToMove = 0 ;
        if( !AllocateNExpandEnvStrings( szLogFile, &szExpandedLogFile) )
        {
            return( FALSE );
        }
        *hLogFile = CreateFile( szExpandedLogFile, GENERIC_WRITE | GENERIC_READ, 
            FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 
            FILE_ATTRIBUTE_NORMAL, NULL );
    	delete [] szExpandedLogFile;
        if( *hLogFile == INVALID_HANDLE_VALUE )
        {
            DWORD dwErr = GetLastError();
            *hLogFile = NULL;
            LogEvent( EVENTLOG_ERROR_TYPE, MSG_ERRLOGFILE, szLogFile );
            LogFormattedGetLastError( EVENTLOG_ERROR_TYPE, 0, dwErr );
            return( FALSE );
        }

        _chVERIFY2( SetFilePointer( *hLogFile, lDistanceToMove, &lDistanceToMove, FILE_END ) );
    }
    return ( TRUE );
}

bool InitializeGlobalObjects()
{
    _chASSERT ( g_hInstRes );

   if( !CreateRegistryEntriesIfNotPresent( ) )
   {
     return ( FALSE );
   }

   DWORD dwCodePage = GetACP();
   if ( dwCodePage == JAP_CODEPAGE || dwCodePage == CHS_CODEPAGE ||dwCodePage == CHT_CODEPAGE || dwCodePage == KOR_CODEPAGE )
   {
       //Fareast code page
       if( !HandleFarEastSpecificRegKeys() )
       {
           return( FALSE );
       }
   }

   g_phLogFile = new HANDLE;
   if( !g_phLogFile )
   {
       return ( FALSE );
   }

   InitializeLogFile( g_pszLogFile, g_phLogFile );
  
   return ( TRUE );
}

void WriteAuditedMsgsToFile( LPSTR szString )
{
    DWORD dwNumBytesWritten, dwMsgLength;
    LPSTR logStr = NULL;
    LPSTR logTime = NULL;
    UDATE uSysDate; //local time 
    DATE  dtCurrent;
    DWORD dwFlags = VAR_VALIDDATE;
    BSTR  szDate = NULL;
    DWORD dwSize = 0;
    DWORD dwFileSizeLowWord = 0, dwFileSizeHighWord = 0;
    LARGE_INTEGER liActualSize = { 0 };

    GetLocalTime( &uSysDate.st );
    if( VarDateFromUdate( &uSysDate, dwFlags, &dtCurrent ) != S_OK )
    {
        goto AuditAbort;
    }

    if( VarBstrFromDate( dtCurrent, 
            MAKELCID( MAKELANGID( LANG_NEUTRAL, SUBLANG_SYS_DEFAULT ), SORT_DEFAULT ), 
            LOCALE_NOUSEROVERRIDE, &szDate ) != S_OK )
    {
        goto AuditAbort;
    }

    dwSize = WideCharToMultiByte( GetOEMCP(), 0, szDate, SysStringByteLen( szDate )/sizeof(TCHAR), 
                         NULL, 0, NULL, NULL ); 
    logTime = new CHAR[ dwSize+1 ]; 
    if( !logTime )
    {
        goto AuditAbort;    
    }

    dwSize = WideCharToMultiByte( GetOEMCP(), 0, szDate, SysStringByteLen( szDate )/sizeof(TCHAR), 
                         logTime, dwSize, NULL, NULL ); 

    logTime[dwSize] = 0;
	
    dwMsgLength = strlen( szString ) + strlen( logTime ) + strlen( NEW_LINE ) + 1;
    logStr = new CHAR[ dwMsgLength + 1 ];
    if( !logStr )
    {
        goto AuditAbort;
    }

    _snprintf( logStr, dwMsgLength, "%s %s%s", szString, logTime, NEW_LINE );
    
    dwFileSizeLowWord = GetFileSize( *g_phLogFile, &dwFileSizeHighWord );
    if( dwFileSizeLowWord == INVALID_FILE_SIZE )
    {
        goto AuditAbort;
    }

    liActualSize.QuadPart = dwFileSizeHighWord;
    liActualSize.QuadPart = liActualSize.QuadPart << (sizeof( dwFileSizeHighWord ) * 8);
    liActualSize.QuadPart += dwFileSizeLowWord + dwMsgLength;

    if( liActualSize.QuadPart <= (g_lMaxFileSize * ONE_MB) )
    {
        g_fIsLogFull = false;
        _chVERIFY2( WriteFile( *g_phLogFile, (LPCVOID) logStr,
                dwMsgLength, &dwNumBytesWritten, NULL ) );
    }
    else
    {
        if( !g_fIsLogFull )
        {
            //Log event
            g_fIsLogFull = true;
            LogEvent(EVENTLOG_INFORMATION_TYPE, LOGFILE_FULL, g_pszLogFile );
        }
    }
AuditAbort:
    SysFreeString( szDate );
    delete[] logTime;
    delete[] logStr;
}

BOOL GetInstalledTlntsvrPath( LPTSTR szPath, DWORD *dwSize )
{
    HKEY hKey = NULL;
    BOOL bResult = FALSE;
    DWORD dwDisp = 0;
    DWORD dwType = 0;

    if( !szPath || !dwSize ) 
    {
        goto GetInstalledTlntsvrPathAbort;
    }

    if( TnSecureRegCreateKeyEx( HKEY_LOCAL_MACHINE, REG_SERVICE_KEY, NULL, NULL, 
                        REG_OPTION_NON_VOLATILE, KEY_QUERY_VALUE, NULL, &hKey, &dwDisp, 0 ) )
    {
        goto GetInstalledTlntsvrPathAbort;
    }

    if( RegQueryValueEx( hKey, L"ImagePath", NULL, &dwType, ( LPBYTE )szPath, dwSize) )
    {
        goto GetInstalledTlntsvrPathAbort;
    }

    bResult = TRUE;

GetInstalledTlntsvrPathAbort:
    if( hKey )
    {
        RegCloseKey( hKey );
    }

    return bResult;
}

void Regsvr32IfNotAlreadyDone()
{
    TCHAR szPath[MAX_PATH+1];
    TCHAR szInstalledTlntsvr[MAX_PATH+1];
    DWORD dwSize = 2* ( MAX_PATH + 1 ); //in bytes;
    CRegKey keyAppID;
    LONG lRes = 0;
    CRegKey key;
    TCHAR szValue[_MAX_PATH];
    DWORD dwLen = _MAX_PATH;
    LPTSTR szTelnetPath = NULL;
    LPTSTR szInstalledDll = NULL;
    STARTUPINFO sinfo;
    PROCESS_INFORMATION pinfo;
    WCHAR szApp[MAX_PATH+14];

    lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("CLSID"));
    if (lRes != ERROR_SUCCESS)
        return;
    
    lRes = key.Open( keyAppID, L"{FE9E48A2-A014-11D1-855C-00A0C944138C}" );
    if (lRes != ERROR_SUCCESS)
        return;

    lRes = key.QueryValue(szValue, _T("Default"), &dwLen);

    keyAppID.Close();
    key.Close();

    //Get the Installed service path from HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\TlntSvr\ImagePath
    if( !GetInstalledTlntsvrPath( szInstalledTlntsvr, &dwSize ) )
    {
        return;
    }

    //path contains tlntsvr.exe at the tail
    //truncate at the last '\' - so *szTelnetPath will have z:\some\folder
    szTelnetPath = wcsrchr( szInstalledTlntsvr, L'\\' );
    if(szTelnetPath)
        *szTelnetPath = L'\0';

    //HKEY_CLASSES_ROOT\CLSID\{FE9E48A2-A014-11D1-855C-00A0C944138C}\InProcServer32
    //truncate at last '\'
    szInstalledDll = wcsrchr( szValue,  L'\\' );
    if(szInstalledDll)
        *szInstalledDll = L'\0';

    if( lstrcmpi( szInstalledTlntsvr, szValue ) == 0 ) 
    {
        //Since both the paths match, our dll is already registered
        return;
    }

    _tcscpy(szPath, L"regsvr32.exe /s " );
    _tcscat(szPath, szInstalledTlntsvr );
    _tcscat(szPath, L"\\tlntsvrp.dll");

    SfuZeroMemory(&sinfo, sizeof(STARTUPINFO));
    sinfo.cb = sizeof(STARTUPINFO);

    if(!GetSystemDirectory(szApp,MAX_PATH))
    {
        return;
    }
    wcsncat(szApp,L"\\regsvr32.exe",13);
    szApp[MAX_PATH+13] = L'\0';
    //initiate Regsvr32 /s path\tlntsvrp.dll
    _TRACE(TRACE_DEBUGGING,L"Calling regsvr32 with szApp = %s and szPath = %s",szApp,szPath);
    if ( CreateProcess( szApp, szPath, NULL, NULL,
                FALSE, 0, NULL, NULL, &sinfo, &pinfo) )
    {
        // wait for the process to finish.
        TlntSynchronizeOn(pinfo.hProcess);
        TELNET_CLOSE_HANDLE(pinfo.hProcess);
        TELNET_CLOSE_HANDLE(pinfo.hThread);
    }
}

DWORD 
WINAPI 
TelnetServiceThread ( ) 
{
    g_pTelnetService = CTelnetService::Instance();
    _chASSERT( g_pTelnetService != NULL );
 
    if( !g_pTelnetService )
    {
        return( FALSE );
    }

    if( !InitializeGlobalObjects() )
    {
        return ( FALSE );
    }

    _Module.SetServiceStatus(SERVICE_START_PENDING);

    //This is needed because W2k telnet server is registering tlntsvrp.dll of %systemdir%. Even if this fails the service can continue 
    Regsvr32IfNotAlreadyDone();

    LogEvent(EVENTLOG_INFORMATION_TYPE, MSG_STARTUP, _T("Service started"));

    g_pTelnetService->ListenerThread();

    _Module.SetServiceStatus( SERVICE_STOP_PENDING );

    CloseAnyGlobalObjects();
    
    delete g_pTelnetService;
    g_pTelnetService = NULL;
    
    return ( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
//

CServiceModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_EnumTelnetClientsSvr, CEnumTelnetClientsSvr)
END_OBJECT_MAP()


LPCTSTR 
FindOneOf
( 
    LPCTSTR p1, 
    LPCTSTR p2 
)
{
    while (*p1 != NULL)
    {
        LPCTSTR p = p2;
        while (*p != NULL)
        {
            if (*p1 == *p++)
                return p1+1;
        }
        p1++;
    }
    return NULL;
}


BOOL 
IsThatMe()
{
    HKEY hk = NULL;
    DWORD dwType;
    DWORD dwSize  = sizeof( DWORD );
    DWORD dwValue = 0;
    BOOL bIsThatMe = FALSE;
    DWORD dwDisp = 0;
    if( TnSecureRegCreateKeyEx( HKEY_LOCAL_MACHINE, REG_PARAMS_KEY, NULL, NULL, 
                        REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED , NULL, &hk, &dwDisp, 0 ) )
    {
        goto Done;
    }
    if( ERROR_SUCCESS == (RegQueryValueEx( hk, L"UpdatedTo", NULL, &dwType, ( LPBYTE )(&dwValue), 
        &dwSize )))
    {
        if(dwValue == LATEST_TELNET_VERSION )
        {
            bIsThatMe = TRUE;
            goto Done;
        }
    }
Done:
    if(hk)
    {
        RegCloseKey(hk);
    }
    return bIsThatMe;
}

BOOL
SetServiceConfigToSelf( LPTSTR szServiceName )
{
    BOOL bResult = FALSE;
    HKEY hKey = NULL;
    DWORD dwDisp = 0;
    WCHAR szMyName[ MAX_PATH + 1 ];
    DWORD dwSize = 0;
    LONG  lRes = 0;
    DWORD dwCreateInitially = 0;

    if( !szServiceName )
    {
        goto SetServiceConfigToSelfAbort;
    }

    // Get our Path.
    if ( !GetModuleFileName(NULL, szMyName, MAX_PATH) )  
    {
        goto SetServiceConfigToSelfAbort;
    }

    if( TnSecureRegCreateKeyEx( HKEY_LOCAL_MACHINE, REG_SERVICE_KEY, NULL, NULL, 
                        REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED , NULL, &hKey, &dwDisp, 0 ) )
    {
        goto SetServiceConfigToSelfAbort;
    }

    dwSize = ( wcslen( szMyName ) + 1 ) * 2 ;
    if( lRes = RegSetValueEx( hKey, L"ImagePath", NULL, REG_EXPAND_SZ, ( BYTE * ) szMyName, dwSize) )
    {
        goto SetServiceConfigToSelfAbort;
    }
    
    if( !GetRegistryDW( hKey, NULL, L"Start", &g_dwStartType,
                        g_dwStartType,FALSE) )
    {
        goto SetServiceConfigToSelfAbort;
    }

    bResult = TRUE;

SetServiceConfigToSelfAbort:
    if( hKey )
    {
        RegCloseKey( hKey );
    }

    return bResult;
}


/**************************
*   Appends the SID to current DACL of a file.
*   Parameters:
*       [in] SID to be appended
*       [in] Name of the file ( full path )
*       [in] Access Mask
*   Return values:
*       boolean to return success or failure.
*/
BOOL AddAccessRights(PSID pSid, LPCWSTR lpszFileName, DWORD dwAccessMask) {

   // File SD variables.
   PSECURITY_DESCRIPTOR pFileSD  = NULL;
   DWORD          cbFileSD       = 0;

   // New SD variables.
   PSECURITY_DESCRIPTOR pNewSD   = NULL;

   // ACL variables.
   PACL           pACL           = NULL;
   BOOL           fDaclPresent;
   BOOL           fDaclDefaulted;
   ACL_SIZE_INFORMATION AclInfo;

   // New ACL variables.
   PACL           pNewACL        = NULL;
   DWORD          cbNewACL       = 0;

   // Temporary ACE.
   LPVOID         pTempAce       = NULL;
   UINT           CurrentAceIndex;

   // Assume function will fail.
   BOOL           fResult        = FALSE;
   BOOL           fAPISuccess;

   __try {

      // 
      // Get security descriptor (SD) for file.
      // 
      fAPISuccess = GetFileSecurity(lpszFileName, 
            DACL_SECURITY_INFORMATION, pFileSD, 0, &cbFileSD);

      // API should have failed with insufficient buffer.
      if (fAPISuccess)
         __leave;
      else if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
         _TRACE(TRACE_DEBUGGING,L"GetFileSecurity() failed.  Error %d\n", 
               GetLastError());
         __leave;
      }

      pFileSD = heapalloc(cbFileSD);
      if (!pFileSD) {
         _TRACE(TRACE_DEBUGGING,L"HeapAlloc() failed.  Error %d\n", GetLastError());
         __leave;
      }

      fAPISuccess = GetFileSecurity(lpszFileName, 
            DACL_SECURITY_INFORMATION, pFileSD, cbFileSD, &cbFileSD);
      if (!fAPISuccess) {
         _TRACE(TRACE_DEBUGGING,L"GetFileSecurity() failed.  Error %d\n", 
               GetLastError());
         __leave;
      }

      // 
      // Initialize new SD.
      // 
      pNewSD = heapalloc(cbFileSD); // Should be same size as FileSD.
      if (!pNewSD) {
         _TRACE(TRACE_DEBUGGING,L"HeapAlloc() failed.  Error %d\n", GetLastError());
         __leave;
      }

      if (!InitializeSecurityDescriptor(pNewSD, 
            SECURITY_DESCRIPTOR_REVISION)) {
         _TRACE(TRACE_DEBUGGING,L"InitializeSecurityDescriptor() failed.  Error %d\n", 
               GetLastError());
         __leave;
      }

      // 
      // Get DACL from SD.
      // 
      if (!GetSecurityDescriptorDacl(pFileSD, &fDaclPresent, &pACL,
            &fDaclDefaulted)) {
         _TRACE(TRACE_DEBUGGING,L"GetSecurityDescriptorDacl() failed.  Error %d\n", 
               GetLastError());
         __leave;
      }

      // 
      // Get size information for DACL.
      // 
      AclInfo.AceCount = 0; // Assume NULL DACL.
      AclInfo.AclBytesFree = 0;
      AclInfo.AclBytesInUse = sizeof(ACL);

      // If not NULL DACL, gather size information from DACL.
      if (fDaclPresent && pACL) {    
         
         if(!GetAclInformation(pACL, &AclInfo, 
               sizeof(ACL_SIZE_INFORMATION), AclSizeInformation)) {
            _TRACE(TRACE_DEBUGGING,L"GetAclInformation() failed.  Error %d\n",
               GetLastError());
            __leave;
         }
      }

      // 
      // Compute size needed for the new ACL.
      // 
      cbNewACL = AclInfo.AclBytesInUse + sizeof(ACCESS_ALLOWED_ACE) 
            + GetLengthSid(pSid) - sizeof(DWORD);

      // 
      // Allocate memory for new ACL.
      // 
      pNewACL = (PACL) heapalloc(cbNewACL);
      if (!pNewACL) {
         _TRACE(TRACE_DEBUGGING,L"HeapAlloc() failed.  Error %d\n", GetLastError());
         __leave;
      }

      // 
      // Initialize the new ACL.
      // 
      if(!InitializeAcl(pNewACL, cbNewACL, ACL_REVISION2)) {
         _TRACE(TRACE_DEBUGGING,L"InitializeAcl() failed.  Error %d\n", GetLastError());
         __leave;
      }

      // 
      // If DACL is present, copy it to a new DACL.
      // 
      if (fDaclPresent) {

         // 
         // Copy the file's ACEs to the new ACL.
         // 
         if (AclInfo.AceCount) {

            //See if the ACE is present in the end.
            if(!GetAce(pACL,AclInfo.AceCount -1, &pTempAce))
            {
                __leave;
            }
            if(((ACE_HEADER *)pTempAce)->AceType == ACCESS_ALLOWED_ACE_TYPE &&
                EqualSid((PSID)&(((ACCESS_ALLOWED_ACE*)pTempAce)->SidStart),pSid))
            {
                //ACE is already present. 
                goto Done;
            }
            for (CurrentAceIndex = 0; 
                  CurrentAceIndex < AclInfo.AceCount;
                  CurrentAceIndex++) {

               // 
               // Get an ACE.
               // 
               if(!GetAce(pACL, CurrentAceIndex, &pTempAce)) {
                  _TRACE(TRACE_DEBUGGING,L"GetAce() failed.  Error %d\n", 
                        GetLastError());
                  __leave;
               }
               //Keep checking if the ACE is already present.
                if(((ACE_HEADER *)pTempAce)->AceType == ACCESS_ALLOWED_ACE_TYPE &&
                    EqualSid((PSID)&(((ACCESS_ALLOWED_ACE*)pTempAce)->SidStart),pSid))
                {
                    //ACE is already present. 
                    goto Done;
                }

               // 
               // Add the ACE to the new ACL.
               // 
               if(!AddAce(pNewACL, ACL_REVISION, MAXDWORD, pTempAce,
                     ((PACE_HEADER) pTempAce)->AceSize)) {
                  _TRACE(TRACE_DEBUGGING,L"AddAce() failed.  Error %d\n", 
                        GetLastError());
                  __leave;
               }
            }
         }
      }

      // 
      // Add the access-allowed ACE to the new DACL.
      // 
      if (!AddAccessAllowedAce(pNewACL, ACL_REVISION2, dwAccessMask,
            pSid)) {
         _TRACE(TRACE_DEBUGGING,L"AddAccessAllowedAce() failed.  Error %d\n",
               GetLastError());
         __leave;
      }

      // 
      // Set the new DACL to the file SD.
      // 
      if (!SetSecurityDescriptorDacl(pNewSD, TRUE, pNewACL, 
            FALSE)) {
         _TRACE(TRACE_DEBUGGING,L"() failed.  Error %d\n", GetLastError());
         __leave;
      }

      // 
      // Set the SD to the File.
      // 
      if (!SetFileSecurity(lpszFileName, DACL_SECURITY_INFORMATION,
            pNewSD)) {
         _TRACE(TRACE_DEBUGGING,L"SetFileSecurity() failed.  Error %d\n", 
               GetLastError());
         __leave;
      }
Done:      

      fResult = TRUE;

   } __finally {

      // 
      // Free allocated memory
      // 

      if (pFileSD)
         heapfree(pFileSD);

      if (pNewSD)
         heapfree(pNewSD);

      if (pNewACL)
         heapfree(pNewACL);
   }
   
   return fResult;
}

/******************************************************************
 *  CreateTelnetClientsGroupAndSetPermissions()
 *  Creates a group called TelnetClients and sets permissions on cmd.exe
 *  to give Read+Execute rights to TelnetClients group.
 *  Parameters:
 *      None
 *  Return values:
 *      Boolean to return success or failure.
*/

BOOL CreateTelnetClientsGroupAndSetPermissions()
{
    LOCALGROUP_INFO_1 giTelnetGroup;
    TCHAR wzGrpi1Name[GNLEN] = { 0 };
    TCHAR wzGrpi1Comment[MAXCOMMENTSZ] = { 0 };
    DWORD dwCount = MAX_PATH;
    BOOL bRetVal = FALSE;
    NET_API_STATUS success = NERR_Success;
    PSID pSidTelnetClients = NULL;
    WCHAR szApp[MAX_PATH+9] = { 0 }; //for "System32_path\\cmd.exe" + NULL

    wcsncpy(wzGrpi1Name,TELNETCLIENTS_GROUP_NAME, GNLEN -1);
     if (! LoadString(g_hInstRes, IDS_TELNETCLIENTS_GROUP_COMMENT, wzGrpi1Comment, 
            sizeof(wzGrpi1Comment) / sizeof(TCHAR)))
    {
        _tcsncpy(wzGrpi1Comment, TEXT("Members of this group have access to Telnet Server on this system."),MAXCOMMENTSZ-1);
    }


    giTelnetGroup.lgrpi1_name = wzGrpi1Name;
    giTelnetGroup.lgrpi1_comment = wzGrpi1Comment;


    success = NetLocalGroupAdd( NULL, 1, (LPBYTE)&giTelnetGroup, NULL);
    if(success != NERR_Success && success != NERR_GroupExists && success != ERROR_ALIAS_EXISTS )
    {
        goto ExitOnError;
    }
    //Get TelnetClients Sid.
    {
    DWORD needed_length   = 0;
    DWORD dwErr     = 0, dwDomainLen = 0;
    SID_NAME_USE    sidNameUse;
    TCHAR           szDomain[ MAX_PATH + 1 ];
    BOOL        success = FALSE;
    TCHAR           szComputerName[MAX_COMPUTERNAME_LENGTH + 1 + 14] = { 0 }; //+14 for '\TelnetClients'
    DWORD           dwNameLen = MAX_COMPUTERNAME_LENGTH + 1;
    success = GetComputerName(szComputerName, &dwNameLen);
    if(success)
    {
        _sntprintf(szComputerName+dwNameLen,(MAX_COMPUTERNAME_LENGTH + 14) - dwNameLen,_T("\\%s"),TELNETCLIENTS_GROUP_NAME);
    }
    LookupAccountName( NULL, szComputerName, pSidTelnetClients, &needed_length, 
                       szDomain, &dwDomainLen, &sidNameUse );
    pSidTelnetClients  = ( PSID ) new UCHAR[ needed_length ];
    if(pSidTelnetClients == NULL)
    {
        _TRACE(TRACE_DEBUGGING,L"Allocation for pSidTelnetClients failed in CreateTelnetClientsGroupAndSetPermissions");
        goto ExitOnError;
    }

    //Even if if allocation fails just go ahead.
    success = LookupAccountName( NULL, szComputerName, pSidTelnetClients, &needed_length, 
                       szDomain, &dwDomainLen, &sidNameUse );
    if( !success ) 
    {
        _TRACE(TRACE_DEBUGGING,L"LookupAccountName failed in CreateTelnetClientsGroupAnd... with %d",GetLastError());
        goto ExitOnError;
    }
  }
    if(!GetSystemDirectory(szApp,MAX_PATH+1))
    {
        goto ExitOnError;
    }
    wcsncat(szApp,L"\\cmd.exe",8);

    bRetVal = AddAccessRights(pSidTelnetClients, (LPCWSTR)szApp, FILE_EXECUTE | FILE_READ_DATA | 
                                                    FILE_READ_ATTRIBUTES |
                                                    FILE_READ_EA |
                                                    STANDARD_RIGHTS_READ |
                                                    SYNCHRONIZE);


ExitOnError:
    if (pSidTelnetClients) 
    {
        delete pSidTelnetClients;
        pSidTelnetClients = NULL;
    }
    return bRetVal;
}


HRESULT 
CServiceModule::RegisterServer
( 
    BOOL bRegTypeLib, 
    BOOL bService 
)
{ 
    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
        return hr;

    if( IsInstalled() )
    {
        if( IsThatMe() )
        {
            //This is needed because it is possible to call tlntsvr /Service 
            //multiple times from commandline
            return S_OK;
        }
        
        //Set the service keys point to self
        if( !SetServiceConfigToSelf( m_szServiceName ) )
        {
            //Let the latest version run
            return S_OK;            
        }
        else
        {
            //Set the service keys point to self
            if( !SetServiceConfigToSelf( m_szServiceName ) )
            {
                if (! LoadString(g_hInstRes, IDS_ERR_CONFIG_SVC, g_szErrRegDelete, 
                       sizeof(g_szErrRegDelete) / sizeof(g_szErrRegDelete[0])))
                {
                    lstrcpy(g_szErrRegDelete, TEXT(""));
                }
            }
        }
    }
    if(!CreateTelnetClientsGroupAndSetPermissions())
        return E_FAIL;
    // Add service entries
    UpdateRegistryFromResource(IDR_TlntSvr, TRUE);
    // Adjust the AppID for Local Server or Service
    CRegKey keyAppID;
    LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"));
    if (lRes != ERROR_SUCCESS)
        return lRes;

    CRegKey key;
    lRes = key.Open( keyAppID, APPID );
    if (lRes != ERROR_SUCCESS)
        return lRes;
    key.DeleteValue(_T("LocalService"));
    HKEY hk = NULL;
    WCHAR szAccnt[_MAX_PATH+1];
    LPWSTR pszAccount = NULL, pszPassword = NULL;
    WCHAR szDomainName[_MAX_PATH+1];
    DWORD dwAccntSize = _MAX_PATH, dwDomainNameSize = _MAX_PATH;
    WCHAR szFullAccountName[_MAX_PATH*2 + 2] = { 0 }; // 3 for '\' and NULL.
    SID_NAME_USE sid_name_use;
    LPWSTR szPasswd = L"";
    if(!TnInitializeStandardSids())
        return FALSE;
    if(!LookupAccountSid(NULL,localLocalSid,szAccnt,&dwAccntSize,szDomainName,&dwDomainNameSize,&sid_name_use))
    {
        // If error is ERROR_NONE_MAPPED, the account is not present. 
        // Probably we are running W2k or NT4.
        // the service will run as local system.
        if(GetLastError() != ERROR_NONE_MAPPED)
        {
            TnFreeStandardSids();
            return E_FAIL;
        }
    }
    else
    {
        _snwprintf(szFullAccountName,MAX_PATH*2+1,L"NT AUTHORITY\\LocalService");
        pszAccount = szFullAccountName; // Name of the Local Service account
        pszPassword = szPasswd; //Empty String
    }
    TnFreeStandardSids();
  
    if (bService)
    {
        key.SetValue(_T("TlntSvr"), _T("LocalService"));
        key.SetValue(_T("-Service -From_DCOM"), _T("ServiceParameters"));
        // Create service
        Install(pszAccount,pszPassword);
    }

    keyAppID.Close();
    key.Close();

    // Add object entries
    hr = CComModule::RegisterServer(bRegTypeLib);

    CoUninitialize();


    //register the message resource

    if(bService)
    {
        // Add event log info
        CRegKey eventLog;

        TCHAR local_key[_MAX_PATH];
        lstrcpy( local_key, _T("SYSTEM\\CurrentControlSet\\Services\\EventLog"
                        _T("\\Application\\")));    // NO, BO, Baskar.

        TCHAR szModule[_MAX_PATH];
        GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);

        TCHAR szResModule[_MAX_PATH*2];
        DWORD len = GetModuleFileName(g_hInstRes, szResModule, _MAX_PATH);

        OSVERSIONINFOEX osvi = { 0 };
        WCHAR szSysDir[MAX_PATH+1] = {0};
        
        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        if ( !GetVersionEx((OSVERSIONINFO *) &osvi ) )
        {
            //OSVERSIONINFOEX is supported from NT4 SP6 on. So GetVerEx() should succeed.
            return E_FAIL;
        }
        //Check if the OS is XPSP, in that case, we need to append the xpspresdll name to 
        //eventmessagefile value in HKLM\system\...\eventlog\tlntsvr.
        //The event message will first be searched in szResModule and then in xpsp1res.dll
        if(osvi.dwPlatformId == VER_PLATFORM_WIN32_NT && osvi.wProductType == VER_NT_WORKSTATION && osvi.wServicePackMajor > 0)
        {
            //OS is Windows XP.
            if(!GetSystemDirectory(szSysDir,MAX_PATH+1))
            {
                _tcsncpy(szSysDir,L"%SYSTEMROOT%\\system32",MAX_PATH);
            }
            _snwprintf(szResModule+len,(_MAX_PATH*2)-len-1,L";%s\\xpsp1res.dll",szSysDir);
        }
        TCHAR szName[_MAX_FNAME];
        _tsplitpath( szModule, NULL, NULL, szName, NULL);

        lstrcat(local_key, szName);     // NO overflow, Baskar

        LONG result = eventLog.Create(HKEY_LOCAL_MACHINE, local_key);
        if( ERROR_SUCCESS != result)
            return result;

        result = eventLog.SetValue(szResModule, _T("EventMessageFile"));
        if(ERROR_SUCCESS != result)
            return result;

        DWORD dwTypes = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE |
            EVENTLOG_INFORMATION_TYPE | EVENTLOG_AUDIT_SUCCESS | 
            EVENTLOG_AUDIT_FAILURE;
        result = eventLog.SetValue(dwTypes, _T("TypesSupported"));
        if(ERROR_SUCCESS != result)
            return result;
        
        eventLog.Close();

        SC_HANDLE hService = NULL, hSCM = NULL;
        TCHAR szServiceDesc[ _MAX_PATH * 2 ];
        DWORD dwData = 0;
        DWORD dwTag = 0;
        DWORD dwDisp = 0;

        if( (result = TnSecureRegCreateKeyEx( HKEY_LOCAL_MACHINE, REG_SERVICE_KEY, NULL, NULL, 
                        REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED , NULL, &hk, &dwDisp, 0 )) == ERROR_SUCCESS )
        {
            LPWSTR pszCreateInitially = NULL;

	        if(LoadString(_Module.GetResourceInstance(), 
	                  IDS_SERVICE_DESCRIPTION, 
	                  szServiceDesc,
	                  sizeof(szServiceDesc) / sizeof(TCHAR)))
	        {
	        	if( !GetRegistryString( hk, NULL, L"Description", &pszCreateInitially,
                     			szServiceDesc,TRUE ) )
	       		{
	       			RegCloseKey(hk);
		       		return E_FAIL;
		       	}
	       		RegCloseKey(hk);
	        }
		else
	        {
		    RegCloseKey(hk);
        	    return E_FAIL;
                }
	       	
        }
        else
        {
        	return E_FAIL;
        }
        hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT | SC_MANAGER_CREATE_SERVICE | 
    											SC_MANAGER_ENUMERATE_SERVICE | MAXIMUM_ALLOWED );

	    if (hSCM != NULL)
	    {
	        hService = ::OpenService(hSCM, m_szServiceName, 
	            SERVICE_CHANGE_CONFIG );
	        if (hService == NULL)
	        {
	            result = E_FAIL;
	            ::CloseServiceHandle(hSCM);
	            return result;
	        }
	        if(!ChangeServiceConfig(hService,SERVICE_NO_CHANGE,SERVICE_NO_CHANGE,
	        					SERVICE_ERROR_NORMAL,NULL,NULL,
	        					NULL,DEFAULT_SERVICE_DEPENDENCY,
	        					pszAccount,pszPassword,SERVICE_DISPLAY_NAME))
	        {
	        	result = E_FAIL;
	        }
	        ::CloseServiceHandle(hService);
	        ::CloseServiceHandle(hSCM);
        }
        else
        {
            return result;
        }
    }

    //Create HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\TelnetServer key and it's values.
    if( !CreateRegistryEntriesIfNotPresent( ) )
    {
       return E_FAIL;
    }

    return hr;
}

HRESULT 
CServiceModule::UnregisterServer()
{
    DWORD dwError = 0;
    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
        return hr;

    // Remove service entries
    UpdateRegistryFromResource(IDR_TlntSvr, FALSE);
    // Remove service
    Uninstall();
    // Remove object entries
    CComModule::UnregisterServer();
    
    //This is so that reg key related to typelib gets deleted
    (void)UnRegisterTypeLib(LIBID_TLNTSVRLib, 1, 0, LOCALE_NEUTRAL, SYS_WIN32); // Stop prefast from reporting an error.

    //remove telnet specific registry entries
    //RegDeleteKey is returning ERROR_INVALID_FUNCTION in the absence of the key
    RegDeleteKey( HKEY_LOCAL_MACHINE, ( READ_CONFIG_KEY ) );
    RegDeleteKey( HKEY_LOCAL_MACHINE, ( REG_PARAMS_KEY ) );
    RegDeleteKey( HKEY_LOCAL_MACHINE, ( REG_DEFAULTS_KEY ) ); 
    RegDeleteKey( HKEY_LOCAL_MACHINE, ( REG_SERVER_KEY ) ); 
    RegDeleteKey( HKEY_CLASSES_ROOT, ( APPID ) );
    RegDeleteKey( HKEY_LOCAL_MACHINE, _T( "System\\CurrentControlSet\\Services\\EventLog\\Application\\TlntSvr" ) );

    LPWSTR lpszKey = NULL;
    if( FormTlntSessKeyForCmd( &lpszKey ) )
    {
        if( ( dwError = RegDeleteKey( HKEY_USERS, lpszKey)) != ERROR_SUCCESS 
    	    && ( dwError != ERROR_INVALID_FUNCTION ) )
        {
           //do nothing
        }
        delete [] lpszKey;
    }
    
    //The following key is not created by this program. But by tlntsvr.rgs
    //I couldn't delete this in any other way. So, manually deleting it
    RegDeleteKey( HKEY_CLASSES_ROOT, _T( "AppID\\TlntSvr.Exe" ) ); 

    CoUninitialize();
    return S_OK;
}

void 
CServiceModule::Init
(
    _ATL_OBJMAP_ENTRY* p, 
    HINSTANCE h,
    UINT nServiceNameID
)
{
    CComModule::Init(p, h);

    m_bService = TRUE;

    if (! LoadString(h, nServiceNameID, m_szServiceName, 
        sizeof(m_szServiceName) / sizeof(TCHAR)))
    {
        lstrcpy(m_szServiceName, TEXT(""));
    }
    if (! LoadString(h, IDS_ERR_REG_DELETE, g_szErrRegDelete, 
        sizeof(g_szErrRegDelete) / sizeof(TCHAR)))
    {
        lstrcpy(g_szErrRegDelete, TEXT(""));
    }
    if (! LoadString(h, IDS_ERR_OPEN_SCM, g_szErrOpenSCM, 
        sizeof(g_szErrOpenSCM) / sizeof(TCHAR)))
    {
        lstrcpy(g_szErrOpenSCM, TEXT(""));
    }
    if (! LoadString(h, IDS_ERR_CREATE_SVC, g_szErrCreateSvc, 
        sizeof(g_szErrCreateSvc) / sizeof(TCHAR)))
    {
        lstrcpy(g_szErrCreateSvc, TEXT(""));
    }
    if (! LoadString(h, IDS_ERR_OPEN_SVC, g_szErrOpenSvc, 
        sizeof(g_szErrOpenSvc) / sizeof(TCHAR)))
    {
        lstrcpy(g_szErrOpenSvc, TEXT(""));
    }
    if (! LoadString(h, IDS_ERR_DELETE_SVC, g_szErrDeleteSvc, 
        sizeof(g_szErrDeleteSvc) / sizeof(TCHAR)))
    {
        lstrcpy(g_szErrDeleteSvc, TEXT(""));
    }
    if (! LoadString(h, IDS_MAX_CONNECTIONS_REACHED, g_szMaxConnectionsReached, 
            sizeof(g_szMaxConnectionsReached) / sizeof(TCHAR)))
    {
        lstrcpy(g_szMaxConnectionsReached, TEXT(""));
    }
    if (! LoadString(h, IDS_LICENSE_LIMIT_REACHED, g_szLicenseLimitReached, 
            sizeof(g_szLicenseLimitReached) / sizeof(TCHAR)))
    {
        lstrcpy(g_szLicenseLimitReached, TEXT(""));
    }
    
    // set up the initial service status 
    m_hServiceStatus = NULL;
    m_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_status.dwCurrentState = SERVICE_STOPPED;
    m_status.dwControlsAccepted = SERVICE_ACCEPT_STOP | 
        SERVICE_ACCEPT_PAUSE_CONTINUE | SERVICE_ACCEPT_SHUTDOWN;
    m_status.dwWin32ExitCode = 0;
    m_status.dwServiceSpecificExitCode = 0;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;
}

LONG 
CServiceModule::Unlock()
{
    LONG x = CComModule::Unlock();
// May be Telnet server has to shutdown
//    if (l == 0 && !m_bService)
//        PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
    return x;
}

BOOL 
CServiceModule::IsInstalled()
{
    BOOL bResult = FALSE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT | SC_MANAGER_CREATE_SERVICE | 
    											SC_MANAGER_ENUMERATE_SERVICE | MAXIMUM_ALLOWED );

    if (hSCM != NULL)
    {
        SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, 
            SERVICE_QUERY_CONFIG);
        if (hService != NULL)
        {
            bResult = TRUE;
            ::CloseServiceHandle(hService);
        }
        ::CloseServiceHandle(hSCM);
    }
    return bResult;
}

BOOL 
CServiceModule::Install(LPWSTR pszAccount, LPWSTR pszPassword)
{
    if (IsInstalled())
        return TRUE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT | SC_MANAGER_CREATE_SERVICE | 
    											SC_MANAGER_ENUMERATE_SERVICE | MAXIMUM_ALLOWED );
    if (hSCM == NULL)
    {
        MessageBox(NULL, g_szErrOpenSCM, m_szServiceName, MB_OK); 
        return FALSE;
    }

    // Get the executable file path
    TCHAR szFilePath[_MAX_PATH + 1] = { 0 };
    ::GetModuleFileName(NULL, szFilePath, _MAX_PATH);

    SC_HANDLE hService = ::CreateService(hSCM, m_szServiceName, 
        SERVICE_DISPLAY_NAME, SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS,
        g_dwStartType,  SERVICE_ERROR_NORMAL, szFilePath, NULL, NULL, 
        DEFAULT_SERVICE_DEPENDENCY,pszAccount,pszPassword);
	
    if (hService == NULL)
    {
        ::CloseServiceHandle(hSCM);
        MessageBox(NULL, g_szErrCreateSvc, m_szServiceName, MB_OK);
        return FALSE;
    }

    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);
    return TRUE;
}

BOOL 
CServiceModule::Uninstall()
{
    if (!IsInstalled())
        return TRUE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT | SC_MANAGER_CREATE_SERVICE | 
    											SC_MANAGER_ENUMERATE_SERVICE | MAXIMUM_ALLOWED );

    if (hSCM == NULL)
    {
        MessageBox(NULL, g_szErrOpenSCM, m_szServiceName, MB_OK);
        return FALSE;
    }

    SC_HANDLE hService = ::OpenService(
        hSCM, m_szServiceName, SERVICE_STOP | DELETE);

    if (hService == NULL)
    {
        ::CloseServiceHandle(hSCM);
        MessageBox(NULL, g_szErrOpenSvc, m_szServiceName, MB_OK);
        return FALSE;
    }
    SERVICE_STATUS status;
    ::ControlService(hService, SERVICE_CONTROL_STOP, &status);

    BOOL bDelete = ::DeleteService(hService);
    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);

    if (bDelete)
        return TRUE;

    MessageBox(NULL, g_szErrDeleteSvc, m_szServiceName, MB_OK);
    return FALSE;
}

////////////////////////////////////////////////////////////////////////////////
// Logging functions
void
LogEvent
(
    WORD wType, 
    DWORD dwEventID, 
    LPCTSTR pFormat, 
    ...
)
{

#define CHARS_TO_LOG        1024

    TCHAR   chMsg[CHARS_TO_LOG] = { 0 };
    LPTSTR  lpszStrings[1] = { chMsg };
    INT     format_length = lstrlen(pFormat);

    if (format_length < CHARS_TO_LOG) 
    {
        va_list	pArg;

        va_start(pArg, pFormat);
        _vsntprintf(chMsg, CHARS_TO_LOG - 1, pFormat, pArg);
        va_end(pArg);
    }
    else
    {
        _sntprintf(chMsg, CHARS_TO_LOG - 1, TEXT("TLNTSVR: Too long a format string to log, Length == %d"), format_length);
    }

    if (_Module.m_bService)
    {
        LogToTlntsvrLog( _Module.m_hEventSource, wType, dwEventID, 
                (LPCTSTR*) &lpszStrings[0] );
    }
    else
    {
        // As we are not running as a service, just write the error to the 
        //console.
        _putts(chMsg);
    }

#undef CHARS_TO_LOG

}

///////////////////////////////////////////////////////////////////////////////
// Service startup and registration
void 
CServiceModule::Start()
{
    SERVICE_TABLE_ENTRY st[] =
    {
        { m_szServiceName, _ServiceMain },
        { NULL, NULL }
    };

    if (m_bService)
    {
        if (! ::StartServiceCtrlDispatcher(st))
        {
            m_bService = FALSE;
        }
    }

    if (m_bService == FALSE)
        Run();
}

void 
CServiceModule::ServiceMain
(
    DWORD  dwArgc, 
    LPTSTR* lpszArgv
)
{
    // DebugBreak();

    // Register the control request handler
    m_status.dwCurrentState = SERVICE_START_PENDING;
    m_hServiceStatus = RegisterServiceCtrlHandler(m_szServiceName, _Handler);
    if (m_hServiceStatus == NULL)
    {
        LogEvent(EVENTLOG_ERROR_TYPE, 0, _T("Handler not installed"));
        return;
    }
//    DebugBreak();
    SetServiceStatus(SERVICE_START_PENDING);

    m_status.dwWin32ExitCode = S_OK;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;

    //
    // Security bug fix: When the CLSID of telnet object is
    // embedded into a web page then DCOM is starting up
    // the service. To disable this from happening the fix
    // we did was to put in a new command line switch in
    // ServiceParameters under the HKCR\AppID\{FE9E4896-A014-11D1-855C-00A0C944138C}\ServiceParameters
    // key. This switch is "-From_DCOM". This will tell us when
    // IE is starting the service versus when the service
    // is started via net.exe or tlntadmn.exe. If IE is starting
    // the service then we immediately exit.
    //
    for (DWORD dwIndex =1; dwIndex < dwArgc; ++dwIndex)
    {
        if (!_tcsicmp(lpszArgv[dwIndex], TEXT("-From_DCOM")) || 
            !_tcsicmp(lpszArgv[dwIndex], TEXT("/From_DCOM")))
        {
            goto ExitOnIEInstantiation;
        }
    }    
    // DebugBreak();

    // When the Run function returns, the service has stopped.
    Run();

    LogEvent(EVENTLOG_INFORMATION_TYPE, MSG_SHUTDOWN, _T("Service stopped"));
ExitOnIEInstantiation:
    DeregisterEventSource(_Module.m_hEventSource);

    SetServiceStatus( SERVICE_STOPPED );
}

void 
CServiceModule::Handler
(
    DWORD dwOpcode
)
{
    switch (dwOpcode)
    {
    case SERVICE_CONTROL_STOP:
        g_pTelnetService->Shutdown();  
        SetServiceStatus(SERVICE_STOP_PENDING);
        break;

    case SERVICE_CONTROL_PAUSE:
        SetServiceStatus(SERVICE_PAUSE_PENDING);
        g_pTelnetService->Pause();
        SetServiceStatus(SERVICE_PAUSED);
        break;

    case SERVICE_CONTROL_CONTINUE:
        SetServiceStatus(SERVICE_CONTINUE_PENDING);
        g_pTelnetService->Resume();
        SetServiceStatus(SERVICE_RUNNING);
        break;

    case SERVICE_CONTROL_INTERROGATE:
        break;

    case SERVICE_CONTROL_SHUTDOWN:
        g_pTelnetService->SystemShutdown();
        break;

    default:
        LogEvent(EVENTLOG_WARNING_TYPE, 0, _T("Bad service request"));
        break;
    }
}

void 
WINAPI 
CServiceModule::_ServiceMain
(
    DWORD dwArgc, 
    LPTSTR* lpszArgv
)
{
    _Module.ServiceMain(dwArgc, lpszArgv);
}

void 
WINAPI 
CServiceModule::_Handler
(
    DWORD dwOpcode
)
{
    _Module.Handler(dwOpcode); 
}

void 
CServiceModule::SetServiceStatus
(
    DWORD dwState
)
{
    m_status.dwCurrentState = dwState;
    ::SetServiceStatus(m_hServiceStatus, &m_status);
}

HRESULT SetSecurityForTheComObject()
{
    HRESULT                  hr = S_FALSE;
    PSID                     pSidAdministrators = NULL;
	int                      aclSize = 0;
    PACL                     newACL = NULL;
    SECURITY_DESCRIPTOR      sd;

    {
        SID_IDENTIFIER_AUTHORITY local_system_authority = SECURITY_NT_AUTHORITY;

        //Build administrators alias sid
        if (! AllocateAndInitializeSid(
                &local_system_authority,
                2, /* there are only two sub-authorities */
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0,0,0,0,0,0, /* Don't care about the rest */
                &pSidAdministrators
                ))
        {
            goto Done;
        }
    }

    aclSize = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pSidAdministrators) - sizeof(DWORD);

    newACL  = (PACL) new BYTE[aclSize];
    if (newACL == NULL)
    {
        goto Done;
    }

    if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
	{
		goto Done;
	}

	if (!AddAccessAllowedAce(newACL, ACL_REVISION, (CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER), pSidAdministrators))
	{
		goto Done;
	}

    if( !InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION ) )
    {
        goto Done;
    }

    if( !SetSecurityDescriptorDacl(&sd, TRUE, newACL, FALSE) )
    {
        goto Done;
    }

    if( !SetSecurityDescriptorOwner(&sd, pSidAdministrators, FALSE ) )
    {
        goto Done;
    }

    if( !SetSecurityDescriptorGroup(&sd, pSidAdministrators, FALSE) )
    {
        goto Done;
    }

    // DebugBreak();

    hr = CoInitializeSecurity(
            &sd, 
            -1,                         // Let COM choose it
            NULL,                       //      -do-
            NULL, 
            RPC_C_AUTHN_LEVEL_PKT,      
            RPC_C_IMP_LEVEL_IMPERSONATE,
            NULL, 
            EOAC_NONE, 
            NULL
            );

Done:

    if( pSidAdministrators  != NULL )
    {
        FreeSid (pSidAdministrators );
    }

    if( newACL  )
    {
        delete[] newACL;
    }

    return hr;
}

void 
CServiceModule::Run()
{

    HRESULT hr;
    HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED );
    _ASSERTE(SUCCEEDED(hRes));
    if( SetSecurityForTheComObject( ) != S_OK )
    {
        m_status.dwWin32ExitCode = ERROR_ACCESS_DENIED;
        SetServiceStatus( SERVICE_STOPPED );

        //log the failure and return;

        goto Done;
    }

    hr = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER|CLSCTX_REMOTE_SERVER,
            REGCLS_MULTIPLEUSE);
    _ASSERTE(SUCCEEDED(hr));
    if( !TelnetServiceThread( ) )
    { 
        m_status.dwWin32ExitCode = ERROR_INVALID_DATA;
        SetServiceStatus( SERVICE_STOPPED );
    }
    

    _Module.RevokeClassObjects();

Done:
    CoUninitialize();
}

int __cdecl NoMoreMemory( size_t size )
{
    int NO_MORE_MEMORY = 1;
		size=size;
    _chASSERT(NO_MORE_MEMORY != 1);
    LogEvent( EVENTLOG_ERROR_TYPE, MSG_NOMOREMEMORY, _T(" ") );
    ExitProcess( 1 );
    return( 0 );
}


/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
    HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
    // DebugBreak();
//    _set_new_handler( NoMoreMemory );
// We do not really care about the return value.
// because g_hInstRes will get the value hInstance in case of any failure
    HrLoadLocalizedLibrarySFU(hInstance,  L"TLNTSVRR.DLL", &g_hInstRes, NULL);
		
    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT
    _Module.Init(ObjectMap, g_hInstRes, IDS_SERVICENAME);
    _Module.m_bService = TRUE;
    // Get a handle to use with ReportEvent().
    _Module.m_hEventSource = RegisterEventSource(NULL, _Module.m_szServiceName);

    TCHAR szTokens[] = _T("-/");
    
    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (_tcsicmp(lpszToken, _T("UnregServer"))==0)
            return _Module.UnregisterServer();

        // Register as Local Server
        if (_tcsicmp(lpszToken, _T("RegServer"))==0)
            return _Module.RegisterServer(TRUE, FALSE);
        
        // Register as Service
        if (_tcsicmp(lpszToken, _T("Service"))==0)
            return _Module.RegisterServer(TRUE, TRUE);
        
        lpszToken = FindOneOf(lpszToken, szTokens);
    }

        OSVERSIONINFOEX osvi = { 0 };
        WCHAR szSysDir[MAX_PATH+1] = {0};
        
        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        if ( !GetVersionEx((OSVERSIONINFO *) &osvi ) )
        {
            //OSVERSIONINFOEX is supported from NT4 SP6 on. So GetVerEx() should succeed.
            return E_FAIL;
        }
        if(osvi.dwPlatformId == VER_PLATFORM_WIN32_NT && osvi.wProductType == VER_NT_WORKSTATION && osvi.wServicePackMajor > 0)
        {
            //OS is Windows XP.
            // Add event log info
            CRegKey eventLog;

            TCHAR local_key[_MAX_PATH];
            lstrcpy( local_key, _T("SYSTEM\\CurrentControlSet\\Services\\EventLog"
                            _T("\\Application\\")));    // NO, BO, Baskar.

            TCHAR szModule[_MAX_PATH + 1] = { 0 };
            GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);

            TCHAR szResModule[(_MAX_PATH*2) +2];
            DWORD len = GetModuleFileName(g_hInstRes, szResModule, _MAX_PATH);

            //Check if the OS is XPSP, in that case, we need to append the xpspresdll name to 
            //eventmessagefile value in HKLM\system\...\eventlog\tlntsvr.
            //The event message will first be searched in szResModule and then in xpsp1res.dll
            if(!GetSystemDirectory(szSysDir,MAX_PATH+1))
            {
                _tcsncpy(szSysDir,L"%SYSTEMROOT%\\system32",MAX_PATH);
            }
            _snwprintf(szResModule+len,(_MAX_PATH*2)-len-1,L";%s\\xpsp1res.dll",szSysDir);
            TCHAR szName[_MAX_FNAME];
            _tsplitpath( szModule, NULL, NULL, szName, NULL);

            lstrcat(local_key, szName);     // NO overflow, Baskar

            LONG result = eventLog.Create(HKEY_LOCAL_MACHINE, local_key);
            if( ERROR_SUCCESS != result)
                return result;

            result = eventLog.SetValue(szResModule, _T("EventMessageFile"));
            if(ERROR_SUCCESS != result)
                return result;

            DWORD dwTypes = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE |
                EVENTLOG_INFORMATION_TYPE | EVENTLOG_AUDIT_SUCCESS | 
                EVENTLOG_AUDIT_FAILURE;
            result = eventLog.SetValue(dwTypes, _T("TypesSupported"));
            if(ERROR_SUCCESS != result)
                return result;
        
            eventLog.Close();

        }

#ifndef NO_PCHECK
#ifndef WHISTLER_BUILD
    if( ! IsLicensedCopy() )
    {
        LogEvent(EVENTLOG_ERROR_TYPE, MSG_LICENSEEXPIRED, _T(" "));
        return 1;
    }
#endif
#endif

    // Are we Service or Local Server
    CRegKey keyAppID;
    LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"),MAXIMUM_ALLOWED);
    if (lRes != ERROR_SUCCESS)
        return lRes;

    CRegKey key;
    lRes = key.Open( keyAppID, APPID,MAXIMUM_ALLOWED );
    if (lRes != ERROR_SUCCESS)
        return lRes;

    TCHAR szValue[_MAX_PATH];
    DWORD dwLen = _MAX_PATH;
    lRes = key.QueryValue(szValue, _T("LocalService"), &dwLen);

    keyAppID.Close();
    key.Close();

    _Module.m_bService = FALSE;
    if (lRes == ERROR_SUCCESS)
        _Module.m_bService = TRUE;

#if _DEBUG || DBG
    CDebugLogger::Init( TRACE_DEBUGGING, "C:\\temp\\TlntSvr.log" );
#endif

//    DebugBreak();
    _Module.Start();

#if _DEBUG || DBG
    CDebugLogger::ShutDown();
#endif

    // When we get here, the service has been stopped
    return _Module.m_status.dwWin32ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\tftpd\precomp.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This header contains all the RFC constants, structure
    definitions used by all modules, and function declarations.

Author:

    Jeffrey C. Venable, Sr. (jeffv) 01-Jun-2001

Revision History:

--*/

#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <winsock2.h>
#include <mswsock.h>
#include <ws2tcpip.h>
#include <svcs.h>
#include <stdlib.h>


//
// TFTPD protocol-specific values, per RFC.
//

typedef enum _TFTPD_DATA_SIZE {

    // RFC 2348.
    TFTPD_MIN_DATA = 8,

    // RFC 1350.
    TFTPD_DEF_DATA = 512,

    // RFC 1783 (obsoleted by RFC 2348 which says 1428).
    // We implement RFC 2348, but honor RFC 1783.
    TFTPD_MTU_DATA = 1432,

    // RFC 2348.
    TFTPD_MAX_DATA = 65464,

} TFTPD_DATA_SIZE;

typedef enum _TFTPD_BUFFER_SIZE TFTPD_BUFFER_SIZE;
typedef struct _TFTPD_CONTEXT TFTPD_CONTEXT, *PTFTPD_CONTEXT;

typedef struct _TFTPD_SOCKET {

    LIST_ENTRY                     linkage;
    SOCKET                         s;
    SOCKADDR_IN                    addr;
    PTFTPD_CONTEXT                 context;
    HANDLE                         wSelectWait;
    HANDLE                         hSelect;
    TFTPD_BUFFER_SIZE              buffersize;
    TFTPD_DATA_SIZE                datasize;
    LONG                           numBuffers;
    DWORD                          postedBuffers;
    DWORD                          lowWaterMark;
    DWORD                          highWaterMark;

} TFTPD_SOCKET, *PTFTPD_SOCKET;

typedef struct _TFTPD_BUFFER {

    struct _internal {
        PTFTPD_SOCKET              socket;
        DWORD                      datasize;
        PTFTPD_CONTEXT             context;
        struct {
            SOCKADDR_IN            peer;
            INT                    peerLen;
            DWORD                  bytes;
            DWORD                  flags;
            union {
                WSAOVERLAPPED      overlapped;
                IO_STATUS_BLOCK    ioStatus;
            };
            // WSARecvMsg values:
            WSAMSG                 msg;
            struct {
                WSACMSGHDR         header;
                IN_PKTINFO         info;
            } control;
        } io;
    } internal;

#pragma pack( push, 1 )
    struct _message {
        USHORT                             opcode;
        union {
            struct _rrq {
                char                       data[1];
            } rrq;
            struct _wrq {
                char                       data[1];
            } wrq;
            struct _data {
                USHORT                     block;
                char                       data[1];
            } data;
            struct _ack {
                USHORT                     block;
            } ack;
            struct _error {
                USHORT                     code;
                char                       error[1];
            } error;
            struct _oack {
                char                       data[1];
            } oack;
        };
    } message;
#pragma pack( pop )

} TFTPD_BUFFER, *PTFTPD_BUFFER;

typedef enum _TFTPD_BUFFER_SIZE {
    
    TFTPD_DEF_BUFFER = (FIELD_OFFSET(TFTPD_BUFFER, message.data.data) + TFTPD_DEF_DATA),
    TFTPD_MTU_BUFFER = (FIELD_OFFSET(TFTPD_BUFFER, message.data.data) + TFTPD_MTU_DATA),
    TFTPD_MAX_BUFFER = (FIELD_OFFSET(TFTPD_BUFFER, message.data.data) + TFTPD_MAX_DATA),

} TFTPD_BUFFER_SIZE;

typedef enum _TFTPD_PACKET_TYPE {

    TFTPD_RRQ   =  1,
    TFTPD_WRQ   =  2,
    TFTPD_DATA  =  3,
    TFTPD_ACK   =  4,
    TFTPD_ERROR =  5,
    TFTPD_OACK  =  6,

} TFTPD_PACKET_TYPE;

typedef enum _TFTPD_ERROR_CODE {

    TFTPD_ERROR_UNDEFINED           = 0,
    TFTPD_ERROR_FILE_NOT_FOUND      = 1,
    TFTPD_ERROR_ACCESS_VIOLATION    = 2,
    TFTPD_ERROR_DISK_FULL           = 3,
    TFTPD_ERROR_ILLEGAL_OPERATION   = 4,
    TFTPD_ERROR_UNKNOWN_TRANSFER_ID = 5,
    TFTPD_ERROR_FILE_EXISTS         = 6,
    TFTPD_ERROR_NO_SUCH_USER        = 7,
    TFTPD_ERROR_OPTION_NEGOT_FAILED = 8,

} TFTPD_ERROR_CODE;

typedef enum _TFTPD_MODE {

    TFTPD_MODE_TEXT                 = 1,
    TFTPD_MODE_BINARY               = 2,
    TFTPD_MODE_MAIL                 = 3,

} TFTPD_MODE;

typedef enum _TFTPD_OPTION_VALUES {

    TFTPD_OPTION_BLKSIZE            = 0x00000001,
    TFTPD_OPTION_TIMEOUT            = 0x00000002,
    TFTPD_OPTION_TSIZE              = 0x00000004,

} TFTPD_OPTION_VALUES;

typedef struct _TFTPD_CONTEXT {

    LIST_ENTRY                     linkage;
    volatile LONG                  reference;

    TFTPD_PACKET_TYPE              type;
    SOCKADDR_IN                    peer;
    PTFTPD_SOCKET                  socket;
    DWORD                          options;
    HANDLE                         hFile;
    PCHAR                          filename;
    LARGE_INTEGER                  filesize;
    LARGE_INTEGER                  fileOffset;
    LARGE_INTEGER                  translationOffset;
    TFTPD_MODE                     mode;
    DWORD                          blksize;
    DWORD                          timeout;
    USHORT                         block;
    USHORT                         sorcerer;
    BOOL                           danglingCR;
    HANDLE                         hWait;
    HANDLE                         wWait;
    HANDLE                         hTimer;
    ULONG                          retransmissions;
    volatile LONG                  state;

} TFTPD_CONTEXT, *PTFTPD_CONTEXT;

typedef enum _TFTPD_STATE {

    TFTPD_STATE_BUSY                = 0x00000001,
    TFTPD_STATE_DEAD                = 0x00000002,

} TFTPD_STATE;

typedef struct _TFTPD_HASH_BUCKET {

    CRITICAL_SECTION   cs;
// #if defined(DBG)
    DWORD              numEntries;
// #endif // defined(DBG)
    LIST_ENTRY         bucket;

} TFTPD_HASH_BUCKET, *PTFTPD_HASH_BUCKET;


//
// Global variables :
//

typedef struct _TFTPD_GLOBALS {

    // Initialization flags :
    struct _initialized {
        BOOL                               ioCS;
        BOOL                               reaperContextCS;
        BOOL                               reaperSocketCS;
        BOOL                               winsock;
        BOOL                               contextHashTable;
    } initialized;

    // Service control :
    struct _service {
        SERVICE_STATUS_HANDLE              hStatus;
        SERVICE_STATUS                     status;
        HANDLE                             hEventLogSource;
        volatile DWORD                     shutdown;
    } service;

    // Service private heap :
    HANDLE                                 hServiceHeap;

    // Registry parameters :
    struct _parameters {

        DWORD                              hashEntries;
        ULONG                              lowWaterMark;
        ULONG                              highWaterMark;
        DWORD                              maxRetries;
        CHAR                               rootDirectory[MAX_PATH];
        CHAR                               validClients[16]; // IPv4 "xxx.xxx.xxx.xxx"
        CHAR                               validReadFiles[MAX_PATH];
        CHAR                               validMasters[16]; // IPv4 "xxx.xxx.xxx.xxx"
        CHAR                               validWriteFiles[MAX_PATH];
#if defined(DBG)
        DWORD                              debugFlags;
#endif // defined(DBG)

    } parameters;

    // I/O mechanisms (sockets) :
    struct _io {

        CRITICAL_SECTION                   cs;
        TFTPD_SOCKET                       master;
        TFTPD_SOCKET                       def;
        TFTPD_SOCKET                       mtu;
        TFTPD_SOCKET                       max;
        HANDLE                             hTimerQueue;
        LONG                               numContexts;
        LONG                               numBuffers;

    } io;

    struct _hash {

        PTFTPD_HASH_BUCKET                 table;
#if defined(DBG)
        DWORD                              numEntries;
#endif // defined(DBG)

    } hash;

    struct _fp {

        LPFN_WSARECVMSG                    WSARecvMsg;

    } fp;

    struct _reaper {

        CRITICAL_SECTION                   contextCS;
        LIST_ENTRY                         leakedContexts;
        DWORD                              numLeakedContexts;

        CRITICAL_SECTION                   socketCS;
        LIST_ENTRY                         leakedSockets;
        DWORD                              numLeakedSockets;

    } reaper;

#if defined(DBG)
    struct _performance {

        DWORD                              maxClients;
        DWORD                              timeouts;
        DWORD                              drops;
        DWORD                              privateSockets;
        DWORD                              sorcerersApprentice;

    } performance;
#endif // defined(DBG)

} TFTPD_GLOBALS, *PTFTPD_GLOBALS;

extern TFTPD_GLOBALS globals;


//
// Useful macros
//

#define  TFTPD_MIN_RECEIVED_DATA                               \
         (FIELD_OFFSET(TFTPD_BUFFER, message.data.data) -      \
          FIELD_OFFSET(TFTPD_BUFFER, message.opcode))

#define  TFTPD_DATA_AMOUNT_RECEIVED(buffer)                    \
         (buffer->internal.io.bytes - TFTPD_MIN_RECEIVED_DATA) \

#define  TFTPD_ACK_SIZE                                        \
         (FIELD_OFFSET(TFTPD_BUFFER, message.ack.block) -      \
          FIELD_OFFSET(TFTPD_BUFFER, message.opcode) +         \
          sizeof(buffer->message.ack))

//
// Function prototypes : context.c
//

PTFTPD_CONTEXT
TftpdContextAllocate(
);

BOOL
TftpdContextAdd(
    PTFTPD_CONTEXT context
);

DWORD
TftpdContextAddReference(
    PTFTPD_CONTEXT context
);

PTFTPD_CONTEXT
TftpdContextAquire(
    PSOCKADDR_IN addr
);

DWORD
TftpdContextRelease(
    PTFTPD_CONTEXT context
);

BOOL
TftpdContextUpdateTimer(
    PTFTPD_CONTEXT context
);

BOOL
TftpdContextFree(
    PTFTPD_CONTEXT context
);

void
TftpdContextKill(
    PTFTPD_CONTEXT context
);

void
TftpdContextLeak(
    PTFTPD_CONTEXT context
);

//
// Function prototypes : io.c
//

PTFTPD_BUFFER
TftpdIoAllocateBuffer(
    PTFTPD_SOCKET socket
);

PTFTPD_BUFFER
TftpdIoSwapBuffer(
    PTFTPD_BUFFER buffer,
    PTFTPD_SOCKET socket
);

void
TftpdIoFreeBuffer(
    PTFTPD_BUFFER buffer
);

DWORD
TftpdIoPostReceiveBuffer(
    PTFTPD_SOCKET socket,
    PTFTPD_BUFFER buffer
);

void
TftpdIoInitializeSocketContext(
    PTFTPD_SOCKET socket,
    PSOCKADDR_IN addr,
    PTFTPD_CONTEXT context
);

BOOL
TftpdIoAssignSocket(
    PTFTPD_CONTEXT context,
    PTFTPD_BUFFER buffer
);

BOOL
TftpdIoDestroySocketContext(
    PTFTPD_SOCKET context
);

void
TftpdIoSendErrorPacket(
    PTFTPD_BUFFER buffer,
    TFTPD_ERROR_CODE error,
    char *reason
);

PTFTPD_BUFFER
TftpdIoSendPacket(
    PTFTPD_BUFFER buffer
);

PTFTPD_BUFFER
TftpdIoSendOackPacket(
    PTFTPD_BUFFER buffer
);

//
// Function prototypes : log.c
//

void
TftpdLogEvent(
    WORD type,
    DWORD request,
    WORD numStrings
);

//
// Function prototypes : process.c
//

BOOL
TftpdProcessComplete(
    PTFTPD_BUFFER buffer
);

void CALLBACK
TftpdProcessTimeout(
    PTFTPD_CONTEXT context,
    BOOLEAN
);

void
TftpdProcessError(
    PTFTPD_BUFFER buffer
);

PTFTPD_BUFFER
TftpdProcessReceivedBuffer(
    PTFTPD_BUFFER buffer
);

//
// Function prototypes: read.c
//

PTFTPD_BUFFER
TftpdReadResume(
    PTFTPD_BUFFER buffer
);

DWORD WINAPI
TftpdReadQueuedResume(
    PTFTPD_BUFFER buffer
);

PTFTPD_BUFFER
TftpdReadAck(
    PTFTPD_BUFFER buffer
);

PTFTPD_BUFFER
TftpdReadRequest(
    PTFTPD_BUFFER buffer
);

//
// Function prototypes : service.c
//

void
TftpdServiceAttemptCleanup(
);

//
// Function prototypes : util.c
//

BOOL
TftpdUtilGetFileModeAndOptions(
    PTFTPD_CONTEXT context,
    PTFTPD_BUFFER buffer
);

PTFTPD_BUFFER
TftpdUtilSendOackPacket(
    PTFTPD_BUFFER buffer
);

BOOL
TftpdUtilMatch(
    const char *const p,
    const char *const q
);

//
// Function prototypes: write.c
//

PTFTPD_BUFFER
TftpdWriteSendAck(
    PTFTPD_BUFFER buffer
);

DWORD WINAPI
TftpdWriteQueuedResume(
    PTFTPD_BUFFER buffer
);

PTFTPD_BUFFER
TftpdWriteData(
    PTFTPD_BUFFER buffer
);

PTFTPD_BUFFER
TftpdWriteRequest(
    PTFTPD_BUFFER buffer
);


//
// Debug
//

#if defined(DBG)

void __cdecl
TftpdOutputDebug(ULONG flag, char *format, ...);

#define  TFTPD_DEBUG(x)             TftpdOutputDebug x

#define  TFTPD_DBG_SERVICE          0x00000001
#define  TFTPD_DBG_IO               0x00000002
#define  TFTPD_DBG_PROCESS          0x00000004
#define  TFTPD_DBG_CONTEXT          0x00000008

#define  TFTPD_TRACE_SERVICE        0x00010000
#define  TFTPD_TRACE_IO             0x00020000
#define  TFTPD_TRACE_PROCESS        0x00040000
#define  TFTPD_TRACE_CONTEXT        0x00080000

#else

#define  TFTPD_DEBUG(x)

#endif // defined(DBG)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\tftpd\read.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module contains functions to manage TFTP read requests
    to the service from a client.

Author:

    Jeffrey C. Venable, Sr. (jeffv) 01-Jun-2001

Revision History:

--*/

#include "precomp.h"


PTFTPD_BUFFER
TftpdReadSendData(PTFTPD_BUFFER buffer) {

    PTFTPD_CONTEXT context = buffer->internal.context;

    TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                 "TftpdReadSendData(buffer = %p, context = %p).\n",
                 buffer, context));

    // Build the DATA packet.
    buffer->message.opcode = htons(TFTPD_DATA);
    buffer->message.data.block = htons((USHORT)(context->block + 1));

    // Complete the operation so we can receive the next ACK packet
    // if the client responds faster than we can exit sending the DATA.
    if (!TftpdProcessComplete(buffer))
        goto exit_send_data;

    // Send the DATA packet.
    buffer = TftpdIoSendPacket(buffer);

exit_send_data :

    return (buffer);

} // TftpdReadSendData()


void
TftpdReadTranslateText(PTFTPD_BUFFER buffer, DWORD bytes) {

    PTFTPD_CONTEXT context = buffer->internal.context;
    char *start, *end, *p, *q;

    TFTPD_DEBUG((TFTPD_TRACE_PROCESS, "TftpdReadTranslateText(buffer = %p, context = %p).\n", buffer, context));

    // NOTE: 'context' must be referenced before this call!
    ASSERT(context != NULL);

    //
    // Text (translated) mode :
    //     The data is sent in NVT-ASCII format.
    //     Cases to worry about:
    //         (a) CR + non-LF -> CR + '\0' + non-LF    (insert '\0')
    //         (b) non-CR + LF -> non-CR + CR + LF      (insert CR)
    //         (b) Dangling CR at the end of a previously converted buffer which affects
    //             the output of the first character of the following buffer.
    //     We can do the conversion in-place.
    //

    // Convert the data in-place.
    start = (char *)&buffer->message.data.data;
    end = (start + bytes);
    p = q = start;
    
    context->translationOffset.QuadPart = 0;

    if (start == end)
        return;

    if (context->danglingCR) {
        context->danglingCR = FALSE;
        if (*p != '\n') {
            *q++ = '\0'; // This is a CR + non-LF combination, insert '\0' (case a).
            context->translationOffset.QuadPart++; // Count the added byte.
        } else
            *q++ = *p++; // Copy the LF.
    }

    while (TRUE) {

        while ((q < end) && (*p != '\r') && (*p != '\n')) { *q++ = *p++; }

        if (q == end)
            break;

        if (*p == '\r') {
            *q++ = *p++; // Copy the CR.
            if (q < end) {
                if (*p != '\n') {
                    *q++ = '\0'; // This is a CR + non-LF combination, insert '\0' (case a).
                    context->translationOffset.QuadPart++; // Count the added byte.
                } else
                    *q++ = *p++; // Copy the LF.
                continue;
            } else
                break;
        }

        *q++ = '\r'; // This is a solitary LF, insert a CR (case b).
        context->translationOffset.QuadPart++; // Count the added byte.
        if (q < end)
            *q++ = *p++; // Copy the solitary LF.
        else
            break;

    } // while (true)

    if (*(end - 1) == '\r')
        context->danglingCR = TRUE;

} // TftpdReadTranslateText()


void CALLBACK
TftpdReadOverlappedCompletion(PTFTPD_BUFFER buffer, BOOLEAN timedOut) {

    PTFTPD_CONTEXT context = buffer->internal.context;

    TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                 "TftpdReadOverlappedCompletion(buffer = %p, context = %p).\n",
                 buffer, context));
    ASSERT(context != NULL);

    if (InterlockedCompareExchangePointer(&context->wWait,
                                          INVALID_HANDLE_VALUE,
                                          NULL) == NULL)
        return;

    ASSERT(context->wWait != NULL);
    if (!UnregisterWait(context->wWait)) {
        DWORD error;
        if ((error = GetLastError()) != ERROR_IO_PENDING) {
            TFTPD_DEBUG((TFTPD_DBG_PROCESS,
                         "TftpdReadOverlappedCompletion(buffer = %p, context = %p): "
                         "UnregisterWait() failed, error 0x%08X.\n",
                         buffer, context, error));
            TftpdContextKill(context);
            TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_UNDEFINED, "Out of memory");
            goto exit_read_completion;
        }
    }
    context->wWait = NULL;

    if (context->state & TFTPD_STATE_DEAD)
        goto exit_read_completion;

    if (context->mode == TFTPD_MODE_TEXT)
        TftpdReadTranslateText(buffer, TFTPD_DATA_AMOUNT_RECEIVED(buffer));

    buffer = TftpdReadSendData(buffer);

exit_read_completion :

    if (buffer != NULL)
        TftpdIoPostReceiveBuffer(buffer->internal.socket, buffer);

    TftpdContextRelease(context);
    
} // TftpdReadOverlappedCompletion()


PTFTPD_BUFFER
TftpdReadResume(PTFTPD_BUFFER buffer) {

    PTFTPD_CONTEXT context = buffer->internal.context;
    DWORD error = NO_ERROR, size = 0;

    TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                 "TftpdReadResume(buffer = %p, context = %p).\n",
                 buffer, context));

    // NOTE: 'context' must be referenced before this call!
    ASSERT(context != NULL);

    // If we need to start the transfer with an OACK, do so now.
    if (context->options) {
        buffer = TftpdUtilSendOackPacket(buffer);
        goto exit_resume_read;
    }

    // Do we need to allocate a non-default buffer for transmitting
    // the file to the client?
    if (buffer->internal.socket == &globals.io.master) {
        buffer = TftpdIoSwapBuffer(buffer, context->socket);
        if (buffer == NULL) {
            TftpdContextKill(context);
            TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_UNDEFINED, "Out of memory");
            goto exit_resume_read;
        }
    } // if (buffer->message.opcode == TFTPD_RRQ)

    // Is there more data to send from the soure file?
    if (context->fileOffset.QuadPart < context->filesize.QuadPart) {

        // Determine size.
        size = __min((DWORD)context->blksize,
                     (DWORD)(context->filesize.QuadPart - context->fileOffset.QuadPart));

        // Prepare the overlapped read.
        buffer->internal.io.overlapped.OffsetHigh = context->fileOffset.HighPart;
        buffer->internal.io.overlapped.Offset     = context->fileOffset.LowPart;
        buffer->internal.io.overlapped.hEvent     = context->hWait;

        TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                     "TftpdReadResume(buffer = %p): "
                     "ReadFile(bytes = %d, offset = %d).\n",
                     buffer, size, context->fileOffset.LowPart));

        // Perform the read operation.
        if (!ReadFile(context->hFile,
                      &buffer->message.data.data,
                      size,
                      NULL,
                      &buffer->internal.io.overlapped))
            error = GetLastError();

        if ((error != NO_ERROR) && (error != ERROR_IO_PENDING)) {
            TFTPD_DEBUG((TFTPD_DBG_PROCESS,
                         "TftpdReadResume(context = %p, buffer = %p): "
                         "ReadFile() failed, error 0x%08X.\n",
                         context, buffer, error));
            TftpdContextKill(context);
            TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_FILE_NOT_FOUND, "Access violation");
            goto exit_resume_read;
        }

    } else {

        ASSERT(context->fileOffset.QuadPart == context->filesize.QuadPart);
        ASSERT(size == 0);
        
    } // if (context->fileOffset.QuadPart < context->filesize.QuadPart)

    buffer->internal.io.bytes = (TFTPD_MIN_RECEIVED_DATA + size);

    if (error == ERROR_IO_PENDING) {

        HANDLE wait = NULL;

        TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                     "TftpdReadResume(buffer = %p): ERROR_IO_PENDING.\n",
                     buffer));

        // Keep an overlapped-operation reference to the context.
        TftpdContextAddReference(context);

        // Register a wait for completion.
        ASSERT(context->wWait == NULL);
        if (!RegisterWaitForSingleObject(&wait,
                                         context->hWait,
                                         (WAITORTIMERCALLBACKFUNC)TftpdReadOverlappedCompletion,
                                         buffer,
                                         INFINITE,
                                         (WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE))) {
            TFTPD_DEBUG((TFTPD_DBG_PROCESS,
                         "TftpdReadResume(context = %p, buffer = %p): "
                         "RegisterWaitForSingleObject() failed, error 0x%08X.\n",
                         context, buffer, GetLastError()));
            // Reclaim the overlapped operation reference.
            TftpdContextKill(context);
            TftpdContextRelease(context);
            TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_UNDEFINED, "Out of memory");
            // Buffer will get leaked.
            buffer = NULL; // Buffer is being used for overlapped operation.
            goto exit_resume_read;
        }

        // Did the completion callback already fire before we could save the wait handle
        // into the context so it cannot deregister the wait?
        if (InterlockedExchangePointer(&context->wWait, wait) != INVALID_HANDLE_VALUE) {
            buffer = NULL; // Buffer is being used for overlapped operation.
            goto exit_resume_read;
        }
            
        // Reclaim the overlapped operation reference.
        TftpdContextRelease(context);

        if (!UnregisterWait(context->wWait)) {
            if ((error = GetLastError()) != ERROR_IO_PENDING) {
                TFTPD_DEBUG((TFTPD_DBG_PROCESS,
                             "TftpdReadResume(context = %p, buffer = %p): "
                             "UnregisterWait() failed, error 0x%08X.\n",
                             context, buffer, error));
                TftpdContextKill(context);
                TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_UNDEFINED, "Out of memory");
                // TftpdContextLeak(context);
                buffer = NULL; // Buffer is being used for overlapped operation.
                goto exit_resume_read;
            }
        }
        context->wWait = NULL;

        // Whoever deregisters the wait proceeds with the operation.

    } // if (error == ERROR_IO_PENDING)

    //
    // Read file completed immediately.
    //

    if (context->mode == TFTPD_MODE_TEXT)
        TftpdReadTranslateText(buffer, size);

    buffer = TftpdReadSendData(buffer);

exit_resume_read :

    return (buffer);

} // TftpdReadResume()


PTFTPD_BUFFER
TftpdReadAck(PTFTPD_BUFFER buffer) {

    PTFTPD_CONTEXT context = NULL;
    DWORD state, newState;

    // Ensure that an ACK isn't send to the master socket.
    if (buffer->internal.socket == &globals.io.master) {
        TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_ILLEGAL_OPERATION, "Illegal TFTP operation");
        goto exit_ack;
    }

    TFTPD_DEBUG((TFTPD_TRACE_PROCESS, "TftpdReadAck(buffer = %p).\n", buffer));

    //
    // Validate context.
    //

    context = TftpdContextAquire(&buffer->internal.io.peer);
    if (context == NULL) {
        TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                     "TftpdReadAck(buffer = %p): Received ACK for non-existant context.\n",
                     buffer));
        TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_UNKNOWN_TRANSFER_ID, "Unknown transfer ID");
        goto exit_ack;
    }

    // Is this a RRQ context?
    if (context->type != TFTPD_RRQ) {
        TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                     "TftpdReadAck(buffer = %p): Received ACK for non-RRQ context.\n",
                     buffer));
        TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_UNKNOWN_TRANSFER_ID, "Unknown transfer ID");
        goto exit_ack;
    }

    //
    // Validate ACK packet.
    //

    // If we sent an OACK, it must be ACK'd with block 0.
    if (context->options && (buffer->message.ack.block != 0)) {
        TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                     "TftpdReadAck: Ignoring ACK buffer = %p, "
                     "expected block 0 for acknowledgement of issued OACK.\n",
                     buffer));
        goto exit_ack;
    }

    //
    // Aquire busy-sending state.
    //

    do {

        USHORT block = context->block;

        if (context->state & (TFTPD_STATE_BUSY | TFTPD_STATE_DEAD))
            goto exit_ack;

        // Is it for the correct block?  The client can ACK the DATA packet
        // we just sent, or it could re-ACK the previous DATA packet meaning
        // it never saw the DATA packet we just sent in which case we need to
        // resend it.  If the ACK is equal to our internal block number, we
        // just need to resend.  If the ACK is equal to our internal block
        // number plus one, it's acking DATA we just sent so increment
        // our internal block number and send the next chunk.  Note that an
        // ACK to our OACK is with block 0, so it will just slip through
        // this code.
        if ((buffer->message.ack.block != block) &&
            (buffer->message.ack.block != (USHORT)(block + 1)))
            goto exit_ack;

    } while (InterlockedCompareExchange(&context->state, TFTPD_STATE_BUSY, 0) != 0);

    //
    // Update state.
    //

    // Prevent the transmission of an OACK.
    context->options = 0;

    // Client has responded to us with acceptable ACK packet, reset timeout counter.
    context->retransmissions = 0;

    // Update block and offsets if necessary.
    if (buffer->message.ack.block == (USHORT)(context->block + 1)) {

        context->block++;
        context->fileOffset.QuadPart += (context->blksize - context->translationOffset.QuadPart);
        context->sorcerer = buffer->message.ack.block;

    } else {

        // RFC 1123.  This is an ACK for the previous block number.
        // Our DATA packet may have been lost, or is merely taking the
        // scenic route through the network.  Go ahead and resend a
        // DATA packet in response to this ACK, however record the
        // block number for which this occurred as a form of history
        // tracking.  Should this occur again in the following block
        // number, we've fallen into the "Sorcerer's Apprentice" bug,
        // and we will break it by ignoring the secondary ACK of the
        // sequence.  However, we must be careful not to break
        // authentic resend requests, so after dropping an ACK in
        // an attempt to break the "Sorcerer's Apprentice" bug, we
        // will resume sending DATA packets in response and then
        // revert back to watching for the bug again.
        if (buffer->message.ack.block == context->sorcerer) {
#if defined(DBG)
            InterlockedIncrement(&globals.performance.sorcerersApprentice);
#endif // defined(DBG)
            context->sorcerer--;
            // Do NOT send the DATA this time.
            buffer->internal.context = context;
            TftpdProcessComplete(buffer);
            goto exit_ack;
        } else {
            context->sorcerer = buffer->message.ack.block;
        }

    } // if (buffer->message.ack.block == (USHORT)(context->block + 1))

    //
    // Send DATA.
    //

    // Is there any more data to send, including a zero-length
    // DATA packet if (filesize % blksize) is zero to terminate
    // the transfer?
    if (context->fileOffset.QuadPart > context->filesize.QuadPart) {
        TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                     "TftpdReadAck(buffer = %p, context = %p: RRQ complete.\n",
                     buffer, context));
        TftpdContextKill(context);
        goto exit_ack;
    }

    // Keep track of the context for the pending DATA we need to issue.
    buffer->internal.context = context;

    buffer = TftpdReadResume(buffer);

exit_ack :

    if (context != NULL)
        TftpdContextRelease(context);

    return (buffer);

} // TftpdReadAck()


PTFTPD_BUFFER
TftpdReadRequest(PTFTPD_BUFFER buffer) {

    PTFTPD_CONTEXT context = NULL;
    NTSTATUS status;

    // Ensure that a RRQ is from the master socket only.
    if (buffer->internal.socket != &globals.io.master) {
        TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_ILLEGAL_OPERATION,
                               "Illegal TFTP operation");
        goto exit_read_request;
    }

    // Is this a duplicate request?  Do we ignore it or send an error?
    if ((context = TftpdContextAquire(&buffer->internal.io.peer)) != NULL) {
        if (context->block > 0)
            TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_ILLEGAL_OPERATION,
                                   "Illegal TFTP operation");
        TftpdContextRelease(context);
        context = NULL;
        goto exit_read_request;
    }

    // Allocate a context for this request (this gives us a reference to it as well).
    if ((context = (PTFTPD_CONTEXT)TftpdContextAllocate()) == NULL)
        goto exit_read_request;

    TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                 "TftpdReadRequest(buffer = %p): context = %p.\n",
                 buffer, context));

    // Initialize the context.
    context->type = TFTPD_RRQ;
    CopyMemory(&context->peer, &buffer->internal.io.peer, sizeof(context->peer));
    context->state = TFTPD_STATE_BUSY;

    // Obtain and validate the requested filename, mode, and options.
    if (!TftpdUtilGetFileModeAndOptions(context, buffer)) {
        TFTPD_DEBUG((TFTPD_DBG_PROCESS,
                     "TftpdReadRequest(buffer = %p): "
                     "Invalid file mode = %d.\n",
                     buffer, context->mode));
        goto exit_read_request;
    }
    
    // Figure out which socket to use for this request (based on blksize).
    if (!TftpdIoAssignSocket(context, buffer)) {
        TFTPD_DEBUG((TFTPD_DBG_PROCESS,
                     "TftpdReadRequest(buffer = %p): "
                     "TftpdIoAssignSocket() failed.\n",
                     buffer));
        goto exit_read_request;
    }

    // Check whether access is permitted.
    if (!TftpdUtilMatch(globals.parameters.validClients, inet_ntoa(context->peer.sin_addr)) ||
        !TftpdUtilMatch(globals.parameters.validReadFiles, context->filename)) {
        TFTPD_DEBUG((TFTPD_DBG_PROCESS,
                     "TftpdReadRequest(buffer = %p): Access denied.\n",
                     buffer));
        TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_ACCESS_VIOLATION,
                               "Access violation");
        goto exit_read_request;
    }

    // Open the file.
    context->hFile = CreateFile(context->filename, GENERIC_READ,
                                FILE_SHARE_READ, NULL, OPEN_EXISTING,
                                FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_OVERLAPPED, NULL);
    if (context->hFile == INVALID_HANDLE_VALUE) {
        TFTPD_DEBUG((TFTPD_DBG_PROCESS,
                     "TftpdReadRequest(buffer = %p): "
                     "CreateFile() for filename = %s not found, error 0x%08X.\n",
                     buffer, context->filename, GetLastError()));
        TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_FILE_NOT_FOUND,
                               "File not found");
        context->hFile = NULL;
        goto exit_read_request;
    }
    if (!GetFileSizeEx(context->hFile, &context->filesize)) {
        TFTPD_DEBUG((TFTPD_DBG_PROCESS,
                     "TftpdReadRequest(buffer = %p): "
                     "Invalid file size for file name = %s.\n",
                     buffer, context->filename));
        TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_ACCESS_VIOLATION,
                               "Access violation");
        goto exit_read_request;
    }

    // Create the ReadFile() wait event.
    if ((context->hWait = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL) {
        TFTPD_DEBUG((TFTPD_DBG_PROCESS,
                     "TftpdReadRequest(buffer = %p): "
                     "CreateEvent() failed, error = %d.\n",
                     buffer, GetLastError()));
        TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_UNDEFINED, "Out of memory");
        goto exit_read_request;
    }

    // Insert the context into the hash-table.
    if (!TftpdContextAdd(context)) {
        TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                     "TftpdReadRequest(buffer = %p): "
                     "Dropping request as we're already servicing it.\n",
                     buffer));
        TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_UNDEFINED,
                               "Illegal TFTP operation");
        goto exit_read_request;
    }

    // Start the retransmission timer.
    if (!CreateTimerQueueTimer(&context->hTimer,
                               globals.io.hTimerQueue,
                               (WAITORTIMERCALLBACKFUNC)TftpdProcessTimeout,
                               context,
                               context->timeout,
                               720000,
                               WT_EXECUTEINIOTHREAD)) {
        TftpdContextKill(context);
        context = NULL;
        TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_UNDEFINED,
                               "Unable to initiate timeout timer.");
        goto exit_read_request;
    } // if (NT_SUCCESS(status))

    // Add our own reference to the context.
    TftpdContextAddReference(context);

    // If 'context->options' is non-zero, TftpdReadResume() will issue an OACK
    // instead of a DATA packet.  The subsquent ACK to the OACK will clear the
    // flags which will allow it to begin issuing subsequent DATA packets.
    buffer->internal.context = context;
    buffer = TftpdReadResume(buffer);

    // Free our own reference to the context.
    TftpdContextRelease(context);

    // If buffer != NULL, it gets recycled if possible.
    return (buffer);

exit_read_request :

    if (context != NULL)
        TftpdContextFree(context);

    // If buffer != NULL, it gets recycled if possible.
    return (buffer);

} // TftpdReadRequest()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\snmp\allinc.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:


Abstract:


Author:


Revision History:

--*/

#ifndef __ALLINC_H__
#define __ALLINC_H__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <crt\stddef.h>
#include <TCHAR.H>
#include <snmp.h>
#include <snmpexts.h>
#include <snmputil.h>
#include <iphlpapi.h>
#include <iphlpint.h>
#include <ipcmp.h>
#include <tcpinfo.h>
#include <ipinfo.h>
#include <ntddip.h>
#include <iphlpstk.h>
#include <ntddip6.h>

#ifdef MIB_DEBUG
#include <rtutils.h>
extern DWORD   g_hTrace;
#endif

#include "mibfuncs.h"

#include "defs.h"
#include "proto.h"
#include "indices.h"

extern DWORD   g_dwLastUpdateTable[NUM_CACHE];
extern DWORD   g_dwTimeoutTable[NUM_CACHE];

extern HANDLE               g_hPrivateHeap;

typedef 
DWORD
(*PFNLOAD_FUNCTION)();

extern PFNLOAD_FUNCTION g_pfnLoadFunctionTable[];

typedef struct _MIB_IPV6_IF_TABLE
{
    DWORD                 dwNumEntries;
    PMIB_IPV6_IF          table;
}MIB_IPV6_IF_TABLE, *PMIB_IPV6_IF_TABLE;

typedef struct _MIB_IPV6_ADDR_TABLE
{
    DWORD                 dwNumEntries;
    PMIB_IPV6_ADDR        table;
}MIB_IPV6_ADDR_TABLE, *PMIB_IPV6_ADDR_TABLE;

typedef struct _MIB_IPV6_NET_TO_MEDIA_TABLE
{
    DWORD                  dwNumEntries;
    PMIB_IPV6_NET_TO_MEDIA table;
}MIB_IPV6_NET_TO_MEDIA_TABLE, *PMIB_IPV6_NET_TO_MEDIA_TABLE;

typedef struct _MIB_IPV6_ROUTE_TABLE
{
    DWORD                  dwNumEntries;
    PMIB_IPV6_ROUTE        table;
}MIB_IPV6_ROUTE_TABLE, *PMIB_IPV6_ROUTE_TABLE;

typedef struct _MIB_IPV6_ADDR_PREFIX_TABLE
{
    DWORD                  dwNumEntries;
    PMIB_IPV6_ADDR_PREFIX  table;
}MIB_IPV6_ADDR_PREFIX_TABLE, *PMIB_IPV6_ADDR_PREFIX_TABLE;

typedef struct _MIB_INET_ICMP_TABLE
{
    DWORD                 dwNumEntries;
    PMIB_INET_ICMP        table;
}MIB_INET_ICMP_TABLE, *PMIB_INET_ICMP_TABLE;

typedef struct _MIB_INET_ICMP_MSG_TABLE
{
    DWORD                 dwNumEntries;
    PMIB_INET_ICMP_MSG    table;
}MIB_INET_ICMP_MSG_TABLE, *PMIB_INET_ICMP_MSG_TABLE;

typedef struct _MIB_CACHE
{
    PMIB_SYSINFO          pRpcSysInfo;
    PMIB_IFTABLE          pRpcIfTable;
    PMIB_UDPTABLE         pRpcUdpTable;
    PMIB_TCPTABLE         pRpcTcpTable;
    PMIB_IPADDRTABLE      pRpcIpAddrTable;
    PMIB_IPFORWARDTABLE   pRpcIpForwardTable;
    PMIB_IPNETTABLE       pRpcIpNetTable;
    PUDP6_LISTENER_TABLE  pRpcUdp6ListenerTable;
    PTCP6_EX_TABLE        pRpcTcp6Table;
    MIB_IPV6_NET_TO_MEDIA_TABLE pRpcIpv6NetToMediaTable;

    //
    // The following are protected by the same lock.
    //
    MIB_IPV6_ROUTE_TABLE  pRpcIpv6RouteTable;
    MIB_IPV6_ADDR_PREFIX_TABLE pRpcIpv6AddrPrefixTable;

    //
    // The following are protected by the same lock.
    //
    MIB_IPV6_IF_TABLE     pRpcIpv6IfTable;
    MIB_IPV6_ADDR_TABLE   pRpcIpv6AddrTable;

    //
    // The following are protected by the same lock.
    //
    MIB_INET_ICMP_TABLE     pRpcInetIcmpTable;
    MIB_INET_ICMP_MSG_TABLE pRpcInetIcmpMsgTable;
}MIB_CACHE, *PMIBCACHE;

extern PMIB_IFSTATUS    g_pisStatusTable;
extern DWORD            g_dwValidStatusEntries;
extern DWORD            g_dwTotalStatusEntries;

extern MIB_CACHE    g_Cache;

extern BOOL         g_bFirstTime;

BOOL
MibTrap(
        AsnInteger          *paiGenericTrap,
        AsnInteger          *paiSpecificTrap,
        RFC1157VarBindList  *pr1157vblVariableBindings
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\tftpd\write.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    write.c

Abstract:

    This module contains functions to manage TFTP write requests
    to the service from a client.

Author:

    Jeffrey C. Venable, Sr. (jeffv) 01-Jun-2001

Revision History:

--*/

#include "precomp.h"


PTFTPD_BUFFER
TftpdWriteSendAck(PTFTPD_BUFFER buffer) {

    PTFTPD_CONTEXT context = buffer->internal.context;

    TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                 "TftpdWriteSendAck(buffer = %p): context = %p.\n",
                 buffer, context));

    // NOTE: 'context' must be referenced before this call!
    ASSERT(context != NULL);

    // If we've gotten all of the data that the client is going to send,
    // we should close the file now before sending the final ACK because
    // if the client races back and asks for the file in a read request,
    // it mail fail due to a sharing violation (we have it open for write).
    if ((buffer->message.opcode != TFTPD_WRQ) &&
        (TFTPD_DATA_AMOUNT_RECEIVED(buffer) < context->blksize))
        TftpdContextKill(context);

    // Build the ACK.
    buffer->message.opcode = htons(TFTPD_ACK);
    buffer->message.ack.block = htons(context->block);
    buffer->internal.io.bytes = TFTPD_ACK_SIZE;

    // Complete the operation so we can receive the next DATA packet
    // if the client responds faster than we can exit sending the ACK.
    if (!TftpdProcessComplete(buffer))
        goto exit_send_ack;

    // Send the ACK.
    buffer = TftpdIoSendPacket(buffer);

exit_send_ack :

    return (buffer);

} // TftpdWriteSendAck()


void CALLBACK
TftpdWriteOverlappedCompletion(PTFTPD_BUFFER buffer, BOOLEAN timedOut) {

    PTFTPD_CONTEXT context = buffer->internal.context;

    if (InterlockedCompareExchangePointer(&context->wWait,
                                          INVALID_HANDLE_VALUE, NULL) == NULL)
        return;

    TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                 "TftpdWriteOverlappedCompletion(buffer = %p, context = %p).\n",
                 buffer, context));

    ASSERT(context->wWait != NULL);
    if (!UnregisterWait(context->wWait)) {
        DWORD error;
        if ((error = GetLastError()) != ERROR_IO_PENDING) {
            TFTPD_DEBUG((TFTPD_DBG_PROCESS,
                         "TftpdWriteOverlappedCompletion(buffer = %p, context = %p): "
                         "UnregisterWait() failed, error 0x%08X.\n",
                         buffer, context, error));
            TftpdContextKill(context);
            TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_UNDEFINED, "Out of memory");
            goto exit_write_completion;
        }
    }
    context->wWait = NULL;

    if (context->state & TFTPD_STATE_DEAD)
        goto exit_write_completion;

    context->fileOffset.QuadPart += (context->blksize - context->translationOffset.QuadPart);

    buffer = TftpdWriteSendAck(buffer);

exit_write_completion :

    if (buffer != NULL)
        TftpdIoPostReceiveBuffer(buffer->internal.socket, buffer);

    TftpdContextRelease(context);
    
} // TftpdWriteOverlappedCompletion()


void
TftpdWriteTranslateText(PTFTPD_BUFFER buffer, PDWORD bytes) {

    PTFTPD_CONTEXT context = buffer->internal.context;
    char *start, *end, *p, *q;

    TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                 "TftpdWriteTranslateText(buffer = %p, context = %p): bytes = %d.\n",
                 buffer, context, *bytes));

    // NOTE: 'context' must be referenced before this call!
    ASSERT(context != NULL);
    ASSERT(*bytes > 0);

    //
    // Text (translated) mode :
    //     The data received is in NVT-ASCII format.  There should be no solitary LF's
    //     to worry about, and solitary CR's would have had a '\0' appended to them.
    //     Cases to worry about:
    //         (a) CR + '\0' -> CR    (strip '\0')
    //         (b) Dangling CR at the end of a previously converted buffer which affects
    //             the output of the first character of the following buffer.
    //     We can do the conversion in-place.
    //

    // Convert the data in-place.
    start = (char *)&buffer->message.data.data;
    end = (start + *bytes);
    p = q = start;
    
    context->translationOffset.QuadPart = 0;

    if (start == end)
        return;

    if (context->danglingCR) {
        context->danglingCR = FALSE;
        if (*p == '\0') {
            p++; // This is a CR + '\0' combination, strip the '\0'.
            // Count the lost byte.
            context->translationOffset.QuadPart++;
            (*bytes)--;
        }
    }

    while (p < end) {

        while ((p < end) && (*p != '\0')) { *q++ = *p++; }

        if (p == end)
            break;

        if ((p > start) && (*(p - 1) == '\r')) {
            p++; // This is a CR + '\0' combination, strip the '\0'.
            // Count the lost byte.
            context->translationOffset.QuadPart++;
            (*bytes)--;
            continue;
        }

        // This is a solitary '\0', just copy it.
        *q++ = *p++;

    } // while (p < end)

    if (*(end - 1) == '\r')
        context->danglingCR = TRUE;

} // TftpdWriteTranslateText()


PTFTPD_BUFFER
TftpdWriteResume(PTFTPD_BUFFER buffer) {

    PTFTPD_CONTEXT context = buffer->internal.context;
    DWORD error = NO_ERROR, size = 0;

    TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                 "TftpdWriteResume(buffer = %p, context = %p).\n",
                 buffer, context));

    // NOTE: 'context' must be referenced before this call!
    ASSERT(context != NULL);

    // If we need to start the transfer with an OACK, do so now.
    if (context->options) {
        buffer = TftpdUtilSendOackPacket(buffer);
        goto exit_resume_write;
    }

    if (buffer->message.opcode == TFTPD_WRQ)
        goto send_ack;

    // Determine size of data to write.
    ASSERT(buffer->internal.io.bytes >= TFTPD_MIN_RECEIVED_DATA);
    size = TFTPD_DATA_AMOUNT_RECEIVED(buffer);
    if (size == 0)
        goto send_ack;

    if (context->mode == TFTPD_MODE_TEXT)
        TftpdWriteTranslateText(buffer, &size);

    // Prepare the overlapped write.
    buffer->internal.io.overlapped.OffsetHigh = context->fileOffset.HighPart;
    buffer->internal.io.overlapped.Offset     = context->fileOffset.LowPart;
    buffer->internal.io.overlapped.hEvent     = context->hWait;

    TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                 "TftpdWriteResume(buffer = %p): "
                 "WriteFile(bytes = %d, offset = %d).\n",
                 buffer, size, context->fileOffset.LowPart));

    // Perform the write operation.
    if (!WriteFile(context->hFile,
                   &buffer->message.data.data,
                   size,
                   NULL,
                   &buffer->internal.io.overlapped))
        error = GetLastError();

    if ((error != NO_ERROR) && (error != ERROR_IO_PENDING)) {
        TFTPD_DEBUG((TFTPD_DBG_PROCESS,
                     "TftpdWriteResume(context = %p, buffer = %p): "
                     "WriteFile() failed, error 0x%08X.\n",
                     context, buffer, error));
        TftpdContextKill(context);
        TftpdIoSendErrorPacket(buffer,
                               TFTPD_ERROR_DISK_FULL,
                               "Disk full or allocation exceeded");
        goto exit_resume_write;
    }

    if (error == ERROR_IO_PENDING) {

        HANDLE wait = NULL;

        TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                     "TftpdWriteResume(buffer = %p): ERROR_IO_PENDING.\n",
                     buffer));

        // Keep an overlapped-operation reference to the context (ie, don't release context).
        TftpdContextAddReference(context);

        // Register a wait for completion.
        ASSERT(context->wWait == NULL);
        if (!RegisterWaitForSingleObject(&wait,
                                         context->hWait,
                                         (WAITORTIMERCALLBACKFUNC)TftpdWriteOverlappedCompletion,
                                         buffer,
                                         INFINITE,
                                         (WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE))) {
            TFTPD_DEBUG((TFTPD_DBG_PROCESS,
                         "TftpdWriteResume(context = %p, buffer = %p): "
                         "RegisterWaitForSingleObject() failed, error 0x%08X.\n",
                         context, buffer, GetLastError()));
            // Reclaim the overlapped operation reference.
            TftpdContextKill(context);
            TftpdContextRelease(context);
            TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_UNDEFINED, "Out of memory");
            // Buffer will get leaked.
            buffer = NULL; // Buffer is being used for overlapped operation.
            goto exit_resume_write;
        }

        // Did the completion callback already fire before we could save the wait handle
        // into the context so it cannot deregister the wait?
        if (InterlockedExchangePointer(&context->wWait, wait) != INVALID_HANDLE_VALUE) {
            buffer = NULL; // Buffer is being used for overlapped operation.
            goto exit_resume_write;
        }
            
        // Reclaim the overlapped operation reference.
        TftpdContextRelease(context);

        if (!UnregisterWait(context->wWait)) {
            if ((error = GetLastError()) != ERROR_IO_PENDING) {
                TFTPD_DEBUG((TFTPD_DBG_PROCESS,
                             "TftpdWriteResume(context = %p, buffer = %p): "
                             "UnregisterWait() failed, error 0x%08X.\n",
                             context, buffer, error));
                TftpdContextKill(context);
                TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_UNDEFINED, "Out of memory");
                // TftpdContextLeak(context);
                buffer = NULL; // Buffer is being used for overlapped operation.
                goto exit_resume_write;
            }
        }
        context->wWait = NULL;

        // Whoever deregisters the wait proceeds with the operation.

    } // if (error == ERROR_IO_PENDING)

    //
    // Write file completed immediately.
    //

    context->fileOffset.QuadPart += (context->blksize - context->translationOffset.QuadPart);

send_ack :

    buffer = TftpdWriteSendAck(buffer);

exit_resume_write :

    return (buffer);

} // TftpdWriteResume()


PTFTPD_BUFFER
TftpdWriteData(PTFTPD_BUFFER buffer) {

    PTFTPD_CONTEXT context = NULL;

    // Ensure that a DATA isn't send to the master socket.
    if (buffer->internal.socket == &globals.io.master) {
        TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_ILLEGAL_OPERATION, "Illegal TFTP operation");
        goto exit_data;
    }

    TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                 "TftpdWriteData(buffer = %p): bytes = %d.\n",
                 buffer, buffer->internal.io.bytes));

    //
    // Validate context.
    //

    context = TftpdContextAquire(&buffer->internal.io.peer);
    if (context == NULL) {
        TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                     "TftpdWriteData(buffer = %p): Received DATA for non-existant context.\n",
                     buffer));
        TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_UNKNOWN_TRANSFER_ID, "Unknown transfer ID");
        goto exit_data;
    }

    // Is this a WRQ context?
    if (context->type != TFTPD_WRQ) {
        TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                     "TftpdWriteData(buffer = %p): Received DATA for non-WRQ context.\n",
                     buffer));
        TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_UNKNOWN_TRANSFER_ID, "Unknown transfer ID");
        goto exit_data;
    }

    //
    // Validate DATA packet.
    //

    // If we sent an OACK, the DATA had better be block 1.
    if (context->options && (buffer->message.data.block != 1)) {
        TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                     "TftpdWriteData: Ignoring DATA buffer = %p, "
                     "expected block 1 for acknowledgement of issued OACK.\n",
                     buffer));
        goto exit_data;
    }

    //
    // Aquire busy-sending state.
    //

    do {

        USHORT block = context->block;

        if (context->state & (TFTPD_STATE_BUSY | TFTPD_STATE_DEAD))
            goto exit_data;

        // Is it for the correct block?  The client can send DATA following
        // the ACK we just sent, or it could resend DATA which would cause us
        // to resend that ACK again meaning it never saw the ACK we just sent
        // in which case we just need to resend it.  If the DATA block is
        // equal to our internal block number, we just need to resend it.
        // If the DATA block is equal to our internal block number plus one,
        // it's new DATA so increment our internal block number and
        // ACK it.  Note that a DATA to our OACK will be with block 1.
        if ((buffer->message.data.block != block) &&
            (buffer->message.data.block != (USHORT)(block + 1)))
            goto exit_data;

    } while (InterlockedCompareExchange(&context->state, TFTPD_STATE_BUSY, 0) != 0);

    //
    // Update state.
    //

    // Prevent the transmission of an OACK.
    context->options = 0;

    // Client has responded to us with acceptable DATA packet, reset timeout counter.
    context->retransmissions = 0;

    //
    // Write data and/or send ACK.
    //

    // Keep track of the context for the pending ACK we need to issue.
    buffer->internal.context = context;

    if (buffer->message.data.block == (USHORT)(context->block + 1)) {

        context->block++;
        context->sorcerer = buffer->message.data.block;
        buffer = TftpdWriteResume(buffer);

    } else {

        // RFC 1123.  This is a DATA for the previous block number.
        // Our ACK packet may have been lost, or is merely taking the
        // scenic route through the network.  Go ahead and resend a
        // ACK packet in response to this DATA, however record the
        // block number for which this occurred as a form of history
        // tracking.  Should this occur again in the following block
        // number, we've fallen into the "Sorcerer's Apprentice" bug,
        // and we will break it by ignoring the secondary DATA of the
        // sequence.  However, we must be careful not to break
        // authentic resend requests, so after dropping an DATA in
        // an attempt to break the "Sorcerer's Apprentice" bug, we
        // will resume sending ACK packets in response and then
        // revert back to watching for the bug again.
        if (buffer->message.data.block == context->sorcerer) {
#if defined(DBG)
            InterlockedIncrement(&globals.performance.sorcerersApprentice);
#endif // defined(DBG)
            context->sorcerer--;
            // Do NOT send the ACK this time.
            buffer->internal.context = context;
            TftpdProcessComplete(buffer);
            goto exit_data;
        } else {
            context->sorcerer = buffer->message.data.block;
        }

        buffer = TftpdWriteSendAck(buffer);

    } // if (buffer->message.data.block == (USHORT)(context->block + 1))

exit_data :

    if (context != NULL)
        TftpdContextRelease(context);

    return (buffer);

} // TftpdWriteData()


PTFTPD_BUFFER
TftpdWriteRequest(PTFTPD_BUFFER buffer) {

    PTFTPD_CONTEXT context = NULL;
    NTSTATUS status;

    // Ensure that a WRQ is from the master socket only.
    if (buffer->internal.socket != &globals.io.master) {
        TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_ILLEGAL_OPERATION,
                               "Illegal TFTP operation");
        goto exit_write_request;
    }

    // Is this a duplicate request?  Do we ignore it or send an error?
    if ((context = TftpdContextAquire(&buffer->internal.io.peer)) != NULL) {
        if (context->block > 0)
            TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_ILLEGAL_OPERATION,
                                   "Illegal TFTP operation");
        TftpdContextRelease(context);
        context = NULL;
        goto exit_write_request;
    }

    // Allocate a context for this request (this gives us a reference to it as well).
    if ((context = (PTFTPD_CONTEXT)TftpdContextAllocate()) == NULL)
        goto exit_write_request;

    TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                 "TftpdWriteRequest(buffer = %p): context = %p.\n",
                 buffer, context));

    // Initialize the context.
    context->type = TFTPD_WRQ;
    context->state = TFTPD_STATE_BUSY;
    CopyMemory(&context->peer, &buffer->internal.io.peer, sizeof(context->peer));

    // Obtain and validate the requested filename, mode, and options.
    if (!TftpdUtilGetFileModeAndOptions(context, buffer)) {
        TFTPD_DEBUG((TFTPD_DBG_PROCESS,
                     "TftpdWriteRequest(buffer = %p): Invalid file mode = %d.\n",
                     buffer, context->mode));
        goto exit_write_request;
    }
    
    // Figure out which socket to use for this request (based on blksize).
    if (!TftpdIoAssignSocket(context, buffer)) {
        TFTPD_DEBUG((TFTPD_DBG_PROCESS,
                     "TftpdWriteRequest(buffer = %p): "
                     "TftpdIoAssignSocket() failed.\n",
                     buffer));
        goto exit_write_request;
    }

    // Check whether access is permitted.
    if (!TftpdUtilMatch(globals.parameters.validMasters, inet_ntoa(context->peer.sin_addr)) ||
        !TftpdUtilMatch(globals.parameters.validWriteFiles, context->filename)) {
        TFTPD_DEBUG((TFTPD_DBG_PROCESS,
                     "TftpdWriteRequest(buffer = %p): Access denied.\n",
                     buffer));
        TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_ACCESS_VIOLATION,
                               "Access violation");
        goto exit_write_request;
    }

    // Open the file.
    context->hFile = CreateFile(context->filename, GENERIC_WRITE, 0, NULL, CREATE_NEW,
                                FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_OVERLAPPED, NULL);
    if (context->hFile == INVALID_HANDLE_VALUE) {
        TFTPD_DEBUG((TFTPD_DBG_PROCESS,
                     "TftpdWriteRequest(buffer = %p): "
                     "File name = %s not found, error = 0x%08X.\n",
                     buffer, context->filename, GetLastError()));
        if (GetLastError() == ERROR_ALREADY_EXISTS)
            TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_FILE_EXISTS, "Cannot overwrite file.");
        else
            TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_ACCESS_VIOLATION, "Access violation.");
        context->hFile = NULL;
        goto exit_write_request;
    }

    // Create the WriteFile() wait event.
    if ((context->hWait = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL) {
        TFTPD_DEBUG((TFTPD_DBG_PROCESS,
                     "TftpdWriteRequest(buffer = %p): "
                     "CreateEvent() failed, error = %d.\n",
                     buffer, GetLastError()));
        TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_UNDEFINED, "Out of memory");
        goto exit_write_request;
    }

    // Insert the context into the hash-table.
    if (!TftpdContextAdd(context)) {
        TFTPD_DEBUG((TFTPD_TRACE_PROCESS,
                     "TftpdWriteRequest(buffer = %p): "
                     "Dropping request as we're already servicing it.\n",
                     buffer));
        TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_UNDEFINED,
                               "Illegal TFTP operation");
        goto exit_write_request;
    }

    // Start the retransmission timer.
    if (!CreateTimerQueueTimer(&context->hTimer,
                               globals.io.hTimerQueue,
                               (WAITORTIMERCALLBACKFUNC)TftpdProcessTimeout,
                               context,
                               context->timeout,
                               720000,
                               WT_EXECUTEINIOTHREAD)) {
        TftpdContextKill(context);
        context = NULL;
        TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_UNDEFINED,
                               "Unable to initiate timeout timer.");
        goto exit_write_request;
    } // if (NT_SUCCESS(status))

    // Add our own reference to the context.
    TftpdContextAddReference(context);

    // If 'context->options' is non-zero, TftpdResumeWrite() will issue an OACK
    // instead of an ACK packet.  The subsquent DATA to the OACK will clear the
    // flags which will allow it to begin issuing subsequent ACK packets.
    buffer->internal.context = context;
    buffer = TftpdWriteResume(buffer);

    // Free our own reference to the context.
    TftpdContextRelease(context);

    // If buffer != NULL, it gets recycled if possible.
    return (buffer);

exit_write_request :

    if (context != NULL)
        TftpdContextFree(context);

    // If buffer != NULL, it gets recycled if possible.
    return (buffer);

} // TftpdWriteRequest()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\tftpd\service.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    service.c

Abstract:

    This module contains functions to implement TFTP
    as a NT system service.  It contains the startup
    and cleanup code for the service.

Author:

    Jeffrey C. Venable, Sr. (jeffv) 01-Jun-2001

Revision History:

--*/

#include "precomp.h"
#include <winsvc.h>


TFTPD_GLOBALS globals;


void
TftpdServiceCleanup() {

    NTSTATUS status;
    UINT x;

    TFTPD_DEBUG((TFTPD_TRACE_SERVICE, "TftpdServiceCleanup().\n"));

    // Destroy the hash table.
    ASSERT(globals.hash.numEntries == 0);
    if (globals.initialized.contextHashTable) {
        for (x = 0; x < globals.parameters.hashEntries; x++)
            DeleteCriticalSection(&globals.hash.table[x].cs);
        HeapFree(globals.hServiceHeap, 0, globals.hash.table);
        globals.hash.table = NULL;
        globals.initialized.contextHashTable = FALSE;
    }

    // Destroy the timeout timer queue.
    if (!DeleteTimerQueueEx(globals.io.hTimerQueue, INVALID_HANDLE_VALUE)) {
        TFTPD_DEBUG((TFTPD_DBG_SERVICE,
                     "TftpdServiceCleanup(): DeleteTimerQueueEx() failed, "
                     "error = 0x%08X.\n",
                     GetLastError()));
    }
    globals.io.hTimerQueue = NULL;

    // Undo initialized things.
    if (globals.initialized.ioCS) {
        DeleteCriticalSection(&globals.io.cs);
        globals.initialized.ioCS = FALSE;
    }
    if (globals.initialized.reaperContextCS) {
        DeleteCriticalSection(&globals.reaper.contextCS);
        globals.initialized.reaperContextCS = FALSE;
    }
    if (globals.initialized.reaperSocketCS) {
        DeleteCriticalSection(&globals.reaper.socketCS);
        globals.initialized.reaperSocketCS = FALSE;
    }
    if (globals.initialized.winsock) {
        WSACleanup();
        globals.initialized.winsock = FALSE;
    }

    // Clean up the service heap.
    if (globals.hServiceHeap != GetProcessHeap()) {

        // We used a private heap, destroying it will automatically deallocate
        // everything we used, including connections.
        HeapDestroy(globals.hServiceHeap);

    } else {

        // We had to use the process heap instead of a private heap,
        // cleanup remaining allocations.

    } // if (globals.hServiceHeap != GetProcessHeap())
    globals.hServiceHeap = NULL;

    // Unregister event-logging if necessary.
    if (globals.service.hEventLogSource != NULL)
        DeregisterEventSource(globals.service.hEventLogSource), globals.service.hEventLogSource = NULL;

    // Notify the service control manager that we've stopped.
    globals.service.status.dwCurrentState = SERVICE_STOPPED;
    SetServiceStatus(globals.service.hStatus, &globals.service.status);

    if (globals.reaper.numLeakedContexts) {
        TFTPD_DEBUG((TFTPD_DBG_SERVICE,
                     "TftpdServiceCleanup(): Leaked %d contexts.\n",
                     globals.reaper.numLeakedContexts));
    }

    if (globals.reaper.numLeakedSockets) {
        TFTPD_DEBUG((TFTPD_DBG_SERVICE,
                     "TftpdServiceCleanup(): Leaked %d sockets.\n",
                     globals.reaper.numLeakedSockets));
    }

    TFTPD_DEBUG((TFTPD_TRACE_SERVICE, "TftpdServiceCleanup(): Service stopped.\n"));

} // TftpdServiceCleanup()


void
TftpdServiceAttemptCleanup() {

    TFTPD_DEBUG((TFTPD_TRACE_SERVICE, "TftpdServiceAttemptCleanup().\n"));

    InterlockedIncrement((PLONG)&globals.service.status.dwCheckPoint);
    SetServiceStatus(globals.service.hStatus, &globals.service.status);

    if ((globals.io.numBuffers != -1) || (globals.io.numContexts != -1))
        return;

    if (InterlockedCompareExchange((PLONG)&globals.service.shutdown, 2, 1) != 1)
        return;

    TftpdServiceCleanup();

} // TftpdServiceAttemptCleanup()


void
TftpdShutdownService() {

    UINT x;

    TFTPD_DEBUG((TFTPD_TRACE_SERVICE, "TftpdShutdownService().\n"));

    ASSERT(globals.service.status.dwCurrentState != SERVICE_STOPPED);

    // Set the shutdown flag.
    InterlockedExchange((PLONG)&globals.service.shutdown, 1);

    // Notify the service control manager that we're going to stop.
    globals.service.status.dwCurrentState = SERVICE_STOP_PENDING;
    globals.service.status.dwWaitHint = 5000;
    globals.service.status.dwCheckPoint = 0;
    SetServiceStatus(globals.service.hStatus, &globals.service.status);

    // Close the sockets.
    EnterCriticalSection(&globals.io.cs); {

        if (globals.io.master.s != INVALID_SOCKET)
            TftpdIoDestroySocketContext(&globals.io.master);
        if (globals.io.def.s != INVALID_SOCKET)
            TftpdIoDestroySocketContext(&globals.io.def);
        if (globals.io.mtu.s != INVALID_SOCKET)
            TftpdIoDestroySocketContext(&globals.io.mtu);
        if (globals.io.max.s != INVALID_SOCKET)
            TftpdIoDestroySocketContext(&globals.io.max);

    } LeaveCriticalSection(&globals.io.cs);

    // Empty out all the contexts from the hash table.
    for (x = 0; x < globals.parameters.hashEntries; x++) {
        
        EnterCriticalSection(&globals.hash.table[x].cs); {
            
            while (globals.hash.table[x].bucket.Flink != &globals.hash.table[x].bucket)
                TftpdContextKill(CONTAINING_RECORD(globals.hash.table[x].bucket.Flink,
                                                   TFTPD_CONTEXT, linkage));

        } LeaveCriticalSection(&globals.hash.table[x].cs);

    } // for (unsigned int x = 0; x < globals.parameters.hashEntries; x++)

    // Empty out all the contexts from the leak list.
    EnterCriticalSection(&globals.reaper.contextCS); {

        PLIST_ENTRY entry;

        while ((entry = RemoveHeadList(&globals.reaper.leakedContexts)) !=
                &globals.reaper.leakedContexts) {

            PTFTPD_CONTEXT context = CONTAINING_RECORD(entry, TFTPD_CONTEXT, linkage);
            if (!TftpdContextFree(context)) {
                // Free the reference from it having been on the leak list.
                TftpdContextRelease(context);
            }
            globals.reaper.numLeakedContexts--;

        }

    } LeaveCriticalSection(&globals.reaper.contextCS);

    // Empty out all the sockets from the leak list.
    EnterCriticalSection(&globals.reaper.socketCS); {

        PLIST_ENTRY entry;
        while ((entry = RemoveHeadList(&globals.reaper.leakedSockets)) !=
                &globals.reaper.leakedSockets) {

            TftpdIoDestroySocketContext(CONTAINING_RECORD(entry, TFTPD_SOCKET, linkage));
            globals.reaper.numLeakedSockets--;

        }

    } LeaveCriticalSection(&globals.reaper.socketCS);

    InterlockedDecrement(&globals.io.numBuffers);
    InterlockedDecrement(&globals.io.numContexts);

    TftpdServiceAttemptCleanup();

} // TftpdShutdownService()


BOOL
TftpdSetStartDirectory(char *path) {

    char expanded[MAX_PATH];
    int length;

    if (path == NULL)
        path = "\\tftpdroot";
    
    // Expand the string and leave room to insert a trailing '\\'.
    if ((length = ExpandEnvironmentStrings(path, expanded, sizeof(expanded) - 1)) == 0)
        return (FALSE);

    CopyMemory(globals.parameters.rootDirectory, expanded, length);
    if ((globals.parameters.rootDirectory[length - 1] != '\\') && (length < MAX_PATH))
        strcat(globals.parameters.rootDirectory, "\\");
    
    return (TRUE);

} // TftpdSetStartDirectory()


void
TftpdReadRegistryParameters() {

    DWORD keyType, valueSize;
    char path[MAX_PATH];
    HKEY parameters = NULL;

    // Open the registry key which contains all the adjustable parameters
    // to the service.  We will register for notification on it later incase
    // anything changes while we're running.
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     "System\\CurrentControlSet\\Services\\Tftpd\\Parameters",
                     0, KEY_QUERY_VALUE, &parameters) != ERROR_SUCCESS)
        parameters = NULL;
    if (parameters == NULL) {
        globals.parameters.hashEntries   =   256;
        globals.parameters.lowWaterMark  =     5;
        globals.parameters.highWaterMark =   256;
        globals.parameters.maxRetries    =    10;
        TftpdSetStartDirectory(NULL);
        strcpy(globals.parameters.validClients,    "*.*.*.*");
        strcpy(globals.parameters.validReadFiles,  "*");
        strcpy(globals.parameters.validMasters,    "*.*.*.*");
        strcpy(globals.parameters.validWriteFiles, "*");
        return;
    }

#if (DBG)
    // Initialize debug settings (if applicable) :
    keyType = 0;
    valueSize = sizeof(globals.parameters.debugFlags);
    if ((RegQueryValueEx(parameters, "DebugFlags", NULL, &keyType,
                         (LPBYTE)&globals.parameters.debugFlags, &valueSize) != ERROR_SUCCESS) ||
        (keyType != REG_DWORD)) {
        globals.parameters.debugFlags = 0x00000000;
    }
#endif // (DBG)

    keyType = 0;
    valueSize = sizeof(globals.parameters.hashEntries);
    if ((RegQueryValueEx(parameters, "HashEntries", NULL, &keyType,
                         (LPBYTE)&globals.parameters.hashEntries, &valueSize) != ERROR_SUCCESS) ||
        (keyType != REG_DWORD) || !globals.parameters.hashEntries)
        globals.parameters.hashEntries = 256;
    if (globals.parameters.hashEntries < 1)
        globals.parameters.hashEntries = 1;

    keyType = 0;
    valueSize = sizeof(globals.parameters.lowWaterMark);
    if ((RegQueryValueEx(parameters, "LowWaterMark", NULL, &keyType,
                         (LPBYTE)&globals.parameters.lowWaterMark, &valueSize) != ERROR_SUCCESS) ||
        (keyType != REG_DWORD) || !globals.parameters.lowWaterMark)
        globals.parameters.lowWaterMark = 5;

    keyType = 0;
    valueSize = sizeof(globals.parameters.highWaterMark);
    if ((RegQueryValueEx(parameters, "HighWaterMark", NULL, &keyType,
                         (LPBYTE)&globals.parameters.highWaterMark, &valueSize) != ERROR_SUCCESS) ||
        (keyType != REG_DWORD) || !globals.parameters.highWaterMark)
        globals.parameters.highWaterMark = 256;

    keyType = 0;
    valueSize = sizeof(globals.parameters.maxRetries);
    if ((RegQueryValueEx(parameters, "MaxRetries", NULL, &keyType,
                         (LPBYTE)&globals.parameters.maxRetries, &valueSize) != ERROR_SUCCESS) ||
        (keyType != REG_DWORD) || !globals.parameters.maxRetries)
        globals.parameters.maxRetries = 4;

    path[0] = '\0';
    keyType = 0;
    valueSize = sizeof(globals.parameters.rootDirectory);
    if ((RegQueryValueEx(parameters, "directory", NULL, &keyType, (LPBYTE)path, &valueSize) != ERROR_SUCCESS) ||
        (keyType != REG_SZ))
        TftpdSetStartDirectory(NULL);
    else
        TftpdSetStartDirectory(path);

    keyType = 0;
    valueSize = sizeof(globals.parameters.validClients);
    if ((RegQueryValueEx(parameters, "clients", NULL, &keyType,
                         (LPBYTE)&globals.parameters.validClients, &valueSize) != ERROR_SUCCESS) ||
        (keyType != REG_SZ))
        strcpy(globals.parameters.validClients, "*.*.*.*");

    keyType = 0;
    valueSize = sizeof(globals.parameters.validReadFiles);
    if ((RegQueryValueEx(parameters, "readable", NULL, &keyType,
                         (LPBYTE)&globals.parameters.validReadFiles, &valueSize) != ERROR_SUCCESS) ||
        (keyType != REG_SZ))
        strcpy(globals.parameters.validReadFiles, "*");

    keyType = 0;
    valueSize = sizeof(globals.parameters.validMasters);
    if ((RegQueryValueEx(parameters, "masters", NULL, &keyType,
                         (LPBYTE)&globals.parameters.validMasters, &valueSize) != ERROR_SUCCESS) ||
        (keyType != REG_SZ))
        strcpy(globals.parameters.validMasters, "*.*.*.*");

    keyType = 0;
    valueSize = sizeof(globals.parameters.validWriteFiles);
    if ((RegQueryValueEx(parameters, "writable", NULL, &keyType,
                         (LPBYTE)&globals.parameters.validWriteFiles, &valueSize) != ERROR_SUCCESS) ||
        (keyType != REG_SZ))
        strcpy(globals.parameters.validWriteFiles, "*");

    RegCloseKey(parameters);

} // TftpdReadRegistryParameters()


void WINAPI
TftpdServiceHandler(
    DWORD dwOpcode
);


void WINAPI
TftpdServiceMain(DWORD argc, PWSTR argv[]) {

    WSADATA wsaData;
    PSERVENT servent;
    SOCKADDR_IN addr;
    NTSTATUS status;
    UINT x;

    TftpdReadRegistryParameters();

    // Register the service control handler.
    if ((globals.service.hStatus = RegisterServiceCtrlHandler(TEXT("Tftpd"), TftpdServiceHandler)) == 0) {
        globals.service.status.dwWin32ExitCode = GetLastError();
        TFTPD_DEBUG((TFTPD_DBG_SERVICE,
                     "ServiceMain: RegisterServiceCtrlHandler() failed, error 0x%08X.\n",
                     globals.service.status.dwWin32ExitCode));
        TftpdLogEvent(EVENTLOG_ERROR_TYPE, 0, 0);
        goto stop_service;
    }

    // Immediately report that we are beginning to start up.
    globals.service.status.dwServiceType      = SERVICE_WIN32_OWN_PROCESS;
    globals.service.status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    globals.service.status.dwCurrentState     = SERVICE_START_PENDING;
    SetServiceStatus(globals.service.hStatus, &globals.service.status);
   
    TFTPD_DEBUG((TFTPD_TRACE_SERVICE,
                 "\nTftpdServiceMain: Parameters...\n"
                 "\tDebug flags              : 0x%08X\n"
                 "\tHash table size          : %d buckets\n"
                 "\tBuffer low water-mark    : %d buffers\n"
                 "\tBuffer high water-mark   : %d buffers\n"
                 "\tMax retries              : %d attempts\n"
                 "\tRoot directory           : %s\n"
                 "\tValid client mask        : %s\n"
                 "\tValid read file mask     : %s\n"
                 "\tValid master mask        : %s\n"
                 "\tValid write file mask    : %s\n",
                 globals.parameters.debugFlags,
                 globals.parameters.hashEntries,
                 globals.parameters.lowWaterMark,
                 globals.parameters.highWaterMark,
                 globals.parameters.maxRetries,
                 globals.parameters.rootDirectory,
                 globals.parameters.validClients,
                 globals.parameters.validReadFiles,
                 globals.parameters.validMasters,
                 globals.parameters.validWriteFiles));

    // Attempt to create the service's private heap.
    if ((globals.hServiceHeap = HeapCreate(0, 0, 0)) == NULL)
        globals.hServiceHeap = GetProcessHeap();

    __try { InitializeCriticalSection(&globals.io.cs); }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        globals.service.status.dwWin32ExitCode = _exception_code();
        TFTPD_DEBUG((TFTPD_DBG_SERVICE,
                   "InitializeCriticalSection() raised exception 0x%08X.\n",
                   globals.service.status.dwWin32ExitCode));
        TftpdLogEvent(EVENTLOG_ERROR_TYPE, 0, 0);
        goto stop_service;
    }
    globals.initialized.ioCS = TRUE;

    __try { InitializeCriticalSection(&globals.reaper.contextCS); }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        globals.service.status.dwWin32ExitCode = _exception_code();
        TFTPD_DEBUG((TFTPD_DBG_SERVICE,
                   "InitializeCriticalSection() raised exception 0x%08X.\n",
                   globals.service.status.dwWin32ExitCode));
        TftpdLogEvent(EVENTLOG_ERROR_TYPE, 0, 0);
        goto stop_service;
    }
    globals.initialized.reaperContextCS = TRUE;
    InitializeListHead(&globals.reaper.leakedContexts);

    __try { InitializeCriticalSection(&globals.reaper.socketCS); }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        globals.service.status.dwWin32ExitCode = _exception_code();
        TFTPD_DEBUG((TFTPD_DBG_SERVICE,
                   "InitializeCriticalSection() raised exception 0x%08X.\n",
                   globals.service.status.dwWin32ExitCode));
        TftpdLogEvent(EVENTLOG_ERROR_TYPE, 0, 0);
        goto stop_service;
    }
    globals.initialized.reaperSocketCS = TRUE;
    InitializeListHead(&globals.reaper.leakedSockets);

    // Initialize Winsock.
    if (globals.service.status.dwWin32ExitCode = WSAStartup(MAKEWORD(2, 0), &wsaData)) {
        TFTPD_DEBUG((TFTPD_DBG_SERVICE,
                     "ServiceMain: WSAStartup() failed, error 0x%08X.\n",
                     globals.service.status.dwWin32ExitCode));
        TftpdLogEvent(EVENTLOG_ERROR_TYPE, 0, 0);
        goto stop_service;
    }
    globals.initialized.winsock = TRUE;

    // Initialize the socket contexts.
    globals.io.master.s             = INVALID_SOCKET;
    globals.io.master.buffersize    = TFTPD_DEF_BUFFER;
    globals.io.master.datasize      = TFTPD_DEF_DATA;
    globals.io.master.lowWaterMark  = globals.parameters.lowWaterMark;
    globals.io.master.highWaterMark = globals.parameters.highWaterMark;
    globals.io.def.s                = INVALID_SOCKET;
    globals.io.def.buffersize       = TFTPD_DEF_BUFFER;
    globals.io.def.datasize         = TFTPD_DEF_DATA;
    globals.io.def.lowWaterMark     = globals.parameters.lowWaterMark;
    globals.io.def.highWaterMark    = globals.parameters.highWaterMark;
    globals.io.mtu.s                = INVALID_SOCKET;
    globals.io.mtu.buffersize       = TFTPD_MTU_BUFFER;
    globals.io.mtu.datasize         = TFTPD_MTU_DATA;
    globals.io.mtu.lowWaterMark     = globals.parameters.lowWaterMark;
    globals.io.mtu.highWaterMark    = globals.parameters.highWaterMark;
    globals.io.max.s                = INVALID_SOCKET;
    globals.io.max.buffersize       = TFTPD_MAX_BUFFER;
    globals.io.max.datasize         = TFTPD_MAX_DATA;
    globals.io.max.lowWaterMark     = globals.parameters.lowWaterMark;
    globals.io.max.highWaterMark    = globals.parameters.highWaterMark;

    // Initialize the context hash table.
    globals.hash.table =
        (PTFTPD_HASH_BUCKET)HeapAlloc(globals.hServiceHeap,
                                      HEAP_ZERO_MEMORY,
                                      (globals.parameters.hashEntries *
                                       sizeof(TFTPD_HASH_BUCKET)));
    if (globals.hash.table == NULL)
        goto stop_service;

    for (x = 0; x < globals.parameters.hashEntries; x++) {

        __try { InitializeCriticalSection(&globals.hash.table[x].cs); }
        __except (EXCEPTION_EXECUTE_HANDLER) {

            int y;

            globals.service.status.dwWin32ExitCode = _exception_code();
            TFTPD_DEBUG((TFTPD_DBG_SERVICE,
                       "InitializeCriticalSection() raised exception 0x%08X.\n",
                       globals.service.status.dwWin32ExitCode));
            TftpdLogEvent(EVENTLOG_ERROR_TYPE, 0, 0);

            for (y = (x - 1); y >= 0; y--)
                DeleteCriticalSection(&globals.hash.table[y].cs);

            HeapFree(globals.hServiceHeap, 0, globals.hash.table);
            globals.hash.table = NULL;

            goto stop_service;

        }

        InitializeListHead(&globals.hash.table[x].bucket);

    }
    globals.initialized.contextHashTable = TRUE;

    //
    // Start the thread pool :
    //

    // Create the timer queue for timeouts.
    globals.io.hTimerQueue = CreateTimerQueue();
    if (globals.io.hTimerQueue == NULL) {
        globals.service.status.dwWin32ExitCode = GetLastError();
        TFTPD_DEBUG((TFTPD_DBG_SERVICE,
                     "ServiceMain: CreateTimerQueue() failed, error 0x%08X.\n",
                     globals.service.status.dwWin32ExitCode));
        TftpdLogEvent(EVENTLOG_ERROR_TYPE, 0, 0);
        goto stop_service;
    }
    
    // Obtain the udp tftp service port to bind the master UDP service socket to.
    if ((servent = getservbyname("tftp", "udp")) == NULL) {
        globals.service.status.dwWin32ExitCode = WSAGetLastError();
        TFTPD_DEBUG((TFTPD_DBG_SERVICE,
                     "ServiceMain: getservbyname() failed, error 0x%08X.\n",
                     globals.service.status.dwWin32ExitCode));
        TftpdLogEvent(EVENTLOG_ERROR_TYPE, 0, 0);
        goto stop_service;
    }
    addr.sin_family      = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port        = servent->s_port;

    // Create the master UDP service socket.
    TftpdIoInitializeSocketContext(&globals.io.master, &addr, NULL);
    if (globals.io.master.s == INVALID_SOCKET) {
        globals.service.status.dwWin32ExitCode = GetLastError();
        TFTPD_DEBUG((TFTPD_DBG_SERVICE,
                     "ServiceMain: TftpdIoInitializeSocketContext() failed, error 0x%08X.\n",
                     globals.service.status.dwWin32ExitCode));
        TftpdLogEvent(EVENTLOG_ERROR_TYPE, 0, 0);
        goto stop_service;
    }

    // Notify the service control manager that we're ready to go.
    globals.service.status.dwCurrentState = SERVICE_RUNNING;
    SetServiceStatus(globals.service.hStatus, &globals.service.status);

    TFTPD_DEBUG((TFTPD_TRACE_SERVICE, "TftpdServiceMain(): Service running.\n"));

    return;

stop_service :

    TftpdShutdownService();

} // TftpdServiceMain()


void WINAPI
TftpdServiceHandler(DWORD dwOpcode) {
    
    switch (dwOpcode) {
        
        case SERVICE_CONTROL_INTERROGATE :

            SetServiceStatus(globals.service.hStatus, &globals.service.status);
            TFTPD_DEBUG((TFTPD_TRACE_SERVICE,
                         "TftpdServiceHandler(SERVICE_CONTROL_INTERROGATE)...\n"
                         "\tMax Clients              : %d\n"
                         "\tTimeouts                 : %d\n"
                         "\tDrops                    : %d\n"
                         "\tPrivate sockets          : %d\n"
                         "\tSorcerer's Apprentice    : %d\n",
                         globals.performance.maxClients,
                         globals.performance.timeouts,
                         globals.performance.drops,
                         globals.performance.privateSockets,
                         globals.performance.sorcerersApprentice));
            break;

        case SERVICE_CONTROL_STOP :

            TFTPD_DEBUG((TFTPD_TRACE_SERVICE, "TftpdServiceHandler: SERVICE_CONTROL_STOP.\n"));

            if (globals.service.shutdown) {
                if (globals.service.shutdown == 1)
                    SetServiceStatus(globals.service.hStatus, &globals.service.status);
                return;
            }

            TftpdShutdownService();
            break;

        default :

            TFTPD_DEBUG((TFTPD_TRACE_SERVICE, "TftpdServiceHandler: Unknown request 0x%08X.\n", dwOpcode));

    } // switch (dwOpcode)

} // TftpdServiceHandler()


void __cdecl
main(int argc, char *argv[]) {

    SERVICE_TABLE_ENTRY dispatch[] = {
        { TEXT("Tftpd"), (LPSERVICE_MAIN_FUNCTION)TftpdServiceMain },
        { NULL, NULL }
    };

    StartServiceCtrlDispatcher(dispatch);

} // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\tftpd\util.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    util.c

Abstract:

    This module contains functions to parse and construct server
    file paths for client requests, request option negotiation,
    and client access security.

Author:

    Jeffrey C. Venable, Sr. (jeffv) 01-Jun-2001

Revision History:

--*/

#include "precomp.h"


#define IS_SEPARATOR(c) (((c) == '\\') || ((c) == '/'))


BOOL
TftpdUtilIsValidString(char *string, unsigned int maxLength) {

    UINT x;

    // Make sure 'string' is null-terminated.
    for (x = 0; x < maxLength; x++)
        if (!string[x])
            return (TRUE);

    return (FALSE);

} // TftpdUtilIsValidString()


BOOL
TftpdUtilCanonicalizeFileName(char *filename) {

    char *source, *destination, *lastComponent;

    // The canonicalization is done in place.  Initialize the source and
    // destination pointers to point to the same place.
    source = destination = filename;

    // The lastComponent variable is used as a placeholder when
    // backtracking over trailing blanks and dots.  It points to the
    // first character after the last directory separator or the
    // beginning of the pathname.
    lastComponent = filename;

    // Get rid of leading directory separators.
    while ((*source != 0) && IS_SEPARATOR(*source))
        source++;

    // Walk through the pathname until we reach the zero terminator.  At
    // the start of this loop, source points to the first charaecter
    // after a directory separator or the first character of the
    // pathname.
    while (*source) {

        if (*source == '.') {

            // If we see a dot, look at the next character.
            if (IS_SEPARATOR(*(source + 1))) {

                // If the next character is a directory separator,
                // advance the source pointer to the directory
                // separator.
                source++;

            } else if ((*(source + 1) == '.') && IS_SEPARATOR(*(source + 2))) {

                // If the following characters are ".\", we have a "..\".
                // Advance the source pointer to the "\".
                source += 2;

                // Move the destination pointer to the character before the
                // last directory separator in order to prepare for backing
                // up.  This may move the pointer before the beginning of
                // the name pointer.
                destination -= 2;

                // If destination points before the beginning of the name
                // pointer, fail because the user is attempting to go
                // to a higher directory than the TFTPD root.  This is
                // the equivalent of a leading "..\", but may result from
                // a case like "dir\..\..\file".
                if (destination <= filename)
                    return (FALSE);

                // Back up the destination pointer to after the last
                // directory separator or to the beginning of the pathname.
                // Backup to the beginning of the pathname will occur
                // in a case like "dir\..\file".
                while ((destination >= filename) && !IS_SEPARATOR(*destination))
                    destination--;

                // destination points to \ or character before name; we
                // want it to point to character after last \.
                destination++;

            } else {

                // The characters after the dot are not "\" or ".\", so
                // so just copy source to destination until we reach a
                // directory separator character.  This will occur in
                // a case like ".file" (filename starts with a dot).
                do {
                    *destination++ = *source++;
                } while (*source && !IS_SEPARATOR(*source));

            } // if (IS_SEPARATOR(*(source + 1)))

        } else {

            // source does not point to a dot, so copy source to
            // destination until we get to a directory separator.
            while (*source && !IS_SEPARATOR(*source))
                *destination++ = *source++;

        } // if (*source == '.')

        // Truncate trailing blanks.  destination should point to the last
        // character before the directory separator, so back up over blanks.
        while ((destination > lastComponent) && (*(destination - 1) == ' '))
            destination--;

        // At this point, source points to a directory separator or to
        // a zero terminator.  If it is a directory separator, put one
        // in the destination.
        if (IS_SEPARATOR(*source)) {

            // If we haven't put the directory separator in the path name,
            // put it in.
            if ((destination != filename) && !IS_SEPARATOR(*(destination - 1)))
                *destination++ = '\\';

            // It is legal to have multiple directory separators, so get
            // rid of them here.  Example: "dir\\\\\\\\file".
            do {
                source++;
            } while (*source && IS_SEPARATOR(*source));

            // Make lastComponent point to the character after the directory
            // separator.
            lastComponent = destination;

        } // if (IS_SEPARATOR(*source))

    } // while (*source)

    // We're just about done.  If there was a trailing ..  (example:
    // "file\.."), trailing .  ("file\."), or multiple trailing
    // separators ("file\\\\"), then back up one since separators are
    // illegal at the end of a pathname.
    if ((destination != filename) && IS_SEPARATOR(*(destination - 1)))
        destination--;

    // Terminate the destination string.
    *destination = '\0';

    return (TRUE);

} // TftpdUtilCanonicalizeFileName()


BOOL
TftpdUtilPrependStringToFileName(char *filename, DWORD maxLength, char *prefix) {

    DWORD prefixLength = strlen(prefix);
    DWORD filenameLength = strlen(filename);
    BOOL  prefixHasSeparater = (prefix[prefixLength - 1] == '\\');
    BOOL  filenameHasSeparater = (filename[0] == '\\');
    DWORD separatorLength = 0;

    if (!prefixHasSeparater && !filenameHasSeparater)
        separatorLength = 1;

    if (prefixHasSeparater && filenameHasSeparater)
        prefixLength--;

    if ((prefixLength + separatorLength + filenameLength) > (maxLength - 1))
        return (FALSE);

    // Move the existing string down to make room for the prefix.
    MoveMemory(filename + prefixLength + separatorLength, filename, filenameLength + 1);
    // Move the prefix into place.
    CopyMemory(filename, prefix, prefixLength);
    // If necessary, insert a backslash between the prefix and the file name.
    if (separatorLength)
        filename[prefixLength] = '\\';
    // Terminate the string.
    filename[prefixLength + separatorLength + filenameLength] = '\0';

    return (TRUE);

} // TftpdUtilPrependStringToFileName()


BOOL
TftpdUtilGetFileModeAndOptions(PTFTPD_CONTEXT context, PTFTPD_BUFFER buffer) {

    DWORD remaining = (TFTPD_DEF_DATA - FIELD_OFFSET(TFTPD_BUFFER, message.data));
    char *filename, *mode, *option;
    int length;

    // Obtain and validate the requested filename.
    filename = buffer->message.rrq.data; // or wrq, same thing
    if (!TftpdUtilIsValidString(filename, remaining)) {
        TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_ILLEGAL_OPERATION,
                               "Malformed file name");
        return (FALSE);
    }
    length = (strlen(filename) + 1);
    remaining -= length;
    if (!TftpdUtilCanonicalizeFileName(filename)) {
        TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_ILLEGAL_OPERATION,
                               "Malformed file name");
        return (FALSE);
    }

    // Obtain and validate the mode.
    mode = (char *)(buffer->message.rrq.data + length);
    if (!TftpdUtilIsValidString(mode, remaining))
        return (FALSE);
    length = (strlen(mode) + 1);
    if (!_stricmp(mode, "netascii"))
        context->mode = TFTPD_MODE_TEXT;
    else if (!_stricmp(mode, "octet"))
        context->mode = TFTPD_MODE_BINARY;
    else {
        TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_ILLEGAL_OPERATION,
                               "Illegal TFTP operation");
        return (FALSE);
    }
    remaining -= length;

    // Obtain and validate any requested options.
    option = (char *)(mode + length);
    while (remaining && *option) {

        char *value;

        if (!TftpdUtilIsValidString(option, remaining))
            break;
        length = (strlen(option) + 1);
        remaining -= length;
        value = (char *)(option + length);
        if (!remaining || !TftpdUtilIsValidString(value, remaining))
            break;
        length = (strlen(value) + 1);
        remaining -= length;

        if (!_stricmp(option, "blksize")) {
            if (!(context->options & TFTPD_OPTION_BLKSIZE)) {
                int blksize = atoi(value);
                // Workaround for problem in .98 version of ROM, which
                // doesn't like our OACK response. If the requested blksize is
                // 1456, pretend that the option wasn't specified. In the case
                // of the ROM's TFTP layer, this is the only option specified,
                // so ignoring it will mean that we don't send an OACK, and the
                // ROM will deign to talk to us. Note that our TFTP code uses
                // a blksize of 1432, so this workaround won't affect us.
                if (blksize != 1456) {
                    blksize = __max(TFTPD_MIN_DATA, blksize);
                    blksize = __min(TFTPD_MAX_DATA, blksize);
                    context->blksize = blksize;
                    context->options |= TFTPD_OPTION_BLKSIZE;
                }
            }
        } else if (!_stricmp(option, "timeout")) {
            if (!(context->options & TFTPD_OPTION_TIMEOUT)) {
                int seconds = atoi(value);
                if ((seconds >= 1) && (seconds <= 255)) {
                    context->timeout = (seconds * 1000);
                    context->options |= TFTPD_OPTION_TIMEOUT;
                }
            }
        } else if (!_stricmp(option, "tsize")) {
            if (context->mode != TFTPD_MODE_TEXT) {
                context->options |= TFTPD_OPTION_TSIZE;
                context->filesize.QuadPart = _atoi64(value);
            }
        }

        // Advance over the option and its value to next option or NUL terminator.
        option += (strlen(option) + 1 + length);

    } // while (*option)

    if (!(context->options & TFTPD_OPTION_BLKSIZE))
        context->blksize = TFTPD_DEF_DATA;

    // Now that we've obtained all the information we need from the buffer, we're
    // free to overwrite it (reuse it) to prepend the filename with its prefix.
    if (!TftpdUtilPrependStringToFileName(filename, 
                                          TFTPD_DEF_BUFFER - FIELD_OFFSET(TFTPD_BUFFER, message.rrq.data),
                                          globals.parameters.rootDirectory)) {
        TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_ILLEGAL_OPERATION,
                               "Malformed file name");
        return (FALSE);
    }

    length = (strlen(filename) + 1);
    context->filename = (char *)HeapAlloc(globals.hServiceHeap, HEAP_ZERO_MEMORY, length);
    if (context->filename == NULL) {
        TftpdIoSendErrorPacket(buffer, TFTPD_ERROR_UNDEFINED, "Out of memory");
        return (FALSE);
    }
    strcpy(context->filename, filename);

    return (TRUE);

} // TftpdUtilGetFileModeAndOptions()

    
PTFTPD_BUFFER
TftpdUtilSendOackPacket(PTFTPD_BUFFER buffer) {

    PTFTPD_CONTEXT context = buffer->internal.context;
    char *oack;
    int length;

    // Build the OACK message.
    ZeroMemory(&buffer->message, buffer->internal.datasize);
    buffer->message.opcode = htons(TFTPD_OACK);
    oack = (char *)&buffer->message.oack.data;
    buffer->internal.io.bytes = (FIELD_OFFSET(TFTPD_BUFFER, message.oack.data) -
                                 FIELD_OFFSET(TFTPD_BUFFER, message.opcode));
    if (context->options & TFTPD_OPTION_BLKSIZE) {
        strcpy(oack, "blksize");
        oack += 8;
        _itoa(context->blksize, oack, 10);
        length = (strlen(oack) + 1);
        oack += length;
        buffer->internal.io.bytes += (8 + length);
    }
    if (context->options & TFTPD_OPTION_TIMEOUT) {
        strcpy(oack, "timeout");
        oack += 8;
        _itoa((context->timeout / 1000), oack, 10);
        length = (strlen(oack) + 1);
        oack += length;
        buffer->internal.io.bytes += (8 + length);
    }
    if (context->options & TFTPD_OPTION_TSIZE) {
        strcpy(oack, "tsize");
        oack += 6;
        _itoa((int)context->filesize.QuadPart, oack, 10);
        length = (strlen(oack) + 1);
        oack += length;
        buffer->internal.io.bytes += (6 + length);
    }

    TFTPD_DEBUG((TFTPD_TRACE_IO,
                 "TftpdUtilSendOackPacket(buffer = %p, context = %p): Issuing OACK, %d bytes. "
                 "[blksize = %d, timeout = %d, tsize = %d]\n",
                 buffer, context, buffer->internal.io.bytes,
                 context->blksize, context->timeout, context->filesize));

    if (!TftpdProcessComplete(buffer))
        return (buffer);

    return (TftpdIoSendPacket(buffer));

} // TftpdUtilSendOackPacket()


BOOL
TftpdUtilMatch(const char *const p, const char *const q) {

    switch (*p) {

        case '\0' :
            return (!(*q));

        case '*'  :
            return (TftpdUtilMatch(p + 1, q) || (*q && TftpdUtilMatch(p, q + 1)));

        case '?'  :
            return (*q && TftpdUtilMatch(p + 1, q + 1));

        default   :
            return ((*p == *q) && TftpdUtilMatch(p + 1, q + 1));

    } // switch (*p)

} // TftpdUtilMatch()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\snmp\compare.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:


Abstract:
         File contains the following functions
	      PortCmp
	      Cmp
	      InetCmp
	      UdpCmp
	      Udp6Cmp
	      TcpCmp
	      Tcp6Cmp
	      IpNetCmp
	
	All these functions behave like strcmp. They return >0 if first argument is greater
	than the second, <0 if the second is greater than the first and 0 if they are equal
	
	These functions should be revised to make them more effecient

Revision History:

    Amritansh Raghav          6/8/95  Created
    Amritansh Raghav          10/18/95 The functions now return >0,0,<0 instead of +1,0,-1

--*/

#include "allinc.h"

LONG 
UdpCmp(
       DWORD dwAddr1, 
       DWORD dwPort1, 
       DWORD dwAddr2, 
       DWORD dwPort2
       )
{
    LONG lResult;
    
    // Addrs are in network byte order
    if (InetCmp(dwAddr1, dwAddr2, lResult))
    {
        return lResult;
    }
    else
    {
        // Ports are in host byte order
        return Cmp(dwPort1, dwPort2, lResult);
    }
}

LONG
Udp6Cmp(
       BYTE  rgbyLocalAddrEx1[20],
       DWORD dwLocalPort1,
       BYTE  rgbyLocalAddrEx2[20],
       DWORD dwLocalPort2
       )
{
    LONG lResult;
    
    // Addr+scopeid is in network byte order.  They're together
    // in one buffer since that's how the INET-ADDRESS-MIB expresses them.
    lResult = memcmp(rgbyLocalAddrEx1, rgbyLocalAddrEx2, 20);
    if (lResult isnot 0)
    {
        return lResult;
    }
    else
    {
        // Ports are in host byte order
        return Cmp(dwLocalPort1, dwLocalPort2, lResult);
    }
}

LONG 
TcpCmp(
       DWORD dwLocalAddr1, 
       DWORD dwLocalPort1, 
       DWORD dwRemAddr1, 
       DWORD dwRemPort1,
       DWORD dwLocalAddr2, 
       DWORD dwLocalPort2, 
       DWORD dwRemAddr2, 
       DWORD dwRemPort2
       )
{
    LONG lResult;
    
    // Addrs are in network byte order
    if (InetCmp(dwLocalAddr1, dwLocalAddr2, lResult) isnot 0)
    {
        return lResult;
    }
    else
    {
        // Ports are in host byte order
        if (Cmp(dwLocalPort1, dwLocalPort2, lResult) isnot 0)
        {
            return lResult;
        }
        else
        {
            // Addrs are in network byte order
            if (InetCmp(dwRemAddr1, dwRemAddr2, lResult) isnot 0)
            {
                return lResult;
            }
            else
            {
                // Ports are in host byte order
                return Cmp(dwRemPort1, dwRemPort2, lResult);
            }
        }
    }
}

LONG 
Tcp6Cmp(
       BYTE rgbyLocalAddrEx1[20], 
       DWORD dwLocalPort1, 
       BYTE rgbyRemAddrEx1[20], 
       DWORD dwRemPort1,
       BYTE rgbyLocalAddrEx2[20], 
       DWORD dwLocalPort2, 
       BYTE rgbyRemAddrEx2[20], 
       DWORD dwRemPort2
       )
{
    LONG lResult;
    
    // Addr+scopeid is in network byte order.  They're together
    // in one buffer since that's how the INET-ADDRESS-MIB expresses them.
    lResult = memcmp(rgbyLocalAddrEx1, rgbyLocalAddrEx2, 20);
    if (lResult isnot 0)
    {
        return lResult;
    }
    else
    {
        // Ports are in host byte order
        if (Cmp(dwLocalPort1, dwLocalPort2, lResult) isnot 0)
        {
            return lResult;
        }
        else
        {
            // Addr+scopeid is in network byte order
            lResult = memcmp(rgbyRemAddrEx1, rgbyRemAddrEx2, 20);
            if (lResult isnot 0)
            {
                return lResult;
            }
            else
            {
                // Ports are in host byte order
                return Cmp(dwRemPort1, dwRemPort2, lResult);
            }
        }
    }
}

LONG 
IpNetCmp(
         DWORD dwIfIndex1, 
         DWORD dwAddr1, 
         DWORD dwIfIndex2, 
         DWORD dwAddr2
         )
{
    LONG lResult;
    
    // Index is a simple DWORD, not a port
    if (Cmp(dwIfIndex1, dwIfIndex2, lResult) isnot 0)
    {
        return lResult;
    }
    else
    {
        // Addrs are in network byte order
        return InetCmp(dwAddr1, dwAddr2, lResult);
    }
}

LONG
IpForwardCmp(
             DWORD dwIpDest1, 
             DWORD dwProto1, 
             DWORD dwPolicy1, 
             DWORD dwIpNextHop1,
             DWORD dwIpDest2, 
             DWORD dwProto2, 
             DWORD dwPolicy2, 
             DWORD dwIpNextHop2
             )
{
    LONG lResult;
    
    // Addrs are in network byte order
    if (InetCmp(dwIpDest1, dwIpDest2, lResult) isnot 0)
    {
        return lResult;
    }
    else
    {
        // Proto is a simple DWORD, not a port
        if (Cmp(dwProto1, dwProto2, lResult) isnot 0)
        {
            return lResult;
        }
        else
        {
            // Policy is a simple DWORD, not a port
            if (Cmp(dwPolicy1, dwPolicy2, lResult) isnot 0)
            {
                return lResult;
            }
            else
            {
                // Addrs are in network byte order
                return InetCmp(dwIpNextHop1, dwIpNextHop2, lResult);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\snmp\cache.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:


Abstract:
         File contains the following functions
	      UpdateCache

Revision History:

    Amritansh Raghav          6/8/95  Created

--*/


//
// Include files
//

#include "allinc.h"
PSZ
CacheToA(
         DWORD dwCache
         );
DWORD
UpdateCache(
            DWORD dwCache
            )
/*++
Routine Description:
    Function used to update a cache. It checks to see if the last time
    the cache was updated is greater than the time out (A value of 0
    for the last time of update means the cache is invalid), calls the
    function that loads the cache and then sets the last update time

Arguments:
    dwCache     This is one of the Cache Ids defined in
                rtrmgr/defs.h. It is used to index into the
                table of locks protecting the caches, the table
                of function pointers that holds a pointer to a
                function that loads the cache andthe table of
                last update times
Returns:
    NO_ERROR or some error code

--*/
{
    DWORD  dwResult = NO_ERROR;
    LONG   dwNeed;
    LONG   dwSpace;

    TRACE1("Trying to update %s Cache",CacheToA(dwCache));

    __try
    {
        EnterWriter(dwCache);

        if((g_dwLastUpdateTable[dwCache] isnot 0) and
           ((GetCurrentTime() - g_dwLastUpdateTable[dwCache]) < g_dwTimeoutTable[dwCache]))
        {
            dwResult = NO_ERROR;
            __leave;
        }

        TRACE1("%s Cache out of date",CacheToA(dwCache));

        dwResult = (*g_pfnLoadFunctionTable[dwCache])();

        if(dwResult isnot NO_ERROR)
        {
            TRACE1("Unable to load %s Cache\n",CacheToA(dwCache));
            g_dwLastUpdateTable[dwCache] = 0;
            __leave;
        }

        TRACE1("%s Cache loaded successfully\n",CacheToA(dwCache));
        g_dwLastUpdateTable[dwCache] = GetCurrentTime();

        dwResult = NO_ERROR;
    }
    __finally
    {
        ReleaseLock(dwCache);
    }
    return(dwResult);
}


PSZ
CacheToA(
         DWORD dwCache
         )
{
    static PSZ cacheName[] = {
                             "System ",
                             "Interfaces",
                             "Ip Address Table",
                             "Ip Forward Table",
			     "Ip Net To Media table",
			     "Tcp Table",
			     "Udp Table",
			     "Arp Entity Table",
			     "Illegal Cache Number - ABORT!!!!"
			   };
    return((((int) dwCache<0) or (dwCache >= NUM_CACHE - 1))?
           cacheName[NUM_CACHE-1] : cacheName[dwCache]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\snmp\indices.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:


Abstract:


Author:


Revision History:

--*/

#ifndef __INDICES_H__
#define __INDICES_H__

//
// A bunch of defines to set up the indices for the mib variables
//

#define mi_sysDescr                     0
#define mi_sysObjectID                  mi_sysDescr                     + 1
#define mi_sysUpTime                    mi_sysObjectID                  + 1
#define mi_sysContact                   mi_sysUpTime                    + 1
#define mi_sysName                      mi_sysContact                   + 1
#define mi_sysLocation                  mi_sysName                      + 1
#define mi_sysServices                  mi_sysLocation                  + 1

#define mi_ifNumber                     0
#define mi_ifTable                      mi_ifNumber                     + 1
#define mi_ifEntry                      mi_ifTable                      + 1
#define mi_ifIndex                      mi_ifEntry                      + 1
#define mi_ifDescr                      mi_ifIndex                      + 1
#define mi_ifType                       mi_ifDescr                      + 1
#define mi_ifMtu                        mi_ifType                       + 1
#define mi_ifSpeed                      mi_ifMtu                        + 1
#define mi_ifPhysAddress                mi_ifSpeed                      + 1
#define mi_ifAdminStatus                mi_ifPhysAddress                + 1
#define mi_ifOperStatus                 mi_ifAdminStatus                + 1
#define mi_ifLastChange                 mi_ifOperStatus                 + 1
#define mi_ifInOctets                   mi_ifLastChange                 + 1
#define mi_ifInUcastPkts                mi_ifInOctets                   + 1
#define mi_ifInNUcastPkts               mi_ifInUcastPkts                + 1
#define mi_ifInDiscards                 mi_ifInNUcastPkts               + 1
#define mi_ifInErrors                   mi_ifInDiscards                 + 1
#define mi_ifInUnknownProtos            mi_ifInErrors                   + 1
#define mi_ifOutOctets                  mi_ifInUnknownProtos            + 1
#define mi_ifOutUcastPkts               mi_ifOutOctets                  + 1
#define mi_ifOutNUcastPkts              mi_ifOutUcastPkts               + 1
#define mi_ifOutDiscards                mi_ifOutNUcastPkts              + 1
#define mi_ifOutErrors                  mi_ifOutDiscards                + 1
#define mi_ifOutQLen                    mi_ifOutErrors                  + 1
#define mi_ifSpecific                   mi_ifOutQLen                    + 1

#define mi_ipForwarding                 0
#define mi_ipDefaultTTL                 mi_ipForwarding                 + 1
#define mi_ipInReceives                 mi_ipDefaultTTL                 + 1
#define mi_ipInHdrErrors                mi_ipInReceives                 + 1
#define mi_ipInAddrErrors               mi_ipInHdrErrors                + 1
#define mi_ipForwDatagrams              mi_ipInAddrErrors               + 1
#define mi_ipInUnknownProtos            mi_ipForwDatagrams              + 1
#define mi_ipInDiscards                 mi_ipInUnknownProtos            + 1
#define mi_ipInDelivers                 mi_ipInDiscards                 + 1
#define mi_ipOutRequests                mi_ipInDelivers                 + 1
#define mi_ipOutDiscards                mi_ipOutRequests                + 1
#define mi_ipOutNoRoutes                mi_ipOutDiscards                + 1
#define mi_ipReasmTimeout               mi_ipOutNoRoutes                + 1
#define mi_ipReasmReqds                 mi_ipReasmTimeout               + 1
#define mi_ipReasmOKs                   mi_ipReasmReqds                 + 1
#define mi_ipReasmFails                 mi_ipReasmOKs                   + 1
#define mi_ipFragOKs                    mi_ipReasmFails                 + 1
#define mi_ipFragFails                  mi_ipFragOKs                    + 1
#define mi_ipFragCreates                mi_ipFragFails                  + 1
#define mi_ipAddrTable                  mi_ipFragCreates                + 1
#define mi_ipAddrEntry                  mi_ipAddrTable                  + 1
#define mi_ipAdEntAddr                  mi_ipAddrEntry                  + 1
#define mi_ipAdEntIfIndex               mi_ipAdEntAddr                  + 1
#define mi_ipAdEntNetMask               mi_ipAdEntIfIndex               + 1
#define mi_ipAdEntBcastAddr             mi_ipAdEntNetMask               + 1
#define mi_ipAdEntReasmMaxSize          mi_ipAdEntBcastAddr             + 1
#define mi_ipRouteTable                 mi_ipAdEntReasmMaxSize          + 1
#define mi_ipRouteEntry                 mi_ipRouteTable                 + 1
#define mi_ipRouteDest                  mi_ipRouteEntry                 + 1
#define mi_ipRouteIfIndex               mi_ipRouteDest                  + 1
#define mi_ipRouteMetric1               mi_ipRouteIfIndex               + 1
#define mi_ipRouteMetric2               mi_ipRouteMetric1               + 1
#define mi_ipRouteMetric3               mi_ipRouteMetric2               + 1
#define mi_ipRouteMetric4               mi_ipRouteMetric3               + 1
#define mi_ipRouteNextHop               mi_ipRouteMetric4               + 1
#define mi_ipRouteType                  mi_ipRouteNextHop               + 1
#define mi_ipRouteProto                 mi_ipRouteType                  + 1
#define mi_ipRouteAge                   mi_ipRouteProto                 + 1
#define mi_ipRouteMask                  mi_ipRouteAge                   + 1
#define mi_ipRouteMetric5               mi_ipRouteMask                  + 1
#define mi_ipRouteInfo                  mi_ipRouteMetric5               + 1
#define mi_ipNetToMediaTable            mi_ipRouteInfo                  + 1
#define mi_ipNetToMediaEntry            mi_ipNetToMediaTable            + 1
#define mi_ipNetToMediaIfIndex          mi_ipNetToMediaEntry            + 1
#define mi_ipNetToMediaPhysAddress      mi_ipNetToMediaIfIndex          + 1
#define mi_ipNetToMediaNetAddress       mi_ipNetToMediaPhysAddress      + 1
#define mi_ipNetToMediaType             mi_ipNetToMediaNetAddress       + 1
#define mi_ipRoutingDiscards            mi_ipNetToMediaType             + 1
#define mi_ipForwardGroup               mi_ipRoutingDiscards            + 1
#define mi_ipForwardNumber              mi_ipForwardGroup               + 1
#define mi_ipForwardTable               mi_ipForwardNumber              + 1
#define mi_ipForwardEntry               mi_ipForwardTable               + 1
#define mi_ipForwardDest                mi_ipForwardEntry               + 1
#define mi_ipForwardMask                mi_ipForwardDest                + 1
#define mi_ipForwardPolicy              mi_ipForwardMask                + 1
#define mi_ipForwardNextHop             mi_ipForwardPolicy              + 1
#define mi_ipForwardIfIndex             mi_ipForwardNextHop             + 1
#define mi_ipForwardType                mi_ipForwardIfIndex             + 1
#define mi_ipForwardProto               mi_ipForwardType                + 1
#define mi_ipForwardAge                 mi_ipForwardProto               + 1
#define mi_ipForwardInfo                mi_ipForwardAge                 + 1
#define mi_ipForwardNextHopAS           mi_ipForwardInfo                + 1
#define mi_ipForwardMetric1             mi_ipForwardNextHopAS           + 1
#define mi_ipForwardMetric2             mi_ipForwardMetric1             + 1
#define mi_ipForwardMetric3             mi_ipForwardMetric2             + 1
#define mi_ipForwardMetric4             mi_ipForwardMetric3             + 1
#define mi_ipForwardMetric5             mi_ipForwardMetric4             + 1

//
// These values should match the order of entries in mib_icmpGroup[]
//
typedef enum {
    mi_icmpInMsgs = 0,
    mi_icmpInErrors,
    mi_icmpInDestUnreachs,
    mi_icmpInTimeExcds,
    mi_icmpInParmProbs,
    mi_icmpInSrcQuenchs,
    mi_icmpInRedirects,
    mi_icmpInEchos,
    mi_icmpInEchoReps,
    mi_icmpInTimestamps,
    mi_icmpInTimestampReps,
    mi_icmpInAddrMasks,
    mi_icmpInAddrMaskReps,
    mi_icmpOutMsgs,
    mi_icmpOutErrors,
    mi_icmpOutDestUnreachs,
    mi_icmpOutTimeExcds,
    mi_icmpOutParmProbs,
    mi_icmpOutSrcQuenchs,
    mi_icmpOutRedirects,
    mi_icmpOutEchos,
    mi_icmpOutEchoReps,
    mi_icmpOutTimestamps,
    mi_icmpOutTimestampReps,
    mi_icmpOutAddrMasks,
    mi_icmpOutAddrMaskReps,
    mi_inetIcmpTable,
        mi_inetIcmpEntry,
            mi_inetIcmpAFType,
            mi_inetIcmpIfIndex,
            mi_inetIcmpInMsgs,
            mi_inetIcmpInErrors,
            mi_inetIcmpOutMsgs,
            mi_inetIcmpOutErrors,
    mi_inetIcmpMsgTable,
        mi_inetIcmpMsgEntry,
            mi_inetIcmpMsgAFType,
            mi_inetIcmpMsgIfIndex,
            mi_inetIcmpMsgType,
            mi_inetIcmpMsgCode,
            mi_inetIcmpMsgInPkts,
            mi_inetIcmpMsgOutPkts,
} MI_ICMPGROUP;

//
// These values should match the order of entries in mib_tcpGroup[]
//
#define mi_tcpRtoAlgorithm              0
#define mi_tcpRtoMin                    mi_tcpRtoAlgorithm              + 1
#define mi_tcpRtoMax                    mi_tcpRtoMin                    + 1
#define mi_tcpMaxConn                   mi_tcpRtoMax                    + 1
#define mi_tcpActiveOpens               mi_tcpMaxConn                   + 1
#define mi_tcpPassiveOpens              mi_tcpActiveOpens               + 1
#define mi_tcpAttemptFails              mi_tcpPassiveOpens              + 1
#define mi_tcpEstabResets               mi_tcpAttemptFails              + 1
#define mi_tcpCurrEstab                 mi_tcpEstabResets               + 1
#define mi_tcpInSegs                    mi_tcpCurrEstab                 + 1
#define mi_tcpOutSegs                   mi_tcpInSegs                    + 1
#define mi_tcpRetransSegs               mi_tcpOutSegs                   + 1
#define mi_tcpConnTable                 mi_tcpRetransSegs               + 1
#define mi_tcpConnEntry                 mi_tcpConnTable                 + 1
#define mi_tcpConnState                 mi_tcpConnEntry                 + 1
#define mi_tcpConnLocalAddress          mi_tcpConnState                 + 1
#define mi_tcpConnLocalPort             mi_tcpConnLocalAddress          + 1
#define mi_tcpConnRemAddress            mi_tcpConnLocalPort             + 1
#define mi_tcpConnRemPort               mi_tcpConnRemAddress            + 1
#define mi_tcpInErrs                    mi_tcpConnRemPort               + 1
#define mi_tcpOutRsts                   mi_tcpInErrs                    + 1
#define mi_tcpNewConnTable              mi_tcpOutRsts                   + 1
#define mi_tcpNewConnEntry              mi_tcpNewConnTable              + 1
#define mi_tcpNewConnLocalAddressType   mi_tcpNewConnEntry              + 1
#define mi_tcpNewConnLocalAddress       mi_tcpNewConnLocalAddressType   + 1
#define mi_tcpNewConnLocalPort          mi_tcpNewConnLocalAddress       + 1
#define mi_tcpNewConnRemAddressType     mi_tcpNewConnLocalPort          + 1
#define mi_tcpNewConnRemAddress         mi_tcpNewConnRemAddressType     + 1
#define mi_tcpNewConnRemPort            mi_tcpNewConnRemAddress         + 1
#define mi_tcpNewConnState              mi_tcpNewConnRemPort            + 1

//
// These values should match the order of entries in mib_udpGroup[]
//
#define mi_udpInDatagrams               0
#define mi_udpNoPorts                   mi_udpInDatagrams               + 1
#define mi_udpInErrors                  mi_udpNoPorts                   + 1
#define mi_udpOutDatagrams              mi_udpInErrors                  + 1
#define mi_udpTable                     mi_udpOutDatagrams              + 1
#define mi_udpEntry                     mi_udpTable                     + 1
#define mi_udpLocalAddress              mi_udpEntry                     + 1
#define mi_udpLocalPort                 mi_udpLocalAddress              + 1
#define mi_udpListenerTable             mi_udpLocalPort                 + 1
#define mi_udpListenerEntry             mi_udpListenerTable             + 1
#define mi_udpListenerLocalAddressType  mi_udpListenerEntry             + 1
#define mi_udpListenerLocalAddress      mi_udpListenerLocalAddressType  + 1
#define mi_udpListenerLocalPort         mi_udpListenerLocalAddress      + 1

//
// These values should match the order of entries in mib_ipv6Group[]
//
typedef enum {
    mi_ipv6Forwarding = 0,
    mi_ipv6DefaultHopLimit,
    mi_ipv6Interfaces,
    mi_ipv6IfTableLastChange,
    mi_ipv6IfTable,
        mi_ipv6IfEntry,
            mi_ipv6IfIndex,
            mi_ipv6IfDescr,
            mi_ipv6IfLowerLayer,
            mi_ipv6IfEffectiveMtu,
            mi_ipv6IfReasmMaxSize,
            mi_ipv6IfIdentifier,
            mi_ipv6IfIdentifierLength,
            mi_ipv6IfPhysicalAddress,
            mi_ipv6IfAdminStatus,
            mi_ipv6IfOperStatus,
            mi_ipv6IfLastChange,
    mi_ipv6IfStatsTable,
        mi_ipv6IfStatsEntry,
            mi_ipv6IfStatsIfIndex,
            mi_ipv6IfStatsInReceives,
            mi_ipv6IfStatsInHdrErrors,
            mi_ipv6IfStatsInTooBigErrors,
            mi_ipv6IfStatsInNoRoutes,
            mi_ipv6IfStatsInAddrErrors,
            mi_ipv6IfStatsInUnknownProtos,
            mi_ipv6IfStatsInTruncatedPkts,
            mi_ipv6IfStatsInDiscards,
            mi_ipv6IfStatsInDelivers,
            mi_ipv6IfStatsOutForwDatagrams,
            mi_ipv6IfStatsOutRequests,
            mi_ipv6IfStatsOutDiscards,
            mi_ipv6IfStatsOutFragOKs,
            mi_ipv6IfStatsOutFragFails,
            mi_ipv6IfStatsOutFragCreates,
            mi_ipv6IfStatsReasmReqds,
            mi_ipv6IfStatsReasmOKs,
            mi_ipv6IfStatsReasmFails,
            mi_ipv6IfStatsInMcastPkts,
            mi_ipv6IfStatsOutMcastPkts,
    mi_ipv6AddrPrefixTable,
        mi_ipv6AddrPrefixEntry,
            mi_ipv6AddrPrefixIfIndex,
            mi_ipv6AddrPrefix,
            mi_ipv6AddrPrefixLength,
            mi_ipv6AddrPrefixOnLinkFlag,
            mi_ipv6AddrPrefixAutonomousFlag,
            mi_ipv6AddrPrefixAdvPreferredLifetime,
            mi_ipv6AddrPrefixAdvValidLifetime,
    mi_ipv6AddrTable,
        mi_ipv6AddrEntry,
            mi_ipv6AddrIfIndex,
            mi_ipv6AddrAddress,
            mi_ipv6AddrPfxLength,
            mi_ipv6AddrType,
            mi_ipv6AddrAnycastFlag,
            mi_ipv6AddrStatus,
    mi_ipv6RouteNumber,
    mi_ipv6DiscardedRoutes,
    mi_ipv6RouteTable,
        mi_ipv6RouteEntry,
            mi_ipv6RouteDest,
            mi_ipv6RoutePfxLength,
            mi_ipv6RouteIndex,
            mi_ipv6RouteIfIndex,
            mi_ipv6RouteNextHop,
            mi_ipv6RouteType,
            mi_ipv6RouteProtocol,
            mi_ipv6RoutePolicy,
            mi_ipv6RouteAge,
            mi_ipv6RouteNextHopRDI,
            mi_ipv6RouteMetric,
            mi_ipv6RouteWeight,
            mi_ipv6RouteInfo,
            mi_ipv6RouteValid,
    mi_ipv6NetToMediaTable,
        mi_ipv6NetToMediaEntry,
            mi_ipv6NetToMediaIfIndex,
            mi_ipv6NetToMediaNetAddress,
            mi_ipv6NetToMediaPhysAddress,
            mi_ipv6NetToMediaType,
            mi_ipv6NetToMediaState,
            mi_ipv6NetToMediaLastUpdated,
            mi_ipv6NetToMediaValid,
} MI_IPV6GROUP;

//
// Now we have to set up defines to tell the Master agent the number of
// rows in each table and the number of rows that are indices for the table.
// The Agent expects the indices to be contiguous and in the beginning.
// In cases where an index includes objects that are not in the table
// themselves, the counts include such objects.  That is, they count
// the number of fields in the structures in mibfuncs.h, which need
// not match the number of entries in the mib_* structures in oid.h
// in this case.
//

//
// IF Table
//

#define ne_ifEntry                  22
#define ni_ifEntry                  1

//
// IP Address table
//

#define ne_ipAddrEntry              5
#define ni_ipAddrEntry              1

//
// IP Route Table
//

#define ne_ipRouteEntry             13
#define ni_ipRouteEntry             1

//
// IP Net To Media Table
//

#define ne_ipNetToMediaEntry        4
#define ni_ipNetToMediaEntry        2

//
// IP Forwarding table
//

#define ne_ipForwardEntry           15
#define ni_ipForwardEntry           4

//
// ICMP table
//

#define ne_inetIcmpEntry            6
#define ni_inetIcmpEntry            2

//
// ICMP Message Table
//

#define ne_inetIcmpMsgEntry         6
#define ni_inetIcmpMsgEntry         4

//
// TCP (IPv4 only) Connection Table
//

#define ne_tcpConnEntry             5
#define ni_tcpConnEntry             4

//
// New TCP (both IPv4 and IPv6) Connection Table
//

#define ne_tcpNewConnEntry          7
#define ni_tcpNewConnEntry          6

//
// Old UDP (IPv4-only) Listener Table
//

#define ne_udpEntry                 2
#define ni_udpEntry                 2

//
// UDP Listener (both IPv4 and IPv6) Table
//

#define ne_udpListenerEntry         3
#define ni_udpListenerEntry         3

//
// IPv6 Interface Table
//

#define ne_ipv6IfEntry             11
#define ni_ipv6IfEntry              1

//
// IPv6 Stats Table
//

#define ne_ipv6IfStatsEntry        21
#define ni_ipv6IfStatsEntry         1 /* inc. IfIndex */

//
// IPv6 Address Prefix Table
//

#define ne_ipv6AddrPrefixEntry      7
#define ni_ipv6AddrPrefixEntry      3 /* inc. IfIndex */

//
// IPv6 Address Table
//

#define ne_ipv6AddrEntry            6
#define ni_ipv6AddrEntry            2 /* inc. IfIndex */

//
// IPv6 Route Table
//

#define ne_ipv6RouteEntry          14
#define ni_ipv6RouteEntry           3

//
// IPv6 Net To Media Table
//

#define ne_ipv6NetToMediaEntry      7
#define ni_ipv6NetToMediaEntry      2 /* inc. IfIndex */

//
// Declaration of the mib view
//

#define NUM_VIEWS   7 // sysGroup
                      // ifGroup
                      // ipGroup
                      // icmpGroup
                      // tcpGroup
                      // udpGroup
                      // ipv6Group

extern SnmpMibView v_mib2[NUM_VIEWS];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\snmp\init.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:


Abstract:


Author:


Revision History:

--*/

#include "allinc.h"


//
// Definitions for external declarations
//

DWORD   g_uptimeReference;

#ifdef MIB_DEBUG
DWORD   g_hTrace=INVALID_TRACEID;
#endif

HANDLE  g_hPollTimer;

RTL_RESOURCE g_LockTable[NUM_LOCKS];

#ifdef DEADLOCK_DEBUG

PBYTE   g_pszLockNames[NUM_LOCKS]   = {"System Group Lock",
                                       "IF Lock",
                                       "IP Address Lock",
                                       "Forwarding Lock",
                                       "ARP Lock",
                                       "TCP Lock",
                                       "UDP Lock",
                                       "New TCP Lock",
                                       "UDP6 Listener Lock",
                                       "IPv6 IF Lock",
                                       "IPv6 Neighbor Lock",
                                       "IPv6 Route Lock",
                                       "ICMP Lock",
                                       "Trap Table Lock"};

#endif // DEADLOCK_DEBUG

DWORD   g_dwLastUpdateTable[NUM_CACHE] = { 0,
                                           0,
                                           0,
                                           0,
                                           0,
                                           0,
                                           0,
                                           0,
                                           0};

DWORD   g_dwTimeoutTable[NUM_CACHE]  = {SYSTEM_CACHE_TIMEOUT,
                                        IF_CACHE_TIMEOUT,
                                        IP_ADDR_CACHE_TIMEOUT,
                                        IP_FORWARD_CACHE_TIMEOUT,
                                        IP_NET_CACHE_TIMEOUT,
                                        TCP_CACHE_TIMEOUT,
                                        UDP_CACHE_TIMEOUT,
                                        TCP_CACHE_TIMEOUT,
                                        UDP_CACHE_TIMEOUT,
                                        IPV6_IF_CACHE_TIMEOUT,
                                        IPV6_NEIGHBOR_CACHE_TIMEOUT,
                                        IPV6_ROUTE_TABLE_TIMEOUT,
                                        ICMP_CACHE_TIMEOUT};

PFNLOAD_FUNCTION g_pfnLoadFunctionTable[] = { LoadSystem,
                                              LoadIfTable,
                                              LoadIpAddrTable,
                                              LoadIpForwardTable,
                                              LoadIpNetTable,
                                              LoadTcpTable,
                                              LoadUdpTable,
                                              LoadTcp6Table,
                                              LoadUdp6ListenerTable,
                                              LoadIpv6IfTable,
                                              LoadIpv6NetToMediaTable,
                                              LoadIpv6RouteTable,
                                              LoadInetIcmpTable};

//
// Implicitly zero all cache fields.  We only explicitly zero one.
//
MIB_CACHE g_Cache = {0};

HANDLE    g_hPrivateHeap;

SnmpTfxHandle g_tfxHandle;

UINT g_viewIndex = 0;

PMIB_IFSTATUS  g_pisStatusTable;
DWORD       g_dwValidStatusEntries;
DWORD       g_dwTotalStatusEntries;

BOOL        g_bFirstTime;

BOOL
Mib2DLLEntry(
    HANDLE  hInst,
    DWORD   ul_reason_being_called,
    LPVOID  lpReserved
    )
{
    DWORD   i;

    switch (ul_reason_being_called)
    {
        case DLL_PROCESS_ATTACH:
        {
            DisableThreadLibraryCalls(hInst);

            g_pisStatusTable        = NULL;
            g_dwValidStatusEntries  = 0;
            g_dwTotalStatusEntries  = 0;

            g_hPollTimer    = NULL;

            g_bFirstTime    = TRUE;
       

            //
            // Create the private heap. If it fails, deregister the trace
            // handle
            //
            
            g_hPrivateHeap = HeapCreate(0,
                                        4*1024,
                                        0);

            if(g_hPrivateHeap is NULL)
            {
                
                //
                // Deregister the trace handle
                //
                
#ifdef MIB_DEBUG

                if(g_hTrace isnot INVALID_TRACEID)
                {
                    TraceDeregister(g_hTrace);

                    g_hTrace = INVALID_TRACEID;
                }
                
#endif
                return FALSE;
            }
            
            for(i = 0; i < NUM_LOCKS; i++)
            {
                RtlInitializeResource(&g_LockTable[i]);
            }

            break ;
        }
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        {
            //
            // not of interest.
            //

            break;
        }
        case DLL_PROCESS_DETACH:    
        {

#ifdef MIB_DEBUG

            if(g_hTrace isnot INVALID_TRACEID)
            {
                TraceDeregister(g_hTrace);

                g_hTrace = INVALID_TRACEID;
            }

#endif 

            if(g_hPrivateHeap)
            {
                HeapDestroy(g_hPrivateHeap);
            }

            if(g_hPollTimer isnot NULL)
            {
                //
                // We had created an timer object
                //

                CloseHandle(g_hPollTimer);

                g_hPollTimer = NULL;
            }

            for(i = 0; i < NUM_LOCKS; i++)
            {
                RtlDeleteResource(&g_LockTable[i]);
            }
            
            break;
        }
    }

    return TRUE;
}

DWORD
GetPollTime(
    VOID
    )

/*++

Routine Description

    This function

Locks

    None

Arguments

    None

Return Value

    None    

--*/

{
    DWORD   dwResult, dwSize, dwValue, dwDisposition, dwType;
    HKEY    hkeyPara;
    WCHAR   wszPollValue[256];
    
    dwResult    = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                 REG_KEY_MIB2SUBAGENT_PARAMETERS,
                                 0,
                                 NULL,
                                 0,
                                 KEY_ALL_ACCESS,
                                 NULL,
                                 &hkeyPara,
                                 &dwDisposition);

    if(dwResult isnot NO_ERROR)
    {
        //
        // Couldnt open/create key just return default value
        //

        return DEFAULT_POLL_TIME;
    }

    //
    // Try and read the Poll time. If the value doesnt exist, write
    // the default in
    //

    dwSize = sizeof(DWORD);

    dwResult = RegQueryValueExW(hkeyPara,
                                REG_VALUE_POLL,
                                0,
                                &dwType,
                                (LPBYTE)(&dwValue),
                                &dwSize);

    if((dwResult isnot NO_ERROR) or
       (dwType isnot REG_DWORD) or
       (dwValue < MIN_POLL_TIME))
    {
        //
        // Registry seems to be corrupt, or key doesnt exist or
        // The value is less than the minimum. Lets set things
        // right
        //

        dwValue = DEFAULT_POLL_TIME;

        wcscpy(wszPollValue,
               REG_VALUE_POLL);

        dwResult = RegSetValueExW(hkeyPara,
                                  REG_VALUE_POLL,
                                  0,
                                  REG_DWORD,
                                  (CONST BYTE *)(&dwValue),
                                  sizeof(DWORD));

        if(dwResult isnot NO_ERROR)
        {
            TRACE1("Error %d setting poll time in registry",
                   dwResult);
        }
    }
                                 
    //
    // At this point dwValue is a good one read out of the registry
    // or is DEFAULT_POLL_TIME
    //

    return dwValue;
}


BOOL 
SnmpExtensionInit(
    IN    DWORD               uptimeReference,
    OUT   HANDLE              *lpPollForTrapEvent,
    OUT   AsnObjectIdentifier *lpFirstSupportedView
    )
{
    DWORD           dwResult, dwPollTime;
    LARGE_INTEGER   liRelTime;
    
    //    
    // save the uptime reference
    //

    g_uptimeReference = uptimeReference;

 
#ifdef MIB_DEBUG

    if (g_hTrace == INVALID_TRACEID)
        g_hTrace = TraceRegister("MIB-II Subagent");

#endif

    //
    // obtain handle to subagent framework
    //

    g_tfxHandle = SnmpTfxOpen(NUM_VIEWS,v_mib2);

    //
    // validate handle
    //

    if (g_tfxHandle is NULL) 
    {
        TRACE1("Error %d opening framework",
               GetLastError());

        //
        // destroy private heap 
        //

        HeapDestroy(g_hPrivateHeap);

        //
        // reinitialize
        //

        g_hPrivateHeap = NULL;

        return FALSE;
    }

    //
    // pass back first view identifier to master
    //

    g_viewIndex = 0; // make sure this is reset...
    *lpFirstSupportedView = v_mib2[g_viewIndex++].viewOid;

    //
    // Update the IF cache. This is needed for the first poll
    //

    UpdateCache(MIB_II_IF);

    //
    // Trap is done by a polling timer
    //

    if(g_hPollTimer is NULL)
    {
        //
        // Do this ONLY if we had  notcreated the timer from an earlier
        // initialization call
        //

        g_hPollTimer    = CreateWaitableTimer(NULL,
                                              FALSE,
                                              NULL); // No name because many DLLs may load this

        if(g_hPollTimer is NULL)
        {
            TRACE1("Error %d creating poll timer for traps",
                   GetLastError());
        }
        else
        {
            //
            // Read poll time from the registry. If the keys dont exist this
            // function will set up the keys and return the default value
            //

            dwPollTime  = GetPollTime();
        
            liRelTime   = RtlLargeIntegerNegate(MilliSecsToSysUnits(dwPollTime));
            
        
            if(!SetWaitableTimer(g_hPollTimer,
                                 &liRelTime,
                                 dwPollTime,
                                 NULL,
                                 NULL,
                                 FALSE))
            {
                TRACE1("Error %d setting timer",
                       GetLastError());

                CloseHandle(g_hPollTimer);

                g_hPollTimer = NULL;
            }
        }
    }
    
    *lpPollForTrapEvent = g_hPollTimer;

    return TRUE;    
}


BOOL 
SnmpExtensionInitEx(
    OUT AsnObjectIdentifier *lpNextSupportedView
    )
{

#ifdef MIB_DEBUG

    if (g_hTrace == INVALID_TRACEID)
        g_hTrace = TraceRegister("MIB-II Subagent");

#endif


    //
    // check if there are views to register
    //

    BOOL fMoreViews = (g_viewIndex < NUM_VIEWS);

    if (fMoreViews) 
    {
        //
        // pass back next supported view to master 
        //

        *lpNextSupportedView = v_mib2[g_viewIndex++].viewOid;
    } 

    //
    // report status
    //

    return fMoreViews;
}


BOOL 
SnmpExtensionQuery(
    IN     BYTE                  requestType,
    IN OUT RFC1157VarBindList    *variableBindings,
    OUT    AsnInteger            *errorStatus,
    OUT    AsnInteger            *errorIndex
    )
{
    //
    // forward to framework
    //

    return SnmpTfxQuery(g_tfxHandle,
                        requestType,
                        variableBindings,
                        errorStatus,
                        errorIndex);
}


BOOL 
SnmpExtensionTrap(
    OUT AsnObjectIdentifier   *enterprise,
    OUT AsnInteger            *genericTrap,
    OUT AsnInteger            *specificTrap,
    OUT AsnTimeticks          *timeStamp,
    OUT RFC1157VarBindList    *variableBindings
    )
{
    DWORD dwResult;

    enterprise->idLength    = 0;
    enterprise->ids         = NULL; // use default enterprise oid

    *timeStamp  = (GetCurrentTime()/10) - g_uptimeReference;

    return MibTrap(genericTrap,
                   specificTrap,
                   variableBindings);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\snmp\defs.h ===
#ifndef __DEFS_H__
#define __DEFS_H__

#define IP_ADDRESS_LEN  4

//
// Since the query types map to MIB_ACTION_XXX we can just pass the action Id onto 
// the Locator functions
//

#define GET_FIRST MIB_ACTION_GETFIRST
#define GET_EXACT MIB_ACTION_GET
#define GET_NEXT  MIB_ACTION_GETNEXT

#define SetAsnInteger(dstBuf,val){                          \
    if ((dstBuf)->asnType)                                  \
    {                                                       \
        ASSERT((dstBuf)->asnType==ASN_INTEGER);             \
        (dstBuf)->asnValue.number = (AsnInteger)(val);      \
    }                                                       \
}

#define ForceSetAsnInteger(dstBuf,val){                     \
    (dstBuf)->asnType = ASN_INTEGER;                        \
    (dstBuf)->asnValue.number = (AsnInteger)(val);          \
}

#define SetAsnUnsigned32(dstBuf,val){                       \
    if ((dstBuf)->asnType)                                  \
    {                                                       \
        ASSERT((dstBuf)->asnType==ASN_RFC2578_UNSIGNED32);  \
        (dstBuf)->asnValue.number = (AsnInteger)(val);      \
    }                                                       \
}

#define ForceSetAsnUnsigned32(dstBuf,val){                  \
    (dstBuf)->asnType = ASN_RFC2578_UNSIGNED32;             \
    (dstBuf)->asnValue.number = (AsnInteger)(val);          \
}

#define SetAsnCounter(dstBuf,val){                          \
    if ((dstBuf)->asnType)                                  \
    {                                                       \
        ASSERT((dstBuf)->asnType==ASN_RFC1155_COUNTER);     \
        (dstBuf)->asnValue.counter = (AsnCounter)(val);     \
    }                                                       \
}

#define SetAsnGauge(dstBuf,val){                            \
    if ((dstBuf)->asnType)                                  \
    {                                                       \
        ASSERT((dstBuf)->asnType==ASN_RFC1155_GAUGE);       \
        (dstBuf)->asnValue.gauge = (AsnGauge)(val);         \
    }                                                       \
}

#define SetAsnTimeTicks(dstBuf,val){                        \
    if ((dstBuf)->asnType)                                  \
    {                                                       \
        ASSERT((dstBuf)->asnType==ASN_RFC1155_TIMETICKS);   \
        (dstBuf)->asnValue.ticks = (AsnTimeticks)(val);     \
    }                                                       \
}

#define SetAsnOctetString(dstBuf,buffer,src,len){                        \
    if ((dstBuf)->asnType)                                               \
    {                                                                    \
        ASSERT((dstBuf)->asnType==ASN_OCTETSTRING);                      \
        if ((dstBuf)->asnValue.string.dynamic)                           \
        {                                                                \
            SnmpUtilMemFree((dstBuf)->asnValue.string.stream);           \
        }                                                                \
        (dstBuf)->asnValue.string.length = len;                          \
        (dstBuf)->asnValue.string.stream = (BYTE*)memcpy(buffer,src,len);\
        (dstBuf)->asnValue.string.dynamic = FALSE;                       \
    }                                                                    \
}

#define ForceSetAsnOctetString(dstBuf,buffer,src,len){               \
    (dstBuf)->asnType = ASN_OCTETSTRING;                             \
    if ((dstBuf)->asnValue.string.dynamic)                           \
    {                                                                \
        SnmpUtilMemFree((dstBuf)->asnValue.string.stream);           \
    }                                                                \
    (dstBuf)->asnValue.string.length = len;                          \
    (dstBuf)->asnValue.string.stream = (BYTE*)memcpy(buffer,src,len);\
    (dstBuf)->asnValue.string.dynamic = FALSE;                       \
}

#define SetAsnIPAddress(dstBuf,buffer,val){                     \
    if ((dstBuf)->asnType)                                      \
    {                                                           \
        ASSERT((dstBuf)->asnType==ASN_RFC1155_IPADDRESS);       \
        (dstBuf)->asnValue.address.length = IP_ADDRESS_LEN;     \
        if(!(dstBuf)->asnValue.address.stream)                  \
        {                                                       \
           (dstBuf)->asnValue.address.stream = (PBYTE)buffer;   \
           (dstBuf)->asnValue.address.dynamic = FALSE;          \
        }                                                       \
        (*(DWORD*)((dstBuf)->asnValue.address.stream)) = val;   \
    }                                                           \
}

#define ForceSetAsnIPAddress(dstBuf,buffer,val){                \
    (dstBuf)->asnType = ASN_RFC1155_IPADDRESS;                  \
    (dstBuf)->asnValue.address.length = IP_ADDRESS_LEN;         \
    if(!((dstBuf)->asnValue.address.stream))                    \
    {                                                           \
       (dstBuf)->asnValue.address.stream = (PBYTE)buffer;       \
       (dstBuf)->asnValue.address.dynamic = FALSE;              \
    }                                                           \
    (*(DWORD*)((dstBuf)->asnValue.address.stream)) = val;       \
}

#define SetAsnUshort(dstBuf,buffer,val){                   \
    if ((dstBuf)->asnType)           \
    {                                                      \
        ASSERT((dstBuf)->asnType==ASN_OCTETSTRING);        \
        (dstBuf)->asnValue.string.length = 2;              \
        (buffer)[0] = (BYTE)(val&0xFF);                    \
        (buffer)[1] = (BYTE)((val>>8)&0xFF);               \
        (dstBuf)->asnValue.string.stream = (BYTE *)buffer; \
        (dstBuf)->asnValue.string.dynamic = FALSE;         \
    }                                                      \
}
#define SetAsnDispString(dstBuf,buffer,src,len){           \
    if ((dstBuf)->asnType)           \
    {                                                      \
        ASSERT((dstBuf)->asnType==ASN_RFC1213_DISPSTRING); \
        (dstBuf)->asnValue.string.length = strlen(src);    \
        if ((dstBuf)->asnValue.string.length>len)          \
        {                                                  \
            (dstBuf)->asnValue.string.length = len;        \
            (dstBuf)->asnValue.string.stream = (BYTE *)strncpy (buffer,src,\
                                                            (dstBuf)->asnValue.string.length);\
            (dstBuf)->asnValue.string.dynamic = FALSE;     \
        }                                                  \
    }                                                      \
}

#define SetToZeroOid(dstBuf){                       \
    if ((dstBuf)->asnType)           \
    {                                                      \
        ASSERT((dstBuf)->asnType==ASN_OBJECTIDENTIFIER);   \
        (dstBuf)->asnValue.object.idLength = NULL_OID_LEN; \
        (dstBuf)->asnValue.object.ids =                    \
            SnmpUtilMemAlloc(NULL_OID_LEN * sizeof(UINT)); \
    }                                                      \
}

#define GetAsnInteger(srcBuf,defVal)                        \
    (((srcBuf)->asnType)? ((srcBuf)->asnValue.number):(defVal))

#define GetAsnCounter(srcBuf,defVal)                        \
    (((srcBuf)->asnType)? ((srcBuf)->asnValue.counter):(defVal))

#define GetAsnOctetString(dst,srcBuf)                                                   \
    (((srcBuf)->asnType)?                                                               \
     (memcpy(dst,(srcBuf)->asnValue.string.stream,(srcBuf)->asnValue.string.length))    \
     :NULL) 

#define GetAsnIPAddress(srcBuf,defVal)                                  \
    (DWORD)(((srcBuf)->asnType && (srcBuf)->asnValue.string.length)?    \
            (*(DWORD*)((srcBuf)->asnValue.address.stream)) : (defVal))  

#define IsAsnTypeNull(asnObj) (!((asnObj)->asnType))
#define IsAsnIPAddressTypeNull(asnObj) (!((asnObj)->asnType && (asnObj)->asnValue.address.length))
#define IsAsnOctetStringTypeNull(asnObj) (!((asnObj)->asnType && (asnObj)->asnValue.string.length))

//
// When adding to this list, update the arrays in init.c.
//
typedef enum {
    MIB_II_SYS = 0,
    MIB_II_IF,
    MIB_II_IPADDR,
    FORWARD_MIB,
    MIB_II_IPNET,
    MIB_II_TCP,
    MIB_II_UDP,
    MIB_II_TCP6,
    MIB_II_UDP6_LISTENER,
    MIB_II_IPV6_IF,
    MIB_II_IPV6_NET_TO_MEDIA,
    MIB_II_IPV6_ROUTE,
    MIB_II_ICMP,
    NUM_CACHE
} MIB_II_IDS;

#define MIB_II_TRAP          NUM_CACHE

#define NUM_LOCKS            MIB_II_TRAP   + 1

//
// Timeouts for the caches in millisecs
//

#define SYSTEM_CACHE_TIMEOUT        (60 * 1000)
#define IF_CACHE_TIMEOUT            (10 * 1000)
#define IP_ADDR_CACHE_TIMEOUT       (20 * 1000)
#define IP_FORWARD_CACHE_TIMEOUT    (20 * 1000)
#define IP_NET_CACHE_TIMEOUT        (30 * 1000)
#define TCP_CACHE_TIMEOUT           (30 * 1000)
#define UDP_CACHE_TIMEOUT           (30 * 1000)
#define IPV6_IF_CACHE_TIMEOUT       (10 * 1000)
#define IPV6_NEIGHBOR_CACHE_TIMEOUT (30 * 1000)
#define IPV6_ROUTE_TABLE_TIMEOUT    (20 * 1000)
#define ICMP_CACHE_TIMEOUT          (10 * 1000)

//
// Cant poll faster than twice IF cache timeout
//

#define MIN_POLL_TIME               (IF_CACHE_TIMEOUT * 2)

//
// Default poll interval is 15 seconds
//

#define DEFAULT_POLL_TIME           15000

#define MAX_DIFF    20
#define SPILLOVER   10

#define is      ==
#define isnot   !=
#define and     &&
#define or      ||

#define INVALID_IFINDEX     0xffffffff

#ifdef MIB_DEBUG
#define TRACE0(Z)             TracePrintf(g_hTrace,Z)
#define TRACE1(Y,Z)           TracePrintf(g_hTrace,Y,Z)
#define TRACE2(X,Y,Z)         TracePrintf(g_hTrace,X,Y,Z)
#define TRACE3(W,X,Y,Z)       TracePrintf(g_hTrace,W,X,Y,Z)
#define TRACE4(V,W,X,Y,Z)     TracePrintf(g_hTrace,V,W,X,Y,Z)
#define TRACE5(U,V,W,X,Y,Z)   TracePrintf(g_hTrace,U,W,X,Y,Z)
#define TraceEnter(X)         TracePrintf(g_hTrace,"Entering " X)
#define TraceLeave(X)         TracePrintf(g_hTrace,"Leaving " X "\n")
#else
#define TRACE0(Z)
#define TRACE1(Y,Z)  
#define TRACE2(X,Y,Z)
#define TRACE3(W,X,Y,Z)
#define TRACE4(V,W,X,Y,Z)
#define TRACE5(U,V,W,X,Y,Z)
#define TraceEnter(X) 
#define TraceLeave(X)
#endif

extern RTL_RESOURCE g_LockTable[NUM_LOCKS];

#ifdef DEADLOCK_DEBUG

extern PBYTE        g_pszLockNames[];

#define ReleaseLock(id) {                                   \
    TRACE1("Exit lock %s",g_pszLockNames[id]);              \
    RtlReleaseResource(&(g_LockTable[(id)]));               \
    TRACE1("Exited lock %s",g_pszLockNames[id]);            \
}

#define EnterReader(id) {                                   \
    TRACE1("Entering Reader %s",g_pszLockNames[id]);        \
    RtlAcquireResourceShared(&(g_LockTable[(id)]),TRUE);    \
    TRACE1("Entered %s",g_pszLockNames[id]);                \
}

#define EnterWriter(id) {                                   \
    TRACE1("Entering Writer %s",g_pszLockNames[id]);        \
    RtlAcquireResourceExclusive(&(g_LockTable[(id)]),TRUE); \
    TRACE1("Entered %s",g_pszLockNames[id]);                \
}

#else   // DEADLOCK_DEBUG

#define ReleaseLock(id)       RtlReleaseResource(&(g_LockTable[(id)]))
#define EnterReader(id)       RtlAcquireResourceShared(&(g_LockTable[(id)]),TRUE)
#define EnterWriter(id)       RtlAcquireResourceExclusive(&(g_LockTable[(id)]),TRUE)

#endif  // DEADLOCK_DEBUG

#define InvalidateCache(X) g_dwLastUpdateTable[(X)] = 0

//
// SYS UNITS is 100s of NS. 1 millisec would be 1 * 10^4 sys units
//

#define SYS_UNITS_IN_1_MILLISEC 10000

#define MilliSecsToSysUnits(X)      \
            RtlEnlargedIntegerMultiply((X),SYS_UNITS_IN_1_MILLISEC)

#define REG_KEY_CPU  \
    TEXT("HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0")

#define REG_KEY_SYSTEM \
    TEXT("HARDWARE\\DESCRIPTION\\System")

#define REG_KEY_VERSION  \
    TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion")

#define REG_KEY_MIB2 \
    TEXT("System\\CurrentControlSet\\Services\\SNMP\\Parameters\\RFC1156Agent")

#define REG_KEY_MIB2SUBAGENT_PARAMETERS \
    TEXT("Software\\Microsoft\\RFC1156Agent\\CurrentVersion\\Parameters")

#define REG_VALUE_POLL  L"TrapPollTimeMilliSecs"

//
// some constant strings
//

#define TEXT_SOFTWARE_WINDOWS_VERSION \
    TEXT("- Software: Windows Version ")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\snmp\locate.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:


Abstract:
         File contains the following functions
	      LocateIfRow
	      LocateIpAddrRow
	      LocateIpForwardRow
	      LocateIpNetRow
	      LocateUdpRow
	      LocateUdp6Row
	      LocateTcpRow
	      LocateTcp6Row
	      LocateIpv6IfRow
	      LocateIpv6AddrRow
	      LocateIpv6NetToMediaRow
	      LocateIpv6RouteRow
	      LocateIpv6AddrPrefixRow
	      LocateInetIcmpRow
	      LocateInetIcmpMsgRow
	 
	 The LocateXXXRow Functions are passed a variable sized array of indices, a count of 
	 the number of indices passed and the type of query for which the location is being 
	 done (GET_FIRST, NEXT or GET/SET/CREATE/DELETE - there are only three type of 
	 behaviours of the locators). They fill in the index of the corresponding row and return 
	 ERROR_NO_DATA, ERROR_INVALID_INDEX, NO_ERROR or ERROR_NO_MORE_ITEMS 
	 
	 The general search algorithm is this;
	 If the table is empty, return ERROR_NO_DATA
	 else
	 If the query is a GET_FIRST
	 Return the first row
	 else
	 Build the index as follows:
         Set the Index to all 0s
         From the number of indices passed  figure out how much of the index you can build
         keeping the rest 0. If the query is a GET, SET, CREATE_ENTRY or DELETE_ENTRY
         then the complete index must be given. This check is, however, supposed to be done
         at the agent.
         If the full index has not been given, the index is deemed to be modified (Again 
         this can only happen in the NEXT case).
         After this a search is done. We try for an exact match with the index. For all
         queries other than NEXT there is no problem. For NEXT there are two cases:
               If the complete index was given and and you get an exact match, then you
               return the next entry. If you dont get an exact match you return the next 
	       higher entry
               If an incomplete index was given and you modified it by padding 0s, and if
               an exact match is found, then you return the matching entry (Of course if an
               exact match is not found you again return the next higher entry)

Revision History:

    Amritansh Raghav          6/8/95  Created

--*/
#include "allinc.h"


PMIB_IFROW
LocateIfRow(
    DWORD  dwQueryType, 
    AsnAny *paaIfIndex
    )
{
    DWORD i;
    DWORD dwIndex;
    
    //
    // If there is no index the type is ASN_NULL. This causes the macro to return the
    // default value (0 in this case)
    //
    
    dwIndex = GetAsnInteger(paaIfIndex, 0);
    
    TraceEnter("LocateIfRow");
    
    if (g_Cache.pRpcIfTable->dwNumEntries is 0)
    {
        TraceLeave("LocateIfRow");
        return NULL;
    }
    
    if (dwQueryType is GET_FIRST)
    {
        TraceLeave("LocateIfRow");
        return &(g_Cache.pRpcIfTable->table[0]);
    }
        
    for (i = 0; i < g_Cache.pRpcIfTable->dwNumEntries; i++)
    {
        if ((g_Cache.pRpcIfTable->table[i].dwIndex is dwIndex) and dwQueryType is GET_EXACT)
        {
            TraceLeave("LocateIfRow");
    
            return &(g_Cache.pRpcIfTable->table[i]);
        }
        
        if (g_Cache.pRpcIfTable->table[i].dwIndex > dwIndex)
        {
            if (dwQueryType is GET_NEXT)
            {
                TraceLeave("LocateIfRow");
                return &(g_Cache.pRpcIfTable->table[i]);
            }
            else
            {
                TraceLeave("LocateIfRow");
                return NULL;
            }
        }
    }
    
    TraceLeave("LocateIfRow");
    
    return NULL;
}

PMIB_IPV6_IF
LocateIpv6IfRow(
    DWORD  dwQueryType, 
    AsnAny *paaIfIndex
    )
{
    DWORD i;
    DWORD dwIndex;
    
    //
    // If there is no index the type is ASN_NULL. This causes the macro to 
    // return the default value (0 in this case)
    //
    
    dwIndex = GetAsnInteger(paaIfIndex, 0);
    
    TraceEnter("LocateIpv6IfRow");
    
    if (g_Cache.pRpcIpv6IfTable.dwNumEntries is 0)
    {
        TraceLeave("LocateIpv6IfRow");
        return NULL;
    }
    
    if (dwQueryType is GET_FIRST)
    {
        TraceLeave("LocateIpv6IfRow");
        return &(g_Cache.pRpcIpv6IfTable.table[0]);
    }
        
    for (i = 0; i < g_Cache.pRpcIpv6IfTable.dwNumEntries; i++)
    {
        if ((g_Cache.pRpcIpv6IfTable.table[i].dwIndex is dwIndex) and dwQueryType is GET_EXACT)
        {
            TraceLeave("LocateIpv6IfRow");
    
            return &(g_Cache.pRpcIpv6IfTable.table[i]);
        }
        
        if (g_Cache.pRpcIpv6IfTable.table[i].dwIndex > dwIndex)
        {
            if (dwQueryType is GET_NEXT)
            {
                TraceLeave("LocateIpv6IfRow");
                return &(g_Cache.pRpcIpv6IfTable.table[i]);
            }
            else
            {
                TraceLeave("LocateIpv6IfRow");
                return NULL;
            }
        }
    }
    
    TraceLeave("LocateIpv6IfRow");
    
    return NULL;
}

PMIB_IPV6_ADDR
LocateIpv6AddrRow(
    DWORD  dwQueryType, 
    AsnAny *paaIfIndex,
    AsnAny *paaAddress
    )
{
    LONG  lCompare;
    DWORD i;
    BOOL  bNext, bModified;
    IN6_ADDR ipAddress;
    DWORD    dwIfIndex;
    
    TraceEnter("LocateIpv6AddrRow");
    
    if (g_Cache.pRpcIpv6AddrTable.dwNumEntries is 0)
    {
        TraceLeave("LocateIpv6AddrRow");
        return NULL;
    }
    
    if (dwQueryType is GET_FIRST)
    {
        TraceLeave("LocateIpv6AddrRow");
        return &(g_Cache.pRpcIpv6AddrTable.table[0]);
    }
   
    ZeroMemory(&ipAddress, sizeof(ipAddress));
    dwIfIndex = GetAsnInteger(paaIfIndex, -1);
    
    bModified = FALSE;
    
    if (IsAsnOctetStringTypeNull(paaAddress) || 
        (paaAddress->asnValue.string.length < sizeof(ipAddress)))
    {
        bModified = TRUE;
    } 
    else
    {
        GetAsnOctetString(&ipAddress, paaAddress);
    }

    bNext = (dwQueryType is GET_NEXT) and (bModified is FALSE);
    
    for (i = 0; i < g_Cache.pRpcIpv6AddrTable.dwNumEntries; i++)
    {
        Cmp(dwIfIndex, g_Cache.pRpcIpv6AddrTable.table[i].dwIfIndex, lCompare);
        if (lCompare is 0) {
            lCompare = memcmp(&ipAddress, 
                              &g_Cache.pRpcIpv6AddrTable.table[i].ipAddress, 
                              sizeof(ipAddress));
        }

        if ((lCompare is 0) and !bNext)
        {
            TraceLeave("LocateIpv6AddrRow");
            return &(g_Cache.pRpcIpv6AddrTable.table[i]);
        }
        
        if (lCompare < 0)
        {
            if (dwQueryType is GET_NEXT)
            {
                TraceLeave("LocateIpv6AddrRow");
                return &(g_Cache.pRpcIpv6AddrTable.table[i]);
            }
            else
            {
                TraceLeave("LocateIpv6AddrRow");
                return NULL;
            }
        }
    }
    
    TraceLeave("LocateIpv6AddrRow");
    return NULL;
}

PMIB_IPV6_NET_TO_MEDIA
LocateIpv6NetToMediaRow(
    DWORD  dwQueryType, 
    AsnAny *paaIfIndex,
    AsnAny *paaAddress
    )
{
    LONG  lCompare;
    DWORD i, dwIfIndex;
    BOOL  bNext, bModified;
    IN6_ADDR ipAddress;
    
    TraceEnter("LocateIpv6NetToMediaRow");
    
    if (g_Cache.pRpcIpv6NetToMediaTable.dwNumEntries is 0)
    {
        TraceLeave("LocateIpv6NetToMediaRow");
        return NULL;
    }
    
    if (dwQueryType is GET_FIRST)
    {
        TraceLeave("LocateIpv6NetToMediaRow");
        return &(g_Cache.pRpcIpv6NetToMediaTable.table[0]);
    }
   
    ZeroMemory(&ipAddress, sizeof(ipAddress));
    dwIfIndex = GetAsnInteger(paaIfIndex, -1);
    
    bModified = FALSE;
    
    if (IsAsnOctetStringTypeNull(paaAddress) ||
        (paaAddress->asnValue.string.length < sizeof(ipAddress)))
    {
        bModified = TRUE;
    }
    else
    {
        GetAsnOctetString(&ipAddress, paaAddress);
    }

    bNext = (dwQueryType is GET_NEXT) and (bModified is FALSE);
    
    for (i = 0; i < g_Cache.pRpcIpv6NetToMediaTable.dwNumEntries; i++)
    {
        Cmp(dwIfIndex, g_Cache.pRpcIpv6NetToMediaTable.table[i].dwIfIndex,
            lCompare);
        if (lCompare is 0) {
            lCompare = memcmp(&ipAddress, 
                              &g_Cache.pRpcIpv6NetToMediaTable.table[i].ipAddress, 
                              sizeof(ipAddress));
        }

        if ((lCompare is 0) and !bNext)
        {
            TraceLeave("LocateIpv6NetToMediaRow");
            return &(g_Cache.pRpcIpv6NetToMediaTable.table[i]);
        }
        
        if (lCompare < 0)
        {
            if (dwQueryType is GET_NEXT)
            {
                TraceLeave("LocateIpv6NetToMediaRow");
                return &(g_Cache.pRpcIpv6NetToMediaTable.table[i]);
            }
            else
            {
                TraceLeave("LocateIpv6NetToMediaRow");
                return NULL;
            }
        }
    }
    
    TraceLeave("LocateIpv6NetToMediaRow");
    return NULL;
}

PMIB_IPV6_ROUTE
LocateIpv6RouteRow(
    DWORD  dwQueryType,
    AsnAny *paaPrefix,
    AsnAny *paaPrefixLength,
    AsnAny *paaIndex
    )
{
    LONG  lCompare;
    DWORD i, dwPrefixLength, dwIndex;
    BOOL  bNext, bModified;
    IN6_ADDR ipPrefix;
    
    TraceEnter("LocateIpv6RouteRow");
    
    if (g_Cache.pRpcIpv6RouteTable.dwNumEntries is 0)
    {
        TraceLeave("LocateIpv6RouteRow");
        return NULL;
    }
    
    if (dwQueryType is GET_FIRST)
    {
        TraceLeave("LocateIpv6RouteRow");
        return &(g_Cache.pRpcIpv6RouteTable.table[0]);
    }
   
    ZeroMemory(&ipPrefix, sizeof(ipPrefix));
    dwPrefixLength = GetAsnInteger(paaPrefixLength, -1); 
    dwIndex = GetAsnInteger(paaIndex, -1); 
    
    bModified = FALSE;
    
    if (IsAsnOctetStringTypeNull(paaPrefix) ||
        (paaPrefix->asnValue.string.length < sizeof(ipPrefix)))
    {
        bModified = TRUE;
    }
    else
    {
        GetAsnOctetString(&ipPrefix, paaPrefix);
    }

    bNext = (dwQueryType is GET_NEXT) and (bModified is FALSE);
    
    for (i = 0; i < g_Cache.pRpcIpv6RouteTable.dwNumEntries; i++)
    {
        lCompare = memcmp(&ipPrefix, 
                          &g_Cache.pRpcIpv6RouteTable.table[i].ipPrefix, 
                          sizeof(ipPrefix));
        if (lCompare is 0) {
            if (Cmp(dwPrefixLength, g_Cache.pRpcIpv6RouteTable.table[i].dwPrefixLength, lCompare) is 0) {
                Cmp(dwIndex, g_Cache.pRpcIpv6RouteTable.table[i].dwIndex, lCompare);
            }
        }

        if ((lCompare is 0) and !bNext)
        {
            TraceLeave("LocateIpv6RouteRow");
            return &(g_Cache.pRpcIpv6RouteTable.table[i]);
        }
        
        if (lCompare < 0)
        {
            if (dwQueryType is GET_NEXT)
            {
                TraceLeave("LocateIpv6RouteRow");
                return &(g_Cache.pRpcIpv6RouteTable.table[i]);
            }
            else
            {
                TraceLeave("LocateIpv6RouteRow");
                return NULL;
            }
        }
    }
    
    TraceLeave("LocateIpv6RouteRow");
    return NULL;
}

PMIB_IPV6_ADDR_PREFIX
LocateIpv6AddrPrefixRow(
    DWORD  dwQueryType,
    AsnAny *paaIfIndex,
    AsnAny *paaPrefix,
    AsnAny *paaPrefixLength
    )
{
    LONG  lCompare;
    DWORD i, dwPrefixLength, dwIfIndex;
    BOOL  bNext, bModified;
    IN6_ADDR ipPrefix;
    
    TraceEnter("LocateIpv6AddrPrefixRow");
    
    if (g_Cache.pRpcIpv6AddrPrefixTable.dwNumEntries is 0)
    {
        TraceLeave("LocateIpv6AddrPrefixRow");
        return NULL;
    }
    
    if (dwQueryType is GET_FIRST)
    {
        TraceLeave("LocateIpv6AddrPrefixRow");
        return &(g_Cache.pRpcIpv6AddrPrefixTable.table[0]);
    }
   
    dwIfIndex = GetAsnInteger(paaIfIndex, -1); 
    ZeroMemory(&ipPrefix, sizeof(ipPrefix));
    dwPrefixLength = GetAsnInteger(paaPrefixLength, -1); 
    
    bModified = FALSE;
    
    if (IsAsnOctetStringTypeNull(paaPrefix) ||
        (paaPrefix->asnValue.string.length < sizeof(ipPrefix)))
    {
        bModified = TRUE;
    }
    else
    {
        GetAsnOctetString(&ipPrefix, paaPrefix);
    }

    bNext = (dwQueryType is GET_NEXT) and (bModified is FALSE);
    
    for (i = 0; i < g_Cache.pRpcIpv6AddrPrefixTable.dwNumEntries; i++)
    {
        if (Cmp(dwIfIndex, g_Cache.pRpcIpv6AddrPrefixTable.table[i].dwIfIndex,
                lCompare) is 0) 
        {
            lCompare = memcmp(&ipPrefix, 
                              &g_Cache.pRpcIpv6AddrPrefixTable.table[i].ipPrefix, 
                              sizeof(ipPrefix));
            if (lCompare is 0) 
            {
                Cmp(dwPrefixLength, 
                    g_Cache.pRpcIpv6AddrPrefixTable.table[i].dwPrefixLength, 
                    lCompare);
            }
        }

        if ((lCompare is 0) and !bNext)
        {
            TraceLeave("LocateIpv6AddrPrefixRow");
            return &(g_Cache.pRpcIpv6AddrPrefixTable.table[i]);
        }
        
        if (lCompare < 0)
        {
            if (dwQueryType is GET_NEXT)
            {
                TraceLeave("LocateIpv6AddrPrefixRow");
                return &(g_Cache.pRpcIpv6AddrPrefixTable.table[i]);
            }
            else
            {
                TraceLeave("LocateIpv6AddrPrefixRow");
                return NULL;
            }
        }
    }
    
    TraceLeave("LocateIpv6AddrPrefixRow");
    return NULL;
}

PMIB_INET_ICMP
LocateInetIcmpRow(
    DWORD  dwQueryType,
    AsnAny *paaAFType,
    AsnAny *paaIfIndex
    )
{
    DWORD i;
    DWORD dwAFType, dwIfIndex;
    
    TraceEnter("LocateInetIcmpRow");
    
    if (g_Cache.pRpcInetIcmpTable.dwNumEntries is 0)
    {
        TraceLeave("LocateInetIcmpRow");
        return NULL;
    }
    
    if (dwQueryType is GET_FIRST)
    {
        TraceLeave("LocateInetIcmpRow");
        return &(g_Cache.pRpcInetIcmpTable.table[0]);
    }

    //
    // If there is no index the type is ASN_NULL. This causes the macro to 
    // return the default value.
    //
    dwAFType = GetAsnInteger(paaAFType, 0);
    dwIfIndex = GetAsnInteger(paaIfIndex, 0);
        
    for (i = 0; i < g_Cache.pRpcInetIcmpTable.dwNumEntries; i++)
    {
        if ((g_Cache.pRpcInetIcmpTable.table[i].dwIfIndex is dwIfIndex) and 
            (g_Cache.pRpcInetIcmpTable.table[i].dwAFType is dwAFType) and 
            (dwQueryType is GET_EXACT))
        {
            TraceLeave("LocateInetIcmpRow");
    
            return &(g_Cache.pRpcInetIcmpTable.table[i]);
        }
        
        if ((g_Cache.pRpcInetIcmpTable.table[i].dwAFType > dwAFType) or
            ((g_Cache.pRpcInetIcmpTable.table[i].dwAFType == dwAFType) and
             (g_Cache.pRpcInetIcmpTable.table[i].dwIfIndex > dwIfIndex)))
        {
            if (dwQueryType is GET_NEXT)
            {
                TraceLeave("LocateInetIcmpRow");
                return &(g_Cache.pRpcInetIcmpTable.table[i]);
            }
            else
            {
                TraceLeave("LocateInetIcmpRow");
                return NULL;
            }
        }
    }
    
    TraceLeave("LocateInetIcmpRow");
    
    return NULL;
}

PMIB_INET_ICMP_MSG
LocateInetIcmpMsgRow(
    DWORD  dwQueryType,
    AsnAny *paaAFType,
    AsnAny *paaIfIndex,
    AsnAny *paaType,
    AsnAny *paaCode
    )
{
    DWORD i;
    DWORD dwAFType, dwIfIndex, dwType, dwCode;
    LONG lCompare;
    
    TraceEnter("LocateInetIcmpMsgRow");
    
    if (g_Cache.pRpcInetIcmpMsgTable.dwNumEntries is 0)
    {
        TraceLeave("LocateInetIcmpMsgRow");
        return NULL;
    }
    
    if (dwQueryType is GET_FIRST)
    {
        TraceLeave("LocateInetIcmpMsgRow");
        return &(g_Cache.pRpcInetIcmpMsgTable.table[0]);
    }

    //
    // If there is no index the type is ASN_NULL. This causes the macro to 
    // return the default value.
    //
    dwAFType = GetAsnInteger(paaAFType, 0);
    dwIfIndex = GetAsnInteger(paaIfIndex, 0);
    dwType = GetAsnInteger(paaType, 0);
    dwCode = GetAsnInteger(paaCode, 0);
        
    for (i = 0; i < g_Cache.pRpcInetIcmpMsgTable.dwNumEntries; i++)
    {
        Cmp(dwAFType, g_Cache.pRpcInetIcmpMsgTable.table[i].dwAFType, lCompare);

        if (lCompare is 0)
        {
            Cmp(dwIfIndex, g_Cache.pRpcInetIcmpMsgTable.table[i].dwIfIndex,
                lCompare);
        }

        if (lCompare is 0)
        {
            Cmp(dwType, g_Cache.pRpcInetIcmpMsgTable.table[i].dwType, lCompare);
        }

        if (lCompare is 0)
        {
            Cmp(dwCode, g_Cache.pRpcInetIcmpMsgTable.table[i].dwCode, lCompare);
        }

        if ((lCompare is 0) and (dwQueryType is GET_EXACT))
        {
            TraceLeave("LocateInetIcmpMsgRow");
    
            return &(g_Cache.pRpcInetIcmpMsgTable.table[i]);
        }
        
        if (lCompare < 0)
        {
            if (dwQueryType is GET_NEXT)
            {
                TraceLeave("LocateInetIcmpMsgRow");
                return &(g_Cache.pRpcInetIcmpMsgTable.table[i]);
            }
            else
            {
                TraceLeave("LocateInetIcmpMsgRow");
                return NULL;
            }
        }
    }
    
    TraceLeave("LocateInetIcmpMsgRow");
    
    return NULL;
}

PMIB_IPADDRROW
LocateIpAddrRow(
    DWORD  dwQueryType, 
    AsnAny *paaIpAddr
    )
{
    LONG  lCompare;
    DWORD i, dwAddr;
    BOOL  bNext, bModified;
    
    TraceEnter("LocateIpAddrRow");
    
    if (g_Cache.pRpcIpAddrTable->dwNumEntries is 0)
    {
        TraceLeave("LocateIpAddrRow");
        return NULL;
    }
    
    if (dwQueryType is GET_FIRST)
    {
        TraceLeave("LocateIpAddrRow");
        return &(g_Cache.pRpcIpAddrTable->table[0]);
    }
   
    dwAddr = GetAsnIPAddress(paaIpAddr, 0x00000000);
    
    bModified = FALSE;
    
    if (IsAsnIPAddressTypeNull(paaIpAddr))
    {
        bModified = TRUE;
    }

    bNext = (dwQueryType is GET_NEXT) and (bModified is FALSE);
    
    for (i = 0; i < g_Cache.pRpcIpAddrTable->dwNumEntries; i++)
    {
        if ((InetCmp(dwAddr, g_Cache.pRpcIpAddrTable->table[i].dwAddr, lCompare) is 0) and !bNext)
        {
            TraceLeave("LocateIpAddrRow");
            return &(g_Cache.pRpcIpAddrTable->table[i]);
        }
        
        if (lCompare < 0)
        {
            if (dwQueryType is GET_NEXT)
            {
                TraceLeave("LocateIpAddrRow");
                return &(g_Cache.pRpcIpAddrTable->table[i]);
            }
            else
            {
                TraceLeave("LocateIpAddrRow");
                return NULL;
            }
        }
    }
    
    TraceLeave("LocateIpAddrRow");
    return NULL;
}

PMIB_IPFORWARDROW
LocateIpRouteRow(
    DWORD  dwQueryType, 
    AsnAny *paaIpDest
    )
{
    DWORD dwDest;
    LONG  lCompare;
    DWORD i;
    BOOL  bNext, bModified;
    
    TraceEnter("LocateIpRouteRow");
    
    if (g_Cache.pRpcIpForwardTable->dwNumEntries is 0)
    {
        TraceLeave("LocateIpRouteRow");
        return NULL;
    }
    
    if (dwQueryType is GET_FIRST)
    {
        TraceLeave("LocateIpRouteRow");
        return &(g_Cache.pRpcIpForwardTable->table[0]);
    }
    
    dwDest = GetAsnIPAddress(paaIpDest, 0x00000000);
    
    bModified = FALSE;
    
    if (IsAsnIPAddressTypeNull(paaIpDest))
    {
        bModified = TRUE;
    }
          
    bNext = (dwQueryType is GET_NEXT) and (bModified is FALSE);
    
    for (i = 0; i < g_Cache.pRpcIpForwardTable->dwNumEntries; i++)
    {
        if ((InetCmp(dwDest, g_Cache.pRpcIpForwardTable->table[i].dwForwardDest, lCompare) is 0) and !bNext)
        {
            TraceLeave("LocateIpRouteRow");
            return &(g_Cache.pRpcIpForwardTable->table[i]);
        }
        
        if (lCompare < 0)
        {
            if (dwQueryType is GET_NEXT)
            {
                TraceLeave("LocateIpRouteRow");
                return &(g_Cache.pRpcIpForwardTable->table[i]);
            }
            else
            {
                TraceLeave("LocateIpRouteRow");
                return NULL;
            }
        }
    }
    
    TraceLeave("LocateIpRouteRow");
    return NULL;
}

PMIB_IPFORWARDROW
LocateIpForwardRow(
    DWORD  dwQueryType,
    AsnAny *paaDest,
    AsnAny *paaProto,
    AsnAny *paaPolicy,
    AsnAny *paaNextHop
    )
{
    DWORD dwIpForwardIndex[4];
    LONG  lCompare;
    DWORD i;
    BOOL  bNext, bModified;
    
    TraceEnter("LocateIpForwardRow");
    
    if (g_Cache.pRpcIpForwardTable->dwNumEntries is 0)
    {
        TraceLeave("LocateIpForwardRow");
        return NULL;
    }
    
    if (dwQueryType is GET_FIRST)
    {
        TraceLeave("LocateIpForwardRow");
        return &(g_Cache.pRpcIpForwardTable->table[0]);
    }
    
    dwIpForwardIndex[0] = GetAsnIPAddress(paaDest, 0x00000000);
    dwIpForwardIndex[1] = GetAsnInteger(paaProto, 0);
    dwIpForwardIndex[2] = GetAsnInteger(paaPolicy, 0);
    dwIpForwardIndex[3] = GetAsnIPAddress(paaNextHop, 0x00000000);
    
    bModified = FALSE;

    if (IsAsnIPAddressTypeNull(paaDest) or
        IsAsnTypeNull(paaProto) or
        IsAsnTypeNull(paaPolicy) or
        IsAsnIPAddressTypeNull(paaNextHop))
    {
        bModified = TRUE;
    }
          
    bNext = (dwQueryType is GET_NEXT) and (bModified is FALSE);
    
    for (i = 0; i < g_Cache.pRpcIpForwardTable->dwNumEntries; i++)
    {
        lCompare = IpForwardCmp(dwIpForwardIndex[0],
                                dwIpForwardIndex[1],
                                dwIpForwardIndex[2],
                                dwIpForwardIndex[3],
                                g_Cache.pRpcIpForwardTable->table[i].dwForwardDest,
                                g_Cache.pRpcIpForwardTable->table[i].dwForwardProto,
                                g_Cache.pRpcIpForwardTable->table[i].dwForwardPolicy,
                                g_Cache.pRpcIpForwardTable->table[i].dwForwardNextHop);
        
        if ((lCompare is 0) and !bNext)
        {
            TraceLeave("LocateIpForwardRow");
            return &(g_Cache.pRpcIpForwardTable->table[i]);
        }
        
        if (lCompare < 0)
        {
            if (dwQueryType is GET_NEXT)
            {
                TraceLeave("LocateIpForwardRow");
                return &(g_Cache.pRpcIpForwardTable->table[i]);
            }
            else
            {
                TraceLeave("LocateIpForwardRow");
                return NULL;
            }
        }
    }
    
    TraceLeave("LocateIpForwardRow");
    return NULL;
}

PMIB_IPNETROW
LocateIpNetRow(
    DWORD  dwQueryType, 
    AsnAny *paaIndex,
    AsnAny *paaAddr
    )
{
    DWORD i;
    LONG  lCompare;
    DWORD dwIpNetIfIndex, dwIpNetIpAddr;
    BOOL  bNext, bModified;

    TraceEnter("LocateIfNetRow");
    
    if (g_Cache.pRpcIpNetTable->dwNumEntries is 0)
    {
        TraceLeave("LocateIpNetRow");
        return NULL;
    }
    
    if (dwQueryType is GET_FIRST)
    {
        TraceLeave("LocateIpNetRow");
        return &(g_Cache.pRpcIpNetTable->table[0]);
    }
          
    bModified = FALSE;

    dwIpNetIfIndex = GetAsnInteger(paaIndex, 0);
    dwIpNetIpAddr  = GetAsnIPAddress(paaAddr, 0x00000000);
    
    if (IsAsnTypeNull(paaIndex) or
        IsAsnIPAddressTypeNull(paaAddr))
    {
        bModified = TRUE;
    }
    
    bNext = (dwQueryType is GET_NEXT) and (bModified is FALSE);
    
    for (i = 0; i < g_Cache.pRpcIpNetTable->dwNumEntries; i++)
    {
        lCompare = IpNetCmp(dwIpNetIfIndex,
                            dwIpNetIpAddr, 
                            g_Cache.pRpcIpNetTable->table[i].dwIndex,
                            g_Cache.pRpcIpNetTable->table[i].dwAddr);
    
        if ((lCompare is 0) and !bNext)
        {
            TraceLeave("LocateIpNetRow");
            return &(g_Cache.pRpcIpNetTable->table[i]);
        }
        
        if (lCompare < 0)
        {
            if (dwQueryType is GET_NEXT)
            {
                TraceLeave("LocateIpNetRow");
                return &(g_Cache.pRpcIpNetTable->table[i]);
            }
            else
            {
                TraceLeave("LocateIpNetRow");
                return NULL;
            }
        }
    }
    
    TraceLeave("LocateIpNetRow");
    return NULL;
}

PMIB_UDPROW
LocateUdpRow(
    DWORD  dwQueryType, 
    AsnAny *paaLocalAddr,
    AsnAny *paaLocalPort
    )
{
    DWORD  i;
    LONG   lCompare;
    DWORD  dwIndex[2];
    BOOL   bNext, bModified;
    
    TraceEnter("LocateUdpRow");
    
    if (g_Cache.pRpcUdpTable->dwNumEntries is 0)
    {
        TraceLeave("LocateUdpRow");
        return NULL;
    }
    
    if (dwQueryType is GET_FIRST)
    {
        TraceLeave("LocateUdpRow");
        return &(g_Cache.pRpcUdpTable->table[0]);
    }

#define LOCAL_ADDR 0
#define LOCAL_PORT 1
	
    dwIndex[LOCAL_ADDR] = GetAsnIPAddress(paaLocalAddr, 0x00000000);
    dwIndex[LOCAL_PORT] = GetAsnInteger(paaLocalPort, 0);
    
    bModified = FALSE;
    
    if (IsAsnIPAddressTypeNull(paaLocalAddr) or
        IsAsnTypeNull(paaLocalPort))
    {
        bModified = TRUE;
    }
    
    bNext = (dwQueryType is GET_NEXT) and (bModified is FALSE);
    
    for (i = 0; i < g_Cache.pRpcUdpTable->dwNumEntries; i++)
    {
        lCompare = UdpCmp(dwIndex[LOCAL_ADDR],
                          dwIndex[LOCAL_PORT],
                          g_Cache.pRpcUdpTable->table[i].dwLocalAddr,
                          g_Cache.pRpcUdpTable->table[i].dwLocalPort);
        
        if ((lCompare is 0) and !bNext)
        {
            TraceLeave("LocateUdpRow");
            return &(g_Cache.pRpcUdpTable->table[i]);
        }
        
        if (lCompare < 0)
        {
            if (dwQueryType is GET_NEXT)
            {
                TraceLeave("LocateUdpRow");
                return &(g_Cache.pRpcUdpTable->table[i]);
            }
            else
            {
                TraceLeave("LocateUdpRow");
                return NULL;
            }
        }
    } 
  
    TraceLeave("LocateUdpRow");

    return NULL;
}

PUDP6ListenerEntry
LocateUdp6Row(
    DWORD  dwQueryType, 
    AsnAny *paaLocalAddr,
    AsnAny *paaLocalPort
    )
{
    DWORD  i;
    LONG   lCompare;
    DWORD  dwLocalPort;
    BOOL   bNext, bModified;

    // address plus scope id
    BYTE   rgbyLocalAddrEx[20];
    
    TraceEnter("LocateUdp6Row");
    
    if (g_Cache.pRpcUdp6ListenerTable->dwNumEntries is 0)
    {
        TraceLeave("LocateUdp6Row");
        return NULL;
    }
    
    if (dwQueryType is GET_FIRST)
    {
        TraceLeave("LocateUdp6Row");
        return &(g_Cache.pRpcUdp6ListenerTable->table[0]);
    }

    // zero out scope id in case the octet string doesn't include it
    ZeroMemory(rgbyLocalAddrEx, sizeof(rgbyLocalAddrEx));

    GetAsnOctetString(rgbyLocalAddrEx, paaLocalAddr);
    dwLocalPort = GetAsnInteger(paaLocalPort, 0);
    
    bModified = FALSE;
    
    if (IsAsnIPAddressTypeNull(paaLocalAddr) or
        IsAsnTypeNull(paaLocalPort))
    {
        bModified = TRUE;
    }
    
    bNext = (dwQueryType is GET_NEXT) and (bModified is FALSE);
    
    for (i = 0; i < g_Cache.pRpcUdp6ListenerTable->dwNumEntries; i++)
    {
        lCompare = Udp6Cmp(rgbyLocalAddrEx,
                           dwLocalPort,
                           g_Cache.pRpcUdp6ListenerTable->table[i].ule_localaddr.s6_bytes,
                           g_Cache.pRpcUdp6ListenerTable->table[i].ule_localport);
        
        if ((lCompare is 0) and !bNext)
        {
            TraceLeave("LocateUdp6Row");
            return &(g_Cache.pRpcUdp6ListenerTable->table[i]);
        }
        
        if (lCompare < 0)
        {
            if (dwQueryType is GET_NEXT)
            {
                TraceLeave("LocateUdp6Row");
                return &(g_Cache.pRpcUdp6ListenerTable->table[i]);
            }
            else
            {
                TraceLeave("LocateUdp6Row");
                return NULL;
            }
        }
    } 
  
    TraceLeave("LocateUdp6Row");
    return NULL;
}

PMIB_TCPROW
LocateTcpRow(
    DWORD  dwQueryType, 
    AsnAny *paaLocalAddr,
    AsnAny *paaLocalPort,
    AsnAny *paaRemoteAddr,
    AsnAny *paaRemotePort
    )
{
    LONG  lCompare;
    DWORD dwIndex[4];
    BOOL  bNext, bModified;
    DWORD startIndex, stopIndex, i;
    
    TraceEnter("LocateTcpRow");
    
    if (g_Cache.pRpcTcpTable->dwNumEntries is 0)
    {
        TraceLeave("LocateTcpRow");
        return NULL;
    }
    
    if (dwQueryType is GET_FIRST)
    {
        TraceLeave("LocateTcpRow");
        return &(g_Cache.pRpcTcpTable->table[0]);
    }

#define REM_ADDR 2
#define REM_PORT 3

    dwIndex[LOCAL_ADDR] = GetAsnIPAddress(paaLocalAddr, 0x00000000);
    dwIndex[LOCAL_PORT] = GetAsnInteger(paaLocalPort, 0);
    dwIndex[REM_ADDR]   = GetAsnIPAddress(paaRemoteAddr, 0x00000000);
    dwIndex[REM_PORT]   = GetAsnInteger(paaRemotePort, 0);
    
    bModified = FALSE;
    
    if (IsAsnIPAddressTypeNull(paaLocalAddr) or
        IsAsnTypeNull(paaLocalPort) or
        IsAsnIPAddressTypeNull(paaRemoteAddr) or
        IsAsnTypeNull(paaRemotePort))
    {
        bModified = TRUE;
    }
    
    bNext = (dwQueryType is GET_NEXT) and (bModified is FALSE);
    
    for (i = 0; i < g_Cache.pRpcTcpTable->dwNumEntries; i++)
    {
        lCompare = TcpCmp(dwIndex[LOCAL_ADDR],
                          dwIndex[LOCAL_PORT],
                          dwIndex[REM_ADDR],
                          dwIndex[REM_PORT],
                          g_Cache.pRpcTcpTable->table[i].dwLocalAddr,
                          g_Cache.pRpcTcpTable->table[i].dwLocalPort,
                          g_Cache.pRpcTcpTable->table[i].dwRemoteAddr,
                          g_Cache.pRpcTcpTable->table[i].dwRemotePort);
        
        if ((lCompare is 0) and !bNext)
        {
            TraceLeave("LocateTcpRow");
            return &(g_Cache.pRpcTcpTable->table[i]);
        }
	
        if (lCompare < 0)
        {
            if (dwQueryType is GET_NEXT)
            {
                TraceLeave("LocateTcpRow");
                return &(g_Cache.pRpcTcpTable->table[i]);
            }
            else
            {
                TraceLeave("LocateTcpRow");
                return NULL;
            }
        }
    }
    
    TraceLeave("LocateTcpRow");
    return NULL;
}

PTCP6ConnTableEntry
LocateTcp6Row(
    DWORD  dwQueryType, 
    AsnAny *paaLocalAddr,
    AsnAny *paaLocalPort,
    AsnAny *paaRemoteAddr,
    AsnAny *paaRemotePort
    )
{
    LONG  lCompare;
    DWORD dwLocalPort, dwRemotePort;
    BOOL  bNext, bModified;
    DWORD startIndex, stopIndex, i;

    // address plus scope id
    BYTE  rgbyLocalAddrEx[20]; 
    BYTE  rgbyRemoteAddrEx[20];
    
    TraceEnter("LocateTcp6Row");
    
    if (g_Cache.pRpcTcp6Table->dwNumEntries is 0)
    {
        TraceLeave("LocateTcp6Row");
        return NULL;
    }
    
    if (dwQueryType is GET_FIRST)
    {
        TraceLeave("LocateTcp6Row");
        return &(g_Cache.pRpcTcp6Table->table[0]);
    }

    // zero out scope id in case the octet string doesn't include it
    ZeroMemory(rgbyLocalAddrEx, sizeof(rgbyLocalAddrEx));
    ZeroMemory(rgbyRemoteAddrEx, sizeof(rgbyRemoteAddrEx));

    GetAsnOctetString(rgbyLocalAddrEx, paaLocalAddr);
    dwLocalPort = GetAsnInteger(paaLocalPort, 0);
    GetAsnOctetString(rgbyRemoteAddrEx, paaRemoteAddr);
    dwRemotePort = GetAsnInteger(paaRemotePort, 0);
    
    bModified = FALSE;
    
    if (IsAsnOctetStringTypeNull(paaLocalAddr) or
        IsAsnTypeNull(paaLocalPort) or
        IsAsnOctetStringTypeNull(paaRemoteAddr) or
        IsAsnTypeNull(paaRemotePort))
    {
        bModified = TRUE;
    }
    
    bNext = (dwQueryType is GET_NEXT) and (bModified is FALSE);
    
    for (i = 0; i < g_Cache.pRpcTcp6Table->dwNumEntries; i++)
    {
        lCompare = Tcp6Cmp(rgbyLocalAddrEx,
                           dwLocalPort,
                           rgbyRemoteAddrEx,
                           dwRemotePort,
                           g_Cache.pRpcTcp6Table->table[i].tct_localaddr.s6_bytes,
                           g_Cache.pRpcTcp6Table->table[i].tct_localport,
                           g_Cache.pRpcTcp6Table->table[i].tct_remoteaddr.s6_bytes,
                           g_Cache.pRpcTcp6Table->table[i].tct_remoteport);
        
        if ((lCompare is 0) and !bNext)
        {
            TraceLeave("LocateTcp6Row");
            return &(g_Cache.pRpcTcp6Table->table[i]);
        }
	
        if (lCompare < 0)
        {
            if (dwQueryType is GET_NEXT)
            {
                TraceLeave("LocateTcp6Row");
                return &(g_Cache.pRpcTcp6Table->table[i]);
            }
            else
            {
                TraceLeave("LocateTcp6Row");
                return NULL;
            }
        }
    }
    
    TraceLeave("LocateTcp6Row");
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\snmp\load.c ===
#include "allinc.h"

DWORD
LoadSystem()
{
    DWORD   dwResult;
    
    TraceEnter("LoadSystem");
    
    if(g_Cache.pRpcSysInfo)
    {
        if(g_Cache.pRpcSysInfo->aaSysObjectID.asnValue.object.ids)
        {
            SnmpUtilOidFree(&g_Cache.pRpcSysInfo->aaSysObjectID.asnValue.object);
        }

        HeapFree(g_hPrivateHeap,
                 0,
                 g_Cache.pRpcSysInfo);
        
        g_Cache.pRpcSysInfo = NULL;
    }
    
    dwResult = GetSysInfo(&(g_Cache.pRpcSysInfo),
                          g_hPrivateHeap,
                          0);
        
    if(dwResult isnot NO_ERROR)
    {
        TRACE1("GetSysInfo failed with error %x",dwResult);
        TraceLeave("LoadSysInfo");
    
        return dwResult;
    }
    
    TraceLeave("LoadSysInfo");
    
    return NO_ERROR;
}


DWORD
LoadIfTable()
{
    DWORD   dwResult;
    
    TraceEnter("LoadIfTable");
    
    if(g_Cache.pRpcIfTable)
    {
        HeapFree(g_hPrivateHeap,
                 0,
                 g_Cache.pRpcIfTable);
        
        g_Cache.pRpcIfTable = NULL;
    }
    
    dwResult = InternalGetIfTable(&(g_Cache.pRpcIfTable),
                                  g_hPrivateHeap,
                                  0);
        
    if(dwResult isnot NO_ERROR)
    {
        TRACE1("GetIfTable failed with error %x",
               dwResult);
        TraceLeave("LoadIfTable");
    
        return dwResult;
    }
    
    TraceLeave("LoadIfTable");
    
    return NO_ERROR;
}

DWORD
LoadIpAddrTable()
{
    DWORD   dwResult;
    
    TraceEnter("LoadIpAddrTable");
    
    if(g_Cache.pRpcIpAddrTable)
    {
        HeapFree(g_hPrivateHeap,
                 0,
                 g_Cache.pRpcIpAddrTable);
        
        g_Cache.pRpcIpAddrTable = NULL;
    }
    
    dwResult = InternalGetIpAddrTable(&(g_Cache.pRpcIpAddrTable),
                                      g_hPrivateHeap,
                                      0);
        
    if(dwResult isnot NO_ERROR)
    {
        TRACE1("GetIpAddrTable failed with error %x",
               dwResult);
        TraceLeave("LoadIpAddrTable");
            
        return dwResult;
    }
    
    TraceLeave("LoadIpAddrTable");
            
    return NO_ERROR;
}

DWORD
LoadIpNetTable()
{
    DWORD   dwResult;
    
    TraceEnter("LoadIpNetTable");
    
    if(g_Cache.pRpcIpNetTable)
    {
        HeapFree(g_hPrivateHeap,
                 0,
                 g_Cache.pRpcIpNetTable);
        
        g_Cache.pRpcIpNetTable = NULL;
    }
    
    dwResult = InternalGetIpNetTable(&(g_Cache.pRpcIpNetTable),
                                     g_hPrivateHeap,
                                     0);
            
    if(dwResult isnot NO_ERROR)
    {
        TRACE1("GetIpNetTable failed with error %x",
               dwResult);
        TraceLeave("LoadIpNetTable");
            
        return dwResult;
    }

    
    TraceLeave("LoadIpNetTable");
            
    return NO_ERROR;
}

DWORD
LoadIpForwardTable()
{
    DWORD   dwResult;
    
    TraceEnter("LoadIpForwardTable");
    
    if(g_Cache.pRpcIpForwardTable)
    {
        HeapFree(g_hPrivateHeap,
                 0,
                 g_Cache.pRpcIpForwardTable);
        
        g_Cache.pRpcIpForwardTable = NULL;
    }
    
    dwResult = InternalGetIpForwardTable(&(g_Cache.pRpcIpForwardTable),
                                         g_hPrivateHeap,
                                         0);
        
    if(dwResult isnot NO_ERROR)
    {
        TRACE1("GetIpForwardTable failed with error %x",
               dwResult);
        TraceLeave("LoadIpForwardTable");
            
        return dwResult;
    }

    TraceLeave("LoadIpForwardTable");
            
    return NO_ERROR;
}

DWORD
LoadTcpTable()
{
    DWORD  dwResult, i;
    
    TraceEnter("LoadTcpTable");
    
    if(g_Cache.pRpcTcpTable)
    {
        HeapFree(g_hPrivateHeap,
                 0,
                 g_Cache.pRpcTcpTable);
        
        g_Cache.pRpcTcpTable = NULL;
    }
    
    dwResult = InternalGetTcpTable(&(g_Cache.pRpcTcpTable),
                                   g_hPrivateHeap,
                                   0);
        
    if(dwResult isnot NO_ERROR)
    {
        TRACE1("GetTcpTable failed with error %x",
               dwResult);
        TraceLeave("LoadTcpTable");
            
        return dwResult;
    }

    //
    // modify port numbers to be in host byte order
    //
    
    for (i = 0; i < g_Cache.pRpcTcpTable->dwNumEntries; i++)
    {
        g_Cache.pRpcTcpTable->table[i].dwLocalPort = 
            (DWORD)ntohs((WORD)g_Cache.pRpcTcpTable->table[i].dwLocalPort);
        g_Cache.pRpcTcpTable->table[i].dwRemotePort = 
            (DWORD)ntohs((WORD)g_Cache.pRpcTcpTable->table[i].dwRemotePort);
    }
    
    TraceLeave("LoadTcpTable");
            
    return NO_ERROR;
}

DWORD
LoadTcp6Table()
{
    DWORD  dwResult, i;
    
    TraceEnter("LoadTcp6Table");
    
    if(g_Cache.pRpcTcp6Table)
    {
        HeapFree(g_hPrivateHeap,
                 0,
                 g_Cache.pRpcTcp6Table);
        
        g_Cache.pRpcTcp6Table = NULL;
    }
    
    dwResult = AllocateAndGetTcpExTableFromStack(
                        (TCP_EX_TABLE **)&(g_Cache.pRpcTcp6Table),
                        TRUE, g_hPrivateHeap, 0, AF_INET6);
        
    if(dwResult isnot NO_ERROR)
    {
        TRACE1("GetTcp6Table failed with error %x",
               dwResult);
        TraceLeave("LoadTcp6Table");
            
        return dwResult;
    }

    //
    // modify port numbers to be in host byte order
    // and scope ids to be in network byte order
    //
    
    for (i = 0; i < g_Cache.pRpcTcp6Table->dwNumEntries; i++)
    {
        g_Cache.pRpcTcp6Table->table[i].tct_localport = 
            (DWORD)ntohs((WORD)g_Cache.pRpcTcp6Table->table[i].tct_localport);
        g_Cache.pRpcTcp6Table->table[i].tct_remoteport = 
            (DWORD)ntohs((WORD)g_Cache.pRpcTcp6Table->table[i].tct_remoteport);
        g_Cache.pRpcTcp6Table->table[i].tct_localscopeid = 
            htonl(g_Cache.pRpcTcp6Table->table[i].tct_localscopeid);
        g_Cache.pRpcTcp6Table->table[i].tct_remotescopeid = 
            htonl(g_Cache.pRpcTcp6Table->table[i].tct_remotescopeid);
    }
    
    TraceLeave("LoadTcp6Table");
            
    return NO_ERROR;
}

DWORD
LoadUdpTable()
{
    DWORD   dwResult, i;
    
    TraceEnter("LoadUdpTable");
    
    if(g_Cache.pRpcUdpTable)
    {
        HeapFree(g_hPrivateHeap,
                 0,
                 g_Cache.pRpcUdpTable);
        
        g_Cache.pRpcUdpTable = NULL;
    }
    

    dwResult = InternalGetUdpTable(&(g_Cache.pRpcUdpTable),
                                   g_hPrivateHeap,
                                   0);
        
    if(dwResult isnot NO_ERROR)
    {
        TRACE1("GetUdpTable failed with error %x",
               dwResult);
        TraceLeave("LoadUdpTable");
            
        return dwResult;
    }

    //
    // modify port numbers to be in host byte order
    //
    
    for (i = 0; i < g_Cache.pRpcUdpTable->dwNumEntries; i++)
    {
        g_Cache.pRpcUdpTable->table[i].dwLocalPort = 
            (DWORD)ntohs((WORD)g_Cache.pRpcUdpTable->table[i].dwLocalPort);
    }
    
    TraceLeave("LoadUdpTable");
            
    return NO_ERROR;
}

DWORD
LoadUdp6ListenerTable()
{
    DWORD   dwResult, i;
    
    TraceEnter("LoadUdp6ListenerTable");
    
    if(g_Cache.pRpcUdp6ListenerTable)
    {
        HeapFree(g_hPrivateHeap,
                 0,
                 g_Cache.pRpcUdp6ListenerTable);
        
        g_Cache.pRpcUdp6ListenerTable = NULL;
    }
    

    dwResult = AllocateAndGetUdpExTableFromStack(
                    (UDP_EX_TABLE **)&(g_Cache.pRpcUdp6ListenerTable),
                    TRUE, g_hPrivateHeap, 0, AF_INET6);
        
    if(dwResult isnot NO_ERROR)
    {
        TRACE1("GetUdp6ListenerTable failed with error %x",
               dwResult);
        TraceLeave("LoadUdp6ListenerTable");
            
        return dwResult;
    }

    //
    // modify port numbers to be in host byte order
    // and scope ids to be in network byte order
    //
    
    for (i = 0; i < g_Cache.pRpcUdp6ListenerTable->dwNumEntries; i++)
    {
        g_Cache.pRpcUdp6ListenerTable->table[i].ule_localport = 
            (DWORD)ntohs((WORD)g_Cache.pRpcUdp6ListenerTable->table[i].ule_localport);
        g_Cache.pRpcUdp6ListenerTable->table[i].ule_localscopeid = 
            htonl(g_Cache.pRpcUdp6ListenerTable->table[i].ule_localscopeid);
    }
    
    TraceLeave("LoadUdp6ListenerTable");
            
    return NO_ERROR;
}

DWORD
GetSysInfo(
    MIB_SYSINFO  **ppRpcSysInfo,
    HANDLE       hHeap,
    DWORD        dwAllocFlags
    )
{
    DWORD dwResult,dwValueType,dwValueLen;
    PMIB_SYSINFO pRpcSysInfo;
    HKEY    hkeySysInfo;
    DWORD   dwBytes = 0, i, dwOidLen;
    PCHAR   pchBuff, pchStr, pchToken;
    BOOL    bOverride;
    
    TraceEnter("GetSysInfo");
    
    *ppRpcSysInfo = NULL;
    
    pRpcSysInfo = HeapAlloc(hHeap,
                            dwAllocFlags,
                            sizeof(MIB_SYSINFO));

    if(pRpcSysInfo is NULL)
    {
        dwResult = GetLastError();
        
        TRACE1("Allocation failed with error %d",
               dwResult);
        TraceLeave("GetSysInfo");
        
        return dwResult;
    }

    dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            REG_KEY_MIB2,
                            0,
                            KEY_ALL_ACCESS,
                            &hkeySysInfo);

    if (dwResult isnot NO_ERROR) {

        HeapFree(hHeap,
                 dwAllocFlags,
                 pRpcSysInfo);
    
        TRACE1("Couldnt open mib2 registry key. Error %d", dwResult);
        TraceLeave("GetSysInfo");

        return dwResult;
    }

    dwValueLen = sizeof(pRpcSysInfo->dwSysServices);

    dwResult = RegQueryValueEx(hkeySysInfo,
                               TEXT("sysServices"),
                               0,
                               &dwValueType,
                               (LPBYTE)&pRpcSysInfo->dwSysServices,
                               &dwValueLen
                               );

    if (dwResult isnot NO_ERROR) {

        HeapFree(hHeap,
                 dwAllocFlags,
                 pRpcSysInfo);
    
        TRACE1("Couldnt read sysServices value. Error %d", dwResult);
        TraceLeave("GetSysInfo");

        return dwResult;
    }

    bOverride = FALSE;
    
    do
    {
        //
        // First get the length of the OID
        //


        dwValueLen = 0;

        dwResult = RegQueryValueExA(hkeySysInfo,
                                    "sysObjectID",
                                    0,
                                    &dwValueType,
                                    NULL,
                                    &dwValueLen);

        if(((dwResult isnot ERROR_MORE_DATA) and (dwResult isnot NO_ERROR)) or
           (dwValueLen is 0))
        {
            //
            // The only two codes that give us a good buffer len are
            // NO_ERROR and ERROR_MORE_DATA. If the error code is not one
            // of those, or if the oid len is 0, just set the OID to system oid
            //

            break;
        }
        
        pchBuff = HeapAlloc(g_hPrivateHeap,
                            HEAP_ZERO_MEMORY,
                            dwValueLen + 1);

        if(pchBuff is NULL)
        {
            break;
        }

        dwResult = RegQueryValueExA(hkeySysInfo,
                                    "sysObjectID",
                                    0,
                                    &dwValueType,
                                    pchBuff,
                                    &dwValueLen);
        
        if((dwResult isnot NO_ERROR) or
           (dwValueType isnot REG_SZ) or
           (dwValueLen is 0))
        {
            break;
        }

        //
        // Parse out the oid and store it away
        // pchBuff is NULL terminated so we use strtok to overwrite
        // all the "." with \0. This way we figure out the number
        // of ids. Then we allocate memory to hold those many ids
        //
        
        dwOidLen = 1;
        
        pchToken = strtok(pchBuff,".");
        
        while(pchToken)
        {
            dwOidLen++;
            
            pchToken = strtok(NULL,".");
        }
        
        //
        // If the leading OID is 0, there is a problem
        //
        
        if(atoi(pchBuff) is 0)
        {
            break;
        }   

        pRpcSysInfo->aaSysObjectID.asnType = ASN_OBJECTIDENTIFIER;
        
        pRpcSysInfo->aaSysObjectID.asnValue.object.idLength = dwOidLen;
        
        pRpcSysInfo->aaSysObjectID.asnValue.object.ids =
            SnmpUtilMemAlloc(dwOidLen * sizeof(UINT));

        for(i = 0, pchStr = pchBuff; i < dwOidLen; i++)
        {
            pRpcSysInfo->aaSysObjectID.asnValue.object.ids[i] = atoi(pchStr);
            
            pchStr += strlen(pchStr) + 1;
        }
        
        HeapFree(g_hPrivateHeap,
                 0,
                 pchBuff);

        bOverride = TRUE;
        
    }while(FALSE);

    if(!bOverride)
    {
        SnmpUtilOidCpy(&pRpcSysInfo->aaSysObjectID.asnValue.object,
                       SnmpSvcGetEnterpriseOID());
    }
    
    dwValueLen = sizeof(pRpcSysInfo->rgbySysName);

    dwResult = RegQueryValueEx(hkeySysInfo,
                               TEXT("sysName"), 
                               0,
                               &dwValueType,
                               pRpcSysInfo->rgbySysName,
                               &dwValueLen
                               );

    if (dwResult isnot NO_ERROR) {

        TRACE1("Couldnt read sysName value. Error %d", dwResult);

        dwValueLen = sizeof(pRpcSysInfo->rgbySysName);

        if (!GetComputerNameA(pRpcSysInfo->rgbySysName, &dwValueLen)) {

            HeapFree(hHeap,
                     dwAllocFlags,
                     pRpcSysInfo);
    
            dwResult = GetLastError();

            TRACE1("Couldnt read computer name. Error %d", dwResult);
            TraceLeave("GetSysInfo");

            return dwResult;
        }
    }

    dwValueLen = sizeof(pRpcSysInfo->rgbySysContact);

    dwResult = RegQueryValueEx(hkeySysInfo,
                               TEXT("sysContact"), 
                               0,
                               &dwValueType,
                               pRpcSysInfo->rgbySysContact,
                               &dwValueLen
                               );

    if (dwResult isnot NO_ERROR) {
        pRpcSysInfo->rgbySysContact[0] = '\0';
    }

    dwValueLen = sizeof(pRpcSysInfo->rgbySysLocation);

    dwResult = RegQueryValueEx(hkeySysInfo,
                               TEXT("sysLocation"), 
                               0,
                               &dwValueType,
                               pRpcSysInfo->rgbySysLocation,
                               &dwValueLen
                               );

    if (dwResult isnot NO_ERROR)
    {
        pRpcSysInfo->rgbySysLocation[0] = '\0';
    }

    RegCloseKey(hkeySysInfo);

    strcpy(&pRpcSysInfo->rgbySysDescr[dwBytes], TEXT("Hardware: "));
    dwBytes += strlen(TEXT("Hardware: "));

    dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                            REG_KEY_CPU,
                            0,
                            KEY_QUERY_VALUE | 
                            KEY_ENUMERATE_SUB_KEYS,
                            &hkeySysInfo);

    if (dwResult is NO_ERROR) {

        dwValueLen = sizeof(pRpcSysInfo->rgbySysDescr) - dwBytes;
        dwResult = RegQueryValueEx(hkeySysInfo,
                                   TEXT("Identifier"), 
                                   0,
                                   &dwValueType,
                                   &pRpcSysInfo->rgbySysDescr[dwBytes],
                                   &dwValueLen);

        if (dwResult is NO_ERROR) {
    
            dwBytes += dwValueLen - 1;
            strcat(&pRpcSysInfo->rgbySysDescr[dwBytes++], TEXT(" "));

        } else {

            strcat(&pRpcSysInfo->rgbySysDescr[dwBytes], TEXT("CPU Unknown "));
            dwBytes += strlen(TEXT("CPU Unknown "));
        }

        RegCloseKey(hkeySysInfo);
    
    } else {

        strcat(&pRpcSysInfo->rgbySysDescr[dwBytes], TEXT("CPU Unknown "));
        dwBytes += strlen(TEXT("CPU Unknown "));
    }

    dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            REG_KEY_SYSTEM,
                            0,
                            KEY_QUERY_VALUE | 
                            KEY_ENUMERATE_SUB_KEYS,
                            &hkeySysInfo);

    if (dwResult is NO_ERROR) {

        dwValueLen = sizeof(pRpcSysInfo->rgbySysDescr) - dwBytes;
        dwResult = RegQueryValueEx(hkeySysInfo,
                                   TEXT("Identifier"), 
                                   0,
                                   &dwValueType,
                                   &pRpcSysInfo->rgbySysDescr[dwBytes],
                                   &dwValueLen);

        if (dwResult is NO_ERROR) {

            dwBytes += dwValueLen - 1;
            strcat(&pRpcSysInfo->rgbySysDescr[dwBytes++], TEXT(" "));

        } else {

            strcat(&pRpcSysInfo->rgbySysDescr[dwBytes], TEXT("SystemType Unknown "));
            dwBytes += strlen(TEXT("SystemType Unknown "));
        }

        RegCloseKey(hkeySysInfo);

    } else {
        
        strcat(&pRpcSysInfo->rgbySysDescr[dwBytes], TEXT("SystemType Unknown "));
        dwBytes += strlen(TEXT("SystemType Unknown "));
    }

    strcat(&pRpcSysInfo->rgbySysDescr[dwBytes], TEXT_SOFTWARE_WINDOWS_VERSION);
    dwBytes += strlen(TEXT_SOFTWARE_WINDOWS_VERSION);

    dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                            REG_KEY_VERSION,
                            0,
                            KEY_QUERY_VALUE |
                            KEY_ENUMERATE_SUB_KEYS,
                            &hkeySysInfo);

    if (dwResult is NO_ERROR) {

        dwValueLen = sizeof(pRpcSysInfo->rgbySysDescr) - dwBytes;
        dwResult = RegQueryValueEx(hkeySysInfo,
                                   TEXT("CurrentVersion"), 
                                   0,
                                   &dwValueType,
                                   &pRpcSysInfo->rgbySysDescr[dwBytes],
                                   &dwValueLen);

        if (dwResult is NO_ERROR) {

            dwBytes += dwValueLen - 1;
            strcat(&pRpcSysInfo->rgbySysDescr[dwBytes++], TEXT(" "));

        } else {

            strcat(&pRpcSysInfo->rgbySysDescr[dwBytes], TEXT("Unknown "));
            dwBytes += strlen(TEXT("Unknown "));
        }

        strcat(&pRpcSysInfo->rgbySysDescr[dwBytes], TEXT("(Build "));
        dwBytes += strlen(TEXT("(Build "));

        dwValueLen = sizeof(pRpcSysInfo->rgbySysDescr) - dwBytes;

        dwResult = RegQueryValueEx(hkeySysInfo,
                                   TEXT("CurrentBuildNumber"), 
                                   0,
                                   &dwValueType,
                                   &pRpcSysInfo->rgbySysDescr[dwBytes],
                                   &dwValueLen);

        if (dwResult is NO_ERROR) {

            dwBytes += dwValueLen - 1;
            strcat(&pRpcSysInfo->rgbySysDescr[dwBytes++], TEXT(" "));

        } else {

            strcat(&pRpcSysInfo->rgbySysDescr[dwBytes], TEXT("Unknown "));
            dwBytes += strlen(TEXT("Unknown "));
        }

        dwValueLen = sizeof(pRpcSysInfo->rgbySysDescr) - dwBytes;

        dwResult = RegQueryValueEx(hkeySysInfo,
                                   TEXT("CurrentType"), 
                                   0,
                                   &dwValueType,
                                   &pRpcSysInfo->rgbySysDescr[dwBytes],
                                   &dwValueLen);

        if (dwResult is NO_ERROR) {

            dwBytes += dwValueLen - 1;
            strcat(&pRpcSysInfo->rgbySysDescr[dwBytes++], TEXT(")"));

        } else {

            pRpcSysInfo->rgbySysDescr[dwBytes - 1] = ')';
        }

        RegCloseKey(hkeySysInfo);

    } else {

        strcat(&pRpcSysInfo->rgbySysDescr[dwBytes], TEXT("Unknown"));
        dwBytes += strlen(TEXT("Unknown"));
    }

    *ppRpcSysInfo = pRpcSysInfo;

    TraceLeave("GetSysInfo");
    
    return NO_ERROR;
}

VOID
FreeIpv6IfTable()
{
    if (g_Cache.pRpcIpv6IfTable.table) {
        HeapFree(g_hPrivateHeap,
                 0,
                 g_Cache.pRpcIpv6IfTable.table);
        
        g_Cache.pRpcIpv6IfTable.table = NULL;
        g_Cache.pRpcIpv6IfTable.dwNumEntries = 0;
    }
}

VOID
FreeIpv6AddrTable()
{
    if (g_Cache.pRpcIpv6AddrTable.table) {
        HeapFree(g_hPrivateHeap,
                 0,
                 g_Cache.pRpcIpv6AddrTable.table);
        
        g_Cache.pRpcIpv6AddrTable.table = NULL;
        g_Cache.pRpcIpv6AddrTable.dwNumEntries = 0;
    }
}

VOID
FreeIpv6NetToMediaTable()
{
    if (g_Cache.pRpcIpv6NetToMediaTable.table) {
        HeapFree(g_hPrivateHeap,
                 0,
                 g_Cache.pRpcIpv6NetToMediaTable.table);

        g_Cache.pRpcIpv6NetToMediaTable.table = NULL;
        g_Cache.pRpcIpv6NetToMediaTable.dwNumEntries = 0;
    }
}

VOID
FreeInetIcmpTable()
{
    if (g_Cache.pRpcInetIcmpTable.table) {
        HeapFree(g_hPrivateHeap,
                 0,
                 g_Cache.pRpcInetIcmpTable.table);

        g_Cache.pRpcInetIcmpTable.table = NULL;
        g_Cache.pRpcInetIcmpTable.dwNumEntries = 0;
    }
}

VOID
FreeInetIcmpMsgTable()
{
    if (g_Cache.pRpcInetIcmpMsgTable.table) {
        HeapFree(g_hPrivateHeap,
                 0,
                 g_Cache.pRpcInetIcmpMsgTable.table);

        g_Cache.pRpcInetIcmpMsgTable.table = NULL;
        g_Cache.pRpcInetIcmpMsgTable.dwNumEntries = 0;
    }
}

VOID
FreeIpv6RouteTable()
{
    if (g_Cache.pRpcIpv6RouteTable.table) {
        HeapFree(g_hPrivateHeap,
                 0,
                 g_Cache.pRpcIpv6RouteTable.table);

        g_Cache.pRpcIpv6RouteTable.table = NULL;
        g_Cache.pRpcIpv6RouteTable.dwNumEntries = 0;
    }

    if (g_Cache.pRpcIpv6AddrPrefixTable.table) {
        HeapFree(g_hPrivateHeap,
                 0,
                 g_Cache.pRpcIpv6AddrPrefixTable.table);

        g_Cache.pRpcIpv6AddrPrefixTable.table = NULL;
        g_Cache.pRpcIpv6AddrPrefixTable.dwNumEntries = 0;
    }
}

typedef enum {
    Preferred = 1,
    Deprecated,
    Invalid,
    Inaccessible,
    Unknown
}MIB_ADDR_STATUS;

//
// This array gives the MIB state we report for each internal
// address state.
//
DWORD
MibAddrState[] = { 
    Invalid,    // DAD_STATE_INVALID
    Unknown,    // DAD_STATE_TENTATIVE
    Unknown,    // DAD_STATE_DUPLICATE
    Deprecated, // DAD_STATE_DEPRECATED
    Preferred   // DAD_STATE_PREFERRED
};

int
__cdecl
CompareIpv6IfRow(
    CONST VOID *pvElem1,
    CONST VOID *pvElem2
    )
{
    LONG lResult;
    PMIB_IPV6_IF  pRow1 = (PMIB_IPV6_IF)pvElem1;
    PMIB_IPV6_IF  pRow2 = (PMIB_IPV6_IF)pvElem2;

    return Cmp(pRow1->dwIndex, pRow2->dwIndex, lResult);
}

int
__cdecl
CompareInetIcmpRow(
    CONST VOID *pvElem1,
    CONST VOID *pvElem2
    )
{
    LONG lResult;
    PMIB_INET_ICMP  pRow1 = (PMIB_INET_ICMP)pvElem1;
    PMIB_INET_ICMP  pRow2 = (PMIB_INET_ICMP)pvElem2;

    if(Cmp(pRow1->dwAFType,
           pRow2->dwAFType,
           lResult) isnot 0)
    {
        return lResult;
    }

    return Cmp(pRow1->dwIfIndex, pRow2->dwIfIndex, lResult);
}

int
__cdecl
CompareInetIcmpMsgRow(
    CONST VOID *pvElem1,
    CONST VOID *pvElem2
    )
{
    LONG lResult;
    PMIB_INET_ICMP_MSG  pRow1 = (PMIB_INET_ICMP_MSG)pvElem1;
    PMIB_INET_ICMP_MSG  pRow2 = (PMIB_INET_ICMP_MSG)pvElem2;

    if(Cmp(pRow1->dwAFType,
           pRow2->dwAFType,
           lResult) isnot 0)
    {
        return lResult;
    }

    if(Cmp(pRow1->dwIfIndex,
           pRow2->dwIfIndex,
           lResult) isnot 0)
    {
        return lResult;
    }

    if(Cmp(pRow1->dwType,
           pRow2->dwType,
           lResult) isnot 0)
    {
        return lResult;
    }

    return Cmp(pRow1->dwCode, pRow2->dwCode, lResult);
}

int
__cdecl
CompareIpv6AddrRow(
    CONST VOID *pvElem1,
    CONST VOID *pvElem2
    )
{
    LONG lResult;
    PMIB_IPV6_ADDR  pRow1 = (PMIB_IPV6_ADDR)pvElem1;
    PMIB_IPV6_ADDR  pRow2 = (PMIB_IPV6_ADDR)pvElem2;

    if(Cmp(pRow1->dwIfIndex,
           pRow2->dwIfIndex,
           lResult) isnot 0)
    {
        return lResult;
    }

    return memcmp(&pRow1->ipAddress,
                  &pRow2->ipAddress,
                  sizeof(IN6_ADDR));
}

int
__cdecl
CompareIpv6NetToMediaRow(
    CONST VOID *pvElem1,
    CONST VOID *pvElem2
    )
{
    LONG lResult;
    PMIB_IPV6_NET_TO_MEDIA  pRow1 = (PMIB_IPV6_NET_TO_MEDIA)pvElem1;
    PMIB_IPV6_NET_TO_MEDIA  pRow2 = (PMIB_IPV6_NET_TO_MEDIA)pvElem2;

    if(Cmp(pRow1->dwIfIndex,
           pRow2->dwIfIndex,
           lResult) isnot 0)
    {
        return lResult;
    }

    return memcmp(&pRow1->ipAddress,
                  &pRow2->ipAddress,
                  sizeof(IN6_ADDR));
}

int
__cdecl
CompareIpv6RouteRow(
    CONST VOID *pvElem1,
    CONST VOID *pvElem2
    )
{
    LONG lResult;
    PMIB_IPV6_ROUTE  pRow1 = (PMIB_IPV6_ROUTE)pvElem1;
    PMIB_IPV6_ROUTE  pRow2 = (PMIB_IPV6_ROUTE)pvElem2;

    lResult = memcmp(&pRow1->ipPrefix,
                     &pRow2->ipPrefix,
                     sizeof(IN6_ADDR));
    if (lResult isnot 0) 
    {
        return lResult;
    }

    if(Cmp(pRow1->dwPrefixLength,
           pRow2->dwPrefixLength,
           lResult) isnot 0)
    {
        return lResult;
    }

    return Cmp(pRow1->dwIndex,
               pRow2->dwIndex,
               lResult);
}

int
__cdecl
CompareIpv6AddrPrefixRow(
    CONST VOID *pvElem1,
    CONST VOID *pvElem2
    )
{
    LONG lResult;
    PMIB_IPV6_ADDR_PREFIX  pRow1 = (PMIB_IPV6_ADDR_PREFIX)pvElem1;
    PMIB_IPV6_ADDR_PREFIX  pRow2 = (PMIB_IPV6_ADDR_PREFIX)pvElem2;

    if(Cmp(pRow1->dwIfIndex,
           pRow2->dwIfIndex,
           lResult) isnot 0)
    {
        return lResult;
    }

    lResult = memcmp(&pRow1->ipPrefix,
                     &pRow2->ipPrefix,
                     sizeof(IN6_ADDR));
    if (lResult isnot 0)
    {
        return lResult;
    }

    return Cmp(pRow1->dwPrefixLength,
               pRow2->dwPrefixLength,
               lResult);
}

DWORD
LoadIpv6IfTable()
{
    DWORD   dwResult, dwOutBufLen = 0;
    DWORD   dwIfCount, dwAddrCount, i;
    PIP_ADAPTER_ADDRESSES pFirstIf, pIf;
    PIP_ADAPTER_UNICAST_ADDRESS pUni;
    PIP_ADAPTER_ANYCAST_ADDRESS pAny;
    PMIB_IPV6_ADDR pAddr;
    PMIB_IPV6_IF   pMibIf;
    
    TraceEnter("LoadIpv6IfTable");
    
    FreeIpv6IfTable();
    FreeIpv6AddrTable();
    
    dwResult = GetAdaptersAddresses(AF_INET6, 
                                    GAA_FLAG_SKIP_MULTICAST | GAA_FLAG_SKIP_DNS_SERVER,
                                    NULL, NULL, &dwOutBufLen);
    if (dwResult == ERROR_NO_DATA) {
        return NO_ERROR;
    }
    
    pFirstIf = HeapAlloc(g_hPrivateHeap, 0, dwOutBufLen);
    if(pFirstIf == NULL) 
    {
        TraceLeave("LoadIpv6IfTable");
        return GetLastError();
    }

    dwResult = GetAdaptersAddresses(AF_INET6, 
                                    GAA_FLAG_SKIP_MULTICAST | GAA_FLAG_SKIP_DNS_SERVER,
                                    NULL, pFirstIf, &dwOutBufLen);

    if(dwResult isnot NO_ERROR)
    {
        TRACE1("GetIpv6IfTable failed with error %x",
               dwResult);
        goto Cleanup;
    }
    dwAddrCount = dwIfCount = 0;
    for (pIf=pFirstIf; pIf; pIf=pIf->Next) {
        dwIfCount++;
        for (pUni=pIf->FirstUnicastAddress; pUni; pUni=pUni->Next) {
            dwAddrCount++;
        }
        for (pAny=pIf->FirstAnycastAddress; pAny; pAny=pAny->Next) {
            dwAddrCount++;
        }
    }

    //
    // Create the interface table
    //
    g_Cache.pRpcIpv6IfTable.table = HeapAlloc(g_hPrivateHeap, 0, dwIfCount * sizeof(MIB_IPV6_IF));
    if (!g_Cache.pRpcIpv6IfTable.table) {
        TraceLeave("LoadIpv6IfTable");
        dwResult = GetLastError();
        goto Cleanup;
    }
    for (pIf=pFirstIf; pIf; pIf=pIf->Next) {
        i = g_Cache.pRpcIpv6IfTable.dwNumEntries++;
        pMibIf = &g_Cache.pRpcIpv6IfTable.table[i]; 
        pMibIf->dwIndex = pIf->Ipv6IfIndex;
        pMibIf->dwEffectiveMtu = pIf->Mtu;
        pMibIf->dwReasmMaxSize = 65535;
        pMibIf->dwAdminStatus = 1; /* up */
        pMibIf->dwOperStatus = pIf->OperStatus;
        pMibIf->dwLastChange = 0;
        pMibIf->dwPhysicalAddressLength = pIf->PhysicalAddressLength;
        memcpy(pMibIf->bPhysicalAddress, pIf->PhysicalAddress, 
               pIf->PhysicalAddressLength);
        wcscpy(pMibIf->wszDescription, pIf->Description);
    }
    qsort(g_Cache.pRpcIpv6IfTable.table,
          dwIfCount,
          sizeof(MIB_IPV6_IF),
          CompareIpv6IfRow);

    //
    // Create the address table
    //
    g_Cache.pRpcIpv6AddrTable.table = HeapAlloc(g_hPrivateHeap, 0, dwAddrCount * sizeof(MIB_IPV6_ADDR));
    if (!g_Cache.pRpcIpv6AddrTable.table) {
        dwResult = GetLastError();
        goto Cleanup;
    }
    for (pIf=pFirstIf; pIf; pIf=pIf->Next) {
        for (pUni=pIf->FirstUnicastAddress; pUni; pUni=pUni->Next) {
            i = g_Cache.pRpcIpv6AddrTable.dwNumEntries++;
            pAddr = &g_Cache.pRpcIpv6AddrTable.table[i]; 
            pAddr->dwIfIndex = pIf->Ipv6IfIndex;
            pAddr->ipAddress = ((LPSOCKADDR_IN6)pUni->Address.lpSockaddr)->sin6_addr;
            pAddr->dwPrefixLength = 64;
            pAddr->dwType = 1;
            pAddr->dwAnycastFlag = 2;
            pAddr->dwStatus = (pIf->OperStatus == IfOperStatusUp)
                ? MibAddrState[pUni->DadState]
                : Inaccessible;
        }
        for (pAny=pIf->FirstAnycastAddress; pAny; pAny=pAny->Next) {
            i = g_Cache.pRpcIpv6AddrTable.dwNumEntries++;
            pAddr = &g_Cache.pRpcIpv6AddrTable.table[i]; 
            pAddr->dwIfIndex = pIf->Ipv6IfIndex;
            pAddr->ipAddress = ((LPSOCKADDR_IN6)pAny->Address.lpSockaddr)->sin6_addr;
            pAddr->dwPrefixLength = 64;
            pAddr->dwType = 1;
            pAddr->dwAnycastFlag = 1;
            pAddr->dwStatus = 1;
        }
    }
    qsort(g_Cache.pRpcIpv6AddrTable.table,
          dwAddrCount,
          sizeof(MIB_IPV6_ADDR),
          CompareIpv6AddrRow);

Cleanup:
    HeapFree(g_hPrivateHeap, 0, pFirstIf);
    
    TraceLeave("LoadIpv6IfTable");
    
    return dwResult;
}

//
// This array gives the ICMP message type value for each field
// in the ICMPStats structure (in ipinfo.h) and MIBICMPSTATS
// structure (in iprtrmib.h), which are identical.  A value of
// -1 means that the field does not count messages for a specific
// type value.
//
DWORD
Ipv4IcmpFieldMsg[] = {
   -1, // dwMsgs
   -1, // dwErrors
    3, // dwDestUnreachs
   11, // dwTimeExcds
   12, // dwParmProbs
    4, // dwSrcQuenchs
    5, // dwRedirects
    8, // dwEchos
    0, // dwEchoReps
   13, // dwTimestamps
   14, // dwTimestampReps
   17, // dwAddrMasks
   18, // dwAddrMaskReps
};

DWORD
LoadInetIcmpTable()
{
    PMIB_INET_ICMP     pRow;
    PMIB_INET_ICMP_MSG pMsg;
    MIB_ICMP           Icmp4;
    ICMPv6SNMPInfo     Icmp6;
    DWORD   dwResult4, dwResult6, dwResult = NO_ERROR;
    DWORD   i, j, k, dwRowCount = 0, dwMsgCount = 0;
    
    TraceEnter("LoadInetIcmpTable");
    
    FreeInetIcmpTable();
    FreeInetIcmpMsgTable();

    dwResult4 = GetIcmpStatistics(&Icmp4);
    if (dwResult4 == NO_ERROR) {
        dwRowCount++;

        for (j=0; j<sizeof(MIBICMPSTATS)/sizeof(DWORD); j++) {
            if (Ipv4IcmpFieldMsg[j] == -1) {
                continue;
            }
            if ((((DWORD*)&Icmp4.stats.icmpInStats)[j] > 0) ||
                (((DWORD*)&Icmp4.stats.icmpOutStats)[j] > 0)) {
                dwMsgCount++;
            }
        }
    }

    dwResult6 = GetIcmpStatsFromStackEx((PVOID)&Icmp6, AF_INET6);
    if (dwResult6 == NO_ERROR) {
        dwRowCount++;

        for (k=0; k<256; k++) {
            if ((Icmp6.icsi_instats.icmps_typecount[k] > 0) ||
                (Icmp6.icsi_outstats.icmps_typecount[k] > 0)) {
                dwMsgCount++;
            }
        }
    }
    
    //
    // Create the ICMP table
    //
    g_Cache.pRpcInetIcmpTable.table = HeapAlloc(g_hPrivateHeap, 0, 
                                            dwRowCount * sizeof(MIB_INET_ICMP));
    if (!g_Cache.pRpcInetIcmpTable.table) {
        TraceLeave("LoadInetIcmpTable");
        dwResult = GetLastError();
        goto Cleanup;
    }
    if (dwResult4 == NO_ERROR) {
        i = g_Cache.pRpcInetIcmpTable.dwNumEntries++;
        pRow = &g_Cache.pRpcInetIcmpTable.table[i]; 
        pRow->dwAFType = 1; // IPv4
        pRow->dwIfIndex = 0; // global
        pRow->dwInMsgs = Icmp4.stats.icmpInStats.dwMsgs;
        pRow->dwInErrors = Icmp4.stats.icmpInStats.dwErrors;
        pRow->dwOutMsgs = Icmp4.stats.icmpOutStats.dwMsgs;
        pRow->dwOutErrors = Icmp4.stats.icmpOutStats.dwErrors;
    }
    if (dwResult6 == NO_ERROR) {
        i = g_Cache.pRpcInetIcmpTable.dwNumEntries++;
        pRow = &g_Cache.pRpcInetIcmpTable.table[i]; 
        pRow->dwAFType = 2; // IPv6
        pRow->dwIfIndex = 0; // global
        pRow->dwInMsgs = Icmp6.icsi_instats.icmps_msgs;
        pRow->dwInErrors = Icmp6.icsi_instats.icmps_errors;
        pRow->dwOutMsgs = Icmp6.icsi_outstats.icmps_msgs;
        pRow->dwOutErrors = Icmp6.icsi_outstats.icmps_errors;
    }
    qsort(g_Cache.pRpcInetIcmpTable.table,
          dwRowCount,
          sizeof(MIB_INET_ICMP),
          CompareInetIcmpRow);

    //
    // Create the ICMP message table
    //
    g_Cache.pRpcInetIcmpMsgTable.table = HeapAlloc(g_hPrivateHeap, 0, 
                                        dwMsgCount * sizeof(MIB_INET_ICMP_MSG));
    if (!g_Cache.pRpcInetIcmpMsgTable.table) {
        dwResult = GetLastError();
        goto Cleanup;
    }
    if (dwResult4 == NO_ERROR) {
        for (j=0; j<sizeof(MIBICMPSTATS)/sizeof(DWORD); j++) {
            k = Ipv4IcmpFieldMsg[j];
            if (k == -1) {
                continue;
            }
            if ((((DWORD*)&Icmp4.stats.icmpInStats)[j] > 0) ||
                (((DWORD*)&Icmp4.stats.icmpOutStats)[j] > 0)) {
                
                i = g_Cache.pRpcInetIcmpMsgTable.dwNumEntries++;
                pMsg = &g_Cache.pRpcInetIcmpMsgTable.table[i]; 
                pMsg->dwAFType = 1; // IPv4
                pMsg->dwIfIndex = 0; // global
                pMsg->dwType = k;
                pMsg->dwCode = 256; // all codes combined 
                pMsg->dwInPkts = ((DWORD*)&Icmp4.stats.icmpInStats)[j];
                pMsg->dwOutPkts = ((DWORD*)&Icmp4.stats.icmpOutStats)[j];
            }
        }
    }
    if (dwResult6 == NO_ERROR) {
        for (k=0; k<256; k++) {
            if ((Icmp6.icsi_instats.icmps_typecount[k] > 0) ||
                (Icmp6.icsi_outstats.icmps_typecount[k] > 0)) {

                i = g_Cache.pRpcInetIcmpMsgTable.dwNumEntries++;
                pMsg = &g_Cache.pRpcInetIcmpMsgTable.table[i]; 
                pMsg->dwAFType = 2; // IPv6
                pMsg->dwIfIndex = 0; // global
                pMsg->dwType = k;
                pMsg->dwCode = 256; // all codes combined 
                pMsg->dwInPkts = Icmp6.icsi_instats.icmps_typecount[k];
                pMsg->dwOutPkts = Icmp6.icsi_outstats.icmps_typecount[k];
            }
        }
    }
    qsort(g_Cache.pRpcInetIcmpMsgTable.table,
          dwMsgCount,
          sizeof(MIB_INET_ICMP_MSG),
          CompareInetIcmpMsgRow);

Cleanup:
    TraceLeave("LoadInetIcmpTable");
    
    return dwResult;
}

HANDLE g_hIpv6Handle = INVALID_HANDLE_VALUE;

VOID
OpenIpv6()
{
    g_hIpv6Handle = CreateFileW(WIN_IPV6_DEVICE_NAME,
                                0,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,   // security attributes
                                OPEN_EXISTING,
                                0,      // flags & attributes
                                NULL);  // template file
}

DWORD
CountNeighbors(
    IN IPV6_INFO_INTERFACE  *IF, 
    IN PVOID                 Arg)
{
    BYTE    bNceBuffer[sizeof(IPV6_INFO_NEIGHBOR_CACHE) + MAX_LINK_LAYER_ADDRESS_LENGTH];
    IPV6_INFO_NEIGHBOR_CACHE *NCE = (IPV6_INFO_NEIGHBOR_CACHE *)bNceBuffer;
    IPV6_QUERY_NEIGHBOR_CACHE Query, NextQuery;
    DWORD   dwInfoSize, dwBytesReturned;
    DWORD   *pdwCount = (DWORD*)Arg;

    NextQuery.IF = IF->This;
    NextQuery.Address = in6addr_any;
    for (;;) {
        Query = NextQuery;
        dwInfoSize = sizeof *NCE + MAX_LINK_LAYER_ADDRESS_LENGTH;

        if (!DeviceIoControl(g_hIpv6Handle, IOCTL_IPV6_QUERY_NEIGHBOR_CACHE,
                             &Query, sizeof Query,
                             NCE, dwInfoSize, &dwBytesReturned, NULL)) {
            return GetLastError();
        }

        NextQuery = NCE->Query;
        
        if (!IN6_ADDR_EQUAL(&Query.Address, &in6addr_any)) {
            (*pdwCount)++;
        }

        if (IN6_ADDR_EQUAL(&NextQuery.Address, &in6addr_any))
            break;
    }

    return NO_ERROR;
}

typedef enum {
    NtmsReachable = 1,
    NtmsStale,
    NtmsDelay,
    NtmsProbe,
    NtmsInvalid,
    NtmsUnknown
}NET_TO_MEDIA_STATE;

DWORD
NDToMibState[] = {
    NtmsStale, NtmsProbe, NtmsDelay, NtmsStale, NtmsReachable, NtmsReachable
};

typedef enum {
    NtmtOther = 1,
    NtmtDynamic,
    NtmtStatic,
    NtmtLocal
}NET_TO_MEDIA_TYPE;

DWORD
LoadNeighbors(
    IN IPV6_INFO_INTERFACE *IF, 
    IN PVOID                Arg)
{
    BYTE    bNceBuffer[sizeof(IPV6_INFO_NEIGHBOR_CACHE) + MAX_LINK_LAYER_ADDRESS_LENGTH];
    IPV6_INFO_NEIGHBOR_CACHE *NCE = (IPV6_INFO_NEIGHBOR_CACHE *)bNceBuffer;
    IPV6_QUERY_NEIGHBOR_CACHE Query, NextQuery;
    DWORD   dwInfoSize, dwBytesReturned, i;
    PMIB_IPV6_NET_TO_MEDIA pRow;
    DWORD   *pdwCount = (DWORD*)Arg;

    NextQuery.IF = IF->This;
    NextQuery.Address = in6addr_any;
    for (;;) {
        Query = NextQuery;
        dwInfoSize = sizeof *NCE + MAX_LINK_LAYER_ADDRESS_LENGTH;

        if (!DeviceIoControl(g_hIpv6Handle, IOCTL_IPV6_QUERY_NEIGHBOR_CACHE,
                             &Query, sizeof Query,
                             NCE, dwInfoSize, &dwBytesReturned, NULL)) {
            return GetLastError();
        }

        NextQuery = NCE->Query;

        if (!IN6_ADDR_EQUAL(&Query.Address, &in6addr_any)) {
            i = g_Cache.pRpcIpv6NetToMediaTable.dwNumEntries++;
            pRow = &g_Cache.pRpcIpv6NetToMediaTable.table[i]; 
            pRow->dwIfIndex = Query.IF.Index;
            pRow->ipAddress = Query.Address;
            memcpy(pRow->bPhysAddress, NCE+1, NCE->LinkLayerAddressLength);
            pRow->dwPhysAddressLen = NCE->LinkLayerAddressLength;
            if (pRow->dwState == ND_STATE_PERMANENT) {
                pRow->dwType = NtmtStatic;
            } else {
                pRow->dwType = NtmtDynamic;
            }
            pRow->dwState = NDToMibState[NCE->NDState];
            pRow->dwLastUpdated = 0;
            pRow->dwValid = 1;
    
            if (g_Cache.pRpcIpv6NetToMediaTable.dwNumEntries == *pdwCount)
                break;
        }

        if (IN6_ADDR_EQUAL(&NextQuery.Address, &in6addr_any))
            break;
    }

    return NO_ERROR;
}

DWORD
ForEachInterface(
    IN DWORD (*func)(IPV6_INFO_INTERFACE *, PVOID),
    IN PVOID arg)
{
    IPV6_QUERY_INTERFACE Query;
    IPV6_INFO_INTERFACE *IF;
    DWORD InfoSize, BytesReturned, dwResult = NO_ERROR;

    InfoSize = sizeof *IF + 2 * MAX_LINK_LAYER_ADDRESS_LENGTH;
    IF = (IPV6_INFO_INTERFACE *) HeapAlloc(g_hPrivateHeap, 0, InfoSize);
    if (IF == NULL) {
        return GetLastError();
    }

    Query.Index = (u_int) -1;

    for (;;) {
        if (!DeviceIoControl(g_hIpv6Handle, IOCTL_IPV6_QUERY_INTERFACE,
                             &Query, sizeof Query,
                             IF, InfoSize, &BytesReturned,
                             NULL)) {
            dwResult = GetLastError();
            goto Cleanup;
        }

        if (Query.Index != (u_int) -1) {

            if ((BytesReturned < sizeof *IF) ||
                (IF->Length < sizeof *IF) ||
                (BytesReturned != IF->Length +
                 ((IF->LocalLinkLayerAddress != 0) ?
                  IF->LinkLayerAddressLength : 0) +
                 ((IF->RemoteLinkLayerAddress != 0) ?
                  IF->LinkLayerAddressLength : 0))) {

                goto Cleanup;
            }

            dwResult = (*func)(IF, arg);
            if (dwResult != NO_ERROR) {
                return dwResult;
            }
        }

        if (IF->Next.Index == (u_int) -1)
            break;
        Query = IF->Next;
    }

Cleanup:
    HeapFree(g_hPrivateHeap, 0, IF);

    return dwResult;
}

DWORD
ForEachRoute(
    IN DWORD (*func)(IPV6_INFO_ROUTE_TABLE *, PVOID, PVOID), 
    IN PVOID Arg1,
    IN PVOID Arg2)
{
    IPV6_QUERY_ROUTE_TABLE Query, NextQuery;
    IPV6_INFO_ROUTE_TABLE RTE;
    DWORD BytesReturned;

    NextQuery.Neighbor.IF.Index = 0;

    for (;;) {
        Query = NextQuery;

        if (!DeviceIoControl(g_hIpv6Handle, IOCTL_IPV6_QUERY_ROUTE_TABLE,
                             &Query, sizeof Query,
                             &RTE, sizeof RTE, &BytesReturned,
                             NULL)) {
            return GetLastError();
        }

        NextQuery = RTE.Next;

        if (Query.Neighbor.IF.Index != 0) {

            RTE.This = Query;
            (*func)(&RTE, Arg1, Arg2);
        }

        if (NextQuery.Neighbor.IF.Index == 0)
            break;
    }

    return NO_ERROR;
}

DWORD
LoadIpv6NetToMediaTable()
{
    DWORD   dwResult, dwOutBufLen = 0;
    DWORD   dwCount, i;

    TraceEnter("LoadIpv6NetToMediaTable");
    
    FreeIpv6NetToMediaTable();

    OpenIpv6();
    
    //
    // Count entries
    //
    dwCount = 0;
    ForEachInterface(CountNeighbors, &dwCount);
    
    //
    // Create the neighbor table
    //
    g_Cache.pRpcIpv6NetToMediaTable.table = HeapAlloc(g_hPrivateHeap, 0, dwCount * sizeof(MIB_IPV6_NET_TO_MEDIA));
    if (!g_Cache.pRpcIpv6NetToMediaTable.table) {
        TraceLeave("LoadIpv6NetToMediaTable");
        return GetLastError();
    }

    //
    // Load entries
    //
    dwResult = ForEachInterface(LoadNeighbors, &dwCount);

    qsort(g_Cache.pRpcIpv6NetToMediaTable.table,
          g_Cache.pRpcIpv6NetToMediaTable.dwNumEntries,
          sizeof(MIB_IPV6_NET_TO_MEDIA),
          CompareIpv6NetToMediaRow);

    CloseHandle(g_hIpv6Handle);

    TraceLeave("LoadIpv6NetToMediaTable");
    
    return dwResult;
}

DWORD
CountRoute(
    IN IPV6_INFO_ROUTE_TABLE *RTE,
    IN PVOID                  Arg1,
    IN PVOID                  Arg2)
{
    DWORD *pdwRouteCount = (DWORD *)Arg1;
    DWORD *pdwAddrPrefixCount = (DWORD *)Arg2;

    //
    // Suppress system routes (used for loopback).
    //
    if (RTE->Type == RTE_TYPE_SYSTEM) {
        return NO_ERROR;
    }

    (*pdwRouteCount)++;

    if ((RTE->This.PrefixLength > 0)
     && (RTE->This.PrefixLength < 128)) {
        (*pdwAddrPrefixCount)++;
    }

    return NO_ERROR;
}

DWORD
LoadRoute(
    IN IPV6_INFO_ROUTE_TABLE *RTE,
    IN PVOID                  Arg1,
    IN PVOID                  Arg2)
{
    DWORD *pdwRouteCount = (DWORD *)Arg1;
    DWORD *pdwAddrPrefixCount = (DWORD *)Arg2;
    DWORD i;
    PMIB_IPV6_ROUTE pRoute;
    PMIB_IPV6_ADDR_PREFIX pPrefix;

    //
    // Suppress system routes (used for loopback).
    //
    if (RTE->Type == RTE_TYPE_SYSTEM) {
        return NO_ERROR;
    }

    if (g_Cache.pRpcIpv6RouteTable.dwNumEntries < *pdwRouteCount) {

        i = g_Cache.pRpcIpv6RouteTable.dwNumEntries++;
        pRoute = &g_Cache.pRpcIpv6RouteTable.table[i];
        pRoute->ipPrefix = RTE->This.Prefix;
        pRoute->dwPrefixLength = RTE->This.PrefixLength;
        pRoute->ipNextHop = RTE->This.Neighbor.Address;
        pRoute->dwIndex = g_Cache.pRpcIpv6RouteTable.dwNumEntries;
        pRoute->dwIfIndex = RTE->This.Neighbor.IF.Index;
        if (!memcmp(&RTE->This.Neighbor.Address, &in6addr_any, sizeof(IN6_ADDR))) {
            pRoute->dwType = 3; /* Local */
        } else {
            pRoute->dwType = 4; /* Remote */
        }
        pRoute->dwProtocol = RTE->Type;
        pRoute->dwPolicy = 0;
        pRoute->dwAge = 0;
        pRoute->dwNextHopRDI = 0;
        pRoute->dwMetric = RTE->Preference;
        pRoute->dwWeight = 0;
        pRoute->dwValid = 1;
    }

    if ((g_Cache.pRpcIpv6AddrPrefixTable.dwNumEntries < *pdwAddrPrefixCount)
     && (RTE->This.PrefixLength > 0)
     && (RTE->This.PrefixLength < 128)) {

        i = g_Cache.pRpcIpv6AddrPrefixTable.dwNumEntries++;
        pPrefix = &g_Cache.pRpcIpv6AddrPrefixTable.table[i];
        pPrefix->dwIfIndex = RTE->This.Neighbor.IF.Index;
        pPrefix->ipPrefix = RTE->This.Prefix;
        pPrefix->dwPrefixLength = RTE->This.PrefixLength;

        if (!memcmp(&RTE->This.Neighbor.Address, &in6addr_any, sizeof(IN6_ADDR))) {
            pPrefix->dwOnLinkFlag = 1; /* True */
        } else {
            pPrefix->dwOnLinkFlag = 2; /* False */
        }

        //
        // TODO: The stack doesn't currently store this information,
        // so always report True for now.
        //
        pPrefix->dwAutonomousFlag = 1; /* True */

        pPrefix->dwPreferredLifetime = RTE->PreferredLifetime;
        pPrefix->dwValidLifetime = RTE->ValidLifetime;
    }

    return NO_ERROR;
}

DWORD
LoadIpv6RouteTable()
{
    DWORD   dwResult, dwOutBufLen = 0;
    DWORD   dwRouteCount = 0, dwAddrPrefixCount = 0, i;

    TraceEnter("LoadIpv6RouteTable");
    
    FreeIpv6RouteTable();

    OpenIpv6();
    
    //
    // Count entries
    //
    ForEachRoute(CountRoute, &dwRouteCount, &dwAddrPrefixCount);
    
    //
    // Create the tables
    //
    if (dwRouteCount) {
        g_Cache.pRpcIpv6RouteTable.table = HeapAlloc(g_hPrivateHeap, 0, dwRouteCount * sizeof(MIB_IPV6_ROUTE));
        if (!g_Cache.pRpcIpv6RouteTable.table) {
            TraceLeave("LoadIpv6RouteTable");
            return GetLastError();
        }
    }
    if (dwAddrPrefixCount) {
        g_Cache.pRpcIpv6AddrPrefixTable.table = HeapAlloc(g_hPrivateHeap, 0, dwAddrPrefixCount * sizeof(MIB_IPV6_ADDR_PREFIX));
        if (!g_Cache.pRpcIpv6AddrPrefixTable.table) {
            FreeIpv6RouteTable();
            TraceLeave("LoadIpv6RouteTable");
            return GetLastError();
        }
    }

    //
    // Load entries
    //
    dwResult = ForEachRoute(LoadRoute, &dwRouteCount, &dwAddrPrefixCount);

    qsort(g_Cache.pRpcIpv6RouteTable.table,
          g_Cache.pRpcIpv6RouteTable.dwNumEntries,
          sizeof(MIB_IPV6_ROUTE),
          CompareIpv6RouteRow);
    qsort(g_Cache.pRpcIpv6AddrPrefixTable.table,
          g_Cache.pRpcIpv6AddrPrefixTable.dwNumEntries,
          sizeof(MIB_IPV6_ADDR_PREFIX),
          CompareIpv6AddrPrefixRow);

    CloseHandle(g_hIpv6Handle);

    TraceLeave("LoadIpv6RouteTable");
    
    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tools\checkv4\makefile.inc ===
$(O)\msg00001.bin: localmsg.mc
    $(MC) -v -h $(O) -r $(O) localmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\snmp\mibfuncs.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:


Abstract:


Author:


Revision History:

--*/

#include "allinc.h"
#include "oid.h"

//
// Values of InetAddressType.
//
typedef enum {
    INET_ADDRESS_TYPE_UNKNOWN = 0,
    INET_ADDRESS_TYPE_IPv4    = 1,
    INET_ADDRESS_TYPE_IPv6    = 2
} INET_ADDRESS_TYPE;

UINT
MibGetIfNumber(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )               
{
    DWORD           dwResult;
    PIF_NUMBER_GET  pOutput;
    
    TraceEnter("MibGetIfNumber");
    
    dwResult = UpdateCache(MIB_II_IF);
    
    if(dwResult isnot NO_ERROR)
    {
        TRACE1("Couldnt update IF cache. Error %d", dwResult);
        TraceLeave("MibGetIfNumber");
        
        return dwResult;
    }
    
    pOutput = (PIF_NUMBER_GET)objectArray;
    
    EnterReader(MIB_II_IF);
    
    SetAsnInteger(&(pOutput->ifNumber),g_Cache.pRpcIfTable->dwNumEntries);
    
    ReleaseLock(MIB_II_IF);

    TraceLeave("MibGetIfNumber");
    
    return MIB_S_SUCCESS;
}

UINT
MibGetIfEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )
{
    DWORD          dwResult;
    PMIB_IFROW     pRpcIf;
    PIF_ENTRY_GET  pOutput;
    
    TraceEnter("MibGetIfEntry");
    
    dwResult = UpdateCache(MIB_II_IF);
    
    if(dwResult isnot NO_ERROR)
    {
        TRACE1("Couldnt update IF cache. Error %d",dwResult);
        TraceLeave("MibGetIfEntry");

        return dwResult;
    }
    
    pOutput = (PIF_ENTRY_GET)objectArray;
    
    EnterReader(MIB_II_IF);
    
    pRpcIf = LocateIfRow(actionId,
                         &(pOutput->ifIndex));
                         
    
    if(pRpcIf is NULL)
    {
        ReleaseLock(MIB_II_IF);

        TRACE2("Unable to locate IF Row. Action is %d. Index is %d",
               actionId,
               GetAsnInteger(&(pOutput->ifIndex),-1));

        TraceLeave("MibGetIfEntry");

        if(actionId is MIB_ACTION_GETNEXT)
        {
            return MIB_S_NO_MORE_ENTRIES;
        }

        return MIB_S_ENTRY_NOT_FOUND;
    }
    
    ForceSetAsnInteger(&(pOutput->ifIndex),pRpcIf->dwIndex);
    
//    SetAsnDispString(&(pOutput->ifDescr),
    SetAsnOctetString(&(pOutput->ifDescr),
                      pOutput->rgbyIfDescrInfo,
                      pRpcIf->bDescr,
                      min(pRpcIf->dwDescrLen,MAX_IF_DESCR_LEN));
    
    SetAsnInteger(&(pOutput->ifType),pRpcIf->dwType);
    SetAsnInteger(&(pOutput->ifMtu),pRpcIf->dwMtu);
    SetAsnGauge(&(pOutput->ifSpeed),pRpcIf->dwSpeed);

    SetAsnOctetString(&(pOutput->ifPhysAddress),
                      pOutput->rgbyIfPhysAddressInfo,
                      pRpcIf->bPhysAddr,
                      pRpcIf->dwPhysAddrLen);

    /*if(!IsAsnTypeNull(&(pOutput->ifPhysAddress)))
      {
      pOutput->ifPhysAddress.asnValue.string.length = pRpcIf->dwPhysAddrLen;
      pOutput->ifPhysAddress.asnValue.string.stream = pOutput->rgbyIfPhysAddressInfo;
      CopyMemory(pOutput->rgbyIfPhysAddressInfo,
      pRpcIf->rgbyPhysAddr,
      pRpcIf->dwPhysAddrLen);
      }*/

    SetAsnInteger(&(pOutput->ifAdminStatus), pRpcIf->dwAdminStatus);
    SetAsnInteger(&(pOutput->ifOperStatus), pRpcIf->dwOperStatus);
    SetAsnTimeTicks(&(pOutput->ifLastChange), SnmpSvcGetUptimeFromTime(pRpcIf->dwLastChange));
    SetAsnCounter(&(pOutput->ifInOctets), pRpcIf->dwInOctets);
    SetAsnCounter(&(pOutput->ifInUcastPkts), pRpcIf->dwInUcastPkts);
    SetAsnCounter(&(pOutput->ifInNUcastPkts), pRpcIf->dwInNUcastPkts);
    SetAsnCounter(&(pOutput->ifInDiscards), pRpcIf->dwInDiscards);
    SetAsnCounter(&(pOutput->ifInErrors), pRpcIf->dwInErrors);
    SetAsnCounter(&(pOutput->ifInUnknownProtos), pRpcIf->dwInUnknownProtos);
    SetAsnCounter(&(pOutput->ifOutOctets), pRpcIf->dwOutOctets);
    SetAsnCounter(&(pOutput->ifOutUcastPkts), pRpcIf->dwOutUcastPkts);
    SetAsnCounter(&(pOutput->ifOutNUcastPkts), pRpcIf->dwOutNUcastPkts);
    SetAsnCounter(&(pOutput->ifOutDiscards), pRpcIf->dwOutDiscards);
    SetAsnCounter(&(pOutput->ifOutErrors), pRpcIf->dwOutErrors);
    SetAsnGauge(&(pOutput->ifOutQLen), pRpcIf->dwOutQLen);

    SetToZeroOid(&(pOutput->ifSpecific));
    
    ReleaseLock(MIB_II_IF);
    
    TraceLeave("MibGetIfEntry");

    return MIB_S_SUCCESS;
}

UINT
MibSetIfEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )
{
    DWORD            dwResult,dwStatus;
    PMIB_IFROW       pRpcIf;
    PIF_ENTRY_SET    pInput;
    PMIB_OPAQUE_INFO pInfo;
    PMIB_IFROW       pSetRow;

    pInput  = (PIF_ENTRY_SET)objectArray;
    pInfo   = (PMIB_OPAQUE_INFO)(pInput->rgdwSetBuffer);
    pSetRow = (PMIB_IFROW)(pInfo->rgbyData);
   
    switch(actionId)
    {
        case MIB_ACTION_VALIDATE:
        {
            TraceEnter("MibSetIfEntry - VALIDATE");

            ASSERT(!(IsAsnTypeNull(&(pInput->ifIndex)) or
                     IsAsnTypeNull(&(pInput->ifAdminStatus))));

            pInput->bLocked = FALSE;

            dwStatus = GetAsnInteger(&(pInput->ifAdminStatus), 0);

            if((dwStatus isnot IF_ADMIN_STATUS_UP) and
               (dwStatus isnot IF_ADMIN_STATUS_DOWN))
            {   
                TRACE0("Status must be UP or DOWN");
                TraceLeave("MibSetIfEntry");

                return MIB_S_INVALID_PARAMETER;
            }
            
            dwResult = UpdateCache(MIB_II_IF);
            
            if(dwResult isnot NO_ERROR)
            {
                TRACE1("Couldnt update IF cache. Error %d",dwResult);
                TraceLeave("MibSetIfEntry");

                return dwResult;
            }

            pInfo->dwId = IF_ROW;

            //
            // We take the lock here and then release it in the cleanup
            // This ensures that things dont change between the two calls
            //
            
            EnterWriter(MIB_II_IF);
   
            pInput->bLocked = TRUE;
 
            pRpcIf = LocateIfRow(GET_EXACT,
                                 &(pInput->ifIndex));
                         
    
            if(pRpcIf is NULL)  
            {
                ReleaseLock(MIB_II_IF);

                pInput->bLocked = FALSE;

                TRACE1("Unable to locate IF Row. Index is %d",
                       GetAsnInteger(&(pInput->ifIndex),-1));

                TraceLeave("MibSetIfEntry");
               
                return MIB_S_ENTRY_NOT_FOUND;
            }   

            if(pRpcIf->dwAdminStatus is dwStatus)
            {
                //
                // Since the types are same, this is a NOP. 
                // 
                
                pInput->raAction = NOP;

                TraceLeave("MibSetIfEntry - SET");
                
                return MIB_S_SUCCESS;
            }

            pInput->raAction = SET_ROW;
            
            pSetRow->dwIndex = pRpcIf->dwIndex;
            pSetRow->dwAdminStatus = dwStatus;

            TraceLeave("MibSetIfEntry - SET");

            return MIB_S_SUCCESS;
        }
        case MIB_ACTION_SET:
        {
            TraceEnter("MibSetIfEntry - SET");
            
            dwResult = NO_ERROR;

            if(pInput->raAction is SET_ROW)
            {
                dwResult = InternalSetIfEntry(pInfo);

#ifdef MIB_DEBUG
                
                if(dwResult isnot NO_ERROR)
                {
                    TRACE1("Set failed!!. Error %d",
                           dwResult);
                }
                
#endif
                InvalidateCache(MIB_II_IF);
            }

            TraceLeave("MibSetIfEntry");

            return dwResult;
        }
        case MIB_ACTION_CLEANUP:
        {
            if(pInput->bLocked)
            {
                ReleaseLock(MIB_II_IF);
            }

            TraceEnter("MibSetIfEntry - CLEANUP");
            TraceLeave("MibSetIfEntry");

            return MIB_S_SUCCESS;
        }
        default:
        {
            TraceEnter("MibSetIfEntry - WRONG ACTION");
            TraceLeave("MibSetIfEntry");

            return MIB_S_INVALID_PARAMETER;
        }       
    }
}



UINT           
MibGetIpGroup(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )
{
    DWORD           dwResult;
    PIP_STATS_GET   pOutput;
    MIB_IPSTATS     rpcIpStats;
    
    TraceEnter("MibGetIpGroup");

    dwResult = GetIpStatistics(&rpcIpStats);
    
    if(dwResult isnot NO_ERROR)
    {
        TRACE1("Couldnt get IP stats. Error %d",dwResult);

        TraceLeave("MibGetIpGroup");

        return dwResult;
    }

    pOutput = (PIP_STATS_GET)objectArray;

    SetAsnInteger(&(pOutput->ipForwarding), rpcIpStats.dwForwarding);
    SetAsnInteger(&(pOutput->ipDefaultTTL), rpcIpStats.dwDefaultTTL);
    SetAsnCounter(&(pOutput->ipInReceives), rpcIpStats.dwInReceives);
    SetAsnCounter(&(pOutput->ipInHdrErrors), rpcIpStats.dwInHdrErrors);
    SetAsnCounter(&(pOutput->ipInAddrErrors), rpcIpStats.dwInAddrErrors);
    SetAsnCounter(&(pOutput->ipForwDatagrams), rpcIpStats.dwForwDatagrams);
    SetAsnCounter(&(pOutput->ipInUnknownProtos), rpcIpStats.dwInUnknownProtos);
    SetAsnCounter(&(pOutput->ipInDiscards), rpcIpStats.dwInDiscards);
    SetAsnCounter(&(pOutput->ipInDelivers), rpcIpStats.dwInDelivers);
    SetAsnCounter(&(pOutput->ipOutRequests), rpcIpStats.dwOutRequests);
    SetAsnCounter(&(pOutput->ipOutDiscards), rpcIpStats.dwOutDiscards);
    SetAsnCounter(&(pOutput->ipOutNoRoutes), rpcIpStats.dwOutNoRoutes);
    SetAsnInteger(&(pOutput->ipReasmTimeout), rpcIpStats.dwReasmTimeout);
    SetAsnCounter(&(pOutput->ipReasmReqds), rpcIpStats.dwReasmReqds);
    SetAsnCounter(&(pOutput->ipReasmOKs), rpcIpStats.dwReasmOks);
    SetAsnCounter(&(pOutput->ipReasmFails), rpcIpStats.dwReasmFails);
    SetAsnCounter(&(pOutput->ipFragOKs), rpcIpStats.dwFragOks);
    SetAsnCounter(&(pOutput->ipFragFails), rpcIpStats.dwFragFails);
    SetAsnCounter(&(pOutput->ipFragCreates), rpcIpStats.dwFragCreates);
    SetAsnCounter(&(pOutput->ipRoutingDiscards), rpcIpStats.dwRoutingDiscards);

    TraceLeave("MibGetIpGroup");

    return MIB_S_SUCCESS;
}

UINT
MibSetIpGroup(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )
{
    MIB_IPSTATS      rpcIpStats;
    DWORD            dwResult,dwTTL,dwForw;
    PIP_STATS_SET    pInput;
    PMIB_OPAQUE_INFO pInfo;
    PMIB_IPSTATS     pSetStats;

    pInput    = (PIP_STATS_SET)objectArray;
    pInfo     = (PMIB_OPAQUE_INFO)(pInput->rgdwSetBuffer);
    pSetStats = (PMIB_IPSTATS)(pInfo->rgbyData);
    
    switch(actionId)
    {
        case MIB_ACTION_VALIDATE:
        {   
            TraceEnter("MibSetIpGroup- VALIDATE");

            if(IsAsnTypeNull(&(pInput->ipDefaultTTL)) and
               IsAsnTypeNull(&(pInput->ipForwarding)))
            {
                TRACE0("Can only set TTL and Forwarding");
                TraceLeave("MibSetIpGroup");
                
                return MIB_S_INVALID_PARAMETER;
            }

            dwResult = GetIpStatistics(&rpcIpStats);
            
            if(dwResult isnot NO_ERROR)
            {
                TRACE1("Couldnt get IP stats. Error %d",dwResult);
                TraceLeave("MibSetIpGroup");
                
                return dwResult;
            }

            pInfo->dwId = IP_STATS;

            dwTTL  = GetAsnInteger(&(pInput->ipDefaultTTL), rpcIpStats.dwDefaultTTL);
            dwForw = GetAsnInteger(&(pInput->ipForwarding), rpcIpStats.dwForwarding);
            
            //
            // Per RFC 2011, the valid range is [1..255].
            //
            if((dwTTL < 1) || (dwTTL > 255))
            {
                TRACE0("TTL must be in the range [1..255]");
                TraceLeave("MibSetIpGroup");
                
                return MIB_S_INVALID_PARAMETER;
            }
            
            if((dwForw isnot MIB_IP_FORWARDING) and
               (dwForw isnot MIB_IP_NOT_FORWARDING))
            {
                TRACE0("Forwarding value wrong");
                TraceLeave("MibSetIpGroup");
                
                return MIB_S_INVALID_PARAMETER;
            }

            pSetStats->dwForwarding = dwForw;
            pSetStats->dwDefaultTTL = dwTTL;

            TraceLeave("MibSetIpGroup");
            
            return MIB_S_SUCCESS;
        }
        case MIB_ACTION_SET:
        {
            TraceEnter("MibSetIpGroup - SET");

            dwResult = InternalSetIpStats(pInfo);

#ifdef MIB_DEBUG
            if(dwResult isnot NO_ERROR)
            {
                TRACE1("Set returned error %d!!",dwResult);
            }
#endif
            TraceLeave("MibSetIpGroup");
            
            return dwResult;
        }
        case MIB_ACTION_CLEANUP:
        {
            TraceEnter("MibSetIpGroup - CLEANUP");
            TraceLeave("MibSetIpGroup");

            return MIB_S_SUCCESS;
        }
        default:
        {
            TraceEnter("MibSetIpGroup - WRONG ACTION");
            TraceLeave("MibSetIpGroup");

            return MIB_S_INVALID_PARAMETER;
        }
    }
}

UINT
MibGetIpAddressEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )
{
    PMIB_IPADDRROW         pRpcIpAddr;
    DWORD                   dwResult;
    PIP_ADDRESS_ENTRY_GET   pOutput;
    
    TraceEnter("MibGetIpAddressEntry");
    
    dwResult = UpdateCache(MIB_II_IPADDR);
    
    if(dwResult isnot NO_ERROR)
    {
        TRACE1("Couldnt update IP Addr cache. Error %d", dwResult);
        TraceLeave("MibGetIpAddressEntry");

        return dwResult;
    }
    
    pOutput = (PIP_ADDRESS_ENTRY_GET)objectArray;
    
    EnterReader(MIB_II_IPADDR);
    
    pRpcIpAddr = LocateIpAddrRow(actionId,
                                 &(pOutput->ipAdEntAddr));
                                 
    
    if(pRpcIpAddr is NULL)
    {
        ReleaseLock(MIB_II_IPADDR);
        
        TRACE2("Unable to locate IP Addr Row. Action is %d, Address is %x",
               actionId,
               GetAsnIPAddress(&(pOutput->ipAdEntAddr),0xffffffff));

        TraceLeave("MibGetIpAddressEntry");

        if(actionId is MIB_ACTION_GETNEXT)
        {
            return MIB_S_NO_MORE_ENTRIES;
        }

        return MIB_S_ENTRY_NOT_FOUND;
    }
    
    
    ForceSetAsnIPAddress(&(pOutput->ipAdEntAddr),
                         &(pOutput->dwIpAdEntAddrInfo),
                         pRpcIpAddr->dwAddr);
    
    SetAsnInteger(&(pOutput->ipAdEntIfIndex), pRpcIpAddr->dwIndex);
    
    SetAsnIPAddress(&(pOutput->ipAdEntNetMask),
                    &(pOutput->dwIpAdEntNetMaskInfo),
                    pRpcIpAddr->dwMask);
    
    SetAsnInteger(&(pOutput->ipAdEntBcastAddr), pRpcIpAddr->dwBCastAddr);
    SetAsnInteger(&(pOutput->ipAdEntReasmMaxSize), pRpcIpAddr->dwReasmSize);
    
    ReleaseLock(MIB_II_IPADDR);
    
    TraceLeave("MibGetIpAddressEntry");
    
    return MIB_S_SUCCESS;
}


UINT
MibGetIpRouteEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )
{
    DWORD                   dwResult;
    PMIB_IPFORWARDROW      pRpcIpForw;
    PIP_ROUTE_ENTRY_GET     pOutput;
    
    TraceEnter("MibGetIpRouteEntry");
    
    dwResult = UpdateCache(FORWARD_MIB);
    
    if(dwResult isnot NO_ERROR)
    {
        TRACE1("Couldnt update IP Forward cache. Error %d", dwResult);
        TraceLeave("MibGetIpRouteEntry");

        return dwResult;
    }
    
    pOutput = (PIP_ROUTE_ENTRY_GET)objectArray;
    
    EnterReader(FORWARD_MIB);
    
    pRpcIpForw = LocateIpRouteRow(actionId,
                                  &(pOutput->ipRouteDest));
    
    if(pRpcIpForw is NULL)
    {
        ReleaseLock(FORWARD_MIB);
        
        TRACE2("Unable to locate IP ROUTE Row. Action is %d. Dest is %x",
               actionId,
               GetAsnIPAddress(&(pOutput->ipRouteDest),0xffffffff));
        TraceLeave("MibGetIpRouteEntry");

        if(actionId is MIB_ACTION_GETNEXT)
        {
            return MIB_S_NO_MORE_ENTRIES;
        }

        return MIB_S_ENTRY_NOT_FOUND;
    }
    
    ForceSetAsnIPAddress(&(pOutput->ipRouteDest),
                         &(pOutput->dwIpRouteDestInfo),
                         pRpcIpForw->dwForwardDest);
    
    SetAsnInteger(&(pOutput->ipRouteIfIndex), pRpcIpForw->dwForwardIfIndex);
    SetAsnInteger(&(pOutput->ipRouteMetric1), pRpcIpForw->dwForwardMetric1);
    SetAsnInteger(&(pOutput->ipRouteMetric2), pRpcIpForw->dwForwardMetric2);
    SetAsnInteger(&(pOutput->ipRouteMetric3), pRpcIpForw->dwForwardMetric3);
    SetAsnInteger(&(pOutput->ipRouteMetric4), pRpcIpForw->dwForwardMetric4);
    
    SetAsnIPAddress(&(pOutput->ipRouteNextHop),
                    &(pOutput->dwIpRouteNextHopInfo),
                    pRpcIpForw->dwForwardNextHop);
    
    SetAsnInteger(&(pOutput->ipRouteType), pRpcIpForw->dwForwardType);
    SetAsnInteger(&(pOutput->ipRouteProto), pRpcIpForw->dwForwardProto);
    SetAsnInteger(&(pOutput->ipRouteAge), pRpcIpForw->dwForwardAge);
    
    SetAsnIPAddress(&(pOutput->ipRouteMask),
                    &(pOutput->dwIpRouteMaskInfo),
                    pRpcIpForw->dwForwardMask);
    
    SetAsnInteger(&(pOutput->ipRouteMetric5), pRpcIpForw->dwForwardMetric5);
    SetToZeroOid(&(pOutput->ipRouteInfo));
    
    ReleaseLock(FORWARD_MIB);
    
    TraceLeave("MibGetIpRouteEntry");
    
    return MIB_S_SUCCESS;
}

UINT
MibSetIpRouteEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )
{
    DWORD               dwResult,dwType,dwIfIndex,dwNextHop;
    PMIB_IPFORWARDROW   pRpcIpForw;
    PIP_ROUTE_ENTRY_SET pInput;
    PMIB_OPAQUE_INFO    pInfo;
    PMIB_IPFORWARDROW   pSetRow;

    pInput  = (PIP_ROUTE_ENTRY_SET)objectArray;
    pInfo   = (PMIB_OPAQUE_INFO)(pInput->rgdwSetBuffer);
    pSetRow = (PMIB_IPFORWARDROW)(pInfo->rgbyData);
    
    switch(actionId)
    {
        case MIB_ACTION_VALIDATE:
        {
            TraceEnter("MibSetIpRouteEntry - VALIDATE");

            ASSERT(!(IsAsnTypeNull(&(pInput->ipRouteDest))));

            pInput->bLocked = FALSE;

            dwResult = UpdateCache(FORWARD_MIB);
            
            if(dwResult isnot NO_ERROR)
            {
                TRACE1("Couldnt update IP Forward cache. Error %d", dwResult);
                TraceLeave("MibGetIpRouteEntry");

                return dwResult;
            }

            pInfo->dwId = IP_FORWARDROW;
            
            EnterWriter(FORWARD_MIB);    

            pInput->bLocked = TRUE;

            pRpcIpForw = LocateIpRouteRow(GET_EXACT,
                                          &(pInput->ipRouteDest));
    
            if(pRpcIpForw is NULL)
            {
                //
                // So we are creating a row. We need the If index, 
                // the mask, next hop and metric 1.  We will try to 
                // determine If index later if necessary.
                //

                if(IsAsnTypeNull(&(pInput->ipRouteMask)) or
                   IsAsnTypeNull(&(pInput->ipRouteNextHop)) or
                   IsAsnTypeNull(&(pInput->ipRouteMetric1)))
                {
                    ReleaseLock(FORWARD_MIB);

                    pInput->bLocked = FALSE;

                    TRACE0("Not enough information to create a route");

                    TraceLeave("MibSetIpRouteEntry");
                    
                    return MIB_S_INVALID_PARAMETER;
                }

                dwType = GetAsnInteger(&(pInput->ipRouteType),
                                       MIB_IPROUTE_TYPE_OTHER);
                
                if(dwType is MIB_IPROUTE_TYPE_INVALID)
                {
                    //
                    // We couldnt be creating and deleting a row at the 
                    // same time
                    //

                    ReleaseLock(FORWARD_MIB);

                    pInput->bLocked = FALSE;

                    TRACE0("Wrong type");
                    
                    TraceLeave("MibSetIpRouteEntry");
                    
                    return MIB_S_INVALID_PARAMETER;
                }
                
                dwIfIndex = GetAsnInteger(&(pInput->ipRouteIfIndex),0);
                dwNextHop = GetAsnIPAddress(&(pInput->ipRouteNextHop),0x00000000);
                
                if(dwIfIndex is 0) 
                {
                    //
                    // Attempt to determine the correct ifIndex
                    //

                    dwIfIndex = GetIfIndexFromAddr(dwNextHop);
                    
                    if(dwIfIndex is INVALID_IFINDEX) 
                    {
                        //
                        // We couldnt determine the correct ifIndex
                        //

                        ReleaseLock(FORWARD_MIB);

                        pInput->bLocked = FALSE;
                
                        TRACE0("Could not determine ifIndex");
                        
                        TraceLeave("MibSetIpRouteEntry");
                        
                        return MIB_S_INVALID_PARAMETER;
                    }
                }

                pInput->raAction = CREATE_ROW;

                pSetRow->dwForwardType = dwType;
                pSetRow->dwForwardIfIndex = dwIfIndex;
                pSetRow->dwForwardNextHop = dwNextHop;

                pSetRow->dwForwardDest =
                    GetAsnIPAddress(&(pInput->ipRouteDest),0xffffffff);
                
                pSetRow->dwForwardMask =
                    GetAsnIPAddress(&(pInput->ipRouteMask),0x00000000);
                pSetRow->dwForwardPolicy = 0;
                
                pSetRow->dwForwardProto =
                    GetAsnInteger(&(pInput->ipRouteProto),MIB_IPPROTO_NETMGMT);

                //
                // We default to an age of INFINITE
                //
                
                pSetRow->dwForwardAge   =
                    GetAsnInteger(&(pInput->ipRouteAge),INFINITE);
                pSetRow->dwForwardNextHopAS = 0;
                pSetRow->dwForwardMetric1 =
                    GetAsnInteger(&(pInput->ipRouteMetric1),0);
                pSetRow->dwForwardMetric2 =
                    GetAsnInteger(&(pInput->ipRouteMetric2),-1);
                pSetRow->dwForwardMetric3 =
                    GetAsnInteger(&(pInput->ipRouteMetric3),-1);
                pSetRow->dwForwardMetric4 =
                    GetAsnInteger(&(pInput->ipRouteMetric4),-1);
                pSetRow->dwForwardMetric5 =
                    GetAsnInteger(&(pInput->ipRouteMetric5),-1);
                TraceLeave("MibSetIpRouteEntry");
                
                return MIB_S_SUCCESS;
            }
            else
            {
                //
                // Ok so we are only changing some stuff in the route
                //

                dwType = GetAsnInteger(&(pInput->ipRouteType),  
                                       pRpcIpForw->dwForwardType);
                
                if(dwType is MIB_IPROUTE_TYPE_INVALID)
                {
                    //
                    // Deleting a row
                    //
                    
                    pInput->raAction = DELETE_ROW;
                    
                    *pSetRow = *pRpcIpForw;

                    TraceLeave("MibSetIpRouteEntry");

                    return MIB_S_SUCCESS;
                }
                
                pInput->raAction = SET_ROW;

                pSetRow->dwForwardDest = 
                    GetAsnIPAddress(&(pInput->ipRouteDest),
                                    pRpcIpForw->dwForwardDest);
                
                pSetRow->dwForwardMask =
                    GetAsnIPAddress(&(pInput->ipRouteMask),
                                    pRpcIpForw->dwForwardMask);

                pSetRow->dwForwardPolicy = 0;
                
                pSetRow->dwForwardNextHop =
                    GetAsnIPAddress(&(pInput->ipRouteNextHop),
                                    pRpcIpForw->dwForwardNextHop);
                
                pSetRow->dwForwardIfIndex =
                    GetAsnInteger(&(pInput->ipRouteIfIndex),
                                  pRpcIpForw->dwForwardIfIndex);

                //
                // The type gets set by the router manager. But incase 
                // we are writing to the stack we need some kind of valid type
                //
                
                pSetRow->dwForwardType =
                    GetAsnInteger(&(pInput->ipRouteType),
                                  pRpcIpForw->dwForwardType);
                
                pSetRow->dwForwardProto =
                    GetAsnInteger(&(pInput->ipRouteProto),
                                  pRpcIpForw->dwForwardProto);
                
                pSetRow->dwForwardAge   =
                    GetAsnInteger(&(pInput->ipRouteAge),
                                  pRpcIpForw->dwForwardAge);

                pSetRow->dwForwardNextHopAS = 0;

                pSetRow->dwForwardMetric1 =
                    GetAsnInteger(&(pInput->ipRouteMetric1),
                                  pRpcIpForw->dwForwardMetric1);

                pSetRow->dwForwardMetric2 =
                    GetAsnInteger(&(pInput->ipRouteMetric2),
                                  pRpcIpForw->dwForwardMetric2);

                pSetRow->dwForwardMetric3 =
                    GetAsnInteger(&(pInput->ipRouteMetric3),
                                  pRpcIpForw->dwForwardMetric3);

                pSetRow->dwForwardMetric4 =
                    GetAsnInteger(&(pInput->ipRouteMetric4),
                                  pRpcIpForw->dwForwardMetric4);

                pSetRow->dwForwardMetric5 =
                    GetAsnInteger(&(pInput->ipRouteMetric5),
                                  pRpcIpForw->dwForwardMetric5);


                TraceLeave("MibSetIpRouteEntry");
                
                return MIB_S_SUCCESS;
            }
        }
        case MIB_ACTION_SET:
        {
            TraceEnter("MibSetIpRouteEntry - SET");
            
            switch(pInput->raAction)
            {
                case CREATE_ROW:
                {
                    dwResult = InternalCreateIpForwardEntry(pInfo);

#ifdef MIB_DEBUG
                    if(dwResult isnot NO_ERROR)
                    {
                        TRACE1("Create failed with error %d",dwResult);
                    }
#endif
                    InvalidateCache(FORWARD_MIB);
                    
                    TraceLeave("MibSetIpRouteEntry");

                    return dwResult;
                }
                case SET_ROW:
                {
                    dwResult = InternalSetIpForwardEntry(pInfo);

#ifdef MIB_DEBUG
                    if(dwResult isnot NO_ERROR)
                    {
                        TRACE1("MibSet failed with error %d",dwResult);
                    }
#endif
                    InvalidateCache(FORWARD_MIB);
                    
                    TraceLeave("MibSetIpRouteEntry");

                    return dwResult;
                }
                case DELETE_ROW:
                {
                    dwResult = InternalDeleteIpForwardEntry(pInfo);

#ifdef MIB_DEBUG
                    if(dwResult isnot NO_ERROR)
                    {
                        TRACE1("Delete failed with error %d",dwResult);
                    }
#endif

                    InvalidateCache(FORWARD_MIB);

                    TraceLeave("MibSetIpRouteEntry");

                    return dwResult;
                }
                default:
                {
                    TRACE1("Wrong row action %d",pInput->raAction);
                    TraceLeave("MibSetIpRouteEntry");

                    return MIB_S_SUCCESS;
                }
            }
        }
        case MIB_ACTION_CLEANUP:
        {
            TraceEnter("MibSetIpRouteEntry - CLEANUP");
            TraceLeave("MibSetIpRouteEntry");

            if(pInput->bLocked)
            {
                ReleaseLock(FORWARD_MIB);
            }

            return MIB_S_SUCCESS;
        }
        default:
        {
            TraceEnter("MibSetIpRouteEntry - WRONG ACTION");
            TraceLeave("MibSetIpRouteEntry");

            return MIB_S_INVALID_PARAMETER;
        }
    }
}

UINT
MibGetIpNetToMediaEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )
{
    PMIB_IPNETROW               pRpcIpNet;
    DWORD                       dwResult;
    PIP_NET_TO_MEDIA_ENTRY_GET  pOutput;
    
    TraceEnter("MibGetIpNetToMediaEntry");
    
    dwResult = UpdateCache(MIB_II_IPNET);
    
    if(dwResult isnot NO_ERROR)
    {
        TRACE1("Couldnt update IP Net cache. Error %d", dwResult);

        TraceLeave("MibGetIpNetToMediaEntry");

        return dwResult;
    }
    
    pOutput = (PIP_NET_TO_MEDIA_ENTRY_GET)objectArray;
    
    EnterReader(MIB_II_IPNET);
    
    pRpcIpNet = LocateIpNetRow(actionId,
                               &(pOutput->ipNetToMediaIfIndex),
                               &(pOutput->ipNetToMediaNetAddress));
    
    if(pRpcIpNet is NULL)
    {
        ReleaseLock(MIB_II_IPNET);
        
        TRACE3("Unable to locateIP Net Row. Action is %d. IfIndex %d. Address %x",
               actionId,
               GetAsnInteger(&(pOutput->ipNetToMediaIfIndex), -1),
               GetAsnIPAddress(&(pOutput->ipNetToMediaNetAddress),0xffffffff));
        TraceLeave("MibGetIpNetToMediaEntry");

        if(actionId is MIB_ACTION_GETNEXT)
        {
            return MIB_S_NO_MORE_ENTRIES;
        }

        return MIB_S_ENTRY_NOT_FOUND;
    }
    
    ForceSetAsnInteger(&(pOutput->ipNetToMediaIfIndex), pRpcIpNet->dwIndex);
    
    SetAsnOctetString(&(pOutput->ipNetToMediaPhysAddress),
                      pOutput->rgbyIpNetToMediaPhysAddressInfo,
                      pRpcIpNet->bPhysAddr,
                      pRpcIpNet->dwPhysAddrLen);
    
    
    
    ForceSetAsnIPAddress(&(pOutput->ipNetToMediaNetAddress),
                         &(pOutput->dwIpNetToMediaNetAddressInfo),
                         pRpcIpNet->dwAddr);
    
    
    SetAsnInteger(&(pOutput->ipNetToMediaType), pRpcIpNet->dwType);
    
    ReleaseLock(MIB_II_IPNET);
    
    TraceLeave("MibGetIpNetToMediaEntry");
    
    return MIB_S_SUCCESS;
}

UINT
MibSetIpNetToMediaEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )
{
    PMIB_IPNETROW               pRpcIpNet;
    DWORD                       dwResult,dwType;
    PIP_NET_TO_MEDIA_ENTRY_SET  pInput;
    PMIB_OPAQUE_INFO            pInfo;
    PMIB_IPNETROW               pSetRow;

    pInput  = (PIP_NET_TO_MEDIA_ENTRY_SET)objectArray;
    pInfo   = (PMIB_OPAQUE_INFO)(pInput->rgdwSetBuffer);
    pSetRow = (PMIB_IPNETROW)(pInfo->rgbyData);


    switch(actionId)
    {
        case MIB_ACTION_VALIDATE:
        {
            TraceEnter("MibSetIpNetToMediaEntry - VALIDATE");

            ASSERT(!(IsAsnTypeNull(&(pInput->ipNetToMediaIfIndex)) or
                     IsAsnTypeNull(&(pInput->ipNetToMediaNetAddress))));

            pInput->bLocked = FALSE;

            dwResult = UpdateCache(MIB_II_IPNET);
    
            if(dwResult isnot NO_ERROR)
            {
                TRACE1("Couldnt update IP Net cache. Error %d", dwResult);
                TraceLeave("MibSetIpNetToMediaEntry");
                
                return dwResult;
            }

            pInfo->dwId = IP_NETROW;
            
            EnterWriter(MIB_II_IPNET);

            pInput->bLocked = TRUE;
    
            pRpcIpNet = LocateIpNetRow(GET_EXACT,
                                       &(pInput->ipNetToMediaIfIndex),
                                       &(pInput->ipNetToMediaNetAddress));
    
            if(pRpcIpNet is NULL)
            {
                //
                // ok so we are creating an entry. We need to have all 
                // the fields
                //

                if(IsAsnTypeNull(&(pInput->ipNetToMediaPhysAddress)) or
                   IsAsnTypeNull(&(pInput->ipNetToMediaType)))
                {
                    ReleaseLock(MIB_II_IPNET);

                    pInput->bLocked = FALSE;

                    TRACE0("Not enough info to create ARP entry");
                    TraceLeave("MibSetIpNetToMediaEntry");
                    
                    return MIB_S_INVALID_PARAMETER;
                }

                dwType = GetAsnInteger(&(pInput->ipNetToMediaType), 0);

                if((dwType isnot MIB_IPNET_TYPE_DYNAMIC) and
                   (dwType isnot MIB_IPNET_TYPE_STATIC))
                {
                    ReleaseLock(MIB_II_IPNET);

                    pInput->bLocked = FALSE;

                    TRACE1("Type %d is wrong",dwType);
                    TraceLeave("MibSetIpNetToMediaEntry");

                    return MIB_S_INVALID_PARAMETER;
                }

                if(pInput->ipNetToMediaPhysAddress.asnValue.string.length > MAX_PHYS_ADDR_LEN)
                {
                    ReleaseLock(MIB_II_IPNET);

                    pInput->bLocked = FALSE;

                    TRACE1("Length of phys addr (%d) is too large",
                           pInput->ipNetToMediaPhysAddress.asnValue.string.length);
                    
                    TraceLeave("MibSetIpNetToMediaEntry");

                    return MIB_S_INVALID_PARAMETER;
                }

                pInput->raAction = CREATE_ROW;
                
                pSetRow->dwIndex = GetAsnInteger(&(pInput->ipNetToMediaIfIndex),
                                                 0);

                pSetRow->dwPhysAddrLen = 
                    pInput->ipNetToMediaPhysAddress.asnValue.string.length;

                CopyMemory(pSetRow->bPhysAddr,
                           pInput->ipNetToMediaPhysAddress.asnValue.string.stream,
                           pInput->ipNetToMediaPhysAddress.asnValue.string.length);
                
                pSetRow->dwAddr = 
                    GetAsnIPAddress(&(pInput->ipNetToMediaNetAddress),
                                    0xffffffff);

                pSetRow->dwType = dwType;
                
                TraceLeave("MibSetIpNetToMediaEntry");

                return MIB_S_SUCCESS;
                
            }
            else
            {
                //
                // only changing stuff
                //

                dwType = GetAsnInteger(&(pInput->ipNetToMediaType), 
                                       pRpcIpNet->dwType);

                if((dwType < 1) or
                   (dwType > 4))
                {
                    ReleaseLock(MIB_II_IPNET);

                    pInput->bLocked = FALSE;

                    TRACE1("Type %d is wrong",dwType);
                    TraceLeave("MibSetIpNetToMediaEntry");

                    return MIB_S_INVALID_PARAMETER;
                }

                if(dwType is MIB_IPNET_TYPE_INVALID)
                {
                    //
                    // We want to delete stuff
                    //

                    *pSetRow = *pRpcIpNet;
                    pInput->raAction = DELETE_ROW;

                    TraceLeave("MibSetIpNetToMediaEntry");

                    return MIB_S_SUCCESS;
                }

                if(pInput->ipNetToMediaPhysAddress.asnType isnot ASN_NULL)
                {
                    if(pInput->ipNetToMediaPhysAddress.asnValue.string.length > MAX_PHYS_ADDR_LEN)
                    {
                        ReleaseLock(MIB_II_IPNET);

                        pInput->bLocked = FALSE;

                        TRACE1("Length of phys addr (%d) is too large",
                               pInput->ipNetToMediaPhysAddress.asnValue.string.length);
                    
                        TraceLeave("MibSetIpNetToMediaEntry");

                        return MIB_S_INVALID_PARAMETER;
                    }

                    pSetRow->dwPhysAddrLen = pInput->ipNetToMediaPhysAddress.asnValue.string.length;
                
                    CopyMemory(pSetRow->bPhysAddr,
                               pInput->ipNetToMediaPhysAddress.asnValue.string.stream,
                               pInput->ipNetToMediaPhysAddress.asnValue.string.length);
                }
                else
                {
                    pSetRow->dwPhysAddrLen = pRpcIpNet->dwPhysAddrLen;
                    
                    CopyMemory(pSetRow->bPhysAddr,
                               pRpcIpNet->bPhysAddr,
                               pRpcIpNet->dwPhysAddrLen);
                }

                pInput->raAction = SET_ROW;
                
                pSetRow->dwAddr = 
                    GetAsnIPAddress(&(pInput->ipNetToMediaNetAddress),
                                    pRpcIpNet->dwAddr);
                
                pSetRow->dwType = dwType;

                pSetRow->dwIndex = GetAsnInteger(&(pInput->ipNetToMediaIfIndex),0);
                
                TraceLeave("MibSetIpNetToMediaEntry");

                return MIB_S_SUCCESS;
            }
        }
        case MIB_ACTION_SET:
        {
            TraceEnter("MibSetIpNetToMediaEntry- SET");

            switch(pInput->raAction)
            {
                case CREATE_ROW:
                {
                    dwResult = InternalCreateIpNetEntry(pInfo);
#ifdef MIB_DEBUG
                    if(dwResult isnot NO_ERROR)
                    {
                        TRACE1("Create failed with error %d!!",dwResult);
                    }
#endif
                    InvalidateCache(MIB_II_IPNET);

                    TraceLeave("MibSetIpNetToMediaEntry");
                    
                    return dwResult;
                }
                case SET_ROW:
                {
                    dwResult = InternalSetIpNetEntry(pInfo);
#ifdef MIB_DEBUG
                    if(dwResult isnot NO_ERROR)
                    {
                        TRACE1("Create failed with error %d!!",dwResult);
                    }
#endif
                    InvalidateCache(MIB_II_IPNET);
                    
                    TraceLeave("MibSetIpNetToMediaEntry");

                    return dwResult;
                }
                case DELETE_ROW:
                {
                    dwResult = InternalDeleteIpNetEntry(pInfo);
#ifdef MIB_DEBUG
                    if(dwResult isnot NO_ERROR)
                    {
                        TRACE1("Create failed with error %d!!",dwResult);
                    }
#endif
                    InvalidateCache(MIB_II_IPNET);
                    
                    TraceLeave("MibSetIpNetToMediaEntry");

                    return dwResult;
                }
                default:
                {
                    TRACE1("Wrong row action %d",pInput->raAction);
                    TraceLeave("MibSetIpNetToMediaEntry");

                    return MIB_S_SUCCESS;
                }
            }
        }
        case MIB_ACTION_CLEANUP:
        {
            TraceEnter("MibSetIpNetToMediaEntry - CLEANUP");
            TraceLeave("MibSetIpNetToMediaEntry");

            if(pInput->bLocked)
            {
                ReleaseLock(MIB_II_IPNET);
            }

            return MIB_S_SUCCESS;
        }
        default:
        {
            TraceEnter("MibSetIpNetToMediaEntry - WRONG ACTION");
            TraceLeave("MibSetIpNetToMediaEntry");

            return MIB_S_INVALID_PARAMETER;
        }
    }
}
            
UINT
MibGetIcmpGroup(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )
{
    MIB_ICMP        rpcIcmp;
    DWORD           dwResult;
    PICMP_GROUP_GET pOutput;
    
    TraceEnter("MibGetIcmpGroup");
               
    dwResult = GetIcmpStatistics(&rpcIcmp);
    
    if(dwResult isnot NO_ERROR)
    {
        TRACE1("Couldnt get ICMP stats. Error %d",dwResult);
        TraceLeave("MibGetIcmpGroup");

        return dwResult;
    }
    
    pOutput = (PICMP_GROUP_GET)objectArray;
    
    SetAsnCounter(&(pOutput->icmpInMsgs), rpcIcmp.stats.icmpInStats.dwMsgs);
    SetAsnCounter(&(pOutput->icmpInErrors), rpcIcmp.stats.icmpInStats.dwErrors);
    SetAsnCounter(&(pOutput->icmpInDestUnreachs), rpcIcmp.stats.icmpInStats.dwDestUnreachs);
    SetAsnCounter(&(pOutput->icmpInTimeExcds), rpcIcmp.stats.icmpInStats.dwTimeExcds);
    SetAsnCounter(&(pOutput->icmpInParmProbs), rpcIcmp.stats.icmpInStats.dwParmProbs);
    SetAsnCounter(&(pOutput->icmpInSrcQuenchs), rpcIcmp.stats.icmpInStats.dwSrcQuenchs);
    SetAsnCounter(&(pOutput->icmpInRedirects), rpcIcmp.stats.icmpInStats.dwRedirects);
    SetAsnCounter(&(pOutput->icmpInEchos), rpcIcmp.stats.icmpInStats.dwEchos);
    SetAsnCounter(&(pOutput->icmpInEchoReps), rpcIcmp.stats.icmpInStats.dwEchoReps);
    SetAsnCounter(&(pOutput->icmpInTimestamps), rpcIcmp.stats.icmpInStats.dwTimestamps);
    SetAsnCounter(&(pOutput->icmpInTimestampReps), rpcIcmp.stats.icmpInStats.dwTimestampReps);
    SetAsnCounter(&(pOutput->icmpInAddrMasks), rpcIcmp.stats.icmpInStats.dwAddrMasks);
    SetAsnCounter(&(pOutput->icmpInAddrMaskReps), rpcIcmp.stats.icmpInStats.dwAddrMaskReps);
    SetAsnCounter(&(pOutput->icmpOutMsgs), rpcIcmp.stats.icmpOutStats.dwMsgs);
    SetAsnCounter(&(pOutput->icmpOutErrors), rpcIcmp.stats.icmpOutStats.dwErrors);
    SetAsnCounter(&(pOutput->icmpOutDestUnreachs), rpcIcmp.stats.icmpOutStats.dwDestUnreachs);
    SetAsnCounter(&(pOutput->icmpOutTimeExcds), rpcIcmp.stats.icmpOutStats.dwTimeExcds);
    SetAsnCounter(&(pOutput->icmpOutParmProbs), rpcIcmp.stats.icmpOutStats.dwParmProbs);
    SetAsnCounter(&(pOutput->icmpOutSrcQuenchs), rpcIcmp.stats.icmpOutStats.dwSrcQuenchs);
    SetAsnCounter(&(pOutput->icmpOutRedirects), rpcIcmp.stats.icmpOutStats.dwRedirects);
    SetAsnCounter(&(pOutput->icmpOutEchos), rpcIcmp.stats.icmpOutStats.dwEchos);
    SetAsnCounter(&(pOutput->icmpOutEchoReps), rpcIcmp.stats.icmpOutStats.dwEchoReps);
    SetAsnCounter(&(pOutput->icmpOutTimestamps), rpcIcmp.stats.icmpOutStats.dwTimestamps);
    SetAsnCounter(&(pOutput->icmpOutTimestampReps), rpcIcmp.stats.icmpOutStats.dwTimestampReps);
    SetAsnCounter(&(pOutput->icmpOutAddrMasks), rpcIcmp.stats.icmpOutStats.dwAddrMasks);
    SetAsnCounter(&(pOutput->icmpOutAddrMaskReps), rpcIcmp.stats.icmpOutStats.dwAddrMaskReps);
    
    TraceLeave("MibGetIcmpGroup");
    
    return MIB_S_SUCCESS;
}

UINT
MibGetTcpGroup(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )
{
    MIB_TCPSTATS    rpcTcp4, rpcTcp6;
    DWORD           dwResult4, dwResult6;
    PTCP_STATS_GET  pOutput;
    
    TraceEnter("MibGetTcpGroup");
    
    ZeroMemory(&rpcTcp4, sizeof(rpcTcp4));
    ZeroMemory(&rpcTcp6, sizeof(rpcTcp6));

    dwResult4 = GetTcpStatisticsEx(&rpcTcp4, AF_INET);
    dwResult6 = GetTcpStatisticsEx(&rpcTcp6, AF_INET6);
    if ((dwResult4 isnot NO_ERROR) && (dwResult6 isnot NO_ERROR))
    {
        TRACE1("Couldnt get Tcp stats. Error %d",dwResult4);
        TraceLeave("MibGetTcpGroup");
        
        return dwResult4;
    }

    pOutput = (PTCP_STATS_GET)objectArray;

    //
    // The current MIB only has one object (per stat) for both IPv4 and IPv6.
    // That is, it assumes a combination TCP stack).  We can add together 
    // counters but for enumerated objects, we arbitrarily report the IPv4 
    // stack value.
    //    
    SetAsnInteger(&(pOutput->tcpRtoAlgorithm), rpcTcp4.dwRtoAlgorithm);
    SetAsnInteger(&(pOutput->tcpRtoMin), rpcTcp4.dwRtoMin);
    SetAsnInteger(&(pOutput->tcpRtoMax), rpcTcp4.dwRtoMax);
    SetAsnInteger(&(pOutput->tcpMaxConn), rpcTcp4.dwMaxConn);
    SetAsnCounter(&(pOutput->tcpActiveOpens), 
                  rpcTcp4.dwActiveOpens + rpcTcp6.dwActiveOpens);
    SetAsnCounter(&(pOutput->tcpPassiveOpens), 
                  rpcTcp4.dwPassiveOpens + rpcTcp6.dwPassiveOpens);
    SetAsnCounter(&(pOutput->tcpAttemptFails), 
                  rpcTcp4.dwAttemptFails + rpcTcp6.dwAttemptFails);
    SetAsnCounter(&(pOutput->tcpEstabResets), 
                  rpcTcp4.dwEstabResets + rpcTcp6.dwEstabResets);
    SetAsnGauge(&(pOutput->tcpCurrEstab), 
                rpcTcp4.dwCurrEstab + rpcTcp6.dwCurrEstab);
    SetAsnCounter(&(pOutput->tcpInSegs), 
                  rpcTcp4.dwInSegs + rpcTcp6.dwInSegs);
    SetAsnCounter(&(pOutput->tcpOutSegs), 
                  rpcTcp4.dwOutSegs + rpcTcp6.dwOutSegs);
    SetAsnCounter(&(pOutput->tcpRetransSegs), 
                  rpcTcp4.dwRetransSegs + rpcTcp6.dwRetransSegs);
    SetAsnCounter(&(pOutput->tcpInErrs), 
                  rpcTcp4.dwInErrs + rpcTcp6.dwInErrs);
    SetAsnCounter(&(pOutput->tcpOutRsts), 
                  rpcTcp4.dwOutRsts + rpcTcp6.dwOutRsts);
    
    TraceLeave("MibGetTcpGroup");

    return MIB_S_SUCCESS;
}

UINT
MibGetTcpConnectionEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )
{
    DWORD                       dwResult;
    PMIB_TCPROW                 pRpcTcp;
    PTCP_CONNECTION_ENTRY_GET   pOutput;
    
    
    TraceEnter("MibGetTcpConnectionEntry");
    
    dwResult = UpdateCache(MIB_II_TCP);
    
    if(dwResult isnot NO_ERROR)
    {
        TRACE1("Couldnt update TCP Connection cache. Error %d", dwResult);
        TraceLeave("MibGetTcpConnectionEntry");

        return dwResult;
    }
    
    pOutput = (PTCP_CONNECTION_ENTRY_GET)objectArray;
    
    EnterReader(MIB_II_TCP);
    
    pRpcTcp = LocateTcpRow(actionId,
                           &(pOutput->tcpConnLocalAddress),
                           &(pOutput->tcpConnLocalPort),
                           &(pOutput->tcpConnRemAddress),
                           &(pOutput->tcpConnRemPort));
                           
    
    if(pRpcTcp is NULL)
    {
        ReleaseLock(MIB_II_TCP);
        
        TRACE5("Couldnt find TCP Row. Action %d. LocalAddr %x, Localport %d, RemAddr %x, RemPort %d",
               actionId,
               GetAsnIPAddress(&(pOutput->tcpConnLocalAddress), 0xffffffff),
               GetAsnInteger(&(pOutput->tcpConnLocalPort), -1),
               GetAsnIPAddress(&(pOutput->tcpConnRemAddress), 0xffffffff),
               GetAsnInteger(&(pOutput->tcpConnRemPort), -1));
        
        TraceLeave("MibGetTcpConnectionEntry");

        if(actionId is MIB_ACTION_GETNEXT)
        {
            return MIB_S_NO_MORE_ENTRIES;
        }

        return MIB_S_ENTRY_NOT_FOUND;
    }
    
    
    SetAsnInteger(&(pOutput->tcpConnState), pRpcTcp->dwState);

    ForceSetAsnIPAddress(&(pOutput->tcpConnLocalAddress),
                         &(pOutput->dwTcpConnLocalAddressInfo),
                         pRpcTcp->dwLocalAddr);

    ForceSetAsnInteger(&(pOutput->tcpConnLocalPort), pRpcTcp->dwLocalPort);

    ForceSetAsnIPAddress(&(pOutput->tcpConnRemAddress),
                         &(pOutput->dwTcpConnRemAddressInfo),
                         pRpcTcp->dwRemoteAddr);
    
    ForceSetAsnInteger(&(pOutput->tcpConnRemPort), pRpcTcp->dwRemotePort);

    ReleaseLock(MIB_II_TCP);

    TraceLeave("MibGetTcpConnectionEntry");

    return MIB_S_SUCCESS;
}

UINT
MibGetTcpNewConnectionEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )
{
    DWORD                           dwResult = MIB_S_NO_MORE_ENTRIES;
    PMIB_TCPROW                     pRpcTcp4;
    PTCP6ConnTableEntry             pRpcTcp6;
    PTCP_NEW_CONNECTION_ENTRY_GET   pOutput;
    DWORD                           dwFamily;
    
    TraceEnter("MibGetTcpNewConnectionEntry");

    pOutput = (PTCP_NEW_CONNECTION_ENTRY_GET)objectArray;

    dwFamily = GetAsnInteger(&pOutput->tcpNewConnLocalAddressType, INET_ADDRESS_TYPE_UNKNOWN);

    if (dwFamily > INET_ADDRESS_TYPE_IPv6) {
        return (actionId is MIB_ACTION_GETNEXT)? 
               MIB_S_NO_MORE_ENTRIES : MIB_S_ENTRY_NOT_FOUND;
    }
    
    //
    // First try IPv4
    //
    if ((dwFamily == INET_ADDRESS_TYPE_UNKNOWN) || 
        (dwFamily == INET_ADDRESS_TYPE_IPv4)) {

        dwResult = UpdateCache(MIB_II_TCP);
        if (dwResult isnot NO_ERROR) {
            goto IPv4Done;
        }
    
        EnterReader(MIB_II_TCP);
        
        pRpcTcp4 = LocateTcpRow(actionId,
                                &(pOutput->tcpNewConnLocalAddress),
                                &(pOutput->tcpNewConnLocalPort),
                                &(pOutput->tcpNewConnRemAddress),
                                &(pOutput->tcpNewConnRemPort));
                               
        
        if (pRpcTcp4 is NULL) {
            dwResult = (actionId is MIB_ACTION_GETNEXT)? 
                        MIB_S_NO_MORE_ENTRIES : MIB_S_ENTRY_NOT_FOUND;
            goto IPv4Cleanup;
        }
        
        ForceSetAsnInteger(&(pOutput->tcpNewConnLocalAddressType), INET_ADDRESS_TYPE_IPv4);
        
        ForceSetAsnOctetString(&(pOutput->tcpNewConnLocalAddress),
                          pOutput->rgbyTcpNewConnLocalAddressInfo,
                          &pRpcTcp4->dwLocalAddr,
                          sizeof(pRpcTcp4->dwLocalAddr));
    
        ForceSetAsnInteger(&(pOutput->tcpNewConnLocalPort), pRpcTcp4->dwLocalPort);
    
        ForceSetAsnInteger(&(pOutput->tcpNewConnRemAddressType), INET_ADDRESS_TYPE_IPv4);
    
        ForceSetAsnOctetString(&(pOutput->tcpNewConnRemAddress),
                          pOutput->rgbyTcpNewConnRemAddressInfo,
                          &pRpcTcp4->dwRemoteAddr,
                          sizeof(pRpcTcp4->dwRemoteAddr));
        
        ForceSetAsnInteger(&(pOutput->tcpNewConnRemPort), pRpcTcp4->dwRemotePort);
    
        SetAsnInteger(&(pOutput->tcpNewConnState), pRpcTcp4->dwState);
    
        dwResult = MIB_S_SUCCESS;

IPv4Cleanup:
        ReleaseLock(MIB_II_TCP);
    }
IPv4Done:

    if (dwResult != MIB_S_NO_MORE_ENTRIES) {
        return dwResult;
    }

    if ((dwFamily == INET_ADDRESS_TYPE_IPv4) && (actionId == MIB_ACTION_GETNEXT)) {
        dwFamily = INET_ADDRESS_TYPE_IPv6;
        actionId = MIB_ACTION_GETFIRST;
    }

    //
    // Now try IPv6
    //
    if ((dwFamily == INET_ADDRESS_TYPE_UNKNOWN) || 
        (dwFamily == INET_ADDRESS_TYPE_IPv6)) {

        dwResult = UpdateCache(MIB_II_TCP6);
        if (dwResult isnot NO_ERROR) {
            goto IPv6Done;
        }
    
        EnterReader(MIB_II_TCP6);
        
        pRpcTcp6 = LocateTcp6Row(actionId,
                                 &(pOutput->tcpNewConnLocalAddress),
                                 &(pOutput->tcpNewConnLocalPort),
                                 &(pOutput->tcpNewConnRemAddress),
                                 &(pOutput->tcpNewConnRemPort));
        
        if (pRpcTcp6 is NULL) {
            dwResult = (actionId is MIB_ACTION_GETNEXT)? 
                        MIB_S_NO_MORE_ENTRIES : MIB_S_ENTRY_NOT_FOUND;
            goto IPv6Cleanup;
        }
        
        ForceSetAsnInteger(&(pOutput->tcpNewConnLocalAddressType), INET_ADDRESS_TYPE_IPv6);
        
        ForceSetAsnOctetString(&(pOutput->tcpNewConnLocalAddress),
                               pOutput->rgbyTcpNewConnLocalAddressInfo,
                               &pRpcTcp6->tct_localaddr,
                               (pRpcTcp6->tct_localscopeid)? 20 : 16);
    
        ForceSetAsnInteger(&(pOutput->tcpNewConnLocalPort), pRpcTcp6->tct_localport);
    
        ForceSetAsnInteger(&(pOutput->tcpNewConnRemAddressType), INET_ADDRESS_TYPE_IPv6);
    
        ForceSetAsnOctetString(&(pOutput->tcpNewConnRemAddress),
                               pOutput->rgbyTcpNewConnRemAddressInfo,
                               &pRpcTcp6->tct_remoteaddr,
                               (pRpcTcp6->tct_remotescopeid)? 20 : 16);
        
        ForceSetAsnInteger(&(pOutput->tcpNewConnRemPort), pRpcTcp6->tct_remoteport);
    
        SetAsnInteger(&(pOutput->tcpNewConnState), pRpcTcp6->tct_state);
    
        dwResult = MIB_S_SUCCESS;

IPv6Cleanup:
        ReleaseLock(MIB_II_TCP6);
    }
IPv6Done:

    TraceLeave("MibGetTcpConnectionEntry");

    return dwResult;
}

UINT
MibSetTcpConnectionEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )
{
    DWORD                       dwResult,dwState;
    PMIB_TCPROW                 pRpcTcp;
    PTCP_CONNECTION_ENTRY_SET   pInput;
    PMIB_OPAQUE_INFO            pInfo;
    PMIB_TCPROW                 pSetRow;

    pInput  = (PTCP_CONNECTION_ENTRY_SET)objectArray;
    pInfo   = (PMIB_OPAQUE_INFO)(pInput->rgdwSetBuffer);
    pSetRow = (PMIB_TCPROW)(pInfo->rgbyData);

    switch(actionId)
    {
        case MIB_ACTION_VALIDATE:
        {
            TraceEnter("MibSetTcpConnectionEntry - VALIDATE");
            
            ASSERT(!(IsAsnTypeNull(&(pInput->tcpConnLocalAddress)) or
                     IsAsnTypeNull(&(pInput->tcpConnLocalPort)) or
                     IsAsnTypeNull(&(pInput->tcpConnRemAddress)) or
                     IsAsnTypeNull(&(pInput->tcpConnRemPort)) or
                     IsAsnTypeNull(&(pInput->tcpConnState))));

            pInput->bLocked = FALSE;

            dwState = GetAsnInteger(&(pInput->tcpConnState), 0);
                            
            if(dwState isnot MIB_TCP_STATE_DELETE_TCB)
            {
                TRACE1("State is %d. Only state allowed is DELETE",dwState);

                return MIB_S_INVALID_PARAMETER;
            }
            
            dwResult = UpdateCache(MIB_II_TCP);
    
            if(dwResult isnot NO_ERROR)
            {
                TRACE1("Couldnt update TCP Connection cache. Error %d", dwResult);
                TraceLeave("MibGetTcpConnectionEntry");

                return dwResult;
            }

            EnterWriter(MIB_II_TCP);
           
            pInput->bLocked = TRUE;
 
            pRpcTcp = LocateTcpRow(GET_EXACT,
                                   &(pInput->tcpConnLocalAddress),
                                   &(pInput->tcpConnLocalPort),
                                   &(pInput->tcpConnRemAddress),
                                   &(pInput->tcpConnRemPort));
                           
            if(pRpcTcp is NULL)
            {
                ReleaseLock(MIB_II_TCP);

                pInput->bLocked = FALSE;

                TRACE5("Couldnt find TCP Row. Action %d. LocalAddr %x, Localport %d, RemAddr %x, RemPort %d",
                       actionId,
                       GetAsnIPAddress(&(pInput->tcpConnLocalAddress), 
                                       0xffffffff),
                       GetAsnInteger(&(pInput->tcpConnLocalPort), 
                                     -1),
                       GetAsnIPAddress(&(pInput->tcpConnRemAddress), 
                                       0xffffffff),
                       GetAsnInteger(&(pInput->tcpConnRemPort), 
                                     -1));

                TraceLeave("MibSetTcpConnectionEntry");
        
                return MIB_S_ENTRY_NOT_FOUND;
            }

            pInput->raAction = SET_ROW;
            
            *pSetRow = *pRpcTcp;

            pSetRow->dwState = MIB_TCP_STATE_DELETE_TCB;

            //
            // change port to network byte order
            //
            
            pSetRow->dwLocalPort = (DWORD)htons((WORD)pSetRow->dwLocalPort);

            //
            // chnage port to network byte order
            //
            
            pSetRow->dwRemotePort = (DWORD)htons((WORD)pSetRow->dwRemotePort);

            return MIB_S_SUCCESS;
        }
        case MIB_ACTION_SET:
        {
            TraceEnter("MibSetTcpConnectionEntry - SET");

            dwResult = NO_ERROR;

            if(pInput->raAction is SET_ROW)
            {
                dwResult = InternalSetTcpEntry(pInfo);
#ifdef MIB_DEBUG
                if(dwResult isnot NO_ERROR)
                {
                    TRACE1("MibSet returned error %d!!",dwResult);
                }
#endif
                InvalidateCache(MIB_II_TCP);
            }

            TraceLeave("MibSetTcpConnectionEntry");

            return dwResult;
        }
        case MIB_ACTION_CLEANUP:
        {
            TraceEnter("MibSetTcpConnectionEntry - CLEANUP");

            if(pInput->bLocked)
            {
                ReleaseLock(MIB_II_TCP);
            }

            TraceLeave("MibSetTcpConnectionEntry");

            return MIB_S_SUCCESS;
        }
        default:
        {
            TraceEnter("MibSetTcpConnectionEntry - WRONG ACTION");
            TraceLeave("MibSetTcpConnectionEntry");

            return MIB_S_INVALID_PARAMETER;
        }
    }            
}

UINT
MibSetTcpNewConnectionEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )
{
    DWORD                           dwResult,dwState;
    PMIB_TCPROW                     pRpcTcp4;
    PTCP_NEW_CONNECTION_ENTRY_SET   pInput;
    PMIB_OPAQUE_INFO                pInfo;
    PMIB_TCPROW                     pSetRow;

    pInput  = (PTCP_NEW_CONNECTION_ENTRY_SET)objectArray;
    pInfo   = (PMIB_OPAQUE_INFO)(pInput->rgdwSetBuffer);
    pSetRow = (PMIB_TCPROW)(pInfo->rgbyData);

    switch(actionId)
    {
        case MIB_ACTION_VALIDATE:
        {
            TraceEnter("MibSetTcpNewConnectionEntry - VALIDATE");
            
            ASSERT(!(IsAsnTypeNull(&(pInput->tcpNewConnLocalAddressType)) or
                     IsAsnTypeNull(&(pInput->tcpNewConnLocalAddress)) or
                     IsAsnTypeNull(&(pInput->tcpNewConnLocalPort)) or
                     IsAsnTypeNull(&(pInput->tcpNewConnRemAddressType)) or
                     IsAsnTypeNull(&(pInput->tcpNewConnRemAddress)) or
                     IsAsnTypeNull(&(pInput->tcpNewConnRemPort)) or
                     IsAsnTypeNull(&(pInput->tcpNewConnState))));

            pInput->bLocked = FALSE;

            dwState = GetAsnInteger(&(pInput->tcpNewConnState), 0);
                            
            if(dwState isnot MIB_TCP_STATE_DELETE_TCB)
            {
                TRACE1("State is %d. Only state allowed is DELETE",dwState);

                return MIB_S_INVALID_PARAMETER;
            }
            
            dwResult = UpdateCache(MIB_II_TCP);
    
            if(dwResult isnot NO_ERROR)
            {
                TRACE1("Couldnt update TCP Connection cache. Error %d", dwResult);
                TraceLeave("MibGetTcpNewConnectionEntry");

                return dwResult;
            }

            EnterWriter(MIB_II_TCP);
           
            pInput->bLocked = TRUE;
 
            pRpcTcp4 = LocateTcpRow(GET_EXACT,
                                    &(pInput->tcpNewConnLocalAddress),
                                    &(pInput->tcpNewConnLocalPort),
                                    &(pInput->tcpNewConnRemAddress),
                                    &(pInput->tcpNewConnRemPort));
                           
            if(pRpcTcp4 is NULL)
            {
                ReleaseLock(MIB_II_TCP);

                pInput->bLocked = FALSE;

                TRACE5("Couldn't find TCP Row. Action %d. LocalAddr %x, Localport %d, RemAddr %x, RemPort %d",
                       actionId,
                       GetAsnIPAddress(&(pInput->tcpConnLocalAddress), 
                                       0xffffffff),
                       GetAsnInteger(&(pInput->tcpConnLocalPort), 
                                     -1),
                       GetAsnIPAddress(&(pInput->tcpConnRemAddress), 
                                       0xffffffff),
                       GetAsnInteger(&(pInput->tcpConnRemPort), 
                                     -1));

                TraceLeave("MibSetTcpNewConnectionEntry");
        
                return MIB_S_ENTRY_NOT_FOUND;
            }

            pInput->raAction = SET_ROW;
            
            *pSetRow = *pRpcTcp4;

            pSetRow->dwState = MIB_TCP_STATE_DELETE_TCB;

            //
            // change port to network byte order
            //
            
            pSetRow->dwLocalPort = (DWORD)htons((WORD)pSetRow->dwLocalPort);

            //
            // chnage port to network byte order
            //
            
            pSetRow->dwRemotePort = (DWORD)htons((WORD)pSetRow->dwRemotePort);

            return MIB_S_SUCCESS;
        }
        case MIB_ACTION_SET:
        {
            TraceEnter("MibSetTcpNewConnectionEntry - SET");

            dwResult = NO_ERROR;

            if(pInput->raAction is SET_ROW)
            {
                dwResult = InternalSetTcpEntry(pInfo);
#ifdef MIB_DEBUG
                if(dwResult isnot NO_ERROR)
                {
                    TRACE1("MibSet returned error %d!!",dwResult);
                }
#endif
                InvalidateCache(MIB_II_TCP);
            }

            TraceLeave("MibSetTcpNewConnectionEntry");

            return dwResult;
        }
        case MIB_ACTION_CLEANUP:
        {
            TraceEnter("MibSetTcpNewConnectionEntry - CLEANUP");

            if(pInput->bLocked)
            {
                ReleaseLock(MIB_II_TCP);
            }

            TraceLeave("MibSetTcpNewConnectionEntry");

            return MIB_S_SUCCESS;
        }
        default:
        {
            TraceEnter("MibSetTcpNewConnectionEntry - WRONG ACTION");
            TraceLeave("MibSetTcpNewConnectionEntry");

            return MIB_S_INVALID_PARAMETER;
        }
    }            
}

UINT
MibGetUdpGroup(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )
{
    DWORD           dwResult;
    MIB_UDPSTATS    rpcUdpStats;
    PUDP_STATS_GET  pOutput;
    
    TraceEnter("MibGetUdpGroup");
    
    dwResult = GetUdpStatistics(&rpcUdpStats);
    
    if(dwResult isnot NO_ERROR)
    {
        TRACE1("Couldnt get Udp stats. Error %d",dwResult);
        TraceLeave("MibGetUdpGroup");
        
        return dwResult;
    }
    
    pOutput = (PUDP_STATS_GET)objectArray;
    
    SetAsnCounter(&(pOutput->udpInDatagrams), rpcUdpStats.dwInDatagrams);
    SetAsnCounter(&(pOutput->udpNoPorts), rpcUdpStats.dwNoPorts);
    SetAsnCounter(&(pOutput->udpInErrors), rpcUdpStats.dwInErrors);
    SetAsnCounter(&(pOutput->udpOutDatagrams), rpcUdpStats.dwOutDatagrams);

    TraceLeave("MibGetUdpGroup");
    
    return MIB_S_SUCCESS;
}

UINT
MibGetUdpEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )
{
    DWORD                  dwResult;
    PMIB_UDPROW            pRpcUdp;
    PUDP_ENTRY_GET         pOutput;
    
    
    TraceEnter("MibGetUdpEntry");
    
    dwResult = UpdateCache(MIB_II_UDP);
    
    if(dwResult isnot NO_ERROR)
    {
        TRACE1("Couldnt update UDP Connection cache. Error %d", dwResult);
        TraceLeave("MibGetUdpEntry");

        return dwResult;
    }
    
    pOutput = (PUDP_ENTRY_GET)objectArray;
    
    EnterReader(MIB_II_UDP);
    
    pRpcUdp = LocateUdpRow(actionId,
                           &(pOutput->udpLocalAddress),
                           &(pOutput->udpLocalPort));
                           
    
    if(pRpcUdp is NULL)
    {
        ReleaseLock(MIB_II_UDP);
        
        TRACE3("Couldnt find UDP Row. Action %d. LocalAddr %x, Localport %d",
               actionId,
               GetAsnIPAddress(&(pOutput->udpLocalAddress), 0xffffffff),
               GetAsnInteger(&(pOutput->udpLocalPort), -1));
        
        TraceLeave("MibGetUdpEntry");
        
        if(actionId is MIB_ACTION_GETNEXT)
        {
            return MIB_S_NO_MORE_ENTRIES;
        }

        return MIB_S_ENTRY_NOT_FOUND;
    }
    
    
    ForceSetAsnIPAddress(&(pOutput->udpLocalAddress),
                         &(pOutput->dwUdpLocalAddressInfo),
                         pRpcUdp->dwLocalAddr);

    ForceSetAsnInteger(&(pOutput->udpLocalPort), pRpcUdp->dwLocalPort);

    ReleaseLock(MIB_II_UDP);

    TraceLeave("MibGetUdpEntry");

    return MIB_S_SUCCESS;
}

UINT
MibGetUdpListenerEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )
{
    DWORD                   dwResult = MIB_S_NO_MORE_ENTRIES;
    PMIB_UDPROW             pRpcUdp4;
    PUDP6ListenerEntry      pRpcUdp6;
    PUDP_LISTENER_ENTRY_GET pOutput;
    DWORD                   dwFamily;
    
    TraceEnter("MibGetUdpListenerEntry");

    pOutput = (PUDP_LISTENER_ENTRY_GET)objectArray;

    dwFamily = GetAsnInteger(&pOutput->udpListenerLocalAddressType, 
                             INET_ADDRESS_TYPE_UNKNOWN);

    if (dwFamily > INET_ADDRESS_TYPE_IPv6) {
        return (actionId is MIB_ACTION_GETNEXT)?
               MIB_S_NO_MORE_ENTRIES : MIB_S_ENTRY_NOT_FOUND;
    }
    
    //
    // First try IPv4
    //
    if ((dwFamily == INET_ADDRESS_TYPE_UNKNOWN) ||
        (dwFamily == INET_ADDRESS_TYPE_IPv4)) {

        dwResult = UpdateCache(MIB_II_UDP);
        if(dwResult isnot NO_ERROR)
        {
            goto IPv4Done;
        }
        
        EnterReader(MIB_II_UDP);
        
        pRpcUdp4 = LocateUdpRow(actionId,
                                &(pOutput->udpListenerLocalAddress),
                                &(pOutput->udpListenerLocalPort));
        
        if(pRpcUdp4 is NULL)
        {
            dwResult = (actionId is MIB_ACTION_GETNEXT)?
                        MIB_S_NO_MORE_ENTRIES : MIB_S_ENTRY_NOT_FOUND;
            goto IPv4Cleanup;
        }
        
        ForceSetAsnInteger(&(pOutput->udpListenerLocalAddressType), 
                           INET_ADDRESS_TYPE_IPv4);
        
        ForceSetAsnOctetString(&(pOutput->udpListenerLocalAddress),
                               pOutput->rgbyUdpLocalAddressInfo,
                               &pRpcUdp4->dwLocalAddr,
                               sizeof(pRpcUdp4->dwLocalAddr));
    
        ForceSetAsnUnsigned32(&(pOutput->udpListenerLocalPort), 
                              pRpcUdp4->dwLocalPort);

        dwResult = MIB_S_SUCCESS;

IPv4Cleanup:
        ReleaseLock(MIB_II_UDP);
    }
IPv4Done:

    if (dwResult != MIB_S_NO_MORE_ENTRIES) {
        return dwResult;
    }

    if ((dwFamily == INET_ADDRESS_TYPE_IPv4) && (actionId == MIB_ACTION_GETNEXT)) {
        dwFamily = INET_ADDRESS_TYPE_IPv6;
        actionId = MIB_ACTION_GETFIRST;
    }

    //
    // Now try IPv6
    //
    if ((dwFamily == INET_ADDRESS_TYPE_UNKNOWN) ||
        (dwFamily == INET_ADDRESS_TYPE_IPv6)) {

        dwResult = UpdateCache(MIB_II_UDP6_LISTENER);
        if(dwResult isnot NO_ERROR)
        {
            goto IPv6Done;
        }
        
        EnterReader(MIB_II_UDP6_LISTENER);
        
        pRpcUdp6 = LocateUdp6Row(actionId,
                                 &(pOutput->udpListenerLocalAddress),
                                 &(pOutput->udpListenerLocalPort));
        
        if(pRpcUdp6 is NULL)
        {
            dwResult = (actionId is MIB_ACTION_GETNEXT)?
                        MIB_S_NO_MORE_ENTRIES : MIB_S_ENTRY_NOT_FOUND;
            goto IPv6Cleanup;
        }
        
        ForceSetAsnInteger(&(pOutput->udpListenerLocalAddressType), 
                           INET_ADDRESS_TYPE_IPv6);
        
        ForceSetAsnOctetString(&(pOutput->udpListenerLocalAddress),
                               pOutput->rgbyUdpLocalAddressInfo,
                               &pRpcUdp6->ule_localaddr,
                               (pRpcUdp6->ule_localscopeid)? 20 : 16);
    
        ForceSetAsnInteger(&(pOutput->udpListenerLocalPort), 
                           pRpcUdp6->ule_localport);

        dwResult = MIB_S_SUCCESS;

IPv6Cleanup:
        ReleaseLock(MIB_II_UDP6_LISTENER);
    }
IPv6Done:

    TraceLeave("MibGetUdpEntry");

    return dwResult;
}


UINT
MibGetIpForwardNumber(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )
{
    DWORD                   dwResult;
    PIP_FORWARD_NUMBER_GET  pOutput;
    
    TraceEnter("MibGetIpForwardNumber");
    
    dwResult = UpdateCache(FORWARD_MIB);
    
    if(dwResult isnot NO_ERROR)
    {
        TRACE1("Couldnt update IP Forward cache",dwResult);
        TraceLeave("MibGetIpForwardNumber");
    
        return dwResult;
    }

    pOutput = (PIP_FORWARD_NUMBER_GET)objectArray;

    EnterReader(FORWARD_MIB);
    
    SetAsnGauge(&(pOutput->ipForwardNumber), g_Cache.pRpcIpForwardTable->dwNumEntries);
    
    ReleaseLock(FORWARD_MIB);
    
    TraceLeave("MibGetIpForwardNumber");
    
    return MIB_S_SUCCESS;
}

UINT
MibGetIpForwardEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )
{
    DWORD                   dwResult;
    PMIB_IPFORWARDROW      pRpcIpForw;
    PIP_FORWARD_ENTRY_GET   pOutput;
    
    TraceEnter("MibGetIpForwardEntry");
    
    dwResult = UpdateCache(FORWARD_MIB);
    
    if(dwResult isnot NO_ERROR)
    {
        TRACE1("Couldnt update IP Forward cache. Error %d", dwResult);
        TraceLeave("MibGetIpForwardEntry");
        
        return dwResult;
    }
    
    pOutput = (PIP_FORWARD_ENTRY_GET)objectArray;
    
    EnterReader(FORWARD_MIB);
    
    pRpcIpForw = LocateIpForwardRow(actionId,
                                    &(pOutput->ipForwardDest),
                                    &(pOutput->ipForwardProto),
                                    &(pOutput->ipForwardPolicy),
                                    &(pOutput->ipForwardNextHop));
    
    if(pRpcIpForw is NULL)
    {
        ReleaseLock(FORWARD_MIB);
        
        TRACE5("Unable to locateIP Forward Row. Action %d. Dest %x Proto %d Policy %d NextHop %x",
               actionId,
               GetAsnIPAddress(&(pOutput->ipForwardDest),0),
               GetAsnInteger(&(pOutput->ipForwardProto),0),
               GetAsnInteger(&(pOutput->ipForwardPolicy),0),
               GetAsnIPAddress(&(pOutput->ipForwardNextHop),0));
        
        TraceLeave("MibGetIpForwardEntry");
        
        if(actionId is MIB_ACTION_GETNEXT)
        {
            return MIB_S_NO_MORE_ENTRIES;
        }

        return MIB_S_ENTRY_NOT_FOUND;
    }
    
    ForceSetAsnIPAddress(&(pOutput->ipForwardDest),
                         &(pOutput->dwIpForwardDestInfo),
                         pRpcIpForw->dwForwardDest);
    
    SetAsnIPAddress(&(pOutput->ipForwardMask),
                    &(pOutput->dwIpForwardMaskInfo),
                    pRpcIpForw->dwForwardMask);
    
    
    ForceSetAsnInteger(&(pOutput->ipForwardPolicy), pRpcIpForw->dwForwardPolicy);
    
    ForceSetAsnIPAddress(&(pOutput->ipForwardNextHop),
                         &(pOutput->dwIpForwardNextHopInfo),
                         pRpcIpForw->dwForwardNextHop);                
    
    SetAsnInteger(&(pOutput->ipForwardIfIndex), pRpcIpForw->dwForwardIfIndex);
    SetAsnInteger(&(pOutput->ipForwardType), pRpcIpForw->dwForwardType);
    ForceSetAsnInteger(&(pOutput->ipForwardProto), pRpcIpForw->dwForwardProto);
    SetAsnInteger(&(pOutput->ipForwardAge), pRpcIpForw->dwForwardAge);
    
    SetToZeroOid(&(pOutput->ipForwardInfo));
    
    SetAsnInteger(&(pOutput->ipForwardNextHopAS), pRpcIpForw->dwForwardNextHopAS);
    SetAsnInteger(&(pOutput->ipForwardMetric1), pRpcIpForw->dwForwardMetric1);
    SetAsnInteger(&(pOutput->ipForwardMetric2), pRpcIpForw->dwForwardMetric2);
    SetAsnInteger(&(pOutput->ipForwardMetric3), pRpcIpForw->dwForwardMetric3);
    SetAsnInteger(&(pOutput->ipForwardMetric4), pRpcIpForw->dwForwardMetric4);
    SetAsnInteger(&(pOutput->ipForwardMetric5), pRpcIpForw->dwForwardMetric5);
    
    ReleaseLock(FORWARD_MIB);
    
    TraceLeave("MibGetIpForwardEntry");
    
    return MIB_S_SUCCESS;
}

UINT
MibSetIpForwardEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )
{
    DWORD                 dwResult,dwType;
    PMIB_IPFORWARDROW     pRpcIpForw;
    PIP_FORWARD_ENTRY_SET pInput;
    PMIB_OPAQUE_INFO      pInfo;
    PMIB_IPFORWARDROW     pSetRow;

    pInput  = (PIP_FORWARD_ENTRY_SET)objectArray;
    pInfo   = (PMIB_OPAQUE_INFO)(pInput->rgdwSetBuffer);
    pSetRow = (PMIB_IPFORWARDROW)(pInfo->rgbyData);

    switch(actionId)
    {
        case MIB_ACTION_VALIDATE:
        {
            TraceEnter("MibSetIpForwardEntry - VALIDATE");
    
            dwResult = UpdateCache(FORWARD_MIB);    

            if(dwResult isnot NO_ERROR)
            {
                TRACE1("Couldnt update IP Forward cache. Error %d", dwResult);
                TraceLeave("GetIpForwardEntry");
                
                return dwResult;
            }

            ASSERT(!(IsAsnTypeNull(&(pInput->ipForwardDest))));

            pInfo->dwId = IP_FORWARDROW;
            
            EnterWriter(FORWARD_MIB);    

            pInput->bLocked = TRUE;

            pRpcIpForw = LocateIpForwardRow(actionId,
                                            &(pInput->ipForwardDest),
                                            &(pInput->ipForwardProto),
                                            &(pInput->ipForwardPolicy),
                                            &(pInput->ipForwardNextHop));
    
    
            if(pRpcIpForw is NULL)
            {
                //
                // So we are creating a row. We need the If index, the mask, 
                // next hop and metric 1
                //

                if(IsAsnTypeNull(&(pInput->ipForwardIfIndex)) or
                   IsAsnTypeNull(&(pInput->ipForwardMask)) or
                   IsAsnTypeNull(&(pInput->ipForwardNextHop)) or
                   IsAsnTypeNull(&(pInput->ipForwardMetric1)))
                {
                    TRACE0("Not enough information to create a route");

                    ReleaseLock(FORWARD_MIB);

                    pInput->bLocked = FALSE;

                    TraceLeave("MibSetIpForwardEntry");
                    
                    return MIB_S_INVALID_PARAMETER;
                }

                dwType = GetAsnInteger(&(pInput->ipForwardType),
                                       MIB_IPROUTE_TYPE_OTHER);
                
                if(dwType is MIB_IPROUTE_TYPE_INVALID)
                {
                    //
                    // We couldnt be creating and deleting a row at the 
                    // same time
                    //

                    ReleaseLock(FORWARD_MIB);

                    pInput->bLocked = FALSE;

                    TRACE0("Wrong type");

                    TraceLeave("MibSetIpForwardEntry");

                    return MIB_S_INVALID_PARAMETER;
                }

                pSetRow->dwForwardProto =
                    GetAsnInteger(&(pInput->ipForwardProto),
                                  MIB_IPPROTO_NETMGMT);

                if((pSetRow->dwForwardProto isnot MIB_IPPROTO_NETMGMT) and
                   (pSetRow->dwForwardProto isnot MIB_IPPROTO_LOCAL))
                {
                    //
                    // wrong protocol
                    //

                    ReleaseLock(FORWARD_MIB);

                    pInput->bLocked = FALSE;

                    TRACE1("Wrong protocol %d",
                           pSetRow->dwForwardProto);

                    TraceLeave("MibSetIpForwardEntry");

                    return MIB_S_INVALID_PARAMETER;
                }
                
                pInput->raAction = CREATE_ROW;
                
                pSetRow->dwForwardDest =
                    GetAsnIPAddress(&(pInput->ipForwardDest),
                                    0xffffffff);
                
                pSetRow->dwForwardMask =
                    GetAsnIPAddress(&(pInput->ipForwardMask),
                                    0x00000000);

                pSetRow->dwForwardPolicy = 0;
                
                pSetRow->dwForwardNextHop =
                    GetAsnIPAddress(&(pInput->ipForwardNextHop),
                                    0x00000000);
                
                pSetRow->dwForwardIfIndex =
                    GetAsnInteger(&(pInput->ipForwardIfIndex),
                                  0);

                //
                // We default to an age of 0 seconds, per RFC 2096.
                //
                
                pSetRow->dwForwardAge   =
                    GetAsnInteger(&(pInput->ipForwardAge),0);
                pSetRow->dwForwardNextHopAS = 0;
                pSetRow->dwForwardMetric1 =
                    GetAsnInteger(&(pInput->ipForwardMetric1),0);
                pSetRow->dwForwardMetric2 =
                    GetAsnInteger(&(pInput->ipForwardMetric2),-1);
                pSetRow->dwForwardMetric3 =
                    GetAsnInteger(&(pInput->ipForwardMetric3),-1);
                pSetRow->dwForwardMetric4 =
                    GetAsnInteger(&(pInput->ipForwardMetric4),-1);
                pSetRow->dwForwardMetric5 =
                    GetAsnInteger(&(pInput->ipForwardMetric5),-1);


                TraceLeave("MibSetIpForwardEntry");
                
                return MIB_S_SUCCESS;
            }
            else
            {
                //
                // Ok so we are only changing some stuff in the route
                //

                dwType = GetAsnInteger(&(pInput->ipForwardType),  
                                       pRpcIpForw->dwForwardType);
                
                if(dwType is MIB_IPROUTE_TYPE_INVALID)
                {
                    //
                    // Deleting a row
                    //
                    
                    pInput->raAction = DELETE_ROW;
                    
                    *pSetRow = *pRpcIpForw;

                    ReleaseLock(FORWARD_MIB);
                    
                    pInput->bLocked = FALSE;

                    TraceLeave("MibSetIpForwardEntry");

                    return MIB_S_SUCCESS;
                }
                
                pSetRow->dwForwardProto =
                    GetAsnInteger(&(pInput->ipForwardProto),
                                  pRpcIpForw->dwForwardProto);

                if((pSetRow->dwForwardProto isnot MIB_IPPROTO_NETMGMT) and
                   (pSetRow->dwForwardProto isnot MIB_IPPROTO_LOCAL))
                {
                    //
                    // wrong protocol
                    //

                    ReleaseLock(FORWARD_MIB);

                    pInput->bLocked = FALSE;

                    TRACE1("Wrong protocol %d",
                           pSetRow->dwForwardProto);

                    TraceLeave("MibSetIpForwardEntry");

                    return MIB_S_INVALID_PARAMETER;
                }

                pInput->raAction = SET_ROW;

                pSetRow->dwForwardDest =
                    GetAsnIPAddress(&(pInput->ipForwardDest),
                                    pRpcIpForw->dwForwardDest);
                
                pSetRow->dwForwardMask =
                    GetAsnIPAddress(&(pInput->ipForwardMask),
                                    pRpcIpForw->dwForwardMask);

                pSetRow->dwForwardPolicy = 0;
                
                pSetRow->dwForwardNextHop =
                    GetAsnIPAddress(&(pInput->ipForwardNextHop),
                                    pRpcIpForw->dwForwardNextHop);
                
                pSetRow->dwForwardIfIndex =
                    GetAsnInteger(&(pInput->ipForwardIfIndex),
                                  pRpcIpForw->dwForwardIfIndex);

                //
                // The type gets set by the router manager. But incase 
                // we are writing to the stack we need some kind of valid type
                //
                
                pSetRow->dwForwardType =
                    GetAsnInteger(&(pInput->ipForwardType),
                                  pRpcIpForw->dwForwardType);
               
                pSetRow->dwForwardAge   =
                    GetAsnInteger(&(pInput->ipForwardAge),
                                  pRpcIpForw->dwForwardAge);

                pSetRow->dwForwardNextHopAS = 0;

                pSetRow->dwForwardMetric1 =
                    GetAsnInteger(&(pInput->ipForwardMetric1),
                                  pRpcIpForw->dwForwardMetric1);

                pSetRow->dwForwardMetric2 =
                    GetAsnInteger(&(pInput->ipForwardMetric2),
                                  pRpcIpForw->dwForwardMetric2);

                pSetRow->dwForwardMetric3 =
                    GetAsnInteger(&(pInput->ipForwardMetric3),
                                  pRpcIpForw->dwForwardMetric3);

                pSetRow->dwForwardMetric4 =
                    GetAsnInteger(&(pInput->ipForwardMetric4),
                                  pRpcIpForw->dwForwardMetric4);

                pSetRow->dwForwardMetric5 =
                    GetAsnInteger(&(pInput->ipForwardMetric5),
                                  pRpcIpForw->dwForwardMetric5);

                TraceLeave("MibSetIpForwardEntry");
                
                return MIB_S_SUCCESS;
            }
        }
        case MIB_ACTION_SET:
        {
            TraceEnter("MibSetIpForwardEntry - SET");
            
            switch(pInput->raAction)
            {
                case CREATE_ROW:
                {
                    dwResult = InternalCreateIpForwardEntry(pInfo);

#ifdef MIB_DEBUG
                    if(dwResult isnot NO_ERROR)
                    {
                        TRACE1("Create failed with error %d",dwResult);
                    }
#endif
                    InvalidateCache(FORWARD_MIB);
                    
                    TraceLeave("MibSetIpForwardEntry");

                    return dwResult;
                }
                case SET_ROW:
                {
                    dwResult = InternalSetIpForwardEntry(pInfo);

#ifdef MIB_DEBUG
                    if(dwResult isnot NO_ERROR)
                    {
                        TRACE1("Set failed with error %d",dwResult);
                    }
#endif
                    InvalidateCache(FORWARD_MIB);
                    
                    TraceLeave("MibSetIpForwardEntry");

                    return dwResult;
                }
                case DELETE_ROW:
                {
                    dwResult = InternalDeleteIpForwardEntry(pInfo);

#ifdef MIB_DEBUG
                    if(dwResult isnot NO_ERROR)
                    {
                        TRACE1("Delete failed with error %d",dwResult);
                    }
#endif

                    InvalidateCache(FORWARD_MIB);

                    TraceLeave("MibSetIpForwardEntry");

                    return dwResult;
                }
                default:
                {
                    TRACE1("Wrong row action %d",pInput->raAction);

                    TraceLeave("MibSetIpForwardEntry");

                    return MIB_S_SUCCESS;
                }
            }
        }
        case MIB_ACTION_CLEANUP:
        {
            TraceEnter("MibSetIpForwardEntry - CLEANUP");

            if(pInput->bLocked)
            {
                ReleaseLock(FORWARD_MIB);
            }

            TraceLeave("MibSetIpForwardEntry");

            return MIB_S_SUCCESS;
        }
        default:
        {
            TraceEnter("MibSetIpForwardEntry - WRONG ACTION");
            TraceLeave("MibSetIpForwardEntry");

            return MIB_S_INVALID_PARAMETER;
        }
    }
}


UINT
MibGetSysInfo(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )               
{
    DWORD          dwResult;
    PSYS_INFO_GET  pOutput;
    
    TraceEnter("MibGetSysInfo");
    
    dwResult = UpdateCache(MIB_II_SYS);
    
    if(dwResult isnot NO_ERROR)
    {
        TRACE1("Couldnt update SYS cache. Error %d", dwResult);
        TraceLeave("MibGetSysInfo");
        
        return dwResult;
    }
    
    pOutput = (PSYS_INFO_GET)objectArray;
    
    EnterReader(MIB_II_SYS);
    
    SetAsnOctetString(&(pOutput->sysDescr),
                      pOutput->rgbySysDescrInfo,
                      g_Cache.pRpcSysInfo->rgbySysDescr,
                      (strlen(g_Cache.pRpcSysInfo->rgbySysDescr)));

    SetAsnInteger(&(pOutput->sysServices),g_Cache.pRpcSysInfo->dwSysServices);

    SetAsnOctetString(&(pOutput->sysContact),
                      pOutput->rgbySysContactInfo,
                      g_Cache.pRpcSysInfo->rgbySysContact,
                      (strlen(g_Cache.pRpcSysInfo->rgbySysContact)));

    SetAsnOctetString(&(pOutput->sysLocation),
                      pOutput->rgbySysLocationInfo,
                      g_Cache.pRpcSysInfo->rgbySysLocation,
                      (strlen(g_Cache.pRpcSysInfo->rgbySysLocation)));

    SetAsnOctetString(&(pOutput->sysName),
                      pOutput->rgbySysNameInfo,
                      g_Cache.pRpcSysInfo->rgbySysName,
                      (strlen(g_Cache.pRpcSysInfo->rgbySysName)));

    //
    // must not cache system uptime so get update from dll
    //

    SetAsnTimeTicks(&(pOutput->sysUpTime),SnmpSvcGetUptime());

    if (!IsAsnTypeNull(&pOutput->sysObjectID)) {
        SnmpUtilOidCpy(&pOutput->sysObjectID.asnValue.object,
                       &g_Cache.pRpcSysInfo->aaSysObjectID.asnValue.object);
    }
    
    ReleaseLock(MIB_II_SYS);

    TraceLeave("MibGetSysInfo");
    
    return MIB_S_SUCCESS;
}

UINT
MibSetSysInfo(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )               
{
    DWORD           dwResult,dwValueLen,dwValueType,dwStringLen;
    PSYS_INFO_SET   pInput;
    HKEY            hkeyMib2;
    
    pInput = (PSYS_INFO_SET)objectArray;

    switch(actionId)
    {
        case MIB_ACTION_VALIDATE:
        {
            pInput->bLocked = FALSE;

            EnterWriter(MIB_II_SYS);

            pInput->bLocked = TRUE;
    
            TraceEnter("MibSetSysInfo - VALIDATE");

            dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                    REG_KEY_MIB2,
                                    0,
                                    KEY_ALL_ACCESS,
                                    &pInput->hkeyMib2);

            if(dwResult isnot NO_ERROR) 
            {
                ReleaseLock(MIB_II_SYS);

                pInput->bLocked = FALSE;

                TRACE1("Couldnt open mib2 registry key. Error %d", dwResult);
                TraceLeave("MibSetSysInfo");
        
                return dwResult;
            }

            TraceLeave("MibSetSysInfo");

            return MIB_S_SUCCESS;
        }

        case MIB_ACTION_SET:
        {
            TraceEnter("MibSetSysInfo - SET");

            hkeyMib2 = pInput->hkeyMib2;
            dwValueType = REG_SZ;

            if (!IsAsnTypeNull(&pInput->sysName)) {

                dwStringLen = pInput->sysName.asnValue.string.length;
                dwValueLen  = dwStringLen + 1;

                memcpy(&pInput->rgbySysNameInfo, 
                       pInput->sysName.asnValue.string.stream,
                       dwStringLen);
            
                pInput->rgbySysNameInfo[dwStringLen] = '\0';

                dwResult = RegSetValueEx(
                    hkeyMib2,
                    TEXT("sysName"),
                    0,
                    dwValueType,
                    pInput->rgbySysNameInfo,
                    dwValueLen);
                                
                if (dwResult isnot NO_ERROR) {

                    TRACE1("Couldnt write sysName value. Error %d", dwResult);
                    TraceLeave("MibSetSysInfo");

                    return dwResult;
                }

                InvalidateCache(MIB_II_SYS);
            }

            if (!IsAsnTypeNull(&pInput->sysContact)) {

                dwStringLen = pInput->sysContact.asnValue.string.length;
                dwValueLen  = dwStringLen + 1;

                memcpy(&pInput->rgbySysContactInfo, 
                       pInput->sysContact.asnValue.string.stream,
                       dwStringLen);
            
                pInput->rgbySysContactInfo[dwStringLen] = '\0';

                dwResult = RegSetValueEx(
                    hkeyMib2,
                    TEXT("sysContact"),
                    0,
                    dwValueType,
                    pInput->rgbySysContactInfo,
                    dwValueLen);

                if (dwResult isnot NO_ERROR) {

                    TRACE1("Couldnt write sysContact value. Error %d", dwResult);
                    TraceLeave("MibSetSysInfo");
        
                    return dwResult;
                }

                InvalidateCache(MIB_II_SYS);
            }

            if (!IsAsnTypeNull(&pInput->sysLocation)) {

                dwStringLen = pInput->sysLocation.asnValue.string.length;
                dwValueLen  = dwStringLen + 1;

                memcpy(&pInput->rgbySysLocationInfo, 
                       pInput->sysLocation.asnValue.string.stream,
                       dwStringLen);
            
                pInput->rgbySysLocationInfo[dwStringLen] = '\0';

                dwResult = RegSetValueEx(
                    hkeyMib2,
                    TEXT("sysLocation"),
                    0,
                    dwValueType,
                    pInput->rgbySysLocationInfo,
                    dwValueLen);

                if (dwResult isnot NO_ERROR) {

                    TRACE1("Couldnt write sysLocation value. Error %d", dwResult);
                    TraceLeave("MibSetSysInfo");
        
                    return dwResult;
                }

                InvalidateCache(MIB_II_SYS);
            }

            TraceLeave("MibSetSysInfo");

            return MIB_S_SUCCESS;
        }
        case MIB_ACTION_CLEANUP:
        {
            TraceEnter("MibSetSysInfo - CLEANUP");

            if (pInput->hkeyMib2) {
                RegCloseKey(pInput->hkeyMib2);
            }

            if(pInput->bLocked)
            {
                ReleaseLock(MIB_II_SYS);
            }

            TraceLeave("MibSetSysInfo");

            return MIB_S_SUCCESS;
        }
        default:
        {
            TraceEnter("MibSetSysInfo - WRONG ACTION");
            TraceLeave("MibSetSysInfo");

            return MIB_S_INVALID_PARAMETER;
        }       
    }
}


DWORD
GetIfIndexFromAddr(
    DWORD dwAddr
    )
{
    DWORD           dwResult, i;
    PMIB_IPADDRROW pRpcIpAddr;
    DWORD           dwIfIndex = INVALID_IFINDEX;
    
    TraceEnter("GetIfIndexFromIpAddr");

    dwResult = UpdateCache(MIB_II_IPADDR);
    
    if(dwResult isnot NO_ERROR)
    {
        TRACE1("Couldnt update IP Addr cache. Error %d", dwResult);

        TraceLeave("GetIfIndexFromIpAddr");

        return dwIfIndex;
    }
    
    EnterReader(MIB_II_IPADDR);

    pRpcIpAddr = &g_Cache.pRpcIpAddrTable->table[0];

    for (i = 0; i < g_Cache.pRpcIpAddrTable->dwNumEntries; i++, pRpcIpAddr++)
    {

        if (dwAddr is pRpcIpAddr->dwAddr)
        {

            dwIfIndex = pRpcIpAddr->dwIndex;
    
            TRACE1("Found exact match. ifIndex %d", dwIfIndex);
            
            break;
        }

        if ((dwIfIndex is INVALID_IFINDEX) and (pRpcIpAddr->dwMask))
        {
            //
            // See if addr is on the same subnet as this address.  
            //

            if ((dwAddr             & pRpcIpAddr->dwMask) is
                (pRpcIpAddr->dwAddr & pRpcIpAddr->dwMask))
            {

                dwIfIndex = pRpcIpAddr->dwIndex;

                TRACE1("Found possible match. ifIndex %d", dwIfIndex);
            }
        }
    }

    ReleaseLock(MIB_II_IPADDR);
    
    TraceLeave("GetIfIndexFromIpAddr");

    return dwIfIndex;    
}

UINT           
MibGetIpv6Group(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )
{
    DWORD           dwResult;
    PIPV6_STATS_GET pOutput;
    MIB_IPSTATS     rpcIpStats;
    
    TraceEnter("MibGetIpv6Group");

    dwResult = GetIpStatisticsEx(&rpcIpStats, AF_INET6);
    
    if(dwResult isnot NO_ERROR)
    {
        TRACE1("Couldnt get IP stats. Error %d",dwResult);

        TraceLeave("MibGetIpGroup");

        if(actionId is MIB_ACTION_GETNEXT)
        {
            return MIB_S_NO_MORE_ENTRIES;
        }

        return MIB_S_ENTRY_NOT_FOUND;
    }

    pOutput = (PIPV6_STATS_GET)objectArray;

    SetAsnInteger(&(pOutput->ipv6Forwarding), rpcIpStats.dwForwarding);
    SetAsnInteger(&(pOutput->ipv6DefaultHopLimit), rpcIpStats.dwDefaultTTL);
    SetAsnUnsigned32(&(pOutput->ipv6Interfaces), rpcIpStats.dwNumIf);
    SetAsnTimeTicks(&(pOutput->ipv6IfTableLastChange), 0);
    SetAsnGauge(&(pOutput->ipv6RouteNumber), rpcIpStats.dwNumRoutes);
    SetAsnCounter(&(pOutput->ipv6DiscardedRoutes), 0);

    TraceLeave("MibGetIpv6Group");

    return MIB_S_SUCCESS;
}

UINT
MibGetIpv6IfEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )
{
    DWORD                 dwResult;
    PMIB_IPV6_IF          pRpcIf;
    PIPV6_IF_GET          pOutput;
    CHAR                  szDescription[MAX_IF_DESCR_LEN + 1];
    
    TraceEnter("MibGetIf6Entry");
    
    dwResult = UpdateCache(MIB_II_IPV6_IF);
    
    if(dwResult isnot NO_ERROR)
    {
        TRACE1("Couldn't update IF cache. Error %d",dwResult);
        TraceLeave("MibGetIfEntry");

        return dwResult;
    }
    
    pOutput = (PIPV6_IF_GET)objectArray;
    
    EnterReader(MIB_II_IPV6_IF);
    
    pRpcIf = LocateIpv6IfRow(actionId,
                             &(pOutput->ipv6IfIndex));
                         
    if(pRpcIf is NULL)
    {
        ReleaseLock(MIB_II_IPV6_IF);

        TRACE2("Unable to locate IF Row. Action is %d. Index is %d",
               actionId,
               GetAsnInteger(&(pOutput->ifIndex),-1));

        TraceLeave("MibGetIfEntry");

        if(actionId is MIB_ACTION_GETNEXT)
        {
            return MIB_S_NO_MORE_ENTRIES;
        }

        return MIB_S_ENTRY_NOT_FOUND;
    }
    
    ForceSetAsnInteger(&(pOutput->ipv6IfIndex),pRpcIf->dwIndex);

    WideCharToMultiByte(CP_UTF8, 0, pRpcIf->wszDescription, -1,
                        szDescription, MAX_IF_DESCR_LEN,
                        NULL, NULL);
    
    SetAsnOctetString(&(pOutput->ipv6IfDescr),
                      pOutput->rgbyIpv6IfDescrInfo,
                      szDescription,
                      min(strlen(szDescription),MAX_IF_DESCR_LEN));

    //
    // Don't implement ifLowerLayer, since it's non-trivial,
    // and is obsoleted in the latest draft updating the RFC.
    //
    SetToZeroOid(&(pOutput->ipv6IfLowerLayer));
    
    SetAsnUnsigned32(&(pOutput->ipv6IfEffectiveMtu), pRpcIf->dwEffectiveMtu);
    SetAsnUnsigned32(&(pOutput->ipv6IfReasmMaxSize), pRpcIf->dwReasmMaxSize);

    //
    // TODO: The EUI-64 is not currently retrievable from user-mode.
    //
    SetAsnOctetString(&(pOutput->ipv6IfIdentifier),
                      pOutput->rgbyIpv6IfIdentifierInfo,
                      NULL,
                      0);
    SetAsnInteger(&(pOutput->ipv6IfIdentifierLength), 0);

    SetAsnOctetString(&(pOutput->ipv6IfPhysicalAddress),
                      pOutput->rgbyIpv6IfPhysicalAddressInfo,
                      pRpcIf->bPhysicalAddress,
                      min(pRpcIf->dwPhysicalAddressLength,MAX_PHYS_ADDR_LEN));

    SetAsnInteger(&(pOutput->ipv6IfAdminStatus), pRpcIf->dwAdminStatus);
    SetAsnInteger(&(pOutput->ipv6IfOperStatus), pRpcIf->dwOperStatus);
    SetAsnTimeTicks(&(pOutput->ipv6IfLastChange), pRpcIf->dwLastChange);

    ReleaseLock(MIB_II_IPV6_IF);
    
    TraceLeave("MibGetIpv6IfEntry");

    return MIB_S_SUCCESS;
}

UINT
MibGetIpv6IfStatsEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )
{
    DWORD              dwResult;
    LONG               IfIndex;
    PIPV6_IF_STATS_GET pOutput = (PIPV6_IF_STATS_GET)objectArray;
    MIB_IPSTATS        rpcIpStats;

    TraceEnter("MibGetIpv6IfStatsEntry");

    IfIndex = GetAsnInteger(&(pOutput->ipv6IfIndex),-1);
    
    if ((actionId is MIB_ACTION_GETNEXT) && (IfIndex >= 0)) 
    {
        TraceLeave("MibGetIpv6IfStatsEntry");
        return MIB_S_NO_MORE_ENTRIES;
    }
    if ((actionId is MIB_ACTION_GET) && (IfIndex != 0)) 
    {
        TraceLeave("MibGetIpv6IfStatsEntry");
        return MIB_S_ENTRY_NOT_FOUND;
    }

    dwResult = GetIpStatisticsEx(&rpcIpStats, AF_INET6);
    
    if(dwResult isnot NO_ERROR)
    {
        TRACE1("Couldn't get IPv6 stats. Error %d",dwResult);

        TraceLeave("MibGetIpv6IfStatsEntry");

        if(actionId is MIB_ACTION_GETNEXT)
        {
            return MIB_S_NO_MORE_ENTRIES;
        }

        return MIB_S_ENTRY_NOT_FOUND;
    }

    ForceSetAsnInteger(&(pOutput->ipv6IfIndex), 0);
    SetAsnCounter(&(pOutput->ipv6IfStatsInReceives), rpcIpStats.dwInReceives);
    SetAsnCounter(&(pOutput->ipv6IfStatsInHdrErrors), rpcIpStats.dwInHdrErrors);
    SetAsnCounter(&(pOutput->ipv6IfStatsInTooBigErrors), 0);
    SetAsnCounter(&(pOutput->ipv6IfStatsInNoRoutes), rpcIpStats.dwOutNoRoutes);
    SetAsnCounter(&(pOutput->ipv6IfStatsInAddrErrors), rpcIpStats.dwInAddrErrors);
    SetAsnCounter(&(pOutput->ipv6IfStatsInUnknownProtos), rpcIpStats.dwInUnknownProtos);
    SetAsnCounter(&(pOutput->ipv6IfStatsInTruncatedPkts), 0);

    SetAsnCounter(&(pOutput->ipv6IfStatsInDiscards), rpcIpStats.dwInDiscards);
    SetAsnCounter(&(pOutput->ipv6IfStatsInDelivers), rpcIpStats.dwInDelivers);

    SetAsnCounter(&(pOutput->ipv6IfStatsOutForwDatagrams), rpcIpStats.dwForwDatagrams);
    SetAsnCounter(&(pOutput->ipv6IfStatsOutRequests), rpcIpStats.dwOutRequests);
    SetAsnCounter(&(pOutput->ipv6IfStatsOutDiscards), rpcIpStats.dwOutDiscards);
    SetAsnCounter(&(pOutput->ipv6IfStatsOutFragOKs), rpcIpStats.dwFragOks);
    SetAsnCounter(&(pOutput->ipv6IfStatsOutFragFails), rpcIpStats.dwFragFails);
    SetAsnCounter(&(pOutput->ipv6IfStatsOutFragCreates), rpcIpStats.dwFragCreates);
    SetAsnCounter(&(pOutput->ipv6IfStatsReasmReqds), rpcIpStats.dwReasmReqds);
    SetAsnCounter(&(pOutput->ipv6IfStatsReasmOKs), rpcIpStats.dwReasmOks);
    SetAsnCounter(&(pOutput->ipv6IfStatsReasmFails), rpcIpStats.dwReasmFails);
    SetAsnCounter(&(pOutput->ipv6IfStatsInMcastPkts), 0);
    SetAsnCounter(&(pOutput->ipv6IfStatsOutMcastPkts), 0);

    TraceLeave("MibGetIpv6IfStatsEntry");

    return MIB_S_SUCCESS;
}

UINT
MibGetInetIcmpEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )
{
    DWORD           dwResult;
    PINET_ICMP_GET pOutput = (PINET_ICMP_GET)objectArray;
    PMIB_INET_ICMP  pRow;

    TraceEnter("MibGetInetIcmpEntry");

    dwResult = UpdateCache(MIB_II_ICMP);

    if(dwResult isnot NO_ERROR)
    {
        TRACE1("Couldn't update ICMP cache. Error %d",dwResult);
        TraceLeave("MibGetInetIcmpEntry");

        return dwResult;
    }

    EnterReader(MIB_II_ICMP);

    pOutput = (PINET_ICMP_GET)objectArray;

    pRow = LocateInetIcmpRow(actionId,
                             &(pOutput->inetIcmpAFType),
                             &(pOutput->inetIcmpIfIndex));

    if(pRow is NULL)
    {
        ReleaseLock(MIB_II_ICMP);

        TRACE0("Unable to locate icmp row");

        TraceLeave("MibGetInetIcmpEntry");

        if(actionId is MIB_ACTION_GETNEXT)
        {
            return MIB_S_NO_MORE_ENTRIES;
        }

        return MIB_S_ENTRY_NOT_FOUND;
    }

    ForceSetAsnInteger(&(pOutput->inetIcmpAFType), pRow->dwAFType);
    ForceSetAsnInteger(&(pOutput->inetIcmpIfIndex), pRow->dwIfIndex);

    SetAsnCounter(&(pOutput->inetIcmpInMsgs), pRow->dwInMsgs);
    SetAsnCounter(&(pOutput->inetIcmpInErrors), pRow->dwInErrors);
    SetAsnCounter(&(pOutput->inetIcmpOutMsgs), pRow->dwOutMsgs);
    SetAsnCounter(&(pOutput->inetIcmpOutErrors), pRow->dwOutErrors);

    ReleaseLock(MIB_II_ICMP);

    TraceLeave("MibGetInetIcmpEntry");

    return MIB_S_SUCCESS;
}

UINT
MibGetInetIcmpMsgEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )
{
    DWORD              dwResult;
    PINET_ICMP_MSG_GET pOutput = (PINET_ICMP_MSG_GET)objectArray;
    PMIB_INET_ICMP_MSG pRow;

    TraceEnter("MibGetInetIcmpMsgEntry");

    dwResult = UpdateCache(MIB_II_ICMP);

    if(dwResult isnot NO_ERROR)
    {
        TRACE1("Couldnt update ICMP cache. Error %d",dwResult);
        TraceLeave("MibGetInetIcmpMsgEntry");

        return dwResult;
    }

    EnterReader(MIB_II_ICMP);

    pOutput = (PINET_ICMP_MSG_GET)objectArray;

    pRow = LocateInetIcmpMsgRow(actionId,
                                &(pOutput->inetIcmpMsgAFType),
                                &(pOutput->inetIcmpMsgIfIndex),
                                &(pOutput->inetIcmpMsgType),
                                &(pOutput->inetIcmpMsgCode));

    if(pRow is NULL)
    {
        ReleaseLock(MIB_II_ICMP);

        TRACE0("Unable to locate icmp row");

        TraceLeave("MibGetInetIcmpMsgEntry");

        if(actionId is MIB_ACTION_GETNEXT)
        {
            return MIB_S_NO_MORE_ENTRIES;
        }

        return MIB_S_ENTRY_NOT_FOUND;
    }

    ForceSetAsnInteger(&(pOutput->inetIcmpMsgAFType), pRow->dwAFType);
    ForceSetAsnInteger(&(pOutput->inetIcmpMsgIfIndex), pRow->dwIfIndex);
    ForceSetAsnInteger(&(pOutput->inetIcmpMsgType), pRow->dwType);
    ForceSetAsnInteger(&(pOutput->inetIcmpMsgCode), pRow->dwCode);

    SetAsnCounter(&(pOutput->inetIcmpMsgInPkts), pRow->dwInPkts);
    SetAsnCounter(&(pOutput->inetIcmpMsgOutPkts), pRow->dwOutPkts);

    ReleaseLock(MIB_II_ICMP);

    TraceLeave("MibGetInetIcmpMsgEntry");

    return MIB_S_SUCCESS;
}

UINT
MibGetIpv6AddrEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )
{
    DWORD          dwResult;
    PIPV6_ADDR_GET pOutput;
    PMIB_IPV6_ADDR pAddr;
    
    TraceEnter("MibGetIpv6AddrEntry");

    dwResult = UpdateCache(MIB_II_IPV6_IF);

    if(dwResult isnot NO_ERROR)
    {
        TRACE1("Couldn't update IPv6 address cache. Error %d",dwResult);
        TraceLeave("MibGetIpv6AddrEntry");

        return dwResult;
    }

    EnterReader(MIB_II_IPV6_IF);

    pOutput = (PIPV6_ADDR_GET)objectArray;

    pAddr = LocateIpv6AddrRow(actionId,
                              &(pOutput->ipv6IfIndex),
                              &(pOutput->ipv6AddrAddress));

    if(pAddr is NULL)
    {
        ReleaseLock(MIB_II_IPV6_IF);

        TRACE0("Unable to locate IPv6 address row");

        TraceLeave("MibGetIpv6AddrEntry");

        if(actionId is MIB_ACTION_GETNEXT)
        {
            return MIB_S_NO_MORE_ENTRIES;
        }

        return MIB_S_ENTRY_NOT_FOUND;
    }

    ForceSetAsnInteger(&(pOutput->ipv6IfIndex), pAddr->dwIfIndex);
    ForceSetAsnOctetString(&(pOutput->ipv6AddrAddress),
                           &pOutput->ipv6AddrAddressInfo,
                           &pAddr->ipAddress,
                           sizeof(IN6_ADDR));

    SetAsnInteger(&(pOutput->ipv6AddrPfxLength), pAddr->dwPrefixLength);
    SetAsnInteger(&(pOutput->ipv6AddrType), pAddr->dwType);
    SetAsnInteger(&(pOutput->ipv6AddrAnycastFlag), pAddr->dwAnycastFlag);
    SetAsnInteger(&(pOutput->ipv6AddrStatus), pAddr->dwStatus);

    ReleaseLock(MIB_II_IPV6_IF);

    TraceLeave("MibGetIpv6AddrEntry");

    return MIB_S_SUCCESS;
}

UINT
MibGetIpv6AddrPrefixEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )
{
    DWORD           dwResult;
    PIPV6_ADDR_PREFIX_GET pOutput;
    PMIB_IPV6_ADDR_PREFIX pRow;
    
    TraceEnter("MibGetIpv6AddrPrefixEntry");

    dwResult = UpdateCache(MIB_II_IPV6_ROUTE);

    if(dwResult isnot NO_ERROR)
    {
        TRACE1("Couldn't update IPv6 addr prefix table. Error %d",dwResult);
        TraceLeave("MibGetIpv6AddrPrefixEntry");

        if(actionId is MIB_ACTION_GETNEXT)
        {
            return MIB_S_NO_MORE_ENTRIES;
        }

        return MIB_S_ENTRY_NOT_FOUND;
    }

    EnterReader(MIB_II_IPV6_ROUTE);

    pOutput = (PIPV6_ADDR_PREFIX_GET)objectArray;

    pRow = LocateIpv6AddrPrefixRow(actionId,
                                   &(pOutput->ipv6IfIndex),
                                   &(pOutput->ipv6AddrPrefix),
                                   &(pOutput->ipv6AddrPrefixLength));

    if(pRow is NULL)
    {
        ReleaseLock(MIB_II_IPV6_ROUTE);

        TRACE0("Unable to locate IPv6 route row");

        TraceLeave("MibGetIpv6AddrPrefixEntry");

        if(actionId is MIB_ACTION_GETNEXT)
        {
            return MIB_S_NO_MORE_ENTRIES;
        }

        return MIB_S_ENTRY_NOT_FOUND;
    }

    ForceSetAsnInteger(&(pOutput->ipv6IfIndex), pRow->dwIfIndex);
    ForceSetAsnOctetString(&(pOutput->ipv6AddrPrefix),
                           &pOutput->ipv6AddrPrefixInfo,
                           &pRow->ipPrefix,
                           sizeof(IN6_ADDR));
    ForceSetAsnInteger(&(pOutput->ipv6AddrPrefixLength), pRow->dwPrefixLength);

    SetAsnInteger(&(pOutput->ipv6AddrPrefixOnLinkFlag), pRow->dwOnLinkFlag);
    SetAsnInteger(&(pOutput->ipv6AddrPrefixAutonomousFlag), 
                  pRow->dwAutonomousFlag);
    SetAsnUnsigned32(&(pOutput->ipv6AddrPrefixAdvPreferredLifetime), 
                     pRow->dwPreferredLifetime);
    SetAsnUnsigned32(&(pOutput->ipv6AddrPrefixAdvValidLifetime), 
                     pRow->dwValidLifetime);

    ReleaseLock(MIB_II_IPV6_ROUTE);

    TraceLeave("MibGetIpv6AddrPrefixEntry");

    return MIB_S_SUCCESS;
}

UINT
MibGetIpv6RouteEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )
{
    DWORD           dwResult;
    PIPV6_ROUTE_GET pOutput;
    PMIB_IPV6_ROUTE pRow;
    
    TraceEnter("MibGetIpv6RouteEntry");

    dwResult = UpdateCache(MIB_II_IPV6_ROUTE);

    if(dwResult isnot NO_ERROR)
    {
        TRACE1("Couldn't update IPv6 route table. Error %d",dwResult);
        TraceLeave("MibGetIpv6RouteEntry");

        if(actionId is MIB_ACTION_GETNEXT)
        {
            return MIB_S_NO_MORE_ENTRIES;
        }

        return MIB_S_ENTRY_NOT_FOUND;
    }

    EnterReader(MIB_II_IPV6_ROUTE);

    pOutput = (PIPV6_ROUTE_GET)objectArray;

    pRow = LocateIpv6RouteRow(actionId,
                              &(pOutput->ipv6RouteDest),
                              &(pOutput->ipv6RoutePfxLength),
                              &(pOutput->ipv6RouteIndex));

    if(pRow is NULL)
    {
        ReleaseLock(MIB_II_IPV6_ROUTE);

        TRACE0("Unable to locate IPv6 route row");

        TraceLeave("MibGetIpv6RouteEntry");

        if(actionId is MIB_ACTION_GETNEXT)
        {
            return MIB_S_NO_MORE_ENTRIES;
        }

        return MIB_S_ENTRY_NOT_FOUND;
    }

    ForceSetAsnOctetString(&(pOutput->ipv6RouteDest),
                      &pOutput->ipv6RouteDestInfo,
                      &pRow->ipPrefix,
                      sizeof(IN6_ADDR));
    ForceSetAsnInteger(&(pOutput->ipv6RoutePfxLength), pRow->dwPrefixLength);
    ForceSetAsnInteger(&(pOutput->ipv6RouteIndex), pRow->dwIndex);

    SetAsnInteger(&(pOutput->ipv6RouteIfIndex), pRow->dwIfIndex);
    SetAsnOctetString(&(pOutput->ipv6RouteNextHop),
                      &pOutput->ipv6RouteNextHopInfo,
                      &pRow->ipNextHop,
                      sizeof(IN6_ADDR));
    SetAsnInteger(&(pOutput->ipv6RouteType), pRow->dwType);
    SetAsnInteger(&(pOutput->ipv6RouteProtocol), pRow->dwProtocol);
    SetAsnInteger(&(pOutput->ipv6RoutePolicy), pRow->dwPolicy);
    SetAsnUnsigned32(&(pOutput->ipv6RouteAge), pRow->dwAge);
    SetAsnUnsigned32(&(pOutput->ipv6RouteNextHopRDI), pRow->dwNextHopRDI);
    SetAsnUnsigned32(&(pOutput->ipv6RouteMetric), pRow->dwMetric);
    SetAsnUnsigned32(&(pOutput->ipv6RouteWeight), pRow->dwWeight);
    SetToZeroOid(&(pOutput->ipv6RouteInfo));
    SetAsnInteger(&(pOutput->ipv6RouteValid), pRow->dwValid);

    ReleaseLock(MIB_II_IPV6_ROUTE);

    TraceLeave("MibGetIpv6RouteEntry");

    return MIB_S_SUCCESS;
}

UINT
MibGetIpv6NetToMediaEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    )
{
    DWORD                  dwResult;
    PIPV6_NET_TO_MEDIA_GET pOutput;
    PMIB_IPV6_NET_TO_MEDIA pRow;
    
    TraceEnter("MibGetIpv6NetToMediaEntry");

    dwResult = UpdateCache(MIB_II_IPV6_NET_TO_MEDIA);

    if(dwResult isnot NO_ERROR)
    {
        TRACE1("Couldn't update IPv6 neighbor cache. Error %d",dwResult);
        TraceLeave("MibGetIpv6NetToMediaEntry");

        if(actionId is MIB_ACTION_GETNEXT)
        {
            return MIB_S_NO_MORE_ENTRIES;
        }

        return MIB_S_ENTRY_NOT_FOUND;
    }

    EnterReader(MIB_II_IPV6_NET_TO_MEDIA);

    pOutput = (PIPV6_NET_TO_MEDIA_GET)objectArray;

    pRow = LocateIpv6NetToMediaRow(actionId,
                              &(pOutput->ipv6IfIndex),
                              &(pOutput->ipv6NetToMediaNetAddress));

    if(pRow is NULL)
    {
        ReleaseLock(MIB_II_IPV6_NET_TO_MEDIA);

        TRACE0("Unable to locate IPv6 neighbor row");

        TraceLeave("MibGetIpv6NetToMediaEntry");

        if(actionId is MIB_ACTION_GETNEXT)
        {
            return MIB_S_NO_MORE_ENTRIES;
        }

        return MIB_S_ENTRY_NOT_FOUND;
    }

    ForceSetAsnInteger(&(pOutput->ipv6IfIndex), pRow->dwIfIndex);
    ForceSetAsnOctetString(&(pOutput->ipv6NetToMediaNetAddress),
                           &pOutput->ipv6NetToMediaNetAddressInfo,
                           &pRow->ipAddress,
                           sizeof(IN6_ADDR));

    SetAsnOctetString(&(pOutput->ipv6NetToMediaPhysAddress),
                      pOutput->ipv6NetToMediaPhysAddressInfo,
                      pRow->bPhysAddress,
                      min(pRow->dwPhysAddressLen,MAX_PHYS_ADDR_LEN));
    SetAsnInteger(&(pOutput->ipv6NetToMediaType), pRow->dwType);
    SetAsnInteger(&(pOutput->ipv6NetToMediaState), pRow->dwState);
    SetAsnTimeTicks(&(pOutput->ipv6NetToMediaLastUpdated), pRow->dwLastUpdated);
    SetAsnInteger(&(pOutput->ipv6NetToMediaValid), pRow->dwValid);

    ReleaseLock(MIB_II_IPV6_NET_TO_MEDIA);

    TraceLeave("MibGetIpv6NetToMediaEntry");

    return MIB_S_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\snmp\trap.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:


Abstract:


Author:


Revision History:

--*/

#include "allinc.h"

static UINT rguiIfEntryIndexList[] = { 1, 3, 6, 1, 2, 1, 2, 2, 1, 1, 0};
static AsnObjectIdentifier aoiIfLinkIndexOid = {sizeof(rguiIfEntryIndexList) / sizeof (UINT),
                                                rguiIfEntryIndexList};

BOOL
MibTrap(
        AsnInteger          *paiGenericTrap,
        AsnInteger          *paiSpecificTrap,
        RFC1157VarBindList  *pr1157vblVariableBindings
        )

/*++

Routine Description
      
  
Locks 


Arguments
      

Return Value

    NO_ERROR

--*/

{
    AsnInteger      NumberOfLinks;
    AsnInteger      LinkNumber;
    AsnInteger      errorStatus;
    RFC1157VarBind  my_item;
    DWORD           i, j, dwResult, dwIndex;
    BOOL            bFound;
    
    TraceEnter("MibTrap");

    if(g_Cache.pRpcIfTable is NULL)
    {
        TRACE0("IF Cache not setup");

        UpdateCache(MIB_II_IF);

        TraceLeave("MibTrap");

        return FALSE;
    }
    
    EnterWriter(MIB_II_TRAP);
    
    if(g_dwValidStatusEntries is 0)
    {

        TRACE0("Status table is empty");

        //
        // This is the case where we are being polled for the first time ever, or
        // we have cycled once through all the interfaces and the poll timer has
        // fired again
        //

        //
        // We check the amount of memory needed and copy out the contents of
        // the current IF cache
        //

        EnterReader(MIB_II_IF);
        
        if((g_dwTotalStatusEntries < g_Cache.pRpcIfTable->dwNumEntries) or
           (g_dwTotalStatusEntries > g_Cache.pRpcIfTable->dwNumEntries + MAX_DIFF))
        {
            if(g_pisStatusTable isnot NULL)
            {
                HeapFree(g_hPrivateHeap,
                         0,
                         g_pisStatusTable);
            }

            g_pisStatusTable =
                HeapAlloc(g_hPrivateHeap,
                          0,
                          sizeof(MIB_IFSTATUS) * (g_Cache.pRpcIfTable->dwNumEntries + SPILLOVER));

            if(g_pisStatusTable is NULL)
            {
                TRACE2("Error %d allocating %d bytes for status table",
                       GetLastError(),
                       sizeof(MIB_IFSTATUS) * (g_Cache.pRpcIfTable->dwNumEntries + SPILLOVER));

                ReleaseLock(MIB_II_IF);

                ReleaseLock(MIB_II_TRAP);

                TraceLeave("MibTrap");

                return FALSE;
            }

            g_dwTotalStatusEntries   = g_Cache.pRpcIfTable->dwNumEntries + SPILLOVER;
        }    

        //
        // Copy out the oper status
        //
        
        for(i = 0; i < g_Cache.pRpcIfTable->dwNumEntries; i++)
        {
            g_pisStatusTable[i].dwIfIndex  = 
                g_Cache.pRpcIfTable->table[i].dwIndex;

            if(g_bFirstTime)
            {
                g_pisStatusTable[i].dwOperationalStatus = 
                    IF_OPER_STATUS_NON_OPERATIONAL;
            }
            else
            {
                g_pisStatusTable[i].dwOperationalStatus = 
                    g_Cache.pRpcIfTable->table[i].dwOperStatus;
            }
        }
       
        if(g_bFirstTime)
        {
            g_bFirstTime = FALSE;
        }
 
        g_dwValidStatusEntries = g_Cache.pRpcIfTable->dwNumEntries;
        
        ReleaseLock(MIB_II_IF);
    }

    dwResult = UpdateCache(MIB_II_IF);
    
    if(dwResult isnot NO_ERROR)
    {
        TRACE1("Error %d updating IF cache",
               dwResult);

        ReleaseLock(MIB_II_TRAP);

        return FALSE;
    }

    EnterReader(MIB_II_IF);
    
    bFound = FALSE;
    
    for(i = 0;
        (i < g_Cache.pRpcIfTable->dwNumEntries) and !bFound;
        i++)
    {
        //
        // Loop till we reach the end of the table or we find the first
        // I/F whose status is different
        //
        
        for(j = 0; j < g_dwValidStatusEntries; j++)
        {
            if(g_pisStatusTable[j].dwIfIndex > g_Cache.pRpcIfTable->table[i].dwIndex)
            {
                //
                // We have passed the index in the array. It cant be after this
                // point since the tables are ordered
                //

                dwIndex = i;
                bFound  = TRUE;

                //
                // Since we have a new I/F we need to reread the StatusTable
                // If we dont then we will always hit this interface and get
                // stuck in a loop
                //

                g_dwValidStatusEntries   = 0;
    
                TRACE1("IF index %d not found in status table",
                       g_Cache.pRpcIfTable->table[i].dwIndex);

                break;
            }
            
            if(g_pisStatusTable[j].dwIfIndex is g_Cache.pRpcIfTable->table[i].dwIndex)
            {
                if(g_pisStatusTable[j].dwOperationalStatus isnot g_Cache.pRpcIfTable->table[i].dwOperStatus)
                {
                    //
                    // Its changed
                    //
                   
                    TRACE2("Status changed for IF %d. New status is %d",
                           g_Cache.pRpcIfTable->table[i].dwIndex,
                           g_Cache.pRpcIfTable->table[i].dwOperStatus);
 
                    g_pisStatusTable[j].dwOperationalStatus = 
                        g_Cache.pRpcIfTable->table[i].dwOperStatus;

                    dwIndex = i;
                    bFound  = TRUE;
                }

                //
                // Try the next i/f or break out of outer loop depending
                // on bFound
                //
                
                break;
            }
        }
    }

    if(!bFound)
    {
        //
        // No i/f found whose status had changed. Set valid entries to 0 so that
        // next time around we reread the cache
        //
        
        g_dwValidStatusEntries   = 0;
        
        ReleaseLock(MIB_II_IF);

        ReleaseLock(MIB_II_TRAP);

        TraceLeave("MibTrap");

        return FALSE;
    }
    
    if(g_Cache.pRpcIfTable->table[dwIndex].dwOperStatus is IF_ADMIN_STATUS_UP)
    {
        *paiGenericTrap = SNMP_GENERICTRAP_LINKUP;
    }
    else
    {
        *paiGenericTrap = SNMP_GENERICTRAP_LINKDOWN;
    }

    
    pr1157vblVariableBindings->list = (RFC1157VarBind *)SnmpUtilMemAlloc((sizeof(RFC1157VarBind)));

    if (pr1157vblVariableBindings->list is NULL)
    {
        ReleaseLock(MIB_II_IF);

        ReleaseLock(MIB_II_TRAP);

        TraceLeave("MibTrap");

        return FALSE;
    }

    pr1157vblVariableBindings->len  = 1;
    
    SnmpUtilOidCpy(&((pr1157vblVariableBindings->list)->name),
                   &aoiIfLinkIndexOid);
    
    (pr1157vblVariableBindings->list)->name.ids[10]     = 
        g_Cache.pRpcIfTable->table[dwIndex].dwIndex;

    (pr1157vblVariableBindings->list)->value.asnType    = ASN_INTEGER;
   
    (pr1157vblVariableBindings->list)->value.asnValue.number   = g_Cache.pRpcIfTable->table[dwIndex].dwIndex; 
    
    *paiSpecificTrap = 0;

    ReleaseLock(MIB_II_IF);

    ReleaseLock(MIB_II_TRAP);

    TraceLeave("MibTrap");

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\snmp\proto.h ===
#ifndef __PROTO_H__
#define __PROTO_H__

PMIB_IFROW
LocateIfRow(
            DWORD  dwQueryType, 
            AsnAny *paaIfIndex
            );
PMIB_IPADDRROW
LocateIpAddrRow(
                DWORD  dwQueryType, 
                AsnAny *paaIpAddr
                );
PMIB_IPFORWARDROW
LocateIpRouteRow(
                 DWORD  dwQueryType ,
                 AsnAny *paaIpDest
                 );
PMIB_IPFORWARDROW
LocateIpForwardRow(
                   DWORD  dwQueryType, 
                   AsnAny *paaDest,
                   AsnAny *paaProto,
                   AsnAny *paaPolicy,
                   AsnAny *paaNextHop
                   );
PMIB_IPNETROW
LocateIpNetRow(
               DWORD  dwQueryType, 
               AsnAny *paaIndex,
               AsnAny *paaAddr
               );
PMIB_UDPROW
LocateUdpRow(
             DWORD  dwQueryType, 
             AsnAny *paaLocalAddr,
             AsnAny *paaLocalPort
             );
PUDP6ListenerEntry
LocateUdp6Row(
             DWORD  dwQueryType, 
             AsnAny *paaLocalAddr,
             AsnAny *paaLocalPort
             );
PMIB_TCPROW
LocateTcpRow(
             DWORD  dwQueryType, 
             AsnAny *paaLocalAddr,
             AsnAny *paaLocalPort,
             AsnAny *paaRemoteAddr,
             AsnAny *paaRemotePort
             );
PTCP6ConnTableEntry
LocateTcp6Row(
             DWORD  dwQueryType, 
             AsnAny *paaLocalAddr,
             AsnAny *paaLocalPort,
             AsnAny *paaRemoteAddr,
             AsnAny *paaRemotePort
             );

typedef struct _MIB_IPV6_IF {
    DWORD dwIndex;
    DWORD dwEffectiveMtu;
    DWORD dwReasmMaxSize;
    DWORD dwAdminStatus;
    DWORD dwOperStatus;
    DWORD dwLastChange;
    BYTE  bPhysicalAddress[MAX_PHYS_ADDR_LEN];
    DWORD dwPhysicalAddressLength;
    WCHAR wszDescription[MAX_IF_DESCR_LEN + 1];
}MIB_IPV6_IF, *PMIB_IPV6_IF;

PMIB_IPV6_IF
LocateIpv6IfRow(
            DWORD  dwQueryType,
            AsnAny *paaIfIndex
            );

typedef struct _MIB_INET_ICMP {
    DWORD dwAFType;
    DWORD dwIfIndex;
    DWORD dwInMsgs;
    DWORD dwInErrors;
    DWORD dwOutMsgs;
    DWORD dwOutErrors;
}MIB_INET_ICMP, *PMIB_INET_ICMP;

PMIB_INET_ICMP
LocateInetIcmpRow(
            DWORD  dwQueryType,
            AsnAny *paaAFType,
            AsnAny *paaIfIndex
            );

typedef struct _MIB_INET_ICMP_MSG {
    DWORD dwAFType;
    DWORD dwIfIndex;
    DWORD dwType;
    DWORD dwCode;
    DWORD dwInPkts;
    DWORD dwOutPkts;
}MIB_INET_ICMP_MSG, *PMIB_INET_ICMP_MSG;

PMIB_INET_ICMP_MSG
LocateInetIcmpMsgRow(
            DWORD  dwQueryType,
            AsnAny *paaAFType,
            AsnAny *paaIfIndex,
            AsnAny *paaType,
            AsnAny *paaCode
            );

typedef struct _MIB_IPV6_ADDR {
    DWORD    dwIfIndex;
    IN6_ADDR ipAddress;
    DWORD    dwPrefixLength;
    DWORD    dwType;
    DWORD    dwAnycastFlag;
    DWORD    dwStatus;
}MIB_IPV6_ADDR, *PMIB_IPV6_ADDR;

PMIB_IPV6_ADDR
LocateIpv6AddrRow(
            DWORD  dwQueryType,
            AsnAny *paaIfIndex,
            AsnAny *paaAddress
            );

typedef struct _MIB_IPV6_ADDR_PREFIX {
    DWORD    dwIfIndex;
    IN6_ADDR ipPrefix;
    DWORD    dwPrefixLength;
    DWORD    dwOnLinkFlag;
    DWORD    dwAutonomousFlag;
    DWORD    dwPreferredLifetime;
    DWORD    dwValidLifetime;
}MIB_IPV6_ADDR_PREFIX, *PMIB_IPV6_ADDR_PREFIX;

PMIB_IPV6_ADDR_PREFIX
LocateIpv6AddrPrefixRow(
            DWORD  dwQueryType,
            AsnAny *paaIfIndex,
            AsnAny *paaPrefix,
            AsnAny *paaPrefixLength
            );

typedef struct _MIB_IPV6_NET_TO_MEDIA {
    DWORD    dwIfIndex;
    IN6_ADDR ipAddress;
    BOOL     bPhysAddress[MAX_PHYS_ADDR_LEN];
    DWORD    dwPhysAddressLen;
    DWORD    dwType; 
    DWORD    dwState; 
    DWORD    dwLastUpdated; 
    DWORD    dwValid; 
}MIB_IPV6_NET_TO_MEDIA, *PMIB_IPV6_NET_TO_MEDIA;

PMIB_IPV6_NET_TO_MEDIA
LocateIpv6NetToMediaRow(
            DWORD  dwQueryType,
            AsnAny *paaIfIndex,
            AsnAny *paaAddress
            );

typedef struct _MIB_IPV6_ROUTE {
    IN6_ADDR ipPrefix;
    DWORD    dwPrefixLength;
    IN6_ADDR ipNextHop;
    DWORD    dwIndex;
    DWORD    dwIfIndex;
    DWORD    dwType;
    DWORD    dwProtocol;
    DWORD    dwPolicy;
    DWORD    dwAge;
    DWORD    dwNextHopRDI;
    DWORD    dwMetric;
    DWORD    dwWeight;
    DWORD    dwValid;
}MIB_IPV6_ROUTE, *PMIB_IPV6_ROUTE;

PMIB_IPV6_ROUTE
LocateIpv6RouteRow(
            DWORD  dwQueryType,
            AsnAny *paaPrefix,
            AsnAny *paaPrefixLength,
            AsnAny *paaIndex
            );

DWORD
LoadSystem(VOID);

DWORD
LoadIfTable(VOID);

DWORD
LoadIpAddrTable(VOID);

DWORD
LoadIpNetTable(VOID);

DWORD
LoadIpForwardTable(VOID);

DWORD
LoadTcpTable(VOID);

DWORD
LoadTcp6Table(VOID);

DWORD
LoadUdpTable(VOID);

DWORD
LoadUdp6ListenerTable(VOID);

DWORD
LoadIpv6IfTable(VOID);

DWORD
LoadIpv6NetToMediaTable(VOID);

DWORD
LoadIpv6RouteTable(VOID);

DWORD
LoadInetIcmpTable(VOID);

DWORD
GetIpStats(MIB_IPSTATS *pStats);

DWORD
GetIcmpStats(MIB_ICMP *pStats);

DWORD
GetTcpStats(MIB_TCPSTATS *pStats);

DWORD
GetUdpStats(MIB_UDPSTATS *pStats);

DWORD
SetIfRow(PMIB_OPAQUE_INFO pRpcRow);

DWORD
CreateIpForwardRow(PMIB_OPAQUE_INFO pRpcRow);

DWORD
SetIpForwardRow(PMIB_OPAQUE_INFO pRpcRow);

DWORD
DeleteIpForwardRow(PMIB_OPAQUE_INFO pRpcRow);

DWORD
SetIpStats(PMIB_OPAQUE_INFO pRpcRow);

DWORD
CreateIpNetRow(PMIB_OPAQUE_INFO pRpcRow);

DWORD
SetIpNetRow(PMIB_OPAQUE_INFO pRpcRow);

DWORD
DeleteIpNetRow(PMIB_OPAQUE_INFO pRpcRow);

DWORD
SetTcpRow(PMIB_OPAQUE_INFO pRpcRow);

LONG  
UdpCmp(
       DWORD dwAddr1, 
       DWORD dwPort1, 
       DWORD dwAddr2, 
       DWORD dwPort2
       );

LONG
Udp6Cmp(
       BYTE  rgbyLocalAddrEx1[20], 
       DWORD dwLocalPort1, 
       BYTE  rgbyLocalAddrEx2[20], 
       DWORD dwLocalPort2
       );
             
LONG  
TcpCmp(
       DWORD dwLocalAddr1, 
       DWORD dwLocalPort1, 
       DWORD dwRemAddr1, 
       DWORD dwRemPort1,
       DWORD dwLocalAddr2, 
       DWORD dwLocalPort2, 
       DWORD dwRemAddr2, 
       DWORD dwRemPort2
       );
LONG  
Tcp6Cmp(
       BYTE  rgbyLocalAddrEx1[20], 
       DWORD dwLocalPort1, 
       BYTE  rgbyRemAddrEx1[20], 
       DWORD dwRemPort1,
       BYTE  rgbyLocalAddrEx2[20], 
       DWORD dwLocalPort2, 
       BYTE  rgbyRemAddrEx2[20], 
       DWORD dwRemPort2
       );

LONG  
IpForwardCmp(DWORD dwIpDest1, 
             DWORD dwProto1, 
             DWORD dwPolicy1, 
             DWORD dwIpNextHop1, 
             DWORD dwIpDest2, 
             DWORD dwProto2, 
             DWORD dwPolicy2, 
             DWORD dwIpNextHop2
             );
             
LONG  
IpNetCmp(
         DWORD dwIfIndex1, 
         DWORD dwAddr1, 
         DWORD dwIfIndex2, 
         DWORD dwAddr2
         );

DWORD 
UpdateCache(DWORD dwCache);

BOOL
IsRouterRunning();

DWORD
GetSysInfo(
           MIB_SYSINFO  **ppRpcSysInfo,
           HANDLE       hHeap,
           DWORD        dwAllocFlags
           );

DWORD
GetIfIndexFromAddr(
    DWORD dwAddr
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\snmp\mibfuncs.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:


Abstract:


Author:


Revision History:

--*/

#ifndef __MIBFUNCS_H__
#define __MIBFUNCS_H__

#define MAX_SYS_NAME_LEN                   256
#define MAX_SYS_DESCR_LEN                  256
#define MAX_SYS_CONTACT_LEN                256
#define MAX_SYS_LOCATION_LEN               256

typedef struct _MIB_SYSINFO 
{
    DWORD  dwSysServices;                      
    BYTE   rgbySysName[MAX_SYS_NAME_LEN];
    BYTE   rgbySysDescr[MAX_SYS_DESCR_LEN];
    BYTE   rgbySysContact[MAX_SYS_CONTACT_LEN];
    BYTE   rgbySysLocation[MAX_SYS_LOCATION_LEN];
    AsnAny aaSysObjectID;
} MIB_SYSINFO, *PMIB_SYSINFO;

typedef struct _SYS_INFO_GET
{
    AsnAny sysDescr;                         
    AsnAny sysObjectID;                      
    AsnAny sysUpTime;                        
    AsnAny sysContact;                       
    AsnAny sysName;                          
    AsnAny sysLocation;                      
    AsnAny sysServices;                      
    BYTE   rgbySysNameInfo[MAX_SYS_NAME_LEN];
    BYTE   rgbySysDescrInfo[MAX_SYS_DESCR_LEN];
    BYTE   rgbySysContactInfo[MAX_SYS_CONTACT_LEN];
    BYTE   rgbySysLocationInfo[MAX_SYS_LOCATION_LEN];
} SYS_INFO_GET, *PSYS_INFO_GET;

typedef struct _SYS_INFO_SET
{
    AsnAny  sysContact;                       
    AsnAny  sysName;                          
    AsnAny  sysLocation;
    BOOL    bLocked;  
    HKEY    hkeyMib2;                    
    BYTE    rgbySysNameInfo[MAX_SYS_NAME_LEN];
    BYTE    rgbySysContactInfo[MAX_SYS_CONTACT_LEN];
    BYTE    rgbySysLocationInfo[MAX_SYS_LOCATION_LEN];
} SYS_INFO_SET, *PSYS_INFO_SET;

UINT
MibGetSysInfo(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

UINT
MibSetSysInfo(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define gf_sysDescr                        MibGetSysInfo
#define gf_sysObjectID                     MibGetSysInfo
#define gf_sysUpTime                       MibGetSysInfo
#define gf_sysContact                      MibGetSysInfo
#define gf_sysName                         MibGetSysInfo
#define gf_sysLocation                     MibGetSysInfo
#define gf_sysServices                     MibGetSysInfo

#define gb_sysDescr                        SYS_INFO_GET
#define gb_sysObjectID                     SYS_INFO_GET
#define gb_sysUpTime                       SYS_INFO_GET
#define gb_sysContact                      SYS_INFO_GET
#define gb_sysName                         SYS_INFO_GET
#define gb_sysLocation                     SYS_INFO_GET
#define gb_sysServices                     SYS_INFO_GET

#define sf_sysContact                      MibSetSysInfo
#define sf_sysName                         MibSetSysInfo
#define sf_sysLocation                     MibSetSysInfo

#define sb_sysContact                      SYS_INFO_SET
#define sb_sysName                         SYS_INFO_SET
#define sb_sysLocation                     SYS_INFO_SET

#define MAX_PHYS_ADDR_LEN                  8
#define MAX_IF_DESCR_LEN                   256
#define NULL_OID_LEN                       2

typedef enum _ROW_ACTION
{
    DELETE_ROW = 0,
    CREATE_ROW,
    SET_ROW,
    NOP
}ROW_ACTION, *PROW_ACTION;

typedef struct _IF_NUMBER_GET
{
    AsnAny ifNumber;
}IF_NUMBER_GET,*PIF_NUMBER_GET;

UINT
MibGetIfNumber(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define gf_ifNumber                         MibGetIfNumber

#define gb_ifNumber                         IF_NUMBER_GET

typedef struct _IF_ENTRY_GET
{
    AsnAny ifIndex;
    AsnAny ifDescr;
    AsnAny ifType;
    AsnAny ifMtu;
    AsnAny ifSpeed;
    AsnAny ifPhysAddress;
    AsnAny ifAdminStatus;
    AsnAny ifOperStatus;
    AsnAny ifLastChange;
    AsnAny ifInOctets;
    AsnAny ifInUcastPkts;
    AsnAny ifInNUcastPkts;
    AsnAny ifInDiscards;
    AsnAny ifInErrors;
    AsnAny ifInUnknownProtos;
    AsnAny ifOutOctets;
    AsnAny ifOutUcastPkts;
    AsnAny ifOutNUcastPkts;
    AsnAny ifOutDiscards;
    AsnAny ifOutErrors;
    AsnAny ifOutQLen;
    AsnAny ifSpecific;
    BYTE   rgbyIfPhysAddressInfo[MAX_PHYS_ADDR_LEN];
    BYTE   rgbyIfDescrInfo[MAX_IF_DESCR_LEN];
}IF_ENTRY_GET, *PIF_ENTRY_GET;

UINT 
MibGetIfEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define gf_ifEntry                          MibGetIfEntry
#define gf_ifIndex                          MibGetIfEntry
#define gf_ifDescr                          MibGetIfEntry
#define gf_ifType                           MibGetIfEntry
#define gf_ifMtu                            MibGetIfEntry
#define gf_ifSpeed                          MibGetIfEntry
#define gf_ifPhysAddress                    MibGetIfEntry
#define gf_ifAdminStatus                    MibGetIfEntry
#define gf_ifOperStatus                     MibGetIfEntry
#define gf_ifLastChange                     MibGetIfEntry
#define gf_ifInOctets                       MibGetIfEntry
#define gf_ifInUcastPkts                    MibGetIfEntry
#define gf_ifInNUcastPkts                   MibGetIfEntry
#define gf_ifInDiscards                     MibGetIfEntry
#define gf_ifInErrors                       MibGetIfEntry
#define gf_ifInUnknownProtos                MibGetIfEntry
#define gf_ifOutOctets                      MibGetIfEntry
#define gf_ifOutUcastPkts                   MibGetIfEntry
#define gf_ifOutNUcastPkts                  MibGetIfEntry
#define gf_ifOutDiscards                    MibGetIfEntry
#define gf_ifOutErrors                      MibGetIfEntry
#define gf_ifOutQLen                        MibGetIfEntry
#define gf_ifSpecific                       MibGetIfEntry

#define gb_ifEntry                          IF_ENTRY_GET
#define gb_ifIndex                          IF_ENTRY_GET
#define gb_ifDescr                          IF_ENTRY_GET
#define gb_ifType                           IF_ENTRY_GET
#define gb_ifMtu                            IF_ENTRY_GET
#define gb_ifSpeed                          IF_ENTRY_GET
#define gb_ifPhysAddress                    IF_ENTRY_GET
#define gb_ifAdminStatus                    IF_ENTRY_GET
#define gb_ifOperStatus                     IF_ENTRY_GET
#define gb_ifLastChange                     IF_ENTRY_GET
#define gb_ifInOctets                       IF_ENTRY_GET
#define gb_ifInUcastPkts                    IF_ENTRY_GET
#define gb_ifInNUcastPkts                   IF_ENTRY_GET
#define gb_ifInDiscards                     IF_ENTRY_GET
#define gb_ifInErrors                       IF_ENTRY_GET
#define gb_ifInUnknownProtos                IF_ENTRY_GET
#define gb_ifOutOctets                      IF_ENTRY_GET
#define gb_ifOutUcastPkts                   IF_ENTRY_GET
#define gb_ifOutNUcastPkts                  IF_ENTRY_GET
#define gb_ifOutDiscards                    IF_ENTRY_GET
#define gb_ifOutErrors                      IF_ENTRY_GET
#define gb_ifOutQLen                        IF_ENTRY_GET
#define gb_ifSpecific                       IF_ENTRY_GET

typedef struct _IF_ENTRY_SET
{
    AsnAny          ifIndex;
    AsnAny          ifAdminStatus;
    BOOL            bLocked;
    ROW_ACTION      raAction;
    DWORD           rgdwSetBuffer[MIB_INFO_SIZE_IN_DWORDS(MIB_IFROW)];
}IF_ENTRY_SET, *PIF_ENTRY_SET;

UINT
MibSetIfEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );
           
#define sf_ifAdminStatus                    MibSetIfEntry

#define sb_ifAdminStatus                    IF_ENTRY_SET

typedef struct _IP_STATS_GET
{
    AsnAny ipForwarding;
    AsnAny ipDefaultTTL;
    AsnAny ipInReceives;
    AsnAny ipInHdrErrors;
    AsnAny ipInAddrErrors;
    AsnAny ipForwDatagrams;
    AsnAny ipInUnknownProtos;
    AsnAny ipInDiscards;
    AsnAny ipInDelivers;
    AsnAny ipOutRequests; 
    AsnAny ipOutDiscards;
    AsnAny ipOutNoRoutes;
    AsnAny ipReasmTimeout;
    AsnAny ipReasmReqds;
    AsnAny ipReasmOKs;
    AsnAny ipReasmFails;
    AsnAny ipFragOKs;
    AsnAny ipFragFails;
    AsnAny ipFragCreates;
    AsnAny ipRoutingDiscards;
}IP_STATS_GET, *PIP_STATS_GET;

UINT
MibGetIpGroup(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define gf_ipForwarding                     MibGetIpGroup
#define gf_ipDefaultTTL                     MibGetIpGroup
#define gf_ipInReceives                     MibGetIpGroup
#define gf_ipInHdrErrors                    MibGetIpGroup
#define gf_ipInAddrErrors                   MibGetIpGroup
#define gf_ipForwDatagrams                  MibGetIpGroup
#define gf_ipInUnknownProtos                MibGetIpGroup
#define gf_ipInDiscards                     MibGetIpGroup
#define gf_ipInDelivers                     MibGetIpGroup
#define gf_ipOutRequests                    MibGetIpGroup
#define gf_ipOutDiscards                    MibGetIpGroup
#define gf_ipOutNoRoutes                    MibGetIpGroup
#define gf_ipReasmTimeout                   MibGetIpGroup
#define gf_ipReasmReqds                     MibGetIpGroup
#define gf_ipReasmOKs                       MibGetIpGroup
#define gf_ipReasmFails                     MibGetIpGroup
#define gf_ipFragOKs                        MibGetIpGroup
#define gf_ipFragFails                      MibGetIpGroup
#define gf_ipFragCreates                    MibGetIpGroup
#define gf_ipRoutingDiscards                MibGetIpGroup

#define gb_ipForwarding                     IP_STATS_GET
#define gb_ipDefaultTTL                     IP_STATS_GET
#define gb_ipInReceives                     IP_STATS_GET
#define gb_ipInHdrErrors                    IP_STATS_GET
#define gb_ipInAddrErrors                   IP_STATS_GET
#define gb_ipForwDatagrams                  IP_STATS_GET
#define gb_ipInUnknownProtos                IP_STATS_GET
#define gb_ipInDiscards                     IP_STATS_GET
#define gb_ipInDelivers                     IP_STATS_GET
#define gb_ipOutRequests                    IP_STATS_GET
#define gb_ipOutDiscards                    IP_STATS_GET
#define gb_ipOutNoRoutes                    IP_STATS_GET
#define gb_ipReasmTimeout                   IP_STATS_GET
#define gb_ipReasmReqds                     IP_STATS_GET
#define gb_ipReasmOKs                       IP_STATS_GET
#define gb_ipReasmFails                     IP_STATS_GET
#define gb_ipFragOKs                        IP_STATS_GET
#define gb_ipFragFails                      IP_STATS_GET
#define gb_ipFragCreates                    IP_STATS_GET
#define gb_ipRoutingDiscards                IP_STATS_GET

typedef struct _IP_STATS_SET
{
    AsnAny          ipForwarding;
    AsnAny          ipDefaultTTL;
    DWORD           rgdwSetBuffer[MIB_INFO_SIZE_IN_DWORDS(MIB_IPSTATS)];
}IP_STATS_SET, *PIP_STATS_SET;

UINT
MibSetIpGroup(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define sf_ipForwarding                     MibSetIpGroup
#define sf_ipDefaultTTL                     MibSetIpGroup

#define sb_ipForwarding                     IP_STATS_SET
#define sb_ipDefaultTTL                     IP_STATS_SET


//
// The space kept for IP Addresses is a DWORD 
//

typedef struct _IP_ADDRESS_ENTRY_GET
{
    AsnAny ipAdEntAddr;
    AsnAny ipAdEntIfIndex;
    AsnAny ipAdEntNetMask;
    AsnAny ipAdEntBcastAddr;
    AsnAny ipAdEntReasmMaxSize;
    DWORD  dwIpAdEntAddrInfo;
    DWORD  dwIpAdEntNetMaskInfo;
}IP_ADDRESS_ENTRY_GET, *PIP_ADDRESS_ENTRY_GET;

UINT
MibGetIpAddressEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define gf_ipAdEntAddr                      MibGetIpAddressEntry
#define gf_ipAdEntIfIndex                   MibGetIpAddressEntry
#define gf_ipAdEntNetMask                   MibGetIpAddressEntry
#define gf_ipAdEntBcastAddr                 MibGetIpAddressEntry
#define gf_ipAdEntReasmMaxSize              MibGetIpAddressEntry

#define gb_ipAdEntAddr                      IP_ADDRESS_ENTRY_GET
#define gb_ipAdEntIfIndex                   IP_ADDRESS_ENTRY_GET
#define gb_ipAdEntNetMask                   IP_ADDRESS_ENTRY_GET
#define gb_ipAdEntBcastAddr                 IP_ADDRESS_ENTRY_GET
#define gb_ipAdEntReasmMaxSize              IP_ADDRESS_ENTRY_GET 

typedef struct _IP_ROUTE_ENTRY_GET
{
    AsnAny ipRouteDest;
    AsnAny ipRouteIfIndex;
    AsnAny ipRouteMetric1;
    AsnAny ipRouteMetric2;
    AsnAny ipRouteMetric3;
    AsnAny ipRouteMetric4;
    AsnAny ipRouteNextHop;
    AsnAny ipRouteType;
    AsnAny ipRouteProto;
    AsnAny ipRouteAge;
    AsnAny ipRouteMask;
    AsnAny ipRouteMetric5;
    AsnAny ipRouteInfo;
    DWORD  dwIpRouteDestInfo;
    DWORD  dwIpRouteMaskInfo;
    DWORD  dwIpRouteNextHopInfo;
}IP_ROUTE_ENTRY_GET, *PIP_ROUTE_ENTRY_GET;

UINT
MibGetIpRouteEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define gf_ipRouteDest                      MibGetIpRouteEntry
#define gf_ipRouteIfIndex                   MibGetIpRouteEntry
#define gf_ipRouteMetric1                   MibGetIpRouteEntry
#define gf_ipRouteMetric2                   MibGetIpRouteEntry
#define gf_ipRouteMetric3                   MibGetIpRouteEntry
#define gf_ipRouteMetric4                   MibGetIpRouteEntry
#define gf_ipRouteNextHop                   MibGetIpRouteEntry
#define gf_ipRouteType                      MibGetIpRouteEntry
#define gf_ipRouteProto                     MibGetIpRouteEntry
#define gf_ipRouteAge                       MibGetIpRouteEntry
#define gf_ipRouteMask                      MibGetIpRouteEntry
#define gf_ipRouteMetric5                   MibGetIpRouteEntry
#define gf_ipRouteInfo                      MibGetIpRouteEntry

#define gb_ipRouteDest                      IP_ROUTE_ENTRY_GET
#define gb_ipRouteIfIndex                   IP_ROUTE_ENTRY_GET
#define gb_ipRouteMetric1                   IP_ROUTE_ENTRY_GET
#define gb_ipRouteMetric2                   IP_ROUTE_ENTRY_GET
#define gb_ipRouteMetric3                   IP_ROUTE_ENTRY_GET
#define gb_ipRouteMetric4                   IP_ROUTE_ENTRY_GET
#define gb_ipRouteNextHop                   IP_ROUTE_ENTRY_GET
#define gb_ipRouteType                      IP_ROUTE_ENTRY_GET
#define gb_ipRouteProto                     IP_ROUTE_ENTRY_GET
#define gb_ipRouteAge                       IP_ROUTE_ENTRY_GET
#define gb_ipRouteMask                      IP_ROUTE_ENTRY_GET
#define gb_ipRouteMetric5                   IP_ROUTE_ENTRY_GET
#define gb_ipRouteInfo                      IP_ROUTE_ENTRY_GET

typedef struct _IP_ROUTE_ENTRY_SET
{
    AsnAny          ipRouteDest;
    AsnAny          ipRouteIfIndex;
    AsnAny          ipRouteMetric1;
    AsnAny          ipRouteMetric2;
    AsnAny          ipRouteMetric3;
    AsnAny          ipRouteMetric4;
    AsnAny          ipRouteNextHop;
    AsnAny          ipRouteType;
    AsnAny          ipRouteProto;
    AsnAny          ipRouteAge;
    AsnAny          ipRouteMask;
    AsnAny          ipRouteMetric5;
    BOOL            bLocked;
    DWORD           dwIpRouteDestInfo;
    DWORD           dwIpRouteMaskInfo;
    DWORD           dwIpRouteNextHopInfo;
    ROW_ACTION      raAction;
    DWORD           rgdwSetBuffer[MIB_INFO_SIZE_IN_DWORDS(MIB_IPFORWARDROW)];
}IP_ROUTE_ENTRY_SET, *PIP_ROUTE_ENTRY_SET;

UINT
MibSetIpRouteEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define sf_ipRouteDest                      MibSetIpRouteEntry
#define sf_ipRouteIfIndex                   MibSetIpRouteEntry
#define sf_ipRouteMetric1                   MibSetIpRouteEntry
#define sf_ipRouteMetric2                   MibSetIpRouteEntry
#define sf_ipRouteMetric3                   MibSetIpRouteEntry
#define sf_ipRouteMetric4                   MibSetIpRouteEntry
#define sf_ipRouteNextHop                   MibSetIpRouteEntry
#define sf_ipRouteType                      MibSetIpRouteEntry
#define sf_ipRouteProto                     MibSetIpRouteEntry
#define sf_ipRouteAge                       MibSetIpRouteEntry
#define sf_ipRouteMask                      MibSetIpRouteEntry
#define sf_ipRouteMetric5                   MibSetIpRouteEntry

#define sb_ipRouteDest                      IP_ROUTE_ENTRY_SET
#define sb_ipRouteIfIndex                   IP_ROUTE_ENTRY_SET
#define sb_ipRouteMetric1                   IP_ROUTE_ENTRY_SET
#define sb_ipRouteMetric2                   IP_ROUTE_ENTRY_SET
#define sb_ipRouteMetric3                   IP_ROUTE_ENTRY_SET
#define sb_ipRouteMetric4                   IP_ROUTE_ENTRY_SET
#define sb_ipRouteNextHop                   IP_ROUTE_ENTRY_SET
#define sb_ipRouteType                      IP_ROUTE_ENTRY_SET
#define sb_ipRouteProto                     IP_ROUTE_ENTRY_SET
#define sb_ipRouteAge                       IP_ROUTE_ENTRY_SET
#define sb_ipRouteMask                      IP_ROUTE_ENTRY_SET
#define sb_ipRouteMetric5                   IP_ROUTE_ENTRY_SET


typedef struct _IP_NET_TO_MEDIA_ENTRY_GET
{
    AsnAny ipNetToMediaIfIndex;
    AsnAny ipNetToMediaPhysAddress;
    AsnAny ipNetToMediaNetAddress;
    AsnAny ipNetToMediaType;
    BYTE   rgbyIpNetToMediaPhysAddressInfo[MAX_PHYS_ADDR_LEN];
    DWORD  dwIpNetToMediaNetAddressInfo;
}IP_NET_TO_MEDIA_ENTRY_GET, *PIP_NET_TO_MEDIA_ENTRY_GET;

UINT
MibGetIpNetToMediaEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define gf_ipNetToMediaIfIndex              MibGetIpNetToMediaEntry
#define gf_ipNetToMediaPhysAddress          MibGetIpNetToMediaEntry
#define gf_ipNetToMediaNetAddress           MibGetIpNetToMediaEntry
#define gf_ipNetToMediaType                 MibGetIpNetToMediaEntry

#define gb_ipNetToMediaIfIndex              IP_NET_TO_MEDIA_ENTRY_GET
#define gb_ipNetToMediaPhysAddress          IP_NET_TO_MEDIA_ENTRY_GET
#define gb_ipNetToMediaNetAddress           IP_NET_TO_MEDIA_ENTRY_GET
#define gb_ipNetToMediaType                 IP_NET_TO_MEDIA_ENTRY_GET

typedef struct _IP_NET_TO_MEDIA_ENTRY_SET
{
    AsnAny          ipNetToMediaIfIndex;
    AsnAny          ipNetToMediaPhysAddress;
    AsnAny          ipNetToMediaNetAddress;
    AsnAny          ipNetToMediaType;
    BOOL            bLocked;
    BYTE            rgbyIpNetToMediaPhysAddressInfo[MAX_PHYS_ADDR_LEN];
    DWORD           dwIpNetToMediaNetAddressInfo;
    ROW_ACTION      raAction;
    DWORD           rgdwSetBuffer[MIB_INFO_SIZE_IN_DWORDS(MIB_IPNETROW)];
}IP_NET_TO_MEDIA_ENTRY_SET, *PIP_NET_TO_MEDIA_ENTRY_SET;

UINT
MibSetIpNetToMediaEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define sf_ipNetToMediaIfIndex              MibSetIpNetToMediaEntry
#define sf_ipNetToMediaPhysAddress          MibSetIpNetToMediaEntry
#define sf_ipNetToMediaNetAddress           MibSetIpNetToMediaEntry
#define sf_ipNetToMediaType                 MibSetIpNetToMediaEntry

#define sb_ipNetToMediaIfIndex              IP_NET_TO_MEDIA_ENTRY_SET
#define sb_ipNetToMediaPhysAddress          IP_NET_TO_MEDIA_ENTRY_SET
#define sb_ipNetToMediaNetAddress           IP_NET_TO_MEDIA_ENTRY_SET
#define sb_ipNetToMediaType                 IP_NET_TO_MEDIA_ENTRY_SET

typedef struct _ICMP_GROUP_GET
{
    AsnAny icmpInMsgs;
    AsnAny icmpInErrors;
    AsnAny icmpInDestUnreachs;
    AsnAny icmpInTimeExcds;
    AsnAny icmpInParmProbs;
    AsnAny icmpInSrcQuenchs;
    AsnAny icmpInRedirects;
    AsnAny icmpInEchos; 
    AsnAny icmpInEchoReps;
    AsnAny icmpInTimestamps;
    AsnAny icmpInTimestampReps;
    AsnAny icmpInAddrMasks;
    AsnAny icmpInAddrMaskReps;
    AsnAny icmpOutMsgs;
    AsnAny icmpOutErrors;
    AsnAny icmpOutDestUnreachs;
    AsnAny icmpOutTimeExcds;
    AsnAny icmpOutParmProbs;
    AsnAny icmpOutSrcQuenchs;
    AsnAny icmpOutRedirects;
    AsnAny icmpOutEchos;
    AsnAny icmpOutEchoReps;
    AsnAny icmpOutTimestamps;
    AsnAny icmpOutTimestampReps;
    AsnAny icmpOutAddrMasks;
    AsnAny icmpOutAddrMaskReps;
}ICMP_GROUP_GET, *PICMP_GROUP_GET;

UINT
MibGetIcmpGroup(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define gf_icmpInMsgs                       MibGetIcmpGroup
#define gf_icmpInErrors                     MibGetIcmpGroup
#define gf_icmpInDestUnreachs               MibGetIcmpGroup
#define gf_icmpInTimeExcds                  MibGetIcmpGroup
#define gf_icmpInParmProbs                  MibGetIcmpGroup
#define gf_icmpInSrcQuenchs                 MibGetIcmpGroup
#define gf_icmpInRedirects                  MibGetIcmpGroup
#define gf_icmpInEchos                      MibGetIcmpGroup
#define gf_icmpInEchoReps                   MibGetIcmpGroup
#define gf_icmpInTimestamps                 MibGetIcmpGroup
#define gf_icmpInTimestampReps              MibGetIcmpGroup
#define gf_icmpInAddrMasks                  MibGetIcmpGroup
#define gf_icmpInAddrMaskReps               MibGetIcmpGroup
#define gf_icmpOutMsgs                      MibGetIcmpGroup
#define gf_icmpOutErrors                    MibGetIcmpGroup
#define gf_icmpOutDestUnreachs              MibGetIcmpGroup
#define gf_icmpOutTimeExcds                 MibGetIcmpGroup
#define gf_icmpOutParmProbs                 MibGetIcmpGroup
#define gf_icmpOutSrcQuenchs                MibGetIcmpGroup
#define gf_icmpOutRedirects                 MibGetIcmpGroup
#define gf_icmpOutEchos                     MibGetIcmpGroup
#define gf_icmpOutEchoReps                  MibGetIcmpGroup
#define gf_icmpOutTimestamps                MibGetIcmpGroup
#define gf_icmpOutTimestampReps             MibGetIcmpGroup
#define gf_icmpOutAddrMasks                 MibGetIcmpGroup
#define gf_icmpOutAddrMaskReps              MibGetIcmpGroup

#define gb_icmpInMsgs                       ICMP_GROUP_GET
#define gb_icmpInErrors                     ICMP_GROUP_GET
#define gb_icmpInDestUnreachs               ICMP_GROUP_GET
#define gb_icmpInTimeExcds                  ICMP_GROUP_GET
#define gb_icmpInParmProbs                  ICMP_GROUP_GET
#define gb_icmpInSrcQuenchs                 ICMP_GROUP_GET
#define gb_icmpInRedirects                  ICMP_GROUP_GET
#define gb_icmpInEchos                      ICMP_GROUP_GET
#define gb_icmpInEchoReps                   ICMP_GROUP_GET
#define gb_icmpInTimestamps                 ICMP_GROUP_GET
#define gb_icmpInTimestampReps              ICMP_GROUP_GET
#define gb_icmpInAddrMasks                  ICMP_GROUP_GET
#define gb_icmpInAddrMaskReps               ICMP_GROUP_GET
#define gb_icmpOutMsgs                      ICMP_GROUP_GET
#define gb_icmpOutErrors                    ICMP_GROUP_GET
#define gb_icmpOutDestUnreachs              ICMP_GROUP_GET
#define gb_icmpOutTimeExcds                 ICMP_GROUP_GET
#define gb_icmpOutParmProbs                 ICMP_GROUP_GET
#define gb_icmpOutSrcQuenchs                ICMP_GROUP_GET
#define gb_icmpOutRedirects                 ICMP_GROUP_GET
#define gb_icmpOutEchos                     ICMP_GROUP_GET
#define gb_icmpOutEchoReps                  ICMP_GROUP_GET
#define gb_icmpOutTimestamps                ICMP_GROUP_GET
#define gb_icmpOutTimestampReps             ICMP_GROUP_GET
#define gb_icmpOutAddrMasks                 ICMP_GROUP_GET
#define gb_icmpOutAddrMaskReps              ICMP_GROUP_GET

typedef struct _INET_ICMP_GET{
    AsnAny inetIcmpAFType;
    AsnAny inetIcmpIfIndex;
    AsnAny inetIcmpInMsgs;
    AsnAny inetIcmpInErrors;
    AsnAny inetIcmpOutMsgs;
    AsnAny inetIcmpOutErrors;
}INET_ICMP_GET, *PINET_ICMP_GET;

UINT
MibGetInetIcmpEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define gf_inetIcmpAFType                   MibGetInetIcmpEntry
#define gf_inetIcmpIfIndex                  MibGetInetIcmpEntry
#define gf_inetIcmpInMsgs                   MibGetInetIcmpEntry
#define gf_inetIcmpInErrors                 MibGetInetIcmpEntry
#define gf_inetIcmpOutMsgs                  MibGetInetIcmpEntry
#define gf_inetIcmpOutErrors                MibGetInetIcmpEntry

#define gb_inetIcmpAFType                   INET_ICMP_GET
#define gb_inetIcmpIfIndex                  INET_ICMP_GET
#define gb_inetIcmpInMsgs                   INET_ICMP_GET
#define gb_inetIcmpInErrors                 INET_ICMP_GET
#define gb_inetIcmpOutMsgs                  INET_ICMP_GET
#define gb_inetIcmpOutErrors                INET_ICMP_GET

typedef struct _INET_ICMP_MSG_GET{
    AsnAny inetIcmpMsgAFType;
    AsnAny inetIcmpMsgIfIndex;
    AsnAny inetIcmpMsgType;
    AsnAny inetIcmpMsgCode;
    AsnAny inetIcmpMsgInPkts;
    AsnAny inetIcmpMsgOutPkts;
}INET_ICMP_MSG_GET, *PINET_ICMP_MSG_GET;

UINT
MibGetInetIcmpMsgEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define gf_inetIcmpMsgAFType                   MibGetInetIcmpMsgEntry
#define gf_inetIcmpMsgIfIndex                  MibGetInetIcmpMsgEntry
#define gf_inetIcmpMsgType                     MibGetInetIcmpMsgEntry
#define gf_inetIcmpMsgCode                     MibGetInetIcmpMsgEntry
#define gf_inetIcmpMsgInPkts                   MibGetInetIcmpMsgEntry
#define gf_inetIcmpMsgOutPkts                  MibGetInetIcmpMsgEntry

#define gb_inetIcmpMsgAFType                   INET_ICMP_MSG_GET
#define gb_inetIcmpMsgIfIndex                  INET_ICMP_MSG_GET
#define gb_inetIcmpMsgType                     INET_ICMP_MSG_GET
#define gb_inetIcmpMsgCode                     INET_ICMP_MSG_GET
#define gb_inetIcmpMsgInPkts                   INET_ICMP_MSG_GET
#define gb_inetIcmpMsgOutPkts                  INET_ICMP_MSG_GET

typedef struct _TCP_STATS_GET
{
    AsnAny tcpRtoAlgorithm;
    AsnAny tcpRtoMin;
    AsnAny tcpRtoMax;
    AsnAny tcpMaxConn;
    AsnAny tcpActiveOpens;
    AsnAny tcpPassiveOpens;
    AsnAny tcpAttemptFails;
    AsnAny tcpEstabResets;
    AsnAny tcpCurrEstab;
    AsnAny tcpInSegs;
    AsnAny tcpOutSegs;
    AsnAny tcpRetransSegs;
    AsnAny tcpInErrs;
    AsnAny tcpOutRsts;
}TCP_STATS_GET, *PTCP_STATS_GET;

UINT
MibGetTcpGroup(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define gf_tcpRtoAlgorithm                  MibGetTcpGroup
#define gf_tcpRtoMin                        MibGetTcpGroup
#define gf_tcpRtoMax                        MibGetTcpGroup
#define gf_tcpMaxConn                       MibGetTcpGroup
#define gf_tcpActiveOpens                   MibGetTcpGroup
#define gf_tcpPassiveOpens                  MibGetTcpGroup
#define gf_tcpAttemptFails                  MibGetTcpGroup
#define gf_tcpEstabResets                   MibGetTcpGroup
#define gf_tcpCurrEstab                     MibGetTcpGroup
#define gf_tcpInSegs                        MibGetTcpGroup
#define gf_tcpOutSegs                       MibGetTcpGroup
#define gf_tcpRetransSegs                   MibGetTcpGroup
#define gf_tcpInErrs                        MibGetTcpGroup
#define gf_tcpOutRsts                       MibGetTcpGroup

#define gb_tcpRtoAlgorithm                  TCP_STATS_GET
#define gb_tcpRtoMin                        TCP_STATS_GET
#define gb_tcpRtoMax                        TCP_STATS_GET
#define gb_tcpMaxConn                       TCP_STATS_GET
#define gb_tcpActiveOpens                   TCP_STATS_GET
#define gb_tcpPassiveOpens                  TCP_STATS_GET
#define gb_tcpAttemptFails                  TCP_STATS_GET
#define gb_tcpEstabResets                   TCP_STATS_GET
#define gb_tcpCurrEstab                     TCP_STATS_GET
#define gb_tcpInSegs                        TCP_STATS_GET
#define gb_tcpOutSegs                       TCP_STATS_GET
#define gb_tcpRetransSegs                   TCP_STATS_GET
#define gb_tcpInErrs                        TCP_STATS_GET
#define gb_tcpOutRsts                       TCP_STATS_GET

typedef struct _TCP_CONNECTION_ENTRY_GET
{
    AsnAny tcpConnState;
    AsnAny tcpConnLocalAddress;
    AsnAny tcpConnLocalPort;
    AsnAny tcpConnRemAddress;
    AsnAny tcpConnRemPort;
    DWORD  dwTcpConnLocalAddressInfo;
    DWORD  dwTcpConnRemAddressInfo;
}TCP_CONNECTION_ENTRY_GET, *PTCP_CONNECTION_ENTRY_GET;

UINT
MibGetTcpConnectionEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define gf_tcpConnState                     MibGetTcpConnectionEntry
#define gf_tcpConnLocalAddress              MibGetTcpConnectionEntry
#define gf_tcpConnLocalPort                 MibGetTcpConnectionEntry
#define gf_tcpConnRemAddress                MibGetTcpConnectionEntry
#define gf_tcpConnRemPort                   MibGetTcpConnectionEntry

#define gb_tcpConnState                     TCP_CONNECTION_ENTRY_GET
#define gb_tcpConnLocalAddress              TCP_CONNECTION_ENTRY_GET
#define gb_tcpConnLocalPort                 TCP_CONNECTION_ENTRY_GET
#define gb_tcpConnRemAddress                TCP_CONNECTION_ENTRY_GET
#define gb_tcpConnRemPort                   TCP_CONNECTION_ENTRY_GET

typedef struct _TCP_CONNECTION_ENTRY_SET
{
    AsnAny          tcpConnState;
    AsnAny          tcpConnLocalAddress;
    AsnAny          tcpConnLocalPort;
    AsnAny          tcpConnRemAddress;
    AsnAny          tcpConnRemPort;
    DWORD           dwTcpConnLocalAddressInfo;
    DWORD           dwTcpConnRemAddressInfo;
    BOOL            bLocked;
    ROW_ACTION      raAction;
    DWORD           rgdwSetBuffer[MIB_INFO_SIZE_IN_DWORDS(MIB_TCPROW)];
}TCP_CONNECTION_ENTRY_SET, *PTCP_CONNECTION_ENTRY_SET;

UINT
MibSetTcpConnectionEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define sf_tcpConnState                     MibSetTcpConnectionEntry

#define sb_tcpConnState                     TCP_CONNECTION_ENTRY_SET

typedef struct _TCP_NEW_CONNECTION_ENTRY_GET
{
    AsnAny tcpNewConnLocalAddressType;
    AsnAny tcpNewConnLocalAddress;
    AsnAny tcpNewConnLocalPort;
    AsnAny tcpNewConnRemAddressType;
    AsnAny tcpNewConnRemAddress;
    AsnAny tcpNewConnRemPort;
    AsnAny tcpNewConnState;
    BYTE   rgbyTcpNewConnLocalAddressInfo[20];
    BYTE   rgbyTcpNewConnRemAddressInfo[20];
}TCP_NEW_CONNECTION_ENTRY_GET, *PTCP_NEW_CONNECTION_ENTRY_GET;

UINT
MibGetTcpNewConnectionEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define gf_tcpNewConnLocalAddressType       MibGetTcpNewConnectionEntry
#define gf_tcpNewConnLocalAddress           MibGetTcpNewConnectionEntry
#define gf_tcpNewConnLocalPort              MibGetTcpNewConnectionEntry
#define gf_tcpNewConnRemAddressType         MibGetTcpNewConnectionEntry
#define gf_tcpNewConnRemAddress             MibGetTcpNewConnectionEntry
#define gf_tcpNewConnRemPort                MibGetTcpNewConnectionEntry
#define gf_tcpNewConnState                  MibGetTcpNewConnectionEntry

#define gb_tcpNewConnLocalAddressType       TCP_NEW_CONNECTION_ENTRY_GET
#define gb_tcpNewConnLocalAddress           TCP_NEW_CONNECTION_ENTRY_GET
#define gb_tcpNewConnLocalPort              TCP_NEW_CONNECTION_ENTRY_GET
#define gb_tcpNewConnRemAddressType         TCP_NEW_CONNECTION_ENTRY_GET
#define gb_tcpNewConnRemAddress             TCP_NEW_CONNECTION_ENTRY_GET
#define gb_tcpNewConnRemPort                TCP_NEW_CONNECTION_ENTRY_GET
#define gb_tcpNewConnState                  TCP_NEW_CONNECTION_ENTRY_GET

typedef struct _TCP_NEW_CONNECTION_ENTRY_SET
{
    AsnAny          tcpNewConnLocalAddressType;
    AsnAny          tcpNewConnLocalAddress;
    AsnAny          tcpNewConnLocalPort;
    AsnAny          tcpNewConnRemAddressType;
    AsnAny          tcpNewConnRemAddress;
    AsnAny          tcpNewConnRemPort;
    AsnAny          tcpNewConnState;
    BYTE            rgbyTcpNewConnLocalAddressInfo[20];
    BYTE            rgbyTcpNewConnRemAddressInfo[20];
    BOOL            bLocked;
    ROW_ACTION      raAction;
    DWORD           rgdwSetBuffer[MIB_INFO_SIZE_IN_DWORDS(TCP6ConnTableEntry)];
}TCP_NEW_CONNECTION_ENTRY_SET, *PTCP_NEW_CONNECTION_ENTRY_SET;

UINT
MibSetTcpNewConnectionEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define sf_tcpNewConnState                  MibSetTcpNewConnectionEntry

#define sb_tcpNewConnState                  TCP_NEW_CONNECTION_ENTRY_SET

typedef struct _UDP_STATS_GET
{
    AsnAny udpInDatagrams;
    AsnAny udpNoPorts;
    AsnAny udpInErrors;
    AsnAny udpOutDatagrams;
}UDP_STATS_GET, *PUDP_STATS_GET;

UINT 
MibGetUdpGroup(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define gf_udpInDatagrams                   MibGetUdpGroup
#define gf_udpNoPorts                       MibGetUdpGroup
#define gf_udpInErrors                      MibGetUdpGroup
#define gf_udpOutDatagrams                  MibGetUdpGroup

#define gb_udpInDatagrams                   UDP_STATS_GET
#define gb_udpNoPorts                       UDP_STATS_GET
#define gb_udpInErrors                      UDP_STATS_GET
#define gb_udpOutDatagrams                  UDP_STATS_GET

typedef struct _UDP_ENTRY_GET
{
    AsnAny udpLocalAddress;
    AsnAny udpLocalPort;
    DWORD  dwUdpLocalAddressInfo;
}UDP_ENTRY_GET, *PUDP_ENTRY_GET;

UINT
MibGetUdpEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define gf_udpLocalAddress                  MibGetUdpEntry
#define gf_udpLocalPort                     MibGetUdpEntry

#define gb_udpLocalAddress                  UDP_ENTRY_GET
#define gb_udpLocalPort                     UDP_ENTRY_GET

typedef struct _UDP_LISTENER_ENTRY_GET
{
    AsnAny udpListenerLocalAddressType;
    AsnAny udpListenerLocalAddress;
    AsnAny udpListenerLocalPort;
    BYTE   rgbyUdpLocalAddressInfo[20];
}UDP_LISTENER_ENTRY_GET, *PUDP_LISTENER_ENTRY_GET;

UINT
MibGetUdpListenerEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define gf_udpListenerLocalAddressType      MibGetUdpListenerEntry
#define gf_udpListenerLocalAddress          MibGetUdpListenerEntry
#define gf_udpListenerLocalPort             MibGetUdpListenerEntry

#define gb_udpListenerLocalAddressType      UDP_LISTENER_ENTRY_GET
#define gb_udpListenerLocalAddress          UDP_LISTENER_ENTRY_GET
#define gb_udpListenerLocalPort             UDP_LISTENER_ENTRY_GET

typedef struct _IP_FORWARD_NUMBER_GET
{
    AsnAny ipForwardNumber;
}IP_FORWARD_NUMBER_GET, *PIP_FORWARD_NUMBER_GET;

UINT
MibGetIpForwardNumber(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define gf_ipForwardNumber                  MibGetIpForwardNumber

#define gb_ipForwardNumber                  IP_FORWARD_NUMBER_GET

typedef struct _IP_FORWARD_ENTRY_GET
{
    AsnAny ipForwardDest;
    AsnAny ipForwardMask;
    AsnAny ipForwardPolicy;
    AsnAny ipForwardNextHop;
    AsnAny ipForwardIfIndex;
    AsnAny ipForwardType;
    AsnAny ipForwardProto;
    AsnAny ipForwardAge;
    AsnAny ipForwardInfo;
    AsnAny ipForwardNextHopAS;
    AsnAny ipForwardMetric1; 
    AsnAny ipForwardMetric2;
    AsnAny ipForwardMetric3;
    AsnAny ipForwardMetric4;
    AsnAny ipForwardMetric5;
    DWORD  dwIpForwardDestInfo;
    DWORD  dwIpForwardMaskInfo;
    DWORD  dwIpForwardNextHopInfo;
}IP_FORWARD_ENTRY_GET, *PIP_FORWARD_ENTRY_GET;

UINT
MibGetIpForwardEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define gf_ipForwardDest                    MibGetIpForwardEntry
#define gf_ipForwardMask                    MibGetIpForwardEntry
#define gf_ipForwardPolicy                  MibGetIpForwardEntry
#define gf_ipForwardNextHop                 MibGetIpForwardEntry
#define gf_ipForwardIfIndex                 MibGetIpForwardEntry
#define gf_ipForwardType                    MibGetIpForwardEntry
#define gf_ipForwardProto                   MibGetIpForwardEntry
#define gf_ipForwardAge                     MibGetIpForwardEntry
#define gf_ipForwardInfo                    MibGetIpForwardEntry
#define gf_ipForwardNextHopAS               MibGetIpForwardEntry
#define gf_ipForwardMetric1                 MibGetIpForwardEntry
#define gf_ipForwardMetric2                 MibGetIpForwardEntry
#define gf_ipForwardMetric3                 MibGetIpForwardEntry
#define gf_ipForwardMetric4                 MibGetIpForwardEntry
#define gf_ipForwardMetric5                 MibGetIpForwardEntry

#define gb_ipForwardDest                    IP_FORWARD_ENTRY_GET
#define gb_ipForwardMask                    IP_FORWARD_ENTRY_GET
#define gb_ipForwardPolicy                  IP_FORWARD_ENTRY_GET
#define gb_ipForwardNextHop                 IP_FORWARD_ENTRY_GET
#define gb_ipForwardIfIndex                 IP_FORWARD_ENTRY_GET
#define gb_ipForwardType                    IP_FORWARD_ENTRY_GET
#define gb_ipForwardProto                   IP_FORWARD_ENTRY_GET
#define gb_ipForwardAge                     IP_FORWARD_ENTRY_GET
#define gb_ipForwardInfo                    IP_FORWARD_ENTRY_GET
#define gb_ipForwardNextHopAS               IP_FORWARD_ENTRY_GET
#define gb_ipForwardMetric1                 IP_FORWARD_ENTRY_GET
#define gb_ipForwardMetric2                 IP_FORWARD_ENTRY_GET
#define gb_ipForwardMetric3                 IP_FORWARD_ENTRY_GET
#define gb_ipForwardMetric4                 IP_FORWARD_ENTRY_GET
#define gb_ipForwardMetric5                 IP_FORWARD_ENTRY_GET


typedef struct _IP_FORWARD_ENTRY_SET
{
    AsnAny          ipForwardDest;
    AsnAny          ipForwardMask;
    AsnAny          ipForwardPolicy;
    AsnAny          ipForwardNextHop;
    AsnAny          ipForwardIfIndex;
    AsnAny          ipForwardType;
    AsnAny          ipForwardProto;
    AsnAny          ipForwardAge;
    AsnAny          ipForwardNextHopAS;
    AsnAny          ipForwardMetric1; 
    AsnAny          ipForwardMetric2;
    AsnAny          ipForwardMetric3;
    AsnAny          ipForwardMetric4;
    AsnAny          ipForwardMetric5;
    BOOL            bLocked;
    DWORD           dwIpForwardDestInfo;
    DWORD           dwIpForwardMaskInfo;
    DWORD           dwIpForwardNextHopInfo;
    ROW_ACTION      raAction;
    DWORD           rgdwSetBuffer[MIB_INFO_SIZE_IN_DWORDS(MIB_IPFORWARDROW)];
}IP_FORWARD_ENTRY_SET, *PIP_FORWARD_ENTRY_SET;

UINT
MibSetIpForwardEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define sf_ipForwardDest                    MibSetIpForwardEntry
#define sf_ipForwardMask                    MibSetIpForwardEntry
#define sf_ipForwardPolicy                  MibSetIpForwardEntry
#define sf_ipForwardNextHop                 MibSetIpForwardEntry
#define sf_ipForwardIfIndex                 MibSetIpForwardEntry
#define sf_ipForwardType                    MibSetIpForwardEntry
#define sf_ipForwardProto                   MibSetIpForwardEntry
#define sf_ipForwardAge                     MibSetIpForwardEntry
#define sf_ipForwardNextHopAS               MibSetIpForwardEntry
#define sf_ipForwardMetric1                 MibSetIpForwardEntry
#define sf_ipForwardMetric2                 MibSetIpForwardEntry
#define sf_ipForwardMetric3                 MibSetIpForwardEntry
#define sf_ipForwardMetric4                 MibSetIpForwardEntry
#define sf_ipForwardMetric5                 MibSetIpForwardEntry

#define sb_ipForwardDest                    IP_FORWARD_ENTRY_SET
#define sb_ipForwardMask                    IP_FORWARD_ENTRY_SET
#define sb_ipForwardPolicy                  IP_FORWARD_ENTRY_SET
#define sb_ipForwardNextHop                 IP_FORWARD_ENTRY_SET
#define sb_ipForwardIfIndex                 IP_FORWARD_ENTRY_SET
#define sb_ipForwardType                    IP_FORWARD_ENTRY_SET
#define sb_ipForwardProto                   IP_FORWARD_ENTRY_SET
#define sb_ipForwardAge                     IP_FORWARD_ENTRY_SET
#define sb_ipForwardNextHopAS               IP_FORWARD_ENTRY_SET
#define sb_ipForwardMetric1                 IP_FORWARD_ENTRY_SET
#define sb_ipForwardMetric2                 IP_FORWARD_ENTRY_SET
#define sb_ipForwardMetric3                 IP_FORWARD_ENTRY_SET
#define sb_ipForwardMetric4                 IP_FORWARD_ENTRY_SET
#define sb_ipForwardMetric5                 IP_FORWARD_ENTRY_SET

typedef struct _IPV6_STATS_GET
{
    AsnAny ipv6Forwarding;
    AsnAny ipv6DefaultHopLimit;
    AsnAny ipv6Interfaces;
    AsnAny ipv6IfTableLastChange;
    AsnAny ipv6RouteNumber;
    AsnAny ipv6DiscardedRoutes;
}IPV6_STATS_GET, *PIPV6_STATS_GET;

UINT
MibGetIpv6Group(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define gf_ipv6Forwarding                   MibGetIpv6Group
#define gf_ipv6DefaultHopLimit              MibGetIpv6Group
#define gf_ipv6Interfaces                   MibGetIpv6Group
#define gf_ipv6IfTableLastChange            MibGetIpv6Group
#define gf_ipv6RouteNumber                  MibGetIpv6Group
#define gf_ipv6DiscardedRoutes              MibGetIpv6Group

#define gb_ipv6Forwarding                   IPV6_STATS_GET
#define gb_ipv6DefaultHopLimit              IPV6_STATS_GET
#define gb_ipv6Interfaces                   IPV6_STATS_GET
#define gb_ipv6IfTableLastChange            IPV6_STATS_GET
#define gb_ipv6RouteNumber                  IPV6_STATS_GET
#define gb_ipv6DiscardedRoutes              IPV6_STATS_GET

typedef struct _IPV6_IF_GET
{
    AsnAny ipv6IfIndex;
    AsnAny ipv6IfDescr;
    AsnAny ipv6IfLowerLayer;
    AsnAny ipv6IfEffectiveMtu;
    AsnAny ipv6IfReasmMaxSize;
    AsnAny ipv6IfIdentifier;
    AsnAny ipv6IfIdentifierLength;
    AsnAny ipv6IfPhysicalAddress;
    AsnAny ipv6IfAdminStatus;
    AsnAny ipv6IfOperStatus; 
    AsnAny ipv6IfLastChange; 
    BYTE   rgbyIpv6IfDescrInfo[MAX_IF_DESCR_LEN];
    BYTE   rgbyIpv6IfIdentifierInfo[8];
    BYTE   rgbyIpv6IfPhysicalAddressInfo[MAX_PHYS_ADDR_LEN];
}IPV6_IF_GET, *PIPV6_IF_GET;

UINT
MibGetIpv6IfEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define gf_ipv6IfIndex                      MibGetIpv6IfEntry
#define gf_ipv6IfDescr                      MibGetIpv6IfEntry
#define gf_ipv6IfLowerLayer                 MibGetIpv6IfEntry
#define gf_ipv6IfEffectiveMtu               MibGetIpv6IfEntry
#define gf_ipv6IfReasmMaxSize               MibGetIpv6IfEntry
#define gf_ipv6IfIdentifier                 MibGetIpv6IfEntry
#define gf_ipv6IfIdentifierLength           MibGetIpv6IfEntry
#define gf_ipv6IfPhysicalAddress            MibGetIpv6IfEntry
#define gf_ipv6IfAdminStatus                MibGetIpv6IfEntry
#define gf_ipv6IfOperStatus                 MibGetIpv6IfEntry
#define gf_ipv6IfLastChange                 MibGetIpv6IfEntry

#define gb_ipv6IfIndex                      IPV6_IF_GET
#define gb_ipv6IfDescr                      IPV6_IF_GET
#define gb_ipv6IfLowerLayer                 IPV6_IF_GET
#define gb_ipv6IfEffectiveMtu               IPV6_IF_GET
#define gb_ipv6IfReasmMaxSize               IPV6_IF_GET
#define gb_ipv6IfIdentifier                 IPV6_IF_GET
#define gb_ipv6IfIdentifierLength           IPV6_IF_GET
#define gb_ipv6IfPhysicalAddress            IPV6_IF_GET
#define gb_ipv6IfAdminStatus                IPV6_IF_GET
#define gb_ipv6IfOperStatus                 IPV6_IF_GET
#define gb_ipv6IfLastChange                 IPV6_IF_GET

typedef struct _IPV6_IF_STATS_GET
{
    AsnAny ipv6IfIndex;
    AsnAny ipv6IfStatsInReceives;
    AsnAny ipv6IfStatsInHdrErrors;
    AsnAny ipv6IfStatsInTooBigErrors;
    AsnAny ipv6IfStatsInNoRoutes;
    AsnAny ipv6IfStatsInAddrErrors;
    AsnAny ipv6IfStatsInUnknownProtos;
    AsnAny ipv6IfStatsInTruncatedPkts;
    AsnAny ipv6IfStatsInDiscards;
    AsnAny ipv6IfStatsInDelivers;
    AsnAny ipv6IfStatsOutForwDatagrams;
    AsnAny ipv6IfStatsOutRequests;
    AsnAny ipv6IfStatsOutDiscards;
    AsnAny ipv6IfStatsOutFragOKs;
    AsnAny ipv6IfStatsOutFragFails;
    AsnAny ipv6IfStatsOutFragCreates;
    AsnAny ipv6IfStatsReasmReqds;
    AsnAny ipv6IfStatsReasmOKs;
    AsnAny ipv6IfStatsReasmFails;
    AsnAny ipv6IfStatsInMcastPkts;
    AsnAny ipv6IfStatsOutMcastPkts;
}IPV6_IF_STATS_GET, *PIPV6_IF_STATS_GET;

UINT
MibGetIpv6IfStatsEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define gf_ipv6IfStatsInReceives            MibGetIpv6IfStatsEntry
#define gf_ipv6IfStatsInHdrErrors           MibGetIpv6IfStatsEntry
#define gf_ipv6IfStatsInTooBigErrors        MibGetIpv6IfStatsEntry
#define gf_ipv6IfStatsInNoRoutes            MibGetIpv6IfStatsEntry
#define gf_ipv6IfStatsInAddrErrors          MibGetIpv6IfStatsEntry
#define gf_ipv6IfStatsInUnknownProtos       MibGetIpv6IfStatsEntry
#define gf_ipv6IfStatsInTruncatedPkts       MibGetIpv6IfStatsEntry
#define gf_ipv6IfStatsInDiscards            MibGetIpv6IfStatsEntry
#define gf_ipv6IfStatsInDelivers            MibGetIpv6IfStatsEntry
#define gf_ipv6IfStatsOutForwDatagrams      MibGetIpv6IfStatsEntry
#define gf_ipv6IfStatsOutRequests           MibGetIpv6IfStatsEntry
#define gf_ipv6IfStatsOutDiscards           MibGetIpv6IfStatsEntry
#define gf_ipv6IfStatsOutFragOKs            MibGetIpv6IfStatsEntry
#define gf_ipv6IfStatsOutFragFails          MibGetIpv6IfStatsEntry
#define gf_ipv6IfStatsOutFragCreates        MibGetIpv6IfStatsEntry
#define gf_ipv6IfStatsReasmReqds            MibGetIpv6IfStatsEntry
#define gf_ipv6IfStatsReasmOKs              MibGetIpv6IfStatsEntry
#define gf_ipv6IfStatsReasmFails            MibGetIpv6IfStatsEntry
#define gf_ipv6IfStatsInMcastPkts           MibGetIpv6IfStatsEntry
#define gf_ipv6IfStatsOutMcastPkts          MibGetIpv6IfStatsEntry

#define gb_ipv6IfStatsInReceives            IPV6_IF_STATS_GET
#define gb_ipv6IfStatsInHdrErrors           IPV6_IF_STATS_GET
#define gb_ipv6IfStatsInTooBigErrors        IPV6_IF_STATS_GET
#define gb_ipv6IfStatsInNoRoutes            IPV6_IF_STATS_GET
#define gb_ipv6IfStatsInAddrErrors          IPV6_IF_STATS_GET
#define gb_ipv6IfStatsInUnknownProtos       IPV6_IF_STATS_GET
#define gb_ipv6IfStatsInTruncatedPkts       IPV6_IF_STATS_GET
#define gb_ipv6IfStatsInDiscards            IPV6_IF_STATS_GET
#define gb_ipv6IfStatsInDelivers            IPV6_IF_STATS_GET
#define gb_ipv6IfStatsOutForwDatagrams      IPV6_IF_STATS_GET
#define gb_ipv6IfStatsOutRequests           IPV6_IF_STATS_GET
#define gb_ipv6IfStatsOutDiscards           IPV6_IF_STATS_GET
#define gb_ipv6IfStatsOutFragOKs            IPV6_IF_STATS_GET
#define gb_ipv6IfStatsOutFragFails          IPV6_IF_STATS_GET
#define gb_ipv6IfStatsOutFragCreates        IPV6_IF_STATS_GET
#define gb_ipv6IfStatsReasmReqds            IPV6_IF_STATS_GET
#define gb_ipv6IfStatsReasmOKs              IPV6_IF_STATS_GET
#define gb_ipv6IfStatsReasmFails            IPV6_IF_STATS_GET
#define gb_ipv6IfStatsInMcastPkts           IPV6_IF_STATS_GET
#define gb_ipv6IfStatsOutMcastPkts          IPV6_IF_STATS_GET

typedef struct _IPV6_ADDR_PREFIX_GET
{
    AsnAny ipv6IfIndex;
    AsnAny ipv6AddrPrefix;
    AsnAny ipv6AddrPrefixLength;
    AsnAny ipv6AddrPrefixOnLinkFlag;
    AsnAny ipv6AddrPrefixAutonomousFlag;
    AsnAny ipv6AddrPrefixAdvPreferredLifetime;
    AsnAny ipv6AddrPrefixAdvValidLifetime;
    IN6_ADDR ipv6AddrPrefixInfo;
}IPV6_ADDR_PREFIX_GET, *PIPV6_ADDR_PREFIX_GET;

UINT
MibGetIpv6AddrPrefixEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define gf_ipv6AddrPrefix                     MibGetIpv6AddrPrefixEntry
#define gf_ipv6AddrPrefixLength               MibGetIpv6AddrPrefixEntry
#define gf_ipv6AddrPrefixOnLinkFlag           MibGetIpv6AddrPrefixEntry
#define gf_ipv6AddrPrefixAutonomousFlag       MibGetIpv6AddrPrefixEntry
#define gf_ipv6AddrPrefixAdvPreferredLifetime MibGetIpv6AddrPrefixEntry
#define gf_ipv6AddrPrefixAdvValidLifetime     MibGetIpv6AddrPrefixEntry

#define gb_ipv6AddrPrefix                     IPV6_ADDR_PREFIX_GET
#define gb_ipv6AddrPrefixLength               IPV6_ADDR_PREFIX_GET
#define gb_ipv6AddrPrefixOnLinkFlag           IPV6_ADDR_PREFIX_GET
#define gb_ipv6AddrPrefixAutonomousFlag       IPV6_ADDR_PREFIX_GET
#define gb_ipv6AddrPrefixAdvPreferredLifetime IPV6_ADDR_PREFIX_GET
#define gb_ipv6AddrPrefixAdvValidLifetime     IPV6_ADDR_PREFIX_GET

typedef struct _IPV6_ADDR_GET
{
    AsnAny ipv6IfIndex;
    AsnAny ipv6AddrAddress;
    AsnAny ipv6AddrPfxLength;
    AsnAny ipv6AddrType;
    AsnAny ipv6AddrAnycastFlag;
    AsnAny ipv6AddrStatus;
    IN6_ADDR ipv6AddrAddressInfo;
}IPV6_ADDR_GET, *PIPV6_ADDR_GET;

UINT
MibGetIpv6AddrEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define gf_ipv6AddrAddress                  MibGetIpv6AddrEntry
#define gf_ipv6AddrPfxLength                MibGetIpv6AddrEntry
#define gf_ipv6AddrType                     MibGetIpv6AddrEntry
#define gf_ipv6AddrAnycastFlag              MibGetIpv6AddrEntry
#define gf_ipv6AddrStatus                   MibGetIpv6AddrEntry

#define gb_ipv6AddrAddress                  IPV6_ADDR_GET
#define gb_ipv6AddrPfxLength                IPV6_ADDR_GET
#define gb_ipv6AddrType                     IPV6_ADDR_GET
#define gb_ipv6AddrAnycastFlag              IPV6_ADDR_GET
#define gb_ipv6AddrStatus                   IPV6_ADDR_GET

typedef struct _IPV6_ROUTE_GET
{
    AsnAny ipv6RouteDest;
    AsnAny ipv6RoutePfxLength;
    AsnAny ipv6RouteIndex;
    AsnAny ipv6RouteIfIndex;
    AsnAny ipv6RouteNextHop;
    AsnAny ipv6RouteType;
    AsnAny ipv6RouteProtocol;
    AsnAny ipv6RoutePolicy;
    AsnAny ipv6RouteAge;
    AsnAny ipv6RouteNextHopRDI;
    AsnAny ipv6RouteMetric;
    AsnAny ipv6RouteWeight;
    AsnAny ipv6RouteInfo;
    AsnAny ipv6RouteValid;
    IN6_ADDR ipv6RouteDestInfo;
    IN6_ADDR ipv6RouteNextHopInfo;
}IPV6_ROUTE_GET, *PIPV6_ROUTE_GET;

UINT
MibGetIpv6RouteEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define gf_ipv6RouteDest                    MibGetIpv6RouteEntry
#define gf_ipv6RoutePfxLength               MibGetIpv6RouteEntry
#define gf_ipv6RouteIndex                   MibGetIpv6RouteEntry
#define gf_ipv6RouteIfIndex                 MibGetIpv6RouteEntry
#define gf_ipv6RouteNextHop                 MibGetIpv6RouteEntry
#define gf_ipv6RouteType                    MibGetIpv6RouteEntry
#define gf_ipv6RouteProtocol                MibGetIpv6RouteEntry
#define gf_ipv6RoutePolicy                  MibGetIpv6RouteEntry
#define gf_ipv6RouteAge                     MibGetIpv6RouteEntry
#define gf_ipv6RouteNextHopRDI              MibGetIpv6RouteEntry
#define gf_ipv6RouteMetric                  MibGetIpv6RouteEntry
#define gf_ipv6RouteWeight                  MibGetIpv6RouteEntry
#define gf_ipv6RouteInfo                    MibGetIpv6RouteEntry
#define gf_ipv6RouteValid                   MibGetIpv6RouteEntry

#define gb_ipv6RouteDest                    IPV6_ROUTE_GET
#define gb_ipv6RoutePfxLength               IPV6_ROUTE_GET
#define gb_ipv6RouteIndex                   IPV6_ROUTE_GET
#define gb_ipv6RouteIfIndex                 IPV6_ROUTE_GET
#define gb_ipv6RouteNextHop                 IPV6_ROUTE_GET
#define gb_ipv6RouteType                    IPV6_ROUTE_GET
#define gb_ipv6RouteProtocol                IPV6_ROUTE_GET
#define gb_ipv6RoutePolicy                  IPV6_ROUTE_GET
#define gb_ipv6RouteAge                     IPV6_ROUTE_GET
#define gb_ipv6RouteNextHopRDI              IPV6_ROUTE_GET
#define gb_ipv6RouteMetric                  IPV6_ROUTE_GET
#define gb_ipv6RouteWeight                  IPV6_ROUTE_GET
#define gb_ipv6RouteInfo                    IPV6_ROUTE_GET
#define gb_ipv6RouteValid                   IPV6_ROUTE_GET

typedef struct _IPV6_NET_TO_MEDIA_GET
{
    AsnAny ipv6IfIndex;
    AsnAny ipv6NetToMediaNetAddress;
    AsnAny ipv6NetToMediaPhysAddress;
    AsnAny ipv6NetToMediaType;
    AsnAny ipv6NetToMediaState;
    AsnAny ipv6NetToMediaLastUpdated;
    AsnAny ipv6NetToMediaValid;
    IN6_ADDR ipv6NetToMediaNetAddressInfo;
    BYTE     ipv6NetToMediaPhysAddressInfo[MAX_PHYS_ADDR_LEN];
}IPV6_NET_TO_MEDIA_GET, *PIPV6_NET_TO_MEDIA_GET;

UINT
MibGetIpv6NetToMediaEntry(
    UINT     actionId,
    AsnAny   *objectArray,
    UINT     *errorIndex
    );

#define gf_ipv6NetToMediaNetAddress         MibGetIpv6NetToMediaEntry
#define gf_ipv6NetToMediaPhysAddress        MibGetIpv6NetToMediaEntry
#define gf_ipv6NetToMediaType               MibGetIpv6NetToMediaEntry
#define gf_ipv6NetToMediaState              MibGetIpv6NetToMediaEntry
#define gf_ipv6NetToMediaLastUpdated        MibGetIpv6NetToMediaEntry
#define gf_ipv6NetToMediaValid              MibGetIpv6NetToMediaEntry

#define gb_ipv6NetToMediaNetAddress         IPV6_NET_TO_MEDIA_GET
#define gb_ipv6NetToMediaPhysAddress        IPV6_NET_TO_MEDIA_GET
#define gb_ipv6NetToMediaType               IPV6_NET_TO_MEDIA_GET
#define gb_ipv6NetToMediaState              IPV6_NET_TO_MEDIA_GET
#define gb_ipv6NetToMediaLastUpdated        IPV6_NET_TO_MEDIA_GET
#define gb_ipv6NetToMediaValid              IPV6_NET_TO_MEDIA_GET

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\snmp\oid.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:


Abstract:


Author:


Revision History:

--*/

#ifndef __OID_H__
#define __OID_H__

//
// mib-2 OBJECT IDENTIFIER ::= {iso(1) org(3) dod(6) internet(1) mgmt(2) 1}
//

static UINT ids_mib2[]                          = {1,3,6,1,2,1};

//
// The groups we handle
//
//  system       OBJECT IDENTIFIER ::= { mib-2 1 }
//
//  interfaces   OBJECT IDENTIFIER ::= { mib-2 2 }
//
//  ip           OBJECT IDENTIFIER ::= { mib-2 4 }
//
//  icmp         OBJECT IDENTIFIER ::= { mib-2 5 }
//
//  tcp          OBJECT IDENTIFIER ::= { mib-2 6 }
//
//  udp          OBJECT IDENTIFIER ::= { mib-2 7 }
//
//  ipForward    OBJECT IDENTIFIER ::= { ip 24 }
//
//  ipv6         OBJECT IDENTIFIER ::= { mib-2 55 }
//

//
// The groups we dont handle
//
//  at           OBJECT IDENTIFIER ::= { mib-2 3 }
//  egp          OBJECT IDENTIFIER ::= { mib-2 8 }
//  cmot         OBJECT IDENTIFIER ::= { mib-2 9 }
//  transmission OBJECT IDENTIFIER ::= { mib-2 10 }
//  snmp         OBJECT IDENTIFIER ::= { mib-2 11 }
//

//
// Since each of the groups below is registered separately with
// both the master agent and the subagent framework we need them
// to be fully qualified.  Each of the objects in the groups is
// then relative to the oids below.
//

static UINT ids_sysGroup[]                      = {1,3,6,1,2,1,1};
static UINT ids_ifGroup[]                       = {1,3,6,1,2,1,2};
static UINT ids_ipGroup[]                       = {1,3,6,1,2,1,4};
static UINT ids_icmpGroup[]                     = {1,3,6,1,2,1,5};
static UINT ids_tcpGroup[]                      = {1,3,6,1,2,1,6};
static UINT ids_udpGroup[]                      = {1,3,6,1,2,1,7};
static UINT ids_ipv6Group[]                     = {1,3,6,1,2,1,55,1};

//
// Now the members of each of these groups themselves
//

//
// Systems group
//

static UINT ids_sysDescr[]                      = {1, 0};
static UINT ids_sysObjectID[]                   = {2, 0};
static UINT ids_sysUpTime[]                     = {3, 0};
static UINT ids_sysContact[]                    = {4, 0};
static UINT ids_sysName[]                       = {5, 0};
static UINT ids_sysLocation[]                   = {6, 0};
static UINT ids_sysServices[]                   = {7, 0};

//
// Interfaces group
//

static UINT ids_ifNumber[]                      = {1, 0};
static UINT ids_ifTable[]                       = {2};

//
// The IF Table is composed of IF Entries which are indexed by the IfIndex
//

static UINT ids_ifEntry[]                       = {2, 1};

//
// The entry is a sequence of:
//

static UINT ids_ifIndex[]                       = {2, 1, 1};
static UINT ids_ifDescr[]                       = {2, 1, 2};
static UINT ids_ifType[]                        = {2, 1, 3};
static UINT ids_ifMtu[]                         = {2, 1, 4};
static UINT ids_ifSpeed[]                       = {2, 1, 5};
static UINT ids_ifPhysAddress[]                 = {2, 1, 6};
static UINT ids_ifAdminStatus[]                 = {2, 1, 7};
static UINT ids_ifOperStatus[]                  = {2, 1, 8};
static UINT ids_ifLastChange[]                  = {2, 1, 9};
static UINT ids_ifInOctets[]                    = {2, 1, 10};
static UINT ids_ifInUcastPkts[]                 = {2, 1, 11};
static UINT ids_ifInNUcastPkts[]                = {2, 1, 12};
static UINT ids_ifInDiscards[]                  = {2, 1, 13};
static UINT ids_ifInErrors[]                    = {2, 1, 14};
static UINT ids_ifInUnknownProtos[]             = {2, 1, 15};
static UINT ids_ifOutOctets[]                   = {2, 1, 16};
static UINT ids_ifOutUcastPkts[]                = {2, 1, 17};
static UINT ids_ifOutNUcastPkts[]               = {2, 1, 18};
static UINT ids_ifOutDiscards[]                 = {2, 1, 19};
static UINT ids_ifOutErrors[]                   = {2, 1, 20};
static UINT ids_ifOutQLen[]                     = {2, 1, 21};
static UINT ids_ifSpecific[]                    = {2, 1, 22};

//
// The IP Group
//

static UINT ids_ipForwarding[]                  = {1, 0};
static UINT ids_ipDefaultTTL[]                  = {2, 0};
static UINT ids_ipInReceives[]                  = {3, 0};
static UINT ids_ipInHdrErrors[]                 = {4, 0};
static UINT ids_ipInAddrErrors[]                = {5, 0};
static UINT ids_ipForwDatagrams[]               = {6, 0};
static UINT ids_ipInUnknownProtos[]             = {7, 0};
static UINT ids_ipInDiscards[]                  = {8, 0};
static UINT ids_ipInDelivers[]                  = {9, 0};
static UINT ids_ipOutRequests[]                 = {10, 0};
static UINT ids_ipOutDiscards[]                 = {11, 0};
static UINT ids_ipOutNoRoutes[]                 = {12, 0};
static UINT ids_ipReasmTimeout[]                = {13, 0};
static UINT ids_ipReasmReqds[]                  = {14, 0};
static UINT ids_ipReasmOKs[]                    = {15, 0};
static UINT ids_ipReasmFails[]                  = {16, 0};
static UINT ids_ipFragOKs[]                     = {17, 0};
static UINT ids_ipFragFails[]                   = {18, 0};
static UINT ids_ipFragCreates[]                 = {19, 0};
static UINT ids_ipRoutingDiscards[]             = {23, 0};

//
// There are a three tables that fit in between IpFragCreates and 
// IpRoutingDiscards, but there are put after the scalars for clarity
//

static UINT ids_ipAddrTable[]                   = {20};
static UINT ids_ipRouteTable[]                  = {21};
static UINT ids_ipNetToMediaTable[]             = {22};


//
// The IP Address Table is composed of IP Address Entries which are 
// indexed by IpAdEntAddr
//

static UINT ids_ipAddrEntry[]                   = {20, 1};

//
// The entry is a sequence of:
//

static UINT ids_ipAdEntAddr[]                   = {20, 1, 1};
static UINT ids_ipAdEntIfIndex[]                = {20, 1, 2};
static UINT ids_ipAdEntNetMask[]                = {20, 1, 3};
static UINT ids_ipAdEntBcastAddr[]              = {20, 1, 4};
static UINT ids_ipAdEntReasmMaxSize[]           = {20, 1, 5};


//
// The IP Route Table is composed of IP Route Entries which are
// indexed by IpRouteDest
//

static UINT ids_ipRouteEntry[]                  = {21, 1};

//
// The entry is a sequence of:
//

static UINT ids_ipRouteDest[]                   = {21, 1, 1};
static UINT ids_ipRouteIfIndex[]                = {21, 1, 2};
static UINT ids_ipRouteMetric1[]                = {21, 1, 3};
static UINT ids_ipRouteMetric2[]                = {21, 1, 4};
static UINT ids_ipRouteMetric3[]                = {21, 1, 5};
static UINT ids_ipRouteMetric4[]                = {21, 1, 6};
static UINT ids_ipRouteNextHop[]                = {21, 1, 7};
static UINT ids_ipRouteType[]                   = {21, 1, 8};
static UINT ids_ipRouteProto[]                  = {21, 1, 9};
static UINT ids_ipRouteAge[]                    = {21, 1, 10};
static UINT ids_ipRouteMask[]                   = {21, 1, 11};
static UINT ids_ipRouteMetric5[]                = {21, 1, 12};
static UINT ids_ipRouteInfo[]                   = {21, 1, 13};


//
// The IP Net To Media Table is composed of IP Net To Media Entries which are
// indexed by IpNetToMediaIfIndex and IpNetToMediaNetAddress
//

static UINT ids_ipNetToMediaEntry[]             = {22, 1};

//
// The entry is a sequence of:
//

static UINT ids_ipNetToMediaIfIndex[]           = {22, 1, 1};
static UINT ids_ipNetToMediaPhysAddress[]       = {22, 1, 2};
static UINT ids_ipNetToMediaNetAddress[]        = {22, 1, 3};
static UINT ids_ipNetToMediaType[]              = {22, 1, 4};

//
// Then there is the IP Forward group which is one scalar and one table. It
// comes at the end of the IP group and is really a sub group of the IP Group
//

static UINT ids_ipForwardGroup[]                = {24};
static UINT ids_ipForwardNumber[]               = {24, 1, 0};
static UINT ids_ipForwardTable[]                = {24, 2};


//
// The IP Forward Table is composed of IP Forward Entries which are
// indexed by IpForwardDest, IpForwardProto, IpForwardPolicy and 
// IpForwardNextHop
//

static UINT ids_ipForwardEntry[]                = {24, 2, 1};

//
// The entry is a sequence of:
//

static UINT ids_ipForwardDest[]                 = {24, 2, 1, 1};
static UINT ids_ipForwardMask[]                 = {24, 2, 1, 2};
static UINT ids_ipForwardPolicy[]               = {24, 2, 1, 3};
static UINT ids_ipForwardNextHop[]              = {24, 2, 1, 4};
static UINT ids_ipForwardIfIndex[]              = {24, 2, 1, 5};
static UINT ids_ipForwardType[]                 = {24, 2, 1, 6};
static UINT ids_ipForwardProto[]                = {24, 2, 1, 7};
static UINT ids_ipForwardAge[]                  = {24, 2, 1, 8};
static UINT ids_ipForwardInfo[]                 = {24, 2, 1, 9};
static UINT ids_ipForwardNextHopAS[]            = {24, 2, 1, 10};
static UINT ids_ipForwardMetric1[]              = {24, 2, 1, 11};
static UINT ids_ipForwardMetric2[]              = {24, 2, 1, 12};
static UINT ids_ipForwardMetric3[]              = {24, 2, 1, 13};
static UINT ids_ipForwardMetric4[]              = {24, 2, 1, 14};
static UINT ids_ipForwardMetric5[]              = {24, 2, 1, 15};

//
// The IPv6 Group (RFC 2465)
//

static UINT ids_ipv6Forwarding[]                = {1, 0};
static UINT ids_ipv6DefaultHopLimit[]           = {2, 0};
static UINT ids_ipv6Interfaces[]                = {3, 0};
static UINT ids_ipv6IfTableLastChange[]         = {4, 0};
static UINT ids_ipv6RouteNumber[]               = {9, 0};
static UINT ids_ipv6DiscardedRoutes[]           = {10, 0};

static UINT ids_ipv6IfTable[]                   = {5};
static UINT ids_ipv6IfEntry[]                   = {5, 1};
static UINT ids_ipv6IfIndex[]                   = {5, 1, 1};
static UINT ids_ipv6IfDescr[]                   = {5, 1, 2};
static UINT ids_ipv6IfLowerLayer[]              = {5, 1, 3};
static UINT ids_ipv6IfEffectiveMtu[]            = {5, 1, 4};
static UINT ids_ipv6IfReasmMaxSize[]            = {5, 1, 5};
static UINT ids_ipv6IfIdentifier[]              = {5, 1, 6};
static UINT ids_ipv6IfIdentifierLength[]        = {5, 1, 7};
static UINT ids_ipv6IfPhysicalAddress[]         = {5, 1, 8};
static UINT ids_ipv6IfAdminStatus[]             = {5, 1, 9};
static UINT ids_ipv6IfOperStatus[]              = {5, 1,10};
static UINT ids_ipv6IfLastChange[]              = {5, 1,11};

static UINT ids_ipv6IfStatsTable[]              = {6};
static UINT ids_ipv6IfStatsEntry[]              = {6, 1};
static UINT ids_ipv6IfStatsInReceives[]         = {6, 1, 1};
static UINT ids_ipv6IfStatsInHdrErrors[]        = {6, 1, 2};
static UINT ids_ipv6IfStatsInTooBigErrors[]     = {6, 1, 3};
static UINT ids_ipv6IfStatsInNoRoutes[]         = {6, 1, 4};
static UINT ids_ipv6IfStatsInAddrErrors[]       = {6, 1, 5};
static UINT ids_ipv6IfStatsInUnknownProtos[]    = {6, 1, 6};
static UINT ids_ipv6IfStatsInTruncatedPkts[]    = {6, 1, 7};
static UINT ids_ipv6IfStatsInDiscards[]         = {6, 1, 8};
static UINT ids_ipv6IfStatsInDelivers[]         = {6, 1, 9};
static UINT ids_ipv6IfStatsOutForwDatagrams[]   = {6, 1,10};
static UINT ids_ipv6IfStatsOutRequests[]        = {6, 1,11};
static UINT ids_ipv6IfStatsOutDiscards[]        = {6, 1,12};
static UINT ids_ipv6IfStatsOutFragOKs[]         = {6, 1,13};
static UINT ids_ipv6IfStatsOutFragFails[]       = {6, 1,14};
static UINT ids_ipv6IfStatsOutFragCreates[]     = {6, 1,15};
static UINT ids_ipv6IfStatsReasmReqds[]         = {6, 1,16};
static UINT ids_ipv6IfStatsReasmOKs[]           = {6, 1,17};
static UINT ids_ipv6IfStatsReasmFails[]         = {6, 1,18};
static UINT ids_ipv6IfStatsInMcastPkts[]        = {6, 1,19};
static UINT ids_ipv6IfStatsOutMcastPkts[]       = {6, 1,20};

static UINT ids_ipv6AddrPrefixTable[]                = {7};
static UINT ids_ipv6AddrPrefixEntry[]                = {7, 1};
static UINT ids_ipv6AddrPrefix[]                     = {7, 1, 1};
static UINT ids_ipv6AddrPrefixLength[]               = {7, 1, 2};
static UINT ids_ipv6AddrPrefixOnLinkFlag[]           = {7, 1, 3};
static UINT ids_ipv6AddrPrefixAutonomousFlag[]       = {7, 1, 4};
static UINT ids_ipv6AddrPrefixAdvPreferredLifetime[] = {7, 1, 5};
static UINT ids_ipv6AddrPrefixAdvValidLifetime[]     = {7, 1, 6};

static UINT ids_ipv6AddrTable[]                 = {8};
static UINT ids_ipv6AddrEntry[]                 = {8, 1};
static UINT ids_ipv6AddrAddress[]               = {8, 1, 1};
static UINT ids_ipv6AddrPfxLength[]             = {8, 1, 2};
static UINT ids_ipv6AddrType[]                  = {8, 1, 3};
static UINT ids_ipv6AddrAnycastFlag[]           = {8, 1, 4};
static UINT ids_ipv6AddrStatus[]                = {8, 1, 5};

static UINT ids_ipv6RouteTable[]                = {11};
static UINT ids_ipv6RouteEntry[]                = {11, 1};
static UINT ids_ipv6RouteDest[]                 = {11, 1, 1};
static UINT ids_ipv6RoutePfxLength[]            = {11, 1, 2};
static UINT ids_ipv6RouteIndex[]                = {11, 1, 3};
static UINT ids_ipv6RouteIfIndex[]              = {11, 1, 4};
static UINT ids_ipv6RouteNextHop[]              = {11, 1, 5};
static UINT ids_ipv6RouteType[]                 = {11, 1, 6};
static UINT ids_ipv6RouteProtocol[]             = {11, 1, 7};
static UINT ids_ipv6RoutePolicy[]               = {11, 1, 8};
static UINT ids_ipv6RouteAge[]                  = {11, 1, 9};
static UINT ids_ipv6RouteNextHopRDI[]           = {11, 1,10};
static UINT ids_ipv6RouteMetric[]               = {11, 1,11};
static UINT ids_ipv6RouteWeight[]               = {11, 1,12};
static UINT ids_ipv6RouteInfo[]                 = {11, 1,13};
static UINT ids_ipv6RouteValid[]                = {11, 1,14};

static UINT ids_ipv6NetToMediaTable[]           = {12};
static UINT ids_ipv6NetToMediaEntry[]           = {12, 1};
static UINT ids_ipv6NetToMediaNetAddress[]      = {12, 1, 1};
static UINT ids_ipv6NetToMediaPhysAddress[]     = {12, 1, 2};
static UINT ids_ipv6NetToMediaType[]            = {12, 1, 3};
static UINT ids_ipv6NetToMediaState[]           = {12, 1, 4};
static UINT ids_ipv6NetToMediaLastUpdated[]     = {12, 1, 5};
static UINT ids_ipv6NetToMediaValid[]           = {12, 1, 6};

// 
// The ICMP group. It is just a bunch of scalars. All are READ-ONLY
//

static UINT ids_icmpInMsgs[]                    = {1, 0};
static UINT ids_icmpInErrors[]                  = {2, 0};
static UINT ids_icmpInDestUnreachs[]            = {3, 0};
static UINT ids_icmpInTimeExcds[]               = {4, 0};
static UINT ids_icmpInParmProbs[]               = {5, 0};
static UINT ids_icmpInSrcQuenchs[]              = {6, 0};
static UINT ids_icmpInRedirects[]               = {7, 0};
static UINT ids_icmpInEchos[]                   = {8, 0};
static UINT ids_icmpInEchoReps[]                = {9, 0};
static UINT ids_icmpInTimestamps[]              = {10, 0};
static UINT ids_icmpInTimestampReps[]           = {11, 0};
static UINT ids_icmpInAddrMasks[]               = {12, 0};
static UINT ids_icmpInAddrMaskReps[]            = {13, 0};
static UINT ids_icmpOutMsgs[]                   = {14, 0};
static UINT ids_icmpOutErrors[]                 = {15, 0};
static UINT ids_icmpOutDestUnreachs[]           = {16, 0};
static UINT ids_icmpOutTimeExcds[]              = {17, 0};
static UINT ids_icmpOutParmProbs[]              = {18, 0};
static UINT ids_icmpOutSrcQuenchs[]             = {19, 0};
static UINT ids_icmpOutRedirects[]              = {20, 0};
static UINT ids_icmpOutEchos[]                  = {21, 0};
static UINT ids_icmpOutEchoReps[]               = {22, 0};
static UINT ids_icmpOutTimestamps[]             = {23, 0};
static UINT ids_icmpOutTimestampReps[]          = {24, 0};
static UINT ids_icmpOutAddrMasks[]              = {25, 0};
static UINT ids_icmpOutAddrMaskReps[]           = {26, 0};
static UINT ids_inetIcmpTable[]                 = {27};
static UINT ids_inetIcmpEntry[]                 = {27, 1};
static UINT ids_inetIcmpAFType[]                = {27, 1, 1};
static UINT ids_inetIcmpIfIndex[]               = {27, 1, 2};
static UINT ids_inetIcmpInMsgs[]                = {27, 1, 3};
static UINT ids_inetIcmpInErrors[]              = {27, 1, 4};
static UINT ids_inetIcmpOutMsgs[]               = {27, 1, 5};
static UINT ids_inetIcmpOutErrors[]             = {27, 1, 6};
static UINT ids_inetIcmpMsgTable[]              = {28};
static UINT ids_inetIcmpMsgEntry[]              = {28, 1};
static UINT ids_inetIcmpMsgAFType[]             = {28, 1, 1};
static UINT ids_inetIcmpMsgIfIndex[]            = {28, 1, 2};
static UINT ids_inetIcmpMsgType[]               = {28, 1, 3};
static UINT ids_inetIcmpMsgCode[]               = {28, 1, 4};
static UINT ids_inetIcmpMsgInPkts[]             = {28, 1, 5};
static UINT ids_inetIcmpMsgOutPkts[]            = {28, 1, 6};

//
// The TCP group. It consists of some scalars (the TCP statistics) and the
// TCP Connection table
//

static UINT ids_tcpRtoAlgorithm[]               = {1, 0};
static UINT ids_tcpRtoMin[]                     = {2, 0};
static UINT ids_tcpRtoMax[]                     = {3, 0};
static UINT ids_tcpMaxConn[]                    = {4, 0};
static UINT ids_tcpActiveOpens[]                = {5, 0};
static UINT ids_tcpPassiveOpens[]               = {6, 0};
static UINT ids_tcpAttemptFails[]               = {7, 0};
static UINT ids_tcpEstabResets[]                = {8, 0};
static UINT ids_tcpCurrEstab[]                  = {9, 0};
static UINT ids_tcpInSegs[]                     = {10, 0};
static UINT ids_tcpOutSegs[]                    = {11, 0};
static UINT ids_tcpRetransSegs[]                = {12, 0};
static UINT ids_tcpInErrs[]                     = {14, 0};
static UINT ids_tcpOutRsts[]                    = {15, 0};

//
// The connection table fits between TcpRetransSegs and TcpInErrs
//

static UINT ids_tcpConnTable[]                  = {13};
static UINT ids_tcpNewConnTable[]               = {19};

//
// The TCP Connection Table is composed of TCP Connection Entries which are
// indexed by TcpConnLocalAddress, TcpConnLocalPort, TcpConnRemAddress, 
// TcpConnRemPort
//

static UINT ids_tcpConnEntry[]                  = {13, 1};
static UINT ids_tcpNewConnEntry[]               = {19, 1};

//
// The entry is a sequence of:
//

static UINT ids_tcpConnState[]                  = {13, 1, 1};
static UINT ids_tcpConnLocalAddress[]           = {13, 1, 2};
static UINT ids_tcpConnLocalPort[]              = {13, 1, 3};
static UINT ids_tcpConnRemAddress[]             = {13, 1, 4};
static UINT ids_tcpConnRemPort[]                = {13, 1, 5};

static UINT ids_tcpNewConnLocalAddressType[]    = {19, 1, 1};
static UINT ids_tcpNewConnLocalAddress[]        = {19, 1, 2};
static UINT ids_tcpNewConnLocalPort[]           = {19, 1, 3};
static UINT ids_tcpNewConnRemAddressType[]      = {19, 1, 4};
static UINT ids_tcpNewConnRemAddress[]          = {19, 1, 5};
static UINT ids_tcpNewConnRemPort[]             = {19, 1, 6};
static UINT ids_tcpNewConnState[]               = {19, 1, 7};

//
// The UDP group. Like the TCP, scalar statistics and a Listener table
//

static UINT ids_udpInDatagrams[]                = {1, 0};
static UINT ids_udpNoPorts[]                    = {2, 0};
static UINT ids_udpInErrors[]                   = {3, 0};
static UINT ids_udpOutDatagrams[]               = {4, 0};
static UINT ids_udpTable[]                      = {5, 0};
static UINT ids_udpListenerTable[]              = {7, 0};

//
// The UDP Listener Table is composed of Udp Entries which are indexed by 
// UdpLocalAddress and UdpLocalPort
//


static UINT ids_udpEntry[]                      = {5, 1};
static UINT ids_udpListenerEntry[]              = {7, 1};

//
// The entry is a sequence of:
//

static UINT ids_udpLocalAddress[]               = {5, 1, 1};
static UINT ids_udpLocalPort[]                  = {5, 1, 2};

static UINT ids_udpListenerLocalAddressType[]   = {7, 1, 1};
static UINT ids_udpListenerLocalAddress[]       = {7, 1, 2};
static UINT ids_udpListenerLocalPort[]          = {7, 1, 3};

SnmpMibEntry mib_sysGroup[] =
{
    MIB_OCTETSTRING_L(sysDescr,0,255),
    MIB_OBJECTIDENTIFIER(sysObjectID),
    MIB_TIMETICKS(sysUpTime),
    MIB_OCTETSTRING_RW_L(sysContact,0,255),
    MIB_OCTETSTRING_RW_L(sysName,0,255),
    MIB_OCTETSTRING_RW_L(sysLocation,0,255),
    MIB_INTEGER_L(sysServices,0,127),
    MIB_END()
};

SnmpMibEntry mib_ifGroup[] =
{
    MIB_INTEGER(ifNumber),
    MIB_TABLE_ROOT(ifTable),
        MIB_TABLE_ENTRY(ifEntry),
            MIB_INTEGER(ifIndex),
            MIB_DISPSTRING_L(ifDescr,0,255),
            MIB_INTEGER(ifType),
            MIB_INTEGER(ifMtu),
            MIB_GAUGE(ifSpeed),
            MIB_PHYSADDRESS(ifPhysAddress),
            MIB_INTEGER_RW(ifAdminStatus),
            MIB_INTEGER(ifOperStatus),
            MIB_TIMETICKS(ifLastChange),
            MIB_COUNTER(ifInOctets),
            MIB_COUNTER(ifInUcastPkts),
            MIB_COUNTER(ifInNUcastPkts),
            MIB_COUNTER(ifInDiscards),
            MIB_COUNTER(ifInErrors),
            MIB_COUNTER(ifInUnknownProtos),
            MIB_COUNTER(ifOutOctets),
            MIB_COUNTER(ifOutUcastPkts),
            MIB_COUNTER(ifOutNUcastPkts),
            MIB_COUNTER(ifOutDiscards),
            MIB_COUNTER(ifOutErrors),
            MIB_GAUGE(ifOutQLen),
            MIB_OBJECTIDENTIFIER(ifSpecific),
    MIB_END()
};

SnmpMibEntry mib_ipGroup[] =
{
    MIB_INTEGER(ipForwarding),
    MIB_INTEGER_RW(ipDefaultTTL),
    MIB_COUNTER(ipInReceives),
    MIB_COUNTER(ipInHdrErrors),
    MIB_COUNTER(ipInAddrErrors),
    MIB_COUNTER(ipForwDatagrams),
    MIB_COUNTER(ipInUnknownProtos),
    MIB_COUNTER(ipInDiscards),
    MIB_COUNTER(ipInDelivers),
    MIB_COUNTER(ipOutRequests),
    MIB_COUNTER(ipOutDiscards),
    MIB_COUNTER(ipOutNoRoutes),
    MIB_INTEGER(ipReasmTimeout),
    MIB_COUNTER(ipReasmReqds),
    MIB_COUNTER(ipReasmOKs),
    MIB_COUNTER(ipReasmFails),
    MIB_COUNTER(ipFragOKs),
    MIB_COUNTER(ipFragFails),
    MIB_COUNTER(ipFragCreates),
    MIB_TABLE_ROOT(ipAddrTable),
        MIB_TABLE_ENTRY(ipAddrEntry),
            MIB_IPADDRESS(ipAdEntAddr),
            MIB_INTEGER(ipAdEntIfIndex),
            MIB_IPADDRESS(ipAdEntNetMask),
            MIB_INTEGER(ipAdEntBcastAddr),
            MIB_INTEGER_L(ipAdEntReasmMaxSize,0,65535),
    MIB_TABLE_ROOT(ipRouteTable),
        MIB_TABLE_ENTRY(ipRouteEntry),
            MIB_IPADDRESS_RW(ipRouteDest),
            MIB_INTEGER_RW(ipRouteIfIndex),
            MIB_INTEGER_RW(ipRouteMetric1),
            MIB_INTEGER_RW(ipRouteMetric2),
            MIB_INTEGER_RW(ipRouteMetric3),
            MIB_INTEGER_RW(ipRouteMetric4),
            MIB_IPADDRESS_RW(ipRouteNextHop),
            MIB_INTEGER_RW(ipRouteType),
            MIB_INTEGER(ipRouteProto),
            MIB_INTEGER_RW(ipRouteAge),
            MIB_IPADDRESS_RW(ipRouteMask),
            MIB_INTEGER_RW(ipRouteMetric5),
            MIB_OBJECTIDENTIFIER(ipRouteInfo),
    MIB_TABLE_ROOT(ipNetToMediaTable),
        MIB_TABLE_ENTRY(ipNetToMediaEntry),
            MIB_INTEGER_RW(ipNetToMediaIfIndex),
            MIB_PHYSADDRESS_RW(ipNetToMediaPhysAddress),
            MIB_IPADDRESS_RW(ipNetToMediaNetAddress),
            MIB_INTEGER_RW(ipNetToMediaType),
    MIB_COUNTER(ipRoutingDiscards),
    MIB_GROUP(ipForwardGroup),
        MIB_GAUGE(ipForwardNumber),
        MIB_TABLE_ROOT(ipForwardTable),
            MIB_TABLE_ENTRY(ipForwardEntry),
                MIB_IPADDRESS(ipForwardDest),
                MIB_IPADDRESS_RW(ipForwardMask),
                MIB_INTEGER(ipForwardPolicy),
                MIB_IPADDRESS(ipForwardNextHop),
                MIB_INTEGER_RW(ipForwardIfIndex),
                MIB_INTEGER_RW(ipForwardType),
                MIB_INTEGER(ipForwardProto),
                MIB_INTEGER(ipForwardAge),
                MIB_OBJECTIDENTIFIER(ipForwardInfo),
                MIB_INTEGER_RW(ipForwardNextHopAS),
                MIB_INTEGER_RW(ipForwardMetric1),
                MIB_INTEGER_RW(ipForwardMetric2),
                MIB_INTEGER_RW(ipForwardMetric3),
                MIB_INTEGER_RW(ipForwardMetric4),
                MIB_INTEGER_RW(ipForwardMetric5),
    MIB_END()
};

SnmpMibEntry mib_icmpGroup[] =
{
    MIB_COUNTER(icmpInMsgs),
    MIB_COUNTER(icmpInErrors),
    MIB_COUNTER(icmpInDestUnreachs),
    MIB_COUNTER(icmpInTimeExcds),
    MIB_COUNTER(icmpInParmProbs),
    MIB_COUNTER(icmpInSrcQuenchs),
    MIB_COUNTER(icmpInRedirects),
    MIB_COUNTER(icmpInEchos),
    MIB_COUNTER(icmpInEchoReps),
    MIB_COUNTER(icmpInTimestamps),
    MIB_COUNTER(icmpInTimestampReps),
    MIB_COUNTER(icmpInAddrMasks),
    MIB_COUNTER(icmpInAddrMaskReps),
    MIB_COUNTER(icmpOutMsgs),
    MIB_COUNTER(icmpOutErrors),
    MIB_COUNTER(icmpOutDestUnreachs),
    MIB_COUNTER(icmpOutTimeExcds),
    MIB_COUNTER(icmpOutParmProbs),
    MIB_COUNTER(icmpOutSrcQuenchs),
    MIB_COUNTER(icmpOutRedirects),
    MIB_COUNTER(icmpOutEchos),
    MIB_COUNTER(icmpOutEchoReps),
    MIB_COUNTER(icmpOutTimestamps),
    MIB_COUNTER(icmpOutTimestampReps),
    MIB_COUNTER(icmpOutAddrMasks),
    MIB_COUNTER(icmpOutAddrMaskReps),
    MIB_TABLE_ROOT(inetIcmpTable),
        MIB_TABLE_ENTRY(inetIcmpEntry),
            MIB_INTEGER_NA(inetIcmpAFType),
            MIB_INTEGER_NA(inetIcmpIfIndex),
            MIB_COUNTER(inetIcmpInMsgs),
            MIB_COUNTER(inetIcmpInErrors),
            MIB_COUNTER(inetIcmpOutMsgs),
            MIB_COUNTER(inetIcmpOutErrors),
    MIB_TABLE_ROOT(inetIcmpMsgTable),
        MIB_TABLE_ENTRY(inetIcmpMsgEntry),
            MIB_INTEGER_NA(inetIcmpMsgAFType),
            MIB_INTEGER_NA(inetIcmpMsgIfIndex),
            MIB_INTEGER_NA(inetIcmpMsgType),
            MIB_INTEGER_NA(inetIcmpMsgCode),
            MIB_COUNTER(inetIcmpMsgInPkts),
            MIB_COUNTER(inetIcmpMsgOutPkts),
    MIB_END()
};

SnmpMibEntry mib_tcpGroup[] =
{
    MIB_INTEGER(tcpRtoAlgorithm),
    MIB_INTEGER(tcpRtoMin),
    MIB_INTEGER(tcpRtoMax),
    MIB_INTEGER(tcpMaxConn),
    MIB_COUNTER(tcpActiveOpens),
    MIB_COUNTER(tcpPassiveOpens),
    MIB_COUNTER(tcpAttemptFails),
    MIB_COUNTER(tcpEstabResets),
    MIB_GAUGE(tcpCurrEstab),
    MIB_COUNTER(tcpInSegs),
    MIB_COUNTER(tcpOutSegs),
    MIB_COUNTER(tcpRetransSegs),
    MIB_TABLE_ROOT(tcpConnTable),
        MIB_TABLE_ENTRY(tcpConnEntry),
            MIB_INTEGER_RW(tcpConnState),
            MIB_IPADDRESS(tcpConnLocalAddress),
            MIB_INTEGER_L(tcpConnLocalPort,0,65535),
            MIB_IPADDRESS(tcpConnRemAddress),
            MIB_INTEGER_L(tcpConnRemPort,0,65535),
    MIB_COUNTER(tcpInErrs),
    MIB_COUNTER(tcpOutRsts),
    // skips some oids here
    MIB_TABLE_ROOT(tcpNewConnTable),
        MIB_TABLE_ENTRY(tcpNewConnEntry),
            MIB_INTEGER_NA(tcpNewConnLocalAddressType),
            MIB_OCTETSTRING_NA(tcpNewConnLocalAddress),
            MIB_INTEGER_NA_L(tcpNewConnLocalPort,0,65535),
            MIB_INTEGER_NA(tcpNewConnRemAddressType),
            MIB_OCTETSTRING_NA(tcpNewConnRemAddress),
            MIB_INTEGER_NA_L(tcpNewConnRemPort,0,65535),
            MIB_INTEGER_RW(tcpNewConnState),
    MIB_END()
};

SnmpMibEntry mib_udpGroup[] =
{
    MIB_COUNTER(udpInDatagrams),
    MIB_COUNTER(udpNoPorts),
    MIB_COUNTER(udpInErrors),
    MIB_COUNTER(udpOutDatagrams),
    MIB_TABLE_ROOT(udpTable),
        MIB_TABLE_ENTRY(udpEntry),
            MIB_IPADDRESS(udpLocalAddress),
            MIB_INTEGER_L(udpLocalPort,0,65535),
    // ipv6UdpTable goes here, but is obsolete
    MIB_TABLE_ROOT(udpListenerTable),
        MIB_TABLE_ENTRY(udpListenerEntry),
            MIB_INTEGER_NA(udpListenerLocalAddressType),
            MIB_OCTETSTRING_NA(udpListenerLocalAddress),
            MIB_UNSIGNED32_L(udpListenerLocalPort,0,65535),
    MIB_END()
};

//
// IPv6 MIB (RFC 2465)
//
SnmpMibEntry mib_ipv6Group[] =
{
    MIB_INTEGER(ipv6Forwarding),
    MIB_INTEGER(ipv6DefaultHopLimit),
    MIB_UNSIGNED32(ipv6Interfaces),
    MIB_TIMETICKS(ipv6IfTableLastChange),
    MIB_TABLE_ROOT(ipv6IfTable),
        MIB_TABLE_ENTRY(ipv6IfEntry),
            MIB_INTEGER_NA(ipv6IfIndex),
            MIB_DISPSTRING_L(ipv6IfDescr,0,255),
            MIB_OBJECTIDENTIFIER(ipv6IfLowerLayer),
            MIB_UNSIGNED32(ipv6IfEffectiveMtu),
            MIB_UNSIGNED32(ipv6IfReasmMaxSize),
            MIB_OCTETSTRING(ipv6IfIdentifier),
            MIB_INTEGER(ipv6IfIdentifierLength),
            MIB_PHYSADDRESS(ipv6IfPhysicalAddress),
            MIB_INTEGER(ipv6IfAdminStatus),
            MIB_INTEGER(ipv6IfOperStatus),
            MIB_TIMETICKS(ipv6IfLastChange),
    MIB_TABLE_ROOT(ipv6IfStatsTable),
        MIB_TABLE_ENTRY(ipv6IfStatsEntry),
            MIB_INTEGER_NA(ipv6IfIndex),
            MIB_COUNTER(ipv6IfStatsInReceives),
            MIB_COUNTER(ipv6IfStatsInHdrErrors),
            MIB_COUNTER(ipv6IfStatsInTooBigErrors),
            MIB_COUNTER(ipv6IfStatsInNoRoutes),
            MIB_COUNTER(ipv6IfStatsInAddrErrors),
            MIB_COUNTER(ipv6IfStatsInUnknownProtos),
            MIB_COUNTER(ipv6IfStatsInTruncatedPkts),
            MIB_COUNTER(ipv6IfStatsInDiscards),
            MIB_COUNTER(ipv6IfStatsInDelivers),
            MIB_COUNTER(ipv6IfStatsOutForwDatagrams),
            MIB_COUNTER(ipv6IfStatsOutRequests),
            MIB_COUNTER(ipv6IfStatsOutDiscards),
            MIB_COUNTER(ipv6IfStatsOutFragOKs),
            MIB_COUNTER(ipv6IfStatsOutFragFails),
            MIB_COUNTER(ipv6IfStatsOutFragCreates),
            MIB_COUNTER(ipv6IfStatsReasmReqds),
            MIB_COUNTER(ipv6IfStatsReasmOKs),
            MIB_COUNTER(ipv6IfStatsReasmFails),
            MIB_COUNTER(ipv6IfStatsInMcastPkts),
            MIB_COUNTER(ipv6IfStatsOutMcastPkts),
    MIB_TABLE_ROOT(ipv6AddrPrefixTable),
        MIB_TABLE_ENTRY(ipv6AddrPrefixEntry),
            MIB_INTEGER_NA(ipv6IfIndex),
            MIB_OCTETSTRING_NA(ipv6AddrPrefix),
            MIB_INTEGER_NA(ipv6AddrPrefixLength),
            MIB_INTEGER(ipv6AddrPrefixOnLinkFlag),
            MIB_INTEGER(ipv6AddrPrefixAutonomousFlag),
            MIB_UNSIGNED32(ipv6AddrPrefixAdvPreferredLifetime),
            MIB_UNSIGNED32(ipv6AddrPrefixAdvValidLifetime),
    MIB_TABLE_ROOT(ipv6AddrTable),
        MIB_TABLE_ENTRY(ipv6AddrEntry),
            MIB_INTEGER_NA(ipv6IfIndex),
            MIB_OCTETSTRING_NA(ipv6AddrAddress),
            MIB_INTEGER(ipv6AddrPfxLength),
            MIB_INTEGER(ipv6AddrType),
            MIB_INTEGER(ipv6AddrAnycastFlag),
            MIB_INTEGER(ipv6AddrStatus),
    MIB_GAUGE(ipv6RouteNumber),
    MIB_COUNTER(ipv6DiscardedRoutes),
    MIB_TABLE_ROOT(ipv6RouteTable),
        MIB_TABLE_ENTRY(ipv6RouteEntry),
            MIB_OCTETSTRING_NA(ipv6RouteDest),
            MIB_INTEGER_NA(ipv6RoutePfxLength),
            MIB_INTEGER_NA(ipv6RouteIndex),
            MIB_INTEGER(ipv6RouteIfIndex),
            MIB_OCTETSTRING(ipv6RouteNextHop),
            MIB_INTEGER(ipv6RouteType),
            MIB_INTEGER(ipv6RouteProtocol),
            MIB_INTEGER(ipv6RoutePolicy),
            MIB_UNSIGNED32(ipv6RouteAge),
            MIB_UNSIGNED32(ipv6RouteNextHopRDI),
            MIB_UNSIGNED32(ipv6RouteMetric),
            MIB_UNSIGNED32(ipv6RouteWeight),
            MIB_OBJECTIDENTIFIER(ipv6RouteInfo),
            MIB_INTEGER(ipv6RouteValid),
    MIB_TABLE_ROOT(ipv6NetToMediaTable),
        MIB_TABLE_ENTRY(ipv6NetToMediaEntry),
            MIB_INTEGER_NA(ipv6IfIndex),
            MIB_OCTETSTRING_NA(ipv6NetToMediaNetAddress),
            MIB_PHYSADDRESS(ipv6NetToMediaPhysAddress),
            MIB_INTEGER(ipv6NetToMediaType),
            MIB_INTEGER(ipv6NetToMediaState),
            MIB_TIMETICKS(ipv6NetToMediaLastUpdated),
            MIB_INTEGER(ipv6NetToMediaValid),
    MIB_END()
};

//
// The list of the out-of-order table indices 
//

SnmpMibEntry * pi_ipNetToMediaEntry[] = {
    MIB_ENTRY_PTR(ipGroup, ipNetToMediaIfIndex),
    MIB_ENTRY_PTR(ipGroup, ipNetToMediaNetAddress)
};

SnmpMibEntry * pi_ipForwardEntry[] = {
    MIB_ENTRY_PTR(ipGroup, ipForwardDest),
    MIB_ENTRY_PTR(ipGroup, ipForwardProto),
    MIB_ENTRY_PTR(ipGroup, ipForwardPolicy),
    MIB_ENTRY_PTR(ipGroup, ipForwardNextHop)
};

SnmpMibEntry * pi_tcpConnEntry[] = {
    MIB_ENTRY_PTR(tcpGroup, tcpConnLocalAddress),
    MIB_ENTRY_PTR(tcpGroup, tcpConnLocalPort),
    MIB_ENTRY_PTR(tcpGroup, tcpConnRemAddress),
    MIB_ENTRY_PTR(tcpGroup, tcpConnRemPort)
};

//
// The list of the tables supported by the sub agent
//

SnmpMibTable tbl_ifGroup[] =
{
    MIB_TABLE(ifGroup, ifEntry, NULL)
};

SnmpMibTable tbl_ipGroup[] =
{
    MIB_TABLE(ipGroup, ipAddrEntry,       NULL),
    MIB_TABLE(ipGroup, ipRouteEntry,      NULL),
    MIB_TABLE(ipGroup, ipNetToMediaEntry, pi_ipNetToMediaEntry),
    MIB_TABLE(ipGroup, ipForwardEntry,    pi_ipForwardEntry)
};

SnmpMibTable tbl_icmpGroup[] =
{
    MIB_TABLE(icmpGroup, inetIcmpEntry,   NULL),
    MIB_TABLE(icmpGroup, inetIcmpMsgEntry,NULL)
};

SnmpMibTable tbl_tcpGroup[] =
{
    MIB_TABLE(tcpGroup, tcpConnEntry,     pi_tcpConnEntry),
    MIB_TABLE(tcpGroup, tcpNewConnEntry,  NULL)
};

SnmpMibTable tbl_udpGroup[] =
{
    MIB_TABLE(udpGroup, udpEntry,         NULL),
    MIB_TABLE(udpGroup, udpListenerEntry, NULL)
};

SnmpMibTable tbl_ipv6Group[] =
{
    MIB_TABLE(ipv6Group, ipv6IfEntry,         NULL),
    MIB_TABLE(ipv6Group, ipv6IfStatsEntry,    NULL),
    MIB_TABLE(ipv6Group, ipv6AddrPrefixEntry, NULL),
    MIB_TABLE(ipv6Group, ipv6AddrEntry,       NULL),
    MIB_TABLE(ipv6Group, ipv6RouteEntry,      NULL),
    MIB_TABLE(ipv6Group, ipv6NetToMediaEntry, NULL),
};

//
// This puts the mib_* and tbl_* entries together to create a complete view
//

SnmpMibView v_mib2[] = {{MIB_VERSION,
                         MIB_VIEW_NORMAL,
                         MIB_OID(ids_sysGroup),
                         MIB_ENTRIES(mib_sysGroup),
                         {NULL,0}},
                        {MIB_VERSION,
                         MIB_VIEW_NORMAL,
                         MIB_OID(ids_ifGroup),
                         MIB_ENTRIES(mib_ifGroup),
                         MIB_TABLES(tbl_ifGroup)},
                        {MIB_VERSION,
                         MIB_VIEW_NORMAL,
                         MIB_OID(ids_ipGroup),
                         MIB_ENTRIES(mib_ipGroup),
                         MIB_TABLES(tbl_ipGroup)},
                        {MIB_VERSION,
                         MIB_VIEW_NORMAL,
                         MIB_OID(ids_icmpGroup),
                         MIB_ENTRIES(mib_icmpGroup),
                         MIB_TABLES(tbl_icmpGroup)},
                        {MIB_VERSION,
                         MIB_VIEW_NORMAL,
                         MIB_OID(ids_tcpGroup),
                         MIB_ENTRIES(mib_tcpGroup),
                         MIB_TABLES(tbl_tcpGroup)},
                        {MIB_VERSION,
                         MIB_VIEW_NORMAL,
                         MIB_OID(ids_udpGroup),
                         MIB_ENTRIES(mib_udpGroup),
                         MIB_TABLES(tbl_udpGroup)},
                        {MIB_VERSION,
                         MIB_VIEW_NORMAL,
                         MIB_OID(ids_ipv6Group),
                         MIB_ENTRIES(mib_ipv6Group),
                         MIB_TABLES(tbl_ipv6Group)}};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tools\dod\precomp.h ===
#include <ndis.h>
#include <cxport.h>
#include <ip.h>         // for IPRcvBuf
#include <ipinfo.h>     // for route-lookup defs
#include <ntddip.h>     // for \Device\Ip I/O control codes
#include <ntddtcp.h>    // for \Device\Tcp I/O control codes
#include <ipfltinf.h>   // for firewall defs
#include <ipfilter.h>   // for firewall defs
#include <tcpinfo.h>    // for TCP_CONN_*
#include <tdiinfo.h>    // for CONTEXT_SIZE, TDIObjectID
#include <tdistat.h>    // for TDI status codes

#define DD_IP_DOD_DEVICE_NAME   L"\\Device\\MapRouteToInterfaceDriver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tools\checkv4\checkv4.c ===
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

//
// Localization library and MessageIds.
//
#include <nls.h>
#include <winnlsp.h>
#include "localmsg.h"

int
filematch(
    char *pszfile,
    char **ppszpat,
    int cpat,
    int fsubdirs
    );

typedef struct token_tmp {
   char *v4;
   char *v6;
   char *both;
} token_t;

token_t token[] = {
 { "AF_INET",           "AF_INET6",           NULL },
 { "PF_INET",           "PF_INET6",           NULL },
 { "in_addr",           "in6_addr",           NULL },
 { "IN_ADDR",           "IN6_ADDR",           NULL },
 { "PIN_ADDR",          "PIN6_ADDR",          NULL },
 { "LPIN_ADDR",         "LPIN6_ADDR",         NULL },
 { "IPAddr",            NULL,                 "SOCKADDR_STORAGE" },
 { "sockaddr_in",       "sockaddr_in6",       "sockaddr_storage" },
 { "SOCKADDR_IN",       "SOCKADDR_IN6",       "SOCKADDR_STORAGE" },
 { "PSOCKADDR_IN",      "PSOCKADDR_IN6",      "PSOCKADDR_STORAGE" },
 { "LPSOCKADDR_IN",     "LPSOCKADDR_IN6",     "LPSOCKADDR_STORAGE" },
 { "INADDR_ANY",        "in6addr_any",        "getaddrinfo with nodename=NULL and AI_PASSIVE" },
 { "INADDR_LOOPBACK",   "in6addr_loopback",   NULL },
 { "IPPROTO_IP",        "IPPROTO_IPV6",       NULL },
 { "IP_MULTICAST_IF",   "IPV6_MULTICAST_IF",  NULL },
 { "IP_MULTICAST_TTL",  "IPV6_MULTICAST_HOPS","SIO_MULTICAST_SCOPE" },
 { "IP_MULTICAST_LOOP", "IPV6_MULTICAST_LOOP","SIO_MULTIPOINT_LOOPBACK" },
 { "IP_ADD_MEMBERSHIP", "IPV6_JOIN_GROUP",    "WSAJoinLeaf" },
 { "IP_DROP_MEMBERSHIP","IPV6_LEAVE_GROUP",   NULL },
 { "ip_mreq",           "ipv6_mreq",          NULL },
 { "gethostbyname",     NULL,                 "getaddrinfo" },
 { "hostent",           NULL,                 "addrinfo" },
 { "HOSTENT",           NULL,                 "ADDRINFO" },
 { "PHOSTENT",          NULL,                 "LPADDRINFO" },
 { "LPHOSTENT",         NULL,                 "LPADDRINFO" },
 { "inet_addr",         NULL,                "WSAStringToAddress or getaddrinfo with AI_NUMERICHOST"},
 { "gethostbyaddr",     NULL,                 "getnameinfo" },
 { "inet_ntoa",         NULL,                "WSAAddressToString or getnameinfo with NI_NUMERICHOST"},
 { "IN_MULTICAST",      "IN6_IS_ADDR_MULTICAST", NULL },
 { "IN_CLASSD",         "IN6_IS_ADDR_MULTICAST", NULL },
 { "IP_TTL",            "IPV6_UNICAST_HOPS",     NULL },
 { "IN_CLASSA",         NULL,                    NULL },
 { "IN_CLASSB",         NULL,                    NULL },
 { "IN_CLASSC",         NULL,                    NULL },
 { "INADDR_BROADCAST",  NULL,                    NULL },
 { "WSAAsyncGetHostByAddr", NULL,                "getnameinfo" },
 { "WSAAsyncGetHostByName", NULL,                "getaddrinfo" },
 { NULL, NULL, NULL },
};

void
process_line(filename, lineno, str)
   char *filename;
   int   lineno;
   char *str;
{
   int   i, len;
   char *p;

   for (i=0; token[i].v4 != NULL; i++) {
      p = strstr(str, token[i].v4);
      if (p == NULL)
         continue;
      if (p>str && (isalnum(p[-1]) || p[-1] == '_'))
         continue; /* not the start of a token */
      len = strlen(token[i].v4);
      if (isalnum(p[len]) || p[len] == '_')
         continue; /* not the end of a token */
      
      NlsPutMsg(STDOUT, CHECKV4_MESSAGE_0, filename, lineno, token[i].v4);
// printf("%s(%d) : %s : ", filename, lineno, token[i].v4);

      if (token[i].both) {
          NlsPutMsg(STDOUT, CHECKV4_MESSAGE_1, token[i].both);
// printf("use %s instead", token[i].both);

      } 

      if (token[i].v6) {
          if (token[i].both) 
             NlsPutMsg(STDOUT, CHECKV4_MESSAGE_2);
// printf(", or ");

          NlsPutMsg(STDOUT, CHECKV4_MESSAGE_3, token[i].v6);
// printf("use %s in addition for IPv6 support", token[i].v6);

      }

      if (!token[i].both && !token[i].v6) {
          NlsPutMsg(STDOUT, CHECKV4_MESSAGE_4);
// printf("valid for IPv4-only");

      }
      NlsPutMsg(STDOUT, CHECKV4_MESSAGE_5);
// printf("\n");

   }
}

void
process_file(filename)
   char *filename;
{
   FILE *fp;
   char  buff[1024];
   int   lineno;

   fp = fopen(filename, "r");
   if (fp == NULL) {
      NlsPutMsg(STDOUT, CHECKV4_MESSAGE_6, filename);
// printf("%s: cannot open file\n", filename);

      return;
   }

   lineno = 0;
   while (fgets(buff, sizeof(buff), fp)) {
      lineno++;
      process_line(filename, lineno, buff);
   }

   fclose(fp);
}

int
__cdecl
main(argc, argv)
   int argc;
   char **argv;
{
   int i;
   int recurse = 0;
   char szfile[MAX_PATH];

   //
   // This will ensure the correct language message is displayed when
   // NlsPutMsg is called.
   //
   SetThreadUILanguage(0);
   
   argc--;
   argv++;

   if (argc>0) {
      if (!_stricmp(argv[0], "/s")) {
         recurse = 1;
         argc--;
         argv++;
      } else if (!_stricmp(argv[0], "/?")) {
         NlsPutMsg(STDOUT, CHECKV4_USAGE);
         return 1;
      }
   }

   if (argc < 1) {
      NlsPutMsg(STDOUT, CHECKV4_MESSAGE_7);

      return 1;
   }

   while (filematch(szfile,argv,argc,recurse) >= 0) {
      process_file(szfile);
   }

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tools\dod\dod.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    dod.c

Abstract:

    This module contains code for a simple map-route-to-interface driver

Author:

    Abolade Gbadegesin (aboladeg)   15-Aug-1999

Revision History:

    Based on tcpip\tools\pfd.

--*/

#include "precomp.h"
#pragma hdrstop

extern PDEVICE_OBJECT IpDeviceObject = NULL;
extern PFILE_OBJECT IpFileObject = NULL;
extern PDEVICE_OBJECT DodDeviceObject = NULL;


uint
DodMapRouteToInterface(
    ROUTE_CONTEXT Context,
    IPAddr Destination,
    IPAddr Source,
    uchar Protocol,
    uchar* Buffer,
    uint Length,
    IPAddr HdrSrc
    )
{
    return INVALID_IF_INDEX;
} // DodMapRouteToInterface


NTSTATUS
DodSetMapRouteToInterfaceHook(
    BOOLEAN Install
    )
{
    IP_SET_MAP_ROUTE_HOOK_INFO HookInfo;
    IO_STATUS_BLOCK IoStatus;
    PIRP Irp;
    KEVENT LocalEvent;
    NTSTATUS status;

    KdPrint(("DodSetMapRouteToInterfaceHook\n"));

    HookInfo.MapRoutePtr = Install ? DodMapRouteToInterface : NULL;

    KeInitializeEvent(&LocalEvent, SynchronizationEvent, FALSE);
    Irp = IoBuildDeviceIoControlRequest(IOCTL_IP_SET_MAP_ROUTE_POINTER,
                                        IpDeviceObject,
                                        (PVOID)&HookInfo, sizeof(HookInfo),
                                        NULL, 0, FALSE, &LocalEvent, &IoStatus);

    if (!Irp) {
        KdPrint(("DodSetMapRouteToInterfaceHook: IoBuildDeviceIoControlRequest=0\n"));
        return STATUS_UNSUCCESSFUL;
    }

    status = IoCallDriver(IpDeviceObject, Irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&LocalEvent, Executive, KernelMode, FALSE, NULL);
        status = IoStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        KdPrint(("DodSetMapRouteToInterfaceHook: SetMapRoutePointer=%x\n", status));
    }

    return status;

} // DodSetMapRouteToInterfaceHook



NTSTATUS
DodInitializeDriver(
    VOID
    )
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS status;
    UNICODE_STRING UnicodeString;

    KdPrint(("DodInitializeDriver\n"));

    RtlInitUnicodeString(&UnicodeString, DD_IP_DEVICE_NAME);
    status = IoGetDeviceObjectPointer(&UnicodeString,
                                      SYNCHRONIZE|GENERIC_READ|GENERIC_WRITE,
                                      &IpFileObject, &IpDeviceObject);
    if (!NT_SUCCESS(status)) {
        KdPrint(("DodInitializeDriver: error %X getting IP object\n", status));
        return status;
    }
    ObReferenceObject(IpDeviceObject);

    return DodSetMapRouteToInterfaceHook(TRUE);

} // DodInitializeDriver


VOID
DodUnloadDriver(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    Performs cleanup for the filter-driver.

Arguments:

    DriverObject - reference to the module's driver-object

Return Value:

--*/

{
    KdPrint(("DodUnloadDriver\n"));

    DodSetMapRouteToInterfaceHook(FALSE);
    IoDeleteDevice(DriverObject->DeviceObject);
    ObDereferenceObject((PVOID)IpFileObject);
    ObDereferenceObject(IpDeviceObject);

} // DodUnloadDriver



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Performs driver-initialization for the filter driver.

Arguments:

Return Value:

    STATUS_SUCCESS if initialization succeeded, error code otherwise.

--*/

{
    WCHAR DeviceName[] = DD_IP_DOD_DEVICE_NAME;
    UNICODE_STRING DeviceString;
    NTSTATUS status;

    PAGED_CODE();

    KdPrint(("DodDriverEntry\n"));

    RtlInitUnicodeString(&DeviceString, DeviceName);
    status = IoCreateDevice(DriverObject, 0, &DeviceString,
                            FILE_DEVICE_NETWORK, FILE_DEVICE_SECURE_OPEN,
                            FALSE, &DodDeviceObject);
    if (!NT_SUCCESS(status)) {
        KdPrint(("IoCreateDevice failed (0x%08X)\n", status));
        return status;
    }

    DriverObject->DriverUnload = DodUnloadDriver;
    DriverObject->DriverStartIo = NULL;

    status = DodInitializeDriver();

    return status;

} // DriverEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tools\checkv4\recurse.c ===
// recurse.c
//      Except for this comment, this file is identical to 
//      base\fs\utils\findstr\recurse.c

#include <ctype.h>
#include <direct.h>
#include <malloc.h>
#include <string.h>
#include <windows.h>
#include <assert.h>
#include <stdlib.h>

typedef struct patarray_s {
    HANDLE  hfind;           // handle for FindFirstFile/FindNextFile
    BOOLEAN find_next_file;  // TRUE if FindNextFile is to be called
    BOOLEAN IsDir;           // TRUE if current found file is a dir
    char    szfile[MAX_PATH];// Name of file/dir found
} patarray_t;

typedef struct dirstack_s {
    struct dirstack_s *next;    // Next element in stack
    struct dirstack_s *prev;    // Previous element in stack
    HANDLE  hfind;
    patarray_t *ppatarray;      // pointer to an array of pattern records
    char szdir[1];              // Directory name
} dirstack_t;                   // Directory stack

#define FA_ATTR(x)  ((x).dwFileAttributes)
#define FA_CCHNAME(x)   MAX_PATH
#define FA_NAME(x)  ((x).cFileName)
#define FA_ALL      (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN | \
                     FILE_ATTRIBUTE_SYSTEM)
#define FA_DIR      FILE_ATTRIBUTE_DIRECTORY

static dirstack_t *pdircur = NULL;  // Current directory pointer

void
makename(
    char *pszfile,
    char *pszname
    )
{
    dirstack_t *pdir;               // Directory stack pointer

    *pszfile = '\0';                // Start with null string
    pdir = pdircur;                 // Point at last entry
    if (pdir->next != pdircur) {    // If not only entry
        do {
            pdir = pdir->next;      // Advance to next subdirectory
            strcat(pszfile,pdir->szdir);// Add the subdirectory
        } while (pdir != pdircur);  // Do until current directory
    } else
        strcpy(pszfile, pdircur->szdir);

    strcat(pszfile,pszname);
}


int
filematch(
    char *pszfile,
    char **ppszpat,
    int cpat,
    int fsubdirs
    )
{
    WIN32_FIND_DATA fi, fi2;
    BOOL            b;
    int i;
    dirstack_t *pdir;
    patarray_t *pPatFind;
    char       drive[_MAX_DRIVE];
    char       dir[_MAX_DIR];
    char       fname[_MAX_FNAME];
    char       ext[_MAX_EXT];

    assert(INVALID_HANDLE_VALUE != NULL);

    if (pdircur == NULL) {

       // If stack empty
       if ((pdircur = (dirstack_t *) malloc(sizeof(dirstack_t)+MAX_PATH+1)) == NULL)
            return(-1);                     // Fail if allocation fails

       if ((pdircur->ppatarray =
                (patarray_t *) malloc(sizeof(patarray_t)*cpat)) == NULL) {
            free(pdircur);
            return(-1);
       }
       pdircur->szdir[0] = '\0';                // Root has no name
       pdircur->hfind = INVALID_HANDLE_VALUE;   // No search handle yet
       pdircur->next = pdircur->prev = pdircur; // Entry points to self

       _splitpath(ppszpat[0], drive, dir, fname, ext);

       strcpy(pdircur->szdir, drive);
       strcat(pdircur->szdir, dir);

       strcpy(ppszpat[0], fname);
       strcat(ppszpat[0], ext);

       for (i=1; i<cpat; i++) {
          _splitpath(ppszpat[i], drive, dir, fname, ext);
          strcpy(ppszpat[i], fname);
          strcat(ppszpat[i], ext);
       }

       for (i=0; i<cpat; i++) {
           pdircur->ppatarray[i].hfind = INVALID_HANDLE_VALUE;
           pdircur->ppatarray[i].szfile[0] = '\0';
       }
    }

    while (pdircur != NULL) {
        // While directories remain

        b = TRUE;

        if (pdircur->hfind == INVALID_HANDLE_VALUE) {
            // If no handle yet

            makename(pszfile,"*.*");        // Make search name

            pdircur->hfind = FindFirstFile((LPSTR) pszfile,
            (LPWIN32_FIND_DATA) &fi);       // Find first matching entry
        } else

           b = FindNextFile(pdircur->hfind,
               (LPWIN32_FIND_DATA) &fi);    // Else find next matching entry

        if (b == FALSE || pdircur->hfind == INVALID_HANDLE_VALUE) {
            // If search fails

            if (pdircur->hfind != INVALID_HANDLE_VALUE)
                FindClose(pdircur->hfind);
            pdir = pdircur;     // Point at record to delete
            if ((pdircur = pdir->prev) != pdir) {
                // If no parent directory

                pdircur->next = pdir->next; // Delete record from list
                pdir->next->prev = pdircur;
            } else
                pdircur = NULL;             // Else cause search to stop

            pPatFind = pdir->ppatarray;
            for (i=0; i<cpat; i++) {
                if (pPatFind[i].hfind != NULL &&
                    pPatFind[i].hfind != INVALID_HANDLE_VALUE)
                    FindClose(pPatFind[i].hfind);
            }
            free(pdir->ppatarray);
            free(pdir);                     // Free the record
            continue;                       // Top of loop
        }


        if (FA_ATTR(fi) & FA_DIR) {
            // If subdirectory found

            if (fsubdirs &&
                strcmp(FA_NAME(fi),".") != 0 && strcmp(FA_NAME(fi),"..") != 0 &&
                (pdir = (dirstack_t *) malloc(sizeof(dirstack_t)+FA_CCHNAME(fi)+1)) != NULL)
            {
                if ((pdir->ppatarray =
                        (patarray_t *) malloc(sizeof(patarray_t)*cpat)) == NULL) {
                     free(pdir);
                     continue;
                }
                // If not "." nor ".." and alloc okay

                strcpy(pdir->szdir,FA_NAME(fi));      // Copy name to buffer
                strcat(pdir->szdir,"\\");             // Add trailing backslash
                pdir->hfind = INVALID_HANDLE_VALUE;   // No search handle yet
                pdir->next = pdircur->next;           // Insert entry in linked list
                pdir->prev = pdircur;
                for (i=0; i<cpat; i++) {
                    pdir->ppatarray[i].hfind = INVALID_HANDLE_VALUE;
                    pdir->ppatarray[i].szfile[0] = '\0';
                }
                pdircur->next = pdir;
                pdir->next->prev = pdir;
                pdircur = pdir;             // Make new entry current
            }
            continue;                       // Top of loop
        }

        pPatFind = pdircur->ppatarray;
        for (i = cpat; i-- > 0; ) {
            // Loop to see if we care
            b = (pPatFind[i].hfind != NULL);
            for (;;) {
                if (pPatFind[i].hfind == INVALID_HANDLE_VALUE) {
                    makename(pszfile, ppszpat[i]);
                    pPatFind[i].hfind = FindFirstFile(pszfile, &fi2);
                    b = (pPatFind[i].hfind != INVALID_HANDLE_VALUE);
                    pPatFind[i].find_next_file = FALSE;
                    if (b) {
                        strcpy(pPatFind[i].szfile, FA_NAME(fi2));
                        pPatFind[i].IsDir = (BOOLEAN)(FA_ATTR(fi2) & FA_DIR);
                    }
                } else if (pPatFind[i].find_next_file) {
                    b = FindNextFile(pPatFind[i].hfind, &fi2);
                    pPatFind[i].find_next_file = FALSE;
                    if (b) {
                        strcpy(pPatFind[i].szfile, FA_NAME(fi2));
                        pPatFind[i].IsDir = (BOOLEAN)(FA_ATTR(fi2) & FA_DIR);
                    }
                }
                if (b) {
                    if (pPatFind[i].IsDir) {
                        pPatFind[i].find_next_file = TRUE;
                    } else
                        break;   // found a file to do matching
                } else {
                    if (pPatFind[i].hfind != NULL &&
                            pPatFind[i].hfind != INVALID_HANDLE_VALUE) {
                        FindClose(pPatFind[i].hfind);
                        pPatFind[i].hfind = NULL;
                    }
                    pPatFind[i].find_next_file = FALSE;
                    break;    // exhausted all entries
                }
            } // for

            if (b) {
                if (strcmp(FA_NAME(fi), pPatFind[i].szfile) == 0) {
                    pPatFind[i].find_next_file = TRUE;
                    makename(pszfile, FA_NAME(fi));
                    return 1;
                }
            }
        }
    }
    return(-1);             // No match found
}



#ifdef  TEST
#include <process.h>
#include <stdio.h>

void
main(
    int carg,
    char **ppszarg
    )
{
    char szfile[MAX_PATH]; // if OS2: CCHPATHMAX];

    while (filematch(szfile,ppszarg,carg) >= 0)
    printf("%s\n",szfile);
    exit(0);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tools\enablerouter\enablerouter.c ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    enablerouter.c

Abstract:

    This module implements a system utility for dynamically enabling forwarding
    on Windows 2000 systems using the EnableRouter and UnenableRouter routines.

Author:

    Abolade Gbadegesin (aboladeg)   26-March-1999

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
int __cdecl
main(
    int argc,
    char* argv[]
    )
{
    HINSTANCE Hinstance = LoadLibrary("IPHLPAPI.DLL");
    if (!Hinstance) {
        printf("LoadLibrary: %d\n", GetLastError());
    } else {
        DWORD (WINAPI* EnableRouter)(PHANDLE, LPOVERLAPPED) =
            (DWORD (WINAPI*)(PHANDLE, LPOVERLAPPED))
                GetProcAddress(Hinstance, "EnableRouter");
        DWORD (WINAPI* UnenableRouter)(LPOVERLAPPED, LPDWORD) =
            (DWORD (WINAPI*)(LPOVERLAPPED, LPDWORD))
                GetProcAddress(Hinstance, "UnenableRouter");
        if (!EnableRouter || !UnenableRouter) {
            printf("GetProcAddress: %d\n", GetLastError());
        } else {
            DWORD Error;
            HANDLE Handle;
            OVERLAPPED Overlapped;
            DWORD Count;
            ZeroMemory(&Overlapped, sizeof(Overlapped));
            Overlapped.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
            if (!Overlapped.hEvent) {
                printf("CreateEvent: %d\n", GetLastError());
            } else {
                Error = EnableRouter(&Handle, &Overlapped);
                if (Error != ERROR_IO_PENDING) {
                    printf("EnableRouter: %d\n", Error);
                } else {
                    printf("Forwarding is now enabled.");
                    printf("Press <Enter> to disable forwarding...");
                    getchar();
                    Error = UnenableRouter(&Overlapped, &Count);
                    if (Error) {
                        printf("UnenableRouter: %d\n", Error);
                    } else {
                        printf("UnenableRouter: %d references left\n", Count);
                    }
                    CloseHandle(Overlapped.hEvent);
                }
            }
        }
        FreeLibrary(Hinstance);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tools\ipfw\ipfw.c ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    ipfw.c

Abstract:

    This module implements a driver which demonstrates the use of
    the TCP/IP driver's support for firewall hooks. It interacts with
    a user-mode control-program to support registration of multiple
    firewall routines.

Author:

    Abolade Gbadegesin (aboladeg)   7-March-2000

Revision History:

--*/

#include <ndis.h>
#include <ipfirewall.h>
#include "ipfw.h"

//
// Structure:   IPFW_ROUTINE
//
// Used to manage the table of routines registered with TCP/IP.
//

typedef struct _IPFW_ROUTINE {
    IPPacketFirewallPtr Routine;
    UINT Priority;
    ULONG Flags;
    ULONG PacketCount;
} IPFW_ROUTINE, *PIPFW_ROUTINE;

#define IPFW_ROUTINE_FLAG_REGISTERED 0x00000001

extern IPFW_ROUTINE IpfwRoutineTable[];

#define DEFINE_IPFW_ROUTINE(_Index) \
    FORWARD_ACTION IpfwRoutine##_Index( \
        VOID** Data, \
        UINT ReceiveIndex, \
        UINT* SendIndex, \
        PUCHAR DestinationType, \
        PVOID Context, \
        UINT ContextLength, \
        IPRcvBuf** OutputData \
        ) { \
        InterlockedIncrement(&IpfwRoutineTable[_Index].PacketCount); \
        return FORWARD; \
    }
#define INCLUDE_IPFW_ROUTINE(_Index) \
    { IpfwRoutine##_Index, 0, 0 },

DEFINE_IPFW_ROUTINE(0)
DEFINE_IPFW_ROUTINE(1)
DEFINE_IPFW_ROUTINE(2)
DEFINE_IPFW_ROUTINE(3)
DEFINE_IPFW_ROUTINE(4)
DEFINE_IPFW_ROUTINE(5)
DEFINE_IPFW_ROUTINE(6)
DEFINE_IPFW_ROUTINE(7)
DEFINE_IPFW_ROUTINE(8)
DEFINE_IPFW_ROUTINE(9)

IPFW_ROUTINE IpfwRoutineTable[IPFW_ROUTINE_COUNT] = {
    INCLUDE_IPFW_ROUTINE(0)
    INCLUDE_IPFW_ROUTINE(1)
    INCLUDE_IPFW_ROUTINE(2)
    INCLUDE_IPFW_ROUTINE(3)
    INCLUDE_IPFW_ROUTINE(4)
    INCLUDE_IPFW_ROUTINE(5)
    INCLUDE_IPFW_ROUTINE(6)
    INCLUDE_IPFW_ROUTINE(7)
    INCLUDE_IPFW_ROUTINE(8)
    INCLUDE_IPFW_ROUTINE(9)
};
KSPIN_LOCK IpfwRoutineLock;
PDEVICE_OBJECT IpfwDeviceObject = NULL;

//
// FORWARD DECLARATIONS
//

NTSTATUS
IpfwClose(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
IpfwCreate(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

VOID
IpfwUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine implements the standard driver-entry for an NT driver.
    It is responsible for registering with the TCP/IP driver.

Arguments:

    DriverObject - object to be initialized with NT driver entrypoints

    RegistryPath - contains path to this driver's registry key

Return Value:

    NTSTATUS - indicates success/failure.

--*/

{
    UNICODE_STRING DeviceName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE ServiceKey;
    NTSTATUS status;

    KdPrint(("DriverEntry\n"));

    KeInitializeSpinLock(&IpfwRoutineLock);

    //
    // Create a device-object on which to communicate with the control program.
    //

    RtlInitUnicodeString(&DeviceName, DD_IPFW_DEVICE_NAME);
    status =
        IoCreateDevice(
            DriverObject,
            0,
            &DeviceName,
            FILE_DEVICE_NETWORK,
            FILE_DEVICE_SECURE_OPEN,
            FALSE,
            &IpfwDeviceObject
            );
    if (!NT_SUCCESS(status)) {
        KdPrint(("DriverEntry: IoCreateDevice=%08x\n", status));
        return status;
    }

    //
    // Create dispatch points for create/open, cleanup, unload.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] = IpfwCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = IpfwClose;
    DriverObject->DriverUnload = IpfwUnload;

    return STATUS_SUCCESS;
} // DriverEntry


NTSTATUS
IpfwClose(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
    UNICODE_STRING  DeviceString;
    KEVENT Event;
    PFILE_OBJECT FileObject;
    ULONG i;
    IO_STATUS_BLOCK IoStatus;
    PDEVICE_OBJECT IpDeviceObject;
    KIRQL Irql;
    PIRP RegisterIrp;
    IP_SET_FIREWALL_HOOK_INFO SetHookInfo;
    NTSTATUS status;

    KdPrint(("IpfwClose\n"));

    i = PtrToUlong(IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext);

#if DBG
    KeAcquireSpinLock(&IpfwRoutineLock, &Irql);
    ASSERT(IpfwRoutineTable[i].Flags & IPFW_ROUTINE_FLAG_REGISTERED);
    KeReleaseSpinLock(&IpfwRoutineLock, Irql);
#endif

    //
    // Revoke the registration made on behalf of the client whose file-object
    // is being closed.
    // Obtain a pointer to the IP device-object,
    // construct a registration IRP, and attempt to register the routine
    // selected above.
    //

    RtlInitUnicodeString(&DeviceString, DD_IP_DEVICE_NAME);
    status =
        IoGetDeviceObjectPointer(
            &DeviceString,
            SYNCHRONIZE|GENERIC_READ|GENERIC_WRITE,
            &FileObject,
            &IpDeviceObject
            );
    if (NT_SUCCESS(status)) {
        ObReferenceObject(IpDeviceObject);
        SetHookInfo.FirewallPtr = IpfwRoutineTable[i].Routine;
        SetHookInfo.Priority = 0; // Unused
        SetHookInfo.Add = FALSE;
        KeInitializeEvent(&Event, SynchronizationEvent, FALSE);
        RegisterIrp =
            IoBuildDeviceIoControlRequest(
                IOCTL_IP_SET_FIREWALL_HOOK,
                IpDeviceObject,
                (PVOID)&SetHookInfo,
                sizeof(SetHookInfo),
                NULL,
                0,
                FALSE,
                &Event,
                &IoStatus
                );
        if (!RegisterIrp) {
            status = STATUS_UNSUCCESSFUL;
        } else {
            status = IoCallDriver(IpDeviceObject, RegisterIrp);
            if (status == STATUS_PENDING) {
                KeWaitForSingleObject(
                    &Event, Executive, KernelMode, FALSE, NULL
                    );
                status = IoStatus.Status;
            }

            ASSERT(NT_SUCCESS(status));
        }

        ObDereferenceObject((PVOID)FileObject);
        ObDereferenceObject(IpDeviceObject);
    }

    //
    // Release the entry in the table of routines.
    //

    KeAcquireSpinLock(&IpfwRoutineLock, &Irql);
    IpfwRoutineTable[i].Flags &= ~IPFW_ROUTINE_FLAG_REGISTERED;
    KeReleaseSpinLock(&IpfwRoutineLock, Irql);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
} // IpfwClose


NTSTATUS
IpfwCreate(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked by the I/O manager to inform us that a handle has
    been opened on our device-object.
--*/

{
    PIPFW_CREATE_PACKET CreatePacket;
    UNICODE_STRING  DeviceString;
    PFILE_FULL_EA_INFORMATION EaBuffer;
    KEVENT Event;
    PFILE_OBJECT FileObject;
    ULONG i;
    IO_STATUS_BLOCK IoStatus;
    PDEVICE_OBJECT IpDeviceObject;
    KIRQL Irql;
    UINT Priority;
    PIRP RegisterIrp;
    IP_SET_FIREWALL_HOOK_INFO SetHookInfo;
    NTSTATUS status;

    KdPrint(("IpfwCreate\n"));

    //
    // Extract the parameters supplied by the caller.
    //

    if ((EaBuffer = Irp->AssociatedIrp.SystemBuffer) &&
        EaBuffer->EaValueLength >= sizeof(IPFW_CREATE_PACKET)) {
        CreatePacket =
            (PIPFW_CREATE_PACKET)
                (EaBuffer->EaName + EaBuffer->EaNameLength + 1);
        Priority = CreatePacket->Priority;
    } else {
        Priority = 0;
    }

    //
    // Look for a free entry in the function-table
    //

    KeAcquireSpinLock(&IpfwRoutineLock, &Irql);
    for (i = 0; i < IPFW_ROUTINE_COUNT; i++) {
        if (!(IpfwRoutineTable[i].Flags & IPFW_ROUTINE_FLAG_REGISTERED)) {
            IpfwRoutineTable[i].Flags |= IPFW_ROUTINE_FLAG_REGISTERED;
            break;
        }
    }
    KeReleaseSpinLock(&IpfwRoutineLock, Irql);

    if (i >= IPFW_ROUTINE_COUNT) {
        status = STATUS_UNSUCCESSFUL;
    } else {

        //
        // Obtain a pointer to the IP device-object,
        // construct a registration IRP, and attempt to register the routine
        // selected above.
        //

        RtlInitUnicodeString(&DeviceString, DD_IP_DEVICE_NAME);
        status =
            IoGetDeviceObjectPointer(
                &DeviceString,
                SYNCHRONIZE|GENERIC_READ|GENERIC_WRITE,
                &FileObject,
                &IpDeviceObject
                );
        if (NT_SUCCESS(status)) {
            ObReferenceObject(IpDeviceObject);
            SetHookInfo.FirewallPtr = IpfwRoutineTable[i].Routine;
            SetHookInfo.Priority = Priority ? Priority : i + 1;
            SetHookInfo.Add = TRUE;
            KeInitializeEvent(&Event, SynchronizationEvent, FALSE);
            RegisterIrp =
                IoBuildDeviceIoControlRequest(
                    IOCTL_IP_SET_FIREWALL_HOOK,
                    IpDeviceObject,
                    (PVOID)&SetHookInfo,
                    sizeof(SetHookInfo),
                    NULL,
                    0,
                    FALSE,
                    &Event,
                    &IoStatus
                    );
            if (!RegisterIrp) {
                status = STATUS_UNSUCCESSFUL;
            } else {
                status = IoCallDriver(IpDeviceObject, RegisterIrp);
                if (status == STATUS_PENDING) {
                    KeWaitForSingleObject(
                        &Event, Executive, KernelMode, FALSE, NULL
                        );
                    status = IoStatus.Status;
                }
            }

            ObDereferenceObject((PVOID)FileObject);
            ObDereferenceObject(IpDeviceObject);
        }

        //
        // If the routine was successfully registered, remember its index
        // in the client's file-object. Otherwise, if the routine could not be
        // registered for any reason, release it.
        //

        if (NT_SUCCESS(status)) {
            IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext = UlongToPtr(i);
        } else {
            KeAcquireSpinLock(&IpfwRoutineLock, &Irql);
            IpfwRoutineTable[i].Flags &= ~IPFW_ROUTINE_FLAG_REGISTERED;
            KeReleaseSpinLock(&IpfwRoutineLock, Irql);
        }
    }

    IoStatus.Status = status;
    IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;

} // IpfwCreate


VOID
IpfwUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine is invoked by the I/O manager to unload this driver.

Arguments:

    DriverObject - the object for this driver

Return Value:

    none.

--*/

{
    KdPrint(("IpfwUnload\n"));
    if (IpfwDeviceObject) {
        IoDeleteDevice(IpfwDeviceObject);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tools\ipfw\ipfw.h ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    ipfw.h

Abstract:

    Contains declarations shared by the IPFW driver and its user-mode
    control program.

Author:

    Abolade Gbadegesin  (aboladeg)      7-Mar-2000

Revision History:

--*/

#ifndef _IPFW_H_
#define _IPFW_H_

#define DD_IPFW_DEVICE_NAME L"\\Device\\IPFW"
#define IPFW_ROUTINE_COUNT  10

typedef struct _IPFW_CREATE_PACKET {
    ULONG Priority;
} IPFW_CREATE_PACKET, *PIPFW_CREATE_PACKET;

#define IPFW_CREATE_NAME        "IpfwCreate"
#define IPFW_CREATE_NAME_LENGTH (sizeof(IPFW_CREATE_NAME) - 1)

#endif // _IPFW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tools\irdp\irdp.c ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    irdp.c

Abstract:

    This module implements a utility to manipulate the TCP/IP driver's
    ICMP router-discovery (IRDP) settings.

Author:

    Abolade Gbadegesin (aboladeg)   11-May-1999

Revision History:

--*/

#define _PNP_POWER_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ndispnp.h>
#include <ntddip.h>
#include <iphlpapi.h>
#include <stdio.h>
#include <stdlib.h>

const char IrdpEnabled[] = "IrdpEnabled";
const char IrdpDisabled[] = "IrdpDisabled";
const char IrdpDisabledUseDhcp[] = "IrdpDisabledUseDhcp";
const char Option31On[] = "Option31On";
const char Option31Off[] = "Option31Off";
const char Option31Absent[] = "Option31Absent";

int __cdecl
main(
    int argc,
    char* argv[]
    )
{
    PIP_ADAPTER_INFO AdapterInfo;
    ANSI_STRING AnsiString;
    UNICODE_STRING BindList;
    UCHAR Buffer[4192];
    CHAR Device[80] = "\\Device\\";
    ULONG Error;
    ULONG Index;
    UNICODE_STRING LowerComponent;
    IP_PNP_RECONFIG_REQUEST Request;
    ULONG Size;
    WCHAR Tcpip[] = L"Tcpip";
    UNICODE_STRING UpperComponent;
    ZeroMemory(&Request, sizeof(Request));
    Request.version = IP_PNP_RECONFIG_VERSION;
    if (argc != 4) {
        Error = TRUE;
    } else {
        Error = FALSE;

        Index = atol(argv[1]);
        AdapterInfo = (PIP_ADAPTER_INFO)Buffer;
        Size = sizeof(Buffer);
        if (GetAdaptersInfo(AdapterInfo, &Size) != NO_ERROR) {
            Error = TRUE;
        } else {
            PIP_ADAPTER_INFO ai;
            for (ai = AdapterInfo; ai; ai = ai->Next) {
                if (ai->Index == Index) {
                    strncat(Device, ai->AdapterName,
                            RTL_NUMBER_OF(Device) - strlen(Device) - 1);
                    break;
                }
            }
            if (!ai) { Error = TRUE; }
        }

        Request.Flags |= IP_PNP_FLAG_PERFORM_ROUTER_DISCOVERY;
        if (lstrcmpi(argv[2], IrdpEnabled) == 0) {
            Request.PerformRouterDiscovery = IP_IRDP_ENABLED;
        } else if (lstrcmpi(argv[2], IrdpDisabled) == 0) {
            Request.PerformRouterDiscovery = IP_IRDP_DISABLED;
        } else if (lstrcmpi(argv[2], IrdpDisabledUseDhcp) == 0) {
            Request.PerformRouterDiscovery = IP_IRDP_DISABLED_USE_DHCP;
        } else {
            Error = TRUE;
        }

        if (lstrcmpi(argv[3], Option31On) == 0) {
            Request.Flags |= IP_PNP_FLAG_DHCP_PERFORM_ROUTER_DISCOVERY;
            Request.DhcpPerformRouterDiscovery = TRUE;
        } else if (lstrcmpi(argv[3], Option31Off) == 0) {
            Request.Flags |= IP_PNP_FLAG_DHCP_PERFORM_ROUTER_DISCOVERY;
            Request.DhcpPerformRouterDiscovery = FALSE;
        } else if (lstrcmpi(argv[3], Option31Absent) == 0) {
            // leave the field blank.
        } else {
            Error = TRUE;
        }
    }
    if (Error) {
        printf("Usage:\n");
        printf(
            "irdp <interface-index>\n"
            "     <%s|%s|%s>\n"
            "     <%s|%s|%s>\n\n",
            IrdpEnabled, IrdpDisabled, IrdpDisabledUseDhcp,
            Option31On, Option31Off, Option31Absent
            );
        printf("<%s|%s|%s>:\n", IrdpEnabled, IrdpDisabled, IrdpDisabledUseDhcp);
        printf("    indicates the local setting for IRDP\n\n");
        printf("<%s|%s|%s>:\n", Option31On, Option31Off, Option31Absent);
        printf("    simulates the setting of DHCP option 31\n\n");
        return 0;
    }

    printf("Device: %d [%s]\n", Index, Device);

    RtlInitUnicodeString(&UpperComponent, Tcpip);
    RtlInitAnsiString(&AnsiString, Device);
    RtlInitUnicodeString(&LowerComponent, NULL);
    RtlAnsiStringToUnicodeString(&LowerComponent, &AnsiString, TRUE);
    RtlInitUnicodeString(&BindList, NULL);

    Error =
        NdisHandlePnPEvent(
            NDIS,
            RECONFIGURE,
            &LowerComponent,
            &UpperComponent,
            &BindList,
            &Request,
            sizeof(Request)
            );
    RtlFreeUnicodeString(&LowerComponent);
    printf("NdisHandlePnPEvent: %d\n", Error);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tools\pfd\pfd.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    pfd.c

Abstract:

    This module contains code for a simple packet-filter driver

Author:

    Abolade Gbadegesin (aboladeg)   15-Aug-1999

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//
// Device- and file-object for the IP driver
//

extern PDEVICE_OBJECT IpDeviceObject = NULL;
extern PFILE_OBJECT IpFileObject = NULL;

//
// Device-object for the filter driver
//

extern PDEVICE_OBJECT PfdDeviceObject = NULL;


//
// FUNCTION PROTOTYPES (alphabetically)
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

FORWARD_ACTION
PfdFilterPacket(
    struct IPHeader UNALIGNED* Header,
    PUCHAR Packet,
    UINT PacketLength,
    UINT ReceivingInterfaceIndex,
    UINT SendingInterfaceIndex,
    IPAddr ReceivingLinkNextHop,
    IPAddr SendingLinkNextHop
    );

NTSTATUS
PfdInitializeDriver(
    VOID
    );

NTSTATUS
PfdSetFilterHook(
    BOOLEAN Install
    );

VOID
PfdUnloadDriver(
    IN PDRIVER_OBJECT  DriverObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Performs driver-initialization for the filter driver.

Arguments:

Return Value:

    STATUS_SUCCESS if initialization succeeded, error code otherwise.

--*/

{
    WCHAR DeviceName[] = DD_IP_PFD_DEVICE_NAME;
    UNICODE_STRING DeviceString;
    LONG i;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE ParametersKey;
    HANDLE ServiceKey;
    NTSTATUS status;
    UNICODE_STRING String;

    PAGED_CODE();

    KdPrint(("DriverEntry\n"));

    //
    // Create the device's object.
    //

    RtlInitUnicodeString(&DeviceString, DeviceName);

    status =
        IoCreateDevice(
            DriverObject,
            0,
            &DeviceString,
            FILE_DEVICE_NETWORK,
            FILE_DEVICE_SECURE_OPEN,
            FALSE,
            &PfdDeviceObject
            );

    if (!NT_SUCCESS(status)) {
        KdPrint(("IoCreateDevice failed (0x%08X)\n", status));
        return status;
    }

    DriverObject->DriverUnload = PfdUnloadDriver;
    DriverObject->DriverStartIo = NULL;

    //
    // Initialize the driver's structures
    //

    status = PfdInitializeDriver();

    return status;

} // DriverEntry


FORWARD_ACTION
PfdFilterPacket(
    struct IPHeader UNALIGNED* Header,
    PUCHAR Packet,
    UINT PacketLength,
    UINT ReceivingInterfaceIndex,
    UINT SendingInterfaceIndex,
    IPAddr ReceivingLinkNextHop,
    IPAddr SendingLinkNextHop
    )

/*++

Routine Description:

    Invoked to determine the fate of each received packet.

Arguments:

    none used.

Return Value:

    FORWARD_ACTION - indicates whether to forward or drop the given packet.

Environment:

    Invoked within the context of reception or transmission.

--*/

{
    KdPrint(("PfdFilterPacket\n"));
    return FORWARD;
} // PfdFilterPacket


NTSTATUS
PfdInitializeDriver(
    VOID
    )

/*++

Routine Description:

    Performs initialization of the driver's structures.

Arguments:

    none.

Return Value:

    NTSTATUS - success/error code.

--*/

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS status;
    UNICODE_STRING UnicodeString;

    KdPrint(("PfdInitializeDriver\n"));

    //
    // Obtain the IP driver device-object
    //

    RtlInitUnicodeString(&UnicodeString, DD_IP_DEVICE_NAME);
    status =
        IoGetDeviceObjectPointer(
            &UnicodeString,
            SYNCHRONIZE|GENERIC_READ|GENERIC_WRITE,
            &IpFileObject,
            &IpDeviceObject
            );
    if (!NT_SUCCESS(status)) {
        KdPrint(("PfdInitializeDriver: error %X getting IP object\n", status));
        return status;
    }

    ObReferenceObject(IpDeviceObject);

    //
    // Install the filter-hook routine
    //

    return PfdSetFilterHook(TRUE);

} // PfdInitializeDriver


NTSTATUS
PfdSetFilterHook(
    BOOLEAN Install
    )

/*++

Routine Description:

    This routine is called to set (Install==TRUE) or clear (Install==FALSE) the
    value of the filter-callout function pointer in the IP driver.

Arguments:

    Install - indicates whether to install or remove the hook.

Return Value:

    NTSTATUS - indicates success/failure

Environment:

    The routine assumes the caller is executing at PASSIVE_LEVEL.

--*/

{
    IP_SET_FILTER_HOOK_INFO HookInfo;
    IO_STATUS_BLOCK IoStatus;
    PIRP Irp;
    KEVENT LocalEvent;
    NTSTATUS status;

    KdPrint(("PfdSetFilterHook\n"));

    //
    // Register (or deregister) as a filter driver
    //

    HookInfo.FilterPtr = Install ? PfdFilterPacket : NULL;

    KeInitializeEvent(&LocalEvent, SynchronizationEvent, FALSE);
    Irp =
        IoBuildDeviceIoControlRequest(
            IOCTL_IP_SET_FILTER_POINTER,
            IpDeviceObject,
            (PVOID)&HookInfo,
            sizeof(HookInfo),
            NULL,
            0,
            FALSE,
            &LocalEvent,
            &IoStatus
            );

    if (!Irp) {
        KdPrint(("PfdSetFilterHook: IoBuildDeviceIoControlRequest=0\n"));
        return STATUS_UNSUCCESSFUL;
    }

    status = IoCallDriver(IpDeviceObject, Irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&LocalEvent, Executive, KernelMode, FALSE, NULL);
        status = IoStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        KdPrint(("PfdSetFilterHook: SetFilterPointer=%x\n", status));
    }

    return status;

} // PfdSetFilterHook


VOID
PfdUnloadDriver(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    Performs cleanup for the filter-driver.

Arguments:

    DriverObject - reference to the module's driver-object

Return Value:

--*/

{
    KdPrint(("PfdUnloadDriver\n"));

    //
    // Stop translation and clear the periodic timer
    //

    PfdSetFilterHook(FALSE);
    IoDeleteDevice(DriverObject->DeviceObject);

    //
    // Release references to the IP device object
    //

    ObDereferenceObject((PVOID)IpFileObject);
    ObDereferenceObject(IpDeviceObject);

} // PfdUnloadDriver
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tools\ipfw\ipfwc.c ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    ipfwc.c

Abstract:

    This module contains the control-program for the IP firewall hook
    test driver.

Author:

    Abolade Gbadegesin  (aboladeg)  7-March-2000

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "ipfw.h"

typedef struct _IPFWC_ENTRY {
    HANDLE FileHandle;
    ULONG Priority;
    ULONG Flags;
} IPFWC_ENTRY, *PIPFWC_ENTRY;

#define IPFWC_ENTRY_FLAG_REGISTERED 0x00000001

IPFWC_ENTRY EntryTable[IPFW_ROUTINE_COUNT];

int __cdecl
main(
    int argc,
    char* argv[]
    )
{
    ULONG i;
    ULONG Selection;

    //
    // Enter a loop where we prompt the user to either register or deregister
    // a firewall hook with a specified priority.
    //

    ZeroMemory(EntryTable, sizeof(EntryTable));
    for (;;) {
        for (i = 0; i < IPFW_ROUTINE_COUNT; i++) {
            if (EntryTable[i].Flags & IPFWC_ENTRY_FLAG_REGISTERED) {
                printf("\tEntry %d Priority %d\n", i, EntryTable[i].Priority);
            }
        }
        printf("1. Register new entry.\n");
        printf("2. Deregister existing entry.\n");
        printf("3. Quit.\n");
        printf("Enter selection:");
        if (!scanf("%d", &Selection)) { break; }
        switch(Selection) {
            case 1: {
                UCHAR Buffer[512];
                PIPFW_CREATE_PACKET CreatePacket;
                PFILE_FULL_EA_INFORMATION EaBuffer;
                ULONG EaBufferLength;
                IO_STATUS_BLOCK IoStatus;
                OBJECT_ATTRIBUTES ObjectAttributes;
                NTSTATUS status;
                UNICODE_STRING UnicodeString;

                for (i = 0; i < IPFW_ROUTINE_COUNT; i++) {
                    if (!(EntryTable[i].Flags & IPFWC_ENTRY_FLAG_REGISTERED)) {
                        break;
                    }
                }
                if (i >= IPFW_ROUTINE_COUNT) {
                    printf("No entries available.\n");
                    break;
                }

                printf("Enter priority: ");
                if (!scanf("%d", &EntryTable[i].Priority)) { break; }
                if (!EntryTable[i].Priority) {
                    printf("Invalid priority.\n");
                    break;
                }

                EaBuffer = (PFILE_FULL_EA_INFORMATION)Buffer;
                EaBufferLength =
                    sizeof(FILE_FULL_EA_INFORMATION) + 
                    IPFW_CREATE_NAME_LENGTH + sizeof(IPFW_CREATE_PACKET);
                EaBuffer->NextEntryOffset = 0;
                EaBuffer->Flags = 0;
                EaBuffer->EaNameLength = IPFW_CREATE_NAME_LENGTH;
                CopyMemory(
                    EaBuffer->EaName, IPFW_CREATE_NAME,
                    IPFW_CREATE_NAME_LENGTH + 1
                    );
                EaBuffer->EaValueLength = sizeof(IPFW_CREATE_PACKET);
                CreatePacket =
                    (PIPFW_CREATE_PACKET)
                        (EaBuffer->EaName + EaBuffer->EaNameLength + 1);
                CreatePacket->Priority = EntryTable[i].Priority;

                RtlInitUnicodeString(&UnicodeString, DD_IPFW_DEVICE_NAME);
                InitializeObjectAttributes(
                    &ObjectAttributes, &UnicodeString, OBJ_CASE_INSENSITIVE,
                    NULL, NULL
                    );
                status =
                    NtCreateFile(
                        &EntryTable[i].FileHandle,
                        GENERIC_READ|GENERIC_WRITE|SYNCHRONIZE,
                        &ObjectAttributes,
                        &IoStatus,
                        NULL,
                        0,
                        FILE_SHARE_READ|FILE_SHARE_WRITE,
                        FILE_OPEN_IF,
                        0,
                        EaBuffer,
                        EaBufferLength
                        );
                if (!NT_SUCCESS(status)) {
                    printf("Registration failed (status=%x).\n", status);
                } else {
                    EntryTable[i].Flags |= IPFWC_ENTRY_FLAG_REGISTERED;
                }
                break;
            }
            case 2: {
                printf("Enter entry index: ");
                if (!scanf("%d", &i)) { break; }
                if (i >= IPFW_ROUTINE_COUNT) {
                    printf("Invalid entry index.\n");
                    break;
                }

                EntryTable[i].Flags &= ~IPFWC_ENTRY_FLAG_REGISTERED;
                NtClose(EntryTable[i].FileHandle);
                break;
            }
            case 3: {
                return 0;
            }
            default:    
                printf("Invalid selection.\n");
                break;
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tools\pfd\precomp.h ===
#include <ndis.h>
#include <cxport.h>
#include <ip.h>         // for IPRcvBuf
#include <ipinfo.h>     // for route-lookup defs
#include <ntddip.h>     // for \Device\Ip I/O control codes
#include <ntddtcp.h>    // for \Device\Tcp I/O control codes
#include <ipfltinf.h>   // for firewall defs
#include <ipfilter.h>   // for firewall defs
#include <tcpinfo.h>    // for TCP_CONN_*
#include <tdiinfo.h>    // for CONTEXT_SIZE, TDIObjectID
#include <tdistat.h>    // for TDI status codes

#define DD_IP_PFD_DEVICE_NAME   L"\\Device\\PacketFilterDriver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tools\sendarp\sendarp.c ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    sendarp.c

Abstract:

    The module implements a utility program to resolve an IP address to
    a hardware address using the SendARP() API routine.

Author:

    Abolade Gbadegesin (aboladeg)   6-October-1999

Revision History:

--*/

#include <windows.h>
#include <winsock.h>
#include <iphlpapi.h>
#include <stdio.h>
#include <stdlib.h>
MIB_IPNETROW IpNetRow;

int __cdecl
main(
    int argc,
    char* argv[]
    )
{
    ULONG Error;
    UCHAR HardwareAddress[6];
    ULONG HardwareAddressLength;
    ULONG InterfaceIndex;
    ULONG Length;
    SOCKADDR_IN SockAddrIn;
    SOCKET Socket;
    ULONG SourceAddress;
    ULONG TargetAddress;
    HANDLE ThreadHandle;
    WSADATA wd;

    if (argc != 2) {
        printf("Usage: %s <IP address>\n", argv[0]);
        return 0;
    }

    WSAStartup(0x202, &wd);
    TargetAddress = inet_addr(argv[1]);

    //
    // Retrieve the best interface for the target IP address,
    // and also perform a UDP-connect to determine the 'closest'
    // local IP address to the target IP address.
    //

    Error = GetBestInterface(TargetAddress, &InterfaceIndex);
    if (Error != NO_ERROR) {
        printf("GetBestInterfaceFromStack: %d\n", Error);
        return 0;
    }

    Length = sizeof(SockAddrIn);
    SockAddrIn.sin_family = AF_INET;
    SockAddrIn.sin_port = 0;
    SockAddrIn.sin_addr.s_addr = TargetAddress;
    if ((Socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP))
            == INVALID_SOCKET ||
        connect(Socket, (PSOCKADDR)&SockAddrIn, sizeof(SockAddrIn))
            == SOCKET_ERROR ||
        getsockname(Socket, (PSOCKADDR)&SockAddrIn, &Length)
            == SOCKET_ERROR) {
        printf("socket/connect/getsockname: %d\n", WSAGetLastError());
    }
    SourceAddress = SockAddrIn.sin_addr.s_addr;

    //
    // Make sure the target IP address isn't already cached,
    // by removing it from the ARP cache if present using the interface index
    // determined above.
    //

    ZeroMemory(&IpNetRow, sizeof(IpNetRow));
    IpNetRow.dwIndex = InterfaceIndex;
    IpNetRow.dwPhysAddrLen = 6;
    IpNetRow.dwAddr = TargetAddress;
    IpNetRow.dwType = MIB_IPNET_TYPE_INVALID;

    DeleteIpNetEntry(&IpNetRow);

    HardwareAddressLength = sizeof(HardwareAddress);
    Error =
        SendARP(
            TargetAddress,
            SourceAddress,
            (PULONG)HardwareAddress,
            &HardwareAddressLength
            );
    if (Error) {
        printf("SendARP: %d\n", Error);
    } else {
        ULONG i;
        printf("%s\t", argv[1]);
        for (i = 0; i < HardwareAddressLength-1; i++) {
            printf("%02x-", HardwareAddress[i]);
        }
        printf("%02x\n", HardwareAddress[i]);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tools\tcbmon\tcbmon.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    tcbmon.c

Abstract:

    This module contains code for a utility program which monitors
    the variables for the active TCP control blocks in the system.
    The program optionally maintains a log for a specified TCB
    in CSV format in a file specified by the user.

Author:

    Abolade Gbadegesin (aboladeg)   January-25-1999

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <winsock2.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntddip.h>
#include <ntddtcp.h>
#include <ipinfo.h>
#include <iphlpapi.h>
#include <iphlpstk.h>

HANDLE ConsoleHandle;
CONSOLE_SCREEN_BUFFER_INFO ConsoleInfo;
ULONG DisplayInterval = 500;
SOCKADDR_IN LogLocal;
PCHAR LogPath;
SOCKADDR_IN LogRemote;
HANDLE StopEvent;
HANDLE TcpipHandle;

VOID
WriteLine(
    COORD Coord,
    CHAR* Format,
    ...
    )
{
    va_list arglist;
    char Buffer[256];
    ULONG Count;
    ULONG Length;
    va_start(arglist, Format);
    Count = vsprintf(Buffer, Format, arglist);
    FillConsoleOutputCharacter(
        ConsoleHandle, ' ', ConsoleInfo.dwSize.X, Coord, &Length
        );
    WriteConsoleOutputCharacter(
        ConsoleHandle, (LPCTSTR)Buffer, Count, Coord, &Length
        );
}

VOID
ClearToEnd(
    COORD Coord,
    COORD End
    )
{
    ULONG Length;
    while (Coord.Y <= End.Y) {
        FillConsoleOutputCharacter(
            ConsoleHandle, ' ', ConsoleInfo.dwSize.X, Coord, &Length
            );
        ++Coord.Y;
    }
}

ULONG WINAPI
DisplayThread(
    PVOID Unused
    )
{
    COORD End = {0,0};
    FILE* LogFile = NULL;
    do {
        COORD Coord = {0, 0};
        DWORD Error;
        ULONG i;
        ULONG Length;
        CHAR LocalAddr[20];
        CHAR RemoteAddr[20];
        char *DestString;
        char *SrcString;
        TCP_FINDTCB_REQUEST Request;
        TCP_FINDTCB_RESPONSE Response;
        PMIB_TCPTABLE Table;
        if (LogPath && !LogFile) {
            LogFile = fopen(LogPath, "w+");
            if (!LogFile) {
                perror("fopen");
                break;
            } else {
                fprintf(
                    LogFile,
                    "#senduna,sendnext,sendmax,sendwin,unacked,maxwin,cwin,"
                    "mss,rtt,smrtt,rexmitcnt,rexmittimer,rexmit,retrans,state,"
                    "flags,rto,delta\n"
                    );
            }
        }
        Error =
            AllocateAndGetTcpTableFromStack(
                &Table,
                TRUE,
                GetProcessHeap(),
                0
                );
        if (Error) {
            COORD Top = {0, 0};
            WriteLine(Top, "AllocateAndGetTcpTableFromStack: %d", Error);
            if (WaitForSingleObject(StopEvent, DisplayInterval)
                    == WAIT_OBJECT_0) {
                break;
            } else {
                continue;
            }
        }
        for (i = 0; i < Table->dwNumEntries; i++) {
            if (Table->table[i].dwState < MIB_TCP_STATE_SYN_SENT ||
                Table->table[i].dwState > MIB_TCP_STATE_TIME_WAIT) {
                continue;
            }
            Request.Src = Table->table[i].dwLocalAddr;
            Request.Dest = Table->table[i].dwRemoteAddr;
            Request.SrcPort = (USHORT)Table->table[i].dwLocalPort;
            Request.DestPort = (USHORT)Table->table[i].dwRemotePort;
            if (!DeviceIoControl(
                    TcpipHandle,
                    IOCTL_TCP_FINDTCB,
                    &Request,
                    sizeof(Request),
                    &Response,
                    sizeof(Response),
                    &Length,
                    NULL
                    )) {
                COORD Top = {0, 0};
                WriteLine(Top, "DeviceIoControl: %d", GetLastError());
                continue;
            }
            SrcString = inet_ntoa(*(PIN_ADDR)&Request.Src);
            DestString = inet_ntoa(*(PIN_ADDR)&Request.Dest);
            if (!SrcString || !DestString) {
                continue;
            }
            lstrcpy(LocalAddr, SrcString);
            lstrcpy(RemoteAddr, DestString);
            ++Coord.Y;
            WriteLine(
                Coord, "%s:%d %s:%d",
                LocalAddr, ntohs(Request.SrcPort),
                RemoteAddr, ntohs(Request.DestPort)
                );
            ++Coord.Y;
            WriteLine(
                Coord, "    smrtt:    %-8d   rexmit:   %-8d  rexmitcnt:   %-8d",
                Response.tcb_smrtt, Response.tcb_rexmit, Response.tcb_rexmitcnt
                );
            ++Coord.Y;
            if (Request.Src == LogLocal.sin_addr.s_addr &&
                Request.Dest == LogRemote.sin_addr.s_addr &&
                (LogLocal.sin_port == 0 ||
                Request.SrcPort == LogLocal.sin_port) &&
                (LogRemote.sin_port == 0 ||
                Request.DestPort == LogRemote.sin_port)) {
                LogLocal.sin_port = Request.SrcPort;
                LogRemote.sin_port = Request.DestPort;
                // senduna, sendnext
                fprintf(
                    LogFile, "%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,"
                    "%x,%u,%u\n",
                    Response.tcb_senduna,
                    Response.tcb_sendnext,
                    Response.tcb_sendmax,
                    Response.tcb_sendwin,
                    Response.tcb_unacked,
                    Response.tcb_maxwin,
                    Response.tcb_cwin,
                    Response.tcb_mss,
                    Response.tcb_rtt,
                    Response.tcb_smrtt,
                    Response.tcb_rexmitcnt,
                    Response.tcb_rexmittimer,
                    Response.tcb_rexmit,
                    Response.tcb_retrans,
                    Response.tcb_state,
                    0,
                    0,
                    0
                    );
            }
        }
        HeapFree(GetProcessHeap(), 0, Table);
        ClearToEnd(Coord, End);
        End = Coord;
    } while (WaitForSingleObject(StopEvent, DisplayInterval) != WAIT_OBJECT_0);
    if (LogFile) { fclose(LogFile); }
    NtClose(TcpipHandle);
    CloseHandle(ConsoleHandle);
    return 0;
}

void
DisplayUsage(
    void
    )
{
    printf("tcbmon [-?] [-refresh <ms>] [-log <path> <session>\n");
    printf("\t<session>     = <local endpoint> <remote endpoint>\n");
    printf("\t<endpoint>    = <address> { <port> | * }\n");
}

void
DisplayTcbHelp(
    void
    )
{
    printf("tcbmon: TCB Help\n");
    printf("tcb fields:\n");
    printf("\tsenduna       = seq. of first unack'd byte\n");
    printf("\tsendnext      = seq. of next byte to send\n");
    printf("\tsendmax       = max. seq. sent so far\n");
    printf("\tsendwin       = size of send window in bytes\n");
    printf("\tunacked       = number of unack'd bytes\n");
    printf("\tmaxwin        = max. send window offered\n");
    printf("\tcwin          = size of congestion window in bytes\n");
    printf("\tmss           = max. segment size\n");
    printf("\trtt           = timestamp of current rtt measurement\n");
    printf("\tsmrtt         = smoothed rtt measurement\n");
    printf("\trexmitcnt     = number of rexmit'd segments\n");
    printf("\trexmittimer   = rexmit timer in ticks\n");
    printf("\trexmit        = rexmit timeout last computed\n");
    printf("\tretrans       = total rexmit'd segments (all sessions)\n");
    printf("\tstate         = connection state\n");
    printf("\tflags         = connection flags (see below)\n");
    printf("\trto           = real-time rto (compare rexmit)\n");
    printf("\tdelta         = rtt variance\n");
    printf("\n");
    printf("flags:\n");
    printf("\t00000001      = window explicitly set\n");
    printf("\t00000002      = has client options\n");
    printf("\t00000004      = from accept\n");
    printf("\t00000008      = from active open\n");
    printf("\t00000010      = client notified of disconnect\n");
    printf("\t00000020      = in delayed action queue\n");
    printf("\t00000040      = completing receives\n");
    printf("\t00000080      = in receive-indication handler\n");
    printf("\t00000100      = needs receive-completes\n");
    printf("\t00000200      = needs to send ack\n");
    printf("\t00000400      = needs to output\n");
    printf("\t00000800      = delayed sending ack\n");
    printf("\t00001000      = probing for path-mtu bh\n");
    printf("\t00002000      = using bsd urgent semantics\n");
    printf("\t00004000      = in 'DeliverUrgent'\n");
    printf("\t00008000      = seen urgent data and urgent data fields valid\n");
    printf("\t00010000      = needs to send fin\n");
    printf("\t00020000      = using nagle's algorithm\n");
    printf("\t00040000      = in 'TCPSend'\n");
    printf("\t00080000      = flow-controlled (received zero-window)\n");
    printf("\t00100000      = disconnect-notif. pending\n");
    printf("\t00200000      = time-wait transition pending\n");
    printf("\t00400000      = output being forced\n");
    printf("\t00800000      = send pending after receive\n");
    printf("\t01000000      = graceful-close pending\n");
    printf("\t02000000      = keepalives enabled\n");
    printf("\t04000000      = processing urgent data inline\n");
    printf("\t08000000      = inform acd about connection\n");
    printf("\t10000000      = fin sent since last retransmit\n");
    printf("\t20000000      = unack'd fin sent\n");
    printf("\t40000000      = need to send rst when closing\n");
    printf("\t80000000      = in tcb table\n");
}

int __cdecl
main(
    int argc,
    char* argv[]
    )
{
    LONG i;
    IO_STATUS_BLOCK IoStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;
    HANDLE ThreadHandle;
    ULONG ThreadId;
    UNICODE_STRING UnicodeString;
    for (i = 1; i < argc; i++) {
        if (lstrcmpi(argv[i], "-?") == 0 || lstrcmpi(argv[i], "/?") == 0) {
            DisplayUsage();
            return 0;
        } else if (lstrcmpi(argv[i], "-tcbhelp") == 0) {
            DisplayTcbHelp();
            return 0;
        } else if (lstrcmpi(argv[i], "-refresh") == 0 && (i + 1) >= argc) {
            DisplayInterval = atol(argv[++i]);
            if (!DisplayInterval) {
                DisplayUsage();
                return 0;
            }
        } else if (lstrcmpi(argv[i], "-log") == 0) {
            if ((i + 5) >= argc) {
                DisplayUsage();
                return 0;
            }
            LogPath = argv[++i];
            LogLocal.sin_addr.s_addr = inet_addr(argv[++i]);
            if (lstrcmpi(argv[i+1], "*") == 0) {
                LogLocal.sin_port = 0; ++i;
            } else {
                LogLocal.sin_port = htons((SHORT)atol(argv[++i]));
            }
            LogRemote.sin_addr.s_addr = inet_addr(argv[++i]);
            if (lstrcmpi(argv[i+1], "*") == 0) {
                LogRemote.sin_port = 0; ++i;
            } else {
                LogRemote.sin_port = htons((SHORT)atol(argv[++i]));
            }
            if (LogLocal.sin_addr.s_addr == INADDR_NONE ||
                LogRemote.sin_addr.s_addr == INADDR_NONE) {
                DisplayUsage();
                return 0;
            }
        }
    }

    StopEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    ConsoleHandle =
        CreateConsoleScreenBuffer(
            GENERIC_READ|GENERIC_WRITE,
            FILE_SHARE_READ|FILE_SHARE_WRITE,
            NULL,
            CONSOLE_TEXTMODE_BUFFER,
            NULL
            );
    SetConsoleActiveScreenBuffer(ConsoleHandle);
    GetConsoleScreenBufferInfo(ConsoleHandle, &ConsoleInfo);
    ConsoleInfo.dwSize.Y = 1000;
    SetConsoleScreenBufferSize(ConsoleHandle, ConsoleInfo.dwSize);

    RtlInitUnicodeString(&UnicodeString, DD_TCP_DEVICE_NAME);
    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );
    Status =
        NtCreateFile(
            &TcpipHandle,
            GENERIC_EXECUTE,
            &ObjectAttributes,
            &IoStatus,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ|FILE_SHARE_WRITE,
            FILE_OPEN_IF,
            0,
            NULL,
            0
            );
    if (!NT_SUCCESS(Status)) {
        printf("NtCreateFile: %x\n", Status);
        return 0;
    }

    ThreadHandle =
        CreateThread(
            NULL,
            0,
            DisplayThread,
            NULL,
            0,
            &ThreadId
            );
    CloseHandle(ThreadHandle);
    getchar();
    SetEvent(StopEvent);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\6to4svc\6to4.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Abstract:

    Defines and prototypes for the 6to4 service

--*/

#define SECONDS         1
#define MINUTES         (60 * SECONDS)
#define HOURS           (60 * MINUTES)
#define DAYS            (24 * HOURS)

#define V4_COMPAT_IFINDEX           2
#define SIX_TO_FOUR_IFINDEX         3

#define KEY_GLOBAL L"System\\CurrentControlSet\\Services\\6to4\\Config"
#define KEY_INTERFACES L"System\\CurrentControlSet\\Services\\6to4\\Interfaces"

typedef struct _ADDR_INFO {
    LPSOCKADDR           lpSockaddr;
    INT                  iSockaddrLength;
    
    ULONG                ul6over4IfIndex;
} ADDR_INFO, *PADDR_INFO;

typedef struct _ADDR_LIST {
    INT                  iAddressCount;
    ADDR_INFO            Address[1];
} ADDR_LIST, *PADDR_LIST;

extern ADDR_LIST *g_pIpv4AddressList;

//////////////////////////
// Routines from svcmain.c
//////////////////////////

VOID
SetHelperServiceStatus(
    IN DWORD   dwState,
    IN DWORD   dwErr);

typedef enum {
    DEFAULT = 0,
    AUTOMATIC,
    ENABLED,
    DISABLED
} STATE;

//////////////////////////
// Routines from 6to4svc.c
//////////////////////////

extern STATE g_stService;
extern SOCKET g_sIPv4Socket;

VOID
StopHelperService(
    IN DWORD Error);

VOID
CleanupHelperService(
    VOID);

DWORD
OnConfigChange(
    VOID);

DWORD
StartHelperService(
    VOID);

VOID
UpdateServiceRequirements(
    IN PIP_ADAPTER_ADDRESSES Adapters);

VOID
IncEventCount(
    IN PCHAR pszWhere);

VOID
DecEventCount(
    IN PCHAR pszWhere);

BOOL
ConvertOemToUnicode(
    IN LPSTR OemString, 
    OUT LPWSTR UnicodeString, 
    IN int UnicodeLen);

ULONG
GetInteger(
    IN HKEY hKey,
    IN LPCTSTR lpName,
    IN ULONG ulDefault);

VOID
GetString(
    IN HKEY hKey,
    IN LPCTSTR lpName,
    IN PWCHAR pBuff,
    IN ULONG ulLength,
    IN PWCHAR pDefault);

DWORD
ConfigureAddressUpdate(
    IN u_int Interface,
    IN SOCKADDR_IN6 *Sockaddr,
    IN u_int Lifetime,
    IN int Type,
    IN u_int PrefixConf,
    IN u_int SuffixConf);

//////////////////////////
// Routines from ipv6.c
//////////////////////////

extern void
ForEachInterface(void (*func)(IPV6_INFO_INTERFACE *, void *), void *Context);

extern int
InitIPv6Library(void);

extern void
UninitIPv6Library(void);

extern BOOL
ReconnectInterface(PWCHAR AdapterName);

extern int
UpdateRouteTable(IPV6_INFO_ROUTE_TABLE *Route);

extern int
UpdateAddress(IPV6_UPDATE_ADDRESS *Address);

extern u_int
ConfirmIPv6Reachability(SOCKADDR_IN6 *Dest, u_int Timeout);

extern BOOL
DeleteInterface(u_int IfIndex);

extern u_int
CreateV6V4Interface(IN_ADDR SrcAddr, IN_ADDR DstAddr);

extern u_int
Create6over4Interface(IN_ADDR SrcAddr);

extern int
UpdateInterface(IPV6_INFO_INTERFACE *Update);

extern IPV6_INFO_INTERFACE *
GetInterfaceStackInfo(WCHAR *pwszAdapterName);

extern BOOL
UpdateRouterLinkAddress(u_int IfIndex, IN_ADDR SrcAddr, IN_ADDR DstAddr);

extern VOID
GetFirstSitePrefix(ULONG IfIndex, IPV6_INFO_SITE_PREFIX *Prefix);

//////////////////////////
// Routines from dyndns.c
//////////////////////////

DWORD
StartIpv6AddressChangeNotification(VOID);

VOID
StopIpv6AddressChangeNotification(VOID);

VOID CALLBACK
OnIpv6AddressChange(IN PVOID lpParameter, IN BOOLEAN TimerOrWaitFired);

//////////////////////////
// Routines from proxy.c
//////////////////////////

BOOL
QueueUpdateGlobalPortState(IN PVOID Unused);

VOID
UninitializePorts(VOID);

VOID
InitializePorts(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tools\tcbview\tcbview.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    tcbview.c

Abstract:

    This module contains code for a utility program which monitors
    the variables for the active TCP/IP control blocks in the system.
    The program optionally maintains a log for a specified TCB
    in CSV format in a file specified by the user.

Author:

    Abolade Gbadegesin (aboladeg)   January-25-1999

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <commctrl.h>
#include <winsock2.h>
#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <fcntl.h>
#include <ntddip.h>
#include <ntddtcp.h>
#include <ipinfo.h>
#include <iphlpapi.h>
#include <iphlpstk.h>

//
// GLOBAL DATA
//

ULONG DisplayInterval = 500;
HWND ListHandle;
SOCKADDR_IN LogLocal;
FILE* LogFile = NULL;
PCHAR LogPath;
SOCKADDR_IN LogRemote;
HANDLE TcpipHandle;
UINT_PTR TimerId;
typedef enum {
    LocalAddressColumn,
    LocalPortColumn,
    RemoteAddressColumn,
    RemotePortColumn,
    SmRttColumn,
    DeltaColumn,
    RtoColumn,
    RexmitColumn,
    RexmitCntColumn,
    MaximumColumn
} LIST_COLUMNS;
CHAR* ColumnText[] = {
    "LocalAddress",
    "LocalPort",
    "RemoteAddress",
    "RemotePort",
    "SmRtt",
    "Delta",
    "Rto",
    "Rexmit",
    "RexmitCnt",
};

VOID
AllocateConsole(
    VOID
    )
{
    INT OsfHandle;
    FILE* FileHandle;

    //
    // Being a GUI application, we do not have a console for our process.
    // Allocate a console now, and make it our standard-output file.
    //

    AllocConsole();
    OsfHandle = _open_osfhandle((intptr_t)GetStdHandle(STD_OUTPUT_HANDLE), _O_TEXT);
    FileHandle = _fdopen(OsfHandle, "w");
    if (!FileHandle) {
        perror("_fdopen");
        exit(0);
    }
    *stdout = *FileHandle;
    setvbuf(stdout, NULL, _IONBF, 0);
}

LRESULT CALLBACK
DisplayWndProc(
    HWND WindowHandle,
    UINT Message,
    WPARAM Wparam,
    LPARAM Lparam
    )
{
    //
    // Handle the few window-messages that we care about.
    // Our window will contain a listview as soon as we've initialized,
    // and we always resize that listview to fill our client area.
    // We also set up a timer which periodically triggers refresh
    // of the TCBs displayed.
    //

    if (Message == WM_CREATE) {
        CREATESTRUCT* CreateStruct = (CREATESTRUCT*)Lparam;
        LVCOLUMN LvColumn;
        RECT rc;
        do {
            //
            // Create the child listview, and insert columns
            // for each of the TCB fields that we'll be displaying.
            //

            GetClientRect(WindowHandle, &rc);
            ListHandle =
                CreateWindowEx(
                    0,
                    WC_LISTVIEW,
                    NULL,
                    WS_CHILD|LVS_REPORT|LVS_NOSORTHEADER,
                    0,
                    0,
                    rc.right,
                    rc.bottom,
                    WindowHandle,
                    NULL,
                    CreateStruct->hInstance,
                    NULL
                    );
            if (!ListHandle) { break; }
            ZeroMemory(&LvColumn, sizeof(LvColumn));
            for (; LvColumn.iSubItem < MaximumColumn; LvColumn.iSubItem++) {
                LvColumn.mask = LVCF_FMT|LVCF_SUBITEM|LVCF_TEXT|LVCF_WIDTH;
                LvColumn.fmt = LVCFMT_LEFT;
                LvColumn.pszText = ColumnText[LvColumn.iSubItem];
                LvColumn.cx = 50;
                ListView_InsertColumn(ListHandle, LvColumn.iSubItem, &LvColumn);
            }

            //
            // Initialize our periodic timer, and display our window.
            //

            TimerId = SetTimer(WindowHandle, 1, DisplayInterval, NULL);
            ShowWindow(WindowHandle, SW_SHOW);
            ShowWindow(ListHandle, SW_SHOW);
            if (!TimerId) { break; }
            return 0;
        } while(FALSE);
        PostQuitMessage(0);
        return (LRESULT)-1;
    } else if (Message == WM_DESTROY) {

        //
        // Stop our periodic timer, close the log-file (if any),
        // close the handle on which we communicate with the TCP/IP driver,
        // and post a quit message to cause the message-loop of our process
        // to end.
        //

        KillTimer(WindowHandle, TimerId);
        if (LogFile) { fclose(LogFile); }
        NtClose(TcpipHandle);
        PostQuitMessage(0);
        return 0;
    } else if (Message == WM_SETFOCUS) {

        //
        // Always pass the focus to our child-control, the listview.
        //

        SetFocus(ListHandle);
        return 0;
    } else if (Message == WM_WINDOWPOSCHANGED) {
        RECT rc;

        //
        // Always resize our listview to fill our client-area.
        //

        GetClientRect(WindowHandle, &rc);
        SetWindowPos(
            ListHandle,
            WindowHandle,
            0,
            0,
            rc.right,
            rc.bottom,
            ((WINDOWPOS*)Lparam)->flags
            );
        return 0;
    } else if (Message == WM_TIMER) {
        COORD Coord = {0, 0};
        DWORD Error;
        ULONG i;
        LONG Item;
        ULONG Length;
        LVITEM LvItem;
        CHAR Text[20];
        TCP_FINDTCB_REQUEST Request;
        TCP_FINDTCB_RESPONSE Response;
        PMIB_TCPTABLE Table;

        //
        // If we're configured to use a log-file and we haven't created one,
        // do so now, and print the CSV header to the file.
        //

        if (LogPath && !LogFile) {
            LogFile = fopen(LogPath, "w+");
            if (!LogFile) {
                return 0;
            } else {
                fprintf(
                    LogFile,
                    "#senduna,sendnext,sendmax,sendwin,unacked,maxwin,cwin,"
                    "mss,rtt,smrtt,rexmitcnt,rexmittimer,rexmit,retrans,state,"
                    "flags,rto,delta\n"
                    );
            }
        }

        //
        // Clear our listview and retrieve a new table of TCP connections.
        // It would be less visually jarring if, instead of deleting all
        // the list-items each time, we used a mark-and-sweep to just update
        // the ones which had changed. However, that sounds too much like work.
        //

        ListView_DeleteAllItems(ListHandle);
        Error =
            AllocateAndGetTcpTableFromStack(
                &Table,
                TRUE,
                GetProcessHeap(),
                0
                );
        if (Error) { return 0; }

        //
        // Display each active TCP control block in the listview.
        // For each entry, we retrieve the partial TCB using IOCTL_TCP_FINDTCB,
        // and then display it in the list.
        // If we are generating a log-file for one of the TCBs,
        // we append the current information to that log-file.
        //

        for (i = 0, Item = 0; i < Table->dwNumEntries; i++) {
            if (Table->table[i].dwState < MIB_TCP_STATE_SYN_SENT ||
                Table->table[i].dwState > MIB_TCP_STATE_TIME_WAIT) {
                continue;
            }

            Request.Src = Table->table[i].dwLocalAddr;
            Request.Dest = Table->table[i].dwRemoteAddr;
            Request.SrcPort = (USHORT)Table->table[i].dwLocalPort;
            Request.DestPort = (USHORT)Table->table[i].dwRemotePort;
            ZeroMemory(&Response, sizeof(Response));
            if (!DeviceIoControl(
                    TcpipHandle,
                    IOCTL_TCP_FINDTCB,
                    &Request,
                    sizeof(Request),
                    &Response,
                    sizeof(Response),
                    &Length,
                    NULL
                    )) {
                continue;
            }

            lstrcpy(Text, inet_ntoa(*(PIN_ADDR)&Request.Src));
            ZeroMemory(&LvItem, sizeof(LvItem));
            LvItem.mask = LVIF_TEXT;
            LvItem.iItem = Item;
            LvItem.iSubItem = LocalAddressColumn;
            LvItem.pszText = Text;
            LvItem.iItem = ListView_InsertItem(ListHandle, &LvItem);
            if (LvItem.iItem == -1) { continue; }

            ListView_SetItemText(
                ListHandle, Item, RemoteAddressColumn,
                inet_ntoa(*(PIN_ADDR)&Request.Dest)
                );
            _ltoa(ntohs(Request.SrcPort), Text, 10);
            ListView_SetItemText(ListHandle, Item, LocalPortColumn, Text);
            _ltoa(ntohs(Request.DestPort), Text, 10);
            ListView_SetItemText(ListHandle, Item, RemotePortColumn, Text);
            _ltoa(Response.tcb_smrtt, Text, 10);
            ListView_SetItemText(ListHandle, Item, SmRttColumn, Text);
            _ltoa(0, /* Response.tcb_delta, */ Text, 10);
            ListView_SetItemText(ListHandle, Item, DeltaColumn, Text);
            wsprintf(
                Text, "%d.%d", 0, // Response.tcb_rto / 10,
                0 // (Response.tcb_rto % 10) * 100
                );
            ListView_SetItemText(ListHandle, Item, RtoColumn, Text);
            _ltoa(Response.tcb_rexmit, Text, 10);
            ListView_SetItemText(ListHandle, Item, RexmitColumn, Text);
            _ltoa(Response.tcb_rexmitcnt, Text, 10);
            ListView_SetItemText(ListHandle, Item, RexmitCntColumn, Text);
            ++Item;

            //
            // If we are generating a log-file, update it now.
            // We allow the user to specify a wildcard for either or both port
            // on the command-line, so if a wildcard was specified
            // in 'LogLocal' or 'LogRemote', we now instantiate the wildcard
            // for the first matching session.
            //

            if (Request.Src == LogLocal.sin_addr.s_addr &&
                Request.Dest == LogRemote.sin_addr.s_addr &&
                (LogLocal.sin_port == 0 ||
                Request.SrcPort == LogLocal.sin_port) &&
                (LogRemote.sin_port == 0 ||
                Request.DestPort == LogRemote.sin_port)) {

                //
                // This assignment instantiates the user's wildcard, if any,
                //

                LogLocal.sin_port = Request.SrcPort;
                LogRemote.sin_port = Request.DestPort;

                fprintf(
                    LogFile, "%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,"
                    "%x,%u,%u\n",
                    Response.tcb_senduna,
                    Response.tcb_sendnext,
                    Response.tcb_sendmax,
                    Response.tcb_sendwin,
                    Response.tcb_unacked,
                    Response.tcb_maxwin,
                    Response.tcb_cwin,
                    Response.tcb_mss,
                    Response.tcb_rtt,
                    Response.tcb_smrtt,
                    Response.tcb_rexmitcnt,
                    Response.tcb_rexmittimer,
                    Response.tcb_rexmit,
                    Response.tcb_retrans,
                    Response.tcb_state,
                    0, // Response.tcb_flags,
                    0, // Response.tcb_rto,
                    0 // Response.tcb_delta
                    );
            }
        }
        HeapFree(GetProcessHeap(), 0, Table);
        UpdateWindow(ListHandle);
        return 0;
    }
    return DefWindowProc(WindowHandle, Message, Wparam, Lparam);
}

void
DisplayUsage(
    void
    )
{
    AllocateConsole();
    printf("tcbview [-?] [-tcbhelp] [-refresh <ms>] [-log <path> <session>\n");
    printf("\t<session>     = <local endpoint> <remote endpoint>\n");
    printf("\t<endpoint>    = <address> { <port> | * }\n");
    printf("Press <Ctrl-C> to continue...");
    Sleep(INFINITE);
}

void
DisplayTcbHelp(
    void
    )
{
    AllocateConsole();
    printf("tcbview: TCB Help\n");
    printf("tcb fields:\n");
    printf("\tsenduna       = seq. of first unack'd byte\n");
    printf("\tsendnext      = seq. of next byte to send\n");
    printf("\tsendmax       = max. seq. sent so far\n");
    printf("\tsendwin       = size of send window in bytes\n");
    printf("\tunacked       = number of unack'd bytes\n");
    printf("\tmaxwin        = max. send window offered\n");
    printf("\tcwin          = size of congestion window in bytes\n");
    printf("\tmss           = max. segment size\n");
    printf("\trtt           = timestamp of current rtt measurement\n");
    printf("\tsmrtt         = smoothed rtt measurement\n");
    printf("\trexmitcnt     = number of rexmit'd segments\n");
    printf("\trexmittimer   = rexmit timer in ticks\n");
    printf("\trexmit        = rexmit timeout last computed\n");
    printf("\tretrans       = total rexmit'd segments (all sessions)\n");
    printf("\tstate         = connection state\n");
    printf("\tflags         = connection flags (see below)\n");
    printf("\trto           = real-time rto (compare rexmit)\n");
    printf("\tdelta         = rtt variance\n");
    printf("\n");
    printf("flags:\n");
    printf("\t00000001      = window explicitly set\n");
    printf("\t00000002      = has client options\n");
    printf("\t00000004      = from accept\n");
    printf("\t00000008      = from active open\n");
    printf("\t00000010      = client notified of disconnect\n");
    printf("\t00000020      = in delayed action queue\n");
    printf("\t00000040      = completing receives\n");
    printf("\t00000080      = in receive-indication handler\n");
    printf("\t00000100      = needs receive-completes\n");
    printf("\t00000200      = needs to send ack\n");
    printf("\t00000400      = needs to output\n");
    printf("\t00000800      = delayed sending ack\n");
    printf("\t00001000      = probing for path-mtu bh\n");
    printf("\t00002000      = using bsd urgent semantics\n");
    printf("\t00004000      = in 'DeliverUrgent'\n");
    printf("\t00008000      = seen urgent data and urgent data fields valid\n");
    printf("\t00010000      = needs to send fin\n");
    printf("\t00020000      = using nagle's algorithm\n");
    printf("\t00040000      = in 'TCPSend'\n");
    printf("\t00080000      = flow-controlled (received zero-window)\n");
    printf("\t00100000      = disconnect-notif. pending\n");
    printf("\t00200000      = time-wait transition pending\n");
    printf("\t00400000      = output being forced\n");
    printf("\t00800000      = send pending after receive\n");
    printf("\t01000000      = graceful-close pending\n");
    printf("\t02000000      = keepalives enabled\n");
    printf("\t04000000      = processing urgent data inline\n");
    printf("\t08000000      = inform acd about connection\n");
    printf("\t10000000      = fin sent since last retransmit\n");
    printf("\t20000000      = unack'd fin sent\n");
    printf("\t40000000      = need to send rst when closing\n");
    printf("\t80000000      = in tcb table\n");
    printf("Press <Ctrl-C> to continue...");
    Sleep(INFINITE);
}

INT WINAPI
WinMain(
    HINSTANCE InstanceHandle,
    HINSTANCE Unused,
    PCHAR CommandLine,
    INT ShowWindowCode
    )
{
    LONG argc;
    PCHAR* argv;
    LONG i;
    IO_STATUS_BLOCK IoStatus;
    MSG Message;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;
    HANDLE ThreadHandle;
    ULONG ThreadId;
    UNICODE_STRING UnicodeString;
    HWND WindowHandle;
    WNDCLASS WndClass;

    //
    // Process command-line arguments. See 'DisplayUsage' above for help.
    //

    argc = __argc;
    argv = __argv;
    for (i = 1; i < argc; i++) {
        if (lstrcmpi(argv[i], "-?") == 0 || lstrcmpi(argv[i], "/?") == 0) {
            DisplayUsage();
            return 0;
        } else if (lstrcmpi(argv[i], "-tcbhelp") == 0) {
            DisplayTcbHelp();
            return 0;
        } else if (lstrcmpi(argv[i], "-refresh") == 0 && (i + 1) >= argc) {
            DisplayInterval = atol(argv[++i]);
            if (!DisplayInterval) {
                DisplayUsage();
                return 0;
            }
        } else if (lstrcmpi(argv[i], "-log") == 0) {
            if ((i + 5) >= argc) {
                DisplayUsage();
                return 0;
            }
            LogPath = argv[++i];
            LogLocal.sin_addr.s_addr = inet_addr(argv[++i]);
            if (lstrcmpi(argv[i+1], "*") == 0) {
                LogLocal.sin_port = 0; ++i;
            } else {
                LogLocal.sin_port = htons((SHORT)atol(argv[++i]));
            }
            LogRemote.sin_addr.s_addr = inet_addr(argv[++i]);
            if (lstrcmpi(argv[i+1], "*") == 0) {
                LogRemote.sin_port = 0; ++i;
            } else {
                LogRemote.sin_port = htons((SHORT)atol(argv[++i]));
            }
            if (LogLocal.sin_addr.s_addr == INADDR_NONE ||
                LogRemote.sin_addr.s_addr == INADDR_NONE) {
                DisplayUsage();
                return 0;
            }
        }
    }

    //
    // Open a handle to the TCP/IP driver,
    // to be used in issuing IOCTL_TCP_FINDTCB requests.
    //

    RtlInitUnicodeString(&UnicodeString, DD_TCP_DEVICE_NAME);
    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );
    Status =
        NtCreateFile(
            &TcpipHandle,
            GENERIC_EXECUTE,
            &ObjectAttributes,
            &IoStatus,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ|FILE_SHARE_WRITE,
            FILE_OPEN_IF,
            0,
            NULL,
            0
            );
    if (!NT_SUCCESS(Status)) {
        printf("NtCreateFile: %x\n", Status);
        return 0;
    }

    //
    // Register our window class and create the sole instance
    // of our main window. Then, enter our application message loop
    // until the user dismisses the window.
    //

    ZeroMemory(&WndClass, sizeof(WndClass));
    WndClass.lpfnWndProc = DisplayWndProc;
    WndClass.hInstance = InstanceHandle;
    WndClass.lpszClassName = "TcbViewClass";
    Message.wParam = 0;
    if (!RegisterClass(&WndClass)) {
        printf("RegisterClass: %d\n", GetLastError());
    } else {
        WindowHandle =
            CreateWindowEx(
                0,
                "TcbViewClass",
                "TcbView",
                WS_TILEDWINDOW,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                NULL,
                NULL,
                InstanceHandle,
                NULL
                );
        if (!WindowHandle) {
            printf("CreateWindowEx: %d\n", GetLastError());
        } else {
            while(GetMessage(&Message, NULL, 0, 0)) {
                TranslateMessage(&Message);
                DispatchMessage(&Message);
            }
        }
    }
    return (LONG)Message.wParam;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\6to4svc\6to4svc.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Abstract:

    Functions implementing the 6to4 service, to provide IPv6 connectivity
    over an IPv4 network.

--*/

#include "precomp.h"
#pragma hdrstop

extern DWORD
APIENTRY
RasQuerySharedPrivateLan(
    OUT GUID*           LanGuid );

STATE g_stService = DISABLED;
ULONG g_ulEventCount = 0;

//
// Worst metric for which we can add a route
//
#define UNREACHABLE                 0x7fffffff

const IN6_ADDR SixToFourPrefix = { 0x20, 0x02, 0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
#define SIXTOFOUR_METRIC 1000

// Metric of subnet/sitelocal route on a router
#define SUBNET_ROUTE_METRIC            1
#define SITELOCAL_ROUTE_METRIC         1

// Information on a 6to4 subnet that we've generated as a router
typedef struct _SUBNET_CONTEXT {
    IN_ADDR V4Addr;
    int     Publish;
    u_int   ValidLifetime;
    u_int   PreferredLifetime;
} SUBNET_CONTEXT, *PSUBNET_CONTEXT;

//
// Variables for settings
//

#define DEFAULT_ENABLE_6TO4         AUTOMATIC
#define DEFAULT_ENABLE_RESOLUTION   AUTOMATIC
#define DEFAULT_ENABLE_ROUTING      AUTOMATIC
#define DEFAULT_RESOLUTION_INTERVAL (24 * HOURS)
#define DEFAULT_ENABLE_SITELOCALS   ENABLED 
#define DEFAULT_ENABLE_6OVER4       DISABLED
#define DEFAULT_ENABLE_V4COMPAT     DISABLED
#define DEFAULT_RELAY_NAME          L"6to4.ipv6.microsoft.com."
#define DEFAULT_UNDO_ON_STOP        ENABLED

#define KEY_ENABLE_6TO4             L"Enable6to4"
#define KEY_ENABLE_RESOLUTION       L"EnableResolution"
#define KEY_ENABLE_ROUTING          L"EnableRouting"
#define KEY_ENABLE_SITELOCALS       L"EnableSiteLocals"
#define KEY_ENABLE_6OVER4           L"Enable6over4"
#define KEY_ENABLE_V4COMPAT         L"EnableV4Compat"
#define KEY_RESOLUTION_INTERVAL     L"ResolutionInterval"
#define KEY_UNDO_ON_STOP            L"UndoOnStop"
#define KEY_RELAY_NAME              L"RelayName"

typedef enum {
    IPV4_SCOPE_NODE,
    IPV4_SCOPE_LINK,
    IPV4_SCOPE_SM_SITE,
    IPV4_SCOPE_MD_SITE,
    IPV4_SCOPE_LG_SITE,
    IPV4_SCOPE_GLOBAL,
    NUM_IPV4_SCOPES
} IPV4_SCOPE;

//
// Global config settings
//

typedef struct {
    STATE stEnable6to4;
    STATE stEnableRouting;
    STATE stEnableResolution;
    STATE stEnableSiteLocals;
    STATE stEnable6over4;
    STATE stEnableV4Compat;
    ULONG ulResolutionInterval; // in minutes
    WCHAR pwszRelayName[NI_MAXHOST];
    STATE stUndoOnStop;
} GLOBAL_SETTINGS;

GLOBAL_SETTINGS g_GlobalSettings;

typedef struct {
    STATE st6to4State;
    STATE stRoutingState;
    STATE stResolutionState;
} GLOBAL_STATE;

GLOBAL_STATE g_GlobalState = { DISABLED, DISABLED, DISABLED };

const ADDR_LIST EmptyAddressList = {0};

// List of public IPv4 addresses used when updating the routing state
ADDR_LIST *g_pIpv4AddressList = NULL;

//
// Variables for interfaces (addresses and routing)
//

typedef struct _IF_SETTINGS {
    WCHAR                pwszAdapterName[MAX_ADAPTER_NAME];

    STATE                stEnableRouting; // be a router on this private iface?
} IF_SETTINGS, *PIF_SETTINGS;

typedef struct _IF_SETTINGS_LIST {
    ULONG                ulNumInterfaces;
    IF_SETTINGS          arrIf[0];
} IF_SETTINGS_LIST, *PIF_SETTINGS_LIST;

PIF_SETTINGS_LIST g_pInterfaceSettingsList = NULL;

typedef struct _IF_INFO {
    WCHAR                pwszAdapterName[MAX_ADAPTER_NAME];

    ULONG                ulIPv6IfIndex;
    STATE                stRoutingState; // be a router on this private iface?
    ULONG                ulNumGlobals;
    ADDR_LIST           *pAddressList;
} IF_INFO, *PIF_INFO;

typedef struct _IF_LIST {
    ULONG                ulNumInterfaces;
    ULONG                ulNumScopedAddrs[NUM_IPV4_SCOPES];
    IF_INFO              arrIf[0];
} IF_LIST, *PIF_LIST;

PIF_LIST g_pInterfaceList = NULL;

HANDLE     g_hAddressChangeEvent = NULL;
OVERLAPPED g_hAddressChangeOverlapped;
HANDLE     g_hAddressChangeWaitHandle = NULL;

HANDLE     g_hRouteChangeEvent = NULL;
OVERLAPPED g_hRouteChangeOverlapped;
HANDLE     g_hRouteChangeWaitHandle = NULL;

// This state tracks whether there are any global IPv4 addresses.
STATE      g_st6to4State = DISABLED;

BOOL       g_b6to4Required = TRUE;

SOCKET     g_sIPv4Socket = INVALID_SOCKET;


//////////////////////////
// Routines for 6to4
//////////////////////////

VOID
Update6to4State(
    VOID
    );

VOID
PreDelete6to4Address(
    IN LPSOCKADDR_IN Ipv4Address,
    IN PIF_LIST InterfaceList,
    IN STATE OldRoutingState
    );

VOID
Delete6to4Address(
    IN LPSOCKADDR_IN Ipv4Address,
    IN PIF_LIST InterfaceList,
    IN STATE OldRoutingState
    );

VOID
Add6to4Address(
    IN LPSOCKADDR_IN Ipv4Address,
    IN PIF_LIST InterfaceList,
    IN STATE OldRoutingState
    );

VOID
PreDelete6to4Routes(
    VOID
    );

VOID
Update6to4Routes(
    VOID
    );


///////////////////////////////////////////////////////////////////////////
// Variables for relays
//

typedef struct _RELAY_INFO {
    SOCKADDR_IN          sinAddress;  // IPv4 address
    SOCKADDR_IN6         sin6Address; // IPv6 address
    ULONG                ulMetric;
} RELAY_INFO, *PRELAY_INFO;

typedef struct _RELAY_LIST {
    ULONG               ulNumRelays;
    RELAY_INFO          arrRelay[0];
} RELAY_LIST, *PRELAY_LIST;

PRELAY_LIST        g_pRelayList                 = NULL;
HANDLE             g_hTimerQueue                = INVALID_HANDLE_VALUE;
HANDLE             g_h6to4ResolutionTimer       = INVALID_HANDLE_VALUE;
HANDLE             g_h6to4TimerCancelledEvent   = NULL;
HANDLE             g_h6to4TimerCancelledWait    = NULL;

VOID
UpdateGlobalResolutionState();

//////////////////////////////////////////////////////////////////////////////
// GetAddrStr - helper routine to get a string literal for an address
LPTSTR
GetAddrStr(
    IN LPSOCKADDR pSockaddr,
    IN ULONG ulSockaddrLen)
{
    static TCHAR tBuffer[INET6_ADDRSTRLEN];
    INT          iRet;
    ULONG        ulLen;

    ulLen = sizeof(tBuffer);
    iRet = WSAAddressToString(pSockaddr, ulSockaddrLen, NULL, tBuffer, &ulLen);

    if (iRet) {
        swprintf(tBuffer, L"<err %d>", WSAGetLastError());
    }

    return tBuffer;
}

BOOL
ConvertOemToUnicode(
    IN LPSTR OemString, 
    OUT LPWSTR UnicodeString, 
    IN int UnicodeLen)
{
    return (MultiByteToWideChar(CP_OEMCP, 0, OemString, (int)(strlen(OemString)+1),
                              UnicodeString, UnicodeLen) != 0);
}

BOOL
ConvertUnicodeToOem(
    IN LPWSTR UnicodeString,
    OUT LPSTR OemString,
    IN int OemLen)
{
    return (WideCharToMultiByte(CP_OEMCP, 0, UnicodeString, 
                (int)(wcslen(UnicodeString)+1), OemString, OemLen, NULL, NULL) != 0);
}


/////////////////////////////////////////////////////////////////////////
// Subroutines for manipulating the list of (usually) public addresses 
// being used for both 6to4 addresses and subnet prefixes.
/////////////////////////////////////////////////////////////////////////

DWORD
MakeEmptyAddressList( 
    OUT PADDR_LIST *ppList)
{
    *ppList = MALLOC(FIELD_OFFSET(ADDR_LIST, Address[0]));
    if (!*ppList) {
        return GetLastError();
    }

    (*ppList)->iAddressCount = 0;
    return NO_ERROR;
}

VOID
FreeAddressList(
    IN PADDR_LIST *ppAddressList)
{
    ADDR_LIST *pList = *ppAddressList;
    int i;

    if (pList == NULL) {
        return;
    }
    
    // Free all addresses
    for (i=0; i<pList->iAddressCount; i++) {
       FREE(pList->Address[i].lpSockaddr);  
    }

    // Free the list
    FREE(pList);
    *ppAddressList = NULL;
}

DWORD
AddAddressToList(
    IN LPSOCKADDR_IN pAddress, 
    IN ADDR_LIST **ppAddressList,
    IN ULONG ul6over4IfIndex)
{
    ADDR_LIST *pOldList = *ppAddressList;
    ADDR_LIST *pNewList;
    int n = pOldList->iAddressCount;

    // Copy existing addresses
    pNewList = MALLOC( FIELD_OFFSET(ADDR_LIST, Address[n+1]) );
    if (!pNewList)  {
        return GetLastError();
    }
    CopyMemory(pNewList, pOldList, 
               FIELD_OFFSET(ADDR_LIST, Address[n]));
    pNewList->iAddressCount = n+1;

    // Add new address
    pNewList->Address[n].lpSockaddr = MALLOC(sizeof(SOCKADDR_IN));
    if (!pNewList->Address[n].lpSockaddr) {
        FREE(pNewList);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    CopyMemory(pNewList->Address[n].lpSockaddr, pAddress, sizeof(SOCKADDR_IN));
    pNewList->Address[n].iSockaddrLength = sizeof(SOCKADDR_IN);
    pNewList->Address[n].ul6over4IfIndex = ul6over4IfIndex;

    // Free the old list without freeing the sockaddrs
    FREE(pOldList);

    *ppAddressList = pNewList;

    return NO_ERROR;
}

DWORD
FindAddressInList(
    IN LPSOCKADDR_IN pAddress,
    IN ADDR_LIST *pAddressList,
    OUT ULONG *pulIndex)
{
    int i;

    // Find address in list
    for (i=0; i<pAddressList->iAddressCount; i++) {
        if (!memcmp(pAddress, pAddressList->Address[i].lpSockaddr,
                    sizeof(SOCKADDR_IN))) {
            *pulIndex = i;
            return NO_ERROR;
        }
    }

    Trace1(ERR, _T("ERROR: FindAddressInList didn't find %d.%d.%d.%d"), 
                  PRINT_IPADDR(pAddress->sin_addr.s_addr));

    return ERROR_NOT_FOUND;
}

DWORD
RemoveAddressFromList(
    IN ULONG ulIndex,
    IN ADDR_LIST *pAddressList)
{
    // Free old address
    FREE(pAddressList->Address[ulIndex].lpSockaddr);

    // Move the last entry into its place
    pAddressList->iAddressCount--;
    pAddressList->Address[ulIndex] = 
        pAddressList->Address[pAddressList->iAddressCount];

    return NO_ERROR;
}


////////////////////////////////////////////////////////////////
// GlobalInfo-related subroutines
////////////////////////////////////////////////////////////////

int
ConfigureRouteTableUpdate(
    IN const IN6_ADDR *Prefix,
    IN u_int PrefixLen,
    IN u_int Interface,
    IN const IN6_ADDR *Neighbor,
    IN int Publish,
    IN int Immortal,
    IN u_int ValidLifetime,
    IN u_int PreferredLifetime,
    IN u_int SitePrefixLen,
    IN u_int Metric)
{
    IPV6_INFO_ROUTE_TABLE Route;
    SOCKADDR_IN6 saddr;
    DWORD dwErr;

    ZeroMemory(&saddr, sizeof(saddr));
    saddr.sin6_family = AF_INET6;
    saddr.sin6_addr = *Prefix;

    Trace7(FSM, _T("Updating route %s/%d iface %d metric %d lifetime %d/%d publish %d"),
                GetAddrStr((LPSOCKADDR)&saddr, sizeof(saddr)),
                PrefixLen,
                Interface,
                Metric,
                PreferredLifetime,
                ValidLifetime,
                Publish);

    memset(&Route, 0, sizeof Route);
    Route.This.Prefix = *Prefix;
    Route.This.PrefixLength = PrefixLen;
    Route.This.Neighbor.IF.Index = Interface;
    Route.This.Neighbor.Address = *Neighbor;
    Route.ValidLifetime = ValidLifetime;
    Route.PreferredLifetime = PreferredLifetime;
    Route.Publish = Publish;
    Route.Immortal = Immortal;
    Route.SitePrefixLength = SitePrefixLen;
    Route.Preference = Metric;
    Route.Type = RTE_TYPE_MANUAL;

    dwErr = UpdateRouteTable(&Route)? NO_ERROR : GetLastError();

    if (dwErr != NO_ERROR) {
        Trace1(ERR, _T("UpdateRouteTable got error %d"), dwErr);
    }

    return dwErr;
}

DWORD
InitializeGlobalInfo()
{
    DWORD dwErr;

    g_GlobalSettings.stEnable6to4         = DEFAULT_ENABLE_6TO4;
    g_GlobalSettings.stEnableRouting      = DEFAULT_ENABLE_ROUTING;
    g_GlobalSettings.stEnableResolution   = DEFAULT_ENABLE_RESOLUTION;
    g_GlobalSettings.ulResolutionInterval = DEFAULT_RESOLUTION_INTERVAL;
    g_GlobalSettings.stEnableSiteLocals   = DEFAULT_ENABLE_SITELOCALS;
    g_GlobalSettings.stEnable6over4       = DEFAULT_ENABLE_6OVER4;
    g_GlobalSettings.stEnableV4Compat     = DEFAULT_ENABLE_V4COMPAT;
    g_GlobalSettings.stUndoOnStop         = DEFAULT_UNDO_ON_STOP;
    wcscpy(g_GlobalSettings.pwszRelayName, DEFAULT_RELAY_NAME); 

    g_GlobalState.st6to4State             = DISABLED;
    g_GlobalState.stRoutingState          = DISABLED;
    g_GlobalState.stResolutionState       = DISABLED;

    g_sIPv4Socket = socket(AF_INET, SOCK_DGRAM, 0);
    if (g_sIPv4Socket == INVALID_SOCKET) {
        Trace0(ERR, _T("socket failed\n"));
        return WSAGetLastError();
    }

    dwErr = MakeEmptyAddressList(&g_pIpv4AddressList);

    return dwErr;
}

// Called by: Stop6to4
VOID
UninitializeGlobalInfo()
{
    closesocket(g_sIPv4Socket);
    g_sIPv4Socket = INVALID_SOCKET;

    FreeAddressList(&g_pIpv4AddressList);
}


////////////////////////////////////////////////////////////////
// IPv4 and IPv6 Address-related subroutines
////////////////////////////////////////////////////////////////

typedef struct {
    IPV4_SCOPE Scope;
    DWORD      Address;
    DWORD      Mask; 
    ULONG      MaskLen;
} IPV4_SCOPE_PREFIX;

IPV4_SCOPE_PREFIX
Ipv4ScopePrefix[] = {
  { IPV4_SCOPE_NODE,    0x0100007f, 0xffffffff, 32 }, // 127.0.0.1/32
  { IPV4_SCOPE_LINK,    0x0000fea9, 0x0000ffff, 16 }, // 169.254/16
  { IPV4_SCOPE_SM_SITE, 0x0000a8c0, 0x0000ffff, 16 }, // 192.168/16
  { IPV4_SCOPE_MD_SITE, 0x000010ac, 0x0000f0ff, 12 }, // 172.16/12
  { IPV4_SCOPE_LG_SITE, 0x0000000a, 0x000000ff,  8 }, // 10/8
  { IPV4_SCOPE_GLOBAL,  0x00000000, 0x00000000,  0 }, // 0/0
};

IPV4_SCOPE
GetIPv4Scope(
    IN DWORD Addr)
{
    int i;
    for (i=0; ; i++) {
        if ((Addr & Ipv4ScopePrefix[i].Mask) == Ipv4ScopePrefix[i].Address) {
            return Ipv4ScopePrefix[i].Scope;
        }
    }
}

DWORD
MakeAddressList(
    IN PIP_ADDR_STRING pIpAddrList,
    OUT ADDR_LIST **ppAddressList, 
    OUT PULONG pulGlobals,
    IN OUT PULONG pulCumulNumScopedAddrs)
{
    ULONG ulGlobals = 0, ulAddresses = 0;
    INT iLength;
    DWORD dwErr = NO_ERROR;
    ADDR_LIST *pList = NULL;
    PIP_ADDR_STRING pIpAddr;
    SOCKADDR_IN *pSin;
    IPV4_SCOPE scope;

    // Count addresses
    for (pIpAddr=pIpAddrList; pIpAddr; pIpAddr=pIpAddr->Next) {
        ulAddresses++;
    }

    *ppAddressList = NULL;
    *pulGlobals = 0;

    pList = MALLOC( FIELD_OFFSET(ADDR_LIST, Address[ulAddresses] ));
    if (pList == NULL) {
        return GetLastError();
    }

    ulAddresses = 0;
    for (pIpAddr=pIpAddrList; pIpAddr; pIpAddr=pIpAddr->Next) {

        Trace1(FSM, _T("Adding address %hs"), pIpAddr->IpAddress.String);

        iLength = sizeof(SOCKADDR_IN);
        pSin = MALLOC( iLength );
        if (pSin == NULL) {
            continue;
        }

        dwErr = WSAStringToAddressA(pIpAddr->IpAddress.String,
                                    AF_INET,
                                    NULL,
                                    (LPSOCKADDR)pSin,
                                    &iLength);
        if (dwErr == SOCKET_ERROR) {
            FREE(pSin);
            pSin = NULL;
            continue;
        }

        //
        // Don't allow 0.0.0.0 as an address.  On an interface with no
        // addresses, the IPv4 stack will report 1 address of 0.0.0.0.
        //
        if (pSin->sin_addr.s_addr == INADDR_ANY) {
            FREE(pSin);
            pSin = NULL;
            continue;
        }

        if ((pSin->sin_addr.s_addr & 0x000000FF) == 0) {
            //
            // An address in 0/8 isn't a real IP address, it's a fake one that
            // the IPv4 stack sticks on a receive-only adapter.
            //
            FREE(pSin);
            pSin = NULL;
            continue;
        }

        scope = GetIPv4Scope(pSin->sin_addr.s_addr);
        pulCumulNumScopedAddrs[scope]++;

        if (scope == IPV4_SCOPE_GLOBAL) {
            ulGlobals++;         
        }

        pList->Address[ulAddresses].iSockaddrLength = iLength;
        pList->Address[ulAddresses].lpSockaddr      = (LPSOCKADDR)pSin;
        ulAddresses++;
    }

    pList->iAddressCount = ulAddresses;
    *ppAddressList = pList;
    *pulGlobals = ulGlobals;

    return dwErr;
}

//
// Create a 6to4 unicast address for this machine.
//
VOID
Make6to4Address(
    OUT LPSOCKADDR_IN6 pIPv6Address,
    IN LPSOCKADDR_IN pIPv4Address)
{
    IN_ADDR *pIPv4 = &pIPv4Address->sin_addr;

    memset(pIPv6Address, 0, sizeof (SOCKADDR_IN6));
    pIPv6Address->sin6_family = AF_INET6;

    pIPv6Address->sin6_addr.s6_addr[0] = 0x20;
    pIPv6Address->sin6_addr.s6_addr[1] = 0x02;
    memcpy(&pIPv6Address->sin6_addr.s6_addr[2], pIPv4, sizeof(IN_ADDR));
    memcpy(&pIPv6Address->sin6_addr.s6_addr[12], pIPv4, sizeof(IN_ADDR));
}


//
// Create a 6to4 anycast address from a local IPv4 address.
//
VOID
Make6to4AnycastAddress(
    OUT LPSOCKADDR_IN6 pIPv6Address,
    IN LPSOCKADDR_IN pIPv4Address)
{
    IN_ADDR *pIPv4 = &pIPv4Address->sin_addr;

    memset(pIPv6Address, 0, sizeof(SOCKADDR_IN6));
    pIPv6Address->sin6_family = AF_INET6;
    pIPv6Address->sin6_addr.s6_addr[0] = 0x20;
    pIPv6Address->sin6_addr.s6_addr[1] = 0x02;
    memcpy(&pIPv6Address->sin6_addr.s6_addr[2], pIPv4, sizeof(IN_ADDR));
}

//
// Create a v4-compatible address from an IPv4 address.
//
VOID
MakeV4CompatibleAddress(
    OUT LPSOCKADDR_IN6 pIPv6Address,
    IN LPSOCKADDR_IN pIPv4Address)
{
    IN_ADDR *pIPv4 = &pIPv4Address->sin_addr;

    memset(pIPv6Address, 0, sizeof(SOCKADDR_IN6));
    pIPv6Address->sin6_family = AF_INET6;
    memcpy(&pIPv6Address->sin6_addr.s6_addr[12], pIPv4, sizeof(IN_ADDR));
}

DWORD
ConfigureAddressUpdate(
    IN u_int Interface,
    IN SOCKADDR_IN6 *Sockaddr,
    IN u_int Lifetime,
    IN int Type,
    IN u_int PrefixConf,
    IN u_int SuffixConf)
{
    IPV6_UPDATE_ADDRESS Address;
    DWORD               dwErr = NO_ERROR;
    IN6_ADDR           *Addr = &Sockaddr->sin6_addr;

    Trace6(FSM, 
           _T("ConfigureAddressUpdate: if %u addr %s life %u type %d conf %u/%u"), 
           Interface,
           GetAddrStr((LPSOCKADDR)Sockaddr, sizeof(SOCKADDR_IN6)),
           Lifetime,
           Type,
           PrefixConf,
           SuffixConf);

    memset(&Address, 0, sizeof Address);
    Address.This.IF.Index = Interface;
    Address.This.Address = *Addr;
    Address.ValidLifetime = Address.PreferredLifetime = Lifetime;
    Address.Type = Type;
    Address.PrefixConf = PrefixConf;
    Address.InterfaceIdConf = SuffixConf;

    if (!UpdateAddress(&Address)) {
        dwErr = GetLastError();
        Trace1(ERR, _T("ERROR: UpdateAddress got error %d"), dwErr);
    }

    return dwErr;
}

void
Configure6to4Subnets(
    IN ULONG ulIfIndex,
    IN PSUBNET_CONTEXT pSubnet);

void
Unconfigure6to4Subnets(
    IN ULONG ulIfIndex,
    IN PSUBNET_CONTEXT pSubnet);

// Called by: OnChangeInterfaceInfo
DWORD
AddAddress(
    IN LPSOCKADDR_IN pIPv4Address,  // public address
    IN PIF_LIST pInterfaceList,     // interface list
    IN STATE stOldRoutingState)     // routing state
{
    SOCKADDR_IN6   OurAddress;
    DWORD          dwErr;
    ULONG          ul6over4IfIndex;

    Trace2(ENTER, _T("AddAddress %d.%d.%d.%d, isrouter=%d"), 
                  PRINT_IPADDR(pIPv4Address->sin_addr.s_addr),
                  stOldRoutingState);

    // Add 6over4 interface (if enabled)
    if (g_GlobalSettings.stEnable6over4 == ENABLED) {
        ul6over4IfIndex = Create6over4Interface(pIPv4Address->sin_addr);
    } else {
        ul6over4IfIndex = 0;
    }

    Trace1(ERR, _T("6over4 ifindex=%d"), ul6over4IfIndex);

    // Put the IPv4 address on our "public" list
    dwErr = AddAddressToList(pIPv4Address, &g_pIpv4AddressList, 
                             ul6over4IfIndex);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    if (GetIPv4Scope(pIPv4Address->sin_addr.s_addr) == IPV4_SCOPE_GLOBAL) {
        // Add v4-compatible address (if enabled)
        if (g_GlobalSettings.stEnableV4Compat == ENABLED) {
            MakeV4CompatibleAddress(&OurAddress, pIPv4Address);
            dwErr = ConfigureAddressUpdate(
                V4_COMPAT_IFINDEX, &OurAddress, INFINITE_LIFETIME, 
                ADE_UNICAST, PREFIX_CONF_WELLKNOWN,
                IID_CONF_LL_ADDRESS);
            if (dwErr != NO_ERROR) {
                return dwErr;
            }
        }
    } 

    IsatapAddressChangeNotification(FALSE, pIPv4Address->sin_addr);

#ifdef TEREDO
    TeredoAddressChangeNotification(FALSE, pIPv4Address->sin_addr);    
#endif // TEREDO
    
    Add6to4Address(pIPv4Address, pInterfaceList, stOldRoutingState);

    TraceLeave("AddAddress");

    return NO_ERROR;
}

// Delete the 6to4 address from the global state, and prepare to
// delete it from the stack.
//
// Called by: UninitializeInterfaces
VOID
PreDeleteAddress(
    IN LPSOCKADDR_IN pIPv4Address,
    IN PIF_LIST pInterfaceList,
    IN STATE stOldRoutingState)
{
    Trace2(ENTER, _T("PreDeleteAddress %d.%d.%d.%d, wasrouter=%d"), 
           PRINT_IPADDR(pIPv4Address->sin_addr.s_addr),
           stOldRoutingState);

    PreDelete6to4Address(pIPv4Address, pInterfaceList, stOldRoutingState);

    TraceLeave("PreDeleteAddress");
}

// Delete 6to4 address information from the stack.
//
// Called by: OnChangeInterfaceInfo, UninitializeInterfaces
VOID
DeleteAddress(
    IN LPSOCKADDR_IN pIPv4Address,
    IN PIF_LIST pInterfaceList,
    IN STATE stOldRoutingState)
{
    SOCKADDR_IN6   OurAddress;
    DWORD          dwErr;
    ULONG          i;
    
    Trace2(ENTER, _T("DeleteAddress %d.%d.%d.%d wasrouter=%d"), 
                  PRINT_IPADDR(pIPv4Address->sin_addr.s_addr),
                  stOldRoutingState);

    if (GetIPv4Scope(pIPv4Address->sin_addr.s_addr) == IPV4_SCOPE_GLOBAL) {

        // Delete the v4-compatible address from the stack (if enabled)
        if (g_GlobalSettings.stEnableV4Compat == ENABLED) {
            MakeV4CompatibleAddress(&OurAddress, pIPv4Address);
            ConfigureAddressUpdate(
                V4_COMPAT_IFINDEX, &OurAddress, 0, ADE_UNICAST, 
                PREFIX_CONF_WELLKNOWN, IID_CONF_LL_ADDRESS);
        }
    }

    IsatapAddressChangeNotification(TRUE, pIPv4Address->sin_addr);

#ifdef TEREDO    
    TeredoAddressChangeNotification(TRUE, pIPv4Address->sin_addr);
#endif // TEREDO

    Delete6to4Address(pIPv4Address, pInterfaceList, stOldRoutingState);

    //
    // We're now completely done with the IPv4 address, so
    // remove it from the public address list.
    //
    dwErr = FindAddressInList(pIPv4Address, g_pIpv4AddressList, &i);
    if (dwErr == NO_ERROR) {
        // Delete 6over4 interface (if enabled)
        if (g_GlobalSettings.stEnable6over4 == ENABLED) {
            DeleteInterface(g_pIpv4AddressList->Address[i].ul6over4IfIndex);
        }

        RemoveAddressFromList(i, g_pIpv4AddressList);
    }

    TraceLeave("DeleteAddress");
}

////////////////////////////////////////////////////////////////
// Relay-related subroutines
////////////////////////////////////////////////////////////////

//
// Given a relay, make sure a default route to it exists with the right metric
//
VOID
AddOrUpdate6to4Relay(
    IN PRELAY_INFO pRelay)
{
    Trace1(ENTER, _T("AddOrUpdate6to4Relay %d.%d.%d.%d"), 
                  PRINT_IPADDR(pRelay->sinAddress.sin_addr.s_addr));

    //
    // Create the default route.
    //
    ConfigureRouteTableUpdate(&in6addr_any, 0,
                              SIX_TO_FOUR_IFINDEX,
                              &pRelay->sin6Address.sin6_addr,
                              TRUE, // Publish.
                              TRUE, // Immortal.
                              2 * HOURS, // Valid lifetime.
                              30 * MINUTES, // Preferred lifetime.
                              0, 
                              pRelay->ulMetric);
}

VOID
FreeRelayList(
    IN PRELAY_LIST *ppList)
{
    if (*ppList) {
        FREE(*ppList);
        *ppList = NULL;
    }
}

DWORD
InitializeRelays()
{
    g_pRelayList = NULL;

    g_hTimerQueue = CreateTimerQueue();
    if (g_hTimerQueue == INVALID_HANDLE_VALUE) {
        return GetLastError();
    }

    return NO_ERROR;
}

VOID
IncEventCount(
    IN PCHAR pszWhere)
{
    ULONG ulCount = InterlockedIncrement(&g_ulEventCount);
    Trace2(FSM, _T("++%u event count (%hs)"), ulCount, pszWhere);
}

VOID
DecEventCount(
    IN PCHAR pszWhere)
{
    
    ULONG ulCount = InterlockedDecrement(&g_ulEventCount);
    Trace2(FSM, _T("--%u event count (%hs)"), ulCount, pszWhere);

    if ((ulCount == 0) && (g_stService == DISABLED)) {
        SetHelperServiceStatus(SERVICE_STOPPED, NO_ERROR);
    }
}

//  This routine is invoked when a resolution timer has been cancelled
//  and all outstanding timer routines have completed.  It is responsible
//  for releasing the event count for the periodic timer.
//
VOID CALLBACK
OnResolutionTimerCancelled(
    IN PVOID lpParameter,
    IN BOOLEAN TimerOrWaitFired)
{
    TraceEnter("OnResolutionTimerCancelled");

    DecEventCount("RT:CancelResolutionTimer");

    TraceLeave("OnResolutionTimerCancelled");
}

DWORD
InitEvents()
{
    ASSERT(g_h6to4TimerCancelledEvent == NULL);
    g_h6to4TimerCancelledEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (g_h6to4TimerCancelledEvent == NULL)
        return GetLastError();

    //
    // Schedule OnResolutionTimerCancelled() to be called whenever
    // g_h6to4TimerCancelledEvent is signalled.
    //
    if (! RegisterWaitForSingleObject(&g_h6to4TimerCancelledWait,
                                      g_h6to4TimerCancelledEvent,
                                      OnResolutionTimerCancelled,
                                      NULL,
                                      INFINITE,
                                      WT_EXECUTEDEFAULT)) {
        return GetLastError();
    }

    return NO_ERROR;
}

VOID
CleanupHelperService()
{
    if (g_h6to4TimerCancelledWait != NULL) {
        UnregisterWait(g_h6to4TimerCancelledWait);
        g_h6to4TimerCancelledWait = NULL;
    }

    if (g_h6to4TimerCancelledEvent != NULL) {
        CloseHandle(g_h6to4TimerCancelledEvent);
        g_h6to4TimerCancelledEvent = NULL;
    }
}

VOID
CancelResolutionTimer(
    IN OUT HANDLE *phResolutionTimer,
    IN HANDLE hEvent)
{
    Trace0(FSM, _T("Cancelling RT"));

    // Stop the resolution timer
    if (*phResolutionTimer != INVALID_HANDLE_VALUE) {

        // Must be done non-blocking since we're holding the lock
        // the resolution timeout needs.  Ask for notification
        // when the cancel completes so we can release the event count.
        DeleteTimerQueueTimer(g_hTimerQueue, *phResolutionTimer, hEvent);

        *phResolutionTimer = INVALID_HANDLE_VALUE;
    }
}

//
// Delete all stack state related to a given relay
//
void
Delete6to4Relay(
    IN PRELAY_INFO pRelay)
{
    Trace1(ENTER, _T("Delete6to4Relay %d.%d.%d.%d"), 
                  PRINT_IPADDR(pRelay->sinAddress.sin_addr.s_addr));

    ConfigureRouteTableUpdate(&in6addr_any, 0,
                              SIX_TO_FOUR_IFINDEX,
                              &pRelay->sin6Address.sin6_addr,
                              FALSE, // Publish.
                              FALSE, // Immortal.
                              0, // Valid lifetime.
                              0, // Preferred lifetime.
                              0, 
                              pRelay->ulMetric);
}

VOID
UninitializeRelays()
{
    ULONG i;

    TraceEnter("UninitializeRelays");

    CancelResolutionTimer(&g_h6to4ResolutionTimer,
                          g_h6to4TimerCancelledEvent);

    // Delete the timer queue
    if (g_hTimerQueue != INVALID_HANDLE_VALUE) {
        DeleteTimerQueue(g_hTimerQueue);
        g_hTimerQueue = INVALID_HANDLE_VALUE;
    }

    if (g_GlobalSettings.stUndoOnStop == ENABLED) {
        // Delete existing relay tunnels
        for (i=0; g_pRelayList && (i<g_pRelayList->ulNumRelays); i++) {
            Delete6to4Relay(&g_pRelayList->arrRelay[i]);
        }
    }

    // Free the "old list"
    FreeRelayList(&g_pRelayList);

    TraceLeave("UninitializeRelays");
}

//
// Start or update the resolution timer to expire in <ulMinutes> minutes
//
DWORD
RestartResolutionTimer(
    IN ULONG ulDelayMinutes, 
    IN ULONG ulPeriodMinutes,
    IN HANDLE *phResolutionTimer,
    IN WAITORTIMERCALLBACK OnTimeout)
{
    ULONG DelayTime = ulDelayMinutes * MINUTES * 1000; // convert mins to ms
    ULONG PeriodTime = ulPeriodMinutes * MINUTES * 1000; // convert mins to ms
    BOOL  bRet;
    DWORD dwErr;

    if (*phResolutionTimer != INVALID_HANDLE_VALUE) {
        bRet = ChangeTimerQueueTimer(g_hTimerQueue, *phResolutionTimer,
                                     DelayTime, PeriodTime);
    } else {
        bRet = CreateTimerQueueTimer(phResolutionTimer,
                                     g_hTimerQueue,
                                     OnTimeout,
                                     NULL,
                                     DelayTime,
                                     PeriodTime,
                                     0);
        if (bRet) {
            IncEventCount("RT:RestartResolutionTimer");
        }
    }

    dwErr = (bRet)? NO_ERROR : GetLastError();

    Trace3(TIMER,
           _T("RestartResolutionTimer: DueTime %d minutes, Period %d minutes, ReturnCode %d"), 
           ulDelayMinutes, ulPeriodMinutes, dwErr);

    return dwErr;
}

//
// Convert an addrinfo list into a relay list with appropriate metrics
//
DWORD
MakeRelayList(
    IN struct addrinfo *addrs)
{
    struct addrinfo *ai;
    ULONG            ulNumRelays = 0;
    ULONG            ulLatency;

    for (ai=addrs; ai; ai=ai->ai_next) {
        ulNumRelays++;
    }

    g_pRelayList = MALLOC( FIELD_OFFSET(RELAY_LIST, arrRelay[ulNumRelays]));
    if (g_pRelayList == NULL) {
        return GetLastError();
    }
    
    g_pRelayList->ulNumRelays = ulNumRelays;
    
    ulNumRelays = 0;
    for (ai=addrs; ai; ai=ai->ai_next) {
        CopyMemory(&g_pRelayList->arrRelay[ulNumRelays].sinAddress, ai->ai_addr,
                   ai->ai_addrlen);

        //
        // Check connectivity using a possible 6to4 address for the relay 
        // router.  However, we'll actually set TTL=1 and accept a
        // hop count exceeded message, so we don't have to guess right.
        //
        Make6to4Address(&g_pRelayList->arrRelay[ulNumRelays].sin6Address, 
                        &g_pRelayList->arrRelay[ulNumRelays].sinAddress);

        // ping it to compute a metric
        ulLatency = ConfirmIPv6Reachability(&g_pRelayList->arrRelay[ulNumRelays].sin6Address, 1000/*ms*/);
        if (ulLatency != 0) {
            g_pRelayList->arrRelay[ulNumRelays].ulMetric = 1000 + ulLatency;
        } else {
            g_pRelayList->arrRelay[ulNumRelays].ulMetric = UNREACHABLE;
        }

        ulNumRelays++;
    }

    return NO_ERROR;
}

//
// When the name-resolution timer expires, it's time to re-resolve the
// relay name to a list of relays.
//
DWORD
WINAPI
OnResolutionTimeout(
    IN PVOID lpData,
    IN BOOLEAN Reason)
{
    DWORD           dwErr = NO_ERROR;
    ADDRINFOW       hints;
    PADDRINFOW      addrs;
    PRELAY_LIST     pOldRelayList;
    ULONG           i, j;

    ENTER_API();
    TraceEnter("OnResolutionTimeout");

    if (g_stService == DISABLED) {
        TraceLeave("OnResolutionTimeout (disabled)");
        LEAVE_API();

        return NO_ERROR;
    }

    pOldRelayList = g_pRelayList;
    g_pRelayList  = NULL;

    // If any 6to4 addresses are configured, 
    //     Resolve the relay name to a set of IPv4 addresses 
    // Else 
    //     Make the new set empty
    if (g_GlobalState.stResolutionState == ENABLED) {
        // Resolve the relay name to a set of IPv4 addresses 
        ZeroMemory(&hints, sizeof(hints));
        hints.ai_family = PF_INET;
        dwErr = GetAddrInfoW(g_GlobalSettings.pwszRelayName, NULL, &hints, &addrs);

        if (dwErr == NO_ERROR) {
            dwErr = MakeRelayList((PADDRINFOA)addrs);
            FreeAddrInfoW(addrs);
            addrs = NULL;
        } else {
            Trace2(ERR, _T("GetAddrInfoW(%s) returned error %d"), 
                        g_GlobalSettings.pwszRelayName, dwErr);
        }
    }

    // Compare the new set to the old set
    // For each address in the new set, ping it to compute a metric
    // For each new address, add a route
    // For each old address not in the new list, delete the route
    // For each address in both, update the route if the metric has changed
    //
    for (i=0; g_pRelayList && (i<g_pRelayList->ulNumRelays); i++) {
        for (j=0; pOldRelayList && (j<pOldRelayList->ulNumRelays); j++) {
            if (g_pRelayList->arrRelay[i].sinAddress.sin_addr.s_addr 
             == pOldRelayList->arrRelay[j].sinAddress.sin_addr.s_addr) {
                break;
            }
        }

        if (pOldRelayList && (j<pOldRelayList->ulNumRelays)) {
            // update the route if the metric has changed
            if (g_pRelayList->arrRelay[i].ulMetric 
             != pOldRelayList->arrRelay[j].ulMetric) {
                AddOrUpdate6to4Relay(&g_pRelayList->arrRelay[i]); 
            }

            g_pRelayList->arrRelay[i].sin6Address = pOldRelayList->arrRelay[j].sin6Address;
        } else {
            // add a relay
            AddOrUpdate6to4Relay(&g_pRelayList->arrRelay[i]);
        }
    }
    for (j=0; pOldRelayList && (j<pOldRelayList->ulNumRelays); j++) {
        for (i=0; g_pRelayList && (i<g_pRelayList->ulNumRelays); i++) {
            if (g_pRelayList->arrRelay[i].sinAddress.sin_addr.s_addr ==
               pOldRelayList->arrRelay[j].sinAddress.sin_addr.s_addr) {
                break;
            }
        }
        if (!g_pRelayList || (i == g_pRelayList->ulNumRelays)) {
            // delete a relay
            Delete6to4Relay(&pOldRelayList->arrRelay[j]);
        }
    }

    FreeRelayList(&pOldRelayList);

    TraceLeave("OnResolutionTimeout");
    LEAVE_API();

    return dwErr;
}



////////////////////////////////////////////////////////////////
// Routing-related subroutines
////////////////////////////////////////////////////////////////

PIF_SETTINGS
FindInterfaceSettings(
    IN WCHAR *pwszAdapterName,
    IN IF_SETTINGS_LIST *pList);

STATE
Get6to4State(
    VOID
    )
{
    //
    // Decide whether 6to4 should be enabled or not.
    //
    if (g_GlobalSettings.stEnable6to4 == AUTOMATIC) {
        return (g_b6to4Required ? ENABLED : DISABLED);
    } else {
        return g_GlobalSettings.stEnable6to4;
    }
}

// 
// Decide whether routing will be enabled at all
//
STATE
GetGlobalRoutingState(
    VOID
    )
{
    PIF_LIST pIfList = g_pInterfaceList;
    DWORD dwErr;
    GUID guid;

    if (Get6to4State() == DISABLED) {
        return DISABLED;
    }
    
    // If routing is explicitly enabled or disabled, use that
    if (g_GlobalSettings.stEnableRouting != AUTOMATIC) {
        return g_GlobalSettings.stEnableRouting;
    }

    // Disable routing if there is no private interface used by ICS
    dwErr = RasQuerySharedPrivateLan(&guid);
    if (dwErr != NO_ERROR) {
        return DISABLED;
    }

    // Disable routing if there are no global IPv4 addresses
    if (!pIfList || !pIfList->ulNumScopedAddrs[IPV4_SCOPE_GLOBAL]) {
        return DISABLED;
    }
    
    return ENABLED;
}

//
// Decide whether a given interface is one we should treat as 
// a private link to be a router on.
//
// Called by: UpdateInterfaceRoutingState, MakeInterfaceList
STATE
GetInterfaceRoutingState(
    IN PIF_INFO pIf) // potential private interface
{
    PIF_SETTINGS   pIfSettings;
    STATE          stEnableRouting = AUTOMATIC;
    DWORD          dwErr;
    GUID           guid;
    UNICODE_STRING usGuid;
    WCHAR          buffer[MAX_INTERFACE_NAME_LEN];

    if (GetGlobalRoutingState() == DISABLED) {
        return DISABLED;
    }

    pIfSettings = FindInterfaceSettings(pIf->pwszAdapterName, 
                                        g_pInterfaceSettingsList);
    if (pIfSettings) {
        stEnableRouting = pIfSettings->stEnableRouting;
    }

    if (stEnableRouting != AUTOMATIC) {
        return stEnableRouting;
    }

    //
    // Enable routing if this is the private interface used by ICS
    //
    dwErr = RasQuerySharedPrivateLan(&guid);
    if (dwErr != NO_ERROR) {
        // no private interface
        return DISABLED;
    }
    
    usGuid.Buffer = buffer;
    usGuid.MaximumLength = MAX_INTERFACE_NAME_LEN;
    dwErr = RtlStringFromGUID(&guid, &usGuid);
    if (dwErr != NO_ERROR) {
        // no private interface
        return DISABLED;
    }

    Trace1(ERR, _T("ICS private interface: %ls"), usGuid.Buffer);

    //
    // Compare guid to pIf->pwszAdapterName
    // 
    // This must be done using a case-insensitive comparison since
    // GetAdaptersInfo() returns GUID strings with upper-case letters
    // while RtlGetStringFromGUID uses lower-case letters.
    //
    if (!_wcsicmp(pIf->pwszAdapterName, usGuid.Buffer)) {
        return ENABLED;
    }

    return DISABLED;
}

// Called by: Configure6to4Subnets, Unconfigure6to4Subnets
VOID
Create6to4Prefixes(
    OUT IN6_ADDR *pSubnetPrefix,
    OUT IN6_ADDR *pSiteLocalPrefix,
    IN IN_ADDR  *ipOurAddr,     // public address
    IN ULONG ulIfIndex)         // private interface
{
    //
    // Create a subnet prefix for the interface,
    // using the interface index as the subnet number.
    //
    memset(pSubnetPrefix, 0, sizeof(IN6_ADDR));
    pSubnetPrefix->s6_addr[0] = 0x20;
    pSubnetPrefix->s6_addr[1] = 0x02;
    memcpy(&pSubnetPrefix->s6_addr[2], ipOurAddr, sizeof(IN_ADDR));
    pSubnetPrefix->s6_addr[6] = HIBYTE(ulIfIndex);
    pSubnetPrefix->s6_addr[7] = LOBYTE(ulIfIndex);

    //
    // Create a site-local prefix for the interface,
    // using the interface index as the subnet number.
    //
    memset(pSiteLocalPrefix, 0, sizeof(IN6_ADDR));
    pSiteLocalPrefix->s6_addr[0] = 0xfe;
    pSiteLocalPrefix->s6_addr[1] = 0xc0;
    pSiteLocalPrefix->s6_addr[6] = HIBYTE(ulIfIndex);
    pSiteLocalPrefix->s6_addr[7] = LOBYTE(ulIfIndex);
}

// Called by: EnableInterfaceRouting, AddAddress
void
Configure6to4Subnets(
    IN ULONG ulIfIndex,         // private interface
    IN PSUBNET_CONTEXT pSubnet) // subnet info, incl. public address
{
    IN6_ADDR SubnetPrefix;
    IN6_ADDR SiteLocalPrefix;

    if ((GetIPv4Scope(pSubnet->V4Addr.s_addr) != IPV4_SCOPE_GLOBAL)) {
        return;
    }

    Create6to4Prefixes(&SubnetPrefix, &SiteLocalPrefix, &pSubnet->V4Addr, 
                       ulIfIndex);

    //
    // Configure the subnet route.
    //
    ConfigureRouteTableUpdate(&SubnetPrefix, 64,
                              ulIfIndex, &in6addr_any,
                              pSubnet->Publish, 
                              pSubnet->Publish, 
                              pSubnet->ValidLifetime,
                              pSubnet->PreferredLifetime,
                              ((g_GlobalSettings.stEnableSiteLocals == ENABLED) ? 48 : 0), 
                              SUBNET_ROUTE_METRIC);

    if (g_GlobalSettings.stEnableSiteLocals == ENABLED) {
        ConfigureRouteTableUpdate(&SiteLocalPrefix, 64,
                                  ulIfIndex, &in6addr_any,
                                  pSubnet->Publish, 
                                  pSubnet->Publish, 
                                  pSubnet->ValidLifetime, 
                                  pSubnet->PreferredLifetime,
                                  0,
                                  SITELOCAL_ROUTE_METRIC);
    }
}

// Called by: DisableInterfaceRouting, DeleteAddress
void
Unconfigure6to4Subnets(
    IN ULONG ulIfIndex,         // private interface
    IN PSUBNET_CONTEXT pSubnet) // subnet info, inc. public address
{
    IN6_ADDR SubnetPrefix;
    IN6_ADDR SiteLocalPrefix;

    if ((GetIPv4Scope(pSubnet->V4Addr.s_addr) != IPV4_SCOPE_GLOBAL)) {
        return;
    }

    Create6to4Prefixes(&SubnetPrefix, &SiteLocalPrefix, &pSubnet->V4Addr, 
                       ulIfIndex);

    //
    // Give the 6to4 route a zero lifetime, making it invalid.
    // If we are a router, continue to publish the 6to4 route
    // until we have disabled routing. This will allow
    // the last Router Advertisements to go out with the prefix.
    //
    ConfigureRouteTableUpdate(&SubnetPrefix, 64,
                              ulIfIndex, &in6addr_any,
                              pSubnet->Publish, // Publish.
                              pSubnet->Publish, // Immortal.
                              pSubnet->ValidLifetime, 
                              pSubnet->PreferredLifetime, 
                              0, 0);

    if (g_GlobalSettings.stEnableSiteLocals == ENABLED) {
        ConfigureRouteTableUpdate(&SiteLocalPrefix, 64,
                                  ulIfIndex, &in6addr_any,
                                  pSubnet->Publish, // Publish.
                                  pSubnet->Publish, // Immortal.
                                  pSubnet->ValidLifetime, 
                                  pSubnet->PreferredLifetime, 
                                  0, 0);
    }
}

#define PUBLIC_ZONE_ID  1
#define PRIVATE_ZONE_ID 2

// Called by: EnableRouting, DisableRouting, EnableInterfaceRouting,
//            DisableInterfaceRouting
DWORD
ConfigureInterfaceUpdate(
    IN u_int Interface,
    IN int Advertises,
    IN int Forwards)
{
    IPV6_INFO_INTERFACE Update;
    DWORD Result;

    IPV6_INIT_INFO_INTERFACE(&Update);

    Update.This.Index = Interface;
    Update.Advertises = Advertises;
    Update.Forwards = Forwards;

    if (Advertises == TRUE) {
        Update.ZoneIndices[ADE_SITE_LOCAL] = PRIVATE_ZONE_ID;
        Update.ZoneIndices[ADE_ADMIN_LOCAL] = PRIVATE_ZONE_ID;
        Update.ZoneIndices[ADE_SUBNET_LOCAL] = PRIVATE_ZONE_ID;
    } else if (Advertises == FALSE) {
        Update.ZoneIndices[ADE_SITE_LOCAL] = PUBLIC_ZONE_ID;
        Update.ZoneIndices[ADE_ADMIN_LOCAL] = PUBLIC_ZONE_ID;
        Update.ZoneIndices[ADE_SUBNET_LOCAL] = PUBLIC_ZONE_ID;
    }
    
    Result = UpdateInterface(&Update);

    Trace4(ERR, _T("UpdateInterface if=%d adv=%d fwd=%d result=%d"),
                Interface, Advertises, Forwards, Result);

    return Result;
}

// Called by: UpdateGlobalRoutingState
VOID
EnableRouting()
{
    SOCKADDR_IN6  AnycastAddress;
    int           i;
    LPSOCKADDR_IN pOurAddr;

    TraceEnter("EnableRouting");

    //
    // Enable forwarding on the tunnel pseudo-interfaces.
    //
    ConfigureInterfaceUpdate(SIX_TO_FOUR_IFINDEX, -1, TRUE);
    ConfigureInterfaceUpdate(V4_COMPAT_IFINDEX, -1, TRUE);

    //
    // Add anycast addresses for all 6to4 addresses
    //
    for (i=0; i<g_pIpv4AddressList->iAddressCount; i++) {
        pOurAddr = (LPSOCKADDR_IN)g_pIpv4AddressList->Address[i].lpSockaddr;
        if ((GetIPv4Scope(pOurAddr->sin_addr.s_addr) != IPV4_SCOPE_GLOBAL)) {
            continue;
        }

        Make6to4AnycastAddress(&AnycastAddress, pOurAddr);
        ConfigureAddressUpdate(
            SIX_TO_FOUR_IFINDEX, &AnycastAddress, INFINITE_LIFETIME, 
            ADE_ANYCAST, PREFIX_CONF_WELLKNOWN, IID_CONF_WELLKNOWN);
    }

    g_GlobalState.stRoutingState = ENABLED;

    TraceLeave("EnableRouting");
}

// Called by: UpdateGlobalRoutingState
VOID
DisableRouting()
{
    SOCKADDR_IN6  AnycastAddress;
    int           i;
    LPSOCKADDR_IN pOurAddr;
    DWORD         dwErr;

    TraceEnter("DisableRouting");

    //
    // Disable forwarding on the tunnel pseudo-interfaces.
    //
    ConfigureInterfaceUpdate(SIX_TO_FOUR_IFINDEX, -1, FALSE);
    ConfigureInterfaceUpdate(V4_COMPAT_IFINDEX, -1, FALSE);

    //
    // Remove anycast addresses for all 6to4 addresses
    //
    for (i=0; i<g_pIpv4AddressList->iAddressCount; i++) {
        pOurAddr = (LPSOCKADDR_IN)g_pIpv4AddressList->Address[i].lpSockaddr;
        if ((GetIPv4Scope(pOurAddr->sin_addr.s_addr) != IPV4_SCOPE_GLOBAL)) {
            continue;
        }

        Make6to4AnycastAddress(&AnycastAddress, pOurAddr);
        dwErr = ConfigureAddressUpdate(
            SIX_TO_FOUR_IFINDEX, &AnycastAddress, 0,
            ADE_ANYCAST, PREFIX_CONF_WELLKNOWN, IID_CONF_WELLKNOWN);
    }

    g_GlobalState.stRoutingState = DISABLED;

    TraceLeave("DisableRouting");
}


// Called by: UpdateInterfaceRoutingState
VOID
EnableInterfaceRouting(
    IN PIF_INFO pIf,                    // private interface
    IN PADDR_LIST pPublicAddressList)   // public address list
{
    int            i;
    LPSOCKADDR_IN  pOurAddr;
    SUBNET_CONTEXT Subnet;

    Trace2(ERR, _T("Enabling routing on interface %d: %ls"), 
                pIf->ulIPv6IfIndex, pIf->pwszAdapterName);

    ConfigureInterfaceUpdate(pIf->ulIPv6IfIndex, TRUE, TRUE);

    // For each public address
    for (i=0; i<pPublicAddressList->iAddressCount; i++) {
        pOurAddr = (LPSOCKADDR_IN)pPublicAddressList->Address[i].lpSockaddr;
        Subnet.V4Addr = pOurAddr->sin_addr;
        Subnet.Publish = TRUE;
        Subnet.ValidLifetime = 2 * DAYS;
        Subnet.PreferredLifetime = 30 * MINUTES;
        Configure6to4Subnets(pIf->ulIPv6IfIndex, &Subnet);
    }

    pIf->stRoutingState = ENABLED;
}

// Called by: PreUpdateInterfaceRoutingState, UninitializeInterfaces
BOOL
PreDisableInterfaceRouting(
    IN PIF_INFO pIf,            // private interface
    IN PADDR_LIST pPublicAddressList)
{
    int            i;
    LPSOCKADDR_IN  pOurAddr;
    SUBNET_CONTEXT Subnet;

    Trace1(ERR, _T("Pre-Disabling routing on interface %d"), 
                pIf->ulIPv6IfIndex);

    //
    // For each public address, publish RA saying we're going away
    //
    for (i=0; i<pPublicAddressList->iAddressCount; i++) {
        pOurAddr = (LPSOCKADDR_IN)pPublicAddressList->Address[i].lpSockaddr;
        Subnet.V4Addr = pOurAddr->sin_addr;
        Subnet.Publish = TRUE;
        Subnet.ValidLifetime = Subnet.PreferredLifetime = 0;
        Unconfigure6to4Subnets(pIf->ulIPv6IfIndex, &Subnet);
    }

    return (pPublicAddressList->iAddressCount > 0);
}

// Called by: UpdateInterfaceRoutingState, UninitializeInterfaces
VOID
DisableInterfaceRouting(
    IN PIF_INFO pIf,            // private interface
    IN PADDR_LIST pPublicAddressList)
{
    int            i;
    LPSOCKADDR_IN  pOurAddr;
    SUBNET_CONTEXT Subnet;

    Trace1(ERR, _T("Disabling routing on interface %d"), pIf->ulIPv6IfIndex);

    ConfigureInterfaceUpdate(pIf->ulIPv6IfIndex, FALSE, FALSE);

    //
    // For each public address, unconfigure 6to4 subnets
    //
    for (i=0; i<pPublicAddressList->iAddressCount; i++) {
        pOurAddr = (LPSOCKADDR_IN)pPublicAddressList->Address[i].lpSockaddr;
        Subnet.V4Addr = pOurAddr->sin_addr;
        Subnet.Publish = FALSE;
        Subnet.ValidLifetime = Subnet.PreferredLifetime = 0;
        Unconfigure6to4Subnets(pIf->ulIPv6IfIndex, &Subnet);
    }

    pIf->stRoutingState = DISABLED;
}

BOOL                            // TRUE if need to sleep
PreUpdateInterfaceRoutingState(
    IN PIF_INFO pIf,            // private interface
    IN PADDR_LIST pPublicAddressList)
{
    STATE stIfRoutingState = GetInterfaceRoutingState(pIf);

    if (pIf->stRoutingState == stIfRoutingState) {
        return FALSE;
    }

    if (!(stIfRoutingState == ENABLED)) {
        return PreDisableInterfaceRouting(pIf, pPublicAddressList);
    }

    return FALSE;
}

//
// Update the current state of an interface (i.e. whether or not it's a 
// private interface on which we're serving as a router) according to 
// configuration and whether IPv4 global addresses exist on the interface.
//
// Called by: UpdateGlobalRoutingState, OnConfigChange
VOID
UpdateInterfaceRoutingState(
    IN PIF_INFO pIf,            // private interface
    IN PADDR_LIST pPublicAddressList) 
{
    STATE stIfRoutingState = GetInterfaceRoutingState(pIf);

    if (pIf->stRoutingState == stIfRoutingState) {
        return;
    }

    if (stIfRoutingState == ENABLED) {
        EnableInterfaceRouting(pIf, pPublicAddressList);
    } else {
        DisableInterfaceRouting(pIf, pPublicAddressList);
    }
}

BOOL
PreUpdateGlobalRoutingState()
{
    ULONG    i;
    PIF_LIST pList = g_pInterfaceList;
    BOOL     bWait = FALSE;
    
    if (pList == NULL) {
        return FALSE;
    }

    for (i = 0; i < pList->ulNumInterfaces; i++) {
        bWait |= PreUpdateInterfaceRoutingState(&pList->arrIf[i], 
                                                g_pIpv4AddressList);
    }

    return bWait;
}

// Called by: OnConfigChange, OnChangeInterfaceInfo
VOID
UpdateGlobalRoutingState()
{
    ULONG    i;
    PIF_LIST pList = g_pInterfaceList;
    STATE    stNewRoutingState;

    stNewRoutingState = GetGlobalRoutingState();

    if (g_GlobalState.stRoutingState != stNewRoutingState) {
        if (stNewRoutingState == ENABLED) {
            EnableRouting();
        } else {
            DisableRouting();
        }
    }

    if (pList == NULL) {
        return;
    }

    for (i=0; i<pList->ulNumInterfaces; i++) {
        UpdateInterfaceRoutingState(&pList->arrIf[i], g_pIpv4AddressList);
    }
}

////////////////////////////////////////////////////////////////
// Interface-related subroutines
////////////////////////////////////////////////////////////////

PIF_SETTINGS
FindInterfaceSettings(
    IN WCHAR *pwszAdapterName,
    IN IF_SETTINGS_LIST *pList)
{
    ULONG        i;
    PIF_SETTINGS pIf;

    if (pList == NULL) {
        return NULL;
    }

    for (i=0; i<pList->ulNumInterfaces; i++) {
        pIf = &pList->arrIf[i];
        if (wcscmp(pIf->pwszAdapterName, pwszAdapterName)) {
            return pIf;
        }
    }

    return NULL;
}

PIF_INFO
FindInterfaceInfo(
    IN WCHAR *pwszAdapterName,
    IN IF_LIST *pList)
{
    ULONG    i;
    PIF_INFO pIf;

    if (pList == NULL) {
        return NULL;
    }

    for (i=0; i<pList->ulNumInterfaces; i++) {
        pIf = &pList->arrIf[i];
        if (!wcscmp(pIf->pwszAdapterName, pwszAdapterName)) {
            return pIf;
        }
    }

    return NULL;
}


DWORD NTAPI
OnRouteChange(
    IN PVOID Context,
    IN BOOLEAN TimedOut
    );

VOID
StopRouteChangeNotification()
{
    if (g_hRouteChangeWaitHandle) {
        //
        // Block until we're sure that the route change callback isn't
        // still running.
        //
        LEAVE_API();
        UnregisterWaitEx(g_hRouteChangeWaitHandle, INVALID_HANDLE_VALUE);
        ENTER_API();

        //
        // Release the event we counted for RegisterWaitForSingleObject
        //
        DecEventCount("AC:StopIpv4RouteChangeNotification");
        g_hRouteChangeWaitHandle = NULL;
    }
    if (g_hRouteChangeEvent) {
        CloseHandle(g_hRouteChangeEvent);
        g_hRouteChangeEvent = NULL;
    }
}

VOID
StartRouteChangeNotification()
{
    ULONG  Error;
    BOOL   bOk;
    HANDLE TcpipHandle;

    TraceEnter("StartRouteChangeNotification");

    //
    // Create an event on which to receive notifications
    // and register a callback routine to be invoked if the event is signalled.
    // Then request notification of route changes on the event.
    //

    if (!g_hRouteChangeEvent) {
        g_hRouteChangeEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (g_hRouteChangeEvent == NULL) {
            goto Error;
        }
    
        //
        // Count the following register as an event.
        //
        IncEventCount("AC:StartIpv4RouteChangeNotification");

        bOk = RegisterWaitForSingleObject(&g_hRouteChangeWaitHandle,
                                          g_hRouteChangeEvent,
                                          OnRouteChange,
                                          NULL,
                                          INFINITE,
                                          0);
        if (!bOk) {
            DecEventCount("AC:StartIpv4RouteChangeNotification");
            goto Error;
        }
    }
    
    ZeroMemory(&g_hRouteChangeOverlapped, sizeof(OVERLAPPED));
    g_hRouteChangeOverlapped.hEvent = g_hRouteChangeEvent;

    Error = NotifyRouteChange(&TcpipHandle, &g_hRouteChangeOverlapped);
    if (Error != ERROR_IO_PENDING) { 
        goto Error;
    }

    return;

Error:
    //
    // A failure has occurred, so cleanup and quit.
    // We proceed in this case without notification of route changes.
    //
    StopRouteChangeNotification();

    TraceLeave("StartRouteChangeNotification");
}


//  This routine is invoked when a change to the IPv4 route table is signalled.
//
DWORD NTAPI
OnRouteChange(
    IN PVOID Context,
    IN BOOLEAN TimedOut)
{
    ENTER_API();
    TraceEnter("OnRouteChange");

    if (g_stService == DISABLED) {
        Trace0(FSM, L"Service disabled");
        goto Done;
    }

    //
    // First register for another route change notification.
    // We must do this *before* processing this route change,
    // to avoid missing an route change.
    //
    StartRouteChangeNotification();
    
    UpdateGlobalResolutionState();
    IsatapRouteChangeNotification();
#ifdef TEREDO    
    TeredoRouteChangeNotification();
#endif // TEREDO
    
Done:    
    TraceLeave("OnRouteChange");
    LEAVE_API();

    return NO_ERROR;
}


DWORD NTAPI
OnChangeInterfaceInfo(
    IN PVOID Context,
    IN BOOLEAN TimedOut
    );

VOID
StopAddressChangeNotification()
{
    if (g_hAddressChangeWaitHandle) {
        //
        // Block until we're sure that the address change callback isn't
        // still running.
        //
        LEAVE_API();
        UnregisterWaitEx(g_hAddressChangeWaitHandle, INVALID_HANDLE_VALUE);
        ENTER_API();

        //
        // Release the event we counted for RegisterWaitForSingleObject
        //
        DecEventCount("AC:StopIpv4AddressChangeNotification");
        g_hAddressChangeWaitHandle = NULL;
    }
    if (g_hAddressChangeEvent) {
        CloseHandle(g_hAddressChangeEvent);
        g_hAddressChangeEvent = NULL;
    }
}

VOID
StartAddressChangeNotification()
{
    ULONG  Error;
    BOOL   bOk;
    HANDLE TcpipHandle;

    TraceEnter("StartAddressChangeNotification");

    //
    // Create an event on which to receive notifications
    // and register a callback routine to be invoked if the event is signalled.
    // Then request notification of address changes on the event.
    //

    if (!g_hAddressChangeEvent) {
        g_hAddressChangeEvent = CreateEvent(NULL,
                                            FALSE,
                                            FALSE,
                                            NULL);
        if (g_hAddressChangeEvent == NULL) {
            goto Error;
        }
    
        //
        // Count the following register as an event.
        //
        IncEventCount("AC:StartIpv4AddressChangeNotification");

        bOk = RegisterWaitForSingleObject(&g_hAddressChangeWaitHandle,
                                          g_hAddressChangeEvent,
                                          OnChangeInterfaceInfo,
                                          NULL,
                                          INFINITE,
                                          0);
        if (!bOk) {
            DecEventCount("AC:StartIpv4AddressChangeNotification");
            goto Error;
        }
    }
    
    ZeroMemory(&g_hAddressChangeOverlapped, sizeof(OVERLAPPED));
    g_hAddressChangeOverlapped.hEvent = g_hAddressChangeEvent;

    Error = NotifyAddrChange(&TcpipHandle, &g_hAddressChangeOverlapped);
    if (Error != ERROR_IO_PENDING) { 
        goto Error;
    }

    return;

Error:

    //
    // A failure has occurred, so cleanup and quit.
    // We proceed in this case without notification of address changes.
    //

    StopAddressChangeNotification();

    TraceLeave("StartAddressChangeNotification");
}

//
// Convert an "adapter" list to an "interface" list and store the result in
// the global g_pInterfaceList.
//
DWORD
MakeInterfaceList(
    IN PIP_ADAPTER_INFO pAdapterInfo)
{
    DWORD                dwErr = NO_ERROR;
    ULONG                ulNumInterfaces = 0, ulSize;
    PIP_ADAPTER_INFO     pAdapter;
    PIF_INFO             pIf;
    IPV6_INFO_INTERFACE *pIfStackInfo;

    // count adapters
    for (pAdapter=pAdapterInfo; pAdapter; pAdapter=pAdapter->Next) {
        ulNumInterfaces++;
    }

    // allocate enough space
    ulSize = FIELD_OFFSET(IF_LIST, arrIf[ulNumInterfaces]);
    g_pInterfaceList = MALLOC(ulSize);
    if (g_pInterfaceList == NULL) {
        return GetLastError();
    }

    // fill in list
    g_pInterfaceList->ulNumInterfaces = ulNumInterfaces;
    ZeroMemory(g_pInterfaceList->ulNumScopedAddrs,
               sizeof(ULONG) * NUM_IPV4_SCOPES);
    ulNumInterfaces = 0;
    for (pAdapter=pAdapterInfo; pAdapter; pAdapter=pAdapter->Next) {
        pIf = &g_pInterfaceList->arrIf[ulNumInterfaces]; 

        ConvertOemToUnicode(pAdapter->AdapterName, pIf->pwszAdapterName,
                            MAX_ADAPTER_NAME);

        Trace1(FSM, _T("Adding interface %ls"), pIf->pwszAdapterName);

        dwErr = MakeAddressList(&pAdapter->IpAddressList,
                                &pIf->pAddressList, &pIf->ulNumGlobals,
                                g_pInterfaceList->ulNumScopedAddrs);

        pIfStackInfo = GetInterfaceStackInfo(pIf->pwszAdapterName);
        if (pIfStackInfo) {
            pIf->ulIPv6IfIndex = pIfStackInfo->This.Index;
        } else {
            pIf->ulIPv6IfIndex = 0;
        }
        FREE(pIfStackInfo);

        pIf->stRoutingState = DISABLED;

        ulNumInterfaces++;
    }

    return dwErr;
}

VOID
FreeInterfaceList(
    IN OUT PIF_LIST *ppList)
{
    ULONG i;

    if (*ppList == NULL) {
        return;
    }

    for (i=0; i<(*ppList)->ulNumInterfaces; i++) {
        FreeAddressList( &(*ppList)->arrIf[i].pAddressList );
    }

    FREE(*ppList);
    *ppList = NULL;
}

DWORD
InitializeInterfaces()
{
    g_pInterfaceList = NULL;
    return NO_ERROR;
}

VOID
ProcessInterfaceStateChange(
    IN ADDR_LIST CONST *pAddressList, 
    IN ADDR_LIST *pOldAddressList,
    IN PIF_LIST pOldInterfaceList,
    IN GLOBAL_STATE *pOldState,
    IN OUT BOOL *pbNeedDelete)
{
    INT j,k;
    LPSOCKADDR_IN pAddr;

    // For each new global address not in old list,
    //    add a 6to4 address
    for (j=0; j<pAddressList->iAddressCount; j++) {
        pAddr = (LPSOCKADDR_IN)pAddressList->Address[j].lpSockaddr;

        Trace1(FSM, _T("Checking for new address %d.%d.%d.%d"), 
                    PRINT_IPADDR(pAddr->sin_addr.s_addr));

        // See if address is in old list
        for (k=0; k<pOldAddressList->iAddressCount; k++) {
            if (pAddr->sin_addr.s_addr == ((LPSOCKADDR_IN)pOldAddressList->Address[k].lpSockaddr)->sin_addr.s_addr) {
                break;
            }
        }

        // If so, continue
        if (k<pOldAddressList->iAddressCount) {
            continue;
        }

        // Add an address, and use it for routing if enabled
        AddAddress(pAddr, g_pInterfaceList, g_GlobalState.stRoutingState);
    }

    // For each old global address not in the new list, 
    //    delete a 6to4 address
    for (k=0; k<pOldAddressList->iAddressCount; k++) {
        pAddr = (LPSOCKADDR_IN)pOldAddressList->Address[k].lpSockaddr;

        Trace1(FSM, _T("Checking for old address %d.%d.%d.%d"), 
                    PRINT_IPADDR(pAddr->sin_addr.s_addr));

        // See if address is in new list
        for (j=0; j<pAddressList->iAddressCount; j++) {
            if (((LPSOCKADDR_IN)pAddressList->Address[j].lpSockaddr)->sin_addr.s_addr
             == pAddr->sin_addr.s_addr) {
                break;
            }
        }

        // If so, continue
        if (j<pAddressList->iAddressCount) {
            continue;
        }

        // Prepare to delete the 6to4 address
        PreDeleteAddress(pAddr, pOldInterfaceList, pOldState->stRoutingState);
        *pbNeedDelete = TRUE;
    }
}

VOID
FinishInterfaceStateChange(
    IN ADDR_LIST CONST *pAddressList, 
    IN ADDR_LIST *pOldAddressList,
    IN PIF_LIST pOldInterfaceList,
    IN GLOBAL_STATE *pOldState)
{
    INT j,k;
    LPSOCKADDR_IN pAddr;

    // For each old global address not in the new list, 
    //    delete a 6to4 address
    for (k=0; k<pOldAddressList->iAddressCount; k++) {
        pAddr = (LPSOCKADDR_IN)pOldAddressList->Address[k].lpSockaddr;

        Trace1(FSM, _T("Checking for old address %d.%d.%d.%d"), 
                    PRINT_IPADDR(pAddr->sin_addr.s_addr));

        // See if address is in new list
        for (j=0; j<pAddressList->iAddressCount; j++) {
            if (((LPSOCKADDR_IN)pAddressList->Address[j].lpSockaddr)->sin_addr.s_addr
             == pAddr->sin_addr.s_addr) {
                break;
            }
        }
    
        // If so, continue
        if (j<pAddressList->iAddressCount) {
            continue;
        }

        // Prepare to delete the 6to4 address
        DeleteAddress(pAddr, pOldInterfaceList, pOldState->stRoutingState);
    }
}

//  This routine is invoked when a change to the set of local IPv4 addressed
//  is signalled.  It is responsible for updating the bindings of the 
//  private and public interfaces, and re-requesting change notification.
//
DWORD NTAPI
OnChangeInterfaceInfo(
    IN PVOID Context,
    IN BOOLEAN TimedOut)
{
    PIF_INFO             pIf, pOldIf;
    ULONG                i, ulSize = 0;
    PIP_ADAPTER_INFO     pAdapterInfo = NULL;
    PIF_LIST             pOldInterfaceList;
    DWORD                dwErr = NO_ERROR;
    ADDR_LIST           *pAddressList, *pOldAddressList;
    GLOBAL_SETTINGS      OldSettings;
    GLOBAL_STATE         OldState;
    BOOL                 bNeedDelete = FALSE, bWait = FALSE;

    ENTER_API();
    TraceEnter("OnChangeInterfaceInfo");

    if (g_stService == DISABLED) {
        Trace0(FSM, L"Service disabled");
        goto Done;
    }

    //
    // First register for another address change notification.
    // We must do this *before* getting the address list,
    // to avoid missing an address change.
    //
    StartAddressChangeNotification();
    
    OldSettings = g_GlobalSettings; // struct copy
    OldState    = g_GlobalState;    // struct copy

    //
    // Get the new set of IPv4 addresses on interfaces
    //
    
    for (;;) {
        dwErr = GetAdaptersInfo(pAdapterInfo, &ulSize);
        if (dwErr == ERROR_SUCCESS) {
            break;
        }
        if (dwErr == ERROR_NO_DATA) {
            dwErr = ERROR_SUCCESS;
            break;
        }

        if (pAdapterInfo) {
            FREE(pAdapterInfo);
            pAdapterInfo = NULL;
        }

        if (dwErr != ERROR_BUFFER_OVERFLOW) {
            dwErr = GetLastError();
            goto Done;
        }

        pAdapterInfo = MALLOC(ulSize);
        if (pAdapterInfo == NULL) {
            dwErr = GetLastError();
            goto Done;
        }
    }

    pOldInterfaceList = g_pInterfaceList;
    g_pInterfaceList  = NULL;

    MakeInterfaceList(pAdapterInfo);
    if (pAdapterInfo) {
        FREE(pAdapterInfo);
        pAdapterInfo = NULL;
    }

    //
    // First update global address list
    //

    // For each interface in the new list...
    for (i=0; i<g_pInterfaceList->ulNumInterfaces; i++) {
        pIf = &g_pInterfaceList->arrIf[i];

        pAddressList = pIf->pAddressList;

        pOldIf = FindInterfaceInfo(pIf->pwszAdapterName,
                                   pOldInterfaceList);

        pOldAddressList = (pOldIf)? pOldIf->pAddressList : &EmptyAddressList;

        if (pOldIf) {
            pIf->stRoutingState = pOldIf->stRoutingState;
        }

        ProcessInterfaceStateChange(pAddressList, pOldAddressList, 
            pOldInterfaceList, &OldState, &bNeedDelete);
    }

    // For each old interface not in the new list,
    // delete information.
    for (i=0; pOldInterfaceList && (i<pOldInterfaceList->ulNumInterfaces); i++){
        pOldIf = &pOldInterfaceList->arrIf[i];
        pOldAddressList = pOldIf->pAddressList;
        pIf = FindInterfaceInfo(pOldIf->pwszAdapterName, g_pInterfaceList);
        if (pIf) {
            continue;
        }
        ProcessInterfaceStateChange(&EmptyAddressList, pOldAddressList, 
            pOldInterfaceList, &OldState, &bNeedDelete);
    }

    Trace2(FSM, _T("num globals=%d num publics=%d"),
           g_pInterfaceList->ulNumScopedAddrs[IPV4_SCOPE_GLOBAL],
           g_pIpv4AddressList->iAddressCount);

    if (g_pInterfaceList->ulNumScopedAddrs[IPV4_SCOPE_GLOBAL] == 0) {
        PreDelete6to4Routes();
    }
    
    bWait = PreUpdateGlobalRoutingState();

    //
    // If needed, wait a bit to ensure that Router Advertisements
    // carrying the zero lifetime prefixes get sent.
    //
    if (bWait || (bNeedDelete && (OldState.stRoutingState == ENABLED))) {
        Sleep(2000);
    }

    g_st6to4State = (g_pInterfaceList->ulNumScopedAddrs[IPV4_SCOPE_GLOBAL] > 0)
        ? ENABLED : DISABLED;

    UpdateGlobalResolutionState();

    Update6to4Routes();
    
    UpdateGlobalRoutingState();

    //
    // Now finish removing the 6to4 addresses.
    //
    if (bNeedDelete) {
        for (i=0; i<g_pInterfaceList->ulNumInterfaces; i++) {
            pIf = &g_pInterfaceList->arrIf[i];

            pAddressList = pIf->pAddressList;

            pOldIf = FindInterfaceInfo(pIf->pwszAdapterName,
                                       pOldInterfaceList);
    
            pOldAddressList = (pOldIf)? pOldIf->pAddressList : &EmptyAddressList;
    
            FinishInterfaceStateChange(pAddressList, pOldAddressList, 
                pOldInterfaceList, &OldState);

        }
        for (i=0; pOldInterfaceList && (i<pOldInterfaceList->ulNumInterfaces); i++){
            pOldIf = &pOldInterfaceList->arrIf[i];
            pOldAddressList = pOldIf->pAddressList;
            pIf = FindInterfaceInfo(pOldIf->pwszAdapterName, g_pInterfaceList);
            if (pIf) {
                continue;
            }
            FinishInterfaceStateChange(&EmptyAddressList, pOldAddressList, 
                pOldInterfaceList, &OldState);
        }
    }

    FreeInterfaceList(&pOldInterfaceList);

Done:
    TraceLeave("OnChangeInterfaceInfo");
    LEAVE_API();

    return dwErr;
}

// Note that this function can take over 2 seconds to complete if we're a 
// router. (This is by design).
//
// Called by: Stop6to4
VOID
UninitializeInterfaces()
{
    PIF_INFO             pIf;
    ULONG                i;
    int                  k;
    ADDR_LIST           *pAddressList;
    LPSOCKADDR_IN        pAddr;

    TraceEnter("UninitializeInterfaces");

    // Cancel the address change notification
    StopIpv6AddressChangeNotification();
    StopAddressChangeNotification();
    StopRouteChangeNotification();

    // Since this is the first function called when stopping, 
    // the "old" global state/settings is in g_GlobalState/Settings.

    if (g_GlobalSettings.stUndoOnStop == ENABLED) {

        if (g_GlobalState.stRoutingState == ENABLED) {
            //
            // First announce we're going away
            //

            PreDelete6to4Routes();

            // 
            // Now do the same for subnets we're advertising
            //
            for (i=0; i<g_pInterfaceList->ulNumInterfaces; i++) {
                pIf = &g_pInterfaceList->arrIf[i];
    
                pAddressList = pIf->pAddressList;
    
                // For each old global address not in the new list,
                //    delete a 6to4 address (see below)
                Trace1(FSM, _T("Checking %d old addresses"),
                            pAddressList->iAddressCount);
                for (k=0; k<pAddressList->iAddressCount; k++) {
                    pAddr = (LPSOCKADDR_IN)pAddressList->Address[k].lpSockaddr;
    
                    Trace1(FSM, _T("Checking for old address %d.%d.%d.%d"),
                                PRINT_IPADDR(pAddr->sin_addr.s_addr));
    
                    PreDeleteAddress(pAddr, g_pInterfaceList, ENABLED);
                }

                if (pIf->stRoutingState == ENABLED) {
                    PreDisableInterfaceRouting(pIf, g_pIpv4AddressList);
                }
            }
    
            //
            // Wait a bit to ensure that Router Advertisements
            // carrying the zero lifetime prefixes get sent.
            //
            Sleep(2000);
        }

        g_st6to4State = DISABLED;            

        Update6to4Routes();

        //
        // Delete 6to4 addresses
        //
        for (i=0; g_pInterfaceList && i<g_pInterfaceList->ulNumInterfaces; i++) {
            pIf = &g_pInterfaceList->arrIf[i];
    
            pAddressList = pIf->pAddressList;
    
            // For each old global address not in the new list, 
            //    delete a 6to4 address (see below)
            Trace1(FSM, _T("Checking %d old addresses"), 
                        pAddressList->iAddressCount);
            for (k=0; k<pAddressList->iAddressCount; k++) {
                pAddr = (LPSOCKADDR_IN)pAddressList->Address[k].lpSockaddr;
    
                Trace1(FSM, _T("Checking for old address %d.%d.%d.%d"), 
                            PRINT_IPADDR(pAddr->sin_addr.s_addr));
    
                DeleteAddress(pAddr, g_pInterfaceList,
                              g_GlobalState.stRoutingState);
            }
        
            // update the IPv6 routing state
            if (pIf->stRoutingState == ENABLED) {
                DisableInterfaceRouting(pIf, g_pIpv4AddressList);
            }
        }

        if (g_GlobalState.stRoutingState == ENABLED) {
            DisableRouting();
        }
    }

    // Free the "old list"
    FreeInterfaceList(&g_pInterfaceList);

    TraceLeave("UninitializeInterfaces");
}

////////////////////////////////////////////////////////////////
// Event-processing functions
////////////////////////////////////////////////////////////////

// Get an integer value from the registry
ULONG
GetInteger(
    IN HKEY hKey,
    IN LPCTSTR lpName,
    IN ULONG ulDefault)
{
    DWORD dwErr, dwType;
    ULONG ulSize, ulValue;

    if (hKey == INVALID_HANDLE_VALUE) {
        return ulDefault;
    }
    
    ulSize = sizeof(ulValue);
    dwErr = RegQueryValueEx(hKey, lpName, NULL, &dwType, (PBYTE)&ulValue, 
                            &ulSize);
    
    if (dwErr != ERROR_SUCCESS) {
        return ulDefault;
    }

    if (dwType != REG_DWORD) {
        return ulDefault;
    }

    if (ulValue == DEFAULT) {
        return ulDefault;
    }

    return ulValue;
}

// Get a string value from the registry
VOID
GetString(
    IN HKEY hKey,
    IN LPCTSTR lpName,
    IN PWCHAR pBuff,
    IN ULONG ulLength,
    IN PWCHAR pDefault)
{
    DWORD dwErr, dwType;
    ULONG ulSize;

    if (hKey == INVALID_HANDLE_VALUE) {
        wcsncpy(pBuff, pDefault, ulLength);
        return;
    }
    
    ulSize = ulLength - sizeof(L'\0');
    dwErr = RegQueryValueEx(hKey, lpName, NULL, &dwType, (PBYTE)pBuff,
                            &ulSize);

    if (dwErr != ERROR_SUCCESS) {
        wcsncpy(pBuff, pDefault, ulLength);
        return;
    }

    if (dwType != REG_SZ) {
        wcsncpy(pBuff, pDefault, ulLength);
        return;
    }

    if (pBuff[0] == L'\0') {
        wcsncpy(pBuff, pDefault, ulLength);
        return;
    }

    ASSERT(ulSize < ulLength);
    pBuff[ulSize / sizeof(WCHAR)] = '\0'; // ensure NULL termination.
}

// called when # of 6to4 addresses becomes 0 or non-zero
// and when stEnableResolution setting changes
//
// Called by: OnConfigChange, OnChangeInterfaceInfo, OnChangeRouteInfo
VOID
UpdateGlobalResolutionState(
    VOID
    )
{
    DWORD i;

    // Decide whether relay name resolution should be enabled or not
    if (Get6to4State() == DISABLED) {
        g_GlobalState.stResolutionState = DISABLED;
    } else if (g_GlobalSettings.stEnableResolution != AUTOMATIC) {
        g_GlobalState.stResolutionState = g_GlobalSettings.stEnableResolution;
    } else {
        // Enable if we have any 6to4 addresses
        g_GlobalState.stResolutionState = g_st6to4State;
    }

    if (g_GlobalState.stResolutionState == ENABLED) {
        //
        // Restart the resolution timer, even if it's already running
        // and the name and interval haven't changed.  We also get
        // called when we first get an IP address, such as when we
        // dial up to the Internet, and we want to immediately retry
        // resolution at this point.
        //
        (VOID) RestartResolutionTimer(
            0, 
            g_GlobalSettings.ulResolutionInterval,
            &g_h6to4ResolutionTimer,
            (WAITORTIMERCALLBACK) OnResolutionTimeout);
    } else {
        if (g_h6to4ResolutionTimer != INVALID_HANDLE_VALUE) {
            // 
            // stop it
            //
            CancelResolutionTimer(&g_h6to4ResolutionTimer,
                                  g_h6to4TimerCancelledEvent);
        }

        // Delete all existing relays
        if (g_pRelayList) {
            for (i=0; i<g_pRelayList->ulNumRelays; i++) {
                Delete6to4Relay(&g_pRelayList->arrRelay[i]);
            }
            FreeRelayList(&g_pRelayList);
        }
    }
}


VOID
Update6over4State(
    IN STATE State
    )
{
    int i;

    if (g_GlobalSettings.stEnable6over4 == State) {
        return;
    }
    g_GlobalSettings.stEnable6over4 = State;
    
    if (g_GlobalSettings.stEnable6over4 == ENABLED) {
        // Create 6over4 interfaces
        for (i=0; i<g_pIpv4AddressList->iAddressCount; i++) {
            if (g_pIpv4AddressList->Address[i].ul6over4IfIndex) {
                continue;
            }
            Trace1(ERR, _T("Creating interface for %d.%d.%d.%d"), 
                   PRINT_IPADDR(((LPSOCKADDR_IN)g_pIpv4AddressList->Address[i].lpSockaddr)->sin_addr.s_addr));

            g_pIpv4AddressList->Address[i].ul6over4IfIndex = Create6over4Interface(((LPSOCKADDR_IN)g_pIpv4AddressList->Address[i].lpSockaddr)->sin_addr);
        }
    } else {
        // Delete all 6over4 interfaces
        for (i=0; i<g_pIpv4AddressList->iAddressCount; i++) {
            if (!g_pIpv4AddressList->Address[i].ul6over4IfIndex) {
                continue;
            }
            Trace1(ERR, _T("Deleting interface for %d.%d.%d.%d"), 
                   PRINT_IPADDR(((LPSOCKADDR_IN)g_pIpv4AddressList->Address[i].lpSockaddr)->sin_addr.s_addr));
            DeleteInterface(g_pIpv4AddressList->Address[i].ul6over4IfIndex);
            g_pIpv4AddressList->Address[i].ul6over4IfIndex = 0;
        }
    }
}

// Process a change to the state of whether v4-compatible addresses 
// are enabled.
VOID
UpdateV4CompatState(
    IN STATE State
    )
{
    int i;
    LPSOCKADDR_IN pIPv4Address;
    SOCKADDR_IN6 OurAddress;
    u_int AddressLifetime;

    if (g_GlobalSettings.stEnableV4Compat == State) {
        return;
    }
    g_GlobalSettings.stEnableV4Compat = State;
    
    // Create or delete the route, and figure out the address lifetime.
    if (g_GlobalSettings.stEnableV4Compat == ENABLED) {
        ConfigureRouteTableUpdate(&in6addr_any, 96,
                                  V4_COMPAT_IFINDEX, &in6addr_any,
                                  TRUE, // Publish.
                                  TRUE, // Immortal.
                                  2 * HOURS, // Valid lifetime.
                                  30 * MINUTES, // Preferred lifetime.
                                  0,
                                  SIXTOFOUR_METRIC);

        AddressLifetime = INFINITE_LIFETIME;
    } else {
        ConfigureRouteTableUpdate(&in6addr_any, 96,
                                  V4_COMPAT_IFINDEX, &in6addr_any,
                                  FALSE, // Publish.
                                  FALSE, // Immortal.
                                  0, 0, 0, 0);

        AddressLifetime = 0;
    }

    // Now go and update the lifetime of v4-compatible addresses,
    // which will cause them to be added or deleted.
    for (i=0; i<g_pIpv4AddressList->iAddressCount; i++) {
        pIPv4Address = (LPSOCKADDR_IN)g_pIpv4AddressList->
                                        Address[i].lpSockaddr;

        if (GetIPv4Scope(pIPv4Address->sin_addr.s_addr) != IPV4_SCOPE_GLOBAL) {
            continue;
        }

        MakeV4CompatibleAddress(&OurAddress, pIPv4Address);

        ConfigureAddressUpdate(V4_COMPAT_IFINDEX, &OurAddress, 
                               AddressLifetime, ADE_UNICAST, 
                               PREFIX_CONF_WELLKNOWN, IID_CONF_LL_ADDRESS);
    }
}


// Process a change to something in the registry
DWORD
OnConfigChange()
{
    HKEY            hGlobal, hInterfaces, hIf;
    DWORD           dwErr, dwSize;
    STATE           State6over4, StateV4Compat;
    DWORD           i;
    WCHAR           pwszAdapterName[MAX_ADAPTER_NAME];
    IF_SETTINGS    *pIfSettings;

    hGlobal = hInterfaces = hIf = INVALID_HANDLE_VALUE;
    
    ENTER_API();
    TraceEnter("OnConfigChange");

    if (g_stService == DISABLED) {
        TraceLeave("OnConfigChange (disabled)");
        LEAVE_API();

        return NO_ERROR;
    }

    // Read global settings from the registry
    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, KEY_GLOBAL, 0, KEY_QUERY_VALUE,
                         &hGlobal);

    g_GlobalSettings.stEnable6to4 = GetInteger(
        hGlobal, KEY_ENABLE_6TO4, DEFAULT_ENABLE_6TO4);
    g_GlobalSettings.stEnableRouting = GetInteger(
        hGlobal, KEY_ENABLE_ROUTING, DEFAULT_ENABLE_ROUTING);
    g_GlobalSettings.stEnableSiteLocals = GetInteger(
        hGlobal, KEY_ENABLE_SITELOCALS, DEFAULT_ENABLE_SITELOCALS);
    g_GlobalSettings.stEnableResolution = GetInteger(
        hGlobal, KEY_ENABLE_RESOLUTION, DEFAULT_ENABLE_RESOLUTION);
    g_GlobalSettings.ulResolutionInterval = GetInteger(
        hGlobal, KEY_RESOLUTION_INTERVAL, DEFAULT_RESOLUTION_INTERVAL);
    GetString(
        hGlobal, KEY_RELAY_NAME,
        g_GlobalSettings.pwszRelayName, NI_MAXHOST, DEFAULT_RELAY_NAME);

    if (g_GlobalSettings.stEnable6to4 == DISABLED) {
        g_GlobalSettings.stEnableRouting
            = g_GlobalSettings.stEnableResolution
            = DISABLED;
    }
    
    State6over4 = GetInteger(
        hGlobal, KEY_ENABLE_6OVER4, DEFAULT_ENABLE_6OVER4);
    StateV4Compat = GetInteger(
        hGlobal, KEY_ENABLE_V4COMPAT, DEFAULT_ENABLE_V4COMPAT);

    g_GlobalSettings.stUndoOnStop = GetInteger(
        hGlobal, KEY_UNDO_ON_STOP, DEFAULT_UNDO_ON_STOP);

    if (hGlobal != INVALID_HANDLE_VALUE) {
        RegCloseKey(hGlobal);
    }

    // Read interface settings from the registry
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, KEY_INTERFACES, 0, KEY_QUERY_VALUE,
                     &hInterfaces) == NO_ERROR) {
        // For each interface in the registry
        for (i=0; ; i++) {
            dwSize = sizeof(pwszAdapterName) / sizeof(WCHAR);
            dwErr = RegEnumKeyEx(hInterfaces, i, pwszAdapterName, &dwSize,
                                 NULL, NULL, NULL, NULL);
            if (dwErr != NO_ERROR) {
                break;
            }

            // Find settings
            pIfSettings = FindInterfaceSettings(pwszAdapterName, 
                                                g_pInterfaceSettingsList);
            if (pIfSettings) {
                // Read interface settings
                (VOID) RegOpenKeyEx(
                    hInterfaces, pwszAdapterName, 0, KEY_QUERY_VALUE, &hIf);

                pIfSettings->stEnableRouting = GetInteger(
                    hIf, KEY_ENABLE_ROUTING, DEFAULT_ENABLE_ROUTING);

                if (hIf != INVALID_HANDLE_VALUE) {
                    RegCloseKey(hIf);
                }
            }
        }
        RegCloseKey(hInterfaces);
    }

    Update6to4State();
    
    Update6over4State(State6over4);

    UpdateV4CompatState(StateV4Compat);

    if (!QueueUpdateGlobalPortState(NULL)) {
        Trace0(SOCKET, L"QueueUpdateGlobalPortState failed");
    }

    IsatapConfigurationChangeNotification();
    
#ifdef TEREDO    
    TeredoConfigurationChangeNotification();
#endif // TEREDO
    
    TraceLeave("OnConfigChange");
    LEAVE_API();

    return NO_ERROR;
}

////////////////////////////////////////////////////////////////
// Startup/Shutdown-related functions
////////////////////////////////////////////////////////////////

// Start the IPv6 helper service.
//
// To prevent the SCM from marking the service as hung, we periodically update
// our status, indicating that we are making progress but need more time.
//
// Called by: OnStartup
DWORD
StartHelperService()
{
    DWORD   dwErr;
    WSADATA wsaData;
    
    SetHelperServiceStatus(SERVICE_START_PENDING, NO_ERROR);
    
    IncEventCount("StartHelperService");

    g_stService = ENABLED;

    //
    // Initialize Winsock.
    //

    if (WSAStartup(MAKEWORD(2, 0), &wsaData)) {
        Trace0(ERR, _T("WSAStartup failed\n"));
        return GetLastError();
    }

    if (!InitIPv6Library()) {
        dwErr = GetLastError();
        Trace1(ERR, _T("InitIPv6Library failed with error %d"), dwErr);
        return dwErr;
    }

    dwErr = InitEvents();
    if (dwErr) {
        return dwErr;
    }

    // Initialize the "old set" of config settings to the defaults
    dwErr = InitializeGlobalInfo();
    if (dwErr) {
        return dwErr;
    }

    // Initialize the "old set" of interfaces (IPv4 addresses) to be empty
    dwErr = InitializeInterfaces();
    if (dwErr) {
        return dwErr;
    }

    // Initialize the "old set" of relays to be empty
    dwErr = InitializeRelays();
    if (dwErr) {
        return dwErr;
    }

    // Initialize the TCP proxy port list
    InitializePorts();

    // Initialize ISATAP
    SetHelperServiceStatus(SERVICE_START_PENDING, NO_ERROR);
    dwErr = IsatapInitialize();
    if (dwErr) {
        return dwErr;
    }
    
#ifdef TEREDO    
    // Initialize Teredo
    SetHelperServiceStatus(SERVICE_START_PENDING, NO_ERROR);
    dwErr = TeredoInitializeGlobals();
    if (dwErr) {
        return dwErr;
    }
#endif // TEREDO
    
    // Process a config change event
    SetHelperServiceStatus(SERVICE_START_PENDING, NO_ERROR);
    dwErr = OnConfigChange();
    if (dwErr) {
        return dwErr;
    }
    
    // Request IPv4 route change notifications.
    SetHelperServiceStatus(SERVICE_START_PENDING, NO_ERROR);
    StartRouteChangeNotification();
    
    // Process an IPv4 address change event.
    // This will also schedule a resolution timer expiration if needed.
    SetHelperServiceStatus(SERVICE_START_PENDING, NO_ERROR);
    dwErr = OnChangeInterfaceInfo(NULL, FALSE);
    if (dwErr) {
        return dwErr;
    }
    
    // Request IPv6 address change notifications.
    SetHelperServiceStatus(SERVICE_START_PENDING, NO_ERROR);
    dwErr = StartIpv6AddressChangeNotification();
    if (dwErr) {
        return dwErr;
    }
    
    SetHelperServiceStatus(SERVICE_RUNNING, NO_ERROR);
    return NO_ERROR;
}

/////////////////////////////////////////////////////////////////////////////
// Stop the IPv6 helper service.  Since this is called with the global lock,
// we're guaranteed this won't be called while another 6to4 operation
// is in progress.  However, another thread may be blocked waiting for
// the lock, so we set the state to stopped and check it in all other
// places after getting the lock.
//
// Called by: OnStop
VOID
StopHelperService(
    IN DWORD Error
    )
{
    SetHelperServiceStatus(SERVICE_STOP_PENDING, Error);
    
    g_stService = DISABLED;

    // We do these in the opposite order from Start6to4

#ifdef TEREDO    
    // Uninitialize Teredo
    TeredoUninitializeGlobals();
#endif // TEREDO
    
    // Uninitialize ISATAP
    IsatapUninitialize();
    
    // Stop proxying
    UninitializePorts();

    // Stop the resolution timer and free resources
    UninitializeRelays();

    // Cancel the IPv4 address change request and free resources
    // Also, stop being a router if we are one.
    UninitializeInterfaces();

    // Free settings resources
    UninitializeGlobalInfo();

    UninitIPv6Library();

    DecEventCount("StopHelperService");
}


////////////////////////////////////////////////////////////
// 6to4 Specific Code
////////////////////////////////////////////////////////////

DWORD
__inline
Configure6to4Address(
    IN BOOL Delete,
    IN PSOCKADDR_IN Ipv4Address
    )
{
    SOCKADDR_IN6 Ipv6Address;
    
    if ((GetIPv4Scope(Ipv4Address->sin_addr.s_addr) != IPV4_SCOPE_GLOBAL)) {
        return NO_ERROR;
    }
        
    Make6to4Address(&Ipv6Address, Ipv4Address);
    return ConfigureAddressUpdate(
        SIX_TO_FOUR_IFINDEX,
        &Ipv6Address,
        Delete ? 0 : INFINITE_LIFETIME,
        ADE_UNICAST, PREFIX_CONF_WELLKNOWN, IID_CONF_LL_ADDRESS);
}


VOID
PreDelete6to4Address(
    IN LPSOCKADDR_IN Ipv4Address,
    IN PIF_LIST InterfaceList,
    IN STATE OldRoutingState
    )
{
    ULONG i;
    SUBNET_CONTEXT Subnet;
    PIF_INFO Interface;

    if ((g_GlobalState.st6to4State != ENABLED) ||
        (GetIPv4Scope(Ipv4Address->sin_addr.s_addr) != IPV4_SCOPE_GLOBAL)) {
        return;
    }
        
    if (OldRoutingState != ENABLED) {
        return;
    }

    //
    // Disable the subnet routes on each private interface.
    // This will generate RAs that have a zero lifetime
    // for the subnet prefixes.
    //
    Subnet.V4Addr = Ipv4Address->sin_addr;
    Subnet.Publish = TRUE;
    Subnet.ValidLifetime = Subnet.PreferredLifetime = 0;

    for (i=0; i<InterfaceList->ulNumInterfaces; i++) {
        Interface = &InterfaceList->arrIf[i];
        if (Interface->stRoutingState != ENABLED) {
            continue;
        }

        Unconfigure6to4Subnets(Interface->ulIPv6IfIndex, &Subnet);
    }
}


VOID
Delete6to4Address(
    IN LPSOCKADDR_IN Ipv4Address,
    IN PIF_LIST InterfaceList,
    IN STATE OldRoutingState
    )
{
    SOCKADDR_IN6 AnycastAddress;
    ULONG i;
    PIF_INFO Interface;
    SUBNET_CONTEXT Subnet;

    if ((g_GlobalState.st6to4State != ENABLED) ||
        (GetIPv4Scope(Ipv4Address->sin_addr.s_addr) != IPV4_SCOPE_GLOBAL)) {
        return;
    }
    
    // Delete the 6to4 address from the stack
    (VOID) Configure6to4Address(TRUE, (PSOCKADDR_IN) Ipv4Address);
    
    if (OldRoutingState != ENABLED) {
        return;
    }    

    Make6to4AnycastAddress(&AnycastAddress, Ipv4Address);
    (VOID) ConfigureAddressUpdate(
        SIX_TO_FOUR_IFINDEX, &AnycastAddress, 0,
        ADE_ANYCAST, PREFIX_CONF_WELLKNOWN, IID_CONF_WELLKNOWN);

    // Remove subnets from all routing interfaces
    Subnet.V4Addr = Ipv4Address->sin_addr;
    Subnet.Publish = FALSE;
    Subnet.ValidLifetime = Subnet.PreferredLifetime = 0;    

    for (i = 0; i < InterfaceList->ulNumInterfaces; i++) {
        Interface = &InterfaceList->arrIf[i];
        if (Interface->stRoutingState != ENABLED) {
            continue;
        }
    
        Unconfigure6to4Subnets(Interface->ulIPv6IfIndex, &Subnet);
    }
}


VOID
Add6to4Address(
    IN LPSOCKADDR_IN Ipv4Address,
    IN PIF_LIST InterfaceList,
    IN STATE OldRoutingState
    )
{
    DWORD Error;
    SOCKADDR_IN6 AnycastAddress;
    ULONG i;
    PIF_INFO Interface;
    SUBNET_CONTEXT Subnet;

    if ((g_GlobalState.st6to4State != ENABLED) ||
        (GetIPv4Scope(Ipv4Address->sin_addr.s_addr) != IPV4_SCOPE_GLOBAL)) {
        return;
    }
    
    // Add a 6to4 address.
    Error = Configure6to4Address(FALSE, (PSOCKADDR_IN) Ipv4Address);
    if (Error != NO_ERROR) {
        return;
    }

    
    if (OldRoutingState != ENABLED) {
        return;
    }
    
    Make6to4AnycastAddress(&AnycastAddress, Ipv4Address);    
    Error = ConfigureAddressUpdate(
        SIX_TO_FOUR_IFINDEX, &AnycastAddress, INFINITE_LIFETIME,
        ADE_ANYCAST, PREFIX_CONF_WELLKNOWN, IID_CONF_WELLKNOWN);
    if (Error != NO_ERROR) {
        return;
    }

    // Add subnets to all routing interfaces
    for (i = 0; i < InterfaceList->ulNumInterfaces; i++) {
        Interface = &InterfaceList->arrIf[i];
        if (Interface->stRoutingState != ENABLED) {
            continue;
        }
    
        Subnet.V4Addr = Ipv4Address->sin_addr;
        Subnet.Publish = TRUE;
        Subnet.ValidLifetime = 2 * HOURS;
        Subnet.PreferredLifetime = 30 * MINUTES;
        Configure6to4Subnets(Interface->ulIPv6IfIndex, &Subnet);
    }
}


VOID
PreDelete6to4Routes(
    VOID
    )
{
    if ((g_GlobalState.st6to4State != ENABLED) ||
        (g_GlobalState.stRoutingState != ENABLED) ||
        (g_st6to4State != ENABLED)) {
        return;
    }
        
    //
    // We were acting as a router and were publishing the 6to4 route, give the
    // route a zero lifetime and continue to publish it until we have disabled
    // routing.  This allows the last RA to go out with the prefix.
    //
    (VOID) ConfigureRouteTableUpdate(
        &SixToFourPrefix, 16, SIX_TO_FOUR_IFINDEX, &in6addr_any,
        TRUE,                   // Publish
        TRUE,                   // Immortal
        0, 0, 0, 0);
        
    //
    // Do the same for the v4-compatible address route (if enabled).
    //
    if (g_GlobalSettings.stEnableV4Compat == ENABLED) {
        (VOID) ConfigureRouteTableUpdate(
            &in6addr_any, 96, V4_COMPAT_IFINDEX, &in6addr_any,
            TRUE,               // Publish
            TRUE,               // Immortal
            0, 0, 0, 0);
    }
}


VOID
Update6to4Routes(
    VOID
    )
{
    BOOL Delete;

    //
    // CAVEAT: We might still end up trying to add a route that exists,
    // or delete one that doesn't.  But this should be harmless.
    //
    
    //
    // Create/Delete the route for the 6to4 prefix.
    // This route causes packets sent to 6to4 addresses
    // to be encapsulated and sent to the extracted v4 address.
    //
   Delete = (Get6to4State() != ENABLED) || (g_st6to4State != ENABLED);

   (VOID) ConfigureRouteTableUpdate(
        &SixToFourPrefix, 16, SIX_TO_FOUR_IFINDEX, &in6addr_any,
        !Delete,                // Publish
        !Delete,                // Immortal
        Delete ? 0 : 2 * HOURS,  // Valid lifetime.
        Delete ? 0 : 30 * MINUTES, // Preferred lifetime.
        0, SIXTOFOUR_METRIC);

    //
    // Create/Delete the v4-compatible address route.
    //
    Delete |= (g_GlobalSettings.stEnableV4Compat != ENABLED);
    
    (VOID) ConfigureRouteTableUpdate(
        &in6addr_any, 96, V4_COMPAT_IFINDEX, &in6addr_any,
        !Delete,                // Publish
        !Delete,                // Immortal
        Delete ? 0 : 2 * HOURS, // Valid lifetime.
        Delete ? 0 : 30 * MINUTES, // Preferred lifetime.
        0, SIXTOFOUR_METRIC);
}


VOID
Start6to4(
    VOID
    )
{
    int i;

    ASSERT(g_GlobalState.st6to4State == DISABLED);

    for (i = 0; i < g_pIpv4AddressList->iAddressCount; i++) {
        (VOID) Configure6to4Address(
            FALSE, (PSOCKADDR_IN) g_pIpv4AddressList->Address[i].lpSockaddr);
    }
    
    Update6to4Routes();

    UpdateGlobalRoutingState();

    UpdateGlobalResolutionState();

    g_GlobalState.st6to4State = ENABLED;    
}


VOID
Stop6to4(
    VOID
    )
{
    int i;
    
    ASSERT(g_GlobalState.st6to4State == ENABLED);

    PreDelete6to4Routes();

    if (PreUpdateGlobalRoutingState()) {
        Sleep(2000);
    }

    for (i = 0; i < g_pIpv4AddressList->iAddressCount; i++) {
        (VOID) Configure6to4Address(
            TRUE, (PSOCKADDR_IN) g_pIpv4AddressList->Address[i].lpSockaddr);
    }    

    Update6to4Routes();

    UpdateGlobalRoutingState();

    UpdateGlobalResolutionState();

    g_GlobalState.st6to4State = DISABLED;
}


VOID
Refresh6to4(
    VOID
    )
{
    ASSERT(g_GlobalState.st6to4State == ENABLED);
    
    if (PreUpdateGlobalRoutingState()) {
        Sleep(2000);
    }
    UpdateGlobalRoutingState();

    UpdateGlobalResolutionState();    
}


VOID
Update6to4State(
    VOID
    )
{
    //
    // Start / Reconfigure / Stop.
    //
    if (Get6to4State() == ENABLED) {
        if (g_GlobalState.st6to4State == ENABLED) {
            Refresh6to4();
        } else {
            Start6to4();
        }
    } else {
        if (g_GlobalState.st6to4State == ENABLED) {
            Stop6to4();
        }
    }
}


VOID
RequirementChangeNotification(
    IN BOOL Required
    )
/*++

Routine Description:

    Process a possible requirement change notification.

Arguments:

    Required - Whether the 6to4 service is required for global connectivity.
    
Return Value:

    None.
    
Caller LOCK: API.

--*/
{
    if (g_b6to4Required != Required) {
        g_b6to4Required = Required;
        Update6to4State();
    }
}


VOID
UpdateServiceRequirements(
    IN PIP_ADAPTER_ADDRESSES Adapters
    )
{
    BOOL Require6to4 = TRUE, RequireTeredo = TRUE;
    
    GUID PrivateLan;
    BOOL IcsEnabled = (RasQuerySharedPrivateLan(&PrivateLan) == NO_ERROR);

    PIP_ADAPTER_ADDRESSES Next;
    PIP_ADAPTER_UNICAST_ADDRESS Address;
    WCHAR Guid[MAX_ADAPTER_NAME_LENGTH];
    PSOCKADDR_IN6 Ipv6;
    
    
    
    for (Next = Adapters; Next != NULL; Next = Next->Next) {
        //
        // Disregard disconnected interfaces.
        //
        if (Next->OperStatus != IfOperStatusUp) {
            continue;
        }

#ifdef TEREDO
        //
        // Disregard the Teredo interface.
        //
        ConvertOemToUnicode(Next->AdapterName, Guid, MAX_ADAPTER_NAME_LENGTH);
        if (TeredoInterface(Guid)) {
            ASSERT(Next->IfType == IF_TYPE_TUNNEL);
            continue;
        }
#else
        DBG_UNREFERENCED_LOCAL_VARIABLE(Guid);
#endif // TEREDO

        for (Address = Next->FirstUnicastAddress;
             Address != NULL;
             Address = Address->Next) {
            //
            // Consider only preferred global IPv6 addresses.
            //
            if (Address->Address.lpSockaddr->sa_family != AF_INET6) {
                continue;
            }
            
            if (Address->DadState != IpDadStatePreferred) {
                continue;
            }

            Ipv6 = (PSOCKADDR_IN6) Address->Address.lpSockaddr;
            if (TeredoIpv6GlobalAddress(&(Ipv6->sin6_addr))) {
                //
                // Since this is not the Teredo interface, and it has a global
                // IPv6 address, Teredo's not required for global connectivity.
                //
                RequireTeredo = FALSE;
                if (Next->Ipv6IfIndex != SIX_TO_FOUR_IFINDEX) {
                    //
                    // Since this is not the 6to4 interface either, and it has
                    // a global IPv6 address, 6to4's not required for global
                    // connectivity.
                    //
                    Require6to4 = FALSE;
                }
            }
            
            if (!Require6to4) {
                ASSERT(!RequireTeredo);
                goto Done;
            }
        }
    }
    
Done:
    //
    // 1. ICS requires 6to4 for advertising a prefix on the private LAN,
    // at least until it implements prefix-delegation or RA proxy.
    //
    // 2. As a result of this advertisement, ICS will configure 6to4 addresses
    // on its private interface as well.  If the service should then disable
    // 6to4 because of the presence of these global addresses on the private
    // interface, it would lose these very addresses it was relying upon.  The
    // service would notice that it has no global IPv6 addresses and be forced
    // to enable 6to4.  Hence it will end up in an infinite loop, cycling 6to4
    // between enabled and disabled states.
    //
    // To circumvent these two issues, we always enable 6to4 on an ICS box.
    //
    RequirementChangeNotification(Require6to4 || IcsEnabled);
#ifdef TEREDO    
    TeredoRequirementChangeNotification(RequireTeredo);
#endif // TEREDO    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\6to4svc\client.c ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

    client.c

Abstract:

    This module contains the teredo client implementation.

Author:

    Mohit Talwar (mohitt) Mon Oct 22 15:17:20 2001

Environment:

    User mode only.

--*/

#include "precomp.h"
#pragma hdrstop


TEREDO_CLIENT_STATE TeredoClient;


TEREDO_PACKET_IO_COMPLETE TeredoClientReadComplete;
TEREDO_PACKET_IO_COMPLETE TeredoClientWriteComplete;
TEREDO_PACKET_IO_COMPLETE TeredoClientBubbleComplete;
TEREDO_PACKET_IO_COMPLETE TeredoClientReceiveComplete;
TEREDO_PACKET_IO_COMPLETE TeredoClientTransmitComplete;
TEREDO_PACKET_IO_COMPLETE TeredoClientMulticastComplete;

VOID TeredoTransmitMulticastBubble( VOID );

BOOL
TeredoAddressPresent(
    VOID
    )
/*++

Routine Description:
    
    Determine whether an IPv6 tunnel interface has a teredo address.
    The address must have been configured from a router advertisement.
    
Arguments:

    None.
    
Return Value:

    TRUE if present, FALSE if not.

--*/ 
{
    DWORD Error;
    ULONG Bytes;
    PIP_ADAPTER_ADDRESSES Adapters, Next;
    PIP_ADAPTER_UNICAST_ADDRESS Address;
    WCHAR Guid[MAX_ADAPTER_NAME_LENGTH];
    BOOL Found = FALSE;
    
    TraceEnter("TeredoAddressPresent");
    
    //
    // 10 Adapters, each with 3 strings and 4 unicast addresses.
    // This would usually be more than enough!
    //
    Bytes = 10 * (
        sizeof(IP_ADAPTER_ADDRESSES) +
        2 * MAX_ADAPTER_NAME_LENGTH + MAX_ADAPTER_DESCRIPTION_LENGTH +
        4 * (sizeof(IP_ADAPTER_UNICAST_ADDRESS) + sizeof(SOCKADDR_IN6)));
    Adapters = MALLOC(Bytes);
    if (Adapters == NULL) {
        return FALSE;
    }

    do {
        Error = GetAdaptersAddresses(
            AF_INET6,
            GAA_FLAG_SKIP_FRIENDLY_NAME |
            GAA_FLAG_SKIP_DNS_SERVER |
            GAA_FLAG_SKIP_MULTICAST |
            GAA_FLAG_SKIP_ANYCAST,
            NULL, Adapters, &Bytes);
        if (Error == ERROR_BUFFER_OVERFLOW) {
            Next = REALLOC(Adapters, Bytes);
            if (Next != NULL) {
                Adapters = Next;
            } else {
                Error = ERROR_OUTOFMEMORY;
            }
        }
    } while (Error == ERROR_BUFFER_OVERFLOW);

    if (Error != NO_ERROR) {
        goto Bail;
    }
        
    for (Next = Adapters; Next != NULL; Next = Next->Next) {
        //
        // Disregard non-Teredo interfaces.
        //
        ConvertOemToUnicode(Next->AdapterName, Guid, MAX_ADAPTER_NAME_LENGTH);
        if (_wcsicmp(TeredoClient.Io.TunnelInterface, Guid) != 0) {
            continue;
        }
        ASSERT(Next->IfType == IF_TYPE_TUNNEL);

        //
        // Bail if the interface is disconnected.
        //
        if (Next->OperStatus != IfOperStatusUp) {
            break;
        }
        
        for (Address = Next->FirstUnicastAddress;
             Address != NULL;
             Address = Address->Next) {
            if ((Address->PrefixOrigin != PREFIX_CONF_RA) ||
                (Address->DadState != IpDadStatePreferred)) {
                continue;
            }
                    
            if (TeredoEqualPrefix(
                &(((PSOCKADDR_IN6) Address->Address.lpSockaddr)->sin6_addr),
                &(TeredoClient.Ipv6Prefix))) {
                Found = TRUE;
                goto Bail;
            }
        }
    }

Bail:
    FREE(Adapters);
    return Found;
}


VOID
CALLBACK
TeredoClientIoCompletionCallback(
    IN DWORD ErrorCode,
    IN DWORD Bytes,
    IN LPOVERLAPPED Overlapped
    )
/*++

Routine Description:

    Callback routine for I/O completion on TUN interface device or UDP socket.

Arguments:

    ErrorCode - Supplies the I/O completion status.

    Bytes - Supplies the number of bytes transferred.

    Overlapped - Supplies the completion context.
    
Return Value:

    None.

--*/
{
    static CONST PTEREDO_PACKET_IO_COMPLETE Callback[] =
    {
        TeredoClientReadComplete,
        TeredoClientWriteComplete,
        TeredoClientBubbleComplete,
        NULL,                   // No bouncing...
        TeredoClientReceiveComplete,
        TeredoClientTransmitComplete,
        TeredoClientMulticastComplete,        
    };
    PTEREDO_PACKET Packet = Cast(
        CONTAINING_RECORD(Overlapped, TEREDO_PACKET, Overlapped),
        TEREDO_PACKET);

    ASSERT(Packet->Type != TEREDO_PACKET_BOUNCE);
    
    //
    // This completion function usually posts the packet for another I/O.
    // Since we are called by a non-I/O worker thread, asynchronous I/O
    // requests posted here might terminate when this thread does.  This
    // is rare enough that we don't special case it.  Moreover, we only
    // make best effort guarantees to the upper layer!
    //
    (*Callback[Packet->Type])(ErrorCode, Bytes, Packet);
}


VOID
CALLBACK
TeredoClientTimerCallback(
    IN PVOID Parameter,
    IN BOOLEAN TimerOrWaitFired
    )
/*++

Routine Description:

    Callback routine for TeredoClient.Timer expiration.
    The timer is active in the probe and qualified states.
    
Arguments:

    Parameter, TimerOrWaitFired - Ignored.
    
Return Value:

    None.

--*/ 
{
    ENTER_API();

    if (TeredoClient.State == TEREDO_STATE_PROBE) {
        if (TeredoClient.RestartQualifiedTimer) {
            //
            // Probe -> Qualified.
            //
            if (TeredoAddressPresent()) {
                //
                // The stack has validated and processed an RA.
                //
                TeredoQualifyClient();
            } else {
                //
                // The stack has not received any valid RA.
                //
                TeredoStopClient();
            }
        } else {
            //
            // Probe -> Offline.
            //
            TeredoStopClient();
        }
    } else {
        if (TeredoClient.RestartQualifiedTimer) {
            //
            // Qualified -> Qualified.
            //
            TeredoQualifyClient();
        } else {
            //
            // Qualified -> Probe.
            //
            TeredoProbeClient();
        }
    }    

    LEAVE_API();
}


VOID
CALLBACK
TeredoClientTimerCleanup(
    IN PVOID Parameter,
    IN BOOLEAN TimerOrWaitFired
    )
/*++

Routine Description:

    Callback routine for TeredoClient.Timer deletion.

    Deletion is performed asynchronously since we acquire a lock in
    the callback function that we hold when deleting the timer.

Arguments:

    Parameter, TimerOrWaitFired - Ignored.
    
Return Value:

    None.

--*/ 
{
    TeredoDereferenceClient();
}


VOID
TeredoClientAddressDeletionNotification(
    IN IN_ADDR Address
    )
/*++
    
Routine Description:

    Process an address deletion request.
    
Arguments:

    Address - Supplies the address that was deleted.
    
Return Value:

    None.
    
Caller LOCK: API.

--*/
{
    if (!IN4_ADDR_EQUAL(Address, TeredoClient.Io.SourceAddress.sin_addr)) {
        return;
    }

    //
    // Refresh the socket state (the socket bound to SourceAddress).
    //
    if (TeredoRefreshSocket(&(TeredoClient.Io)) != NO_ERROR) {
        //
        // [Probe | Qualified] -> Offline.
        //
        TeredoStopClient();
        return;
    }

    if (IN4_ADDR_EQUAL(
        TeredoClient.Io.SourceAddress.sin_addr,
        TeredoClient.Io.ServerAddress.sin_addr)) {
        //
        // [Probe | Qualified] -> Offline.
        //
        TeredoStopClient();
        return;        
    }
    
    //
    // [Probe | Qualified] -> Probe.
    //
    TeredoProbeClient();
}


VOID
TeredoClientRefreshIntervalChangeNotification(
    VOID
    )
/*++
    
Routine Description:

    Process a refresh interval change request.
    
Arguments:

    None.
    
Return Value:

    None.
    
Caller LOCK: API.

--*/
{
    if (TeredoClient.RefreshInterval == TeredoClientRefreshInterval) {
        return;
    }

    TeredoClient.RefreshInterval = TeredoClientRefreshInterval;
    if (TeredoClient.State == TEREDO_STATE_QUALIFIED) {
        //
        // Refresh interval has been updated.
        // Qualified -> Qualified.
        //
        TeredoQualifyClient();
    }
}


VOID
TeredoStartClient(
    VOID
    )
/*++

Routine Description:

    Attempt to start the teredo service at the client.

    Events / Transitions
    ServiceStart            Offline -> Probe.
    ServiceEnable           Offline -> Probe.
    AdapterArrival          Offline -> Probe.
    AddressAddition         Offline -> Probe.

Arguments:

    None.

Return Value:

    None.

Caller LOCK: API.

--*/ 
{
    TraceEnter("TeredoStartClient");

    //
    // Can't have both the client and server on the same node.
    //
    if (TeredoServer.State != TEREDO_STATE_OFFLINE) {
        return;
    }

    //
    // Well, the service has already been started!
    //
    if (TeredoClient.State != TEREDO_STATE_OFFLINE) {
        return;
    }

    TeredoClient.State = TEREDO_STATE_PROBE;

    //
    // Start I/O processing.
    //
    if (TeredoStartIo(&(TeredoClient.Io)) != NO_ERROR) {
        goto Bail;
    }

    if (IN4_ADDR_EQUAL(
        TeredoClient.Io.SourceAddress.sin_addr,
        TeredoClient.Io.ServerAddress.sin_addr)) {
        goto Bail;
    }
    
    //
    // Start a one shot probe timer.
    //
    if (!CreateTimerQueueTimer(
            &(TeredoClient.Timer),
            NULL,
            TeredoClientTimerCallback,
            NULL,
            TEREDO_PROBE_INTERVAL * 1000, // in milliseconds.
            INFINITE_INTERVAL,
            0)) {
        goto Bail;
    }
    
    //
    // Obtain a reference on the teredo client for the running timer.
    //
    TeredoReferenceClient();

    return;

Bail:
    TeredoClient.State = TEREDO_STATE_OFFLINE;
    TeredoStopIo(&(TeredoClient.Io));
}


VOID
TeredoStopClient(
    VOID
    )
/*++

Routine Description:

    Stop the teredo service at the client.
    
    Events / Transitions   
    ProbeTimer              Probe -> Offline.
    ServiceStop             [Probe | Qualified] -> Offline.
    ServiceDisable          [Probe | Qualified] -> Offline.
    AdapterRemoval          [Probe | Qualified] -> Offline.
    AddressDeletion         [Probe | Qualified] -> Offline.

Arguments:

    None.

Return Value:

    None.

Caller LOCK: API.

--*/ 
{
    TraceEnter("TeredoStopClient");

    //
    // Well, the service was never started!
    //
    if (TeredoClient.State == TEREDO_STATE_OFFLINE) {
        return;
    }

    TeredoClient.State = TEREDO_STATE_OFFLINE;    

    TeredoClient.Ipv6Prefix = in6addr_any;
    
    TeredoClient.RestartQualifiedTimer = FALSE;
    DeleteTimerQueueTimer(
        NULL, TeredoClient.Timer, TeredoClient.TimerEvent);
    TeredoClient.Timer = NULL;
    
    TeredoStopIo(&(TeredoClient.Io));
    
    TeredoUninitializePeerSet();
}


VOID
TeredoProbeClient(
    VOID
    )
/*++

Routine Description:

    Probe the teredo service at the client.
    
    Events / Transitions   
    QualifiedTimer          Qualified -> Probe.
    AddressDeletion         [Probe | Qualified] -> Probe.

Arguments:

    None.

Return Value:

    None.

Caller LOCK: API.

--*/ 
{
    TraceEnter("TeredoProbeClient");
    
    TeredoClient.State = TEREDO_STATE_PROBE;
    
    //
    // Reconnect!
    //
    if (!ReconnectInterface(TeredoClient.Io.TunnelInterface)) {
        //
        // [Probe | Qualified] -> Offline.
        //
        TeredoStopClient();
        return;    
    }
    
    if (!ChangeTimerQueueTimer(
            NULL,
            TeredoClient.Timer,
            TEREDO_PROBE_INTERVAL * 1000, // in milliseconds.
            INFINITE_INTERVAL)) {
        TeredoStopClient();
        return;
    }

    TeredoClient.RestartQualifiedTimer = FALSE;
}


VOID
TeredoQualifyClient(
    VOID
    )
/*++

Routine Description:

    Qualify the teredo service at the client.
    
    Events / Transitions
    RouterAdvertisement     Probe -> Qualified.
    NatMappingRefresh       Qualified -> Qualified.
    RefreshIntervalChange   Qualified -> Qualified.
    
Arguments:

    None.

Return Value:

    None.

Caller LOCK: API.

--*/ 
{
    TraceEnter("TeredoQualifyClient");

    TeredoClient.State = TEREDO_STATE_QUALIFIED;
    
    if (!ChangeTimerQueueTimer(
            NULL,
            TeredoClient.Timer,
            TeredoClient.RefreshInterval * 1000, // in milliseconds.
            INFINITE_INTERVAL)) {
        //
        // [Probe | Qualified] -> Offline.
        //
        TeredoStopClient();
        return;
    }

    TeredoTransmitMulticastBubble();
    
    
    TeredoClient.RestartQualifiedTimer = FALSE;
}


DWORD
TeredoInitializeClient(
    VOID
    )
/*++

Routine Description:

    Initializes the client.
    
Arguments:

    None.

Return Value:

    NO_ERROR or failure code.

--*/ 
{
    DWORD Error;

    //
    // Obtain a reference on the teredo client for initialization.
    //
    TeredoClient.ReferenceCount = 1;

    TeredoClient.PeerHeap
        = TeredoClient.TimerEvent
        = TeredoClient.TimerEventWait
        = NULL;

    TeredoClient.BubbleTicks = 0;
    TeredoClient.BubblePosted = FALSE;

    TeredoInitializePacket(&(TeredoClient.Packet));
    TeredoClient.Packet.Type = TEREDO_PACKET_MULTICAST;
    TeredoClient.Packet.Buffer.len = sizeof(IP6_HDR);
    ASSERT(TeredoClient.Packet.Buffer.buf ==
           (PUCHAR) &(TeredoClient.Bubble));
    
    TeredoClient.Bubble.ip6_flow = 0;
    TeredoClient.Bubble.ip6_plen = 0;
    TeredoClient.Bubble.ip6_nxt = IPPROTO_NONE;
    TeredoClient.Bubble.ip6_hlim = IPV6_HOPLIMIT;
    TeredoClient.Bubble.ip6_vfc = IPV6_VERSION;
    // Peer->Bubble.ip6_src... Filled in when sending.
    TeredoClient.Bubble.ip6_dest = TeredoIpv6MulticastPrefix;

    //
    // Multicast bubble destination UDP port & IPv4 address.
    //
    TeredoParseAddress(
        &(TeredoClient.Bubble.ip6_dest),
        &(TeredoClient.Packet.SocketAddress.sin_addr),
        &(TeredoClient.Packet.SocketAddress.sin_port));
        
    Error = TeredoInitializeIo(
        &(TeredoClient.Io),
        TeredoClient.Packet.SocketAddress.sin_addr,
        TeredoReferenceClient,
        TeredoDereferenceClient,
        TeredoClientIoCompletionCallback);
    if (Error != NO_ERROR) {
        return Error;
    }

    TeredoClient.PeerHeap = HeapCreate(0, 0, 0);
    if (TeredoClient.PeerHeap == NULL) {
        Error = GetLastError();
        goto Bail;
    }

    TeredoClient.TimerEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (TeredoClient.TimerEvent == NULL) {
        Error = GetLastError();
        goto Bail;
    }
    
    if (!RegisterWaitForSingleObject(
            &(TeredoClient.TimerEventWait),
            TeredoClient.TimerEvent,
            TeredoClientTimerCleanup,
            NULL,
            INFINITE,
            0)) {
        Error = GetLastError();
        goto Bail;
    }
    
    TeredoClient.RestartQualifiedTimer = FALSE;
    
    TeredoClient.Time = TeredoGetTime();
    TeredoClient.State = TEREDO_STATE_OFFLINE;
    TeredoClient.Ipv6Prefix = in6addr_any;
    TeredoClient.RefreshInterval = TeredoClientRefreshInterval;
    TeredoClient.Timer = INVALID_HANDLE_VALUE;

    Error = TeredoInitializePeerSet();
    if (Error != NO_ERROR) {
        goto Bail;
    }

    IncEventCount("TeredoInitializeClient");

    return NO_ERROR;
    
Bail:
    TeredoCleanupIo(&(TeredoClient.Io));
        
    if (TeredoClient.PeerHeap != NULL) {
        HeapDestroy(TeredoClient.PeerHeap);
        TeredoClient.PeerHeap = NULL;
    }

    if (TeredoClient.TimerEventWait != NULL) {
        UnregisterWait(TeredoClient.TimerEventWait);
        TeredoClient.TimerEventWait = NULL;
    }

    if (TeredoClient.TimerEvent != NULL) {
        CloseHandle(TeredoClient.TimerEvent);
        TeredoClient.TimerEvent = NULL;
    }
    
    return Error;
}


VOID
TeredoUninitializeClient(
    VOID
    )
/*++

Routine Description:

    Uninitializes the client.  Typically invoked upon service stop.
    
Arguments:

    None.

Return Value:

    None.

--*/
{
    TeredoStopClient();
    TeredoDereferenceClient();
}


VOID
TeredoCleanupClient(
    VOID
    )
/*++

Routine Description:

    Cleans up the client after the last reference to it has been released.
    
Arguments:

    None.

Return Value:

    None.

--*/
{
    TeredoCleanupPeerSet();
    
    UnregisterWait(TeredoClient.TimerEventWait);
    TeredoClient.TimerEventWait = NULL;
    
    CloseHandle(TeredoClient.TimerEvent);
    TeredoClient.TimerEvent = NULL;

    HeapDestroy(TeredoClient.PeerHeap);
    TeredoClient.PeerHeap = NULL;

    TeredoCleanupIo(&(TeredoClient.Io));
        
    DecEventCount("TeredoCleanupClient");
}


VOID
TeredoTransmitMulticastBubble(
    VOID
    ) 
/*++

Routine Description:

    Transmit a teredo multicast bubble on the native link.

Arguments:

    None.
    
Return Value:

    None.
    
Caller LOCK: API.

--*/ 
{
    ASSERT(TeredoClient.State == TEREDO_STATE_QUALIFIED);

    if (TeredoClient.BubbleTicks == 0) {
        //
        // No multicast bubbles should be sent.
        //
        return;
    }

    if (--TeredoClient.BubbleTicks != 0) {
        //
        // Our time is not yet up!
        //
        return;
    }

    if (TeredoClient.BubblePosted == TRUE) {
        //
        // At most one outstanding multicast bubble is allowed!  Try later.
        //
        TeredoClient.BubbleTicks = 1;
        return;
    }
    
    //
    // Reset the timer.
    //
    TeredoClient.BubbleTicks = TEREDO_MULTICAST_BUBBLE_TICKS;
    
    //
    // Obtain a reference for the posted multicast bubble.
    //
    TeredoReferenceClient();
    
    TeredoClient.Bubble.ip6_src = TeredoClient.Ipv6Prefix;
    if (TeredoTransmitPacket(
        &(TeredoClient.Io), &(TeredoClient.Packet)) != NULL) {
        TeredoClientMulticastComplete(
            NO_ERROR, sizeof(IP6_HDR), &(TeredoClient.Packet));
    }
}


VOID
TeredoTransmitBubble(
    IN PTEREDO_PEER Peer
    ) 
/*++

Routine Description:

    Transmit a teredo bubble to a peer.

Arguments:

    Peer - Supplies the peer of interest.
    
Return Value:

    None.
    
--*/ 
{
    if (TIME_GREATER(
            Peer->LastTransmit,
            (TeredoClient.Time - TEREDO_BUBBLE_INTERVAL))) {
        //
        // Rate limit bubble transmission.
        //
        return;
    }
        
    if (TIME_GREATER(
            (TeredoClient.Time - TEREDO_BUBBLE_THRESHHOLD),
            Peer->LastReceive) &&
        TIME_GREATER(
            Peer->LastTransmit,
            (TeredoClient.Time - TEREDO_SLOW_BUBBLE_INTERVAL))) {
        //
        // If the peer refuses to respond, drop rate (to once in 5 minutes).
        // 
        return;
    }

    if (InterlockedExchange(&(Peer->BubblePosted), TRUE)) {
        //
        // At most one outstanding bubble is allowed!
        //
        return;
    }

    //
    // Obtain a reference for the posted bubble.
    //
    TeredoReferencePeer(Peer);
    
    Peer->LastTransmit = TeredoClient.Time;
    Peer->BubbleCount++;
    Peer->Bubble.ip6_src = TeredoClient.Ipv6Prefix;
    if (TeredoTransmitPacket(
        &(TeredoClient.Io), &(Peer->Packet)) != NULL) {
        TeredoClientBubbleComplete(
            NO_ERROR, sizeof(IP6_HDR), &(Peer->Packet));
    }
}


BOOL
TeredoReceiveRouterAdvertisement(
    IN PTEREDO_PACKET Packet,
    IN ULONG Bytes
    )
/*++

Routine Description:

    Process the router advertisement packet received on the UDP socket.
    
Arguments:

    Packet - Supplies the packet that was received.

    Bytes - Supplies the length of the packet.
    
Return Value:

    TRUE if the packet should be forwarded to the stack, FALSE otherwise.

--*/ 
{
    PUCHAR Buffer = Packet->Buffer.buf;
    ICMPv6Header *Icmp6;
    UCHAR Type;
    ULONG Length;
    NDOptionPrefixInformation *Prefix = NULL;
    
    if (!IN4_SOCKADDR_EQUAL(
        &(Packet->SocketAddress), &(TeredoClient.Io.ServerAddress))) {
        //
        // Only the teredo server is allowed to send an RA.
        //
        return FALSE;
    }    

    //
    // Parse up until the ICMPv6 header for the router advertisement.
    //
    Icmp6 = TeredoParseIpv6Headers(Buffer, Bytes);
    if (Icmp6 == NULL) {
        return FALSE;
    }
            
    if ((Icmp6->Type != ICMPv6_ROUTER_ADVERT) || (Icmp6->Code != 0)) {
        return FALSE;
    }
    Buffer = (PUCHAR) (Icmp6 + 1);
    Bytes -= (ULONG) (Buffer - Packet->Buffer.buf);
    
    //
    // Parse the rest of the router advertisement header.
    //
    if (Bytes < sizeof(NDRouterAdvertisement)) {
        return FALSE;
    }
    Buffer += sizeof(NDRouterAdvertisement);
    Bytes -= sizeof(NDRouterAdvertisement);
    
    while (Bytes != 0) {
        //
        // Parse TLV options.
        //
        if (Bytes < 8) {
            return FALSE;
        }
        
        Type = Buffer[0];
        Length = (Buffer[1] * 8);        
        if ((Length == 0) || (Bytes < Length)) {
            return FALSE;
        }
        
        if (Type == ND_OPTION_PREFIX_INFORMATION) {
            if (Prefix != NULL) {
                //
                // There should only be one advertised prefix.
                //
                return FALSE;
            }            

            if (Length != sizeof(NDOptionPrefixInformation)) {
                return FALSE;
            }
            Prefix = (NDOptionPrefixInformation *) Buffer;

            if (!TeredoValidAdvertisedPrefix(
                &(Prefix->Prefix), Prefix->PrefixLength)) {
                return FALSE;
            }
        }
        
        Buffer += Length;
        Bytes -= Length;
    }

    //
    // We have a valid router advertisement!
    // [Probe | Qualified] -> Qualified.
    //
    if (!IN6_ADDR_EQUAL(&(TeredoClient.Ipv6Prefix), &(Prefix->Prefix))) {
        //
        // We've either created a new IPv6 address or changed the existing one.
        // Transmit a multicast bubble as soon as the client qualifies.
        //
        TeredoClient.BubbleTicks =
            (TEREDO_MULTICAST_BUBBLE_TICKS != 0) ? 1 : 0;
    }    
        
    TeredoClient.Ipv6Prefix = Prefix->Prefix;
    TeredoClient.RestartQualifiedTimer = TRUE;

    return TRUE;
}

            
BOOL
TeredoClientReceiveData(
    IN PTEREDO_PACKET Packet
    )
/*++

Routine Description:

    Process the data packet received on the UDP socket.
    
Arguments:

    Packet - Supplies the packet that was received.

Return Value:

    TRUE if the packet should be forwarded to the stack, FALSE otherwise.

--*/ 
{
    PIP6_HDR Ipv6;
    IN_ADDR Address;
    USHORT Port;
    PTEREDO_PEER Peer;

    if (IN6_IS_ADDR_UNSPECIFIED(&(TeredoClient.Ipv6Prefix))) {
        //
        // The client hasn't been qualified ever!
        //
        return FALSE;
    }

    if (IN4_SOCKADDR_EQUAL(
        &(Packet->SocketAddress), &(TeredoClient.Io.ServerAddress))) {
        //
        // The client received the packet from the teredo server.
        //
        if (TeredoClient.State == TEREDO_STATE_QUALIFIED) {
            //
            // The NAT mapping has been refreshed.
            // NOTE: Since we don't acquire the API lock here, there is a small
            // chance that we have now transitioned to PROBE state.  If so,
            // setting the flag to TRUE below will mistakenly cause us to
            // re-enter the qualified state.  However that's quite harmless.
            //
            TeredoClient.RestartQualifiedTimer = TRUE;
        }
        return TRUE;
    }

    Ipv6 = (PIP6_HDR) Packet->Buffer.buf;

    if (!TeredoServicePrefix(&(Ipv6->ip6_src))) {
        //
        // The IPv6 source address should be a valid teredo address.
        //
        return FALSE;
    }

    TeredoParseAddress(&(Ipv6->ip6_src), &Address, &Port);
    if (!TeredoIpv4GlobalAddress((PUCHAR) &Address)) {
        //
        // The IPv4 source address should be global scope.
        //
        return FALSE;
    }
        
    if (!IN4_ADDR_EQUAL(Packet->SocketAddress.sin_addr, Address) ||
        (Packet->SocketAddress.sin_port != Port)) {
        //
        // Should have been constructed by the *right* teredo peer.
        //
        return FALSE;
    }

    Peer = TeredoFindOrCreatePeer(&(Ipv6->ip6_src));
    if (Peer != NULL) {
        Peer->LastReceive = TeredoClient.Time;
        TeredoTransmitBubble(Peer);
        TeredoDereferencePeer(Peer);
    }

    return TRUE;    
}


VOID
TeredoClientReadComplete(
    IN DWORD Error,
    IN ULONG Bytes,
    IN PTEREDO_PACKET Packet
    )
/*++

Routine Description:

    Process a read completion on the TUN device.

--*/ 
{
    PIP6_HDR Ipv6;
    IN_ADDR Address;
    USHORT Port;
    PTEREDO_PEER Peer;
    
    if ((Error != NO_ERROR) || (Bytes < sizeof(IP6_HDR))) {
        //
        // Attempt to post the read again.
        // If we are going offline, the packet is destroyed in the attempt.
        //
        TeredoPostRead(&(TeredoClient.Io), Packet);
        return;
    }

    TraceEnter("TeredoClientReadComplete");

    TeredoClient.Time = TeredoGetTime();
    
    Ipv6 = (PIP6_HDR) Packet->Buffer.buf;

    //
    // Default to tunneling the packet to the teredo server.
    //
    Packet->SocketAddress = TeredoClient.Io.ServerAddress;
    
    if (TeredoServicePrefix(&(Ipv6->ip6_dest))) {
        //
        // If the IPv6 destination address is a teredo address,
        // the IPv4 destination address should be global scope.
        //
        TeredoParseAddress(&(Ipv6->ip6_dest), &Address, &Port);
        if (!TeredoIpv4GlobalAddress((PUCHAR) &Address)) {
            goto Bail;
        }
        
        Peer = TeredoFindOrCreatePeer(&(Ipv6->ip6_dest));
        if (Peer != NULL) {
            if (TIME_GREATER(
                    Peer->LastReceive,
                    (TeredoClient.Time - TEREDO_REFRESH_INTERVAL))) {
                //
                // Tunnel the packet directly to the peer.
                //
                Packet->SocketAddress.sin_addr = Address;
                Packet->SocketAddress.sin_port = Port;
                Peer->LastTransmit = TeredoClient.Time;
            } else {
                TeredoTransmitBubble(Peer);
            }
            TeredoDereferencePeer(Peer);
        }
    }

    Packet->Type = TEREDO_PACKET_TRANSMIT;
    Packet->Buffer.len = Bytes;
    if (TeredoTransmitPacket(&(TeredoClient.Io), Packet) == NULL) {
        return;
    }

Bail:    
    //
    // We are done processing this packet.
    //
    TeredoClientTransmitComplete(NO_ERROR, Bytes, Packet);
}


VOID
TeredoClientWriteComplete(
    IN DWORD Error,
    IN ULONG Bytes,
    IN PTEREDO_PACKET Packet
    )
/*++

Routine Description:

    Process a write completion on the TUN device.

--*/ 
{
    TraceEnter("TeredoClientWriteComplete");
        
    //
    // Attempt to post the receive again.
    // If we are going offline, the packet is destroyed in the attempt.
    //
    Packet->Type = TEREDO_PACKET_RECEIVE;
    Packet->Buffer.len = IPV6_TEREDOMTU;
    TeredoPostReceives(&(TeredoClient.Io), Packet);
}


VOID
TeredoClientBubbleComplete(
    IN DWORD Error,
    IN ULONG Bytes,
    IN PTEREDO_PACKET Packet
    )
/*++

Routine Description:

    Process a bubble transmit completion on the UDP socket.

--*/ 
{
    PTEREDO_PEER Peer = Cast(
        CONTAINING_RECORD(Packet, TEREDO_PEER, Packet), TEREDO_PEER);

    TraceEnter("TeredoClientBubbleComplete");
    
    Peer->BubblePosted = FALSE;
    TeredoDereferencePeer(Peer);
}


VOID
TeredoClientReceiveComplete(
    IN DWORD Error,
    IN ULONG Bytes,
    IN PTEREDO_PACKET Packet
    )
/*++

Routine Description:

    Process a receive completion on the UDP socket.

--*/ 
{
    PIP6_HDR Ipv6;
    BOOL Forward = FALSE;
    
    InterlockedDecrement(&(TeredoClient.Io.PostedReceives));
    
    if ((Error != NO_ERROR) || (Bytes < sizeof(IP6_HDR))) {
        //
        // Attempt to post the receive again.
        // If we are going offline, the packet is destroyed in the attempt.
        //
        TeredoPostReceives(&(TeredoClient.Io), Packet);
        return;
    }

    TraceEnter("TeredoClientReceiveComplete");

    TeredoClient.Time = TeredoGetTime();
        
    Ipv6 = (PIP6_HDR) Packet->Buffer.buf;

    if (IN6_IS_ADDR_LINKLOCAL(&(Ipv6->ip6_src)) ||
        IN6_IS_ADDR_LINKLOCAL(&(Ipv6->ip6_dest))) {
        //
        // This should be a valid router advertisement.  Note that only router
        // advertisement packets are accepted from/to link-local addresses.
        //
        Forward = TeredoReceiveRouterAdvertisement(Packet, Bytes);
    } else {
        //
        // This may be a packet of any other kind.  Note that the IPv6 stack
        // drops router advertisements with a non link-local source address.
        //
        Forward = TeredoClientReceiveData(Packet);
    }

    if (Forward) {
        Packet->Type = TEREDO_PACKET_WRITE;
        Packet->Buffer.len = Bytes;
        if (TeredoWritePacket(&(TeredoClient.Io), Packet) == NULL) {
            return;
        }
    }
    
    //
    // We are done processing this packet.
    //
    TeredoClientWriteComplete(NO_ERROR, Bytes, Packet);
}


VOID
TeredoClientTransmitComplete(
    IN DWORD Error,
    IN ULONG Bytes,
    IN PTEREDO_PACKET Packet
    )
/*++

Routine Description:

    Process a transmit completion on the UDP socket.

--*/ 
{
    TraceEnter("TeredoClientTransmitComplete");
        
    //
    // Attempt to post the read again.
    // If we are going offline, the packet is destroyed in the attempt.
    //
    Packet->Type = TEREDO_PACKET_READ;
    Packet->Buffer.len = IPV6_TEREDOMTU;
    TeredoPostRead(&(TeredoClient.Io), Packet);
}


VOID
TeredoClientMulticastComplete(
    IN DWORD Error,
    IN ULONG Bytes,
    IN PTEREDO_PACKET Packet
    )
/*++

Routine Description:

    Process a multicast bubble transmit completion on the UDP socket.

--*/ 
{
    ASSERT(Packet == &(TeredoClient.Packet));

    TraceEnter("TeredoClientMulticastComplete");
    
    TeredoClient.BubblePosted = FALSE;
    TeredoDereferenceClient();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\6to4svc\getprivate.c ===
#pragma warning(disable:4201) // nameless struct/union

#define COBJMACROS

#include <windows.h>
#include <objbase.h>
#include <hnetcfg.h>

DWORD
APIENTRY
RasQuerySharedPrivateLan(
    OUT GUID*           LanGuid )

/*++

Routine Description:

    This routine is invoked to determine the private-lan which
    is allowed access to the shared-network, if any.

Arguments:

    LanGuid - receives the GUID for the private lan

Return Value:

    DWORD - Win32 status code.

--*/

{
    HRESULT hr;
    BOOLEAN fComInitialized = TRUE;
    IHNetIcsSettings *pIcsSettings;
    IEnumHNetIcsPrivateConnections *pEnum;
    IHNetIcsPrivateConnection *pPrivateConn;
    IHNetConnection *pConn;
    ULONG ulCount;
    GUID *pGuid;

    if (NULL == LanGuid) {
        return ERROR_BAD_ARGUMENTS;
    }

    hr = CoInitializeEx(0, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);
    if (FAILED(hr)) {
        fComInitialized = FALSE;
        if (RPC_E_CHANGED_MODE == hr) {
            hr = S_OK;
        }
    }

    if (FAILED(hr)) {
        goto Done;
    }

    hr = CoCreateInstance(
            &CLSID_HNetCfgMgr,
            NULL,
            CLSCTX_ALL,
            &IID_IHNetIcsSettings,
            (void**)&pIcsSettings
            );

    if (FAILED(hr)) {
        goto Done;
    }

    hr = IHNetIcsSettings_EnumIcsPrivateConnections(pIcsSettings, &pEnum);
    IHNetIcsSettings_Release(pIcsSettings);

    if (FAILED(hr)) {
        goto Done;
    }

    hr = IEnumHNetIcsPrivateConnections_Next(pEnum, 1, &pPrivateConn, &ulCount);
    IEnumHNetIcsPrivateConnections_Release(pEnum);

    if (FAILED(hr)) {
        goto Done;
    }

    if (1 == ulCount) {
        hr = IHNetIcsPrivateConnection_QueryInterface(
                pPrivateConn,
                &IID_IHNetConnection,
                (void**)&pConn
                );

        IHNetIcsPrivateConnection_Release(pPrivateConn);

        if (FAILED(hr)) {
            goto Done;
        }

    } else {
        hr = E_FAIL;
        goto Done;
    }

    hr = IHNetConnection_GetGuid(pConn, &pGuid);
    IHNetConnection_Release(pConn);

    if (SUCCEEDED(hr)) {
        CopyMemory(LanGuid, pGuid, sizeof(*pGuid));
        CoTaskMemFree(pGuid);
    }

Done:
    if (TRUE == fComInitialized) {
        CoUninitialize();
    }

    return SUCCEEDED(hr) ? ERROR_SUCCESS : HRESULT_CODE(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\6to4svc\common.c ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

    common.c

Abstract:

    This module contains the teredo interface to the IPv6 Helper Service.

Author:

    Mohit Talwar (mohitt) Wed Nov 07 11:27:01 2001

Environment:

    User mode only.

--*/

#include "precomp.h"
#pragma hdrstop

CONST IN6_ADDR TeredoIpv6ServicePrefix = TEREDO_SERVICE_PREFIX;
CONST IN6_ADDR TeredoIpv6MulticastPrefix = TEREDO_MULTICAST_PREFIX;

LPGUID TeredoWmiEvent[] = {
    (LPGUID) &GUID_NDIS_NOTIFY_ADAPTER_ARRIVAL,
    (LPGUID) &GUID_NDIS_NOTIFY_ADAPTER_REMOVAL,
    (LPGUID) &GUID_NDIS_NOTIFY_DEVICE_POWER_ON,
    (LPGUID) &GUID_NDIS_NOTIFY_DEVICE_POWER_OFF,
};

HANDLE TeredoTimer;             // Periodic timer started for the service.
HANDLE TeredoTimerEvent;        // Event signalled upon Timer deletion.
HANDLE TeredoTimerEventWait;    // Wait registered for TimerEvent.
ULONG TeredoResolveInterval = TEREDO_RESOLVE_INTERVAL;

ULONG TeredoClientRefreshInterval = TEREDO_REFRESH_INTERVAL;
TEREDO_TYPE TeredoType = TEREDO_DEFAULT_TYPE;
WCHAR TeredoServerName[NI_MAXHOST] = TEREDO_SERVER_NAME;

BOOL TeredoClientEnabled = (TEREDO_DEFAULT_TYPE == TEREDO_CLIENT);
BOOL TeredoServerEnabled = (TEREDO_DEFAULT_TYPE == TEREDO_SERVER);
BOOL TeredoRequired = TRUE;

BOOL TeredoInitialized = FALSE;


ICMPv6Header *
TeredoParseIpv6Headers (
    IN PUCHAR Buffer,
    IN ULONG Bytes
    )
{
    UCHAR NextHeader = IP_PROTOCOL_V6;
    ULONG Length;

    //
    // Parse up until the ICMPv6 header.
    //
    for (;;) {
        switch (NextHeader) {
        case IP_PROTOCOL_V6:
            if (Bytes < sizeof(IP6_HDR)) {
                return NULL;
            }
            NextHeader = ((PIP6_HDR) Buffer)->ip6_nxt;
            Length = sizeof(IP6_HDR);
            break;
            
        case IP_PROTOCOL_HOP_BY_HOP:
        case IP_PROTOCOL_DEST_OPTS:
        case IP_PROTOCOL_ROUTING:
            if (Bytes < sizeof(ExtensionHeader)) {
                return NULL;
            }
            NextHeader = ((ExtensionHeader *) Buffer)->NextHeader;
            Length = ((ExtensionHeader *) Buffer)->HeaderExtLength * 8 + 8;
            break;

        case IP_PROTOCOL_FRAGMENT:
            if (Bytes < sizeof(FragmentHeader)) {
                return NULL;
            }
            NextHeader = ((FragmentHeader *) Buffer)->NextHeader;
            Length = sizeof(FragmentHeader);
            break;
            
        case IP_PROTOCOL_AH:
            if (Bytes < sizeof(AHHeader)) {
                return NULL;
            }
            NextHeader = ((AHHeader *) Buffer)->NextHeader;
            Length = sizeof(AHHeader) +
                ((AHHeader *) Buffer)->PayloadLen * 4 + 8;
            break;

        case IP_PROTOCOL_ICMPv6:
            if (Bytes < sizeof(ICMPv6Header)) {
                return NULL;
            }
            return (ICMPv6Header *) Buffer;
            
        default:
            return NULL;
        }
        
        if (Bytes < Length) {
            return NULL;
        }
        Buffer += Length;
        Bytes -= Length;
    }
}


BOOL
TeredoInterface(
    IN PWCHAR Guid
    )
/*++

Routine Description:

    Determine whether an interface is the Teredo Tunnel.

Arguments:

    Guid - Supplies the interface GUID.
    
Return Value:

    True if Teredo Tunnel, False o/w.
    
Caller LOCK: API.

--*/
{
    PTEREDO_IO Io = NULL;
    
    if (TeredoClient.State != TEREDO_STATE_OFFLINE) {
        Io = &(TeredoClient.Io);
    }

    if (TeredoServer.State != TEREDO_STATE_OFFLINE) {
        Io = &(TeredoServer.Io);
    }

    if ((Io != NULL) && (_wcsicmp(Io->TunnelInterface, Guid) == 0)) {
        return TRUE;
    }

    return FALSE;
}


__inline
VOID
TeredoStart(
    VOID
    )
{
    //
    // Both client and server should not be enabled on the same node.
    //
    ASSERT(!TeredoClientEnabled || !TeredoServerEnabled);

    if (TeredoClientEnabled) {
        //
        // The service might already be running, but that's alright.
        //
        TeredoStartClient();
    }

    if (TeredoServerEnabled) {
        //
        // The service might already be running, but that's alright.
        //
        TeredoStartServer();
    }
}


__inline
VOID
TeredoStop(
    VOID
    )
{
    //
    // Both client and server should not be enabled on the same node.
    //
    ASSERT(!TeredoClientEnabled || !TeredoServerEnabled);

    if (TeredoClientEnabled) {
        //
        // The service might not be running, but that's all right.
        //
        TeredoStopClient();
    }

    if (TeredoServerEnabled) {
        //
        // The service might not be running, but that's all right.
        //
        TeredoStopServer();
    }
}


DWORD
__inline
TeredoEnableWmiEvent(
    IN LPGUID EventGuid,
    IN BOOLEAN Enable
    )
{
    return WmiNotificationRegistrationW(
        EventGuid,                      // Event Type.
        Enable,                         // Enable or Disable.
        TeredoWmiEventNotification,     // Callback.
        0,                              // Context.
        NOTIFICATION_CALLBACK_DIRECT);  // Notification Flags.
}


VOID
__inline
TeredoDeregisterWmiEventNotification(
    VOID
    )
{
    int i;
    
    for (i = 0; i < (sizeof(TeredoWmiEvent) / sizeof(LPGUID)); i++) {
        (VOID) TeredoEnableWmiEvent(TeredoWmiEvent[i], FALSE);
    }
}


DWORD
__inline
TeredoRegisterWmiEventNotification(
    VOID
    )
{
    DWORD Error;
    int i;
    
    for (i = 0; i < (sizeof(TeredoWmiEvent) / sizeof(LPGUID)); i++) {
        Error = TeredoEnableWmiEvent(TeredoWmiEvent[i], TRUE);
        if (Error != NO_ERROR) {
            Trace2(ANY, L"TeredoEnableWmiEvent(%u): Error(%x)", i, Error);
            goto Bail;
        }
    }

    return NO_ERROR;

Bail:
    TeredoDeregisterWmiEventNotification();
    return Error;
}


VOID
CALLBACK
TeredoTimerCallback(
    IN PVOID Parameter,
    IN BOOLEAN TimerOrWaitFired
    )
/*++

Routine Description:

    Callback routine for TeredoTimer expiration.
    The timer is always active.

Arguments:

    Parameter, TimerOrWaitFired - Ignored.

Return Value:

    None.

--*/
{
    ENTER_API();
    TeredoStart();
    LEAVE_API();
}


VOID
CALLBACK
TeredoTimerCleanup(
    IN PVOID Parameter,
    IN BOOLEAN TimerOrWaitFired
    )
/*++

Routine Description:

    Callback routine for TeredoTimer deletion.

    Deletion is performed asynchronously since we acquire a lock in
    the callback function that we hold when deleting the timer.

Arguments:

    Parameter, TimerOrWaitFired - Ignored.

Return Value:

    None.

--*/
{
    UnregisterWait(TeredoTimerEventWait);
    CloseHandle(TeredoTimerEvent);
    DecEventCount("TeredoCleanupTimer");
}


DWORD
TeredoInitializeTimer(
    VOID
    )
/*++

Routine Description:

    Initializes the timer.

Arguments:

    None.

Return Value:

    NO_ERROR or failure code.

--*/
{
    DWORD Error;
    ULONG ResolveInterval;
    
    TeredoTimerEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (TeredoTimerEvent == NULL) {
        Error = GetLastError();
        return Error;
    }

    if (!RegisterWaitForSingleObject(
            &(TeredoTimerEventWait),
            TeredoTimerEvent,
            TeredoTimerCleanup,
            NULL,
            INFINITE,
            0)) {
        Error = GetLastError();
        CloseHandle(TeredoTimerEvent);
        return Error;
    }

    //
    // If the service is enabled, we attempt to start it every
    // TeredoResolveInterval seconds.  Else we disable its timer.
    //
    ResolveInterval = (TeredoClientEnabled || TeredoServerEnabled)
        ? (TeredoResolveInterval * 1000)
        : INFINITE_INTERVAL;
    if (!CreateTimerQueueTimer(
            &(TeredoTimer),
            NULL,
            TeredoTimerCallback,
            NULL,
            ResolveInterval,
            ResolveInterval,
            0)) { 
        Error = GetLastError();
        UnregisterWait(TeredoTimerEventWait);
        CloseHandle(TeredoTimerEvent);
        return Error;
    }

    IncEventCount("TeredoInitializeTimer");
    return NO_ERROR;
}


VOID
TeredoUninitializeTimer(
    VOID
    )
/*++

Routine Description:

    Uninitializes the timer.  Typically invoked upon service stop.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DeleteTimerQueueTimer(NULL, TeredoTimer, TeredoTimerEvent);
    TeredoTimer = NULL;
}


DWORD
TeredoInitializeGlobals(
    VOID
    )
/*++

Routine Description:

    Initializes the teredo client and server and attempts to start them.

Arguments:

    None.

Return Value:

    NO_ERROR or failure code.

--*/
{
    DWORD Error;
    BOOL ClientInitialized = FALSE;
    BOOL ServerInitialized = FALSE;
    BOOL TimerInitialized = FALSE;
    
    Error = TeredoInitializeClient();
    if (Error != NO_ERROR) {
        goto Bail;
    }
    ClientInitialized = TRUE;    
    
    Error = TeredoInitializeServer();
    if (Error != NO_ERROR) {
        goto Bail;
    }
    ServerInitialized = TRUE;

    Error = TeredoInitializeTimer();
    if (Error != NO_ERROR) {
        goto Bail;
    }
    TimerInitialized = TRUE;

    Error = TeredoRegisterWmiEventNotification();
    if (Error != NO_ERROR) {
        goto Bail;
    }
    
    TeredoStart();

    TeredoInitialized = TRUE;
    
    return NO_ERROR;

Bail:
    //
    // This can always be safely invoked!
    //
    TeredoDeregisterWmiEventNotification();
    
    if (TimerInitialized) {
        TeredoUninitializeTimer();
    }

    if (ServerInitialized) {
        TeredoUninitializeServer();
    }

    if (ClientInitialized) {
        TeredoUninitializeClient();
    }

    return Error;
}


VOID
TeredoUninitializeGlobals(
    VOID
    )
/*++

Routine Description:

    Uninitializes the teredo client and server.

Arguments:

    None.

Return Value:

    None.
    
--*/
{
    if (!TeredoInitialized) {
        return;
    }

    TeredoDeregisterWmiEventNotification();
    TeredoUninitializeTimer();
    TeredoUninitializeServer();
    TeredoUninitializeClient();

    TeredoInitialized = FALSE;
}


VOID
TeredoAddressChangeNotification(
    IN BOOL Delete,
    IN IN_ADDR Address
    )
/*++

Routine Description:

    Process an address deletion or addition request.

Arguments:

    Delete - Supplies a boolean.  TRUE if the address was deleted, FALSE o/w.

    Address - Supplies the IPv4 address that was deleted or added.
    
Return Value:

    None.
    
Caller LOCK: API.

--*/ 
{
    if (Delete) {
        //
        // Both client and server should not be running on the same node.
        //
        ASSERT((TeredoClient.State == TEREDO_STATE_OFFLINE) ||
               (TeredoServer.State == TEREDO_STATE_OFFLINE));

        if (TeredoClient.State != TEREDO_STATE_OFFLINE) {
            TeredoClientAddressDeletionNotification(Address);
        }
        
        if (TeredoServer.State != TEREDO_STATE_OFFLINE) {
            TeredoServerAddressDeletionNotification(Address);
        }

        return;
    }

    //
    // Address addition.
    // Attempt to start the service (if it is not already running).
    //
    TeredoStart();
}


VOID
TeredoRouteChangeNotification(
    VOID
    )
/*++

Routine Description:

    Process a route change notification.

Arguments:

    None.
    
Return Value:

    None.
    
Caller LOCK: API.

--*/
{
    //
    // Both client and server should not be enabled on the same node.
    //
    ASSERT(!TeredoClientEnabled || !TeredoServerEnabled);

    if (TeredoClientEnabled) {
        if (TeredoClient.State != TEREDO_STATE_OFFLINE) {
            //
            // Refresh I/O state.
            //
            TeredoRefreshClient();
        } else {
            TeredoStartClient();
        }
    }

    if (TeredoServerEnabled) {
        if (TeredoServer.State != TEREDO_STATE_OFFLINE) {
            //
            // Refresh I/O state.
            //
            TeredoRefreshServer();
        } else {
            TeredoStartServer();
        }
    }
}


VOID
TeredoConfigurationChangeNotification(
    VOID
    )
/*++

Routine Description:

    Process an configuration change request.

Arguments:

    None.
    
Return Value:

    None.
    
Caller LOCK: API.

--*/ 
{
    HKEY Key = INVALID_HANDLE_VALUE;
    BOOL EnableClient, EnableServer;
    ULONG RefreshInterval, ResolveInterval;
    WCHAR OldServerName[NI_MAXHOST];
    BOOL IoStateChange = FALSE;
    
    (VOID) RegOpenKeyExW(
        HKEY_LOCAL_MACHINE, KEY_TEREDO, 0, KEY_QUERY_VALUE, &Key);
    //
    // Continue despite errors, reverting to default values.
    //
    
    //
    // Get the new configuration parameters.
    //
    RefreshInterval = GetInteger(
        Key, KEY_TEREDO_REFRESH_INTERVAL, TEREDO_REFRESH_INTERVAL);
    if (RefreshInterval == 0) {
        //
        // Invalid value.  Revert to default.
        //
        RefreshInterval = TEREDO_REFRESH_INTERVAL;
    }
    TeredoClientRefreshInterval = RefreshInterval;
    TeredoClientRefreshIntervalChangeNotification();
    
    TeredoType = GetInteger(Key, KEY_TEREDO_TYPE, TEREDO_DEFAULT_TYPE);
    if ((TeredoType == TEREDO_DEFAULT) || (TeredoType >= TEREDO_MAXIMUM)) {
        //
        // Invalid value.  Revert to default.
        //
        TeredoType = TEREDO_DEFAULT_TYPE;
    }
    EnableClient = ((TeredoType == TEREDO_CLIENT) ||
                    ((TeredoType == TEREDO_AUTOMATIC) && TeredoRequired));
    EnableServer = (TeredoType == TEREDO_SERVER);

    wcscpy(OldServerName, TeredoServerName);
    GetString(
        Key,
        KEY_TEREDO_SERVER_NAME,
        TeredoServerName,
        NI_MAXHOST,
        TEREDO_SERVER_NAME);
    if (_wcsicmp(TeredoServerName, OldServerName) != 0) {
        IoStateChange = TRUE;
    }

    if (Key != INVALID_HANDLE_VALUE) {
        RegCloseKey(Key);
    }
    
    //
    // Both client and server should not be enabled on the same node.
    //
    ASSERT(!TeredoClientEnabled || !TeredoServerEnabled);

    //
    // Stop / Start / Reconfigure.
    //
    if (!EnableClient && TeredoClientEnabled) {
        TeredoClientEnabled = FALSE;
        TeredoStopClient();
    }
    
    if (!EnableServer && TeredoServerEnabled) {
        TeredoServerEnabled = FALSE;
        TeredoStopServer();
    }

    if (EnableClient) {
        if (TeredoClient.State != TEREDO_STATE_OFFLINE) {
            if (IoStateChange) {
                //
                // Refresh I/O state.
                //
                TeredoRefreshClient();
            }
        } else {
            TeredoClientEnabled = TRUE;
            TeredoStartClient();
        }
    }

    if (EnableServer) {
        if (TeredoServer.State != TEREDO_STATE_OFFLINE) {
            if (IoStateChange) {
                //
                // Refresh I/O state.
                //
                TeredoRefreshServer();
            }
        } else {
            TeredoServerEnabled = TRUE;
            TeredoStartServer();
        }
    }

    //
    // If the service is enabled, we attempt to start it every
    // TeredoResolveInterval seconds.  Else we disable its timer.
    //
    ResolveInterval = (TeredoClientEnabled || TeredoServerEnabled)
        ? (TeredoResolveInterval * 1000)
        : INFINITE_INTERVAL;
    (VOID) ChangeTimerQueueTimer(
        NULL, TeredoTimer, ResolveInterval, ResolveInterval);
}


VOID
WINAPI
TeredoWmiEventNotification(
    IN PWNODE_HEADER Event,
    IN UINT_PTR Context
    )
/*++

Routine Description:

    Process a WMI event (specifically adapter arrival or removal).
    
Arguments:

    Event - Supplies event specific information.

    Context - Supplies the context registered.
    
Return Value:

    None.
    
--*/ 
{
    PWNODE_SINGLE_INSTANCE Instance = (PWNODE_SINGLE_INSTANCE) Event;
    USHORT AdapterNameLength;
    WCHAR AdapterName[MAX_ADAPTER_NAME_LENGTH], *AdapterGuid;

    if (Instance == NULL) {
        return;
    }
    
    ENTER_API();
    
    TraceEnter("TeredoWmiEventNotification");
    
    //
    // WNODE_SINGLE_INSTANCE is organized thus...
    // +-----------------------------------------------------------+
    // |<--- DataBlockOffset --->| AdapterNameLength | AdapterName |
    // +-----------------------------------------------------------+
    //
    // AdapterName is defined as "\DEVICE\"AdapterGuid
    //
    AdapterNameLength =
        *((PUSHORT) (((PUCHAR) Instance) + Instance->DataBlockOffset));
    if (AdapterNameLength > ((MAX_ADAPTER_NAME_LENGTH - 1) * sizeof(WCHAR))) {
        AdapterNameLength = (MAX_ADAPTER_NAME_LENGTH - 1) * sizeof(WCHAR);
    }
    
    RtlCopyMemory(
        AdapterName,
        ((PUCHAR) Instance) + Instance->DataBlockOffset + sizeof(USHORT),
        AdapterNameLength);
    AdapterName[AdapterNameLength / sizeof(WCHAR)] = L'\0';
    AdapterGuid = AdapterName + wcslen(DEVICE_PREFIX);        
    Trace1(ANY, L"TeredoAdapter: %s", AdapterGuid);


    if ((memcmp(
            &(Event->Guid),
            &GUID_NDIS_NOTIFY_ADAPTER_ARRIVAL,
            sizeof(GUID)) == 0) ||
        (memcmp(
            &(Event->Guid),
            &GUID_NDIS_NOTIFY_DEVICE_POWER_ON,
            sizeof(GUID)) == 0)) {
        //
        // Adapter arrival (perhaps TUN).
        // Attempt to start the service (if it is not already running).
        //
        Trace0(ANY, L"Adapter Arrival");
        TeredoStart();
    }

    if ((memcmp(
            &(Event->Guid),
            &GUID_NDIS_NOTIFY_ADAPTER_REMOVAL,
            sizeof(GUID)) == 0) ||
        (memcmp(
            &(Event->Guid),
            &GUID_NDIS_NOTIFY_DEVICE_POWER_OFF,
            sizeof(GUID)) == 0)) {
        if (TeredoInterface(AdapterGuid)) {
            //
            // TUN adapter removal.
            // Stop the service if it is running.
            //
            Trace0(ANY, L"Adapter Removal");
            TeredoStop();
        }
    }

    LEAVE_API();
}


VOID
TeredoRequirementChangeNotification(
    IN BOOL Required
    )
/*++

Routine Description:

    Process a possible requirement change notification.

Arguments:

    Required - Whether the Teredo service is required for global connectivity.
    
Return Value:

    None.
    
Caller LOCK: API.

--*/
{
    if (TeredoRequired != Required) {
        TeredoRequired = Required;
        TeredoConfigurationChangeNotification();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\6to4svc\dyndns.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Abstract:

    Routines implementing Dynamic DNS registration of IPv6 addresses.

--*/

#include "precomp.h"
#pragma hdrstop
#include <windns.h>
#include <ntddip6.h>

//
// DHCP IPv4 addresses inside Microsoft have a default TTL of 20 minutes.
//
#define MAX_AAAA_TTL            1200            // Seconds.

//
// We must update the DNS records occasionally,
// or the DNS server might garbage-collect them.
// MSDN recommends a one-day interval.
//
#define MIN_UPDATE_INTERVAL     (1*DAYS*1000)   // Milliseconds.

__inline ULONG
MIN(ULONG a, ULONG b)
{
    if (a < b)
        return a;
    else
        return b;
}


SOCKET g_hIpv6Socket = INVALID_SOCKET;
WSAEVENT g_hIpv6AddressChangeEvent = NULL;
HANDLE g_hIpv6AddressChangeWait = NULL;
WSAOVERLAPPED g_hIpv6AddressChangeOverlapped;
//
// Stores the state from the last invocation of OnIpv6AddressChange. The only
// two fields used from the previous state are the site id
// (ZoneIndices[ScopeLevelSite]) and Mtu. The mtu field is overloaded to store
// information if the site id was manually changed for the interface or not. If
// the site id was manually change, Mtu is set to 1, otherwise 0. Once the site
// id has been manually changed, we do not try to override it. Also, this
// information is not persistent across reboots. If the site id is changed
// manually, on the next reboot, this information is lost and the 6to4 service
// might try to assign a new value. Secondly, there is no way to undo a manual
// setting. If a user sets the site id once, there is no way to go back to
// automatic configuration.
//
PIP_ADAPTER_ADDRESSES g_PreviousInterfaceState = NULL;

#define SITEID_MANUALLY_CHANGED Mtu

//
// Our caller uses StopIpv6AddressChangeNotification
// if we fail, so we don't need to cleanup.
//
DWORD
StartIpv6AddressChangeNotification()
{
    ASSERT(g_hIpv6Socket == INVALID_SOCKET);

    g_hIpv6Socket = WSASocket(AF_INET6, 0, 0,
                              NULL, 0,
                              WSA_FLAG_OVERLAPPED);
    if (g_hIpv6Socket == INVALID_SOCKET)
        return WSAGetLastError();

    //
    // We create an auto-reset event in the signalled state.
    // So OnIpv6AddressChange will be executed initially.
    //

    ASSERT(g_hIpv6AddressChangeEvent == NULL);
    g_hIpv6AddressChangeEvent = CreateEvent(NULL, FALSE, TRUE, NULL);
    if (g_hIpv6AddressChangeEvent == NULL)
        return GetLastError();

    //
    // We specify a timeout, so that we update DNS
    // at least that often. Otherwise the DNS server might
    // garbage-collect our records.
    //

    IncEventCount("AC:StartIpv6AddressChangeNotification");
    if (! RegisterWaitForSingleObject(&g_hIpv6AddressChangeWait,
                                      g_hIpv6AddressChangeEvent,
                                      OnIpv6AddressChange,
                                      NULL,
                                      MIN_UPDATE_INTERVAL,
                                      WT_EXECUTELONGFUNCTION)) {
        DecEventCount("AC:StartIpv6AddressChangeNotification");
        return GetLastError();
    }

    return NO_ERROR;
}

//
// Assume that if the primary DNS server is the same, then that's
// good enough to combine the records.
//
BOOL
IsSameDNSServer(
    PIP_ADAPTER_ADDRESSES pIf1,
    PIP_ADAPTER_ADDRESSES pIf2
    )
{
    PIP_ADAPTER_DNS_SERVER_ADDRESS pDns1, pDns2;
    
    pDns1 = pIf1->FirstDnsServerAddress;
    while ((pDns1 != NULL) &&
           (pDns1->Address.lpSockaddr->sa_family != AF_INET)) {
        pDns1 = pDns1->Next;
    }

    pDns2 = pIf2->FirstDnsServerAddress;
    while ((pDns2 != NULL) &&
           (pDns2->Address.lpSockaddr->sa_family != AF_INET)) {
        pDns2 = pDns2->Next;
    }

    if ((pDns1 == NULL) || (pDns2 == NULL)) {
        return FALSE;
    }

    ASSERT(pDns1->Address.lpSockaddr->sa_family == 
           pDns2->Address.lpSockaddr->sa_family);

    return !memcmp(pDns1->Address.lpSockaddr,
                   pDns2->Address.lpSockaddr,
                   pDns1->Address.iSockaddrLength);
}

DNS_RECORD *
BuildRecordSetW(
    WCHAR *hostname,
    PIP_ADAPTER_ADDRESSES pFirstIf,
    PIP4_ARRAY *ppServerList
    )
{
    DNS_RECORD *RSet, *pNext;
    int i, iAddressCount = 0;
    PIP_ADAPTER_UNICAST_ADDRESS Address;
    PIP_ADAPTER_ADDRESSES pIf;
    int ServerCount = 0;
    PIP_ADAPTER_DNS_SERVER_ADDRESS DnsServer;
    LPSOCKADDR_IN sin;
    BOOL RegisterSiteLocals = ENABLED;

    //
    // Count DNS servers
    //
    for (DnsServer = pFirstIf->FirstDnsServerAddress; 
         DnsServer; 
         DnsServer = DnsServer->Next) 
    {
        if (DnsServer->Address.lpSockaddr->sa_family != AF_INET) {
            //
            // DNS api currently only supports IPv4 addresses of servers
            //
            continue;
        }
        ServerCount++;
    }
    if (ServerCount == 0) {
        *ppServerList = NULL;
        return NULL;
    }

    //
    // Fill in DNS server array
    //
    *ppServerList = MALLOC(FIELD_OFFSET(IP4_ARRAY, AddrArray[ServerCount]));
    if (*ppServerList == NULL) {
        return NULL;
    }
    (*ppServerList)->AddrCount = ServerCount;
    for (i = 0, DnsServer = pFirstIf->FirstDnsServerAddress; 
         DnsServer; 
         DnsServer = DnsServer->Next) 
    {
        sin = (LPSOCKADDR_IN)DnsServer->Address.lpSockaddr;
        if (sin->sin_family == AF_INET) {
            (*ppServerList)->AddrArray[i++] = sin->sin_addr.s_addr;
        }
    }
    ASSERT(i == ServerCount);

    //
    // Decide whether to register site locals in DNS.
    //
    {
        HKEY hKey;
        DWORD dwErr;

        dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, KEY_GLOBAL, 0, 
                             KEY_QUERY_VALUE, &hKey);
        if (dwErr == NO_ERROR) {
            RegisterSiteLocals = GetInteger(hKey, L"EnableSiteLocalDdns", 
                                            ENABLED);
            RegCloseKey(hKey);
        }
    }
    
    //
    // Count eligible addresses
    //
    for (pIf=pFirstIf; pIf; pIf=pIf->Next) {
        if (!(pIf->Flags & IP_ADAPTER_DDNS_ENABLED))
            continue;
        // 
        // Make sure interface has same DNS server
        //
        if ((pIf != pFirstIf) && !IsSameDNSServer(pFirstIf, pIf)) {
            continue;
        }
        for (Address=pIf->FirstUnicastAddress; Address; Address=Address->Next) {
            if ((Address->Address.lpSockaddr->sa_family == AF_INET6) &&
                (Address->Flags & IP_ADAPTER_ADDRESS_DNS_ELIGIBLE) &&
                ((RegisterSiteLocals == ENABLED) || 
                 !IN6_IS_ADDR_SITELOCAL(&((LPSOCKADDR_IN6)
                    Address->Address.lpSockaddr)->sin6_addr))) {
                iAddressCount++;
            }
        } 
    }

    Trace1(FSM, _T("DDNS building record set of %u addresses"), iAddressCount);

    if (iAddressCount == 0) {
        //
        // Build a record set that specifies deletion.
        //

        RSet = MALLOC(sizeof *RSet);
        if (RSet == NULL) {
            return NULL;
        }

        memset(RSet, 0, sizeof *RSet);
        RSet->pName = (LPTSTR)hostname;
        RSet->wType = DNS_TYPE_AAAA;
        return RSet;
    }

    RSet = MALLOC(sizeof *RSet * iAddressCount);
    if (RSet == NULL) {
        return NULL;
    }

    memset(RSet, 0, sizeof *RSet * iAddressCount);

    pNext = NULL;
    i = iAddressCount;
    while (--i >= 0) {
        RSet[i].pNext = pNext;
        pNext = &RSet[i];
    }

    i=0;
    for (pIf=pFirstIf; pIf; pIf=pIf->Next) {
        if (!(pIf->Flags & IP_ADAPTER_DDNS_ENABLED))
            continue;
        
        if ((pIf != pFirstIf) && !IsSameDNSServer(pFirstIf, pIf)) {
            continue;
        }
        for (Address=pIf->FirstUnicastAddress; 
             Address; 
             Address=Address->Next) {
            if ((Address->Address.lpSockaddr->sa_family == AF_INET6) &&
                (Address->Flags & IP_ADAPTER_ADDRESS_DNS_ELIGIBLE) &&
                ((RegisterSiteLocals == ENABLED) || 
                 !IN6_IS_ADDR_SITELOCAL(&((LPSOCKADDR_IN6)
                    Address->Address.lpSockaddr)->sin6_addr))) {
                SOCKADDR_IN6 *sin6 = (SOCKADDR_IN6 *)
                    Address->Address.lpSockaddr;

                RSet[i].pName = (LPTSTR)hostname;

                //
                // Using a large TTL is not good because it means
                // any changes (adding a new address, removing an address)
                // might not be visible for a long time.
                //
                RSet[i].dwTtl = MIN(MAX_AAAA_TTL,
                                    MIN(Address->PreferredLifetime,
                                        Address->LeaseLifetime));

                RSet[i].wType = DNS_TYPE_AAAA;
                RSet[i].wDataLength = sizeof RSet[i].Data.AAAA;
                RSet[i].Data.AAAA.Ip6Address =
                    * (IP6_ADDRESS *) &sin6->sin6_addr;
                i++;
            }
        }
    }
    ASSERT(i == iAddressCount);

    return RSet;
}

VOID
ReportDnsUpdateStatusW(
    IN DNS_STATUS Status,
    IN WCHAR *hostname,
    IN DNS_RECORD *RSet
    )
{
    Trace3(ERR, _T("6to4svc: DnsReplaceRecordSet(%ls) %s: status %d"),
           hostname,
           RSet->wDataLength == 0 ? "delete" : "replace",
           Status);
}

//
// This function adapted from net\tcpip\commands\ipconfig\info.c
//
VOID
GetInterfaceDeviceName(
    IN ULONG Ipv4IfIndex,
    IN PIP_INTERFACE_INFO InterfaceInfo,
    OUT LPWSTR *IfDeviceName
    )
{
    DWORD i;

    //
    // search the InterfaceInfo to get the devicename for this interface.
    //

    (*IfDeviceName) = NULL;
    for( i = 0; i < (DWORD)InterfaceInfo->NumAdapters; i ++ ) {
        if( InterfaceInfo->Adapter[i].Index != Ipv4IfIndex ) continue;
        (*IfDeviceName) = InterfaceInfo->Adapter[i].Name + strlen(
            "\\Device\\Tcpip_" );
        break;
    }
}

VOID
RegisterNameOnInterface(
    PIP_ADAPTER_ADDRESSES pIf,
    PWCHAR hostname,
    DWORD namelen)
{
    DNS_RECORD *RSet = NULL;
    PIP4_ARRAY pServerList = NULL;
    DWORD Status;

    //
    // Convert to a DNS record set.
    //

    RSet = BuildRecordSetW(hostname, pIf, &pServerList);
    if ((RSet == NULL) || (pServerList == NULL)) {
        goto Cleanup;
    }

    Trace2(ERR, _T("DDNS registering %ls to server %d.%d.%d.%d"), 
           hostname, PRINT_IPADDR(pServerList->AddrArray[0]));

    //
    // REVIEW: We could (should?) compare the current record set
    // to the previous record set, and only update DNS
    // if there has been a change or if there was a timeout.
    //

    Status = DnsReplaceRecordSetW(
                    RSet,
                    DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                    NULL,
                    pServerList,
                    NULL);
    if (Status != NO_ERROR) {
        Trace1(ERR, _T("Error: DnsReplaceRecordSet returned %d"), Status);
    }

    ReportDnsUpdateStatusW(Status, hostname, RSet);

Cleanup:
    if (pServerList) {
        FREE(pServerList);
    }
    if (RSet) {
        FREE(RSet);
    }
}

VOID
DoDdnsOnInterface(
    PIP_ADAPTER_ADDRESSES pIf)
{
    // Leave room to add a trailing "."
    WCHAR hostname[NI_MAXHOST+1];
    DWORD namelen;

    //
    // Get the fully-qualified DNS name for this machine
    // and append a trailing dot.
    //
    namelen = NI_MAXHOST;
    if (! GetComputerNameExW(ComputerNamePhysicalDnsFullyQualified,
                             hostname, &namelen)) {
        return;
    }
    
    namelen = (DWORD)wcslen(hostname);

    hostname[namelen] = L'.';
    hostname[namelen+1] = L'\0';

    RegisterNameOnInterface(pIf, hostname, namelen);

    //
    // Also register the connection-specific name if configured to do so.
    //
    if (pIf->Flags & IP_ADAPTER_REGISTER_ADAPTER_SUFFIX) {
        namelen = NI_MAXHOST;
        if (! GetComputerNameExW(ComputerNamePhysicalDnsHostname,
                                 hostname, &namelen)) {
            return;
        }

        wcscat(hostname, L".");
        wcscat(hostname, pIf->DnsSuffix);

        namelen = (DWORD)wcslen(hostname);
        
        hostname[namelen] = L'.';
        hostname[namelen+1] = L'\0';

        RegisterNameOnInterface(pIf, hostname, namelen);
    }
}

//
// Set the site id of a given interface.
//
VOID
SetSiteId(
    IN PIP_ADAPTER_ADDRESSES pIf,
    IN ULONG SiteId)
{
    PIP_ADAPTER_DNS_SERVER_ADDRESS pDNS;
    IPV6_INFO_INTERFACE Update;
    DWORD Result;
    PSOCKADDR_IN6 pAddr;

    IPV6_INIT_INFO_INTERFACE(&Update);

    Update.This.Index = pIf->Ipv6IfIndex;
    Update.ZoneIndices[ADE_SITE_LOCAL] = SiteId;

    Result = UpdateInterface(&Update);

    Trace3(ERR, _T("SetSiteId if=%d site=%d result=%d"),
                pIf->Ipv6IfIndex, SiteId, Result);

    pIf->ZoneIndices[ScopeLevelSite] = SiteId;
    
    //
    // Site-local addresses of DNS servers may now have the wrong scope id.
    // Fix them.
    //
    for (pDNS = pIf->FirstDnsServerAddress; pDNS != NULL; pDNS = pDNS->Next) {
        pAddr = (PSOCKADDR_IN6)pDNS->Address.lpSockaddr;
        if ((pAddr->sin6_family == AF_INET6) &&
            (IN6_IS_ADDR_SITELOCAL(&pAddr->sin6_addr))) {
            pAddr->sin6_scope_id = SiteId;
        }
    }
}

//
// Set the site id of a given interface to an unused value.
//
VOID
NewSiteId(
    IN PIP_ADAPTER_ADDRESSES pIf,
    IN PIP_ADAPTER_ADDRESSES pAdapterAddresses)
{
    PIP_ADAPTER_ADDRESSES CompareWithIf;
    ULONG PotentialSiteId = 1;

    //
    // Find the lowest unused site id.
    //
    CompareWithIf = pAdapterAddresses;
    while (CompareWithIf != NULL) {
        if (CompareWithIf->ZoneIndices[ScopeLevelSite] == PotentialSiteId) {
            PotentialSiteId++;
            CompareWithIf = pAdapterAddresses;
        } else {
            CompareWithIf = CompareWithIf->Next;
        }
    }

    SetSiteId(pIf, PotentialSiteId);
}

BOOL
SameSite(
    IN PIP_ADAPTER_ADDRESSES A,
    IN PIP_ADAPTER_ADDRESSES B)
{
    IPV6_INFO_SITE_PREFIX PrefixA, PrefixB;

    //
    // If a connection-specific DNS suffix exists on either, then compare that.
    //
    // We do this first because it's more efficient than diving to the 
    // kernel to get the site prefixes.  In addition, it's immune to
    // whether the site prefix length is correct.
    //
    if (((A->DnsSuffix != NULL) && (A->DnsSuffix[0] != L'\0')) ||
        ((B->DnsSuffix != NULL) && (B->DnsSuffix[0] != L'\0'))) {
        if ((A->DnsSuffix == NULL) || (B->DnsSuffix == NULL)) {
            return FALSE;
        }
        return (wcscmp(A->DnsSuffix, B->DnsSuffix) == 0);
    }

    //
    // No connection-specific DNS suffix exists on either interface.
    // If an IPv6 site prefix exists on either, then compare that.
    //
    GetFirstSitePrefix(A->Ipv6IfIndex, &PrefixA);
    GetFirstSitePrefix(B->Ipv6IfIndex, &PrefixB);
    if ((PrefixA.Query.IF.Index != 0) || (PrefixB.Query.IF.Index != 0)) {
        if ((PrefixA.Query.IF.Index == 0) || (PrefixB.Query.IF.Index == 0)) {
            return FALSE;
        }
        if (PrefixA.Query.PrefixLength != PrefixB.Query.PrefixLength) {
            return FALSE;
        }
        return (RtlEqualMemory(PrefixA.Query.Prefix.s6_addr,
                               PrefixB.Query.Prefix.s6_addr,
                               sizeof(IPv6Addr)));
    }

    //
    // No site prefix exists on either interface.
    // Default to saying they're in different sites.
    //
    return FALSE;
}

VOID CALLBACK
OnIpv6AddressChange(
    IN PVOID lpParameter,
    IN BOOLEAN TimerOrWaitFired)
{
    PIP_ADAPTER_ADDRESSES pAdapterAddresses = NULL;
    PIP_ADAPTER_ADDRESSES pIf, pIf2, PreviousInterfaceState;
    BOOLEAN SetPreviousState = FALSE;
    ULONG BytesNeeded = 0;
    DWORD dwErr;
    DWORD BytesReturned;

    //
    // Sleep for one second.
    // Often there will be multiple address changes in a small time period,
    // and we prefer to update DNS once.
    //
    Sleep(1000);

    ENTER_API();
    TraceEnter("OnIpv6AddressChange");

    if (g_stService == DISABLED) {
        Trace0(FSM, L"Service disabled");
        goto Done;
    }

    //
    // First request another async notification.
    // We must do this *before* getting the address list,
    // to avoid missing an address change.
    //

    if (TimerOrWaitFired == FALSE) {
        for (;;) {
            ZeroMemory(&g_hIpv6AddressChangeOverlapped, sizeof(WSAOVERLAPPED));
            g_hIpv6AddressChangeOverlapped.hEvent = g_hIpv6AddressChangeEvent;
    
            dwErr = WSAIoctl(g_hIpv6Socket, SIO_ADDRESS_LIST_CHANGE,
                             NULL, 0,
                             NULL, 0, &BytesReturned,
                             &g_hIpv6AddressChangeOverlapped,
                             NULL);
            if (dwErr != 0) {
                dwErr = WSAGetLastError();
                if (dwErr != WSA_IO_PENDING) {
                    goto Done;
                }
    
                //
                // The overlapped operation was initiated.
                //
                break;
            }
    
            //
            // The overlapped operation completed immediately.
            // Just try it again.
            //
        }
    }

    //
    // Get the address list.
    //

    for (;;) {
        //
        // GetAdaptersAddresses only returns addresses of the specified address
        // family.  To obtain both IPv4 DNS server addresses and IPv6 unicast
        // addresses in the same call we need to pass AF_UNSPEC.
        //
        dwErr = GetAdaptersAddresses(
            AF_UNSPEC, GAA_FLAG_SKIP_ANYCAST | GAA_FLAG_SKIP_MULTICAST |
                       GAA_FLAG_SKIP_FRIENDLY_NAME,
            NULL, pAdapterAddresses, &BytesNeeded);
        if (dwErr == NO_ERROR) {
            SetPreviousState = TRUE;
            break;
        }

        if (dwErr != ERROR_BUFFER_OVERFLOW) {
            Trace1(ERR, _T("Error: GetAdaptersAddresses returned %d"), dwErr);
            if (pAdapterAddresses != NULL) {
                FREE(pAdapterAddresses);
                pAdapterAddresses = NULL;
            }
            goto Cleanup;
        }

        if (pAdapterAddresses == NULL)
            pAdapterAddresses = MALLOC(BytesNeeded);
        else {
            PVOID Mem;

            Mem = REALLOC(pAdapterAddresses, BytesNeeded);
            if (Mem == NULL) {
                FREE(pAdapterAddresses);
            }
            pAdapterAddresses = Mem;
        }
        if (pAdapterAddresses == NULL) {
            Trace0(ERR, _T("Error: malloc failed"));
            goto Cleanup;
        }
    }


    //
    // Check for site id changes.  At the start of each iteration, everything 
    // before 'pIf' will be fine.  Everything after it will be untouched.
    //
    for (pIf = pAdapterAddresses; pIf != NULL; pIf = pIf->Next) {
        //
        // Don't change values for the 6to4 or ISATAP interfaces,
        // since the site id is inherited off the underlying interface.
        // Also we can't change values for IPv4-only interfaces.
        //
        if ((pIf->Ipv6IfIndex == V4_COMPAT_IFINDEX) ||
            (pIf->Ipv6IfIndex == SIX_TO_FOUR_IFINDEX) ||
            (pIf->Ipv6IfIndex == 0)) {
            continue;
        }

        //
        // Try to find if we have state for this interface from a previous
        // invocation of OnIpv6AddressChange.
        // 
        for (PreviousInterfaceState = g_PreviousInterfaceState; 
             PreviousInterfaceState != NULL;
             PreviousInterfaceState = PreviousInterfaceState->Next) {
            if (PreviousInterfaceState->Ipv6IfIndex == pIf->Ipv6IfIndex) {
                break;
            }
        }
        if (PreviousInterfaceState != NULL) {
            // 
            // There is already state present for this interface. If the site
            // id has changed from the previous state, this is a manual
            // configuration. Set the manually changed flag to 1 (note that the
            // Mtu is overloaded for this purpose). 
            //
            if (PreviousInterfaceState->ZoneIndices[ScopeLevelSite] != 
                pIf->ZoneIndices[ScopeLevelSite]) {
                pIf->SITEID_MANUALLY_CHANGED = 1;
            }  else {
                pIf->SITEID_MANUALLY_CHANGED = 
                    PreviousInterfaceState->SITEID_MANUALLY_CHANGED;
            }
        } else {
            pIf->SITEID_MANUALLY_CHANGED = 0;
        }
        if (pIf->SITEID_MANUALLY_CHANGED == 1) {
            continue;
        }

        for (pIf2 = pAdapterAddresses; pIf2 != pIf; pIf2 = pIf2->Next) {
            if ((pIf2->Ipv6IfIndex == V4_COMPAT_IFINDEX) ||
                (pIf2->Ipv6IfIndex == SIX_TO_FOUR_IFINDEX) ||
                (pIf2->Ipv6IfIndex == 0) ||
                (pIf2->SITEID_MANUALLY_CHANGED == 1)) {
                continue;
            }
            
            if (SameSite(pIf, pIf2)) {
                if (pIf->ZoneIndices[ScopeLevelSite] != 
                    pIf2->ZoneIndices[ScopeLevelSite]) {
                    //
                    // pIf has just moved into the same site as an earlier
                    // interface.
                    //
                    SetSiteId(pIf, pIf2->ZoneIndices[ScopeLevelSite]);
                }
            } else {
                if (pIf->ZoneIndices[ScopeLevelSite] == 
                    pIf2->ZoneIndices[ScopeLevelSite]) {
                    //
                    // pIf has just moved out of its previous site.
                    // Pick a new unused site id.
                    //
                    NewSiteId(pIf, pAdapterAddresses);
                }
            }
        }
    }

    for (pIf=pAdapterAddresses; pIf; pIf=pIf->Next) {
        if (pIf->Flags & IP_ADAPTER_DDNS_ENABLED) {
    
            //
            // See if we've already done this interface because it
            // had the same DNS server as a previous one.
            //
            for (pIf2=pAdapterAddresses; pIf2 != pIf; pIf2 = pIf2->Next) {
                if (!(pIf2->Flags & IP_ADAPTER_DDNS_ENABLED))
                    continue;
                if (IsSameDNSServer(pIf2, pIf)) {
                    break;
                }
            }

            //
            // If not, go ahead and do DDNS.
            //
            if (pIf2 == pIf) {
                DoDdnsOnInterface(pIf);
            }
        }
    }

    //
    // A change in the set of IPv6 addresses might update the need for the
    // different transition mechanisms.
    //
    UpdateServiceRequirements(pAdapterAddresses);

Cleanup:
    //
    // At this point, pAdapterAddresses is NULL, otherwise points to valid
    // adapter data. 
    //
    if (SetPreviousState) {
        if (g_PreviousInterfaceState) {
            FREE(g_PreviousInterfaceState);
        }
        g_PreviousInterfaceState = pAdapterAddresses;
    } else {
        ASSERT(pAdapterAddresses == NULL);
    }

Done:
    TraceLeave("OnIpv6AddressChange");
    LEAVE_API();
}

VOID
StopIpv6AddressChangeNotification()
{
    if (g_hIpv6AddressChangeWait != NULL) {
        //
        // Block until we're sure that the address change callback isn't
        // still running.
        //
        LEAVE_API();
        UnregisterWaitEx(g_hIpv6AddressChangeWait, INVALID_HANDLE_VALUE);
        ENTER_API();

        //
        // Release the event we counted for RegisterWaitForSingleObject
        //
        DecEventCount("AC:StopIpv6AddressChangeNotification");
        g_hIpv6AddressChangeWait = NULL;
    }

    if (g_PreviousInterfaceState != NULL) {
        FREE(g_PreviousInterfaceState);
        g_PreviousInterfaceState = NULL;
    }
    
    if (g_hIpv6AddressChangeEvent != NULL) {
        CloseHandle(g_hIpv6AddressChangeEvent);
        g_hIpv6AddressChangeEvent = NULL;
    }

    if (g_hIpv6Socket != INVALID_SOCKET) {
        closesocket(g_hIpv6Socket);
        g_hIpv6Socket = INVALID_SOCKET;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\6to4svc\isatap.h ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

    isatap.h
    
Abstract:

    This module contains the ISATAP interface to the IPv6 Helper Service.

Author:

    Mohit Talwar (mohitt) Tue May 07 16:34:44 2002

Environment:

    User mode only.

--*/

#ifndef _ISATAP_
#define _ISATAP_

#pragma once


DWORD
IsatapInitialize(
    VOID
    );

VOID
IsatapUninitialize(
    VOID
    );

VOID
IsatapAddressChangeNotification(
    IN BOOL Delete,
    IN IN_ADDR Address
    );

VOID
IsatapRouteChangeNotification(
    VOID
    );

VOID
IsatapConfigurationChangeNotification(
    VOID
    );

#endif // _ISATAP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\6to4svc\makefile.inc ===
tcemsg.mc:    .\log.h
    mapmsg NET TCELOG_BASE .\log.h > tcemsg.mc

tcemsg.h msg00001.bin:    tcemsg.mc
    mc -v tcemsg.mc

tce.rc: msg00001.bin

clean::
    -del tcemsg.mc tcemsg.h tcemsg.rc msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\6to4svc\isatap.c ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

    isatap.c

Abstract:

    This module contains the ISATAP interface to the IPv6 Helper Service.

Author:

    Mohit Talwar (mohitt) Tue May 07 10:16:49 2002

Environment:

    User mode only.

--*/

#include "precomp.h"
#pragma hdrstop

#define DEFAULT_ISATAP_STATE                ENABLED
#define DEFAULT_ISATAP_ROUTER_NAME          L"isatap"
#define DEFAULT_ISATAP_RESOLUTION_STATE     ENABLED
#define DEFAULT_ISATAP_RESOLUTION_INTERVAL  (24 * HOURS)

#define KEY_ISATAP_STATE                    L"IsatapState"
#define KEY_ISATAP_ROUTER_NAME              L"IsatapRouterName"
#define KEY_ISATAP_RESOLUTION_STATE         L"EnableIsatapResolution"
#define KEY_ISATAP_RESOLUTION_INTERVAL      L"IsatapResolutionInterval"

STATE IsatapState;
WCHAR IsatapRouterName[NI_MAXHOST];
STATE IsatapResolutionState;
ULONG IsatapResolutionInterval; // in minutes

HANDLE IsatapTimer;             // Periodic timer started for the service.
HANDLE IsatapTimerEvent;        // Event signalled upon Timer deletion.
HANDLE IsatapTimerEventWait;    // Wait registered for TimerEvent.

IN_ADDR IsatapRouter;
IN_ADDR IsatapToken;

BOOL IsatapInitialized = FALSE;

DWORD
GetPreferredSource(
    IN IN_ADDR Destination,
    OUT PIN_ADDR Source
    )
{
    SOCKADDR_IN DestinationAddress, SourceAddress;
    int BytesReturned;

    memset(&DestinationAddress, 0, sizeof(SOCKADDR_IN));
    DestinationAddress.sin_family = AF_INET;
    DestinationAddress.sin_addr = Destination;

    if (WSAIoctl(
        g_sIPv4Socket, SIO_ROUTING_INTERFACE_QUERY,
        &DestinationAddress, sizeof(SOCKADDR_IN),
        &SourceAddress, sizeof(SOCKADDR_IN),
        &BytesReturned, NULL, NULL) == SOCKET_ERROR) {
        return WSAGetLastError();
    }

    *Source = SourceAddress.sin_addr;
    return NO_ERROR;
}


VOID
IsatapUpdateRouterAddress(
    VOID
    )
{
    DWORD Error = NO_ERROR;
    ADDRINFOW Hints;
    PADDRINFOW Addresses;
    IN_ADDR NewRouter = { INADDR_ANY }, NewToken = { INADDR_ANY };

    //
    // Set the ISATAP router address if ISATAP resolution is enabled.
    //
    if (IsatapResolutionState == ENABLED) {
        //
        // Resolve IsatapRouterName to an IPv4 address.
        //
        ZeroMemory(&Hints, sizeof(Hints));
        Hints.ai_family = PF_INET;
        Error = GetAddrInfoW(IsatapRouterName, NULL, &Hints, &Addresses);
        if (Error == NO_ERROR) {
            NewRouter = ((LPSOCKADDR_IN) Addresses->ai_addr)->sin_addr;
            FreeAddrInfoW(Addresses);

            //
            // Determine the preferred source address.
            //
            if (GetPreferredSource(NewRouter, &NewToken) != NO_ERROR) {
                //
                // What use is the IsatapRouter that cannot be reached?
                //
                NewRouter.s_addr = INADDR_ANY;
            }
        } else {
            Trace2(ERR, _T("GetAddrInfoW(%s): %x"), IsatapRouterName, Error);
        }
    }

    //
    // Update the stack with the new addresses.
    //
    IsatapRouter = NewRouter;
    IsatapToken = NewToken;
    UpdateRouterLinkAddress(V4_COMPAT_IFINDEX, IsatapToken, IsatapRouter);
}


VOID
IsatapConfigureAddress(
    IN BOOL Delete,
    IN IN_ADDR Ipv4
    )
/*++

Routine Description:

    Creates an ISATAP link-scoped address from an IPv4 address.
    
--*/
{
    SOCKADDR_IN6 IsatapAddress;
    
    memset(&IsatapAddress, 0, sizeof(SOCKADDR_IN6));
    IsatapAddress.sin6_family = AF_INET6;
    IsatapAddress.sin6_addr.s6_addr[0] = 0xfe;
    IsatapAddress.sin6_addr.s6_addr[1] = 0x80;
    IsatapAddress.sin6_addr.s6_addr[10] = 0x5e;
    IsatapAddress.sin6_addr.s6_addr[11] = 0xfe;
    memcpy(&IsatapAddress.sin6_addr.s6_addr[12], &Ipv4, sizeof(IN_ADDR));
    
    (VOID) ConfigureAddressUpdate(
        V4_COMPAT_IFINDEX,
        &IsatapAddress,
        Delete ? 0 : INFINITE_LIFETIME,
        ADE_UNICAST, PREFIX_CONF_WELLKNOWN, IID_CONF_LL_ADDRESS);    
}


VOID
IsatapConfigureAddressList(
    IN BOOL Delete
    )
{
    int i;
 
    //
    // Configure the lifetime of link-local ISATAP addresses.
    // This will cause them to be either added or deleted.
    //
    for (i = 0; i < g_pIpv4AddressList->iAddressCount; i++) {
        IsatapConfigureAddress(
            Delete,
            ((PSOCKADDR_IN)
             g_pIpv4AddressList->Address[i].lpSockaddr)->sin_addr);
    }
}


__inline
VOID
IsatapRestartTimer(
    VOID
    )
{
    ULONG ResolveInterval = (IsatapResolutionState == ENABLED)
        ? IsatapResolutionInterval * MINUTES * 1000 // minutes to milliseconds
        : INFINITE_INTERVAL;

    (VOID) ChangeTimerQueueTimer(NULL, IsatapTimer, 0, ResolveInterval);
}


__inline
VOID
IsatapStart(
    VOID
    )
{
    ASSERT(IsatapState != ENABLED);    
    IsatapState = ENABLED;

    IsatapConfigureAddressList(FALSE);

    IsatapRestartTimer();
}


__inline
VOID
IsatapStop(
    VOID
    )
{
    ASSERT(IsatapState == ENABLED);
    IsatapState = DISABLED;

    IsatapConfigureAddressList(TRUE);
    
    IsatapRestartTimer();
}


__inline
VOID
IsatapRefresh(
    VOID
    )
{
    ASSERT(IsatapState == ENABLED);
    
    IsatapRestartTimer();
}


VOID
CALLBACK
IsatapTimerCallback(
    IN PVOID Parameter,
    IN BOOLEAN TimerOrWaitFired
    )
/*++

Routine Description:

    Callback routine for IsatapTimer expiration.
    The timer is always active.

Arguments:

    Parameter, TimerOrWaitFired - Ignored.

Return Value:

    None.

--*/
{
    ENTER_API();

    TraceEnter("IsatapTimerCallback");

    IsatapUpdateRouterAddress();

    TraceLeave("IsatapTimerCallback");
    
    LEAVE_API();
}


VOID
CALLBACK
IsatapTimerCleanup(
    IN PVOID Parameter,
    IN BOOLEAN TimerOrWaitFired
    )
/*++

Routine Description:

    Callback routine for IsatapTimer deletion.

    Deletion is performed asynchronously since we acquire a lock in
    the callback function that we hold when deleting the timer.

Arguments:

    Parameter, TimerOrWaitFired - Ignored.

Return Value:

    None.

--*/
{
    UnregisterWait(IsatapTimerEventWait);
    IsatapTimerEventWait = NULL;

    CloseHandle(IsatapTimerEvent);
    IsatapTimerEvent = NULL;
    
    IsatapState = IsatapResolutionState = DISABLED;
    IsatapUpdateRouterAddress();
    
    DecEventCount("IsatapCleanupTimer");
}


DWORD
IsatapInitializeTimer(
    VOID
    )
/*++

Routine Description:

    Initializes the timer.

Arguments:

    None.

Return Value:

    NO_ERROR or failure code.

--*/
{
    DWORD Error;
    ULONG ResolveInterval;
    
    IsatapTimerEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (IsatapTimerEvent == NULL) {
        Error = GetLastError();
        return Error;
    }

    if (!RegisterWaitForSingleObject(
            &(IsatapTimerEventWait),
            IsatapTimerEvent,
            IsatapTimerCleanup,
            NULL,
            INFINITE,
            0)) {
        Error = GetLastError();
        CloseHandle(IsatapTimerEvent);
        return Error;
    }

    ResolveInterval = (IsatapResolutionState == ENABLED)
        ? (IsatapResolutionInterval * MINUTES * 1000)
        : INFINITE_INTERVAL;
    
    if (!CreateTimerQueueTimer(
            &(IsatapTimer),
            NULL,
            IsatapTimerCallback,
            NULL,
            0,
            ResolveInterval,
            0)) {
        Error = GetLastError();
        UnregisterWait(IsatapTimerEventWait);
        CloseHandle(IsatapTimerEvent);
        return Error;
    }

    IncEventCount("IsatapInitializeTimer");
    return NO_ERROR;
}


VOID
IsatapUninitializeTimer(
    VOID
    )
/*++

Routine Description:

    Uninitializes the timer.  Typically invoked upon service stop.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DeleteTimerQueueTimer(NULL, IsatapTimer, IsatapTimerEvent);
    IsatapTimer = NULL;
}


DWORD
IsatapInitialize(
    VOID
    )
/*++

Routine Description:

    Initializes ISATAP and attempts to start it.

Arguments:

    None.

Return Value:

    NO_ERROR or failure code.

--*/
{
    DWORD Error;

    IsatapState = DEFAULT_ISATAP_STATE;
    wcscpy(IsatapRouterName, DEFAULT_ISATAP_ROUTER_NAME);
    IsatapResolutionState = DEFAULT_ISATAP_RESOLUTION_STATE;
    IsatapResolutionInterval = DEFAULT_ISATAP_RESOLUTION_INTERVAL;

    IsatapRouter.s_addr = INADDR_ANY;
    IsatapToken.s_addr = INADDR_ANY;

    IsatapUpdateRouterAddress();
    
    Error = IsatapInitializeTimer();
    if (Error != NO_ERROR) {
        return Error;
    }

    IsatapInitialized = TRUE;
    
    return NO_ERROR;
}


VOID
IsatapUninitialize(
    VOID
    )
/*++

Routine Description:

    Uninitializes ISATAP.

Arguments:

    None.

Return Value:

    None.
    
--*/
{
    if (!IsatapInitialized) {
        return;
    }

    IsatapUninitializeTimer();

    IsatapInitialized = FALSE;
}


VOID
IsatapAddressChangeNotification(
    IN BOOL Delete,
    IN IN_ADDR Address
    )
/*++

Routine Description:

    Process an address deletion or addition request.

Arguments:

    Delete - Supplies a boolean.  TRUE if the address was deleted, FALSE o/w.

    Address - Supplies the IPv4 address that was deleted or added.
    
Return Value:

    None.
    
Caller LOCK: API.

--*/ 
{
    IsatapConfigureAddress(Delete, Address);

    if (IsatapResolutionState == ENABLED) {
        //
        // Preferred source address deleted -or- Any address added.
        //
        if (Delete
            ? (IsatapToken.s_addr == Address.s_addr)
            : (IsatapToken.s_addr == INADDR_ANY)) {
            Sleep(1000);            // Wait a second to ensure DNS is alerted.
            IsatapUpdateRouterAddress();
        }
    }
}


VOID
IsatapRouteChangeNotification(
    VOID
    )
/*++

Routine Description:

    Process a route change notification.

Arguments:

    None.
    
Return Value:

    None.
    
Caller LOCK: API.

--*/
{
    if (IsatapResolutionState == ENABLED) {
        IsatapRefresh();
    }
}


VOID
IsatapConfigurationChangeNotification(
    VOID
    )
/*++

Routine Description:

    Process an configuration change request.

Arguments:

    None.
    
Return Value:

    None.
    
Caller LOCK: API.

--*/ 
{
    HKEY Key = INVALID_HANDLE_VALUE;
    STATE State;
    
    (VOID) RegOpenKeyExW(
        HKEY_LOCAL_MACHINE, KEY_GLOBAL, 0, KEY_QUERY_VALUE, &Key);
    //
    // Continue despite errors, reverting to default values.
    //

    State = GetInteger(
        Key,
        KEY_ISATAP_STATE,
        DEFAULT_ISATAP_STATE);

    IsatapResolutionState = GetInteger(
        Key,
        KEY_ISATAP_RESOLUTION_STATE,
        DEFAULT_ISATAP_RESOLUTION_STATE);

    IsatapResolutionInterval= GetInteger(
        Key,
        KEY_ISATAP_RESOLUTION_INTERVAL,
        DEFAULT_ISATAP_RESOLUTION_INTERVAL);
    
    GetString(
        Key,
        KEY_ISATAP_ROUTER_NAME,
        IsatapRouterName,
        NI_MAXHOST,
        DEFAULT_ISATAP_ROUTER_NAME);

    if (Key != INVALID_HANDLE_VALUE) {
        RegCloseKey(Key);
    }

    if (State == DISABLED) {
        IsatapResolutionState = DISABLED;
    }
    
    //
    // Start / Reconfigure / Stop.
    //
    if (State == ENABLED) {
        if (IsatapState == ENABLED) {
            IsatapRefresh();
        } else {
            IsatapStart();
        }    
    } else {
        if (IsatapState == ENABLED) {
            IsatapStop();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\6to4svc\io.c ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

    io.c

Abstract:

    This module contains teredo I/O management functions.
    
    Socket management, overlapped completion indication, and buffer management
    ideas were originally implemented for tftpd by JeffV.

Author:

    Mohit Talwar (mohitt) Wed Oct 24 14:05:36 2001

Environment:

    User mode only.

--*/

#include "precomp.h"
#pragma hdrstop


WCHAR TeredoTunnelDeviceName[] = L"\\\\.\\\\Tun0";


DWORD
GetPreferredSourceAddress(
    IN PSOCKADDR_IN Destination,
    OUT PSOCKADDR_IN Source
    )
{
    int BytesReturned;
    
    if (WSAIoctl(
        g_sIPv4Socket, SIO_ROUTING_INTERFACE_QUERY,
        Destination, sizeof(SOCKADDR_IN), Source, sizeof(SOCKADDR_IN),
        &BytesReturned, NULL, NULL) == SOCKET_ERROR) {
        return WSAGetLastError();
    }

    //
    // When the source is local, the node is configured as the teredo server.
    // Hence it needs to explicitly specify the port to bind to.  Assign here!
    //
    if ((Source->sin_addr.s_addr == Destination->sin_addr.s_addr) ||
        (Source->sin_addr.s_addr == htonl(INADDR_LOOPBACK))) {
        *Source = *Destination;
    }
    
    return NO_ERROR;
}


__inline
DWORD
TeredoResolveServer(
    IN PTEREDO_IO TeredoIo
    )
/*++

Routine Description:

    Resolve the teredo IPv4 server address and UDP service port.

Arguments:

    TeredoIo - Supplies the I/O state.
    
Return Value:

    NO_ERROR or failure code.

--*/
{
    PADDRINFOW Addresses;
    DWORD Error;

    //
    // Resolve the teredo server name.
    //
    Error = GetAddrInfoW(TeredoServerName, NULL, NULL, &Addresses);
    if (Error == NO_ERROR) {
        Error = ERROR_INCORRECT_ADDRESS;
        
        if (Addresses->ai_family == AF_INET) {
            TeredoIo->ServerAddress.sin_addr =
                ((PSOCKADDR_IN) Addresses->ai_addr)->sin_addr;
            TeredoIo->ServerAddress.sin_port = TEREDO_PORT;
            Error = NO_ERROR;
        } else if (Addresses->ai_family == AF_INET6) {
            PIN6_ADDR Ipv6Address;
            IN_ADDR Ipv4Address;
            USHORT Port;
            
            //
            // Extract server's IPv4 address and port from the IPv6 address.
            //
            Ipv6Address = &(((PSOCKADDR_IN6) Addresses->ai_addr)->sin6_addr);
            if (TeredoServicePrefix(Ipv6Address)) {
                TeredoParseAddress(Ipv6Address, &Ipv4Address, &Port);
                if (Port == TEREDO_PORT) {
                    TeredoIo->ServerAddress.sin_addr = Ipv4Address;
                    TeredoIo->ServerAddress.sin_port = Port;
                    Error = NO_ERROR;
                }
            }
        }
        FreeAddrInfoW(Addresses);
    }
    
    return Error;
}


PTEREDO_PACKET
TeredoCreatePacket(
    IN PTEREDO_IO TeredoIo
    )
/*++

Routine Description:

    Creates a teredo packet.
    
Arguments:
    
    TeredoIo - Supplies the I/O state.
    
Return Value:

    Returns the created packet.
    
--*/
{
    PTEREDO_PACKET Packet = (PTEREDO_PACKET) HeapAlloc(
        TeredoIo->PacketHeap, 0, sizeof(TEREDO_PACKET) + IPV6_TEREDOMTU);
    if (Packet == NULL) {
        return NULL;
    }
    
    TeredoInitializePacket(Packet);
    Packet->Buffer.len = IPV6_TEREDOMTU;

    //
    // Obtain a reference on the teredo object for each outstanding packet.
    //
    (*TeredoIo->Reference)();

    return Packet;
}


VOID
TeredoDestroyPacket(
    IN PTEREDO_IO TeredoIo,
    IN PTEREDO_PACKET Packet
    )
/*++

Routine Description:

    Destroys a teredo packet.
    
Arguments:

    TeredoIo - Supplies the I/O state.
    
    Packet - Supplies the packet to destroy.
    
Return Value:

    None.
    
--*/
{
    ASSERT(Packet->Type != TEREDO_PACKET_BUBBLE);
    ASSERT(Packet->Type != TEREDO_PACKET_MULTICAST);
    HeapFree(TeredoIo->PacketHeap, 0, Packet);
    (*TeredoIo->Dereference)();
}


ULONG
TeredoPostReceives(
    IN PTEREDO_IO TeredoIo,
    IN PTEREDO_PACKET Packet OPTIONAL
    )
/*++

Routine Description:

    Post an asynchronous receive request on the UDP socket.

    NOTE: The supplied packet (if any) is destroyed if there are already
    enough (TEREDO_HIGH_WATER_MARK) receives posted on the UDP socket.

Arguments:

    TeredoIo - Supplies the I/O state.
    
    Packet - Supplies the packet to reuse, or NULL.
    
Return Value:

    Returns the number of receives posted on the UDP socket.
    
--*/
{
    ULONG Count = 0, PostedReceives = TeredoIo->PostedReceives;
    DWORD Error, Bytes;
    
    //
    // Attempt to post as many receives as required to...
    // 1. - either - have high water-mark number of posted receives.
    // 2.  - or - satisfy the current burst of packets.
    //
    while (PostedReceives < TEREDO_HIGH_WATER_MARK) {
        //
        // Allocate the Packet if we're not reusing one.
        //
        if (Packet == NULL) {
            Packet = TeredoCreatePacket(TeredoIo);
            if (Packet == NULL) {
                return PostedReceives;
            }
        }
        Packet->Type = TEREDO_PACKET_RECEIVE;

        ZeroMemory((PUCHAR) &(Packet->Overlapped), sizeof(OVERLAPPED));        
        Error = WSARecvFrom(
            TeredoIo->Socket,
            &(Packet->Buffer),
            1,
            &Bytes,
            &(Packet->Flags),
            (PSOCKADDR) &(Packet->SocketAddress),
            &(Packet->SocketAddressLength),
            &(Packet->Overlapped),
            NULL);
        if (Error == SOCKET_ERROR) {
            Error = WSAGetLastError();
        }
        switch (Error) {
        case NO_ERROR:
            //
            // The completion routine will have already been scheduled.
            //
            PostedReceives =
                InterlockedIncrement(&(TeredoIo->PostedReceives));
            if (Count++ > TEREDO_LOW_WATER_MARK) {
                //
                // Enough already!
                //
                return PostedReceives;
            }
            Packet = NULL;
            continue;

        case WSA_IO_PENDING:
            //
            // The overlapped operation has been successfully initiated.
            // Completion will be indicated at a later time.
            //
            PostedReceives =
                InterlockedIncrement(&(TeredoIo->PostedReceives));
            return PostedReceives;

        case WSAECONNRESET:
            //
            // A previous send operation resulted in an ICMP "Port Unreachable"
            // message.  But why let that stop us?  Post the same packet again.
            //
            continue;
            
        default:
            //
            // The overlapped operation was not successfully initiated.
            // No completion indication will occur.
            //
            goto Bail;
        }
    }

Bail:
    if (Packet != NULL) {
        TeredoDestroyPacket(TeredoIo, Packet);
    }
    
    return PostedReceives;
}

            
VOID
CALLBACK
TeredoReceiveNotification(
    IN PVOID Parameter,
    IN BOOLEAN TimerOrWaitFired
    )
/*++

Routine Description:
    
    Callback for when there are pending read notifications on the UDP socket.
    We attempt to post more packets.
    
Arguments:

    Parameter - Supplies the I/O state.
    
    TimerOrWaitFired - Ignored.

Return Value:

    None.

--*/ 
{
    ULONG Old, New;
    PTEREDO_IO TeredoIo = Cast(Parameter, TEREDO_IO);
    
    New = TeredoIo->PostedReceives;
    
    while(New < TEREDO_LOW_WATER_MARK) {
        //
        // If this fails, the event triggering this callback will stop
        // signalling due to a lack of a successful WSARecvFrom.  This will
        // likely occur during low-memory or stress conditions.  When the
        // system returns to normal, the low water-mark packets will be
        // reposted, thus re-enabling the event which triggers this callback.
        //
        Old = New;
        New = TeredoPostReceives(TeredoIo, NULL);
        if (New == Old) {
            //
            // There is no change in the number of posted receive packets.
            //
            return;
        }
    } 
}


PTEREDO_PACKET
TeredoTransmitPacket(
    IN PTEREDO_IO TeredoIo,
    IN PTEREDO_PACKET Packet
    )
/*++

Routine Description:

    Post an asynchronous transmit request on the UDP socket.
    
Arguments:

    TeredoIo - Supplies the I/O state.
    
    Packet - Supplies the packet to transmit.
    
Return Value:

    Returns the supplied packet if the transmit completed or failed;
    NULL if the transmit will complete asynchronously.
    
--*/
{
    DWORD Error, Bytes;

    ASSERT((Packet->Type == TEREDO_PACKET_BUBBLE) ||
           (Packet->Type == TEREDO_PACKET_BOUNCE) ||
           (Packet->Type == TEREDO_PACKET_TRANSMIT) ||
           (Packet->Type == TEREDO_PACKET_MULTICAST));
    
    //
    // Try sending it non-blocking.
    //
    Error = WSASendTo(
        TeredoIo->Socket, &(Packet->Buffer), 1, &Bytes, Packet->Flags,
        (PSOCKADDR) &(Packet->SocketAddress), Packet->SocketAddressLength,
        NULL, NULL);
    if ((Error != SOCKET_ERROR) || (WSAGetLastError() != WSAEWOULDBLOCK)) {
        return Packet;
    }

    //
    // WSASendTo threatens to block, so we send it overlapped.
    //
    ZeroMemory((PUCHAR) &(Packet->Overlapped), sizeof(OVERLAPPED));    
    Error = WSASendTo(
        TeredoIo->Socket, &(Packet->Buffer), 1, &Bytes, Packet->Flags,
        (PSOCKADDR) &(Packet->SocketAddress), Packet->SocketAddressLength,
        &(Packet->Overlapped), NULL);
    if ((Error != SOCKET_ERROR) || (WSAGetLastError() != WSA_IO_PENDING)) {
        return Packet;
    }

    //
    // The overlapped operation has been successfully initiated.
    // Completion will be indicated at a later time.
    //
    return NULL;
}


VOID
TeredoDestroySocket(
    IN PTEREDO_IO TeredoIo
    )
/*++

Routine Description:

    Close the UDP socket.
    
Arguments:

    TeredoIo - Supplies the I/O state.
    
Return Value:

    None.
    
--*/
{
    if (TeredoIo->ReceiveEventWait != NULL) {
        UnregisterWait(TeredoIo->ReceiveEventWait);
        TeredoIo->ReceiveEventWait = NULL;
    }

    if (TeredoIo->ReceiveEvent != NULL) {
        CloseHandle(TeredoIo->ReceiveEvent);
        TeredoIo->ReceiveEvent = NULL;
    }

    if (TeredoIo->Socket != INVALID_SOCKET) {
        //
        // Close the socket.  This will disable the FD_READ event select,
        // as well as cancel all pending overlapped operations.
        //
        closesocket(TeredoIo->Socket);
        TeredoIo->Socket = INVALID_SOCKET;
    }
}


DWORD
TeredoCreateSocket(
    IN PTEREDO_IO TeredoIo
    )
/*++

Routine Description:

    Open the UDP socket for receives and transmits.
    
Arguments:

    TeredoIo - Supplies the I/O state.
    
Return Value:

    NO_ERROR or failure code.

--*/
{
    DWORD Error;
    struct ip_mreq  Multicast;
    BOOL Loopback;
    
    //
    // Create the socket.
    //
    TeredoIo->Socket = WSASocket(
        AF_INET, SOCK_DGRAM, 0, NULL, 0, WSA_FLAG_OVERLAPPED);
    if (TeredoIo->Socket == INVALID_SOCKET) {
        return GetLastError();
    }

    //
    // Bind the socket on the correct address and port.
    //
    if (bind(
        TeredoIo->Socket,
        (PSOCKADDR) &(TeredoIo->SourceAddress),
        sizeof(SOCKADDR_IN)) == SOCKET_ERROR) {
        goto Bail;
    }

    //  
    // Register for completion callbacks on the socket.
    //
    if (!BindIoCompletionCallback(
        (HANDLE) TeredoIo->Socket, TeredoIo->IoCompletionCallback, 0)) {
        goto Bail;
    }
    
    //
    // Select the socket for read notifications so we know when to post
    // more packets.  This also sets the socket to nonblocking mode.
    //
    TeredoIo->ReceiveEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (TeredoIo->ReceiveEvent == NULL) {
        goto Bail;
    }

    if (WSAEventSelect(
        TeredoIo->Socket,
        TeredoIo->ReceiveEvent,
        FD_READ) == SOCKET_ERROR) {
        goto Bail;
    }
    
    if (!RegisterWaitForSingleObject(
        &(TeredoIo->ReceiveEventWait),
        TeredoIo->ReceiveEvent,
        TeredoReceiveNotification,
        (PVOID) TeredoIo,
        INFINITE,
        0)) {
        goto Bail;
    }

    //
    // Prepost low water-mark number of receive Packets.  If the FD_READ event
    // signals on the socket before we're done, we'll exceed the low water-mark
    // here but that's really quite harmless.
    //
    SetEvent(TeredoIo->ReceiveEvent);

    //
    // See if there is a multicast group to join.
    //
    if (IN4_MULTICAST(TeredoIo->Group)) {
        //
        // Default TTL of multicast packets is 1, so don't bother setting it.
        // Set loopback to ignore self generated multicast packets.
        // Failure is not fatal!
        //
        Loopback = FALSE;
        (VOID) setsockopt(
            TeredoIo->Socket,
            IPPROTO_IP,
            IP_MULTICAST_LOOP,
            (const CHAR *) &Loopback,
            sizeof(BOOL));

        //
        // Join the multicast group on the native interface.
        // Failure is not fatal!
        //
        Multicast.imr_multiaddr = TeredoIo->Group;
        Multicast.imr_interface = TeredoIo->SourceAddress.sin_addr;
        (VOID) setsockopt(
            TeredoIo->Socket,
            IPPROTO_IP,
            IP_ADD_MEMBERSHIP,
            (const CHAR *) &Multicast,
            sizeof(struct ip_mreq));
    }
    
    return NO_ERROR;
    
Bail:
    Error = GetLastError();
    TeredoDestroySocket(TeredoIo);
    return Error;
}


BOOL
TeredoPostRead(
    IN PTEREDO_IO TeredoIo,
    IN PTEREDO_PACKET Packet OPTIONAL
    )
/*++

Routine Description:

    Post an asynchronous read request on the TUN interface device.
    
Arguments:

    TeredoIo - Supplies the I/O state.
    
    Packet - Supplies the packet to reuse, or NULL.
    
Return Value:

    TRUE if a read was successfully posted, FALSE otherwise.
    
--*/
{
    BOOL Success;
    
    //
    // Allocate the Packet if we're not reusing one.
    //
    if (Packet == NULL) {
        Packet = TeredoCreatePacket(TeredoIo);
        if (Packet == NULL) {
            return FALSE;
        }
    }
    Packet->Type = TEREDO_PACKET_READ;

    ZeroMemory((PUCHAR) &(Packet->Overlapped), sizeof(OVERLAPPED));
    Success = ReadFile(
        TeredoIo->TunnelDevice,
        Packet->Buffer.buf,
        Packet->Buffer.len,
        NULL,
        &(Packet->Overlapped));
    if (Success || (GetLastError() == ERROR_IO_PENDING)) {
        //
        // On success, the completion routine will have already been scheduled.
        //
        return TRUE;
    }
        
    TeredoDestroyPacket(TeredoIo, Packet);
    return FALSE;
}


PTEREDO_PACKET
TeredoWritePacket(
    IN PTEREDO_IO TeredoIo,
    IN PTEREDO_PACKET Packet
    )
/*++

Routine Description:

    Post an asynchronous write request on the TUN interface device.
    
Arguments:

    TeredoIo - Supplies the I/O state.
    
    Packet - Supplies the packet to write.
    
Return Value:

    Returns the supplied packet if the write failed;
    NULL if the write will complete asynchronously.
    
--*/
{
    BOOL Success;

    ASSERT(Packet->Type == TEREDO_PACKET_WRITE);

    ZeroMemory((PUCHAR) &(Packet->Overlapped), sizeof(OVERLAPPED));
    Success = WriteFile(
        TeredoIo->TunnelDevice,
        Packet->Buffer.buf,
        Packet->Buffer.len,
        NULL,
        &(Packet->Overlapped));
    if (Success || (GetLastError() == ERROR_IO_PENDING)) {
        //
        // On success, the completion routine will have already been scheduled.
        //
        return NULL;
    }

    return Packet;
}


VOID
TeredoCloseDevice(
    IN PTEREDO_IO TeredoIo
    )
/*++

Routine Description:

    Close the TUN interface device.
    
Arguments:

    TeredoIo - Supplies the I/O state.
    
Return Value:

    None.
    
--*/
{
    //
    // Close the device. This will cancel all pending overlapped operations.
    //
    if (TeredoIo->TunnelDevice != INVALID_HANDLE_VALUE) {
        CloseHandle(TeredoIo->TunnelDevice);
        TeredoIo->TunnelDevice = INVALID_HANDLE_VALUE;
        wcscpy(TeredoIo->TunnelInterface, L"");
    }
}


DWORD
TeredoOpenDevice(
    IN PTEREDO_IO TeredoIo
    )
/*++

Routine Description:

    Open the TUN interface device for reads and writes.
    
Arguments:

    None.
    
Return Value:

    NO_ERROR or failure code.

--*/
{
    UCHAR Buffer[sizeof(USHORT) + sizeof(WCHAR) * MAX_ADAPTER_NAME_LENGTH];
    USHORT AdapterNameLength;
    PWCHAR AdapterGuid;
    DWORD AdapterGuidLength, BytesReturned, Error;
    ULONG i;
    
    TeredoIo->TunnelDevice = CreateFile(
        TeredoTunnelDeviceName,
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_OVERLAPPED,
        NULL);
    if (TeredoIo->TunnelDevice == INVALID_HANDLE_VALUE) {
        return GetLastError();
    }
    
    if (!DeviceIoControl(
        TeredoIo->TunnelDevice,
        IOCTL_TUN_GET_MINIPORT_NAME,
        NULL,
        0,
        Buffer,
        sizeof(Buffer),
        &BytesReturned,
        NULL)) {
        Error = GetLastError();
        goto Bail;
    }

    if (BytesReturned < sizeof(USHORT)) {
        Error = ERROR_INVALID_NAME;
        goto Bail;
    }
    AdapterNameLength = *((PUSHORT) Buffer);

    if ((AdapterNameLength < wcslen(DEVICE_PREFIX) * sizeof(WCHAR)) ||
        (AdapterNameLength > (MAX_ADAPTER_NAME_LENGTH - 1) * sizeof(WCHAR))) {
        Error = ERROR_INVALID_NAME;
        goto Bail;
    }
    AdapterGuidLength = 
        AdapterNameLength - (USHORT)(wcslen(DEVICE_PREFIX) * sizeof(WCHAR));
    AdapterGuid = (PWCHAR)
        (Buffer + sizeof(USHORT) +  wcslen(DEVICE_PREFIX) * sizeof(WCHAR));
    
    RtlCopyMemory(
        TeredoClient.Io.TunnelInterface, AdapterGuid, AdapterGuidLength);
    TeredoClient.Io.TunnelInterface[AdapterGuidLength / sizeof(WCHAR)] = L'\0';

    Trace1(ANY, L"TeredoAdapter: %s", TeredoClient.Io.TunnelInterface);

    //  
    // Register for completion callbacks on the tun device.
    //
    if (!BindIoCompletionCallback(
        TeredoIo->TunnelDevice, TeredoIo->IoCompletionCallback, 0)) {
        Error = GetLastError();
        goto Bail;
    }

    //
    // Post a fixed number of reads on the device.
    //
    for (i = 0; i < TEREDO_LOW_WATER_MARK; i++) {
        if (!TeredoPostRead(TeredoIo, NULL)) {
            break;
        }
    }

    if (i != 0) {
        return NO_ERROR;
    }
    Error = ERROR_READ_FAULT;
    
    //
    // We couldn't post a single read on the device.  What good is it?
    //

Bail:
    TeredoCloseDevice(TeredoIo);
    return Error;    
}


VOID
TeredoStopIo(
    IN PTEREDO_IO TeredoIo
    )
/*++

Routine Description:

    Stop I/O processing.
    
Arguments:

    TeredoIo - Supplies the I/O state.
    
Return Value:

    None.

--*/
{
    if (TeredoIo->TunnelDevice != INVALID_HANDLE_VALUE) {
        TeredoCloseDevice(TeredoIo);
    }
    
    if (TeredoIo->Socket != INVALID_SOCKET) {
        TeredoDestroySocket(TeredoIo);
    }

    TeredoIo->ServerAddress.sin_port = 0;
    TeredoIo->ServerAddress.sin_addr.s_addr = htonl(INADDR_ANY);
    TeredoIo->SourceAddress.sin_addr.s_addr = htonl(INADDR_ANY);
}


DWORD
TeredoStartIo(
    IN PTEREDO_IO TeredoIo
    )
/*++

Routine Description:

    Start I/O processing.
    
Arguments:

    TeredoIo - Supplies the I/O state.
    
Return Value:

    NO_ERROR or failure code.

--*/ 
{
    DWORD Error;
    
    //
    // Resolve the teredo server name and service name.
    //
    Error = TeredoResolveServer(TeredoIo);
    if (Error != NO_ERROR) {        
        Trace1(ERR, _T("TeredoResolveServer: %u"), Error);
        return Error;
    }

    //
    // Get the preferred source address to the teredo server.
    //
    Error = GetPreferredSourceAddress(
        &(TeredoIo->ServerAddress), &(TeredoIo->SourceAddress));
    if (Error != NO_ERROR) {
        Trace1(ERR, _T("GetPreferredSourceAddress: %u"), Error);
        goto Bail;
    }
    
    //
    // Create the UDP Socket.
    //
    Error = TeredoCreateSocket(TeredoIo);
    if (Error != NO_ERROR) {
        Trace1(ERR, _T("TeredoCreateSocket: %u"), Error);
        goto Bail;
    }

    //
    // Open the TunnelDevice.
    //
    Error = TeredoOpenDevice(TeredoIo);
    if (Error != NO_ERROR) {
        Trace1(ERR, _T("TeredoOpenDevice: %u"), Error);
        goto Bail;
    }

    return NO_ERROR;
    
Bail:
    TeredoStopIo(TeredoIo);
    return Error;
}


DWORD
TeredoRefreshSocket(
    IN PTEREDO_IO TeredoIo
    )
/*++

Routine Description:

    Refresh the I/O state upon deletion of SourceAddress.
    
Arguments:

    TeredoIo - Supplies the I/O state.
    
Return Value:

    NO_ERROR if the I/O state is successfully refreshed, o/w failure code.
    The caller is responsible for cleaning up the I/O state upon failure.
    
--*/
{
    DWORD Error;
    SOCKADDR_IN Old = TeredoIo->SourceAddress;
    
    //
    // Let's re-resolve the teredo server address and port.
    // Refresh might have been triggered by a change in server/service name.
    //
    Error = TeredoResolveServer(TeredoIo);
    if (Error != NO_ERROR) {
        return Error;
    }

    //
    // Get the preferred source address to the teredo server.
    //
    Error = GetPreferredSourceAddress(
        &(TeredoIo->ServerAddress), &(TeredoIo->SourceAddress));
    if (Error != NO_ERROR) {
        return Error;
    }

    if (IN4_SOCKADDR_EQUAL(&(TeredoIo->SourceAddress), &Old)) {
        //
        // No change to the bound address and port.  Whew!
        //
        return NO_ERROR;
    }
    
    //
    // Destroy the old UDP socket.
    //
    TeredoDestroySocket(TeredoIo);

    //
    // Create a new UDP socket, bound to the new address and port.
    //
    Error = TeredoCreateSocket(TeredoIo);
    if (Error != NO_ERROR) {
        return Error;
    }

    return NO_ERROR;
}


DWORD
TeredoInitializeIo(
    IN PTEREDO_IO TeredoIo,
    IN IN_ADDR Group,
    IN PTEREDO_REFERENCE Reference,
    IN PTEREDO_DEREFERENCE Dereference,
    IN LPOVERLAPPED_COMPLETION_ROUTINE IoCompletionCallback    
    )
/*++

Routine Description:

    Initialize the I/O state.
    
Arguments:

    TeredoIo - Supplies the I/O state.

    Group - Supplies the multicast group to join (or INADDR_ANY).
    
Return Value:

    NO_ERROR or failure code.

--*/ 
{
#if DBG
    TeredoIo->Signature = TEREDO_IO_SIGNATURE;
#endif // DBG        

    
    TeredoIo->PostedReceives = 0;    
    TeredoIo->ReceiveEvent = TeredoIo->ReceiveEventWait = NULL;
    TeredoIo->Group = Group;
    ZeroMemory(&(TeredoIo->ServerAddress), sizeof(SOCKADDR_IN));
    TeredoIo->ServerAddress.sin_family = AF_INET;
    ZeroMemory(&(TeredoIo->SourceAddress), sizeof(SOCKADDR_IN));
    TeredoIo->SourceAddress.sin_family = AF_INET;
    TeredoIo->Socket = INVALID_SOCKET;
    TeredoIo->TunnelDevice = INVALID_HANDLE_VALUE;
    wcscpy(TeredoIo->TunnelInterface, L"");
    TeredoIo->Reference = Reference;
    TeredoIo->Dereference = Dereference;
    TeredoIo->IoCompletionCallback = IoCompletionCallback;    

    TeredoIo->PacketHeap = HeapCreate(0, 0, 0);
    if (TeredoIo->PacketHeap == NULL) {
        return GetLastError();
    }
    return NO_ERROR;
}


VOID
TeredoCleanupIo(
    IN PTEREDO_IO TeredoIo
    )
/*++

Routine Description:

    Cleanup the I/O state.
    
Arguments:

    TeredoIo - Supplies the I/O state.
    
Return Value:

    None.
    
--*/ 
{
    HeapDestroy(TeredoIo->PacketHeap);
    TeredoIo->PacketHeap = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\6to4svc\ipv6.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Helper functions for dealing with the IPv6 protocol stack.
// Really these should be in a library of some kind.
//

#include "precomp.h"
#pragma hdrstop

HANDLE Handle;

//
// Initialize this module.
// Returns FALSE for failure.
//
int
InitIPv6Library(void)
{
    //
    // Get a handle to the IPv6 device.
    // We will use this for ioctl operations.
    //
    Handle = CreateFileW(WIN_IPV6_DEVICE_NAME,
                         GENERIC_WRITE,      // access mode
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         NULL,   // security attributes
                         OPEN_EXISTING,
                         0,      // flags & attributes
                         NULL);  // template file

    return Handle != INVALID_HANDLE_VALUE;
}

void
UninitIPv6Library(void)
{
    CloseHandle(Handle);
    Handle = INVALID_HANDLE_VALUE;
}

void
ForEachInterface(void (*func)(IPV6_INFO_INTERFACE *, void *), void *Context)
{
    IPV6_QUERY_INTERFACE Query;
    IPV6_INFO_INTERFACE *IF;
    u_int InfoSize, BytesReturned;

    InfoSize = sizeof *IF + 2 * MAX_LINK_LAYER_ADDRESS_LENGTH;
    IF = (IPV6_INFO_INTERFACE *) MALLOC(InfoSize);
    if (IF == NULL) 
        return;

    Query.Index = (u_int) -1;

    for (;;) {
        if (!DeviceIoControl(Handle, IOCTL_IPV6_QUERY_INTERFACE,
                             &Query, sizeof Query,
                             IF, InfoSize, &BytesReturned,
                             NULL)) {
            // fprintf(stderr, "bad index %u\n", Query.Index);
            break;
        }

        if (Query.Index != (u_int) -1) {

            if ((BytesReturned < sizeof *IF) ||
                (IF->Length < sizeof *IF) ||
                (BytesReturned != IF->Length +
                 ((IF->LocalLinkLayerAddress != 0) ?
                  IF->LinkLayerAddressLength : 0) +
                 ((IF->RemoteLinkLayerAddress != 0) ?
                  IF->LinkLayerAddressLength : 0))) {

                // printf("inconsistent interface info length\n");
                break;
            }

            (*func)(IF, Context);
        }
        else {
            if (BytesReturned != sizeof IF->Next) {
                // printf("inconsistent interface info length\n");
                break;
            }
        }

        if (IF->Next.Index == (u_int) -1)
            break;
        Query = IF->Next;
    }

    FREE(IF);
}

BOOL ReconnectInterface(
    IN PWCHAR AdapterName
    )
{
    UNICODE_STRING GuidString;
    IPV6_QUERY_INTERFACE Query;
    UINT BytesReturned;

    TraceEnter("ReconnectInterface");

    RtlInitUnicodeString(&GuidString, AdapterName);
    if (RtlGUIDFromString(&GuidString, &Query.Guid) != NO_ERROR) {
        return FALSE;
    }

    //
    // Pretend as though the interface was reconnected.
    // This causes the IPv6 stack to resend router solicitation messages.
    //
    Query.Index = 0;    
    if (!DeviceIoControl(Handle,
                         IOCTL_IPV6_RENEW_INTERFACE, &Query, sizeof(Query),
                         NULL, 0, &BytesReturned, NULL)) {
        return FALSE;
    }

    return TRUE;
}

int
UpdateInterface(IPV6_INFO_INTERFACE *Update)
{
    u_int BytesReturned;

    TraceEnter("UpdateInterface");

    return DeviceIoControl(Handle, IOCTL_IPV6_UPDATE_INTERFACE,
                           Update, sizeof *Update,
                           NULL, 0, &BytesReturned, NULL);
}

int
UpdateRouteTable(IPV6_INFO_ROUTE_TABLE *Route)
{
    u_int BytesReturned;

    TraceEnter("UpdateRouteTable");

    return DeviceIoControl(Handle, IOCTL_IPV6_UPDATE_ROUTE_TABLE,
                           Route, sizeof *Route,
                           NULL, 0, &BytesReturned, NULL);
}

int
UpdateAddress(IPV6_UPDATE_ADDRESS *Address)
{
    u_int BytesReturned;

    TraceEnter("UpdateAddress");

    return DeviceIoControl(Handle, IOCTL_IPV6_UPDATE_ADDRESS,
                           Address, sizeof *Address,
                           NULL, 0, &BytesReturned, NULL);
}



//* ConfirmIPv6Reachability
//
//  Pings the specifies IPv6 destination address using
//  the specified timeout in milliseconds.
//
//  The return value is the round-trip latency in milliseconds.
//  (Forced to be at least one.)
//
//  If there is a timeout or failure, returns zero.
//
u_int
ConfirmIPv6Reachability(SOCKADDR_IN6 *Dest, u_int Timeout)
{
    ICMPV6_ECHO_REQUEST request;
    ICMPV6_ECHO_REPLY reply;
    u_long BytesReturned;
    DWORD TickCount;
    char hostname[NI_MAXHOST];

    //
    // REVIEW: Ad hoc testing showed that cisco's relay had problems
    // without this delay.  Need to investigate why.  In the meantime,
    // add a workaround to unblock people.
    //
    Sleep(500);

    getnameinfo((LPSOCKADDR)Dest, sizeof(SOCKADDR_IN6),
                hostname, sizeof(hostname),
                NULL, 0, NI_NUMERICHOST);

    Trace1(FSM, L"ConfirmIPv6Reachability: %hs", hostname);

    CopyTDIFromSA6(&request.DstAddress, Dest);
    memset(&request.SrcAddress, 0, sizeof request.SrcAddress);
    request.Timeout = Timeout;
    request.TTL = 1;
    request.Flags = 0;

    //
    // Start measuring elapsed time.
    //
    TickCount = GetTickCount();

    if (! DeviceIoControl(Handle,
                          IOCTL_ICMPV6_ECHO_REQUEST,
                          &request, sizeof request,
                          &reply, sizeof reply,
                          &BytesReturned,
                          NULL)) {
        // fprintf(stderr, "DeviceIoControl: %u\n", GetLastError());
        return 0;
    }

    if (reply.Status == IP_HOP_LIMIT_EXCEEDED) {
        //
        // We guessed wrong about the relay's IPv6 address, but we have 
        // IPv6 reachability via the IPv6 address in the reply.
        //
        CopySAFromTDI6(Dest, &reply.Address);

        getnameinfo((LPSOCKADDR)Dest, sizeof(SOCKADDR_IN6),
                    hostname, sizeof(hostname),
                    NULL, 0, NI_NUMERICHOST);
    
        Trace1(FSM, L"Got actual IPv6 address: %hs", hostname);

    } else if (reply.Status != IP_SUCCESS) {
        Trace1(ERR,L"Got error %u", reply.Status);
        return 0;
    }

    //
    // Stop the elapsed time measurement.
    //
    TickCount = GetTickCount() - TickCount;
    if (TickCount == 0)
        TickCount = 1;

    return TickCount;
}

IPV6_INFO_INTERFACE *
GetInterfaceStackInfo(WCHAR *strAdapterName)
{
    UNICODE_STRING UGuidStr;
    IPV6_QUERY_INTERFACE Query;
    IPV6_INFO_INTERFACE *IF;
    u_int InfoSize, BytesReturned;
    NTSTATUS Status;

    TraceEnter("GetInterfaceStackInfo");

    InfoSize = sizeof *IF + 2 * MAX_LINK_LAYER_ADDRESS_LENGTH;
    IF = (IPV6_INFO_INTERFACE *) MALLOC(InfoSize);
    if (IF == NULL) 
        return NULL;

    RtlInitUnicodeString(&UGuidStr, strAdapterName);
    Status = RtlGUIDFromString(&UGuidStr, &Query.Guid);
    if (! NT_SUCCESS(Status))
        goto Error;

    Query.Index = 0; // query by guid.

    if (!DeviceIoControl(Handle, IOCTL_IPV6_QUERY_INTERFACE,
                         &Query, sizeof Query,
                         IF, InfoSize, &BytesReturned,
                         NULL))
        goto Error;

    if ((BytesReturned < sizeof *IF) ||
        (IF->Length < sizeof *IF) ||
        (BytesReturned != IF->Length +
         ((IF->LocalLinkLayerAddress != 0) ?
          IF->LinkLayerAddressLength : 0) +
         ((IF->RemoteLinkLayerAddress != 0) ?
          IF->LinkLayerAddressLength : 0)))
        goto Error;

    return IF;

Error:
    FREE(IF);
    return NULL;
}

u_int
Create6over4Interface(IN_ADDR SrcAddr)
{
    struct {
        IPV6_INFO_INTERFACE Info;
        IN_ADDR SrcAddr;
    } Create;
    IPV6_QUERY_INTERFACE Result;
    u_int BytesReturned;

    IPV6_INIT_INFO_INTERFACE(&Create.Info);

    Create.Info.Type  = IPV6_IF_TYPE_TUNNEL_6OVER4;
    Create.Info.NeighborDiscovers = TRUE;
    Create.Info.RouterDiscovers = TRUE;
    Create.Info.LinkLayerAddressLength = sizeof(IN_ADDR);
    Create.Info.LocalLinkLayerAddress = (u_int)
        ((char *)&Create.SrcAddr - (char *)&Create.Info);
    Create.SrcAddr = SrcAddr;

    if (!DeviceIoControl(Handle, IOCTL_IPV6_CREATE_INTERFACE,
                         &Create, sizeof Create,
                         &Result, sizeof Result, &BytesReturned, NULL) ||
        (BytesReturned != sizeof Result)) {
        return 0;
    }

    Trace1(ERR, _T("Created 6over4 interface %d"), Result.Index);

    return Result.Index;
}

u_int
CreateV6V4Interface(IN_ADDR SrcAddr, IN_ADDR DstAddr)
{
    struct {
        IPV6_INFO_INTERFACE Info;
        IN_ADDR SrcAddr;
        IN_ADDR DstAddr;
    } Create;
    IPV6_QUERY_INTERFACE Result;
    u_int BytesReturned;

    IPV6_INIT_INFO_INTERFACE(&Create.Info);

    Create.Info.Type  = IPV6_IF_TYPE_TUNNEL_V6V4;
    Create.Info.PeriodicMLD = TRUE;
    Create.Info.LinkLayerAddressLength = sizeof(IN_ADDR);
    Create.Info.LocalLinkLayerAddress = (u_int)
        ((char *)&Create.SrcAddr - (char *)&Create.Info);
    Create.Info.RemoteLinkLayerAddress = (u_int)
        ((char *)&Create.DstAddr - (char *)&Create.Info);
    Create.SrcAddr = SrcAddr;
    Create.DstAddr = DstAddr;

    if (!DeviceIoControl(Handle, IOCTL_IPV6_CREATE_INTERFACE,
                         &Create, sizeof Create,
                         &Result, sizeof Result, &BytesReturned, NULL) ||
        (BytesReturned != sizeof Result)) {
        return 0;
    }

    Trace1(ERR, _T("Created v6v4 interface %d"), Result.Index);

    return Result.Index;
}

BOOL
DeleteInterface(u_int IfIndex)
{
    IPV6_QUERY_INTERFACE Query;
    u_int BytesReturned;

    Trace1(ERR, _T("Deleting interface %d"), IfIndex);

    Query.Index = IfIndex;

    if (!DeviceIoControl(Handle, IOCTL_IPV6_DELETE_INTERFACE,
                         &Query, sizeof Query,
                         NULL, 0, &BytesReturned, NULL)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
UpdateRouterLinkAddress(u_int IfIndex, IN_ADDR SrcAddr, IN_ADDR DstAddr)
{
    char Buffer[sizeof(IPV6_UPDATE_ROUTER_LL_ADDRESS) + 2 * sizeof(IPAddr)];
    IPV6_UPDATE_ROUTER_LL_ADDRESS *Update =
        (IPV6_UPDATE_ROUTER_LL_ADDRESS *) Buffer;
    IN_ADDR *Addr = (IN_ADDR*) (Update + 1);
    u_int BytesReturned;

    Trace2(FSM, _T("Setting router link address on if %d to %d.%d.%d.%d"),
           IfIndex, PRINT_IPADDR(DstAddr.s_addr));

    Update->IF.Index = IfIndex;
    Addr[0] = SrcAddr;
    Addr[1] = DstAddr;

    if (!DeviceIoControl(Handle, IOCTL_IPV6_UPDATE_ROUTER_LL_ADDRESS,
                         Buffer, sizeof(Buffer),
                         NULL, 0, &BytesReturned, NULL)) {
        Trace1(ERR, _T("DeviceIoControl error %d"), GetLastError());
        return FALSE;
    }

    return TRUE;
}

VOID
GetFirstSitePrefix(
    IN ULONG IfIndex,
    IN IPV6_INFO_SITE_PREFIX *Prefix)
{
    IPV6_QUERY_SITE_PREFIX Query, NextQuery;
    IPV6_INFO_SITE_PREFIX SPE;
    DWORD dwBytesReturned;

    NextQuery.IF.Index = 0;

    for (;;) {
        Query = NextQuery;

        if (!DeviceIoControl(Handle, IOCTL_IPV6_QUERY_SITE_PREFIX,
                             &Query, sizeof Query,
                             &SPE, sizeof SPE, &dwBytesReturned,
                             NULL)) {
            break;
        }

        NextQuery = SPE.Query;

        if (Query.IF.Index != 0) {
            SPE.Query = Query;
            if (Query.IF.Index == IfIndex) {
                *Prefix = SPE;
                return;
            }
        }

        if (NextQuery.IF.Index == 0) {
            break;
        }
    }

    Prefix->Query.IF.Index = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\6to4svc\main.c ===
#include "precomp.h"
#pragma hdrstop


DWORD            g_TraceId        = INVALID_TRACEID;
HANDLE           g_LogHandle      = NULL;
DWORD            g_dwLoggingLevel = 0;
HANDLE           g_Heap           = INVALID_HANDLE_VALUE;
HANDLE           g_Lock           = INVALID_HANDLE_VALUE;

//------------------------------------------------------------------------------
//            _DllStartup
//
// Creates a private heap,
// and creates the global critical section.
//
// Note: no structures must be allocated from heap here, as StartProtocol()
//    if called after StopProtocol() destroys the heap.
// Return Values: TRUE (if no error), else FALSE.
//------------------------------------------------------------------------------
BOOL
DllStartup(
    )
{
    // create a private heap 

    g_Heap = HeapCreate(0, 0, 0);
    if (g_Heap == NULL) {
        goto Error;
    }

    g_Lock = CreateMutex(NULL, FALSE, L"6to4svc mutex");
    if (g_Lock == NULL) {
        goto Error;
    }

    return TRUE;

Error:
    if (g_Heap != NULL) {
        HeapDestroy(g_Heap);
        g_Heap = NULL;
    }
    return FALSE;
}

//------------------------------------------------------------------------------
//            _DllCleanup
//
// Called when the 6to4 dll is being unloaded. StopProtocol() would have
// been called before, and that would have cleaned all the 6to4 structures.
// This call frees the global mutex, destroys the local heap,
//
// Return Value:  TRUE
//------------------------------------------------------------------------------
BOOL
DllCleanup(
    )
{
    CloseHandle(g_Lock);
    g_Lock = INVALID_HANDLE_VALUE;

    // destroy private heap

    if (g_Heap != NULL) {
        HeapDestroy(g_Heap);
        g_Heap = NULL;
    }

    return TRUE;
}

//------------------------------------------------------------------------------
//      _DLLMAIN
//
// Called immediately after 6to4svc.dll is loaded for the first time by the
// process, and when the 6to4svc.dll is unloaded by the process.
// It does some initialization/final cleanup.
//
// Calls: _DllStartup() or _DllCleanup()
//------------------------------------------------------------------------------
BOOL
WINAPI
DLLMAIN (
    HINSTANCE   hModule,
    DWORD       dwReason,
    LPVOID      lpvReserved
    )
{
    BOOL     bErr;

    switch (dwReason) {

        //
        // Startup Initialization of Dll
        //
        case DLL_PROCESS_ATTACH:
        {
            // disable per-thread initialization
            DisableThreadLibraryCalls(hModule);


            // create and initialize global data
            bErr = DllStartup();

            break;
        }

        //
        // Cleanup of Dll
        //
        case DLL_PROCESS_DETACH:
        {
            // free global data
            bErr = DllCleanup();

            break;
        }

        default:
            bErr = TRUE;
            break;

    }
    return bErr;
} // end _DLLMAIN

#ifdef STANDALONE
int __cdecl
main(
    int     argc,
    WCHAR **argv)
{
    if (!DllStartup())
        return 1;

    ServiceMain(argc, argv);

    Sleep(100 * 1000);

    DllCleanup();

    return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\6to4svc\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ndisguid.h>
#include <wmium.h>
#include <winsvc.h>
#include <rtutils.h>
#include <tchar.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdio.h>
#include <iphlpapi.h>
#include <iptypes.h>

#pragma warning(disable:4057) // 'volatile LONG *' differs in indirection to 
                              // slightly different base types from 'ULONG *'
#pragma warning(disable:4100) // unreferenced formal parameter
#pragma warning(disable:4152) // function/data pointer conversion 
#pragma warning(disable:4200) // zero-sized array in struct/union
#pragma warning(disable:4201) // nameless struct/union
#pragma warning(disable:4214) // bit field types other than int

#include <ip6.h>
#include <icmp6.h>
#include <ntddip6.h>
#include <ws2ip6.h>
#include <rasuip.h>
#include <mswsock.h>
#include "trace.h"
#include "6to4.h"
#include "isatap.h"
#include "teredo.h"

#define isnot !=
#define is ==

//
// instead of using goto:end to go to the end of the block, use the following
//
#define BEGIN_BREAKOUT_BLOCK1    do
#define GOTO_END_BLOCK1          goto END_BREAKOUT_BLOCK_1
#define END_BREAKOUT_BLOCK1      while(FALSE); END_BREAKOUT_BLOCK_1:
#define BEGIN_BREAKOUT_BLOCK2    do
#define GOTO_END_BLOCK2          goto END_BREAKOUT_BLOCK_2
#define END_BREAKOUT_BLOCK2      while(FALSE); END_BREAKOUT_BLOCK_2:

extern DWORD            g_TraceId;
extern HANDLE           g_LogHandle;
extern DWORD            g_dwLoggingLevel;
extern HANDLE           g_Heap;
extern HANDLE           g_Lock;

//
// WaitForSingleObject should always succeed, since we should never
// time out, abandon the mutex, or pass an invalid handle.
//
#define ENTER_API() \
        if (WaitForSingleObject(g_Lock, INFINITE) != WAIT_OBJECT_0) \
            ASSERT(FALSE)

#define LEAVE_API() \
        ReleaseMutex(g_Lock)

#define MALLOC(x)       HeapAlloc(g_Heap, 0, x)
#define FREE(x)         HeapFree(g_Heap, 0, x)
#define REALLOC(x, y)   HeapReAlloc(g_Heap, 0, x, y)

#define PROFILE(x)   printf("%s\n", x)

#define PRINT_IPADDR(x) \
    ((x)&0x000000ff),(((x)&0x0000ff00)>>8),(((x)&0x00ff0000)>>16),(((x)&0xff000000)>>24)

VOID WINAPI
ServiceMain(
    IN DWORD   argc,
    IN LPWSTR *argv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\6to4svc\peer.c ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

    peer.c

Abstract:

    This module contains teredo peer management functions.

Author:

    Mohit Talwar (mohitt) Wed Oct 24 14:05:08 2001

Environment:

    Kernel mode only.

--*/

#include "precomp.h"
#pragma hdrstop


__inline
USHORT
TeredoHash(
    IN CONST IN6_ADDR *Address
    )
/*++

Routine Description:

    Hash a peer's teredo IPv6 address.  Used by our static hash table
    implementation.  Sum of mapped address and port words, mod # buckets.

Arguments:

    Address - Supplies the peer's teredo IPv6 address.

Return Value:

    Hashed Value.

--*/
{
    return ((Address->s6_words[1] + // Teredo mapped IPv4 address.
             Address->s6_words[2] + // Teredo mapped IPv4 address.
             Address->s6_words[3])  // Teredo mapped UDP port.
            % BUCKET_COUNT);
}


PTEREDO_PEER
TeredoCreatePeer(
    IN PLIST_ENTRY BucketHead
    )
/*++

Routine Description:

    Creates a teredo peer entry.
    
Arguments:

    BucketHead - Supplies the bucket list head to which the peer belongs.
    
Return Value:

    NO_ERROR or failure code.

Caller LOCK: Client::PeerSet.

--*/
{
    PTEREDO_PEER Peer;

    //
    // Allocate the peer structure from the appropriate heap.
    //
    Peer = (PTEREDO_PEER) HeapAlloc(
        TeredoClient.PeerHeap, 0, sizeof(TEREDO_PEER));
    if (Peer == NULL) {
        return NULL;
    }
    
    //
    // Initialize fields that remain unchanged for used neighors.
    //
    
#if DBG
    Peer->Signature = TEREDO_PEER_SIGNATURE;
#endif // DBG        

    //
    // Insert the peer at the beginning of the LRU list.
    //
    TeredoClient.PeerSet.Size++;
    InsertHeadList(BucketHead, &(Peer->Link));
    
    Peer->ReferenceCount = 1;
    Peer->BubblePosted = FALSE;

    TeredoInitializePacket(&(Peer->Packet));
    Peer->Packet.Type = TEREDO_PACKET_BUBBLE;
    Peer->Packet.Buffer.len = sizeof(IP6_HDR);
    ASSERT(Peer->Packet.Buffer.buf == (PUCHAR) &(Peer->Bubble));
    
    //
    // Create the teredo bubble packet.
    //
    Peer->Bubble.ip6_flow = 0;
    Peer->Bubble.ip6_plen = 0;
    Peer->Bubble.ip6_nxt = IPPROTO_NONE;
    Peer->Bubble.ip6_hlim = IPV6_HOPLIMIT;
    Peer->Bubble.ip6_vfc = IPV6_VERSION;

    //
    // Obtain a reference on the teredo client for the peer.
    //
    TeredoReferenceClient();
    return Peer;
}


VOID
TeredoDestroyPeer(
    IN PTEREDO_PEER Peer
    )
/*++

Routine Description:

    Destroys a peer entry.
    
Arguments:

    Peer - Supplies the peer entry to destroy.
    
Return Value:

    NO_ERROR.

--*/
{
    ASSERT(IsListEmpty(&(Peer->Link)));
    ASSERT(Peer->ReferenceCount == 0);    
    ASSERT(Peer->BubblePosted == FALSE);

    HeapFree(TeredoClient.PeerHeap, 0, (PUCHAR) Peer);
    
    //
    // Release the peer's reference on the teredo client.
    // This might cause the client to be cleaned up, hence we do it last.
    //
    TeredoDereferenceClient();
}


VOID
TeredoInitializePeer(
    OUT PTEREDO_PEER Peer,
    IN CONST IN6_ADDR *Address
    )
/*++

Routine Description:

    Initialize the state of a peer upon creation or reuse.

    The peer is already inserted in the appropriate bucket.
    
Arguments:

    Peer - Returns a peer with its state initialized.
        
    Address - Supplies the peer's teredo IPv6 address.
    
Return Value:

    None.

Caller LOCK: Client::PeerSet.

--*/
{
    ASSERT(Peer->ReferenceCount == 1);
    ASSERT(Peer->BubblePosted == FALSE);
    
    //
    // Reset fields for both new and used peers...
    //
    Peer->LastReceive = Peer->LastTransmit =
        TeredoClient.Time - TEREDO_REFRESH_INTERVAL;
    Peer->Address = *Address;
    Peer->BubbleCount = 0;

    //
    // Teredo mapped UDP port & IPv4 address.
    //
    TeredoParseAddress(
        Address,
        &(Peer->Packet.SocketAddress.sin_addr),
        &(Peer->Packet.SocketAddress.sin_port));

    //
    // Update fields in the teredo bubble packet.
    //
    Peer->Bubble.ip6_dest = Peer->Address;
    // Peer->Bubble.ip6_src... Filled in when sending.
}


VOID
TeredoDeletePeer(
    IN OUT PTEREDO_PEER Peer
    )
/*++

Routine Description:

    Delete a peer from the peer set, thus initiating its destruction.

Arguments:

    Interface - Returns a peer deleted from the peer set.

Return Value:

    None.

Caller LOCK: Client::PeerSet.

--*/
{
    //
    // Unlink the neighbor from the peer set...
    //
    TeredoClient.PeerSet.Size--;
    RemoveEntryList(&(Peer->Link));
    InitializeListHead(&(Peer->Link));
    
    //
    // And release the reference obtained for being in it.
    //
    TeredoDereferencePeer(Peer);
}


BOOL
__inline
TeredoCachedPeer(
    IN PTEREDO_PEER Peer
    )
/*++

Routine Description:

    Determine if the peer belonging to the PeerSet is cached.
    
Arguments:

    Peer - Supplies the peer being inspected.
        The peer should still be a member of the peer set.
        
Return Value:

    TRUE if cached, FALSE otherwise.

--*/
{
    //
    // The peer does belong to a peer set.  Right?
    //
    ASSERT(!IsListEmpty(&(Peer->Link)));
    return (Peer->ReferenceCount == 1);
}


PTEREDO_PEER
TeredoReusePeer(
    IN PLIST_ENTRY BucketHead
    )
/*++

Routine Description:

    Reuse an existing peer entry from the bucket if one is cached.
    
Arguments:

    BucketHead - Supplies the bucket list head to which the peer belongs.

Return Value:

    Peer entry to reuse or NULL.

Caller LOCK: Client::PeerSet.

--*/
{
    PLIST_ENTRY Next;
    PTEREDO_PEER Peer;
    
    Next = BucketHead->Blink;
    if (Next == BucketHead) {
        return NULL;
    }
    
    Peer = Cast(CONTAINING_RECORD(Next, TEREDO_PEER, Link), TEREDO_PEER);
    if (TeredoCachedPeer(Peer)) {
        //
        // Insert the peer at the beginning of the LRU list.
        //
        RemoveEntryList(Next);
        InsertHeadList(BucketHead, Next);
    
        return Peer;
    }

    return NULL;
}


PTEREDO_PEER
TeredoReuseOrCreatePeer(
    IN PLIST_ENTRY BucketHead,
    IN CONST IN6_ADDR *Address
    )
/*++

Routine Description:

    Reuse or create a teredo peer and (re)initialize its state.
    
Arguments:

    BucketHead - Supplies the bucket list head to which the peer belongs.
    
    Address - Supplies the peer's teredo IPv6 address.
    
Return Value:

    Peer entry to use or NULL.

Caller LOCK: Client::PeerSet.

--*/
{
    PTEREDO_PEER Peer;
    
    Peer = TeredoReusePeer(BucketHead);
    if (Peer == NULL) {
        Peer = TeredoCreatePeer(BucketHead);
    }

    if (Peer == NULL) {
        return NULL;
    }
    
    TeredoInitializePeer(Peer, Address);
    return Peer;    
}


PTEREDO_PEER
TeredoFindPeer(
    IN PLIST_ENTRY BucketHead,
    IN CONST IN6_ADDR *Address
    )
/*++

Routine Description:

    Find a peer entry with the given address.
    
Arguments:

    BucketHead - Supplies the bucket list head to which the peer belongs.
    
    Address - Supplies the peer's teredo IPv6 address.
    
Return Value:

    Peer entry or NULL.

Caller LOCK: Client::PeerSet.

--*/
{
    PLIST_ENTRY Next;
    PTEREDO_PEER Peer;

    for (Next = BucketHead->Flink; Next != BucketHead; Next = Next->Flink) {
        Peer = Cast(
            CONTAINING_RECORD(Next, TEREDO_PEER, Link), TEREDO_PEER);
        if (TeredoEqualPrefix(&(Peer->Address), Address)) {
            return Peer;        // found!
        }
    }

    return NULL;                // not found!
}


PTEREDO_PEER
TeredoFindOrCreatePeer(
    IN CONST IN6_ADDR *Address
)
/*++

Routine Description:

    Find a peer entry with the given teredo IPv6 address.

    Create one if the search is unsuccessful.

    Returns a reference on the found/created peer to the caller.

Arguments:

    Address - Supplies the peer's teredo IPv6 address.
    
Return Value:

    Peer entry or NULL.

--*/
{
    PTEREDO_PEER Peer = NULL;
    PLIST_ENTRY Head = TeredoClient.PeerSet.Bucket + TeredoHash(Address);
    
    ASSERT(Address->s6_words[0] == TeredoIpv6ServicePrefix.s6_words[0]);

    //
    // Note: Since we typically do only a small amount of work while holding
    // this lock we don't need it to be a multiple-reader-single-writer lock!
    //
    EnterCriticalSection(&(TeredoClient.PeerSet.Lock));

    if (TeredoClient.State != TEREDO_STATE_OFFLINE) {
        Peer = TeredoFindPeer(Head, Address);
        if (Peer == NULL) {
            Peer = TeredoReuseOrCreatePeer(Head, Address);
        }

        if (Peer != NULL) {
            TeredoReferencePeer(Peer);
        }
    }
    
    LeaveCriticalSection(&(TeredoClient.PeerSet.Lock));
        
    return Peer;
}


DWORD
TeredoInitializePeerSet(
    VOID
    )
/*++

Routine Description:

    Initializes the peer set, organized as a statically sized hash table.
    
Arguments:

    None.

Return Value:

    NO_ERROR or failure code.

--*/ 
{
    ULONG i;

    __try {
        InitializeCriticalSection(&(TeredoClient.PeerSet.Lock));
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        return GetLastError();
    }
    
    TeredoClient.PeerSet.Size = 0;
    for (i = 0; i < BUCKET_COUNT; i++) {
        InitializeListHead(TeredoClient.PeerSet.Bucket + i);
    }

    return NO_ERROR;
}


VOID
TeredoUninitializePeerSet(
    VOID
    )
/*++

Routine Description:

    Uninitializes the peer set.  Typically invoked when going offline.
    Deletes all existing peers.
    
Arguments:

    None.

Return Value:

    None.
    
--*/
{
    PLIST_ENTRY Head, Next;
    PTEREDO_PEER Peer;
    ULONG i;
    
    ASSERT(TeredoClient.State == TEREDO_STATE_OFFLINE);
    
    EnterCriticalSection(&(TeredoClient.PeerSet.Lock));
    
    for (i = 0;
         (i < BUCKET_COUNT) && (TeredoClient.PeerSet.Size != 0);
         i++) {
        Head = TeredoClient.PeerSet.Bucket + i;
        while (!IsListEmpty(Head)) {
            Next = RemoveHeadList(Head);
            Peer = Cast(
                CONTAINING_RECORD(Next, TEREDO_PEER, Link), TEREDO_PEER);
            TeredoDeletePeer(Peer);
        }
    }

    ASSERT(TeredoClient.PeerSet.Size == 0);   // no more, no less

    LeaveCriticalSection(&(TeredoClient.PeerSet.Lock));
}


VOID
TeredoCleanupPeerSet(
    VOID
    )
/*++

Routine Description:

    Cleans up the peer set.  Typically invoked upon service stop.
    All peers should have been deleted.
    
Arguments:

    None.

Return Value:

    None.
    
--*/
{
    ASSERT(TeredoClient.PeerSet.Size == 0); // no more, no less

    DeleteCriticalSection(&(TeredoClient.PeerSet.Lock));    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\6to4svc\proxy.c ===
//
// proxy.c - Generic application level proxy for IPv6/IPv4
//
// This program accepts TCP connections on one socket and port, and 
// forwards data between it and another socket to a given address 
// (default loopback) and port (default same as listening port).
//
// For example, it can make an unmodified IPv4 server look like an IPv6 server.
// Typically, the proxy will run on the same machine as
// the server it is fronting, but that doesn't have to be the case.
//
// Copyright (C) Microsoft Corporation.
// All rights reserved.
//
// History:
//      Original code by Brian Zill.
//      Made into a service by Dave Thaler.
//

#include "precomp.h"
#pragma hdrstop

//
// Configuration parameters.
//
#define BUFFER_SIZE (4 * 1024)

typedef enum {
    Connect,
    Accept,
    Receive,
    Send
} OPERATION;

CONST CHAR *OperationName[]={
    "Connect", 
    "Accept", 
    "Receive", 
    "Send"
};

typedef enum {
    Inbound = 0, // Receive from client, send to server.
    Outbound,    // Receive from server, send to client.
    NumDirections
} DIRECTION;

typedef enum {
    Client = 0,
    Server,
    NumSides
} SIDE;

//
// Information we keep for each port we're proxying on.
//
#define ADDRESS_BUFFER_LENGTH (16 + sizeof(SOCKADDR_IN6))

typedef struct _PORT_INFO {
    LIST_ENTRY Link;
    ULONG ReferenceCount;

    SOCKET ListenSocket;
    SOCKET AcceptSocket;

    BYTE AcceptBuffer[ADDRESS_BUFFER_LENGTH * 2];

    WSAOVERLAPPED Overlapped;
    OPERATION Operation;

    SOCKADDR_STORAGE LocalAddress;
    ULONG LocalAddressLength;
    SOCKADDR_STORAGE RemoteAddress;
    ULONG RemoteAddressLength;

    //
    // A lock protects the connection list for this port.
    //
    CRITICAL_SECTION Lock;
    LIST_ENTRY ConnectionHead;
} PORT_INFO, *PPORT_INFO;

//
// Information we keep for each direction of a bi-directional connection.
//
typedef struct _DIRECTION_INFO {
    WSABUF Buffer;

    WSAOVERLAPPED Overlapped;
    OPERATION Operation;

    struct _CONNECTION_INFO *Connection;
    DIRECTION Direction;
} DIRECTION_INFO, *PDIRECTION_INFO;

//
// Information we keep for each client connection.
//
typedef struct _CONNECTION_INFO {
    LIST_ENTRY Link;
    ULONG ReferenceCount;
    PPORT_INFO Port;

    BOOL HalfOpen;  // Has one side or the other stopped sending?
    BOOL Closing;
    SOCKET Socket[NumSides];
    DIRECTION_INFO DirectionInfo[NumDirections];
} CONNECTION_INFO, *PCONNECTION_INFO;


//
// Global variables.
//
LIST_ENTRY g_GlobalPortList;

LPFN_CONNECTEX ConnectEx = NULL;

//
// Function prototypes.
//

VOID
ProcessReceiveError(
    IN ULONG NumBytes,
    IN LPOVERLAPPED Overlapped,
    IN ULONG Status
    );

VOID
ProcessSendError(
    IN ULONG NumBytes,
    IN LPOVERLAPPED Overlapped,
    IN ULONG Status
    );

VOID
ProcessAcceptError(
    IN ULONG NumBytes,
    IN LPOVERLAPPED Overlapped,
    IN ULONG Status
    );

VOID
ProcessConnectError(
    IN ULONG NumBytes,
    IN LPOVERLAPPED Overlapped,
    IN ULONG Status
    );

VOID APIENTRY
TpProcessWorkItem(
    IN ULONG Status,
    IN ULONG NumBytes,
    IN LPOVERLAPPED Overlapped
    );

//
// Inline functions.
//

__inline
BOOL
SOCKADDR_IS_EQUAL(
    IN CONST SOCKADDR *a,
    IN CONST SOCKADDR *b
    )
{
    if ((a->sa_family != b->sa_family) || (SS_PORT(a) != SS_PORT(b))) {
        return FALSE;
    }

    if (a->sa_family == AF_INET) {
        PSOCKADDR_IN a4 = (PSOCKADDR_IN) a, b4 = (PSOCKADDR_IN) b;        

        return (a4->sin_addr.s_addr == b4->sin_addr.s_addr);
    } else {
        PSOCKADDR_IN6 a6 = (PSOCKADDR_IN6) a, b6 = (PSOCKADDR_IN6) b;        

        ASSERT(a->sa_family == AF_INET6);
        return ((a6->sin6_scope_id == b6->sin6_scope_id) &&
                IN6_ADDR_EQUAL(&(a6->sin6_addr), &(b6->sin6_addr)));
    }    
}

__inline
VOID
ReferenceConnection(
    IN PCONNECTION_INFO Connection,
    IN PTCHAR CallerName
    )
{
    InterlockedIncrement(&Connection->ReferenceCount);
    Trace3(FSM, _T("R++ %d %x %s"),
           Connection->ReferenceCount, Connection, CallerName);
}

__inline
VOID
DereferenceConnection(
    IN OUT PCONNECTION_INFO *ConnectionPtr,
    IN PTCHAR CallerName    
    )
{
    ULONG Value;

    Trace3(FSM, _T("R-- %d %x %s"), 
           (*ConnectionPtr)->ReferenceCount, (*ConnectionPtr), CallerName);    
    Value = InterlockedDecrement(&(*ConnectionPtr)->ReferenceCount);
    if (Value == 0) {
        FREE(*ConnectionPtr);
        *ConnectionPtr = NULL;
    }
}

__inline
VOID
ReferencePort(
    IN PPORT_INFO Port
    )
{
    InterlockedIncrement(&Port->ReferenceCount);
}

__inline
VOID
DereferencePort(
    IN OUT PPORT_INFO *PortPtr
    )
{
    ULONG Value;

    Value = InterlockedDecrement(&(*PortPtr)->ReferenceCount);
    if (Value == 0) {
        ASSERT(IsListEmpty(&(*PortPtr)->ConnectionHead));
        DeleteCriticalSection(&(*PortPtr)->Lock);
        FREE(*PortPtr);
        *PortPtr = NULL;
    }
}

//
// Allocate and initialize state for a new client connection.
//
PCONNECTION_INFO
NewConnection(
    IN SOCKET ClientSocket,
    IN ULONG ConnectFamily
    )
{
    PCONNECTION_INFO Connection;
    SOCKET ServerSocket;
    
    //
    // Allocate space for a CONNECTION_INFO structure and two buffers.
    //
    Connection = MALLOC(sizeof(*Connection) + (2 * BUFFER_SIZE));
    if (Connection == NULL) {
        return NULL;
    }
    ZeroMemory(Connection, sizeof(*Connection));

    ServerSocket = socket(ConnectFamily, SOCK_STREAM, 0);
    if (ServerSocket == INVALID_SOCKET) {
        FREE(Connection);
        return NULL;
    }
    
    //
    // Fill everything in (start out receiving in both directions).
    //
    Connection->HalfOpen = FALSE;
    Connection->Closing = FALSE;

    Connection->Socket[Client] = ClientSocket;
    Connection->DirectionInfo[Inbound].Direction = Inbound;
    Connection->DirectionInfo[Inbound].Operation = Receive;
    Connection->DirectionInfo[Inbound].Buffer.len = BUFFER_SIZE;
    Connection->DirectionInfo[Inbound].Buffer.buf = (char *)(Connection + 1);
    Connection->DirectionInfo[Inbound].Connection = Connection;

    Connection->Socket[Server] = ServerSocket;
    Connection->DirectionInfo[Outbound].Direction = Outbound;
    Connection->DirectionInfo[Outbound].Operation = Receive;
    Connection->DirectionInfo[Outbound].Buffer.len = BUFFER_SIZE;
    Connection->DirectionInfo[Outbound].Buffer.buf =
        Connection->DirectionInfo[Inbound].Buffer.buf + BUFFER_SIZE;
    Connection->DirectionInfo[Outbound].Connection = Connection;

    Connection->ReferenceCount = 0;

    ReferenceConnection(Connection, _T("NewConnection"));

    return Connection;
}

//
// Start an asynchronous accept.
//
// Assumes caller holds a reference on Port.
//
DWORD
StartAccept(
    IN PPORT_INFO Port
    )
{
    ULONG Status, Junk;

    ASSERT(Port->ReferenceCount > 0);

    //
    // Count another reference for the operation.
    //
    ReferencePort(Port);

    Port->AcceptSocket = socket(Port->LocalAddress.ss_family, SOCK_STREAM, 0);
    if (Port->AcceptSocket == INVALID_SOCKET) {
        Status = WSAGetLastError();
        ProcessAcceptError(0, &Port->Overlapped, Status);
        return Status;
    }

    Trace2(SOCKET, _T("Starting an accept with new socket %x ovl %p"),
           Port->AcceptSocket, &Port->Overlapped);

    Port->Overlapped.hEvent = NULL;

    Port->Operation = Accept;
    if (!AcceptEx(Port->ListenSocket,
                  Port->AcceptSocket,
                  Port->AcceptBuffer, // only used to hold addresses
                  0,
                  ADDRESS_BUFFER_LENGTH,
                  ADDRESS_BUFFER_LENGTH,
                  &Junk,
                  &Port->Overlapped)) {

        Status = WSAGetLastError();
        if (Status != ERROR_IO_PENDING) {
            ProcessAcceptError(0, &Port->Overlapped, Status);
            return Status;
        }
    }

    return NO_ERROR;
}

//
// Start an asynchronous connect.
//
// Assumes caller holds a reference on Connection.
//
DWORD
StartConnect(
    IN PCONNECTION_INFO Connection,
    IN PPORT_INFO Port
    )
{
    ULONG Status, Junk;
    SOCKADDR_STORAGE LocalAddress;

    //
    // Count a reference for the operation.
    //
    ReferenceConnection(Connection, _T("StartConnect"));

    ASSERT(Connection->Socket[Server] != INVALID_SOCKET);

    ZeroMemory(&LocalAddress, Port->RemoteAddressLength);
    LocalAddress.ss_family = Port->RemoteAddress.ss_family;

    if (bind(Connection->Socket[Server], (LPSOCKADDR)&LocalAddress, 
             Port->RemoteAddressLength) == SOCKET_ERROR) {
        Status = WSAGetLastError();
        ProcessConnectError(0, &Connection->DirectionInfo[Inbound].Overlapped, 
                            Status);
        return Status;
    }

    if (!BindIoCompletionCallback((HANDLE)Connection->Socket[Server],
                                  TpProcessWorkItem,
                                  0)) {
        Status = GetLastError();
        ProcessConnectError(0, &Connection->DirectionInfo[Inbound].Overlapped, 
                            Status);
        return Status;
    }

    if (ConnectEx == NULL) {
        GUID Guid = WSAID_CONNECTEX;

        if (WSAIoctl(Connection->Socket[Server],
                     SIO_GET_EXTENSION_FUNCTION_POINTER,
                     &Guid,
                     sizeof(Guid),
                     &ConnectEx,
                     sizeof(ConnectEx),
                     &Junk,
                     NULL, NULL) == SOCKET_ERROR) {

            ProcessConnectError(0, 
                                &Connection->DirectionInfo[Inbound].Overlapped,
                                WSAGetLastError());
        }
    }

    Trace2(SOCKET, _T("Starting a connect with socket %x ovl %p"),
           Connection->Socket[Server], 
           &Connection->DirectionInfo[Inbound].Overlapped);

    Connection->DirectionInfo[Inbound].Operation = Connect;
    if (!ConnectEx(Connection->Socket[Server],
                   (LPSOCKADDR)&Port->RemoteAddress,
                   Port->RemoteAddressLength,
                   NULL, 0,
                   &Junk,
                   &Connection->DirectionInfo[Inbound].Overlapped)) {

        Status = WSAGetLastError();
        if (Status != ERROR_IO_PENDING) {
            ProcessConnectError(0, 
                                &Connection->DirectionInfo[Inbound].Overlapped,
                                Status);
            return Status;
        }
    }
                   
    return NO_ERROR;
}

//
// Start an asynchronous receive.
//
// Assumes caller holds a reference on Connection.
//
VOID
StartReceive(
    IN PDIRECTION_INFO DirectionInfo
    )
{
    ULONG Status;
    PCONNECTION_INFO Connection =
        CONTAINING_RECORD(DirectionInfo, CONNECTION_INFO,
                          DirectionInfo[DirectionInfo->Direction]);

    Trace3(SOCKET, _T("starting ReadFile on socket %x with Dir %p ovl %p"), 
           Connection->Socket[DirectionInfo->Direction], DirectionInfo,
           &DirectionInfo->Overlapped);

    //
    // Count a reference for the operation.
    //
    ReferenceConnection(Connection, _T("StartReceive"));

    ASSERT(DirectionInfo->Overlapped.hEvent == NULL);
    ASSERT(DirectionInfo->Buffer.len > 0);
    ASSERT(DirectionInfo->Buffer.buf != NULL);

    DirectionInfo->Operation = Receive;

    Trace4(SOCKET, _T("ReadFile %x %p %d %p"), 
           Connection->Socket[DirectionInfo->Direction],
           &DirectionInfo->Buffer.buf,
           DirectionInfo->Buffer.len,
           &DirectionInfo->Overlapped);

    //
    // Post receive buffer.
    //
    if (!ReadFile((HANDLE)Connection->Socket[DirectionInfo->Direction],
                  DirectionInfo->Buffer.buf,
                  DirectionInfo->Buffer.len,
                  NULL,
                  &DirectionInfo->Overlapped)) {

        Status = GetLastError();
        if (Status != ERROR_IO_PENDING) {
            ProcessReceiveError(0, &DirectionInfo->Overlapped, Status);
            return;
        }
    }
}

//
// Start an asynchronous send.
//
// Assumes caller holds a reference on Connection.
//
VOID
StartSend(
    IN PDIRECTION_INFO DirectionInfo,
    IN ULONG NumBytes
    )
{
    ULONG BytesSent, Status;
    PCONNECTION_INFO Connection =
        CONTAINING_RECORD(DirectionInfo, CONNECTION_INFO, 
                          DirectionInfo[DirectionInfo->Direction]);

    Trace3(SOCKET, _T("starting WriteFile on socket %x with Dir %p ovl %p"), 
           Connection->Socket[1 - DirectionInfo->Direction], DirectionInfo,
           &DirectionInfo->Overlapped);

    //
    // Count a reference for the operation.
    //
    ReferenceConnection(Connection, _T("StartSend"));

    DirectionInfo->Operation = Send;

    //
    // Post send buffer.
    //
    if (!WriteFile((HANDLE)Connection->Socket[1 - DirectionInfo->Direction],
                   DirectionInfo->Buffer.buf,
                   NumBytes,
                   &BytesSent,
                   &DirectionInfo->Overlapped)) {

        Status = GetLastError();
        if (Status != ERROR_IO_PENDING) {
            Trace1(ERR, _T("WriteFile 1 failed %d"), Status);
            ProcessSendError(0, &DirectionInfo->Overlapped, Status);
            return;
        }
    }
}

//
// This gets called when we want to start proxying for a new port.
//
DWORD
StartUpPort(
    IN PPORT_INFO Port
    )
{
    ULONG Status = NO_ERROR;
    CHAR LocalBuffer[256];
    CHAR RemoteBuffer[256];
    ULONG Length;

    __try {
        InitializeCriticalSection(&Port->Lock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        return GetLastError();
    }

    //
    // Add an initial reference.
    //
    ReferencePort(Port);

    InitializeListHead(&Port->ConnectionHead);

    Port->ListenSocket = socket(Port->LocalAddress.ss_family, SOCK_STREAM, 0);
    if (Port->ListenSocket == INVALID_SOCKET) {
        Status = WSAGetLastError();
        Trace1(ERR, _T("socket() failed with error %u"), Status);
        return Status;
    }
    
    if (bind(Port->ListenSocket, (LPSOCKADDR)&Port->LocalAddress, 
             Port->LocalAddressLength) == SOCKET_ERROR) {
        Trace1(ERR, _T("bind() failed with error %u"), WSAGetLastError());
        goto Fail;
    }

    if (listen(Port->ListenSocket, 5) == SOCKET_ERROR) {
        Trace1(ERR, _T("listen() failed with error %u"), WSAGetLastError());
        goto Fail;
    }

    if (!BindIoCompletionCallback((HANDLE)Port->ListenSocket,
                                  TpProcessWorkItem,
                                  0)) {
        Trace1(ERR, _T("BindIoCompletionCallback() failed with error %u"), 
                    GetLastError());
        goto Fail;
    }

    Length = sizeof(LocalBuffer);
    LocalBuffer[0] = '\0';
    WSAAddressToStringA((LPSOCKADDR)&Port->LocalAddress, 
                        Port->LocalAddressLength, NULL, LocalBuffer, &Length);

    Length = sizeof(RemoteBuffer);
    RemoteBuffer[0] = '\0';
    WSAAddressToStringA((LPSOCKADDR)&Port->RemoteAddress, 
                        Port->RemoteAddressLength, NULL, RemoteBuffer, &Length);
                        
    Trace2(FSM, _T("Proxying %hs to %hs"), LocalBuffer, RemoteBuffer);

    //
    // Start an asynchronous accept
    //
    return StartAccept(Port);

Fail:
    closesocket(Port->ListenSocket);
    Port->ListenSocket = INVALID_SOCKET;
    return WSAGetLastError();
}

VOID
CloseConnection(
    IN OUT PCONNECTION_INFO *ConnectionPtr
    )
{
    PCONNECTION_INFO Connection = (*ConnectionPtr);
    PPORT_INFO Port = Connection->Port;

    if (InterlockedExchange((PLONG) &Connection->Closing, TRUE) != FALSE) {
        //
        // Nothing to do.
        //
        return;
    }

    Trace2(SOCKET, _T("Closing client socket %x and server socket %x"),
           Connection->Socket[Client],
           Connection->Socket[Server]);

    closesocket(Connection->Socket[Client]);
    closesocket(Connection->Socket[Server]);

    EnterCriticalSection(&Port->Lock);
    {
        RemoveEntryList(&Connection->Link);
    }
    LeaveCriticalSection(&Port->Lock);

    //
    // Release the connection's reference on the port.
    //
    DereferencePort(&Port);

    DereferenceConnection(ConnectionPtr, _T("CloseConnection"));
}

//
// This gets called when we want to stop proxying for a given port.
//
VOID
ShutDownPort(
    IN PPORT_INFO *PortPtr
    )
{
    PLIST_ENTRY ple, pleNext, pleHead;
    PCONNECTION_INFO Connection;
    PPORT_INFO Port = *PortPtr;

    //
    // Close any connections.
    //
    EnterCriticalSection(&Port->Lock);
    pleHead = &(Port->ConnectionHead);
    for (ple = pleHead->Flink; ple != pleHead; ple = pleNext) {
        pleNext = ple->Flink;
        Connection = CONTAINING_RECORD(ple, CONNECTION_INFO, Link);
        CloseConnection(&Connection);
    }
    LeaveCriticalSection(&Port->Lock);

    closesocket(Port->ListenSocket);
    Port->ListenSocket = INVALID_SOCKET;

    Trace1(FSM, _T("Shut down port %u"),
           RtlUshortByteSwap(SS_PORT(&Port->RemoteAddress)));

    //
    // Release the reference added by StartUpPort.
    //
    DereferencePort(PortPtr);
}

typedef enum {
    V4TOV4,
    V4TOV6,
    V6TOV4,
    V6TOV6
} PPTYPE, *PPPTYPE;

typedef struct {
    ULONG ListenFamily;
    ULONG ConnectFamily;
    PWCHAR KeyString;
} PPTYPEINFO, *PPPTYPEINFO;

#define KEY_V4TOV4 L"v4tov4"
#define KEY_V4TOV6 L"v4tov6"
#define KEY_V6TOV4 L"v6tov4"
#define KEY_V6TOV6 L"v6tov6"

#define KEY_PORTS L"System\\CurrentControlSet\\Services\\PortProxy"

PPTYPEINFO PpTypeInfo[] = {
    { AF_INET,  AF_INET,  KEY_V4TOV4 },
    { AF_INET,  AF_INET6, KEY_V4TOV6 },
    { AF_INET6, AF_INET,  KEY_V6TOV4 },
    { AF_INET6, AF_INET6, KEY_V6TOV6 },
};

//
// Given new configuration data, make any changes needed.
//
VOID
ApplyNewPortList(
    IN OUT PLIST_ENTRY pleNewList
    )
{
    PPORT_INFO pOld, pNew;
    PLIST_ENTRY pleOld, pleNew, pleNext, pleOldList;

    ENTER_API();

    //
    // Compare against old port list.
    //
    pleOldList = &(g_GlobalPortList);

    for (pleOld = pleOldList->Flink; pleOld != pleOldList; pleOld = pleNext) {
        pleNext = pleOld->Flink;
        pOld = CONTAINING_RECORD(pleOld, PORT_INFO, Link);

        for (pleNew = pleNewList->Flink;
             pleNew != pleNewList;
             pleNew = pleNew->Flink) {
            pNew = CONTAINING_RECORD(pleNew, PORT_INFO, Link);
            if (SOCKADDR_IS_EQUAL((PSOCKADDR) &pNew->LocalAddress,
                                  (PSOCKADDR) &pOld->LocalAddress)) {
                break;
            }
        }
        if (pleNew == pleNewList) {
            //
            // Shut down an old proxy port.
            //
            RemoveEntryList(pleOld);
            ShutDownPort(&pOld);
        }
    }

    for (pleNew = pleNewList->Flink; pleNew != pleNewList; pleNew = pleNext) {
        pleNext = pleNew->Flink;
        pNew = CONTAINING_RECORD(pleNew, PORT_INFO, Link);
        
        for (pleOld = pleOldList->Flink;
             pleOld != pleOldList;
             pleOld = pleOld->Flink) {
            pOld = CONTAINING_RECORD(pleOld, PORT_INFO, Link);
            if (SOCKADDR_IS_EQUAL((PSOCKADDR) &pOld->LocalAddress,
                                  (PSOCKADDR) &pNew->LocalAddress)) {
                //
                // Update remote address.
                //
                pOld->RemoteAddress = pNew->RemoteAddress;
                pOld->RemoteAddressLength = pNew->RemoteAddressLength;
                break;
            }
        }
        if (pleOld == pleOldList) {
            //
            // Start up a new proxy port.
            //
            RemoveEntryList(pleNew);
            InsertTailList(pleOldList, pleNew);

            if (StartUpPort(pNew) != NO_ERROR) {
                RemoveEntryList(pleNew);
                //
                // Insert the failed port at the head of the new list
                // so we don't try to start it up again.
                //
                InsertHeadList(pleNewList, pleNew);
            }
        }
    }

    LEAVE_API();
}

//
// Reads from the registry one type of proxying (e.g., v6-to-v4).
//
VOID
AppendType(
    IN PLIST_ENTRY Head, 
    IN HKEY hPorts, 
    IN PPTYPE Type
    )
{
    ADDRINFOW ListenHints, ConnectHints;
    PADDRINFOW LocalAi, RemoteAi;
    ULONG ListenChars, dwType, ConnectBytes, i;
    WCHAR ListenBuffer[256], *ListenAddress, *ListenPort;
    WCHAR ConnectAddress[256], *ConnectPort;
    PPORT_INFO Port;
    ULONG Status;
    HKEY hType, hProto;

    ZeroMemory(&ListenHints, sizeof(ListenHints));
    ListenHints.ai_family = PpTypeInfo[Type].ListenFamily;
    ListenHints.ai_socktype = SOCK_STREAM;
    ListenHints.ai_flags = AI_PASSIVE;

    ZeroMemory(&ConnectHints, sizeof(ConnectHints));
    ConnectHints.ai_family = PpTypeInfo[Type].ConnectFamily;
    ConnectHints.ai_socktype = SOCK_STREAM;

    Status = RegOpenKeyExW(hPorts, PpTypeInfo[Type].KeyString, 0, 
                           KEY_QUERY_VALUE, &hType);
    if (Status != NO_ERROR) {
        return;
    }

    Status = RegOpenKeyExW(hType, L"tcp", 0, KEY_QUERY_VALUE, &hProto);
    if (Status != NO_ERROR) {
        RegCloseKey(hType);
        return;
    }

    for (i=0; ; i++) {
        ListenChars = sizeof(ListenBuffer)/sizeof(WCHAR);
        ConnectBytes = sizeof(ConnectAddress);
        Status = RegEnumValueW(hProto, i, ListenBuffer, &ListenChars, NULL, 
                               &dwType, (PVOID)ConnectAddress, &ConnectBytes);
        if (Status != NO_ERROR) {
            break;
        }
        
        if (dwType != REG_SZ) {
            continue;
        }

        ListenPort = wcschr(ListenBuffer, L'/');
        if (ListenPort) {
            //
            // Replace slash with NULL, so we have 2 strings to pass
            // to getaddrinfo.
            //
            if (ListenBuffer[0] == '*') {
                ListenAddress = NULL;
            } else {
                ListenAddress = ListenBuffer;
            }
            *ListenPort++ = '\0';
        } else {
            //
            // If the address data didn't include a connect address
            // use NULL.
            //
            ListenAddress = NULL;
            ListenPort = ListenBuffer;
        }

        ConnectPort = wcschr(ConnectAddress, '/');
        if (ConnectPort) {
            //
            // Replace slash with NULL, so we have 2 strings to pass
            // to getaddrinfo.
            //
            *ConnectPort++ = '\0';
        } else {
            //
            // If the address data didn't include a remote port number,
            // use the same port as the local port number.
            //
            ConnectPort = ListenPort;
        }

        Status = GetAddrInfoW(ConnectAddress, ConnectPort, &ConnectHints, 
                              &RemoteAi);
        if (Status != NO_ERROR) {
            continue;
        }

        Status = GetAddrInfoW(ListenAddress, ListenPort, &ListenHints, 
                              &LocalAi);
        if (Status != NO_ERROR) {
            FreeAddrInfoW(RemoteAi);
            continue;
        }

        Port = MALLOC(sizeof(PORT_INFO));
        if (Port) {
            ZeroMemory(Port, sizeof(PORT_INFO));
            InsertTailList(Head, &Port->Link);

            memcpy(&Port->RemoteAddress, RemoteAi->ai_addr, RemoteAi->ai_addrlen);
            Port->RemoteAddressLength = (ULONG)RemoteAi->ai_addrlen;
            memcpy(&Port->LocalAddress, LocalAi->ai_addr, LocalAi->ai_addrlen);
            Port->LocalAddressLength = (ULONG)LocalAi->ai_addrlen;
        }

        FreeAddrInfoW(RemoteAi);
        FreeAddrInfoW(LocalAi);
    }

    RegCloseKey(hProto);
    RegCloseKey(hType);
}

//
// Read new configuration data from the registry and see what's changed.
//
VOID
UpdateGlobalPortState(
    IN PVOID Unused
    )
{
    LIST_ENTRY PortHead, *ple;
    PPORT_INFO Port;
    HKEY hPorts;

    InitializeListHead(&PortHead);

    //
    // Read new port list from registry and initialize per-port proxy state.
    //
    if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, KEY_PORTS, 0, KEY_QUERY_VALUE,
                      &hPorts) == NO_ERROR) {
        AppendType(&PortHead, hPorts, V4TOV4);
        AppendType(&PortHead, hPorts, V4TOV6);
        AppendType(&PortHead, hPorts, V6TOV4);
        AppendType(&PortHead, hPorts, V6TOV6);

        RegCloseKey(hPorts);
    }

    ApplyNewPortList(&PortHead);

    //
    // Free new port list.
    //
    while (!IsListEmpty(&PortHead)) {
        ple = RemoveHeadList(&PortHead);
        Port = CONTAINING_RECORD(ple, PORT_INFO, Link);
        FREE(Port);
    }
}

//
// Force UpdateGlobalPortState to be executed in a persistent thread,
// since we need to make sure that the asynchronous IO routines are
// started in a thread that won't go away before the operation completes.
//
BOOL
QueueUpdateGlobalPortState(
    IN PVOID Unused
    )
{
    NTSTATUS nts = QueueUserWorkItem(
        (LPTHREAD_START_ROUTINE)UpdateGlobalPortState,
        (PVOID)Unused,
        WT_EXECUTEINPERSISTENTTHREAD);

    return NT_SUCCESS(nts);
}

VOID
InitializePorts(
    VOID
    )
{
    InitializeListHead(&g_GlobalPortList);
}

VOID
UninitializePorts(
    VOID
    )
{
    LIST_ENTRY Empty;

    //
    // Check if ports got initialized to begin with.
    //
    if (g_GlobalPortList.Flink == NULL)
        return;

    InitializeListHead(&Empty);
    ApplyNewPortList(&Empty);
}


//////////////////////////////////////////////////////////////////////////////
// Event handlers
//////////////////////////////////////////////////////////////////////////////

//
// This is called when an asynchronous accept completes successfully.
//
VOID
ProcessAccept(
    IN ULONG NumBytes,
    IN LPOVERLAPPED Overlapped
    )
{
    PPORT_INFO Port = CONTAINING_RECORD(Overlapped, PORT_INFO, Overlapped);
    SOCKADDR_IN6 *psinLocal, *psinRemote;
    int iLocalLen, iRemoteLen;
    PCONNECTION_INFO Connection;
    ULONG Status;

    //
    // Accept incoming connection.
    //
    GetAcceptExSockaddrs(Port->AcceptBuffer,
                         0,
                         ADDRESS_BUFFER_LENGTH,
                         ADDRESS_BUFFER_LENGTH,
                         (LPSOCKADDR*)&psinLocal,
                         &iLocalLen,
                         (LPSOCKADDR*)&psinRemote,
                         &iRemoteLen );

    if (!BindIoCompletionCallback((HANDLE)Port->AcceptSocket,
                                  TpProcessWorkItem,
                                  0)) {
        Status = GetLastError();
        Trace2(SOCKET, 
               _T("BindIoCompletionCallback failed on socket %x with error %u"),
               Port->AcceptSocket, Status);
        ProcessAcceptError(NumBytes, Overlapped, Status);
        return;
    }

    //
    // Call SO_UPDATE_ACCEPT_CONTEXT so that the AcceptSocket will be valid
    // in other winsock calls like shutdown().
    //
    if (setsockopt(Port->AcceptSocket,
                   SOL_SOCKET,
                   SO_UPDATE_ACCEPT_CONTEXT,
                   (char *)&Port->ListenSocket,
                   sizeof(Port->ListenSocket)) == SOCKET_ERROR) {
        Status = WSAGetLastError();
        Trace2(SOCKET, 
               _T("SO_UPDATE_ACCEPT_CONTEXT failed on socket %x with error %u"),
               Port->AcceptSocket, Status);
        ProcessAcceptError(NumBytes, Overlapped, Status);
        return;
    }

    //
    // Create connection state.
    //
    Connection = NewConnection(Port->AcceptSocket, 
                               Port->RemoteAddress.ss_family);
    if (Connection != NULL) {
        //
        // Add connection to port's list.
        //
        EnterCriticalSection(&Port->Lock);
        {
            //
            // Add a reference for the connection on the port.
            //
            ReferencePort(Port);
            Connection->Port = Port;
            InsertTailList(&Port->ConnectionHead, &Connection->Link);
        }
        LeaveCriticalSection(&Port->Lock);

        //
        // Connect to real server on client's behalf.
        //
        StartConnect(Connection, Port);
    } else {
        closesocket(Port->AcceptSocket);
    }    

    //
    // Start next accept.
    //
    StartAccept(Port);

    //
    // Release the reference from the original accept.
    //
    DereferencePort(&Port);    
}

//
// This is called when an asynchronous accept completes with an error.
//
VOID
ProcessAcceptError(
    IN ULONG NumBytes,
    IN LPOVERLAPPED Overlapped,
    IN ULONG Status
    )
{
    PPORT_INFO Port = CONTAINING_RECORD(Overlapped, PORT_INFO, Overlapped);

    if (Status == ERROR_MORE_DATA) {
        ProcessAccept(NumBytes, Overlapped);
        return;
    } else {
        //
        // This happens at shutdown time when the accept
        // socket gets closed.
        // 
        Trace3(ERR, _T("Accept failed with port=%p nb=%d err=%x"),
               Port, NumBytes, Status);
    }

    //
    // Release the reference from the accept.
    //
    DereferencePort(&Port);
}

//
// This is called when an asynchronous connect completes successfully.
//
VOID
ProcessConnect(
    IN ULONG NumBytes,
    IN LPOVERLAPPED Overlapped
    )
{
    PDIRECTION_INFO pInbound = CONTAINING_RECORD(Overlapped, DIRECTION_INFO, 
                                                 Overlapped);
    PCONNECTION_INFO Connection = CONTAINING_RECORD(pInbound, CONNECTION_INFO, 
                                               DirectionInfo[Inbound]);
    ULONG Status;

    Trace3(SOCKET, _T("Connect succeeded with %d bytes with ovl %p socket %x"),
           NumBytes, Overlapped, Connection->Socket[Server]);


    //
    // Call SO_UPDATE_CONNECT_CONTEXT so that the socket will be valid
    // in other winsock calls like shutdown().
    //
    if (setsockopt(Connection->Socket[Server],
                   SOL_SOCKET,
                   SO_UPDATE_CONNECT_CONTEXT,
                   NULL,
                   0) == SOCKET_ERROR) {
        Status = WSAGetLastError();
        Trace2(SOCKET,
               _T("SO_UPDATE_CONNECT_CONTEXT failed on socket %x with error %u"),
               Connection->Socket[Server], Status);
        ProcessConnectError(NumBytes, Overlapped, Status);
        return;
    }

    StartReceive(&Connection->DirectionInfo[Inbound]);
    StartReceive(&Connection->DirectionInfo[Outbound]);

    //
    // Release the reference from the connect.
    //
    DereferenceConnection(&Connection, _T("ProcessConnect"));
}

//
// This is called when an asynchronous connect completes with an error.
//
VOID
ProcessConnectError(
    IN ULONG NumBytes,
    IN LPOVERLAPPED Overlapped,
    IN ULONG Status
    )
{
    PDIRECTION_INFO pInbound = CONTAINING_RECORD(Overlapped, DIRECTION_INFO, 
                                                 Overlapped);
    PCONNECTION_INFO Connection = CONTAINING_RECORD(pInbound, CONNECTION_INFO, 
                                               DirectionInfo[Inbound]);

    Trace1(ERR, _T("ProcessConnectError saw error %x"), Status);

    CloseConnection(&Connection);

    //
    // Release the reference from the connect.
    //
    DereferenceConnection(&Connection, _T("ProcessConnectError"));
}

//
// This is called when an asynchronous send completes successfully.
//
VOID
ProcessSend(
    IN ULONG NumBytes,
    IN LPOVERLAPPED Overlapped
    )
{
    PDIRECTION_INFO DirectionInfo =
        CONTAINING_RECORD(Overlapped, DIRECTION_INFO, Overlapped);
    PCONNECTION_INFO Connection =
        CONTAINING_RECORD(DirectionInfo, CONNECTION_INFO, 
                          DirectionInfo[DirectionInfo->Direction]);

    //
    // Post another recv request since we but live to serve.
    //
    StartReceive(DirectionInfo);

    //
    // Release the reference from the send.
    //
    DereferenceConnection(&Connection, _T("ProcessSend"));
}

//
// This is called when an asynchronous send completes with an error.
//
VOID
ProcessSendError(
    IN ULONG NumBytes,
    IN LPOVERLAPPED Overlapped,
    IN ULONG Status
    )
{
    PDIRECTION_INFO DirectionInfo =
        CONTAINING_RECORD(Overlapped, DIRECTION_INFO, Overlapped);
    PCONNECTION_INFO Connection =
        CONTAINING_RECORD(DirectionInfo, CONNECTION_INFO, 
                          DirectionInfo[DirectionInfo->Direction]);

    Trace3(FSM, _T("WriteFile on ovl %p failed with error %u = 0x%x"), 
           Overlapped, Status, Status);

    if (Status == ERROR_NETNAME_DELETED) {
        struct linger Linger;

        Trace2(FSM, _T("Connection %p %hs was reset"), Connection,
               (DirectionInfo->Direction == Inbound)? "inbound" : "outbound");

        //
        // Prepare to forward the reset, if we can.
        //
        ZeroMemory(&Linger, sizeof(Linger));
        setsockopt(Connection->Socket[DirectionInfo->Direction],
                   SOL_SOCKET, SO_LINGER, (char*)&Linger,
                   sizeof(Linger));
    } else {
        Trace1(ERR, _T("Send failed with error %u"), Status);
    }

    if (Connection->HalfOpen == FALSE) {
        //
        // Other side is still around, tell it to quit.
        //
        Trace1(SOCKET, _T("Starting a shutdown on socket %x"),
               Connection->Socket[DirectionInfo->Direction]);

        if (shutdown(Connection->Socket[DirectionInfo->Direction], SD_RECEIVE)
             == SOCKET_ERROR) {

            Status = WSAGetLastError();
            Trace2(SOCKET, _T("shutdown failed with error %u = 0x%x"),
                   Status, Status);
            CloseConnection(&Connection);
        } else {
            Connection->HalfOpen = TRUE;
        }
    } else {
        CloseConnection(&Connection);
    }

    //
    // Release the reference from the send.
    //
    DereferenceConnection(&Connection, _T("ProcessSendError"));
}

//
// This is called when an asynchronous receive completes successfully.
//
VOID
ProcessReceive(
    IN ULONG NumBytes,
    IN LPOVERLAPPED Overlapped
    )
{
    PDIRECTION_INFO DirectionInfo;
    PCONNECTION_INFO Connection;

    if (NumBytes == 0) {
        //
        // Other side initiated a close.
        //
        ProcessReceiveError(0, Overlapped, ERROR_NETNAME_DELETED);
        return;
    }

    DirectionInfo = CONTAINING_RECORD(Overlapped, DIRECTION_INFO, Overlapped);
    Connection = CONTAINING_RECORD(DirectionInfo, CONNECTION_INFO, 
                                   DirectionInfo[DirectionInfo->Direction]);

    Trace2(SOCKET, _T("Dir %d got %d bytes"),
           DirectionInfo->Direction, NumBytes);

    //
    // Connection is still active, and we received some data.
    // Post a send request to forward it onward.
    //
    StartSend(DirectionInfo, NumBytes);

    //
    // Release the reference from the receive.
    //
    DereferenceConnection(&Connection, _T("ProcessReceive"));
}

//
// This is called when an asynchronous receive completes with an error.
//
VOID
ProcessReceiveError(
    IN ULONG NumBytes,
    IN LPOVERLAPPED Overlapped,
    IN ULONG Status
    )
{
    PDIRECTION_INFO DirectionInfo =
        CONTAINING_RECORD(Overlapped, DIRECTION_INFO, Overlapped);
    PCONNECTION_INFO Connection =
        CONTAINING_RECORD(DirectionInfo, CONNECTION_INFO, 
                          DirectionInfo[DirectionInfo->Direction]);

    Trace3(ERR, _T("ReadFile on ovl %p failed with error %u = 0x%x"), 
           Overlapped, Status, Status);

    if (Status == ERROR_NETNAME_DELETED) {
        struct linger Linger;

        Trace2(FSM, _T("Connection %p %hs was reset"), Connection,
               (DirectionInfo->Direction == Inbound)? "inbound" : "outbound");

        //
        // Prepare to forward the reset, if we can.
        //
        ZeroMemory(&Linger, sizeof(Linger));
        setsockopt(Connection->Socket[1 - DirectionInfo->Direction],
                   SOL_SOCKET, SO_LINGER, (char*)&Linger,
                   sizeof(Linger));
    } else {
        Trace1(ERR, _T("Receive failed with error %u"), Status);
    }

    if (Connection->HalfOpen == FALSE) {
        //
        // Other side is still around, tell it to quit.
        //
        Trace1(SOCKET, _T("Starting a shutdown on socket %x"), 
               Connection->Socket[1 - DirectionInfo->Direction]);

        if (shutdown(Connection->Socket[1 - DirectionInfo->Direction], SD_SEND)
             == SOCKET_ERROR) {

            Status = WSAGetLastError();
            Trace2(SOCKET, _T("shutdown failed with error %u = 0x%x"),
                   Status, Status);
            CloseConnection(&Connection);
        } else {
            Connection->HalfOpen = TRUE;
        }
    } else {
        CloseConnection(&Connection);
    }

    //
    // Release the reference from the receive.
    //
    DereferenceConnection(&Connection, _T("ProcessReceiveError"));
}

//
// Main dispatch routine
//
VOID APIENTRY
TpProcessWorkItem(
    IN ULONG Status,
    IN ULONG NumBytes,
    IN LPOVERLAPPED Overlapped
    )
{
    OPERATION Operation;

    Operation = *(OPERATION*)(Overlapped+1);

    Trace4(SOCKET,
           _T("TpProcessWorkItem got err %x operation=%hs ovl %p bytes=%d"),
           Status, OperationName[Operation], Overlapped, NumBytes);

    if (Status == NO_ERROR) {
        switch(Operation) {
        case Accept:
            ProcessAccept(NumBytes, Overlapped);
            break;
        case Connect:
            ProcessConnect(NumBytes, Overlapped);
            break;
        case Receive:
            ProcessReceive(NumBytes, Overlapped);
            break;
        case Send:
            ProcessSend(NumBytes, Overlapped);
            break;
        }
    } else if (Overlapped) {
        switch(Operation) {
        case Accept:
            ProcessAcceptError(NumBytes, Overlapped, Status);
            break;
        case Connect:
            ProcessConnectError(NumBytes, Overlapped, Status);
            break;
        case Receive:
            ProcessReceiveError(NumBytes, Overlapped, Status);
            break;
        case Send:
            ProcessSendError(NumBytes, Overlapped, Status);
            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\6to4svc\svcmain.c ===
#include "precomp.h"
#pragma hdrstop

#define SERVICE_NAME TEXT("6to4")

HANDLE          g_hServiceStatusHandle = INVALID_HANDLE_VALUE;
SERVICE_STATUS  g_ServiceStatus;

VOID
SetHelperServiceStatus(
    IN DWORD   dwState,
    IN DWORD   dwErr)
{
    BOOL bOk;

    Trace1(FSM, _T("Setting state to %d"), dwState);

    g_ServiceStatus.dwCurrentState = dwState;
    g_ServiceStatus.dwCheckPoint   = 0;
    g_ServiceStatus.dwWin32ExitCode= dwErr;
#ifndef STANDALONE
    bOk = SetServiceStatus(g_hServiceStatusHandle, &g_ServiceStatus);
    if (!bOk) {
        Trace0(ERR, _T("SetServiceStatus returned failure"));
    }
#endif

    if (dwState == SERVICE_STOPPED) {
        CleanupHelperService();

        // Uninitialize tracing and error logging.    
        UNINITIALIZE_TRACING_LOGGING();
    }
}

DWORD
OnStartup()
{
    DWORD   dwErr;

    ENTER_API();

    // Initialize tracing and error logging.  Continue irrespective of
    // success or failure.  NOTE: TracePrintf and ReportEvent both have
    // built in checks for validity of TRACEID and LOGHANDLE.
    INITIALIZE_TRACING_LOGGING();
    
    TraceEnter("OnStartup");

    dwErr = StartHelperService();

    TraceLeave("OnStartup");
    LEAVE_API();

    return dwErr;
}

VOID
OnStop(
    IN DWORD dwErr)
{
    ENTER_API();
    TraceEnter("OnStop");

    // Make sure we don't try to stop twice.
    if ((g_ServiceStatus.dwCurrentState != SERVICE_STOP_PENDING) &&
        (g_ServiceStatus.dwCurrentState != SERVICE_STOPPED)) {
    
        StopHelperService(dwErr);
    }

    TraceLeave("OnStop");

    LEAVE_API();
}

////////////////////////////////////////////////////////////////
// ServiceMain - main entry point called by svchost or by the
// standalone main.
//
#define SERVICE_CONTROL_DDNS_REGISTER 128

VOID WINAPI
ServiceHandler(
    IN DWORD dwCode)
{
    switch (dwCode) {
    case SERVICE_CONTROL_STOP:
        OnStop(NO_ERROR);
        break;
    case SERVICE_CONTROL_PARAMCHANGE:
        OnConfigChange();
        break;
    case SERVICE_CONTROL_DDNS_REGISTER:
        OnIpv6AddressChange(NULL, TRUE);
        break;
    }
}


VOID WINAPI
ServiceMain(
    IN ULONG   argc,
    IN LPWSTR *argv)
{
    DWORD dwErr;

#ifndef STANDALONE
    g_hServiceStatusHandle = RegisterServiceCtrlHandler(SERVICE_NAME,
                                                        ServiceHandler);

    // RegisterServiceCtrlHandler returns NULL on failure
    if (g_hServiceStatusHandle == NULL) {
        return;
    }
#endif

    ZeroMemory(&g_ServiceStatus, sizeof(g_ServiceStatus));
    g_ServiceStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
    g_ServiceStatus.dwControlsAccepted =
        SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_PARAMCHANGE;

    // Do startup processing
    dwErr = OnStartup();
#ifndef STANDALONE
    if (dwErr != NO_ERROR) {
        OnStop(dwErr);
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\6to4svc\server.c ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

    server.c
    
Abstract:

    This module contains the teredo server (and relay) implementation.

Author:

    Mohit Talwar (mohitt) Fri Nov 02 14:55:38 2001

Environment:

    User mode only.

--*/

#include "precomp.h"
#pragma hdrstop


TEREDO_SERVER_STATE TeredoServer;


TEREDO_PACKET_IO_COMPLETE TeredoServerReadComplete;
TEREDO_PACKET_IO_COMPLETE TeredoServerWriteComplete;
TEREDO_PACKET_IO_COMPLETE TeredoServerBounceComplete;
TEREDO_PACKET_IO_COMPLETE TeredoServerReceiveComplete;
TEREDO_PACKET_IO_COMPLETE TeredoServerTransmitComplete;


USHORT
__inline
TeredoChecksumDatagram(
    IN CONST IN6_ADDR *Destination,
    IN CONST IN6_ADDR *Source,
    IN USHORT NextHeader,
    IN UCHAR CONST *Buffer,
    IN USHORT Bytes
    )
/*++

Routine Description:
    
    16-bit one's complement of the one's complement sum of a 'Buffer'
    of size 'Bytes'.  NOTE: The sum is independent of the byte order!
    
Arguments:

    Buffer - Supplies the buffer containing data to compute checksum for.

    Bytes - Supplies the number of bytes to compute checksum for.

Return Value:

    The checksum.

--*/
{
    DWORD Sum, Words, i;
    PUSHORT Start = (PUSHORT) Buffer;

    //
    // If 'Bytes' is odd, this has to be handled differently.
    // That, however, is never the case for us, so we optimize.
    // Also ensure that 'Buffer' is aligned on a 2 byte boundary.
    //
    ASSERT(((((DWORD_PTR) Buffer) % 2) == 0) && ((Bytes % 2) == 0));
    Words = Bytes / 2;

    //
    // Start with the pseudo-header.
    //
    Sum = htons(Bytes) + (NextHeader << 8);
    for (i = 0; i < 8; i++) {
        Sum += Source->s6_words[i] + Destination->s6_words[i];
    }    

    for (i = 0; i < Words; i++) {
        Sum += Start[i];
    }
    
    Sum = (Sum & 0x0000ffff) + (Sum >> 16);
    Sum += (Sum >> 16);

    return LOWORD(~((DWORD_PTR) Sum));
}


VOID
CALLBACK
TeredoServerIoCompletionCallback(
    IN DWORD ErrorCode,
    IN DWORD Bytes,
    IN LPOVERLAPPED Overlapped
    )
/*++

Routine Description:

    Callback routine for I/O completion on TUN interface device or UDP socket.

Arguments:

    ErrorCode - Supplies the I/O completion status.

    Bytes - Supplies the number of bytes transferred.

    Overlapped - Supplies the completion context.
    
Return Value:

    None.

--*/
{
    static CONST PTEREDO_PACKET_IO_COMPLETE Callback[] =
    {
        TeredoServerReadComplete,
        TeredoServerWriteComplete,
        NULL,                   // No bubbling...
        TeredoServerBounceComplete,
        TeredoServerReceiveComplete,
        TeredoServerTransmitComplete,
        NULL,                   // No multicasting...
    };
    PTEREDO_PACKET Packet = Cast(
        CONTAINING_RECORD(Overlapped, TEREDO_PACKET, Overlapped),
        TEREDO_PACKET);

    ASSERT((Packet->Type != TEREDO_PACKET_BUBBLE) &&
           (Packet->Type != TEREDO_PACKET_MULTICAST));
    
    //
    // This completion function usually posts the packet for another I/O.
    // Since we are called by a non-I/O worker thread, asynchronous I/O
    // requests posted here might terminate when this thread does.  This
    // is rare enough that we don't special case it.  Moreover, we only
    // make best effort guarantees to the upper layer!
    //
    (*Callback[Packet->Type])(ErrorCode, Bytes, Packet);
}


VOID
TeredoServerAddressDeletionNotification(
    IN IN_ADDR Address
    )
/*++
    
Routine Description:

    Process an address deletion request.
    
Arguments:

    Address - Supplies the address that was deleted.
    
Return Value:

    None.
    
Caller LOCK: API.

--*/
{
    if (!IN4_ADDR_EQUAL(Address, TeredoServer.Io.SourceAddress.sin_addr)) {
        return;
    }

    //
    // Refresh the socket state (the socket bound to SourceAddress).
    //
    if (TeredoRefreshSocket(&(TeredoServer.Io)) != NO_ERROR) {
        //
        // Online -> Offline.
        //
        TeredoStopServer();
        return;
    }

    if (!IN4_ADDR_EQUAL(
        TeredoServer.Io.SourceAddress.sin_addr,
        TeredoServer.Io.ServerAddress.sin_addr)) {
        //
        // Online -> Offline.
        //
        TeredoStopServer();
        return;
    }    
}


VOID
TeredoStartServer(
    VOID
    )
/*++

Routine Description:

    Attempt to start the teredo service at the server.

    Events / Transitions
    ServiceStart        Offline -> Online.
    ServiceEnable       Offline -> Online.
    AdapterArrival      Offline -> Online.
    AddressAddition     Offline -> Online.

Arguments:

    None.

Return Value:

    None.

Caller LOCK: API.

--*/ 
{
    TraceEnter("TeredoStartServer");

    //
    // Can't have both the client and server on the same node.
    //
    if (TeredoClient.State != TEREDO_STATE_OFFLINE) {
        return;
    }

    //
    // Well, the service has already been started!
    //
    if (TeredoServer.State != TEREDO_STATE_OFFLINE) {
        return;
    }

    TeredoServer.State = TEREDO_STATE_ONLINE;

    //
    // Start I/O processing.
    //
    if (TeredoStartIo(&(TeredoServer.Io)) != NO_ERROR) {
        goto Bail;
    }

    if (!IN4_ADDR_EQUAL(
        TeredoServer.Io.SourceAddress.sin_addr,
        TeredoServer.Io.ServerAddress.sin_addr)) {
        goto Bail;
    }
                        
    return;

Bail:
    TeredoServer.State = TEREDO_STATE_OFFLINE;
    TeredoStopIo(&(TeredoServer.Io));
}


VOID
TeredoStopServer(
    VOID
    )
/*++

Routine Description:

    Stop the teredo service at the server.
    
    Events / Transitions   
    ServiceStop         Online -> Offline.
    ServiceDisable      Online -> Offline.
    AdapterRemoval      Online -> Offline.
    AddressDeletion     Online -> Offline.

Arguments:

    None.

Return Value:

    None.

Caller LOCK: API.

--*/ 
{
    TraceEnter("TeredoStopServer");

    //
    // Well, the service was never started!
    //
    if (TeredoServer.State == TEREDO_STATE_OFFLINE) {
        return;
    }

    TeredoServer.State = TEREDO_STATE_OFFLINE;    

    TeredoStopIo(&(TeredoServer.Io));
}


DWORD
TeredoInitializeServer(
    VOID
    )
/*++

Routine Description:

    Initializes the server.
    
Arguments:

    None.

Return Value:

    NO_ERROR or failure code.

--*/ 
{
    DWORD Error;
    IN_ADDR Group;
    Group.s_addr = htonl(INADDR_ANY);
    
    //
    // Obtain a reference on the teredo server for initialization.
    //
    TeredoServer.ReferenceCount = 1;

    Error = TeredoInitializeIo(
        &(TeredoServer.Io),
        Group,
        TeredoReferenceServer,
        TeredoDereferenceServer,
        TeredoServerIoCompletionCallback);
    if (Error != NO_ERROR) {
        return Error;
    }

    TeredoServer.State = TEREDO_STATE_OFFLINE;

    IncEventCount("TeredoInitializeServer");

    return NO_ERROR;
}


VOID
TeredoUninitializeServer(
    VOID
    )
/*++

Routine Description:

    Uninitializes the server.  Typically invoked upon service stop.
    
Arguments:

    None.

Return Value:

    None.

--*/
{
    TeredoStopServer();
    TeredoDereferenceServer();
}


VOID
TeredoCleanupServer(
    VOID
    )
/*++

Routine Description:

    Cleans up the server after the last reference to it has been released.
    
Arguments:

    None.

Return Value:

    None.

--*/
{
    TeredoCleanupIo(&(TeredoServer.Io));        
    DecEventCount("TeredoCleanupServer");
}


VOID
TeredoBuildRouterAdvertisementPacket(
    OUT PTEREDO_PACKET Packet,
    IN IN6_ADDR Destination,
    IN IN_ADDR Address,
    IN USHORT Port
    )
/*++

Routine Description:

    Construct an RA in response to the client's RS.
    
Arguments:

    Packet - Returns the constructed RA in the caller supplied packet.

    Destination - Supplies the destination address of the RA,
        the client's random link-local address in the triggering RS.
        Passed by value so this function may reuse the packet buffer.
        
    Address - Supplies the client's address, used to source the RS.

    Port - Supplies the client's port, used to source the RS.
    
Return Value:

    None.

--*/    
{
    PIP6_HDR Ipv6 = (PIP6_HDR) Packet->Buffer.buf;
    ICMPv6Header *Icmpv6 = (ICMPv6Header *) (Ipv6 + 1);
    NDRouterAdvertisement *Ra = (NDRouterAdvertisement *) (Icmpv6 + 1);
    NDOptionPrefixInformation *Prefix = (NDOptionPrefixInformation *) (Ra + 1);
    NDOptionMTU *Mtu = (NDOptionMTU *) (Prefix + 1);
    PUCHAR End = (PUCHAR) (Mtu + 1);
    
    Packet->Buffer.len = (ULONG) (End - (Packet->Buffer.buf));
    ZeroMemory(Packet->Buffer.buf, Packet->Buffer.len);

    //
    // Construct the IPv6 Header...
    //
    Ipv6->ip6_plen = htons((USHORT) (Packet->Buffer.len - sizeof(IP6_HDR)));
    Ipv6->ip6_nxt = IP_PROTOCOL_ICMPv6;
    Ipv6->ip6_hlim = 255;
    Ipv6->ip6_vfc = IPV6_VERSION;

    //
    // ...using the server's link local address: fe80:IPv4 Address:UDP Port::1
    //
    Ipv6->ip6_src.s6_words[0] = 0x80fe;
    Ipv6->ip6_src.s6_words[1] =
        ((PUSHORT) &TeredoServer.Io.ServerAddress.sin_addr)[0];
    Ipv6->ip6_src.s6_words[2] =
        ((PUSHORT) &TeredoServer.Io.ServerAddress.sin_addr)[1];
    Ipv6->ip6_src.s6_words[3] =
        TeredoServer.Io.ServerAddress.sin_port;
    Ipv6->ip6_src.s6_words[7] = 0x0100;
    Ipv6->ip6_dest = Destination;
    
    //
    // Construct ICMPv6 Header.
    //
    Icmpv6->Type = ICMPv6_ROUTER_ADVERT;

    //
    // Construct RouterAdvertisement Header.
    //
    Ra->RouterLifetime = htons(TEREDO_ROUTER_LIFETIME);
    Ra->Flags = ROUTE_PREF_LOW;
    
    //
    // Construct Prefix Option.
    //
    Prefix->Type = ND_OPTION_PREFIX_INFORMATION;
    Prefix->Length = sizeof(NDOptionPrefixInformation) / 8;
    Prefix->PrefixLength = 64;
    Prefix->Flags = ND_PREFIX_FLAG_AUTONOMOUS;
    Prefix->ValidLifetime = Prefix->PreferredLifetime = IPV6_INFINITE_LIFETIME;

    Prefix->Prefix.s6_words[0] = TeredoIpv6ServicePrefix.s6_words[0];
    Prefix->Prefix.s6_words[1] = ((PUSHORT) &Address)[0];
    Prefix->Prefix.s6_words[2] = ((PUSHORT) &Address)[1];
    Prefix->Prefix.s6_words[3] = Port;

    //
    // Construct MTU Option.
    //
    Mtu->Type = ND_OPTION_MTU;
    Mtu->Length = sizeof(NDOptionMTU) / 8;
    Mtu->MTU = htonl(IPV6_TEREDOMTU);

    //
    // Checksum Packet!
    //
    Icmpv6->Checksum = TeredoChecksumDatagram(
        &(Ipv6->ip6_dest),
        &(Ipv6->ip6_src),
        IP_PROTOCOL_ICMPv6,
        (PUCHAR) Icmpv6,
        (USHORT) (End - ((PUCHAR) Icmpv6)));
}


PTEREDO_PACKET
TeredoReceiveRouterSolicitation(
    IN PTEREDO_PACKET Packet,
    IN ULONG Bytes
    )
/*++

Routine Description:

    Process the router solicitation packet received on the UDP socket.
    
Arguments:

    Packet - Supplies the packet that was received.

    Bytes - Supplies the length of the packet.
    
Return Value:

    Returns the supplied packet if processing completed or failed;
    NULL if the processing will complete asynchronously.

--*/ 
{
    PUCHAR Buffer = Packet->Buffer.buf;
    ICMPv6Header *Icmpv6;
    ULONG Length;
    PIP6_HDR Ipv6 = (PIP6_HDR) Packet->Buffer.buf;
    
    Icmpv6 = TeredoParseIpv6Headers(Buffer, Bytes);
    if (Icmpv6 == NULL) {
        return Packet;
    }
            
    if ((Icmpv6->Type != ICMPv6_ROUTER_SOLICIT) || (Icmpv6->Code != 0)) {
        return Packet;
    }
    Buffer = (PUCHAR) (Icmpv6 + 1);
    Bytes -= (ULONG) (Buffer - Packet->Buffer.buf);
    
    //
    // Parse the rest of the router solicitation header.
    //
    if (Bytes < sizeof(ULONG)) {
        return Packet;
    }
    Buffer += sizeof(ULONG);
    Bytes -= sizeof(ULONG);
    
    while (Bytes != 0) {
        //
        // Parse TLV options.
        //
        if (Bytes < 8) {
            return Packet;
        }
        
        Length = (Buffer[1] * 8);        
        if ((Length == 0) || (Bytes < Length)) {
            return Packet;
        }
        
        Buffer += Length;
        Bytes -= Length;
    }

    //
    // Checksum Packet!
    //
    if (TeredoChecksumDatagram(
        &(Ipv6->ip6_dest),
        &(Ipv6->ip6_src),
        IP_PROTOCOL_ICMPv6,
        (PUCHAR) Icmpv6,
        (USHORT) (Buffer - ((PUCHAR) Icmpv6))) != 0) {
        return Packet;
    }
    
    //
    // We have a valid router solicitation, so tunnel an advertisement!
    // Reuse the RS packet to bounce the RA.
    //
    TeredoBuildRouterAdvertisementPacket(
        Packet,
        Ipv6->ip6_src, 
        Packet->SocketAddress.sin_addr,
        Packet->SocketAddress.sin_port);
    Packet->Type = TEREDO_PACKET_BOUNCE;
    return TeredoTransmitPacket(&(TeredoServer.Io), Packet);
}


PTEREDO_PACKET
TeredoServerReceiveData(
    IN PTEREDO_PACKET Packet,
    IN ULONG Bytes
    )
/*++

Routine Description:

    Process the data packet received on the UDP socket.
    
Arguments:

    Packet - Supplies the packet that was received.

    Bytes - Supplies the length of the packet.
    
Return Value:

    Returns the supplied packet if processing completed or failed;
    NULL if the processing will complete asynchronously.

--*/ 
{
    PIP6_HDR Ipv6 = (PIP6_HDR) Packet->Buffer.buf;
    IN_ADDR Address;
    USHORT Port;

    //
    // Validate source address.
    //
    if (!TeredoServicePrefix(&(Ipv6->ip6_src))) {
        return Packet;
    }

    TeredoParseAddress(&(Ipv6->ip6_src), &Address, &Port);
    if (!IN4_ADDR_EQUAL(Packet->SocketAddress.sin_addr, Address) ||
        (Packet->SocketAddress.sin_port != Port)) {
        //
        // Should have been constructed by the *right* teredo peer.
        //
        return Packet;
    }
    //
    // NOTE: Caller has previously verified that the source has global scope.
    //

    //
    // Validate destination address.
    //
    if (TeredoServicePrefix(&(Ipv6->ip6_dest))) {
        TeredoParseAddress(&(Ipv6->ip6_dest), &Address, &Port);
        if (!TeredoIpv4GlobalAddress((PUCHAR) &Address)) {
            //
            // The IPv4 destination address should be global scope.
            //
            return Packet;
        }

        //
        // Now tunnel it to the destination.
        //
        Packet->SocketAddress.sin_addr = Address;
        Packet->SocketAddress.sin_port = Port;
        Packet->Type = TEREDO_PACKET_BOUNCE;
        Packet->Buffer.len = Bytes;
        return TeredoTransmitPacket(&(TeredoServer.Io), Packet);
    }

    if (!TeredoIpv6GlobalAddress(&(Ipv6->ip6_dest))) {
        //
        // The IPv6 destination address should be global scope.
        //
        return Packet;
    }

    //
    // Else forward it to the stack for forwarding.
    //
    Packet->Type = TEREDO_PACKET_WRITE;
    Packet->Buffer.len = Bytes;
    return TeredoWritePacket(&(TeredoServer.Io), Packet);
}


VOID
TeredoServerReadComplete(
    IN DWORD Error,
    IN ULONG Bytes,
    IN PTEREDO_PACKET Packet
    )
/*++

Routine Description:

    Process a read completion on the TUN device.

--*/ 
{
    PIP6_HDR Ipv6 = (PIP6_HDR) Packet->Buffer.buf;
    IN_ADDR Address;
    USHORT Port;
    
    if ((Error != NO_ERROR) || (Bytes < sizeof(IP6_HDR))) {
        //
        // Attempt to post the read again.
        // If we are going offline, the packet is destroyed in the attempt.
        //
        TeredoPostRead(&(TeredoServer.Io), Packet);
        return;
    }

    TraceEnter("TeredoServerReadComplete");

    //
    // Validate destination address.
    //
    if (!TeredoServicePrefix(&(Ipv6->ip6_dest))) {
        TeredoPostRead(&(TeredoServer.Io), Packet);
        return;
    }
    
    TeredoParseAddress(&(Ipv6->ip6_dest), &Address, &Port);
    if (!TeredoIpv4GlobalAddress((PUCHAR) &Address)) {
        //
        // The IPv4 source address should be global scope.
        //
        TeredoPostRead(&(TeredoServer.Io), Packet);
        return;
    }

    //
    // Now tunnel it to the destination.
    //
    Packet->SocketAddress.sin_addr = Address;
    Packet->SocketAddress.sin_port = Port;
    Packet->Type = TEREDO_PACKET_TRANSMIT;
    Packet->Buffer.len = Bytes;
    if (TeredoTransmitPacket(&(TeredoServer.Io), Packet) == NULL) {
        return;
    }
    
    //
    // We are done processing this packet.
    //
    TeredoServerTransmitComplete(NO_ERROR, Bytes, Packet);
}


VOID
TeredoServerWriteComplete(
    IN DWORD Error,
    IN ULONG Bytes,
    IN PTEREDO_PACKET Packet
    )
/*++

Routine Description:

    Process a write completion on the TUN device.

--*/ 
{
    TraceEnter("TeredoServerWriteComplete");
        
    //
    // Attempt to post the receive again.
    // If we are going offline, the packet is destroyed in the attempt.
    //
    Packet->Type = TEREDO_PACKET_RECEIVE;
    Packet->Buffer.len = IPV6_TEREDOMTU;
    TeredoPostReceives(&(TeredoServer.Io), Packet);
}


VOID
TeredoServerBounceComplete(
    IN DWORD Error,
    IN ULONG Bytes,
    IN PTEREDO_PACKET Packet
    )
/*++

Routine Description:

    Process a bounce completion on the UDP socket.

--*/
{
    TraceEnter("TeredoServerBounceComplete");

    //
    // Attempt to post the receive again.
    // If we are going offline, the packet is destroyed in the attempt.
    //
    Packet->Type = TEREDO_PACKET_RECEIVE;
    Packet->Buffer.len = IPV6_TEREDOMTU;
    TeredoPostReceives(&(TeredoServer.Io), Packet);
}


VOID
TeredoServerReceiveComplete(
    IN DWORD Error,
    IN ULONG Bytes,
    IN PTEREDO_PACKET Packet
    )
/*++

Routine Description:

    Process a receive completion on the UDP socket.

--*/ 
{
    PIP6_HDR Ipv6 = (PIP6_HDR) Packet->Buffer.buf;
    
    InterlockedDecrement(&(TeredoServer.Io.PostedReceives));
    
    if ((Error != NO_ERROR) ||
        (Bytes < sizeof(IP6_HDR)) ||
        ((Ipv6->ip6_vfc & IP_VER_MASK) != IPV6_VERSION) ||
        (Bytes < (ntohs(Ipv6->ip6_plen) + sizeof(IP6_HDR))) ||
        (!TeredoIpv4GlobalAddress(
            (PUCHAR) &(Packet->SocketAddress.sin_addr)))) {
        //
        // Attempt to post the receive again.
        // If we are going offline, the packet is destroyed in the attempt.
        //
        TeredoPostReceives(&(TeredoServer.Io), Packet);
        return;
    }

    TraceEnter("TeredoServerReceiveComplete");
    
    if (IN6_IS_ADDR_LINKLOCAL(&(Ipv6->ip6_src)) ||
        IN6_IS_ADDR_UNSPECIFIED(&(Ipv6->ip6_src))) {
        //
        // This should be a valid router solicitation.  Note that only router
        // solicitation packets are accepted with a link-local source address.
        //
        Packet = TeredoReceiveRouterSolicitation(Packet, Bytes);
    } else {
        //
        // This may be a packet of any other kind.
        //
        Packet = TeredoServerReceiveData(Packet, Bytes);
    }

    if (Packet != NULL) {
        //
        // We are done processing this packet.
        //
        TeredoServerWriteComplete(NO_ERROR, Bytes, Packet);
    }
}


VOID
TeredoServerTransmitComplete(
    IN DWORD Error,
    IN ULONG Bytes,
    IN PTEREDO_PACKET Packet
    )
/*++

Routine Description:

    Process a transmit completion on the UDP socket.

--*/ 
{
    TraceEnter("TeredoServerTransmitComplete");
        
    //
    // Attempt to post the read again.
    // If we are going offline, the packet is destroyed in the attempt.
    //
    Packet->Type = TEREDO_PACKET_READ;
    Packet->Buffer.len = IPV6_TEREDOMTU;
    TeredoPostRead(&(TeredoServer.Io), Packet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\6to4svc\trace.h ===
//----------------------------------------------------------------------------
// constants used for g_dwLoggingLevel
//----------------------------------------------------------------------------

#define IPA_LOGGING_NONE                   0
#define IPA_LOGGING_ERROR                  1
#define IPA_LOGGING_WARN                   2
#define IPA_LOGGING_INFO                   3

// constants and macros used for tracing
//

#define IPA_TRACE_ANY             ((DWORD)0xFFFF0000 | TRACE_USE_MASK)

#define IPA_TRACE_ERR             ((DWORD)0x00010000 | TRACE_USE_MASK)

#define IPA_TRACE_ENTER           ((DWORD)0x00020000 | TRACE_USE_MASK)
#define IPA_TRACE_LEAVE           ((DWORD)0x00020000 | TRACE_USE_MASK)
#define IPA_TRACE_START           ((DWORD)0x00020000 | TRACE_USE_MASK)
#define IPA_TRACE_STOP            ((DWORD)0x00020000 | TRACE_USE_MASK)

#define IPA_TRACE_MSG             ((DWORD)0x00040000 | TRACE_USE_MASK)
#define IPA_TRACE_SOCKET          ((DWORD)0x00080000 | TRACE_USE_MASK)
#define IPA_TRACE_FSM             ((DWORD)0x00100000 | TRACE_USE_MASK)

#define IPA_TRACE_REF             ((DWORD)0x10000000 | TRACE_USE_MASK)
#define IPA_TRACE_TIMER           ((DWORD)0x20000000 | TRACE_USE_MASK)
#define IPA_TRACE_CS              ((DWORD)0x40000000 | TRACE_USE_MASK)
#define IPA_TRACE_CS1             ((DWORD)0x80000000 | TRACE_USE_MASK)

#ifdef LOCK_DBG

#define ENTER_CRITICAL_SECTION(pcs, type, proc)             \
            Trace0(CS,_T("----To enter ") _T(type) _T(" in ") _T(proc)); \
            EnterCriticalSection(pcs);                         \
            Trace0(CS,_T("----Entered ") _T(type) _T(" in ") _T(proc));

//#define ENTER_CRITICAL_SECTION(pcs, type, proc)             \
//            Trace2(CS,_T("----To enter %s in %s"), type, proc);    \
//            EnterCriticalSection(pcs);                         \
//            Trace2(CS1,_T("----Entered %s in %s"), type, proc)

#define LEAVE_CRITICAL_SECTION(pcs, type, proc)         \
            Trace0(CS,_T("----Left ") _T(type) _T(" in ") _T(proc)); \
            LeaveCriticalSection(pcs)

//#define LEAVE_CRITICAL_SECTION(pcs, type, proc)         \
//            Trace2(CS1,_T("----Left %s in %s"), type, proc);    \
//            LeaveCriticalSection(pcs)

#define WAIT_FOR_SINGLE_OBJECT( event, time, type, proc) \
        Trace2(EVENT, _T("++++To wait for singleObj %s in %s"), type, proc); \
        WaitForSingleObject(event, time);    \
        Trace2(EVENT, _T("++++WaitForSingleObj returned %s in %s"), type, proc)

#define SET_EVENT(event, type, proc) \
        Trace2(EVENT, _T("++++SetEvent %s in %s"), type, proc);    \
        SetEvent(event)

#else
#define ENTER_CRITICAL_SECTION(pcs, type, proc) \
            EnterCriticalSection(pcs)

#define LEAVE_CRITICAL_SECTION(pcs, type, proc)    \
            LeaveCriticalSection(pcs)

#define WAIT_FOR_SINGLE_OBJECT( event, time, type, proc) \
        WaitForSingleObject(event, time)

#define SET_EVENT(event, type, proc) \
        SetEvent(event)

#endif // LOCK_DBG

#define TRACEID         g_TraceId


#define Trace0(l,a)             \
            TracePrintfEx(TRACEID, IPA_TRACE_ ## l, a)
#define Trace1(l,a,b)           \
            TracePrintfEx(TRACEID, IPA_TRACE_ ## l, a, b)
#define Trace2(l,a,b,c)         \
            TracePrintfEx(TRACEID, IPA_TRACE_ ## l, a, b, c)
#define Trace3(l,a,b,c,d)       \
            TracePrintfEx(TRACEID, IPA_TRACE_ ## l, a, b, c, d)
#define Trace4(l,a,b,c,d,e)     \
            TracePrintfEx(TRACEID, IPA_TRACE_ ## l, a, b, c, d, e)
#define Trace5(l,a,b,c,d,e,f)   \
            TracePrintfEx(TRACEID, IPA_TRACE_ ## l, a, b, c, d, e, f)
#define Trace6(l,a,b,c,d,e,f,g)   \
            TracePrintfEx(TRACEID, IPA_TRACE_ ## l, a, b, c, d, e, f,g)
#define Trace7(l,a,b,c,d,e,f,g,h)   \
            TracePrintfEx(TRACEID, IPA_TRACE_ ## l, a, b, c, d, e, f,g,h)
#define Trace8(l,a,b,c,d,e,f,g,h,i)   \
            TracePrintfEx(TRACEID, IPA_TRACE_ ## l, a, b, c, d, e, f,g,h,i)
#define Trace9(l,a,b,c,d,e,f,g,h,i,j)   \
            TracePrintfEx(TRACEID, IPA_TRACE_ ## l, a, b, c, d, e, f,g,h,i,j)


#define TRACEDUMP(l,a,b,c)      \
            TraceDumpEx(TRACEID,l,a,b,c,TRUE)

#ifdef ENTER_DBG

#define TraceEnter(X)  TracePrintfEx(TRACEID, IPA_TRACE_ENTER, \
    _T("Entered: ")_T(X))
#define TraceLeave(X)  TracePrintfEx(TRACEID, IPA_TRACE_ENTER, \
    _T("Leaving: ")_T(X))

#else

#define TraceEnter(X)
#define TraceLeave(X)

#endif // ENTER_DBG

  
#define LOGLEVEL        g_dwLoggingLevel
#define LOGHANDLE       g_LogHandle
#define LOGERR          RouterLogError

// Error logging

#define Logerr0(msg,err) \
        if (LOGLEVEL >= IPA_LOGGING_ERROR) \
            LOGERR(LOGHANDLE,IPALOG_ ## msg,0,NULL,(err))
#define Logerr1(msg,a,err) \
        if (LOGLEVEL >= IPA_LOGGING_ERROR) \
            LOGERR(LOGHANDLE,IPALOG_ ## msg,1,&(a),(err))
#define Logerr2(msg,a,b,err) \
        if (LOGLEVEL >= IPA_LOGGING_ERROR) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGERR(LOGHANDLE,IPALOG_ ## msg,2,_asz,(err)); \
        }
#define Logerr3(msg,a,b,c,err) \
        if (LOGLEVEL >= IPA_LOGGING_ERROR) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGERR(LOGHANDLE,IPALOG_ ## msg,3,_asz,(err)); \
        }
#define Logerr4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= IPA_LOGGING_ERROR) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGERR(LOGHANDLE,IPALOG_ ## msg,4,_asz,(err)); \
        }


//-----------------------------------------------------------------------------
// INITIALIZE_TRACING_LOGGING
//-----------------------------------------------------------------------------

//
// also set the default logging level. It will be reset during
// StartProtocol(), when logging level is set as part of global config
//
#define INITIALIZE_TRACING_LOGGING() {                  \
    TRACEID = TraceRegister(_T("6to4"));                \
    LOGHANDLE = RouterLogRegister(_T("6to4"));          \
    LOGLEVEL = IPA_LOGGING_WARN;                        \
}

//-----------------------------------------------------------------------------
// UNINITIALIZE_TRACING_LOGGING
//-----------------------------------------------------------------------------

#define UNINITIALIZE_TRACING_LOGGING() {                \
    if (TRACEID != INVALID_TRACEID) {                   \
        TraceDeregister(TRACEID);                       \
        TRACEID = INVALID_TRACEID;                      \
    }                                                   \
                                                        \
    if (LOGHANDLE != NULL) {                            \
        RouterLogDeregister(LOGHANDLE);                 \
        LOGHANDLE = NULL;                               \
    }                                                   \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplayip6\bilink.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    BILINK.C

Abstract:

    Management for doubly linked lists

Author:

    George Joy

Environment:

    32-bit 'C'

Revision History:

--*/
#include <windows.h>
#include "dpsp.h"
#include <dpf.h>
#include "bilink.h"

// Note: serialization of access to BILINK structures must 
//       take place in the calling code.  Operations are
//       not intrinsically atomic.

#ifdef DEBUG
int FindObject(
    BILINK *link,
    BILINK *list
    )
{
    BILINK *p = list->next;
    while(p != link && p != list)
        p= p->next;
    return (p==link);
}
#endif

void InsertAfter(
    BILINK *in,
    BILINK *after
    )
/*=========================================================================
 *  Description:
 *      Insert an object after a specified object in the doubly linked list.
 *      The after object could be the Head BILINK for adding to the head of a
 *      queue.
 *  Returns:
 *
 */
{
    #ifdef DEBUG
    if(FindObject(in,after)) {
        DPF(0,"Attempt to re-insert object in BILINK queue\n");
        DEBUG_BREAK();
    }
    #endif
    in->next = after->next;
    in->prev = after;
    after->next->prev = in;
    after->next = in;
}

void InsertBefore(
     BILINK *in,
     BILINK *before
    )
/*=========================================================================
 *  Description:
 * Inserts an  object before a specified object in the doubly linked list.
 * The before object could be the Head BILINK for adding to the end
 * of the queue
 * CALLED WITH INTERRUPTS_OFF
 *
 *  Returns:
 *
 */
{
    #ifdef DEBUG
    if(FindObject(in,before)) {
        DPF(0,"Attempt to re-insert object in BILINK queue\n");
        DEBUG_BREAK();
    }
    #endif
    in->next = before;
    in->prev = before->prev;
    before->prev->next = in;
    before->prev = in;
}

void Delete(
     BILINK *p
)
/*=========================================================================
 *  Description:
 *
 * Delete a  object from a doubly linked list. Make sure it IS on a list!
 * CALLED WITH INTERRUPTS OFF (must be atomic).
 *
 *  Returns:
 *
 */
{
    ASSERT(p && p->prev && p->next);
    ASSERT(p->prev->next == p && p->next->prev == p);
    p->next->prev = p->prev;
    p->prev->next = p->next;
    // p->next = p->prev = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\6to4svc\teredo.h ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

    teredo.h

Abstract:

    This module contains the teredo client and server (cum relay) state.

Author:

    Mohit Talwar (mohitt) Mon Oct 22 15:17:48 2001

Environment:

    User mode only.

--*/

#ifndef _TEREDO_
#define _TEREDO_

#pragma once


#include <tunuser.h>
#define DEVICE_PREFIX L"\\Device\\"


//
// IP6_HDR
//
// Define the RFC 2292 structure for an IPv6 header.
//

typedef struct _IP6_HDR {
    union {
        struct ip6_hdrctl {
            UINT32 ip6_un1_flow;    // 20 bits of flow-ID
            UINT16 ip6_un1_plen;    // payload length
            UINT8  ip6_un1_nxt;     // next header
            UINT8  ip6_un1_hlim;    // hop limit
        } ip6_un1;
        UINT8 ip6_un2_vfc;          // 4 bits version, 4 bits priority
    } ip6_ctlun;
    IN6_ADDR ip6_src;               // source address
    IN6_ADDR ip6_dest;              // destination address
#define ip6_vfc    ip6_ctlun.ip6_un2_vfc
#define ip6_flow   ip6_ctlun.ip6_un1.ip6_un1_flow
#define ip6_plen   ip6_ctlun.ip6_un1.ip6_un1_plen
#define ip6_nxt    ip6_ctlun.ip6_un1.ip6_un1_nxt
#define ip6_hlim   ip6_ctlun.ip6_un1.ip6_un1_hlim
#define ip6_hops   ip6_ctlun.ip6_un1.ip6_un1_hlim
} IP6_HDR, *PIP6_HDR;

#define IPV6_VERSION                0x60 // This is 6 << 4
#define IPV6_TEREDOMTU            1280
#define IPV6_INFINITE_LIFETIME      0xffffffff
#define IPPROTO_NONE                59


//
// HASHTABLE
//
// Define a simple, statically sized, locked hash table.
// Each bucket is a doubly linked LRU list.
//

#define BUCKET_COUNT 29         // # buckets in the hash table
typedef struct _HASHTABLE {
    CRITICAL_SECTION Lock;      // Protects the table and entries.
    ULONG Size;                 // # entries in the hash table
    LIST_ENTRY Bucket[BUCKET_COUNT];
} HASHTABLE, *PHASHTABLE;


//
// TEREDO_TYPE
//
// Define the type of the teredo service.
//

typedef enum {
    TEREDO_DEFAULT = 0,
    TEREDO_CLIENT,
    TEREDO_SERVER,
    TEREDO_DISABLED,
    TEREDO_AUTOMATIC,
    TEREDO_MAXIMUM,
} TEREDO_TYPE, *PTEREDO_TYPE;


//
// TEREDO_PACKET_TYPE
//
// Define the type of a teredo packet.
//

typedef enum {
    TEREDO_PACKET_READ,         // Data read from TUN device.
    TEREDO_PACKET_WRITE,        // Data written to TUN device.
    TEREDO_PACKET_BUBBLE,       // Bubble transmitted on UDP socket.
    TEREDO_PACKET_BOUNCE,       // Packet bounced on UDP socket.
    TEREDO_PACKET_RECEIVE,      // Packet received on UDP socket.
    TEREDO_PACKET_TRANSMIT,     // Packet transmitted on UDP socket.
    TEREDO_PACKET_MULTICAST,    // Multicast bubble transmitted on UDP socket.
    TEREDO_PACKET_MAX,
} TEREDO_PACKET_TYPE, *PTEREDO_PACKET_TYPE;


//
// TEREDO_PACKET
//
// Define a teredo packet.
// The packet structure is followed in memory by the packet's data buffer.
//

typedef struct _TEREDO_PACKET {
#if DBG
    ULONG Signature;            // TEREDO_PACKET_SIGNATURE
#endif // DBG
    
    OVERLAPPED Overlapped;      // For asynchronous completion.
    TEREDO_PACKET_TYPE Type;    // Packet type.
    SOCKADDR_IN SocketAddress;  // Peer we are in communication with.
    UINT SocketAddressLength;   // Length of the peer's socket address.
    WSABUF Buffer;              // Packet buffer and length.
    DWORD Flags;                // Flags required during sends and receives.
} TEREDO_PACKET, *PTEREDO_PACKET;

#define TEREDO_PACKET_BUFFER(Packet)  \
    ((PUCHAR) (((PTEREDO_PACKET) (Packet)) + 1))


typedef
VOID
(TEREDO_REFERENCE)(
    VOID
    );
typedef TEREDO_REFERENCE *PTEREDO_REFERENCE;

typedef
VOID
(TEREDO_DEREFERENCE)(
    VOID
    );
typedef TEREDO_DEREFERENCE *PTEREDO_DEREFERENCE;

typedef
VOID
(TEREDO_PACKET_IO_COMPLETE)(
    IN DWORD Error,
    IN ULONG Bytes,
    IN PTEREDO_PACKET Packet
    );
typedef TEREDO_PACKET_IO_COMPLETE *PTEREDO_PACKET_IO_COMPLETE;


//
// TEREDO_STATE_TYPE
//
// Define the protocol state values of the teredo client service.
//

typedef enum {
    TEREDO_STATE_OFFLINE,
    TEREDO_STATE_PROBE,
    TEREDO_STATE_QUALIFIED,
    TEREDO_STATE_ONLINE,
} TEREDO_STATE_TYPE, *PTEREDO_STATE_TYPE;


//
// TEREDO_IO
//
// Define teredo I/O state.
// NOTE: All addresses and ports are stored in network byte order.
//

typedef struct _TEREDO_IO {
#if DBG
    ULONG Signature;            // TEREDO_PACKET_SIGNATURE
#endif // DBG
    
    HANDLE PacketHeap;          // Head for allocating teredo packets.

    ULONG PostedReceives;       // Count of posted receives.
    HANDLE ReceiveEvent;        // Event signalled upon a receive notification.
    HANDLE ReceiveEventWait;    // Wait registered for ReceiveEvent.

    IN_ADDR Group;              // Group joined on the native interface.
    SOCKADDR_IN ServerAddress;  // Teredo server IPv4 address and UDP port.
    SOCKADDR_IN SourceAddress;  // Preferred source address to teredo server.
    SOCKET Socket;              // Socket bound to SourceAddress on a UDP port.
    HANDLE TunnelDevice;        // Interface to the TUNNEL driver.
    WCHAR TunnelInterface[MAX_ADAPTER_NAME_LENGTH];

    //
    // Function handlers.
    //
    PTEREDO_REFERENCE Reference;
    PTEREDO_DEREFERENCE Dereference;
    LPOVERLAPPED_COMPLETION_ROUTINE IoCompletionCallback;    
} TEREDO_IO, *PTEREDO_IO;


//
// TEREDO_CLIENT_STATE
//
// Define the global state of the teredo client service.
//
// References:
// - One for initialization.
// - One for any running timer.
// - One for each teredo peer.
// - One for each teredo packet
// - One for "the" multicast bubble.  At most one outstanding bubble allowed.
// (reads, writes posted on TunDevice & receives, transmits posted on Socket).
//

typedef struct _TEREDO_CLIENT_STATE {
    ULONG ReferenceCount;       // Number of outstanding references.

    TEREDO_IO Io;               // I/O state.  TUN device and UDP socket.    

    HANDLE PeerHeap;            // Heap for allocating teredo peers.

    HANDLE Timer;               // One shot timer active in Probe & Qualified.
    HANDLE TimerEvent;          // Event signalled upon timer deletion.
    HANDLE TimerEventWait;      // Wait registered for TimerEvent.
    BOOL RestartQualifiedTimer; // When NAT mapping is created or refreshed.

    LONG Time;                  // Current time (in seconds).
    TEREDO_STATE_TYPE State;    // Teredo client service protocol state.
    IN6_ADDR Ipv6Prefix;        // Teredo IPv6 prefix advertised by server.
    ULONG RefreshInterval;      // Expected lifetime of client's NAT mapping.
    HASHTABLE PeerSet;          // Locked set of recent teredo peers.

    ULONG BubbleTicks;          // "RefreshInterval" ticks until next bubble.
    BOOL BubblePosted;          // Whether there is any outstanding bubble.
    TEREDO_PACKET Packet;       // Teredo multicast bubble packet.
    IP6_HDR Bubble;             // Teredo multicast bubble packet buffer.
} TEREDO_CLIENT_STATE, *PTEREDO_CLIENT_STATE;


//
// TEREDO_SERVER_STATE
//
// Define the global state of the teredo server service.
//
// References:
// - One for initialization.
// - One for each teredo packet
// (reads, writes posted on TunDevice & receives, transmits posted on Socket).
//

typedef struct _TEREDO_SERVER_STATE {
    ULONG ReferenceCount;       // Number of outstanding references.

    TEREDO_IO Io;               // I/O state.  TUN device and UDP socket.

    TEREDO_STATE_TYPE State;    // Teredo server service protocol state.
} TEREDO_SERVER_STATE, *PTEREDO_SERVER_STATE;


//
// TEREDO_PEER
//
// Define a teredo peer's state.
//
// References:
// - One for initialization.
// - One for "the" posted bubble.  At most one outstanding bubble is allowed.
//
// Synchronization:
// - Link: Protected by PeerSet::Lock.
// - ReferenceCount: InterlockedIncrement, InterlockedDecrement.
// - LastReceive, LastTransmit: Atomic reads and writes.
// - BubbleCount: Single writer!  Atomic reads.
// - BubblePosted: InterlockedExchange.
// - Remaining Fields: Read only.
//

typedef struct _TEREDO_PEER {
#if DBG
    ULONG Signature;            // TEREDO_PEER_SIGNATURE
#endif // DBG
    
    LIST_ENTRY Link;            // Linkage within the PeerSet.

    ULONG ReferenceCount;       // Number of outstanding references.
    
    LONG LastReceive;           // Time of last reception from the peer.
    LONG LastTransmit;          // Time of last transmission to the peer.
    IN6_ADDR Address;           // Teredo IPv6 address of the peer.
    ULONG BubbleCount;          // Number of bubbles transmitted to the peer.
    
    BOOL BubblePosted;          // Whether there is any outstanding bubble.    
    TEREDO_PACKET Packet;       // Teredo bubble packet.
    IP6_HDR Bubble;             // Teredo bubble packet buffer.
} TEREDO_PEER, *PTEREDO_PEER;


//
// Cast and Signature Verification
//

#define TEREDO_IO_SIGNATURE     'oIhS' // 'ShIo'
#define TEREDO_PEER_SIGNATURE   'ePhS' // 'ShPe'
#define TEREDO_PACKET_SIGNATURE 'aPhS' // 'ShPa'

//
// A NULL handle is considered a valid structure.
//

#define Cast(Pointer, TYPE)                         \
    ((TYPE *) (Pointer));                           \
    ASSERT(!(Pointer) ||                            \
           (((TYPE *) (Pointer))->Signature == TYPE##_SIGNATURE))


//
// Lower and upper limits on number of posted reads or receives.
//
#define TEREDO_LOW_WATER_MARK         5       // Receives or Reads.
#define TEREDO_HIGH_WATER_MARK        256     // Receives.  Reads are fixed.

//
// Intervals used by the protocol.
//
#define INFINITE_INTERVAL               0x7fffffff
#define TEREDO_RESOLVE_INTERVAL         15 * MINUTES
#define TEREDO_PROBE_INTERVAL           15 * SECONDS
#define TEREDO_REFRESH_INTERVAL         30 * SECONDS
#define TEREDO_MULTICAST_BUBBLE_TICKS   0       // In RefreshInterval units.
#define TEREDO_BUBBLE_INTERVAL          10 * SECONDS
#define TEREDO_SLOW_BUBBLE_INTERVAL     5 * MINUTES
#define TEREDO_BUBBLE_THRESHHOLD        2 * MINUTES
#define TEREDO_ROUTER_LIFETIME          5 * HOURS


//
// Teredo multicast bubbles are sent to group 224.0.0.252 on port 337.
//
#define TEREDO_MULTICAST_PREFIX         \
    { 0x20, 0x03, 0xe0, 0x00, 0x00, 0xfc, 0x01, 0x51, }

#define TEREDO_DEFAULT_TYPE             TEREDO_DISABLED

#define TEREDO_PORT                     htons(337)
#define TEREDO_SERVER_NAME              L"teredo.ipv6.microsoft.com"
#define TEREDO_SERVICE_PREFIX           { 0x20, 0x03, }

#define KEY_TEREDO_REFRESH_INTERVAL     L"RefreshInterval"
#define KEY_TEREDO_TYPE                 L"Type"
#define KEY_TEREDO_SERVER_NAME          L"ServerName"
#define KEY_TEREDO L"System\\CurrentControlSet\\Services\\Teredo"


//
// Configured parameters.
//
extern ULONG TeredoClientRefreshInterval;
extern TEREDO_TYPE TeredoType;
extern WCHAR TeredoServerName[NI_MAXHOST];

extern CONST IN6_ADDR TeredoIpv6ServicePrefix;
extern CONST IN6_ADDR TeredoIpv6MulticastPrefix;
extern TEREDO_CLIENT_STATE TeredoClient;
extern TEREDO_SERVER_STATE TeredoServer;


//
// Time.
//

__inline
LONG
TeredoGetTime(
    VOID
    )
{
    //
    // FILETIME is a 64 bit value representing the number of 100 nanoseconds.
    //
    C_ASSERT(sizeof(FILETIME) == sizeof(ULONGLONG));
    ULONGLONG Time;
    
    GetSystemTimeAsFileTime((PFILETIME) &Time);
    return ((ULONG) (Time / (10 * 1000 * 1000)));
}

#define TIME_GREATER(a, b) (((a) - (b)) > 0)


//
// Address validation and parsing.
//

__inline
BOOL
IN4_MULTICAST(IN_ADDR a) 
{
    return ((a.s_addr & 0x0000000f) == 0x0000000e);
}    

_inline
BOOL
IN4_ADDR_EQUAL(IN_ADDR a, IN_ADDR b)
{
    return (a.s_addr == b.s_addr);
}

_inline
BOOL
IN4_SOCKADDR_EQUAL(CONST SOCKADDR_IN *a, CONST SOCKADDR_IN *b)
{
    ASSERT((a->sin_family == AF_INET) && (b->sin_family == AF_INET));
    return (IN4_ADDR_EQUAL(a->sin_addr, b->sin_addr) &&
            (a->sin_port == b->sin_port));
}

__inline
BOOL
TeredoIpv6GlobalAddress(
    IN CONST IN6_ADDR *Address
    )
/*++

Routine Description:
    
    Determine whether the supplied IPv6 address is of global unicast scope.
 
--*/ 
{
    //
    // This can be coded quite a bit more efficiently!
    //
    if (IN6_IS_ADDR_UNSPECIFIED(Address) ||
        IN6_IS_ADDR_LOOPBACK(Address) ||
        IN6_IS_ADDR_MULTICAST(Address) ||
        IN6_IS_ADDR_LINKLOCAL(Address) ||
        IN6_IS_ADDR_SITELOCAL(Address)) {
        return FALSE;
    }    
        
    return TRUE;
}

__inline
BOOL
TeredoIpv4GlobalAddress(
    IN CONST UCHAR *Address
    )
/*++

Routine Description:
    
    Determine whether the supplied IPv4 address is of global unicast scope.
 
--*/ 
{
    if ((Address[0] > 223) ||   // ~Unicast
        (Address[0] == 0) ||    // 0/8
        (Address[0] == 127) ||  // 127/8
        (Address[0] == 10) ||   // 10/8
        ((Address[0] == 169) && (Address[1] == 254)) ||         // 169.254/16
        ((Address[0] == 172) && ((Address[1] & 0xf0) == 16)) || // 172.16/12
        ((Address[0] == 192) && (Address[1] == 168))) {         // 192.168/16 
            return FALSE;
    }
    
    return TRUE;
}

__inline
BOOL
TeredoServicePrefix(
    IN CONST IN6_ADDR *Address
    )
{
    return (Address->s6_words[0] == TeredoIpv6ServicePrefix.s6_words[0]);
}

__inline
BOOL
TeredoValidAdvertisedPrefix(
    IN CONST IN6_ADDR *Address,
    IN UCHAR Length
    )
{
    if (Length != 64) {
        return FALSE;
    }
    
    if (!TeredoServicePrefix(Address)) {
        return FALSE;
    }

    if (!TeredoIpv4GlobalAddress((PUCHAR) (Address->s6_words + 1))) {
        return FALSE;
    }
    
    return TRUE;
}

__inline
VOID
TeredoParseAddress(
    IN CONST IN6_ADDR *Address,
    OUT PIN_ADDR Ipv4Address,
    OUT PUSHORT Ipv4Port
    )
{
    ASSERT(TeredoServicePrefix(Address));
    
    //
    // These are returned in network byte order.
    //    
    ((PUSHORT) Ipv4Address)[0] = Address->s6_words[1];
    ((PUSHORT) Ipv4Address)[1] = Address->s6_words[2];
    *Ipv4Port = Address->s6_words[3];
}

__inline
BOOL
TeredoEqualPrefix(
    IN CONST IN6_ADDR *Address1,
    IN CONST IN6_ADDR *Address2
    )
{
    //
    // Compare Teredo IPv6 Service Prefix, Mapped IPv4 Address and Port.
    //
    return ((Address1->s6_words[0] == Address2->s6_words[0]) &&
            (Address1->s6_words[1] == Address2->s6_words[1]) &&
            (Address1->s6_words[2] == Address2->s6_words[2]) &&
            (Address1->s6_words[3] == Address2->s6_words[3]));
}


//
// Client API
//

DWORD
TeredoInitializeClient(
    VOID
    );

VOID
TeredoUninitializeClient(
    VOID
    );

VOID
TeredoCleanupClient(
    VOID
    );

__inline
VOID
TeredoReferenceClient(
    VOID
    )
{
    ASSERT(TeredoClient.ReferenceCount > 0);
    InterlockedIncrement(&(TeredoClient.ReferenceCount));
}

__inline
VOID
TeredoDereferenceClient(
    VOID
    )
{
    ASSERT(TeredoClient.ReferenceCount > 0);
    if (InterlockedDecrement(&(TeredoClient.ReferenceCount)) == 0) {
        TeredoCleanupClient();
    }
}

VOID
TeredoStartClient(
    VOID
    );

VOID
TeredoStopClient(
    VOID
    );

VOID
TeredoProbeClient(
    VOID
    );

VOID
TeredoQualifyClient(
    VOID
    );

VOID
TeredoClientAddressDeletionNotification(
    IN IN_ADDR Address
    );

VOID
TeredoClientRefreshIntervalChangeNotification(
    VOID
    );

__inline
VOID
TeredoRefreshClient(
    VOID
    )
{
    ASSERT(TeredoClient.State != TEREDO_STATE_OFFLINE);
    TeredoClientAddressDeletionNotification(
        TeredoClient.Io.SourceAddress.sin_addr);
}


//
// Server API
//

DWORD
TeredoInitializeServer(
    VOID
    );

VOID
TeredoUninitializeServer(
    VOID
    );

VOID
TeredoCleanupServer(
    VOID
    );

__inline
VOID
TeredoReferenceServer(
    VOID
    )
{
    ASSERT(TeredoServer.ReferenceCount > 0);
    InterlockedIncrement(&(TeredoServer.ReferenceCount));
}

__inline
VOID
TeredoDereferenceServer(
    VOID
    )
{
    ASSERT(TeredoServer.ReferenceCount > 0);
    if (InterlockedDecrement(&(TeredoServer.ReferenceCount)) == 0) {
        TeredoCleanupServer();
    }
}

VOID
TeredoStartServer(
    VOID
    );

VOID
TeredoStopServer(
    VOID
    );

VOID
TeredoServerAddressDeletionNotification(
    IN IN_ADDR Address
    );

__inline
VOID
TeredoRefreshServer(
    VOID
    )
{
    ASSERT(TeredoServer.State != TEREDO_STATE_OFFLINE);
    TeredoServerAddressDeletionNotification(
        TeredoServer.Io.SourceAddress.sin_addr);
}


//
// Common API
//

BOOL
TeredoInterface(
    IN PWCHAR Guid
    );

DWORD
TeredoInitializeGlobals(
    VOID
    );

VOID
TeredoUninitializeGlobals(
    VOID
    );

VOID
TeredoAddressChangeNotification(
    IN BOOL Delete,
    IN IN_ADDR Address
    );

VOID
TeredoRouteChangeNotification(
    VOID
    );

VOID
TeredoConfigurationChangeNotification(
    VOID
    );

VOID
WINAPI
TeredoWmiEventNotification(
    IN PWNODE_HEADER Event,
    IN UINT_PTR Context
    );

VOID
TeredoRequirementChangeNotification(
    IN BOOL Required
    );


//
// Peer API.
//

DWORD
TeredoInitializePeerSet(
    VOID
    );

VOID
TeredoUninitializePeerSet(
    VOID
    );

VOID
TeredoCleanupPeerSet(
    VOID
    );

PTEREDO_PEER
TeredoFindOrCreatePeer(
    IN CONST IN6_ADDR *Address
);

VOID
TeredoDestroyPeer(
    IN PTEREDO_PEER Peer
    );

__inline
VOID
TeredoReferencePeer(
    IN PTEREDO_PEER Peer
    )
{
    
    ASSERT(Peer->ReferenceCount > 0);
    InterlockedIncrement(&(Peer->ReferenceCount));
}

__inline
VOID
TeredoDereferencePeer(
    IN PTEREDO_PEER Peer
    )
{
    ASSERT(Peer->ReferenceCount > 0);
    if (InterlockedDecrement(&(Peer->ReferenceCount)) == 0) {
        TeredoDestroyPeer(Peer);
    }
}


//
// I/O API.
//

DWORD
TeredoInitializeIo(
    IN PTEREDO_IO TeredoIo,
    IN IN_ADDR Group,
    IN PTEREDO_REFERENCE Reference,
    IN PTEREDO_DEREFERENCE Dereference,
    IN LPOVERLAPPED_COMPLETION_ROUTINE IoCompletionCallback    
    );

VOID
TeredoCleanupIo(
    IN PTEREDO_IO TeredoIo
    );

DWORD
TeredoStartIo(
    IN PTEREDO_IO TeredoIo
    );

DWORD
TeredoRefreshSocket(
    IN PTEREDO_IO TeredoIo
    );

VOID
TeredoStopIo(
    IN PTEREDO_IO TeredoIo
    );

__inline
VOID
TeredoInitializePacket(
    IN PTEREDO_PACKET Packet
    )
{    
#if DBG
    Packet->Signature = TEREDO_PACKET_SIGNATURE;
#endif // DBG
    ZeroMemory(&(Packet->SocketAddress), sizeof(SOCKADDR_IN));
    Packet->SocketAddress.sin_family = AF_INET;    
    Packet->SocketAddressLength = sizeof(SOCKADDR_IN);
    Packet->Flags = 0;
    Packet->Buffer.buf = TEREDO_PACKET_BUFFER(Packet);
}

ULONG
TeredoPostReceives(
    IN PTEREDO_IO TeredoIo,
    IN PTEREDO_PACKET Packet
    );

PTEREDO_PACKET
TeredoTransmitPacket(
    IN PTEREDO_IO TeredoIo,
    IN PTEREDO_PACKET Packet
    );

BOOL
TeredoPostRead(
    IN PTEREDO_IO TeredoIo,
    IN PTEREDO_PACKET Packet OPTIONAL
    );

PTEREDO_PACKET
TeredoWritePacket(
    IN PTEREDO_IO TeredoIo,
    IN PTEREDO_PACKET Packet
    );


//
// Utility Functions.
//

ICMPv6Header *
TeredoParseIpv6Headers(
    IN PUCHAR Buffer,
    IN ULONG Bytes
    );

#endif // _TEREDO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\6to4svc\events\svcmain.c ===
#include "precomp.h"
#pragma hdrstop

#define SERVICE_NAME TEXT("6to4")

HANDLE          g_hServiceStatusHandle = INVALID_HANDLE_VALUE;
HANDLE          g_hDeviceNotificationHandle = INVALID_HANDLE_VALUE;
SERVICE_STATUS  g_ServiceStatus;

VOID
Set6to4ServiceStatus(
    IN DWORD   dwState,
    IN DWORD   dwErr)
{
    BOOL bOk;

    Trace1(FSM, _T("Setting state to %d"), dwState);

    g_ServiceStatus.dwCurrentState = dwState;
    g_ServiceStatus.dwCheckPoint   = 0;
    g_ServiceStatus.dwWin32ExitCode= dwErr;
#ifndef STANDALONE
    bOk = SetServiceStatus(g_hServiceStatusHandle, &g_ServiceStatus);
    if (!bOk) {
        Trace0(ERR, _T("SetServiceStatus returned failure"));
    }
#endif

    if (dwState == SERVICE_STOPPED) {
        Cleanup6to4();

        // Uninitialize tracing and error logging.    
        UNINITIALIZE_TRACING_LOGGING();
    }
}

DWORD
OnStartup()
{
    int     i;
    DWORD   dwErr;
    WSADATA wsaData;

    ENTER_API();

    // Initialize tracing and error logging.  Continue irrespective of
    // success or failure.  NOTE: TracePrintf and ReportEvent both have
    // built in checks for validity of TRACEID and LOGHANDLE.
    INITIALIZE_TRACING_LOGGING();
    
    TraceEnter("OnStartup");

    dwErr = Start6to4();
    
    TraceLeave("OnStartup");
    LEAVE_API();

    return dwErr;
}

VOID
OnStop(
    IN DWORD dwErr)
{
    DWORD i;

    ENTER_API();
    TraceEnter("OnStop");
    
    Set6to4ServiceStatus(SERVICE_STOP_PENDING, dwErr);

    if (Stop6to4()) {
        Set6to4ServiceStatus(SERVICE_STOPPED, dwErr);
    }

    if (g_hDeviceNotificationHandle != INVALID_HANDLE_VALUE) {
        UnregisterDeviceNotification(g_hDeviceNotificationHandle);
    }

    TraceLeave("OnStop");

    LEAVE_API();
}

////////////////////////////////////////////////////////////////
// ServiceMain - main entry point called by svchost or by the
// standalone main.
//

DWORD WINAPI
ServiceHandler(
    IN DWORD dwControl,
    IN DWORD dwEventType,
    IN PVOID pvEventData,
    IN PVOID pvContext)
{
    switch (dwControl) {
    case SERVICE_CONTROL_DEVICEEVENT:
        if (g_ServiceStatus.dwCurrentState == SERVICE_RUNNING) {
            ENTER_API();
            ShipwormDeviceChangeNotification(dwEventType, pvEventData);
            LEAVE_API();
        }
        return NO_ERROR;

    case SERVICE_CONTROL_STOP:
        OnStop(NO_ERROR);
        return NO_ERROR;
        
    case SERVICE_CONTROL_PARAMCHANGE:
        OnConfigChange();
        return NO_ERROR;

    default:
        Trace2(ANY, L"ServiceHandler %u (%u)", dwControl, dwEventType);
        break;    
    }
    
    return ERROR_CALL_NOT_IMPLEMENTED;
}


VOID WINAPI
ServiceMain(
    IN ULONG   argc,
    IN LPWSTR *argv)
{
    DWORD dwErr = NO_ERROR;
    DEV_BROADCAST_DEVICEINTERFACE PnpFilter;

    do {
#ifndef STANDALONE
        g_hServiceStatusHandle = RegisterServiceCtrlHandlerEx(
            SERVICE_NAME, ServiceHandler, NULL);

        // RegisterServiceCtrlHandler returns NULL on failure
        if (g_hServiceStatusHandle == NULL) {
            dwErr = GetLastError();
            break;
        }

        // Register for adapter arrival and removal notifications.
        ZeroMemory (&PnpFilter, sizeof(PnpFilter));
        PnpFilter.dbcc_size = sizeof(PnpFilter);
        PnpFilter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
        PnpFilter.dbcc_classguid = GUID_NDIS_LAN_CLASS;
        g_hDeviceNotificationHandle = RegisterDeviceNotification (
            (HANDLE) g_hServiceStatusHandle,
            &PnpFilter,
            DEVICE_NOTIFY_SERVICE_HANDLE);
    
        if (g_hDeviceNotificationHandle == NULL) {
            dwErr = GetLastError();
            break;
        }
#endif

        ZeroMemory(&g_ServiceStatus, sizeof(g_ServiceStatus));
        g_ServiceStatus.dwServiceType =
            SERVICE_WIN32_SHARE_PROCESS | SERVICE_INTERACTIVE_PROCESS;
        g_ServiceStatus.dwControlsAccepted =
            SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_PARAMCHANGE;
        Set6to4ServiceStatus(SERVICE_START_PENDING, NO_ERROR);

        // Do startup processing
        dwErr = OnStartup();
        if (dwErr) {
            break;
        }

#ifndef STANDALONE
        Set6to4ServiceStatus(SERVICE_RUNNING, NO_ERROR);
        // Wait until shutdown time
        
        return;
#endif

    } while (FALSE);

#ifndef STANDALONE
    OnStop(dwErr);
#endif

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\6to4svc\events\common.c ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

    common.c

Abstract:

    This module contains the shipworm interface to the IPv6 Helper Service.

Author:

    Mohit Talwar (mohitt) Wed Nov 07 11:27:01 2001

Environment:

    User mode only.

--*/

#include "precomp.h"
#pragma hdrstop


ULONG ShipwormClientRefreshInterval = SHIPWORM_REFRESH_INTERVAL;
BOOL ShipwormClientEnabled = (SHIPWORM_DEFAULT_TYPE == SHIPWORM_CLIENT);
BOOL ShipwormServerEnabled = (SHIPWORM_DEFAULT_TYPE == SHIPWORM_SERVER);
WCHAR ShipwormServerName[NI_MAXHOST] = SHIPWORM_SERVER_NAME;
WCHAR ShipwormServiceName[NI_MAXSERV] = SHIPWORM_SERVICE_NAME;

CONST IN6_ADDR ShipwormIpv6ServicePrefix = SHIPWORM_SERVICE_PREFIX;

#define DEVICE_PREFIX L"\\Device\\"

LPGUID ShipwormWmiEvent[] = {
    (LPGUID) &GUID_NDIS_NOTIFY_ADAPTER_ARRIVAL,
    (LPGUID) &GUID_NDIS_NOTIFY_ADAPTER_REMOVAL,
};


VOID
WINAPI
ShipwormWmiEventNotification(
    IN PWNODE_HEADER Event,
    IN UINT_PTR Context
    )
/*++

Routine Description:

    Process a WMI event (Adapter arrival or removal).
    
Arguments:

    Event - Supplies the event specific information.

    Context - Supplies the context
    
Return Value:

    None.
    
Caller LOCK: API.

--*/ 
{
    PWNODE_SINGLE_INSTANCE Instance = (PWNODE_SINGLE_INSTANCE) Event;
    USHORT AdapterNameLength;
    WCHAR AdapterName[MAX_ADAPTER_NAME_LENGTH], *AdapterGuid;
    PSHIPWORM_IO Io = NULL;

    if (Instance == NULL) {
        return;
    }
    
    ENTER_API();
    
    TraceEnter("ShipwormWmiEventNotification");
    
    //
    // WNODE_SINGLE_INSTANCE is organized thus...
    // +-----------------------------------------------------------+
    // |<--- DataBlockOffset --->| AdapterNameLength | AdapterName |
    // +-----------------------------------------------------------+
    //
    // AdapterName is defined as "\DEVICE\"AdapterGuid
    //
    AdapterNameLength =
        *((PUSHORT) (((PUCHAR) Instance) + Instance->DataBlockOffset));
    RtlCopyMemory(
        AdapterName,
        ((PUCHAR) Instance) + Instance->DataBlockOffset + sizeof(USHORT),
        AdapterNameLength);
    AdapterName[AdapterNameLength] = L'\0';
    AdapterGuid = AdapterName + wcslen(DEVICE_PREFIX);        
    Trace1(ANY, L"ShipwormAdapter: %s", AdapterGuid);


    if (memcmp(
        &(Event->Guid), &GUID_NDIS_NOTIFY_ADAPTER_ARRIVAL, sizeof(GUID)) == 0) {
        Trace0(ANY, L"GUID_NDIS_NOTIFY_ADAPTER_ARRIVAL");
        //
        // Adapter arrival (perhaps TUN).
        // Attempt to start the service (if it is not already running).
        //
        ShipwormStart();
        return;

        
    }

    if (memcmp(
        &(Event->Guid), &GUID_NDIS_NOTIFY_ADAPTER_REMOVAL, sizeof(GUID)) == 0)
    {
        
        Trace0(ANY, L"GUID_NDIS_NOTIFY_ADAPTER_REMOVAL");
        if (ShipwormClient.State != SHIPWORM_STATE_OFFLINE) {
            Io = &(ShipwormClient.Io);
        }

        if (ShipwormServer.State != SHIPWORM_STATE_OFFLINE) {
            Io = &(ShipwormServer.Io);
        }

        if ((Io != NULL) &&
            (_wcsicmp(Io->TunnelInterface, AdapterGuid) == 0)) {
            //
            // TUN adapter removal.
            // Stop the service if it is running.
            //
            ShipwormStop();
            
        
        }
    }

    LEAVE_API();
}


DWORD
__inline
ShipwormEnableWmiEvent(
    IN LPGUID EventGuid,
    IN BOOLEAN Enable
    )
{
    return WmiNotificationRegistrationW(
        EventGuid,                      // Event Type.
        Enable,                         // Enable or Disable.
        ShipwormWmiEventNotification,   // Callback.
        0,                              // Context.
        NOTIFICATION_CALLBACK_DIRECT);  // Notification Flags.
}


VOID
__inline
ShipwormDeregisterWmiEventNotification(
    VOID
    )
{
    int i;
    
    for (i = 0; i < (sizeof(ShipwormWmiEvent) / sizeof(LPGUID)); i++) {
        (VOID) ShipwormEnableWmiEvent(ShipwormWmiEvent[i], FALSE);
    }
}


DWORD
__inline
ShipwormRegisterWmiEventNotification(
    VOID
    )
{
    DWORD Error;
    int i;
    
    for (i = 0; i < (sizeof(ShipwormWmiEvent) / sizeof(LPGUID)); i++) {
        Error = ShipwormEnableWmiEvent(ShipwormWmiEvent[i], TRUE);
        if (Error != NO_ERROR) {
            goto Bail;
        }
    }

    return NO_ERROR;

Bail:
    ShipwormDeregisterWmiEventNotification();
    return Error;
}


ICMPv6Header *
ShipwormParseIpv6Headers (
    IN PUCHAR Buffer,
    IN ULONG Bytes
    )
{
    UCHAR NextHeader = IP_PROTOCOL_V6;
    ULONG Length;

    //
    // Parse up until the ICMPv6 header.
    //
    while (TRUE) {
        switch (NextHeader) {
        case IP_PROTOCOL_V6:
            if (Bytes < sizeof(IP6_HDR)) {
                return NULL;
            }
            NextHeader = ((PIP6_HDR) Buffer)->ip6_nxt;
            Length = sizeof(IP6_HDR);
            break;
            
        case IP_PROTOCOL_HOP_BY_HOP:
        case IP_PROTOCOL_DEST_OPTS:
        case IP_PROTOCOL_ROUTING:
            if (Bytes < sizeof(ExtensionHeader)) {
                return NULL;
            }
            NextHeader = ((ExtensionHeader *) Buffer)->NextHeader;
            Length = ((ExtensionHeader *) Buffer)->HeaderExtLength * 8 + 8;
            break;

        case IP_PROTOCOL_FRAGMENT:
            if (Bytes < sizeof(FragmentHeader)) {
                return NULL;
            }
            NextHeader = ((FragmentHeader *) Buffer)->NextHeader;
            Length = sizeof(FragmentHeader);
            break;
            
        case IP_PROTOCOL_AH:
            if (Bytes < sizeof(AHHeader)) {
                return NULL;
            }
            NextHeader = ((AHHeader *) Buffer)->NextHeader;
            Length = sizeof(AHHeader) +
                ((AHHeader *) Buffer)->PayloadLen * 4 + 8;
            break;

        case IP_PROTOCOL_ICMPv6:
            if (Bytes < sizeof(ICMPv6Header)) {
                return NULL;
            }
            return (ICMPv6Header *) Buffer;
            
        default:
            return NULL;
        }
        
        if (Bytes < Length) {
            return NULL;
        }
        Buffer += Length;
        Bytes -= Length;
    }
    ASSERT(FALSE);
}


__inline
VOID
ShipwormStart(
    VOID
    )
{
    //
    // Both client and server should not be enabled on the same node.
    //
    ASSERT(!ShipwormClientEnabled || !ShipwormServerEnabled);

    if (ShipwormClientEnabled) {
        //
        // The service might already be running, but that's alright.
        //
        ShipwormStartClient();
    }

    if (ShipwormServerEnabled) {
        //
        // The service might already be running, but that's alright.
        //
        ShipwormStartServer();
    }
}


__inline
VOID
ShipwormStop(
    VOID
    )
{
    //
    // Both client and server should not be enabled on the same node.
    //
    ASSERT(!ShipwormClientEnabled || !ShipwormServerEnabled);

    if (ShipwormClientEnabled) {
        //
        // The service might not be running, but that's alright.
        //
        ShipwormStopClient();
    }

    if (ShipwormServerEnabled) {
        //
        // The service might not be running, but that's alright.
        //
        ShipwormStopServer();
    }
}


DWORD
ShipwormInitialize(
    VOID
    )
/*++

Routine Description:

    Initializes the shipworm client and server and attempts to start them.

Arguments:

    None.

Return Value:

    NO_ERROR or failure code.

--*/
{
    DWORD Error;
    BOOL ClientInitialized = FALSE, ServerInitialized = FALSE;
    
    Error = ShipwormRegisterWmiEventNotification();
    if (Error != NO_ERROR) {
        return Error;
    }
    
    Error = ShipwormInitializeClient();
    if (Error != NO_ERROR) {
        goto Bail;
    }
    ClientInitialized = TRUE;
    
    
    Error = ShipwormInitializeServer();
    if (Error != NO_ERROR) {
        goto Bail;
    }
    ServerInitialized = TRUE;

    ShipwormStart();

    return NO_ERROR;

Bail:
    ShipwormDeregisterWmiEventNotification();
    
    if (ClientInitialized) {
        ShipwormUninitializeClient();
    }

    if (ServerInitialized) {
        ShipwormUninitializeServer();
    }

    return Error;
}


VOID
ShipwormUninitialize(
    VOID
    )
/*++

Routine Description:

    Uninitializes the shipworm client and server.

Arguments:

    None.

Return Value:

    None.
    
--*/
{
    ShipwormUninitializeClient();
    ShipwormUninitializeServer();
    ShipwormDeregisterWmiEventNotification();
}


VOID
ShipwormAddressChangeNotification(
    IN BOOL Delete,
    IN IN_ADDR Address
    )
/*++

Routine Description:

    Process an address deletion or addition request.

Arguments:

    Delete - Supplies a boolean.  TRUE if the address was deleted, FALSE o/w.

    Address - Supplies the IPv4 address that was deleted or added.
    
Return Value:

    None.
    
Caller LOCK: API.

--*/ 
{
    if (Delete) {
        //
        // Both client and server should not be running on the same node.
        //
        ASSERT((ShipwormClient.State == SHIPWORM_STATE_OFFLINE) ||
               (ShipwormServer.State == SHIPWORM_STATE_OFFLINE));

        if (ShipwormClient.State != SHIPWORM_STATE_OFFLINE) {
            ShipwormClientAddressDeletionNotification(Address);
        }
        
        if (ShipwormServer.State != SHIPWORM_STATE_OFFLINE) {
            ShipwormServerAddressDeletionNotification(Address);
        }

        return;
    }

    //
    // Address addition.
    // Attempt to start the service (if it is not already running).
    //
    ShipwormStart();
}


VOID
ShipwormConfigurationChangeNotification(
    VOID
    )
/*++

Routine Description:

    Process an configuration change request.

Arguments:

    None.
    
Return Value:

    None.
    
Caller LOCK: API.

--*/ 
{
    HKEY Key = INVALID_HANDLE_VALUE;
    SHIPWORM_TYPE Type;
    BOOL EnableClient, EnableServer;
    ULONG RefreshInterval;
    WCHAR OldServerName[NI_MAXHOST];
    WCHAR OldServiceName[NI_MAXSERV];    
    BOOL IoStateChange = FALSE;

    (VOID) RegOpenKeyExW(
        HKEY_LOCAL_MACHINE, KEY_SHIPWORM, 0, KEY_QUERY_VALUE, &Key);
    //
    // Continue despite errors, reverting to default values.
    //
    
    //
    // Get the new configuration parameters.
    //
    RefreshInterval = GetInteger(
        Key, KEY_SHIPWORM_REFRESH_INTERVAL, SHIPWORM_REFRESH_INTERVAL);
    if (RefreshInterval == 0) {
        //
        // Invalid value.  Revert to default.
        //
        RefreshInterval = SHIPWORM_REFRESH_INTERVAL;
    }
    ShipwormClientRefreshInterval = RefreshInterval;
    
    Type = GetInteger(Key, KEY_SHIPWORM_TYPE, SHIPWORM_DEFAULT_TYPE);
    if ((Type == SHIPWORM_DEFAULT) || (Type >= SHIPWORM_MAXIMUM)) {
        //
        // Invalid value.  Revert to default.
        //
        Type = SHIPWORM_DEFAULT_TYPE;
    }
    EnableClient = (Type == SHIPWORM_CLIENT);
    EnableServer = (Type == SHIPWORM_SERVER);

    wcscpy(OldServerName, ShipwormServerName);
    GetString(
        Key,
        KEY_SHIPWORM_SERVER_NAME,
        ShipwormServerName,
        NI_MAXHOST,
        SHIPWORM_SERVER_NAME);
    if (_wcsicmp(ShipwormServerName, OldServerName) != 0) {
        IoStateChange = TRUE;
    }
    
    wcscpy(OldServiceName, ShipwormServiceName);
    GetString(
        Key,
        KEY_SHIPWORM_SERVICE_NAME,
        ShipwormServiceName,
        NI_MAXSERV,
        SHIPWORM_SERVICE_NAME);
    if (_wcsicmp(ShipwormServiceName, OldServiceName) != 0) {
        IoStateChange = TRUE;
    }

    RegCloseKey(Key);
    
    //
    // Both client and server should not be enabled on the same node.
    //
    ASSERT(!ShipwormClientEnabled || !ShipwormServerEnabled);

    //
    // Stop / Start / Reconfigure.
    //
    if (!EnableClient && ShipwormClientEnabled) {
        ShipwormClientEnabled = FALSE;
        ShipwormStopClient();
    }
    
    if (!EnableServer && ShipwormServerEnabled) {
        ShipwormServerEnabled = FALSE;
        ShipwormStopServer();
    }

    if (EnableClient) {
        if (ShipwormClient.State != SHIPWORM_STATE_OFFLINE) {
            if (IoStateChange) {
                //
                // Refresh I/O state.
                //
                ShipwormClientAddressDeletionNotification(
                    ShipwormClient.Io.SourceAddress.sin_addr);
            }
        } else {
            ShipwormClientEnabled = TRUE;
            ShipwormStartClient();
        }
    }
    
    if (EnableServer) {
        if (ShipwormServer.State != SHIPWORM_STATE_OFFLINE) {
            if (IoStateChange) {
                //
                // Refresh I/O state.
                //
                ShipwormServerAddressDeletionNotification(
                    ShipwormServer.Io.SourceAddress.sin_addr);
            }
        } else {
            ShipwormServerEnabled = TRUE;
            ShipwormStartServer();
        }
    }    
}


VOID
ShipwormDeviceChangeNotification(
    IN DWORD Type,
    IN PVOID Data
    )
/*++

Routine Description:

    Process an adapter arrival or removal request.
    
Arguments:

    Type - Supplies the event type.

    Data - Supplies the data associated with the event.
    
Return Value:

    None.
    
Caller LOCK: API.

--*/ 
{
    DEV_BROADCAST_DEVICEINTERFACE *Adapter =
        (DEV_BROADCAST_DEVICEINTERFACE *) Data;
    PSHIPWORM_IO Io = NULL;
    PWCHAR AdapterGuid;

    TraceEnter("ShipwormDeviceChangeNotification");

    switch(Type) {
    case DBT_DEVICEARRIVAL:
        Trace0(ANY, L"DeviceArrival");
        break;
        
    case DBT_DEVICEREMOVECOMPLETE:
        Trace0(ANY, L"DeviceRemoveComplete");
        break;
      
    case DBT_DEVICEQUERYREMOVE:
        Trace0(ANY, L"DeviceQueryRemove");
        break;
        
    case DBT_DEVICEQUERYREMOVEFAILED:
        Trace0(ANY, L"DeviceQueryRemoveFailed");
        break;
        
    case DBT_DEVICEREMOVEPENDING:
        Trace0(ANY, L"DeviceQueryRemovePending");
        break;
        
    case DBT_CUSTOMEVENT:
        Trace0(ANY, L"DeviceCustomEvent");
        break;

    default:
        Trace2(ANY, L"Device Type %u, %u", Type, Adapter->dbcc_devicetype);
        break;    
    }
    
    //
    // Scan for the last occurance of the '{' character.
    // The string beginning at that position is the adapter GUID.
    //
    if ((Adapter == NULL) ||
        (Adapter->dbcc_devicetype != DBT_DEVTYP_DEVICEINTERFACE) ||
        ((AdapterGuid = wcsrchr(Adapter->dbcc_name, L'{')) == NULL)) {
        return;
    }
    
    switch(Type) {
    case DBT_DEVICEARRIVAL:
        //
        // Adapter arrival (perhaps TUN).
        // Attempt to start the service (if it is not already running).
        //
        ShipwormStart();
        return;

    case DBT_DEVICEREMOVECOMPLETE:
        if (ShipwormClient.State != SHIPWORM_STATE_OFFLINE) {
            Io = &(ShipwormClient.Io);
        }

        if (ShipwormServer.State != SHIPWORM_STATE_OFFLINE) {
            Io = &(ShipwormServer.Io);
        }

        if ((Io != NULL) &&
            (_wcsicmp(Io->TunnelInterface, AdapterGuid) == 0)) {
            //
            // TUN adapter removal.
            // Stop the service if it is running.
            //
            ShipwormStop();
        }
        
        return;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplayip6\addr.c ===
#include "dpsp.h"

#undef DPF_MODNAME
#define DPF_MODNAME    "GetHostAddr"

#define DUMMYPORTNAME "1" // value unused but must be non-zero

void
AddAddress(IPV6_INFO_INTERFACE *IF, IPV6_INFO_ADDRESS *ADE, void *Context)
{
    int i;
    LPSOCKADDR_IN6 ps;
    SOCKET_ADDRESS_LIST *pList = (SOCKET_ADDRESS_LIST *)Context;
    ULONG ulSize = sizeof(SOCKADDR_IN6);

    // Skip it if it's not a unicast address
    if (IN6_IS_ADDR_MULTICAST(&ADE->This.Address))
    {
        return;
    }

    ps = MemAlloc(ulSize);
    if (ps == NULL)
    {
        // Memory allocation failed
        DEBUGPRINTADDR(0,"Could not add address : \n",ps);
        return;
    }
    
    i = pList->iAddressCount++;
    
    ZeroMemory(ps, ulSize);
    ps->sin6_family = AF_INET6;
    ps->sin6_addr = ADE->This.Address;
    ps->sin6_scope_id = IF->ZoneIndices[ADE->Scope];
    
    pList->Address[i].iSockaddrLength = ulSize;
    pList->Address[i].lpSockaddr = (LPSOCKADDR)ps;

    DEBUGPRINTADDR(0,"Added address : \n",ps);
}

void
AddInterfaceAddresses(IPV6_INFO_INTERFACE *IF, void *Context1, void *Context2, void *Context3)
{
    // Skip the loopback interface
    if (IF->This.Index == 1)
    {
        return;
    }

    DPF(0,"Processing interface %d",IF->This.Index);
    ForEachAddress(IF, AddAddress, Context1);
}

void
CountAddress(IPV6_INFO_INTERFACE *IF, IPV6_INFO_ADDRESS *ADE, void *Context)
{
    ULONG *pulNumAddresses = (ULONG *)Context; 

    // Skip it if it's not a unicast address
    if (IN6_IS_ADDR_MULTICAST(&ADE->This.Address))
    {
        return;
    }

    (*pulNumAddresses)++;
}

void
CountInterfaceAddresses(IPV6_INFO_INTERFACE *IF, void *Context1, void *Context2, void *Context3)
{
    // Skip the loopback interface
    if (IF->This.Index == 1)
    {
        return;
    }

    ForEachAddress(IF, CountAddress, Context1);
}

// Helper function to retrieve host IP Address(es).
// Caller must call FreeHostAddr on list returned
SOCKET_ADDRESS_LIST *GetHostAddr(void)
{
    UINT err;
    ULONG ulNumAddresses = 0;
    SOCKET_ADDRESS_LIST *pList;

    ForEachInterface(CountInterfaceAddresses, &ulNumAddresses, NULL, NULL);
    if (ulNumAddresses == 0)
    {
        DPF(0,"could not get addresses for local machine\n");
        return NULL;
    }

    pList = MemAlloc( FIELD_OFFSET(SOCKET_ADDRESS_LIST, Address[ulNumAddresses] ));
    if (pList == NULL) 
    {
        DPF(0,"could not get addresses for local machine - err = %d\n", GetLastError());
        return NULL;
    }

    pList->iAddressCount = 0;
    ForEachInterface(AddInterfaceAddresses, pList, NULL, NULL);

    return pList;
} // GetHostAddr

void
FreeHostAddr(SOCKET_ADDRESS_LIST *pList)
{
    int i;
    for (i=0; i<pList->iAddressCount; i++)
    {
        MemFree(pList->Address[i].lpSockaddr);
    }
    MemFree(pList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplayip6\bilink.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    BILINK.H

Abstract:

    Management for doubly linked lists

Author:

    George Joy

Environment:

    32-bit 'C'

Revision History:

--*/// BILINK.H

#ifndef _BILINK_

#define _BILINK_

#if !defined(offsetof)
	#define offsetof(type, field) ((int)(&((type *)0)->field))
#endif	

typedef struct BILINK {
    struct BILINK *next;
    struct BILINK *prev;
} BILINK;

/* XLATOFF */

#define EMPTY_BILINK(_pBilink) ((_pBilink)->next==(_pBilink))

#ifdef DEBUG
    #define ASSERT_EMPTY_BILINK(_b) ASSERT((_b)->next==(_b))
#else
    #define ASSERT_EMPTY_BILINK(_b)
#endif

// This only works for BILINKS that are the first item in a structure.
#define BilinkToList( _pBilink ) \
	(_pBilink)->prev->next=NULL;

#define InitBilink( _pBilink ) \
    (_pBilink)->prev=(_pBilink)->next=(_pBilink);

#ifdef DEBUG

int FindObject(
    BILINK *link,
    BILINK *list
    );
#endif

void InsertAfter(
    BILINK *in,
    BILINK *after
    );

void InsertBefore(
     BILINK *in,
     BILINK *before
    );

void Delete(
     BILINK *p
);

/* XLATON */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplayip6\dpf.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.h
 *  Content:    header file for debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06-apr-95  craige  initial implementation
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96	kipo	added msinternal
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifdef NEW_DPF
#include "newdpf.h"
#else

    #ifndef __DPF_INCLUDED__
    #define __DPF_INCLUDED__

    #ifdef __cplusplus
    extern "C" {
    #endif

    #ifdef WINNT
        #undef DEBUG
        #ifdef DBG
	    #define DEBUG
        #endif
    #endif

    extern void cdecl dprintf( UINT lvl, LPSTR szFormat, ...);
    extern void DPFInit( void );
    #ifdef DEBUG
        #define DPFINIT()   DPFInit()
        #define DPF         dprintf
        #define DPF_ERR(a)  dprintf( 0, DPF_MODNAME ": " a );
        extern HWND hWndListBox;
        #if defined( _WIN32 ) && !defined(WINNT)
	    #define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
        #else
	    #define DEBUG_BREAK()       DebugBreak()
        #endif
        #define USE_DDASSERT
    #else
        #pragma warning(disable:4002)
        #define DPFINIT()
        #define DPF()
        #define DPF_ERR(a)
        #define DEBUG_BREAK()
    #endif

    #if defined(DEBUG) && defined(USE_DDASSERT)

    extern void _DDAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);

    #define DDASSERT(condition) if (!(condition)) _DDAssert(__FILE__, __LINE__, #condition)

    #else  /* DEBUG && USE_DDASSERT */

    #define DDASSERT(condition)

    #endif /* DEBUG && USE_DDASSERT */

    #ifdef _WIN32

    #ifdef DEBUG
        __inline DWORD clockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
        __inline DWORD clock()     {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}

        #define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
        #define TIMEZERO(t)   t ## T = 0, t ## N = 0
        #define TIMESTART(t)  t ## T -= clock(), t ## N ++
        #define TIMESTOP(t)   t ## T += clock()
        #define TIMEFMT(t)    ((DWORD)(t) / clockrate()), (((DWORD)(t) * 1000 / clockrate())%1000)
        #define TIMEOUT(t)    if (t ## N) DPF(1, #t ": %ld calls, %ld.%03ld sec (%ld.%03ld)", t ## N, TIMEFMT(t ## T), TIMEFMT(t ## T / t ## N))
    #else
        #define TIMEVAR(t)
        #define TIMEZERO(t)
        #define TIMESTART(t)
        #define TIMESTOP(t)
        #define TIMEFMT(t)
        #define TIMEOUT(t)
    #endif

    #endif
    #ifdef __cplusplus
    }
    #endif

    #endif
#endif //use new dpf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplayip6\dbgtopic.h ===
DEBUG_TOPIC(B,"&Blting")
DEBUG_TOPIC(C,"&Clipping")
DEBUG_TOPIC(D,"&DDraw Object")
DEBUG_TOPIC(F,"&Focus Changes")
DEBUG_TOPIC(H,"&HAL/HEL Calls")
DEBUG_TOPIC(I,"Internal Fn Entered")
DEBUG_TOPIC(K,"NT Kernel Calls")
DEBUG_TOPIC(L,"&Locking/Ownership")
DEBUG_TOPIC(O,"M&odes")
DEBUG_TOPIC(M,"&Memory")
DEBUG_TOPIC(P,"API &Parameters")
DEBUG_TOPIC(R,"&Reference Counting")
DEBUG_TOPIC(S,"&Surface Objects")
DEBUG_TOPIC(T,"Fil&ters")
DEBUG_TOPIC(V,"&Video Memory allocation")
DEBUG_TOPIC(W,"&Windows and Handles")
DEBUG_TOPIC(X,"Ad-Hoc Message &X")

#undef PROF_SECT
#define PROF_SECT "DirectPlay"

#undef DPF_MODULE_NAME
#ifdef START_STR
	#define DPF_MODULE_NAME START_STR
#else
	#define DPF_MODULE_NAME "DPWSOCK"
#endif


/*
 * Use this identifier to define which line in WIN.INI [DirectX] denotes the
 * debug control string
 */
#undef DPF_CONTROL_LINE
#define DPF_CONTROL_LINE "DPlayDebug"

/*
 * It is important that the first DEBUG_TOPIC appear at the top line of this
 * file, and that no other lines are interspersed between DEBUG_TOPIC lines.
 * (The debug system uses the __LINE__ pseudo-variable to identify topics)
 */

/*
 * Definitions for DPF detail levels:
 *
 * 0: Error useful for application developers.
 * 1: Warning useful for application developers.
 * 2: API Entered
 * 3: API parameters, API return values
 * 4: Driver conversation
 *
 * 5: Deeper program flow notifications
 * 6: Dump structures 
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplayip6\dllmain.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dllmain.c
 *  Content:	dpwsock.dll initialization
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   2/1	andyco	created it
 ***************************************************************************/
//#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "dpf.h"
#include "dpsp.h"
#include "memalloc.h"

DWORD dwRefCnt=0;// the # of attached processes
BOOL bFirstTime;

#undef DPF_MODNAME
#define DPF_MODNAME "dpwsock sp dllmain"

HANDLE ghInstance; // save this for our dialog box

/*
 * DllMain
 */
BOOL WINAPI DllMain(HINSTANCE hmod, DWORD dwReason, LPVOID lpvReserved)
{

    switch( dwReason )
    {
	
	case DLL_PROCESS_ATTACH:
	
	    DisableThreadLibraryCalls( hmod );
	    DPFINIT(); // bugbug : dpfinit for every proc?

	    DPF( 0, "====> ENTER: DLLMAIN(%08lx): Process Attach: %08lx, tid=%08lx", DllMain,
	            GetCurrentProcessId(), GetCurrentThreadId() );
	    	
	    /*
	     * initialize memory
	     */
	    if( dwRefCnt == 0 )
	    {
			INIT_DPSP_CSECT();	
			
	        if( !MemInit() )
	        {
		        DPF( 0, "LEAVING, COULD NOT MemInit" );
		        return FALSE;
	        }

			// save the instance
			ghInstance = hmod;
			
	    }

    	dwRefCnt++;

        break;

    case DLL_PROCESS_DETACH:

	    DPF( 2, "====> ENTER: DLLMAIN(%08lx): Process Detach %08lx, tid=%08lx",
	        DllMain, GetCurrentProcessId(), GetCurrentThreadId() );
	    
	    dwRefCnt--;        
      	if (0==dwRefCnt) 
       	{
	
			DPF(0,"DPWSOCK - dllmain - going away!");

		    #ifdef DEBUG
	    	    MemState();
		    #endif // debug
	    
	        MemFini(); 
			
			FINI_DPSP_CSECT();
       	} 
	    break;

    default:
        break;
    }

    return TRUE;

} /* DllMain */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplayip6\dputils.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dputils.c
 *  Content:	common support routines
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 *  3/17/97	kipo	created it
 ***************************************************************************/

#include <windows.h>

#include "dpf.h"
#include "dputils.h"

/*
 ** WideToAnsi
 *
 *  CALLED BY:	everywhere
 *
 *  PARAMETERS: lpStr - destination string
 *				lpWStr - string to convert
 *				cchStr - size of dest buffer
 *
 *  DESCRIPTION:
 *				converts unicode lpWStr to ansi lpStr.
 *				fills in unconvertable chars w/ DPLAY_DEFAULT_CHAR "-"
 *				
 *
 *  RETURNS:  if cchStr is 0, returns the size required to hold the string
 *				otherwise, returns the number of chars converted
 *
 */
int WideToAnsi(LPSTR lpStr,LPWSTR lpWStr,int cchStr)
{
	int rval;
	BOOL bDefault;

	if (!lpWStr && cchStr)
	{
		// can't call us w/ null pointer & non-zero cch
		DDASSERT(FALSE);
		return 0;
	}
	
	// use the default code page (CP_ACP)
	// -1 indicates WStr must be null terminated
	rval = WideCharToMultiByte(CP_ACP,0,lpWStr,-1,lpStr,cchStr,
			DPLAY_DEFAULT_CHAR,&bDefault);

	if (bDefault)
	{
		DPF(0,"!!! WARNING - used default string in WideToAnsi conversion.!!!");
		DPF(0,"!!! Possible bad unicode string - (you're not hiding ansi in there are you?) !!! ");
	}
	
	return rval;

} // WideToAnsi

/*
 ** AnsiToWide
 *
 *  CALLED BY: everywhere
 *
 *  PARAMETERS: lpWStr - dest string
 *				lpStr  - string to convert
 *				cchWstr - size of dest buffer
 *
 *  DESCRIPTION: converts Ansi lpStr to Unicode lpWstr
 *
 *
 *  RETURNS:  if cchStr is 0, returns the size required to hold the string
 *				otherwise, returns the number of chars converted
 *
 */
int AnsiToWide(LPWSTR lpWStr,LPSTR lpStr,int cchWStr)
{
	int rval;

	if (!lpStr && cchWStr)
	{
		// can't call us w/ null pointer & non-zero cch
		DDASSERT(FALSE);
		return 0;
	}

	rval =  MultiByteToWideChar(CP_ACP,0,lpStr,-1,lpWStr,cchWStr);

	return rval;
}  // AnsiToWide
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplayip6\dplaysp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplaysp.h
 *  Content:    DirectPlay Service Provider header
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/96    	andyco  created it
 *  1/26/96   	andyco  list data structures
 *	2/15/96		andyco	packed structures (for net xport)
 *	3/16/96		andyco	added shutdown callback
 *	3/25/96		andyco	added sp nodes for sp enum
 *	3/28/96		andyco	added free receive buffer callback
 *	4/9/96		andyco	moved dplayi_dplay, packed player, spnode, etc. to dplaypr.h
 *	4/10/96		andyco	added getmessagesize,isvalidmessage fn's
 *  4/11/96		andyco	added spdata instead of reserving a bunch of dwords
 *	4/12/96		andyco	added dplay_xxx methods to get rid of dpmess.h macros
 *	4/18/96		andyco	added remote players to createplayer, getplayer + group
 *						list fn's
 *	4/25/96		andyco	got rid of dwreservedx. added dwSPHeaderSize. spblob  
 *						follows message
 *	5/2/96		andyco	replaced idirectplay * with iunknown *
 *	5/9/96		andyco	idirectplay2
 *	6/8/96		andyco	moved dplayi_player/group to dplaypr.h. ported from 
 *						(now defunct) dplayi.h.
 *	6/19/96		andyco	changed names, etc. for consistency
 *	6/22/96		andyco	tossed dwCookies. removed pUnk from callbacks.  removed sessiondesc
 *	 					from callbacks.  alphapathetical order.
 *	6/22/96		andyco	made DPlay_xxx functions a COM interface (IDirectPlaySP)
 *	6/22/96		kipo	added EnumConnectionData() method.
 *	6/23/96		andyco	updated comments. removed bLocal from Create fn's (look 
 *						at flags).
 *	6/23/96		kipo	cleanup for service provider lab.
 *	6/24/96		kipo	added version number
 *	6/24/96		andyco	added getaddress
 *	6/25/96		kipo	added WINAPI prototypes and updated for DPADDRESS
 *	6/28/96		kipo	added support for CreateAddress() method.
 *	7/10/96		andyco	added dwflags to createaddress.  changed guid * to
 *						refguid in createaddress call.
 *	7/16/96		kipo	changed address types to be GUIDs instead of 4CC
 *  7/30/96     kipo    added DPLAYI_PLAYER_CREATEDPLAYEREVENT
 *  8/23/96     kipo    incremented major version number
 *	10/10/96	andyco	added optimized groups
 *	2/7/97		andyco	added idpsp to each callback
 *	3/04/97		kipo	updated gdwDPlaySPRefCount definition
 *	3/17/97		kipo	added support for CreateCompoundAddress()
 *	5/8/97		myronth	added DPLAYI_GROUP_STAGINGAREA (internal)
 *	5/18/97		kipo	added DPLAYI_PLAYER_SPECTATOR
 *	5/23/97		kipo	Added support for return status codes
 *	10/21/97	myronth	Added DPLAYI_GROUP_HIDDEN
 *	10/29/97	myronth	Added DPLAYI_PLAYER_OWNER (internal)
 *	10/31/97	andyco	added voice call
 *	1/20/98		myronth	#ifdef'd out voice support
 *	1/28/98		sohailm	Added dwSessionFlags to DPSP_OPENDATA
 *  4/1/98      aarono  Added DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE
 *  6/2/98		aarono  Added DPLAYI_PLAYER_BEING_DESTROYED to avoid
 *                       deleting more than once.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DPLAYSP_INCLUDED__
#define __DPLAYSP_INCLUDED__

#include "dplay.h"
#include "dplobby.h"

#ifdef __cplusplus
extern "C" {
#endif

/*============================================================================
 *
 * DirectPlay Service Provider Structures
 *
 * Various structures used to invoke DirectPlay Service Providers.
 *
 *==========================================================================*/

/*
 * Callback for EnumMRU()
 */
typedef BOOL (PASCAL *LPENUMMRUCALLBACK)(
    LPCVOID         lpData,
    DWORD           dwDataSize,
    LPVOID          lpContext);

/*
 * Major version number for service provider.
 *
 * The most-significant 16 bits are reserved for the DirectPlay
 * major version number. The least-significant 16 bits are for
 * use by the service provider.
 */
#define DPSP_MAJORVERSION               0x00060000

/*
 * This is the major version number that DirectX 3 (DX3) shipped with
 */
#define DPSP_DX3VERSION               	0x00040000

/*
 * This is the major version number that DirectX 5 (DX5) shipped with
 */
#define DPSP_DX5VERSION               	0x00050000

/*
 * Masks to help check the version info
 */
#define DPSP_MAJORVERSIONMASK			0xFFFF0000

#define DPSP_MINORVERSIONMASK			0x0000FFFF

//@@BEGIN_MSINTERNAL
#ifdef BIGMESSAGEDEFENSE
/*
 * warning types that could be returned from the SP via HandleSPWarning
 * see below for corresponding structures
 */
#define DPSPWARN_MESSAGETOOBIG			0xB0FF0001
#define DPSPWARN_PLAYERDEAD				0xB0FF0002

#endif
//@@END_MSINTERNAL

/*
 * DPLAYI_PLAYER_FLAGS
 *
 * These flags may be used with players or groups, as appropriate.
 * The service provider can get these by calling IDirectPlaySP->GetFlags()
 * as defined below.  The flags are also available in the dwFlags field
 * for most of the callback data structures.
 * 
 * These flags are set by DirectPlay - they are read only for the 
 * service provider
 *
 */

/*
 * Player is the system player (player only).
 */
#define DPLAYI_PLAYER_SYSPLAYER         0x00000001

/* 
 * Player is the name server (player only). Only valid when 
 * DPLAYI_PLAYER_SYSPLAYER is also set.
 */
#define DPLAYI_PLAYER_NAMESRVR          0x00000002

/*
 * Player belongs to a group (player only).
 */
#define DPLAYI_PLAYER_PLAYERINGROUP     0x00000004

/*
 * Player allocated on this IDirectPlay (player or group).
 */
#define DPLAYI_PLAYER_PLAYERLOCAL       0x00000008

//@@BEGIN_MSINTERNAL
/*
 * Player event allocated by DirectPlay (player only).
 * Used for compatability with the IDirectPlay1 API.
 * INTERNAL USE ONLY
 */
#define DPLAYI_PLAYER_CREATEDPLAYEREVENT 0x00000010
//@@END_MSINTERNAL

/*
 * This group is the system group.  If the service provider returns
 * DPCAPS_GROUPOPTIMIZED on a GetCaps call, then DirectPlay will create
 * a system group containing all players in the game.  Sends by the application
 * to DPID_ALLPLAYERS will be sent to this group.  (group only).
 *												   
 */
#define DPLAYI_GROUP_SYSGROUP			0x00000020

/*
 * DirectPlay "owns" this group.  Sends to this group will be emulated by DirectPlay
 * (sends go to each individual member).  This flag  is set on a group if the
 * Service Provider returns failure to the CreateGroup or AddPlayerToGroup
 * callback. (group only).
 *
 */
#define DPLAYI_GROUP_DPLAYOWNS			0x00000040

/*
 * This player is the app's server player
 */
#define DPLAYI_PLAYER_APPSERVER       	0x00000080

//@@BEGIN_MSINTERNAL
/*
 * This group is a staging area
 */
#define DPLAYI_GROUP_STAGINGAREA       	0x00000100
//@@END_MSINTERNAL

/*
 * This player is a spectator
 */
#define DPLAYI_PLAYER_SPECTATOR       	0x00000200

/*
 * This group is hidden
 */
#define DPLAYI_GROUP_HIDDEN		       	0x00000400

//@@BEGIN_MSINTERNAL
/*
 * Player is the owner of a group.  (Only used
 * internally, and only used during EnumGroupPlayers).
 * INTERNAL USE ONLY
 */
#define DPLAYI_PLAYER_OWNER             0x00000800

// a-josbor: Internal flag that gets set when the Keepalive has
//	determined that this player should be killed
#define DPLAYI_PLAYER_ON_DEATH_ROW		0x00001000

// aarono: use this flag to mark players waiting for nametable.
// any sends to these players just return DPERR_UNAVAILABLE
// this bit is cleared when we transmit the nametable.
#define DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE 0x00002000

// a-josbor: set when we get an error back on a reliable
// send.  We don't kill them right away because there might
// be messages pending from them
#define DPLAYI_PLAYER_CONNECTION_LOST		0x00004000
/*
 * Used to stop re-entering destory player
 */
#define DPLAYI_PLAYER_BEING_DESTROYED 0x00010000

#define DPLAYI_PLAYER_NONPROP_FLAGS ( DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE | \
									  DPLAYI_PLAYER_BEING_DESTROYED | \
									  DPLAYI_PLAYER_ON_DEATH_ROW |\
									  DPLAYI_PLAYER_CONNECTION_LOST )

//@@END_MSINTERNAL


/*
 *	IDirectPlaySP
 *
 *	Service providers are passed an IDirectPlaySP interface
 *	in the SPInit method. This interface is used to call DirectPlay.
 */

struct IDirectPlaySP;

typedef struct IDirectPlaySP FAR* LPDIRECTPLAYSP;

#undef INTERFACE
#define INTERFACE IDirectPlaySP
DECLARE_INTERFACE_( IDirectPlaySP, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlaySP methods ***/
    STDMETHOD(AddMRUEntry)          (THIS_ LPCWSTR, LPCWSTR, LPCVOID, DWORD, DWORD) PURE;
    STDMETHOD(CreateAddress)        (THIS_ REFGUID,REFGUID,LPCVOID,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(EnumAddress)          (THIS_ LPDPENUMADDRESSCALLBACK,LPCVOID,DWORD,LPVOID) PURE;
    STDMETHOD(EnumMRUEntries)       (THIS_ LPCWSTR, LPCWSTR, LPENUMMRUCALLBACK, LPVOID) PURE;
    STDMETHOD(GetPlayerFlags)       (THIS_ DPID,LPDWORD) PURE;
    STDMETHOD(GetSPPlayerData)      (THIS_ DPID,LPVOID *,LPDWORD,DWORD) PURE;
    STDMETHOD(HandleMessage)        (THIS_ LPVOID,DWORD,LPVOID) PURE;
    STDMETHOD(SetSPPlayerData)      (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    /*** IDirectPlaySP methods added for DX 5 ***/
    STDMETHOD(CreateCompoundAddress)(THIS_ LPCDPCOMPOUNDADDRESSELEMENT,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetSPData)      		(THIS_ LPVOID *,LPDWORD,DWORD) PURE;
    STDMETHOD(SetSPData)      		(THIS_ LPVOID,DWORD,DWORD) PURE;
    /*** IDirectPlaySP methods added for DX 6 ***/
    STDMETHOD_(VOID,SendComplete)   (THIS_ LPVOID,DWORD) PURE;
//@@BEGIN_MSINTERNAL 
#ifdef BIGMESSAGEDEFENSE
    STDMETHOD(HandleSPWarning)      (THIS_ LPVOID,DWORD,LPVOID) PURE;
#endif
//@@END_MSINTERNAL
};

/*
 * GUID for IDirectPlaySP
 */
// {0C9F6360-CC61-11cf-ACEC-00AA006886E3}
DEFINE_GUID(IID_IDirectPlaySP, 0xc9f6360, 0xcc61, 0x11cf, 0xac, 0xec, 0x0, 0xaa, 0x0, 0x68, 0x86, 0xe3);

/* CALLBACK DATA STRUCTURES
 *
 * These are passed by DirectPlay to the service provider when
 * the callback is invoked.
 */

/*
 * DPSP_ADDPLAYERTOGROUPDATA
 */
typedef struct _DPSP_ADDPLAYERTOGROUPDATA
{
    DPID        idPlayer;
    DPID        idGroup;
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_ADDPLAYERTOGROUPDATA;

typedef DPSP_ADDPLAYERTOGROUPDATA FAR* LPDPSP_ADDPLAYERTOGROUPDATA;

/*
 * DPSP_CLOSEDATA - used with CloseEx
 */
typedef struct _DPSP_CLOSEDATA
{
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_CLOSEDATA;

typedef DPSP_CLOSEDATA FAR* LPDPSP_CLOSEDATA;

/*
 * DPSP_CREATEGROUPDATA
 */
typedef struct _DPSP_CREATEGROUPDATA 
{
    DPID        idGroup;
    DWORD       dwFlags;            //  DPLAYI_PLAYER_xxx flags 
    LPVOID      lpSPMessageHeader;  // For local groups, lpSPMessageHeader will be 
                                    // NULL. For remote groups, lpSPMessageHeader 
                                    // will be the header that was received with 
                                    // the AddPlayer message.
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_CREATEGROUPDATA;

typedef DPSP_CREATEGROUPDATA FAR* LPDPSP_CREATEGROUPDATA;

/*
 * DPSP_CREATEPLAYERDATA
 */
typedef struct _DPSP_CREATEPLAYERDATA
{
    DPID        idPlayer;
    DWORD       dwFlags;            //  DPLAYI_PLAYER_xxx flags 
    LPVOID      lpSPMessageHeader;  // For local groups, lpSPMessageHeader will be 
                                    // NULL. For remote groups, lpSPMessageHeader 
                                    // will be the header that was received with 
                                    // the AddPlayer message.
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_CREATEPLAYERDATA;

typedef DPSP_CREATEPLAYERDATA FAR* LPDPSP_CREATEPLAYERDATA;

/*
 * DPSP_DELETEGROUPDATA
 */
typedef struct _DPSP_DELETEGROUPDATA
{
    DPID        idGroup;
    DWORD       dwFlags;            //  DPLAYI_PLAYER_xxx flags 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_DELETEGROUPDATA;

typedef DPSP_DELETEGROUPDATA FAR* LPDPSP_DELETEGROUPDATA;

/*
 * DPSP_DELETEPLAYERDATA
 */
typedef struct _DPSP_DELETEPLAYERDATA
{
    DPID        idPlayer;           //  player being deleted 
    DWORD       dwFlags;            //  DPLAYI_PLAYER_xxx flags 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_DELETEPLAYERDATA;

typedef DPSP_DELETEPLAYERDATA FAR* LPDPSP_DELETEPLAYERDATA;

/*
 * DPSP_ENUMSESSIONSDATA
 */
typedef struct _DPSP_ENUMSESSIONSDATA
{
    LPVOID      lpMessage;          //  enum message to send 
    DWORD       dwMessageSize;      //  size of message to send (including sp header) 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
    BOOL		bReturnStatus;      //  TRUE to return status on progress of enum
} DPSP_ENUMSESSIONSDATA;                

typedef DPSP_ENUMSESSIONSDATA FAR* LPDPSP_ENUMSESSIONSDATA;

/*
 * DPSP_GETADDRESSDATA
 */
typedef struct _DPSP_GETADDRESSDATA
{ 
    DPID        idPlayer;           // player (or group) to get ADDRESS for 
    DWORD       dwFlags;            // DPLAYI_PLAYER_xxx flags for idPlayer
    LPDPADDRESS lpAddress;          // return buffer for address of idPlayer
    LPDWORD     lpdwAddressSize;    // pointer to size of address buffer. If 
                                    // this is less than the required size 
                                    // (or is 0) the service provider should
                                    // set *lpdwAddressSize to the required
                                    // size and return DPERR_BUFFERTOOSMALL
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_GETADDRESSDATA;

typedef DPSP_GETADDRESSDATA FAR* LPDPSP_GETADDRESSDATA;

/*
 * DPSP_GETADDRESSCHOICESDATA
 */
typedef struct _DPSP_GETADDRESSCHOICESDATA
{ 
    LPDPADDRESS lpAddress;          // return buffer for address choices
    LPDWORD     lpdwAddressSize;    // pointer to size of address buffer. If 
                                    // this is less than the required size 
                                    // (or is 0) the service provider should
                                    // set *lpdwAddressSize to the required
                                    // size and return DPERR_BUFFERTOOSMALL
	IDirectPlaySP * lpISP;
} DPSP_GETADDRESSCHOICESDATA;

typedef DPSP_GETADDRESSCHOICESDATA FAR* LPDPSP_GETADDRESSCHOICESDATA;

/*
 * DPSP_GETCAPSDATA
 */
typedef struct _DPSP_GETCAPSDATA
{ 
    DPID        idPlayer;           //  player to get caps for 
    LPDPCAPS    lpCaps;
    DWORD       dwFlags;            //  DPGETCAPS_xxx 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_GETCAPSDATA;

typedef DPSP_GETCAPSDATA FAR* LPDPSP_GETCAPSDATA;

/*
 * DPSP_OPENDATA
 */
typedef struct _DPSP_OPENDATA
{ 
    BOOL        bCreate;            // TRUE if creating, FALSE if joining 
    LPVOID      lpSPMessageHeader;  // If we are joining a session, lpSPMessageData 
                                    // is the message data received with the 
                                    // EnumSessionsReply message. If we are creating 
                                    // a session, it will be set to NULL. 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
    BOOL		bReturnStatus;      // TRUE to return status on progress of open
    /*** fields added for DX 6 ***/    
    DWORD		dwOpenFlags;		// flags passed by app to IDirectPlayX->Open(...)
    DWORD		dwSessionFlags;		// flags passed by app in the session desc
} DPSP_OPENDATA;

typedef DPSP_OPENDATA FAR* LPDPSP_OPENDATA;

/*
 * DPSP_REMOVEPLAYERFROMGROUPDATA
 */
typedef struct _DPSP_REMOVEPLAYERFROMGROUPDATA
{
    DPID        idPlayer;
    DPID        idGroup;
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_REMOVEPLAYERFROMGROUPDATA;

typedef DPSP_REMOVEPLAYERFROMGROUPDATA FAR* LPDPSP_REMOVEPLAYERFROMGROUPDATA;

/*
 * DPSP_REPLYDATA
 */
typedef struct _DPSP_REPLYDATA
{			  
    LPVOID      lpSPMessageHeader;  //  header that was received by dplay 
                                    // (with the message we're replying to) 
    LPVOID      lpMessage;          //  message to send 
    DWORD       dwMessageSize;      //  size of message to send (including sp header) 
    DPID        idNameServer;       //  player id of nameserver 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_REPLYDATA;               

typedef DPSP_REPLYDATA FAR* LPDPSP_REPLYDATA;

/*
 * DPSP_SENDDATA
 */
typedef struct _DPSP_SENDDATA
{
    DWORD       dwFlags;            //  e.g. DPSEND_GUARANTEE 
    DPID        idPlayerTo;         //  player we're sending to 
    DPID        idPlayerFrom;       //  player we're sending from 
    LPVOID      lpMessage;          //  message to send 
    DWORD       dwMessageSize;      //  size of message to send (including sp header) 
    BOOL        bSystemMessage;     //  TRUE if this is a system message 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_SENDDATA;

typedef DPSP_SENDDATA FAR* LPDPSP_SENDDATA;

/*
 * DPSP_SENDTOGROUPDATA
 */
typedef struct _DPSP_SENDTOGROUPDATA
{
    DWORD       dwFlags;            //  e.g. DPSEND_GUARANTEE 
    DPID        idGroupTo;          //  group we're sending to 
    DPID        idPlayerFrom;       //  player we're sending from 
    LPVOID      lpMessage;          //  message to send 
    DWORD       dwMessageSize;      //  size of message to send (including sp header) 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_SENDTOGROUPDATA;

typedef DPSP_SENDTOGROUPDATA FAR* LPDPSP_SENDTOGROUPDATA;

/*
 * DPSP_SENDEXDATA
 */
typedef struct _DPSP_SENDEXDATA
{
	IDirectPlaySP * lpISP;			//  indication interface
	
    DWORD       dwFlags;            //  e.g. DPSEND_GUARANTEE 
    DPID        idPlayerTo;         //  player we're sending to 
    DPID        idPlayerFrom;       //  player we're sending from 
    LPSGBUFFER  lpSendBuffers;      //  scatter gather array of send data
    DWORD       cBuffers;           //  count of buffers
    DWORD       dwMessageSize;      //  total size of message
    DWORD       dwPriority;         //  message priority
    DWORD       dwTimeout;          //  timeout for message in ms (don't send after t/o)
    LPVOID      lpDPContext;        //  async only: context value to use when notifying completion
    LPDWORD     lpdwSPMsgID;        //  async only: message id to be assigned by SP for use in other apis.
    BOOL        bSystemMessage;     //  TRUE if this is a system message 
    
} DPSP_SENDEXDATA;

typedef DPSP_SENDEXDATA FAR* LPDPSP_SENDEXDATA;


/*
 * DPSP_SENDTOGROUPEXDATA
 */
typedef struct _DPSP_SENDTOGROUPEXDATA
{
	IDirectPlaySP * lpISP;			//  indication interface
	
    DWORD       dwFlags;            //  e.g. DPSEND_GUARANTEE 
    DPID        idGroupTo;          //  group we're sending to 
    DPID        idPlayerFrom;       //  player we're sending from 
    LPSGBUFFER  lpSendBuffers;      //  scatter gather array of send data
    DWORD       cBuffers;           //  count of buffers
    DWORD       dwMessageSize;      //  total size of message
    DWORD       dwPriority;         //  message priority
    DWORD       dwTimeout;          //  timeout for message in ms (don't send after t/o)
    LPVOID      lpDPContext;        //  async only: context value to use when notifying completion
    LPDWORD     lpdwSPMsgID;        //  async only: message id to be assigned by SP for use in other apis.

} DPSP_SENDTOGROUPEXDATA;

typedef DPSP_SENDTOGROUPEXDATA FAR* LPDPSP_SENDTOGROUPEXDATA;

/*
 * DPSP_GETMESSAGEQUEUE
 */
typedef struct _DPSP_GETMESSAGEQUEUEDATA
{
	IDirectPlaySP * lpISP;			//  indication interface

	DWORD           dwFlags;
	DPID            idFrom;			
	DPID            idTo;
	LPDWORD         lpdwNumMsgs;
	LPDWORD         lpdwNumBytes;

} DPSP_GETMESSAGEQUEUEDATA;

typedef DPSP_GETMESSAGEQUEUEDATA FAR* LPDPSP_GETMESSAGEQUEUEDATA;

/*
 * DPSP_CANCELSEND
 */
 
#define DPCANCELSEND_PRIORITY		0x00000001
#define DPCANCELSEND_ALL            0x00000002

typedef struct _DPSP_CANCELDATA
{
	IDirectPlaySP * lpISP;			//  indication interface

	DWORD           dwFlags;        // 0,DPCANCELSEND_PRIORITY,DPCANCELSEND_ALL,etc.
	LPRGLPVOID      lprglpvSPMsgID; // cancel just these messages      (dwFlags == 0)
	DWORD           cSPMsgID;       // number of message id's in array (dwFlags == 0)
	DWORD           dwMinPriority;  // cancel all sends at this priority (dwFlags==DPCANCELSEND_PRIORITY)
	DWORD           dwMaxPriority;  // cancel all sends between Min and Max.
	
} DPSP_CANCELDATA;

typedef DPSP_CANCELDATA FAR* LPDPSP_CANCELDATA;

/*
 * DPSP_SHUTDOWNDATA - used with ShutdownEx
 */
typedef struct _DPSP_SHUTDOWNDATA
{
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_SHUTDOWNDATA;

typedef DPSP_SHUTDOWNDATA FAR* LPDPSP_SHUTDOWNDATA;

//@@BEGIN_MSINTERNAL
#ifdef BIGMESSAGEDEFENSE
/*
 * DPSP_MSGTOOBIG - used with HandleSPNotification (DPSPWARN_MESSAGETOOBIG)
 */
typedef struct _DPSP_MSGTOOBIG
{
	DWORD	dwType;
	LPBYTE 	pReceiveBuffer;	// --> pointer to the message data
	DWORD 	dwBytesReceived;// --> the number of bytes of the message actually received
	DWORD 	dwMessageSize;	// --> the size of the message as understood by the SP
} DPSP_MSGTOOBIG;

typedef DPSP_MSGTOOBIG FAR* LPDPSP_MSGTOOBIG;

/*
 * DPSP_PLAYERDEAD - used with HandleSPNotification (DPSPWARN_PLAYERDEAD)
 */
typedef struct _DPSP_PLAYERDISCONNECT
{
	DWORD	dwType;
	DPID	dwID;		// ID of the Sys player that has been disconnected
} DPSP_PLAYERDEAD;

typedef DPSP_PLAYERDEAD FAR* LPDPSP_PLAYERDEAD;
#endif
//@@END_MSINTERNAL

/*
 * Prototypes for callbacks returned by SPInit.
 */
typedef HRESULT   (WINAPI *LPDPSP_CREATEPLAYER)(LPDPSP_CREATEPLAYERDATA);
typedef HRESULT   (WINAPI *LPDPSP_DELETEPLAYER)(LPDPSP_DELETEPLAYERDATA);
typedef HRESULT   (WINAPI *LPDPSP_SEND)(LPDPSP_SENDDATA);
typedef HRESULT   (WINAPI *LPDPSP_ENUMSESSIONS)(LPDPSP_ENUMSESSIONSDATA);
typedef HRESULT   (WINAPI *LPDPSP_REPLY)(LPDPSP_REPLYDATA);
typedef HRESULT   (WINAPI *LPDPSP_SHUTDOWN)(void);
typedef HRESULT   (WINAPI *LPDPSP_CREATEGROUP)(LPDPSP_CREATEGROUPDATA);
typedef HRESULT   (WINAPI *LPDPSP_DELETEGROUP)(LPDPSP_DELETEGROUPDATA);
typedef HRESULT   (WINAPI *LPDPSP_ADDPLAYERTOGROUP)(LPDPSP_ADDPLAYERTOGROUPDATA);
typedef HRESULT   (WINAPI *LPDPSP_REMOVEPLAYERFROMGROUP)(LPDPSP_REMOVEPLAYERFROMGROUPDATA);
typedef HRESULT   (WINAPI *LPDPSP_GETCAPS)(LPDPSP_GETCAPSDATA);
typedef HRESULT   (WINAPI *LPDPSP_GETADDRESS)(LPDPSP_GETADDRESSDATA);
typedef HRESULT   (WINAPI *LPDPSP_GETADDRESSCHOICES)(LPDPSP_GETADDRESSCHOICESDATA);
typedef HRESULT   (WINAPI *LPDPSP_OPEN)(LPDPSP_OPENDATA);
typedef HRESULT   (WINAPI *LPDPSP_CLOSE)(void);
typedef HRESULT   (WINAPI *LPDPSP_SENDTOGROUP)(LPDPSP_SENDTOGROUPDATA);
typedef HRESULT   (WINAPI *LPDPSP_SHUTDOWNEX)(LPDPSP_SHUTDOWNDATA);
typedef HRESULT   (WINAPI *LPDPSP_CLOSEEX)(LPDPSP_CLOSEDATA);
typedef HRESULT   (WINAPI *LPDPSP_SENDEX)(LPDPSP_SENDEXDATA);
typedef HRESULT   (WINAPI *LPDPSP_SENDTOGROUPEX)(LPDPSP_SENDTOGROUPEXDATA);
typedef HRESULT   (WINAPI *LPDPSP_CANCEL)(LPDPSP_CANCELDATA);
typedef HRESULT   (WINAPI *LPDPSP_GETMESSAGEQUEUE)(LPDPSP_GETMESSAGEQUEUEDATA);

/*
 * DPSP_SPCALLBACKS
 *
 * Table of callback pointers passed to SPInit. The service provider should fill
 * in the functions it implements. If the service provider does not implement
 * a callback, it should not set the table value for the unimplemented callback.
 */
typedef struct _DPSP_SPCALLBACKS
{
    DWORD                       dwSize;             //  size of table 
    DWORD                       dwVersion;			// 	the DPSP_MAJORVERSION of this DPLAY object
													// 	for DX3, this was 0. 
    LPDPSP_ENUMSESSIONS         EnumSessions;       //  required 
    LPDPSP_REPLY                Reply;              //  required 
    LPDPSP_SEND                 Send;               //  required 
    LPDPSP_ADDPLAYERTOGROUP     AddPlayerToGroup;   //  optional 
    LPDPSP_CLOSE                Close;              //  optional - for DX3 compat only
    LPDPSP_CREATEGROUP          CreateGroup;        //  optional 
    LPDPSP_CREATEPLAYER         CreatePlayer;       //  optional 
    LPDPSP_DELETEGROUP          DeleteGroup;        //  optional 
    LPDPSP_DELETEPLAYER         DeletePlayer;       //  optional 
    LPDPSP_GETADDRESS           GetAddress;         //  optional 
    LPDPSP_GETCAPS              GetCaps;            //  required 
    LPDPSP_OPEN                 Open;               //  optional 
    LPDPSP_REMOVEPLAYERFROMGROUP RemovePlayerFromGroup; //  optional 
    LPDPSP_SENDTOGROUP          SendToGroup;        //  optional 
    LPDPSP_SHUTDOWN             Shutdown;           //  optional - for DX3 compat only
    /*** fields added for DX 5 ***/
    LPDPSP_CLOSEEX	            CloseEx;			//  optional 
    LPDPSP_SHUTDOWNEX			ShutdownEx;			//  optional 
    LPDPSP_GETADDRESSCHOICES	GetAddressChoices;	//  optional 
	/*** fields added for DX 6 ***/
    /*** for async ***/
    LPDPSP_SENDEX               SendEx;             //  optional - required for async
    LPDPSP_SENDTOGROUPEX        SendToGroupEx;      //  optional - optional for async
    LPDPSP_CANCEL               Cancel;             //  optional - optional for async, highly recommended
    LPDPSP_GETMESSAGEQUEUE      GetMessageQueue;    //  optional - optional for async, highly recommended
} DPSP_SPCALLBACKS;             

typedef DPSP_SPCALLBACKS FAR *LPDPSP_SPCALLBACKS;

/*
 * SPINITDATA
 *
 * Data structure passed to the service provider at SPInit.
 */
typedef struct _SPINITDATA 
{
    LPDPSP_SPCALLBACKS  lpCB;               //  service provider fills in entry points 
    IDirectPlaySP      	* lpISP;            //  used to call back into DirectPlay 
                                            // (e.g. when message is received) 
    LPWSTR              lpszName;           //  service provider name from registry 
    LPGUID              lpGuid;             //  service provider GUID from registry 
    DWORD               dwReserved1;        //  service provider-specific data from registry 
    DWORD               dwReserved2;        //  service provider-specific data from registry 
    DWORD               dwSPHeaderSize;     //  dwSPHeaderSize is the size of the 
                                            //  data the sp wants stored with each message.
                                            //  DirectPlay will allocate dwSPHeaderSize 
                                            //  bytes at the beginning of each message.
                                            //  The service provider can then do what 
                                            //  they want with these. 
    LPDPADDRESS         lpAddress;          //  address to use for connection
    DWORD               dwAddressSize;      //  size of address data
    DWORD               dwSPVersion;        //  version number 16 | 16 , major | minor version 
} SPINITDATA;

typedef SPINITDATA FAR* LPSPINITDATA;

/*
 * SPInit
 *
 * DirectPlay calls this function to initialize the service provider.
 * All service providers must export this entry point from their DLL.
 */
typedef HRESULT (WINAPI *LPDPSP_SPINIT)(LPSPINITDATA);

HRESULT WINAPI SPInit(LPSPINITDATA);

/*
 * gdwDPlaySPRefCount
 *
 * To ensure that the DPLAYX.DLL will not be unloaded before the service
 * provider, the server provider should statically link to DPLAYX.LIB and
 * increment this global during the SPINIT call and decrement this global
 * during Shutdown.
 */
extern __declspec(dllimport) DWORD gdwDPlaySPRefCount;


/*@@BEGIN_MSINTERNAL */
/*
 *	All of the following entries are part of the voice support that was
 *	removed from dplay before DX6.  It is currently still part of the
 *	code base and is just #ifdef'd out.
 */
#ifdef DPLAY_VOICE_SUPPORT
	/*
	 *	Player was created on a system that has voice capability
	 *
	 * INTERNAL USE ONLY
	 * THIS ENTRY SHOULD BE SURROUNDED BY MSINTERNALS!!!!!
	 */
	#define DPLAYI_PLAYER_HASVOICE			0x00001000

	/*
	 * DPSP_CLOSEVOICEDATA - used with CloseVoice
	 */
	typedef struct _DPSP_CLOSEVOICEDATA
	{
		IDirectPlaySP * lpISP;
		DWORD			dwFlags;
	} DPSP_CLOSEVOICEDATA;
	typedef DPSP_CLOSEVOICEDATA FAR* LPDPSP_CLOSEVOICEDATA;

	/*
	 * DPSP_OPENVOICEDATA - used with OpenVoice
	 */
	typedef struct _DPSP_OPENVOICEDATA
	{
		IDirectPlaySP * lpISP;
		DWORD			dwFlags;
		DPID			idTo;
		DPID			idFrom;
		BOOL			bToPlayer; // TRUE if idTo is a Player
	} DPSP_OPENVOICEDATA;
	typedef DPSP_OPENVOICEDATA FAR* LPDPSP_OPENVOICEDATA;

	typedef HRESULT   (WINAPI *LPDPSP_CLOSEVOICE)(LPDPSP_CLOSEVOICEDATA);
	typedef HRESULT   (WINAPI *LPDPSP_OPENVOICE)(LPDPSP_OPENVOICEDATA);

	// From interface declaration
	LPDPSP_CLOSEVOICE           CloseVoice;         //  optional 
	LPDPSP_OPENVOICE            OpenVoice;          //  optional 

#endif // DPLAY_VOICE_SUPPORT
/*@@END_MSINTERNAL */

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplayip6\dplaysvr.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplaysvr.h
 *  Content: 	dplay winsock shared .exe - allows multiple apps to share 
 *				a single winsock port
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	2/10/97		andyco	created it from ddhelp 
 *	1/29/98		sohailm	added macros for critical section
 *
 ***************************************************************************/
#ifndef __DPLAYSVR_INCLUDED__
#define __DPLAYSVR_INCLUDED__

// need this for hresult
#include "ole2.h"

// crit section
extern CRITICAL_SECTION gcsCritSection;	// defined in dphelp.c
#define INIT_DPLAYSVR_CSECT() InitializeCriticalSection(&gcsCritSection);
#define FINI_DPLAYSVR_CSECT() DeleteCriticalSection(&gcsCritSection);

#ifdef DEBUG
extern int gnCSCount; // count of dplaysvr lock
#define ENTER_DPLAYSVR() EnterCriticalSection(&gcsCritSection),gnCSCount++;
#define LEAVE_DPLAYSVR() gnCSCount--;ASSERT(gnCSCount>=0);LeaveCriticalSection(&gcsCritSection);
#else 
#define ENTER_DPLAYSVR() EnterCriticalSection(&gcsCritSection);
#define LEAVE_DPLAYSVR() LeaveCriticalSection(&gcsCritSection);
#endif

/*
 * named objects
 */
#define DPHELP_EVENT_NAME			"__DPHelpEvent__"
#define DPHELP_ACK_EVENT_NAME		"__DPHelpAckEvent__"
#define DPHELP_STARTUP_EVENT_NAME	"__DPHelpStartupEvent__"
#define DPHELP_SHARED_NAME			"__DPHelpShared__"
#define DPHELP_MUTEX_NAME			"__DPHelpMutex__"

/*
 * requests 
 */
#define DPHELPREQ_SUICIDE			1
#define DPHELPREQ_DPLAYADDSERVER	2
#define DPHELPREQ_DPLAYDELETESERVER	3
#define DPHELPREQ_RETURNHELPERPID 	4

/*
 * communication data
 */
typedef struct DPHELPDATA
{
    int			req;
    DWORD		pid;
	USHORT		port;
    HRESULT		hr;
} DPHELPDATA, *LPDPHELPDATA;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplayip6\dpsp.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpsp.c
 *  Content:    sample direct play service provider, based on winsock
 *  History:
 *  Date        By        Reason
 *  ====        ==        ======
 *  1/96        andyco    created it
 *  2/8/96        andyco    steam + dgram model, including name server support
 *    2/15/96        andyco    added reliable receive.  added send (udp + stream). 
 *                        added macros for dwReserved to clean up, (and provide
 *                        means for reducing # dwords reserved per player)
 *    3/13/96        andyco    relaible send + receive for all players. MW2
 *    3/16/96        andyco    shutdown method - code cleanup - shared stream receive, etc.
 *    3/19/96        andyco    new message macros (IS_VALID, GET_MESSAGE_SIZE). see dpmess.h
 *    4/3/96        andyco    moved start up / shut down winsock code here from dllmain 
 *    4/10/96        andyco    added spplayerdata
 *    4/12/96        andyco    got rid of dpmess.h! use DPlay_ instead of message macros
 *    4/18/96        andyco    added multihomed support, started ipx
 *    4/23/96        andyco    ipx support.  ipx only - no spx.  spx doesn't support
 *                        graceful disconnect (winsock bug?) so we don't know
 *                        when it's safe to closesocket.
 *    4/25/96        andyco    messages now have blobs (sockaddr's) instead of dwReserveds  
 *    5/31/96        andyco    all non-system players share a socket (gsStream and 
 *                        gsDGramSocket).
 *    6/9/96        andyco    ouch.  dplayi_player + group are gone!
 *    6/19/96        andyco    sp sets own header!
 *    6/22/96        andyco    no more stashing goodies in sessiondesc.  tossed cookies.
 *    6/23/96        kipo    updated for latest service provider interfaces.
 *    6/25/96        kipo    added WINAPI prototypes and updated for DPADDRESS;
 *                        added version.
 *    7/11/96        andyco    reset gsEnumSocket to INVALID_SOCKET if spInit fails
 *                        #2348.  added sp_getaddress.
 *    7/18/96        andyco    added dphelp for server socket
 *    7/16/96        kipo    changed address types to be GUIDs instead of 4CC
 *  8/1/96        andyco    fixed up caps.  dplay allocs sp data, not us.  
 *  8/9/96        andyco    throw DPCAPS_GUARANTEEDOPTIMIZED for AF_INET
 *    8/12/96        andyco    changed failure check on inithelper
 *    8/15/96        andyco    added sp local data + clean up on thread terminate
 *    8/30/96        andyco    clean it up b4 you shut it down! added globaldata.
 *    9/1/96        andyco    right said thread!  if you spin it, they won't block.
 *                        bagosockets.
 *     9/4/96        andyco    kill threads at shutdown only. add all threads to
 *                        threadlist. don't add thread to list if it's already
 *                        done.
 *    11/11/96    andyco    check for NULL header or data when creating
 *                        non-local players (support game server). Memset our 
 *                        sockaddr to 0 before calling getserveraddress.
 *    12/18/96    andyco    de-threading - use a fixed # of prealloced threads.
 *                        cruised the enum socket / thread - use the system
 *                        socket / thread instead
 *    1/15/97        andyco    return actual hr on open failure (bug 5197) instead of
 *                        just DP_OK.  also, allow system messages to go in the 
 *                        socket cache. 
 *    1/17/97        andyco    workaround for nt bug 68093 - recvfrom returns buffer size
 *                        instead of WSAEMSGSIZE
 *    1/23/97        kipo    return an error code from StartDPHelp() so Open() returns
 *                        an error if you cannot host a session.
 *    1/24/97        andyco    handle incoming message when receive thread isn't running yet
 *    2/7/97        andyco  store globals w/ IDirectPlaySP, so we can have > 1 SP per DLL.
 *    2/10/97        andyco    remove sockets from receive list if we get an error when receiving 
 *                        on them.  this keeps us from going into a spin on select(...).
 *    2/15/97        andyco    wait on accept thread b4 receive thread.  pass port to 
 *                        helperdeletedplayserver.
 *    3/04/97        kipo    external definition of gdwDPlaySPRefCount now in dplaysp.h
 *    3/18/97        andyco    create socket at spinit to verify support for requested
 *                        address family
 *    3/18/97        kipo    GetServerAddress() now returns an error so that we can
 *                        return DPERR_USERCANCEL from the EnumSessions dialog
 *    3/25/97        andyco    tweaked shutdown code to send message to streamreceivethreadproc
 *                        to exit, rather than nuking the control socket which
 *                        would sometimes hang.
 *    4/11/97        andyco    make sure it's really the control socket @ init
 *    5/12/97        kipo    return DPERR_UNAVAILABLE if SP could not be opened (i.e. if
 *                        IPX not installed) to be compatible with the modem SP; added
 *                        support for Unicode IP address strings.
 *    5/18/97        andyco    close threads + sockets at close.  this way, we don't hold
 *                        sockets across sessions.
 *    6/11/97        andyco    changed reply thread proc to flush q when waking up
 *    6/18/97        andyco    check for bogus reply headers, just to be safe
 *    6/19/97        myronth    Fixed handle leak (#10059)
 *    6/20/97        andyco    check for bogus IPX install by looking for sa_nodenum
 *                        of all 0's at SPInit.  raid 9625.
 *    7/11/97        andyco    added async reply thread and ws2 support
 *    7/30/97        andyco    call wsastartup w/ version 1.1 if app has already 
 *                        called it.
 *   8/4/97        andyco    added support for DPSEND_ASYNC (no return status) so 
 *                        we can make addforward async
 *    8/25/97        sohailm updated stream receive logic to avoid congestion (bug #10952)
 *    9/05/97        kipo    Fixed memphis bug #43655 to deal with getsockopt failing
 *    12/5/97        andyco    voice support
 *    01/5/98        sohailm    fd set now grows dynamically - allows for any number of clients (#15244).
 *    01/14/98    sohailm    don't look for Winsock2.0 on non-nt platforms for IPX (#15253)
 *    1/20/98        myronth    #ifdef'd out voice support
 *    1/21/98    a-PeterZ    Fix #15242 SP_GetAddress supports local players
 *    1/27/98        sohailm    added Firewall support.
 *    1/30/98        sohailm    bug fix for 17731
 *    2/09/98    a-PeterZ    Fix #17737 ReceiveList Memory Leak
 *  2/13/98     aarono  added async support
 *  2/13/98     aarono  made IPX return proper header size
 *    2/16/98    a-PeterZ    Fix #15342 Detect no local connection in SP_EnumSessions and SP_Open
 *    2/18/98    a-peterz Comment byte order mess-up with SERVER_xxx_PORT constants
 *  2/24/98     aarono  Bug#18646 fix startup/close race crashing stress.
 *  3/3/98      aarono  Bug#19188 remove accept thread 
 *  3/30/98     aarono  changed KillSocket on StreamAccept socket to closesocket
 *  4/6/98      aarono  mapped WSAECONNRESET to DPERR_CONNECTIONLOST
 *  4/23/98     aarono  workaround Winsock shutdown bug.
 *                       The workaround for DPLAY would be to close all accepted sockets first 
 *                          and only then listening socket. (VadimE)
 *  6/19/98     aarono  map WSAENETRESET and WSAENOTCONN to DPERR_CONNECTIONLOST too.
 *                      required since we now turn on keepalives on reliable
 *                      connections.
 * 12/15/98     aarono  Fix Async Enum.
 *  7/9/99      aarono  Cleaning up GetLastError misuse, must call right away,
 *                      before calling anything else, including DPF.
 *
 ***************************************************************************/

/***************************************************************************
*  summary -                                                                
*     + SPInit is the entry point called by dplay. SP fills in callbacks,        
*         does any other init stuff there.                                    
*     + All dplay callbacks start with SP_                                    
*                                                                           
*****************************************************************************/

// todo - need a meaningful mapping from socket errors to hresults

// todo - figure out when to pop a message box to the user for tragic errors

#define INITGUID

#ifdef BIGMESSAGEDEFENSE

#include <dplobby.h>

// a-josbor: this terrible, terrible hack is brought to you by the elmer build system
#ifndef MAXMSGSIZEGUIDDEFINED

// {F5D09980-F0C4-11d1-8326-006097B01411}
DEFINE_GUID(DPAID_MaxMessageSize, 
0xf5d09980, 0xf0c4, 0x11d1, 0x83, 0x26, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

#endif

#endif /* BIGMESSAGEDEFENSE */

#include "dpsp.h"
#include "fpm.h"
#include <initguid.h>
#include "helpcli.h"

/*            */
/*  globals    */
/*            */
WSADATA gwsaData; // from wsastartup
HINSTANCE hWS2; // dynaload the ws2_32.dll, so if it's not installed (e.g. win 95 gold)
                // we still load
HINSTANCE hWSHIP6 = NULL; // dynaload the wship6.dll only if on Win2k

// stuff for ddhelp
DWORD dwHelperPid; // for ddhelp
HANDLE hModule;  // for ddhelp

CRITICAL_SECTION gcsDPSPCritSection;
#ifdef DEBUG
int gCSCount;
#endif

#ifdef DPLAY_VOICE_SUPPORT
BOOL gbVoiceInit = FALSE; // set to TRUE if we have nm voice init'ed
BOOL gbVoiceOpen = FALSE; // set to TRUE if we have a call open
#endif // DPLAY_VOICE_SUPPORT

const IN6_ADDR in6addr_multicast = IN6ADDR_MULTICAST_INIT;
const SOCKADDR_IN6 sockaddr_any = {AF_INET6,0};


#undef DPF_MODNAME
#define DPF_MODNAME    "DEBUGPRINTSOCKADDR"

#ifdef DEBUG
void DebugPrintAddr(UINT nLevel,LPSTR pStr,SOCKADDR * psockaddr)
{
    char buff[INET6_ADDRSTRLEN];
    int ret;
    LPSOCKADDR_IN6 pin6 = (LPSOCKADDR_IN6)psockaddr;
    ULONG ulLength = INET6_ADDRSTRLEN;

    ret = WSAAddressToString(psockaddr, sizeof(SOCKADDR_IN6), NULL,
            buff, &ulLength); 

    if (!ret)
        DPF(nLevel,"%s af = AF_INET6 : address =  %s\n",pStr,buff);

} // DebugPrintAddr

void DebugPrintSocket(UINT level,LPSTR pStr,SOCKET * pSock) 
{
    SOCKADDR_IN6 sockaddr;
    int addrlen=sizeof(sockaddr);

    getsockname(*pSock,(LPSOCKADDR)&sockaddr,&addrlen);
    DEBUGPRINTADDR(level,pStr,&sockaddr);
}
#endif // debug

#undef DPF_MODNAME
#define DPF_MODNAME    "DatagramListenThread"

void SetMessageHeader(LPDWORD pdwMsg,DWORD dwSize, DWORD dwToken)
{

    if (dwSize > SPMAXMESSAGELEN)
    {
        ASSERT(FALSE);
    }

    *pdwMsg = dwSize | dwToken;    

    return ;

}// SetMessageHeader

#undef DPF_MODNAME
#define DPF_MODNAME    "DatagramReceiveThread"

// our initial guess at the size of the dgram receive buffer.
// any messages bigger than this will be truncated BUT when we 
// receive a too big message, we double the buffer size (winsock
// won't tell us exactly how big the message was, so we guess).
// a-josbor: I thought 1024 was really stingy, so I bumped this up to 16K
#define BUF_SIZE 0x4000
DWORD WINAPI DgramListenThreadProc(LPVOID pvCast)
{
    UINT err;
    LPBYTE pBuffer;
    SOCKADDR_IN6 sockaddr; // the from address
    INT addrlen=sizeof(sockaddr);
    DWORD dwBufSize = BUF_SIZE;
    IDirectPlaySP * pISP = (IDirectPlaySP *)pvCast;
    LPGLOBALDATA pgd;
    DWORD dwDataSize = sizeof(GLOBALDATA);
    SOCKET sSocket;
    HRESULT hr;
    
    DPF(2,"starting udp listen thread ");

    // get the global data
    hr =pISP->lpVtbl->GetSPData(pISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
    if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
    {
        DPF_ERR("couldn't get SP data from DirectPlay - failing");
        ExitThread(0);
        return 0;
    }
    
    // use the dgram socket
    sSocket = pgd->sSystemDGramSocket;
    
    ENTER_DPSP();
    
    pBuffer = MemAlloc(BUF_SIZE);
    
    LEAVE_DPSP();
    
    if (!pBuffer)
    {
        DPF_ERR("could not alloc dgram receive buffer");
        ExitThread(0);
        return 0;
    }
    
    while (1)
    {
        err = recvfrom(sSocket,pBuffer,dwBufSize,0,(LPSOCKADDR)&sockaddr,&addrlen);
        if ( (SOCKET_ERROR == err)  || (dwBufSize == err))
        {
        
            if (dwBufSize == err)
            {
                // this works around NT bug 68093
                err = WSAEMSGSIZE;
            }
            else 
            {
                err = WSAGetLastError();                
            }
            
            DPF(2,"\n udp recv error - err = %d socket = %d",err,(DWORD)sSocket);
            
            if (WSAEMSGSIZE == err)
            {
                // buffer too small!
                dwBufSize *= 2;
                
                ENTER_DPSP();
                
                pBuffer = MemReAlloc(pBuffer,dwBufSize);
                
                LEAVE_DPSP();
                
                if (!pBuffer)
                {
                    DPF_ERR("could not realloc dgram receive buffer");
                    ExitThread(0);
                    return 0;
                }
                // we don't pass dplay this message, since it was truncated...
            }
            else 
            {
                // bail on other errors
                goto ERROR_EXIT;
            }
        }
        else if ( (err >= sizeof(DWORD)) &&  (VALID_DPWS_MESSAGE(pBuffer)) )
        {
        
            DEBUGPRINTADDR(9,"received udp message from : ",&sockaddr);
            if (VALID_SP_MESSAGE(pBuffer))
            {
                // it came from another dplay (not from our dplay helper)
                // if it came from our helper, we've already poked the ip addr
                // into the message body
                IP6_SetAddr((LPVOID)pBuffer,(SOCKADDR_IN6 *)&sockaddr);
            }

            // pass message to dplays handler
            pISP->lpVtbl->HandleMessage(pISP,pBuffer + sizeof(MESSAGEHEADER),
                err -  sizeof(MESSAGEHEADER), pBuffer);
        }
        else 
        {
            DEBUGPRINTADDR(9,"received udp message from : ",&sockaddr);        
            // it must be just a raw send...
            pISP->lpVtbl->HandleMessage(pISP,pBuffer,err,NULL);
        }
    }

ERROR_EXIT:
    DPF(2,"UDP Listen thread exiting");
    
    ENTER_DPSP();
    
    if (pBuffer) MemFree(pBuffer);
    
    LEAVE_DPSP();

    // all done
    ExitThread(0);
    return 0;

} // UDPListenThreadProc

#undef DPF_MODNAME
#define DPF_MODNAME    "StreamListenThread"

// make sure the buffer is big enough to fit the message size
HRESULT MakeBufferSpace(LPBYTE * ppBuffer,LPDWORD pdwBufferSize,DWORD dwMessageSize)
{
    HRESULT hr = DP_OK;

    ASSERT(ppBuffer);
    ASSERT(pdwBufferSize);
            
    ENTER_DPSP();
    
    if (!*ppBuffer)
    {
        DPF(9, "Allocating space for message of size %d", dwMessageSize);

        // need to alloc receive buffer?
        *ppBuffer = MemAlloc(dwMessageSize);
        if (!*ppBuffer)
        {
            DPF_ERR("could not alloc stream receive buffer - out of memory");        
            hr = E_OUTOFMEMORY;
            goto CLEANUP_EXIT;
        }
        *pdwBufferSize = dwMessageSize;
    }
    // make sure receive buffer can hold data
    else if (dwMessageSize > *pdwBufferSize) 
    {
        LPVOID pvTemp;

        DPF(9, "ReAllocating space for message of size %d", dwMessageSize);

        // realloc buffer to hold data
        pvTemp = MemReAlloc(*ppBuffer,dwMessageSize);
        if (!pvTemp)
        {
            DPF_ERR("could not realloc stream receive buffer - out of memory");
            hr = E_OUTOFMEMORY;
            goto CLEANUP_EXIT;
        }
        *ppBuffer = pvTemp;
        *pdwBufferSize = dwMessageSize;
    }

    // fall through
    
CLEANUP_EXIT: 
    
    LEAVE_DPSP();
    return hr;    
    
}  // MakeBufferSpace

// is this sockaddr local to this machine?
BOOL IsLocalIP(SOCKADDR_IN6 sockaddr)
{
    SOCKADDR_IN6 temp;
    SOCKET s;
    int ret;

    s = socket(AF_INET6, SOCK_DGRAM, 0);
    if (s == INVALID_SOCKET) 
    {
        return FALSE;
    }
    
    temp = sockaddr;
    temp.sin6_port = 0;
    ret = bind(s, (LPSOCKADDR)&temp, sizeof(temp)); 
    closesocket(s);
    return (ret == 0);
}  // IsLocalIP

// adds socket to our send list
HRESULT AddSocketToBag(LPGLOBALDATA pgd, SOCKET socket, DPID dpid, SOCKADDR_IN6 *psockaddr, DWORD dwFlags)
{
    UINT i=0;
    BOOL bFound = FALSE;
    BOOL bTrue = TRUE;
    HRESULT hr=DP_OK;
        
    ASSERT(psockaddr);

    ENTER_DPSP();

    // see if we can find an empty slot
    i=0;
    while (( i < pgd->nSocketsInBag) && !bFound)
    {
        if (INVALID_SOCKET == pgd->BagOSockets[i].sSocket) bFound = TRUE;
        else i++;
    }
    if (!bFound)    
    {
        // no space. bummer
        DPF(5,"no space in bag o' sockets. slowness ensues");
        hr = E_FAIL;
        goto CLEANUP_EXIT;
    }

    DPF(5,"adding new socket to bag for id = %d, slot = %d",dpid,i);
    DEBUGPRINTSOCK(7, "Adding socket to bag - ",&socket);
    
    pgd->BagOSockets[i].dwPlayerID = dpid;    
    pgd->BagOSockets[i].sSocket = socket;
    pgd->BagOSockets[i].sockaddr = *psockaddr;
    pgd->BagOSockets[i].dwFlags = dwFlags;

    // fall through

CLEANUP_EXIT:
    LEAVE_DPSP();
    return hr;
}

void FreeConnection(LPCONNECTION pConnection)
{
    if (pConnection->pBuffer && (pConnection->pBuffer != pConnection->pDefaultBuffer)) 
    {
        MemFree(pConnection->pBuffer);
        pConnection->pBuffer = NULL;
    }
    if (pConnection->pDefaultBuffer) 
    {
        MemFree(pConnection->pDefaultBuffer);
        pConnection->pDefaultBuffer = NULL;
    }

    // initialize connection 
    pConnection->socket = INVALID_SOCKET; // this tells us if connection is valid
    pConnection->dwCurMessageSize = 0;
    pConnection->dwTotalMessageSize = 0;
    pConnection->dwFlags = 0;
}


HRESULT AddSocketToReceiveList(LPGLOBALDATA pgd,SOCKET sSocket,DWORD dwFlags)
{
    UINT i = 0;
    UINT err, iNewSlot;
    BOOL bFoundSlot = FALSE;
    HRESULT hr = DP_OK;
    INT addrlen=sizeof(SOCKADDR_IN6);
    LPCONNECTION pNewConnection=NULL;
    DWORD dwCurrentSize,dwNewSize;
    
    ENTER_DPSP();
    
    // look for an empty slot 
    while ( (i < pgd->ReceiveList.nConnections) && !bFoundSlot)
    {
        if (INVALID_SOCKET == pgd->ReceiveList.pConnection[i].socket)
        {
            bFoundSlot = TRUE;            
            iNewSlot = i;
        }
        else 
        {
            i++;
        }
    }
    
    if (!bFoundSlot)
    {        
        // allocate space for list of connections
        dwCurrentSize = pgd->ReceiveList.nConnections * sizeof(CONNECTION);
        dwNewSize = dwCurrentSize +  INITIAL_RECEIVELIST_SIZE * sizeof(CONNECTION);        
        hr =  MakeBufferSpace((LPBYTE *)&(pgd->ReceiveList.pConnection),&dwCurrentSize,dwNewSize);
        if (FAILED(hr))
        {
            ASSERT(FALSE);
            goto ERROR_EXIT;
        }        
        ASSERT(dwCurrentSize == dwNewSize);
        
        // set all the new entries to INVALID
        for (i = pgd->ReceiveList.nConnections + 1; 
            i < pgd->ReceiveList.nConnections + INITIAL_RECEIVELIST_SIZE; i++ )
        {
            pgd->ReceiveList.pConnection[i].socket = INVALID_SOCKET;
        }
        
        // store the new socket in the 1st new spot
        iNewSlot = pgd->ReceiveList.nConnections;

        // allocate space for an fd set (fd_count + fd_array)
        if (pgd->ReceiveList.nConnections)
        {
            dwCurrentSize = sizeof(u_int) + pgd->ReceiveList.nConnections * sizeof(SOCKET);
            dwNewSize =    dwCurrentSize + INITIAL_RECEIVELIST_SIZE * sizeof(SOCKET);
        }
        else
        {
            dwCurrentSize = 0;
            dwNewSize = sizeof(u_int) + INITIAL_RECEIVELIST_SIZE * sizeof(SOCKET);
        }
        hr =  MakeBufferSpace((LPBYTE *)&(pgd->readfds.pfdbigset),&dwCurrentSize,dwNewSize);
        if (FAILED(hr))
        {
            ASSERT(FALSE);
            goto ERROR_EXIT;
        }        
        ASSERT(dwCurrentSize == dwNewSize);
        
        // update the # of connections
        pgd->ReceiveList.nConnections += INITIAL_RECEIVELIST_SIZE; 
        // update the fd_array buffer size
        pgd->readfds.dwArraySize = pgd->ReceiveList.nConnections;
        
    } // !bFoundSlot

    // we have a space holder for a connection when we get here
    
    // Initialize new connection 
    pNewConnection = &(pgd->ReceiveList.pConnection[iNewSlot]);
    pNewConnection->socket = sSocket;
    pNewConnection->dwFlags = dwFlags;

    if(dwFlags != SP_STREAM_ACCEPT){

        // allocate a default receive buffer if don't have one already
        if (!pNewConnection->pDefaultBuffer)
        {
            pNewConnection->pDefaultBuffer = MemAlloc(DEFAULT_RECEIVE_BUFFERSIZE);
            if (!pNewConnection->pDefaultBuffer)
            {
                hr = DPERR_OUTOFMEMORY;
                DPF_ERR("could not alloc default receive buffer - out of memory");        
                goto ERROR_EXIT;
            }
        }
        
        // receive buffer initially points to our default buffer
        pNewConnection->pBuffer = pNewConnection->pDefaultBuffer;
        
        // remember the address we are connected to
        err = getpeername(pNewConnection->socket, (LPSOCKADDR)&(pNewConnection->sockAddr), &addrlen);
        if (SOCKET_ERROR == err) 
        {
            err = WSAGetLastError();
            DPF(1,"could not getpeername err = %d\n",err);
        }

        DEBUGPRINTADDR(9, "Socket is connected to address - ",&(pNewConnection->sockAddr));

    }
    
    LEAVE_DPSP();

    DPF(5, "Added new socket at index %d", iNewSlot);


    // success
    return DP_OK;

    // not a fall through
    
ERROR_EXIT:

    if (pNewConnection)
    {
        K