SE)
        goto cleanup;

    m_JetErr = pbDomainSid.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_DOMAINSETUPID
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = szInstallId.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_LSSETUPID
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = szDomainName.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_DOMAINNAME
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = szTlsServerName.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_LSERVERNAME
                    );                    

    if(IsSuccess() == FALSE)
        goto cleanup;

    //----------------------------------------------------

    m_JetErr = szKeyPackId.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_LPID
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;
                        
    m_JetErr = ucAgreementType.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_AGREEMENTTYPE
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = szCompanyName.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_COMPANYNAME
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = szProductId.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_PRODUCTID
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = wMajorVersion.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_MAJORVERSION
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = wMinorVersion.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_MINORVERSION
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;
        
    m_JetErr = dwPlatformType.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_PLATFORMTYPE
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = ucLicenseType.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_LICENSETYPE
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = ucChannelOfPurchase.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_COP
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = szBeginSerialNumber.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_BSERIALNUMBER
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwTotalLicenseInKeyPack.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_TOTALLICENSES
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwProductFlags.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_PRODUCTFLAGS
                    );


cleanup:
    return IsSuccess();
}

//------------------------------------------------------------

CLASS_PRIVATE BOOL
LicPackTable::ProcessSingleColumn(
    IN BOOL bFetch,
    IN TLSColumnBase& column,
    IN DWORD offset,
    IN PVOID pbData,
    IN DWORD cbData,
    IN PDWORD pcbDataReturn,
    IN LPCTSTR szColumnName
    )
/*

Abstract:

    Fetch/Insert/Update a particular column.

Parameter:

    bFetch - TRUE if fetch, FALSE if update/insert.
    column - Intended column for operation, reference pointer to TLSColumn
    szColumnName - name of the column, for debugging print purpose only

Returns:

    TRUE if successful, FALSE otherwise.
*/
{
    if(bFetch) 
    {
        m_JetErr = column.FetchColumnValue(
                                    pbData, 
                                    cbData, 
                                    offset, 
                                    pcbDataReturn
                                );
    }
    else
    {
        m_JetErr = column.InsertColumnValue(
                                    pbData, 
                                    cbData, 
                                    offset
                                );
    }

    REPORTPROCESSFAILED(
            bFetch,
            GetTableName(),
            szColumnName,
            m_JetErr
        );
    return IsSuccess();
}

//--------------------------------------------------------------

CLASS_PRIVATE BOOL
LicPackTable::ProcessRecord(
    LICENSEPACK* kp,
    BOOL bFetch,
    DWORD dwParam,
    BOOL bUpdate
    )
/*++

    See comment on TLSTable<> template class

++*/
{
    DWORD dwSize;

    JB_ASSERT(kp != NULL);

    if(kp == NULL)
    {
        SetLastJetError(JET_errInvalidParameter);
        return FALSE;
    }

    if(bFetch == FALSE)
    {
        BeginUpdate(bUpdate);

        //
        // any update will require update on lastmodifytime column
        if(!(dwParam & LICENSEDPACK_PROCESS_MODIFYTIME))
        {
            #if DBG
            //  
            // This is for self-checking only, TLSColumnFileTime 
            // will automatically update the time.
            //
            JB_ASSERT(FALSE);
            #endif

            dwParam |= LICENSEDPACK_PROCESS_MODIFYTIME;
        }

    }
    else
    {
        SetLastJetError(JET_errSuccess);
    }

    if(IsSuccess() == FALSE)
    {
        JB_ASSERT(FALSE);
        goto cleanup;    
    }        


    //
    //
    if(dwParam & LICENSEDPACK_PROCESS_SZKEYPACKID)
    {
        ProcessSingleColumn( 
                    bFetch, 
                    szKeyPackId, 
                    0,
                    kp->szKeyPackId,
                    sizeof(kp->szKeyPackId),
                    &dwSize,
                    LICENSEDPACK_COLUMN_LPID 
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    //
    if(dwParam & LICENSEDPACK_PROCESS_AGREEMENTTYPE)
    {
        ProcessSingleColumn( 
                    bFetch, 
                    ucAgreementType, 
                    0,
                    &(kp->ucAgreementType),
                    sizeof(kp->ucAgreementType),
                    &dwSize,
                    LICENSEDPACK_COLUMN_AGREEMENTTYPE 
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    //
    if(dwParam & LICENSEDPACK_PROCESS_PRODUCTID)
    {
        ProcessSingleColumn(
                    bFetch, 
                    szProductId, 
                    0,
                    kp->szProductId,
                    sizeof(kp->szProductId),
                    &dwSize,
                    LICENSEDPACK_COLUMN_PRODUCTID
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    //
    if(dwParam & LICENSEDPACK_PROCESS_MAJORVERSION)
    {
        ProcessSingleColumn( 
                    bFetch,
                    wMajorVersion,
                    0,
                    &(kp->wMajorVersion),
                    sizeof(kp->wMajorVersion),
                    &dwSize,
                    LICENSEDPACK_COLUMN_MAJORVERSION
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    //
    if(dwParam & LICENSEDPACK_PROCESS_MINORVERSION)
    {
        ProcessSingleColumn(
                    bFetch,
                    wMinorVersion,
                    0,
                    &(kp->wMinorVersion),
                    sizeof(kp->wMinorVersion),
                    &dwSize,
                    LICENSEDPACK_COLUMN_MINORVERSION
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    //
    if(dwParam & LICENSEDPACK_PROCESS_PLATFORMTYPE)
    {
        ProcessSingleColumn(
                    bFetch,
                    dwPlatformType,
                    0,
                    &(kp->dwPlatformType),
                    sizeof(kp->dwPlatformType),
                    &dwSize,
                    LICENSEDPACK_COLUMN_PLATFORMTYPE
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    //
    if(dwParam & LICENSEDPACK_PROCESS_LICENSETYPE)
    {
        ProcessSingleColumn(
                    bFetch,
                    ucLicenseType,
                    0,
                    &(kp->ucLicenseType),
                    sizeof(kp->ucLicenseType),
                    &dwSize,
                    LICENSEDPACK_COLUMN_LICENSETYPE
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    //
    if(dwParam & LICENSEDPACK_PROCESS_COP)
    {
        ProcessSingleColumn(
                    bFetch,
                    ucChannelOfPurchase,
                    0,
                    &(kp->ucChannelOfPurchase),
                    sizeof(kp->ucChannelOfPurchase),
                    &dwSize,
                    LICENSEDPACK_COLUMN_COP
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    //
    if(dwParam & LICENSEDPACK_PROCESS_BSERIALNUMBER)
    {
        ProcessSingleColumn(
                    bFetch,
                    szBeginSerialNumber,
                    0,
                    kp->szBeginSerialNumber,
                    sizeof(kp->szBeginSerialNumber),
                    &dwSize,
                    LICENSEDPACK_COLUMN_BSERIALNUMBER
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    //
    if(dwParam & LICENSEDPACK_PROCESS_TOTALLICENSES)
    {
        ProcessSingleColumn(
                    bFetch,
                    dwTotalLicenseInKeyPack,
                    0,
                    &(kp->dwTotalLicenseInKeyPack),
                    sizeof(kp->dwTotalLicenseInKeyPack),
                    &dwSize,
                    LICENSEDPACK_COLUMN_TOTALLICENSES
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    //        
    if(dwParam & LICENSEDPACK_PROCESS_PRODUCTFLAGS)
    {
        ProcessSingleColumn(
                    bFetch,
                    dwProductFlags,
                    0,
                    &(kp->dwProductFlags),
                    sizeof(kp->dwProductFlags),
                    &dwSize,
                    LICENSEDPACK_COLUMN_PRODUCTFLAGS
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    //
    if(dwParam & LICENSEDPACK_PROCESS_COMPANYNAME)
    {
        ProcessSingleColumn(
                    bFetch,
                    szCompanyName,
                    0,
                    kp->szCompanyName,
                    sizeof(kp->szCompanyName),
                    &dwSize,
                    LICENSEDPACK_COLUMN_COMPANYNAME
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;


    //
    //    
    if(dwParam & LICENSEDPACK_PROCESS_DWINTERNAL)
    {
        // this is the primary index, can't be changed
        if(bUpdate == FALSE)
        {
            ProcessSingleColumn(
                    bFetch,
                    dwKeyPackId,
                    0,
                    &(kp->dwKeyPackId),
                    sizeof(kp->dwKeyPackId),
                    &dwSize,
                    LICENSEDPACK_COLUMN_KEYPACKID
                );
        }
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

    if(dwParam & LICENSEDPACK_PROCESS_MODIFYTIME)
    {
        ProcessSingleColumn(
                    bFetch,
                    ftLastModifyTime,
                    0,
                    &(kp->ftLastModifyTime),
                    sizeof(kp->ftLastModifyTime),
                    &dwSize,
                    LICENSEDPACK_COLUMN_LASTMODIFYTIME
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;


    if(dwParam & LICENSEDPACK_PROCESS_ATTRIBUTE)
    {
        ProcessSingleColumn(
                    bFetch,
                    dwAttribute,
                    0,
                    &(kp->dwAttribute),
                    sizeof(kp->dwAttribute),
                    &dwSize,
                    LICENSEDPACK_COLUMN_ATTRIBUTE
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;


    //
    //    
    if(dwParam & LICENSEDPACK_PROCESS_KEYPACKSTATUS)
    {
        ProcessSingleColumn(
                    bFetch,
                    ucKeyPackStatus,
                    0,
                    &(kp->ucKeyPackStatus),
                    sizeof(kp->ucKeyPackStatus),
                    &dwSize,
                    LICENSEDPACK_COLUMN_KEYPACKSTATUS
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    //
    if(dwParam & LICENSEDPACK_PROCESS_AVAILABLE)
    {
        ProcessSingleColumn(
                    bFetch,
                    dwNumberOfLicenses, 
                    0,
                    &(kp->dwNumberOfLicenses),
                    sizeof(kp->dwNumberOfLicenses),
                    &dwSize,
                    LICENSEDPACK_COLUMN_AVAILABLE
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    //
    if(dwParam & LICENSEDPACK_PROCESS_ACTIVATEDATE)
    {
        ProcessSingleColumn(
                    bFetch,
                    dwActivateDate,
                    0,
                    &(kp->dwActivateDate),
                    sizeof(kp->dwActivateDate),
                    &dwSize,
                    LICENSEDPACK_COLUMN_ACTIVATEDATE
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    //
    if(dwParam & LICENSEDPACK_PROCESS_EXPIREDATE)
    {
        ProcessSingleColumn(
                    bFetch,
                    dwExpirationDate,
                    0,
                    &(kp->dwExpirationDate),
                    sizeof(kp->dwExpirationDate),
                    &dwSize,
                    LICENSEDPACK_COLUMN_EXPIREDATE
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

#if 0
    // no more domain sid.    
    if(dwParam & LICENSEDPACK_PROCESS_DOMAINSID)
    {
        if(bFetch == TRUE)
        {
            DWORD size;

            m_JetErr = pbDomainSid.FetchColumnValue(
                                        NULL,
                                        0,
                                        0,
                                        &size
                                    );
            if(IsSuccess() == FALSE)
                goto cleanup;

            if(size > kp->cbDomainSid || kp->pbDomainSid == NULL)
            {
                FreeMemory(kp->pbDomainSid);

                kp->pbDomainSid = (PBYTE)AllocateMemory(kp->cbDomainSid = size);
                if(kp->pbDomainSid == NULL)
                {
                    SetLastJetError(JET_errOutOfMemory);
                    goto cleanup;
                }
            }
        
            m_JetErr = pbDomainSid.FetchColumnValue(
                                        kp->pbDomainSid,
                                        kp->cbDomainSid,
                                        0,
                                        &kp->cbDomainSid
                                    );
        }
        else
        {
            ProcessSingleColumn(
                        bFetch,
                        pbDomainSid,
                        0,
                        kp->pbDomainSid,
                        kp->cbDomainSid,
                        &dwSize,
                        LICENSEDPACK_COLUMN_DOMAINSETUPID
                    );
        }
    }

    if(IsSuccess() == FALSE)
        goto cleanup;
#endif

    if(dwParam & LICENSEDPACK_PROCESS_LSSETUPID)
    {
        ProcessSingleColumn(
                    bFetch,
                    szInstallId,
                    0,
                    kp->szInstallId,
                    sizeof(kp->szInstallId),
                    &dwSize,
                    LICENSEDPACK_COLUMN_LSSETUPID
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

    if(dwParam & LICENSEDPACK_PROCESS_DOMAINNAME)
    {
        ProcessSingleColumn(
                    bFetch,
                    szDomainName,
                    0,
                    kp->szDomainName,
                    sizeof(kp->szDomainName),
                    &dwSize,
                    LICENSEDPACK_COLUMN_DOMAINNAME
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

    if(dwParam & LICENSEDPACK_PROCESS_SERVERNAME)
    {
        ProcessSingleColumn(
                    bFetch,
                    szTlsServerName,
                    0,
                    &kp->szTlsServerName,
                    sizeof(kp->szTlsServerName),
                    &dwSize,
                    LICENSEDPACK_COLUMN_LSERVERNAME
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;
        
    if(dwParam & LICENSEDPACK_PROCESS_NEXTSERIALNUMBER)
    {
        ProcessSingleColumn(
                    bFetch,
                    dwNextSerialNumber,
                    0,
                    &(kp->dwNextSerialNumber),
                    sizeof(kp->dwNextSerialNumber),
                    &dwSize,
                    LICENSEDPACK_COLUMN_NEXTSERIALNUMBER
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;


    if(dwParam & LICENSEDPACK_PROCESS_ENTRYSTATUS)
    {
        ProcessSingleColumn(
                    bFetch,
                    ucEntryStatus,
                    0,
                    &(kp->ucEntryStatus),
                    sizeof(kp->ucEntryStatus),
                    &dwSize,
                    LICENSEDPACK_COLUMN_ENTRYSTATUS
                );
    }

cleanup:

    // 
    // For inserting/updating record
    if(bFetch == FALSE)
    {
        JET_ERR jetErr;
        jetErr = GetLastJetError();

        //
        // End update will reset the error code
        //
        EndUpdate(IsSuccess() == FALSE);

        if(jetErr != JET_errSuccess  && IsSuccess() == FALSE)
            SetLastJetError(jetErr);
    }

    return IsSuccess();
}

//-------------------------------------------------------
JBKeyBase*
LicPackTable::EnumerationIndex( 
    IN BOOL bMatchAll,
    IN DWORD dwParam,
    IN LICENSEPACK* kp,
    IN OUT BOOL* pbCompareKey
    )
/*
*/
{
    BOOL bRetCode;
    JBKeyBase* index=NULL;

    //
    // if matching all value in field, set to compare key
    //
    *pbCompareKey = bMatchAll;

    if(dwParam == LICENSEDPACK_FIND_PRODUCT) 
    {
        index = new TLSLicensedPackIdxInstalledProduct(kp);
    }
    else if(dwParam == LICENSEDPACK_FIND_LICENSEPACK)
    {
        index = new TLSLicensedPackIdxAllocateLicense(kp);
    }
    else if(dwParam & LICENSEDPACK_PROCESS_SZKEYPACKID)
    {
        index = new TLSLicensedPackIdxKeyPackId(kp);
    }
    else if(dwParam & LICENSEDPACK_PROCESS_COMPANYNAME)
    {
        index = new TLSLicensedPackIdxCompany(kp);
    }
    else if(dwParam & LICENSEDPACK_PROCESS_PRODUCTID)
    {
        index = new TLSLicensedPackIdxProductId(kp);
    }
    else if(dwParam & LICENSEDPACK_PROCESS_MODIFYTIME)
    {
        index = new TLSLicensedPackIdxLastModifyTime(kp);
    }
    else
    {
        index = new TLSLicensedPackIdxInternalKpId(kp);

        //
        // default index, can't compare key even if 
        // bmatchall is set to true
        //
        *pbCompareKey = (bMatchAll && (dwParam & LICENSEDPACK_PROCESS_DWINTERNAL));
    }

    return index;
}

//-------------------------------------------------------
BOOL
LicPackTable::EqualValue(
    IN LICENSEPACK& s1,         // values to be compared
    IN LICENSEPACK& s2,
    IN BOOL bMatchAll,      // match all specified fields in structure 
    IN DWORD dwParam        // which fields in KEYPACK to be compared
    )
/*

Compare fields in two KEYPACK structure

s1 : first value
s2 : second value
bMatchAll : TRUE if match all field specified in dwParam, FALSE otherwise
dwParam : fields that will be in comparision
               

*/
{
    BOOL bRetCode = TRUE;

    if(dwParam & LICENSEDPACK_PROCESS_ENTRYSTATUS)
    {
        bRetCode = (s1.ucEntryStatus == s2.ucEntryStatus);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_SZKEYPACKID)
    {
        bRetCode = (_tcscmp(s1.szKeyPackId, s2.szKeyPackId) == 0);

        //
        // bMatchAll == TRUE and bRetCode == FALSE -> return FALSE
        // bMatchAll == FALSE and bRetCode == TRUE -> return TRUE
        if(bMatchAll != bRetCode)
            goto cleanup;
    }
    
    if(dwParam & LICENSEDPACK_PROCESS_AGREEMENTTYPE)
    {
        bRetCode = (s1.ucAgreementType == s2.ucAgreementType);

        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_PRODUCTID)
    {
        bRetCode = (_tcscmp(s1.szProductId, s2.szProductId) == 0);

        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_MAJORVERSION)
    {
        bRetCode = (s1.wMajorVersion == s2.wMajorVersion);

        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_MINORVERSION)
    {
        bRetCode = (s1.wMinorVersion == s2.wMinorVersion);

        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_PLATFORMTYPE)
    {
        bRetCode = (s1.dwPlatformType == s2.dwPlatformType);
    
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_LICENSETYPE)
    {
        bRetCode = (s1.ucLicenseType == s2.ucLicenseType);

        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_COP)
    {
        bRetCode = (s1.ucChannelOfPurchase == s2.ucChannelOfPurchase);

        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_BSERIALNUMBER)
    {
        bRetCode = (_tcscmp(s1.szBeginSerialNumber, s2.szBeginSerialNumber) == 0);

        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_TOTALLICENSES)
    {
        bRetCode = (s1.dwTotalLicenseInKeyPack == s2.dwTotalLicenseInKeyPack);

        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_PRODUCTFLAGS)
    {
        bRetCode = (s1.dwProductFlags == s2.dwProductFlags);

        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_COMPANYNAME)
    {
        bRetCode = (_tcscmp(s1.szCompanyName, s2.szCompanyName) == 0);

        if(bMatchAll != bRetCode)
            goto cleanup;
    }


    if(dwParam & LICENSEDPACK_PROCESS_DWINTERNAL)
    {
        bRetCode = (s1.dwKeyPackId == s2.dwKeyPackId);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_MODIFYTIME)
    {
        bRetCode = (CompareFileTime(&s1.ftLastModifyTime, &s2.ftLastModifyTime) == 0);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_ATTRIBUTE)
    {
        bRetCode = (s1.dwAttribute == s2.dwAttribute);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_KEYPACKSTATUS)
    {
        bRetCode = (s1.ucKeyPackStatus == s2.ucKeyPackStatus);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_AVAILABLE)
    {
        bRetCode = (s1.dwNumberOfLicenses == s2.dwNumberOfLicenses);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_ACTIVATEDATE)
    {
        bRetCode = (s1.dwActivateDate == s2.dwActivateDate);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_EXPIREDATE)
    {
        bRetCode = (s1.dwExpirationDate == s2.dwExpirationDate);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    //if(dwParam & LICENSEDPACK_PROCESS_DOMAINSID)
    //{
    //    bRetCode = EqualSid(s1.pbDomainSid, s2.pbDomainSid);
    //    if(bMatchAll != bRetCode)
    //        goto cleanup;
    //}

    if(dwParam & LICENSEDPACK_PROCESS_LSSETUPID)
    {
        bRetCode = (_tcsicmp(s1.szInstallId, s2.szInstallId) == 0);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_DOMAINNAME)
    {
        bRetCode = (_tcsicmp(s1.szDomainName, s2.szDomainName) == 0);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_SERVERNAME)
    {
        bRetCode = (_tcsicmp(s1.szTlsServerName, s2.szTlsServerName) == 0);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_NEXTSERIALNUMBER)
    {
        bRetCode = (s1.dwNextSerialNumber == s2.dwNextSerialNumber);
    }
 
cleanup:

    return bRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tlsdb\version.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       version.h 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __TLS_VERSION_H__
#define __TLS_VERSION_H__

#include "JetBlue.h"
#include "TlsDb.h"

#define VERSION_TABLE_PROCESS_VERSION   0x00000001
#define VERSION_TABLE_PROCESS_INSTALLID 0x00000002
#define VERSION_TABLE_PROCESS_DOMAINID  0x00000004

//
// Only one row in Version
//
#define VERSION_TABLE_NAME      _TEXT("Version")
#define VERSION_TABLE_VERSION   _TEXT("DataBaseVersion")
#define VERSION_TABLE_INSTALLID _TEXT("TLSSetupId")
#define VERSION_TABLE_DOMAINID  _TEXT("TLSDomainSetupId")


typedef struct __Version : public TLSReplVersion 
{
    //----------------------------------------------------
    __Version() 
    {
        pbDomainSid = NULL;
        dwVersion = 0;
        cbDomainSid = 0;
        memset(szInstallId, 0, sizeof(szInstallId));
    }


    //----------------------------------------------------
    ~__Version() 
    {
        if(pbDomainSid != NULL)
        {
            FreeMemory(pbDomainSid);
        }
    }

    //----------------------------------------------------
    __Version(const __Version& v) 
    {
        *this = v;
    }

    //----------------------------------------------------
    __Version&
    operator=(const TLSReplVersion& v)
    {
        BOOL bSuccess;

        dwVersion = v.dwVersion;
        _tcscpy(szInstallId, v.szInstallId);

        bSuccess = TLSDBCopySid(
                            v.pbDomainSid,
                            v.cbDomainSid,
                            (PSID *)&pbDomainSid,
                            &cbDomainSid
                        );

        JB_ASSERT(bSuccess == TRUE);        
        return *this;
    }

    __Version&
    operator=(const __Version& v)
    {
        BOOL bSuccess;

        if(this == &v)
            return *this;

        dwVersion = v.dwVersion;
        _tcscpy(szInstallId, v.szInstallId);

        bSuccess = TLSDBCopySid(
                            v.pbDomainSid,
                            v.cbDomainSid,
                            (PSID *)&pbDomainSid,
                            &cbDomainSid
                        );

        JB_ASSERT(bSuccess == TRUE);        
        return *this;
    }

} TLSVersion;


//
// Index on version ID
//
#define VERSION_ID_INDEXNAME \
    VERSION_TABLE_NAME SEPERATOR VERSION_TABLE_VERSION SEPERATOR INDEXNAME

//
// Primary index - "+DataBaseVersion\0"
//
#define VERSION_ID_INDEXNAME_INDEXKEY \
    INDEX_SORT_ASCENDING VERSION_TABLE_VERSION INDEX_END_COLNAME

typedef struct __VersionIndexOnVersionId : public JBKeyBase {

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;


    DWORD dwVersion;

    //-------------------------------------------------
    __VersionIndexOnVersionId(
        const TLSVersion* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //-------------------------------------------------
    __VersionIndexOnVersionId(
        const TLSVersion& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    __VersionIndexOnVersionId&
    operator=(const TLSVersion& v) {
        dwVersion = v.dwVersion;
        SetEmptyValue(FALSE);
        return *this;
    }

    //--------------------------------------------------------
    DWORD
    GetNumKeyComponents() { return 1; }

    inline LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    inline LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    inline BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*
    */
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &(dwVersion);
        *cbData = sizeof(dwVersion);
        *grbit = JET_bitNewKey;
        return TRUE;
    }

} TLSVersionIndexVersionId;



//----------------------------------------------------------------------
class VersionTable : public TLSTable<TLSVersion> {

    static LPCTSTR pszTableName;

public:
    TLSColumnDword  dwVersion;
    TLSColumnText   szInstallId;
    TLSColumnBinary pbDomainSid;


    //------------------------------------------------
    virtual LPCTSTR
    GetTableName() {
        return pszTableName;
    }

    //------------------------------------------------
    VersionTable(
        JBDatabase& database
        ) : TLSTable<TLSVersion>(database)
    /*
    */
    {
    }

    //------------------------------------------------
    virtual BOOL
    ResolveToTableColumn();

    //----------------------------------------------------
    virtual BOOL
    FetchRecord(
        TLSVersion& v,
        DWORD dwParam=PROCESS_ALL_COLUMNS
    );

    //----------------------------------------------------
    BOOL
    InsertUpdateRecord(
        TLSVersion* v,
        DWORD dwParam=PROCESS_ALL_COLUMNS
    );
        
    //----------------------------------------------------
    virtual BOOL
    InsertRecord(
        TLSVersion& v,
        DWORD dwParam=PROCESS_ALL_COLUMNS
    );

    //----------------------------------------------------
    virtual BOOL
    UpdateRecord(
        TLSVersion& v,
        DWORD dwParam=PROCESS_ALL_COLUMNS
    );

    //----------------------------------------------------
    virtual BOOL
    Initialize() { return TRUE; }

    //----------------------------------------------------
    virtual JBKeyBase*    
    EnumerationIndex( 
        BOOL bMatchAll,
        DWORD dwParam,
        TLSVersion* pVersion,
        BOOL* bCompareKey
    );

    //----------------------------------------------------
    virtual BOOL
    EqualValue(
        TLSVersion& s1,
        TLSVersion& s2,
        BOOL bMatchAll,
        DWORD dwParam
    );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tlsdb\misc.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       misc.cpp 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include "tlsdb.h"

//-----------------------------------------------------------
BOOL
TLSDBCopySid(
    PSID pbSrcSid,
    DWORD cbSrcSid, 
    PSID* pbDestSid, 
    DWORD* cbDestSid
    )
/*++

++*/
{
    if( *pbDestSid == NULL || pbSrcSid == NULL ||
        LocalSize(*pbDestSid) < cbSrcSid )
    {
        if(*pbDestSid != NULL)
        {
            FreeMemory(*pbDestSid);
            *pbDestSid = NULL;
        }

        if(cbSrcSid && pbSrcSid)
        {
            *pbDestSid = (PBYTE)AllocateMemory(cbSrcSid);
            if(*pbDestSid == NULL)
            {
                return FALSE;
            }
        }
    }        

    *cbDestSid = cbSrcSid;
    return (cbSrcSid) ? CopySid(*cbDestSid, *pbDestSid, pbSrcSid) : TRUE;
}

//-----------------------------------------------------------
BOOL
TLSDBCopyBinaryData(
    PBYTE pbSrcData,
    DWORD cbSrcData, 
    PBYTE* ppbDestData, 
    DWORD* pcbDestData
    )
/*++

++*/
{

    if( ppbDestData == NULL || pcbDestData == NULL )
    {
        return(FALSE);
    }

    if( pbSrcData == NULL || cbSrcData == 0 )
    {
        return(TRUE);
    }

    //
    // would be nice to get the actual size of memory allocated
    //

    if( *ppbDestData != NULL && LocalSize(*ppbDestData) < cbSrcData )
    {
        LocalFree(*ppbDestData);
        *ppbDestData = NULL;
    }

    if( *ppbDestData == NULL )
    {
        *ppbDestData = (PBYTE)AllocateMemory(cbSrcData);
        if( *ppbDestData == NULL )
        {
            return FALSE;
        }
    }

    *pcbDestData = cbSrcData;

    memcpy(*ppbDestData, pbSrcData, cbSrcData);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tlsdb\tlsdb.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        tlsdb.h
//
// Contents:    basic class for license table
//
// History:     
//              
//---------------------------------------------------------------------------
#ifndef __TLSDB_H__
#define __TLSDB_H__

#include "JetBlue.h"
#include "locks.h"
#include "tlsrpc.h"

#define ENUMERATE_COMPARE_NO_FIELDS         0x00000000
#define PROCESS_ALL_COLUMNS                 0xFFFFFFFF

#define TLSTABLE_INDEX_DEFAULT_DENSITY  TLS_TABLE_INDEX_DEFAULT_DENSITY
#define TLSTABLE_MAX_BINARY_LENGTH          8192

#define RECORD_ENTRY_DELETED                0x01

#if DBG

    #define REPORT_IF_FETCH_FAILED( Table, Column, ErrCode )                                          \
        if(ErrCode < JET_errSuccess) {                                                      \
            DebugOutput(_TEXT("Table %s, Column %s - fetch failed with error code %d\n"),   \
                        Table, Column, ErrCode );                                            \
        }

    #define REPORT_IF_INSERT_FAILED( Table, Column, ErrCode )                                          \
        if(ErrCode < JET_errSuccess) {                                                      \
            DebugOutput(_TEXT("Table %s, Column %s - insert failed with error code %d\n"),   \
                        Table, Column, ErrCode );                                           \
        }

    #define REPORTPROCESSFAILED(bFetch, tablename, columnname, jeterror) \
        if(bFetch)  \
        {           \
            REPORT_IF_FETCH_FAILED(tablename, columnname, jeterror);  \
        }           \
        else        \
        {           \
            REPORT_IF_INSERT_FAILED(tablename, columnname, jeterror); \
        }

#else

    #define REPORT_IF_FETCH_FAILED( a, b, c )
    #define REPORT_IF_INSERT_FAILED( a, b, c )
    #define REPORTPROCESSFAILED( a, b, c, d)

#endif

//
////////////////////////////////////////////////////////////////
//
// This is to force compiler to check for require member 
// function
//
struct TLSColumnBase  {
    virtual JET_ERR
    FetchColumnValue(
        PVOID pbData,
        DWORD cbData,
        DWORD offset,
        PDWORD pcbReturnData
    ) = 0;

    virtual JET_ERR
    InsertColumnValue(
        PVOID pbData,
        DWORD cbData,
        DWORD offset
    ) = 0;
};

//
////////////////////////////////////////////////////////////////
//
template<class Type, JET_COLTYP JetColType>
struct TLSColumn : public JBColumnBufferBase, TLSColumnBase {

private:
    JBColumn* m_JetColumn;    

    //--------------------------------------------
    JET_ERR
    RetrieveColumnValue(
        PVOID pbData,
        DWORD cbData,
        DWORD offset
        ) 
    /*
    */
    {
        JB_ASSERT(IsValid() == TRUE);

        if(m_JetColumn == NULL)
        {
            #ifdef DBG
            OutputDebugString(
                    _TEXT("Column buffer not attach to any table...\n")
                );
            #endif

            return JET_errNotInitialized;
        }

        //JB_ASSERT(pbData != NULL);

        //
        // TODO - supply conversion routine ???
        //
        if(m_JetColumn->GetJetColumnType() != JB_COLTYPE_TEXT)
        {
            // we are using long binary type as long text so ignore
            // this one
            if(m_JetColumn->GetJetColumnType() != JetColType)
            {
                //
                // this is an internal error
                //
                JB_ASSERT(m_JetColumn->GetJetColumnType() == JetColType);
                m_JetColumn->SetLastJetError(
                                    JET_errInvalidParameter
                                );
                return FALSE;
            }
        }

        BOOL bSuccess;

        bSuccess = m_JetColumn->FetchColumn(
                            pbData,
                            cbData,
                            offset
                        );

        return (bSuccess == TRUE) ? JET_errSuccess : m_JetColumn->GetLastJetError();
    }

public:

    //--------------------------------------------
    TLSColumn( 
        TLSColumn& src 
        ) : 
        m_JetColumn(src.m_JetColumn) 
    /*
    */        
    {
    }
    
    //--------------------------------------------
    TLSColumn(
        JBTable& jbTable,
        LPCTSTR pszColumnName
        )
    /*
    */
    {
        if(AttachToTable(jbTable, pszColumnName) == FALSE)
        {
            JB_ASSERT(FALSE);
        }
    }
            
    //--------------------------------------------
    TLSColumn() : m_JetColumn(NULL) {}

    //--------------------------------------------

    JET_ERR
    AttachToTable( 
        JBTable& jbTable, 
        LPCTSTR pszColumnName 
        )   
    /*
    */
    {
        m_JetColumn = jbTable.FindColumnByName(pszColumnName);
        return (m_JetColumn != NULL) ? JET_errSuccess : jbTable.GetLastJetError();
    }
    

    //--------------------------------------------
    BOOL 
    IsValid() 
    {
        return (m_JetColumn != NULL);
    }
                
    //--------------------------------------------
    virtual JET_ERR
    FetchColumnValue(
        PVOID pbData,           // buffer for returning data
        DWORD cbData,           // size of buffer
        DWORD offset,
        PDWORD pcbReturnData    // actual data returned.
        ) 
    /*
    */
    {
        JET_ERR jetErr;
        jetErr = RetrieveColumnValue(
                                pbData,
                                cbData,
                                offset
                            );

        if(pcbReturnData)
        {
            *pcbReturnData = GetActualDataSize();
        }
        return jetErr;
    }

    //--------------------------------------------
    virtual JET_ERR
    InsertColumnValue(
        PVOID pbData,
        DWORD cbData,
        DWORD offset
        )
    /*
    */
    {
        JB_ASSERT(IsValid() == TRUE);
        if(m_JetColumn == NULL)
        {
            #ifdef DBG
            OutputDebugString(
                    _TEXT("Column buffer not attach to any table...\n")
                );
            #endif

            return JET_errNotInitialized;
        }


        BOOL bSuccess;
        bSuccess = m_JetColumn->InsertColumn(
                                pbData,
                                cbData,
                                offset
                            );

        return (bSuccess == TRUE) ? JET_errSuccess : m_JetColumn->GetLastJetError();
    }

    //--------------------------------------------
    JET_ERR
    GetLastJetError() 
    {
        return (m_JetColumn) ? m_JetColumn->GetLastJetError() : JET_errNotInitialized;
    }

    //--------------------------------------------
    DWORD
    GetActualDataSize() 
    {
        return m_JetColumn->GetDataSize();
    }

    //-------------------------------------------
    JET_COLTYP
    GetJetColumnType() 
    {
        return JetColType;
    }


    //
    // Always require calling function to pass in buffer
    //
    PVOID
    GetInputBuffer() 
    { 
        JB_ASSERT(FALSE); 
        return NULL;
    }

    //-----------------------------------------
    PVOID
    GetOutputBuffer() 
    {
        JB_ASSERT(FALSE);
        return NULL;
    }

    //-----------------------------------------
    DWORD
    GetInputBufferLength() 
    { 
        return 0; 
    }

    //-----------------------------------------
    DWORD
    GetOutputBufferLength() 
    { 
        return 0; 
    }
};  


// ----------------------------------------------------------
//
// Out text is unicode, JetBlue only support fix length text up 
// to 255 characters so we use Long text instead.
//
// JET_coltypBinary
// JET_coltypText
// JET_coltypLongBinary
// JET_coltypLongText
//
// See esent.h
//
typedef TLSColumn<LPTSTR, JET_coltypLongText> TLSColumnText;
typedef TLSColumn<PVOID, JET_coltypLongBinary> TLSColumnBinary;

//
// unsigned byte
typedef TLSColumn<UCHAR, JET_coltypUnsignedByte> TLSColumnUchar;   

//
// 2-byte integer, signed
typedef TLSColumn<WORD, JET_coltypShort> TLSColumnShort;

//
// 4-byte integer, signed
typedef TLSColumn<LONG, JET_coltypLong> TLSColumnLong;

//
//
typedef TLSColumn<DWORD, JET_coltypLong> TLSColumnDword;


//
// 4-byte IEEE single precision
typedef TLSColumn<float, JET_coltypIEEESingle> TLSColumnFloat;

// 
// 8-byte IEEE double precision
typedef TLSColumn<double, JET_coltypIEEEDouble> TLSColumnDouble;


//
// File Time
typedef TLSColumn<FILETIME, JET_coltypBinary> TLSColumnFileTime;


//--------------------------------------------------------------    

JET_ERR
TLSColumnText::InsertColumnValue(
    PVOID pbData,
    DWORD cbData,
    DWORD offset
    )
/*
*/
{
    JB_ASSERT(IsValid() == TRUE);
    JET_ERR jetErr;

    jetErr = m_JetColumn->InsertColumn(
                            pbData,
                            _tcslen((LPTSTR) pbData) * sizeof(TCHAR),
                            offset
                        );

    return jetErr;
}

//--------------------------------------------------------------    

JET_ERR
TLSColumnText::FetchColumnValue(
    PVOID pbData,
    DWORD cbData,
    DWORD offset,
    PDWORD pcbDataReturn
    ) 
/*
*/
{
    PVOID pbBuffer = pbData;
    DWORD cbBuffer = cbData;

    // Cause recursive call - stack overflow
    // if(TLSColumn<Type>::FetchColumnValue(offset, pbData, cbData) == FALSE)
    //     return m_JetColumn->GetLastJetError();

    JET_ERR jetErr = RetrieveColumnValue( pbBuffer, cbBuffer, offset );
    if(jetErr == JET_errSuccess) 
    {
        ((LPTSTR)pbBuffer)[(min(cbBuffer, GetActualDataSize())) / sizeof(TCHAR)] = _TEXT('\0');
    }

    if(pcbDataReturn)
    {
        *pcbDataReturn = _tcslen((LPTSTR)pbBuffer);
    }

    return jetErr;
}

//---------------------------------------------------

JET_ERR
TLSColumnFileTime::InsertColumnValue(
    PVOID pbData,
    DWORD cbData,
    DWORD offset
    )
/*
*/
{
    FILETIME ft;
    SYSTEMTIME sysTime;

    JB_ASSERT(IsValid() == TRUE);
    JB_ASSERT(cbData == sizeof(FILETIME));
    JET_ERR jetErr;

    if(IsValid() == FALSE)
    {
        jetErr = JET_errNotInitialized;
    }
    else if(cbData != sizeof(FILETIME) || pbData == NULL)
    {
        m_JetColumn->SetLastJetError(jetErr = JET_errInvalidParameter);
    }
    else 
    {    

        memset(&ft, 0, sizeof(ft));
        if(CompareFileTime(&ft, (FILETIME *)pbData) == 0)
        {
            GetSystemTime(&sysTime);
            SystemTimeToFileTime(&sysTime, &ft);

            ((FILETIME *)pbData)->dwLowDateTime = ft.dwLowDateTime;
            ((FILETIME *)pbData)->dwHighDateTime = ft.dwHighDateTime;
        }
        else
        {
            ft.dwLowDateTime = ((FILETIME *)pbData)->dwLowDateTime;
            ft.dwHighDateTime = ((FILETIME *)pbData)->dwHighDateTime;
        }

        jetErr = m_JetColumn->InsertColumn(
                                (PVOID)&ft,
                                sizeof(ft),
                                0
                            );
    }

    return jetErr;
}

//---------------------------------------------------

JET_ERR
TLSColumnBinary::FetchColumnValue(
    PVOID pbData,
    DWORD cbData,
    DWORD offset,
    PDWORD pcbDataReturn
    )
/*
*/
{
    //
    // don't worry about buffer size, calling function 
    // should trap it.
    JET_ERR jetErr = RetrieveColumnValue( pbData, cbData, offset );
    if(jetErr == JET_errSuccess && pcbDataReturn != NULL) 
    {
        *pcbDataReturn = GetActualDataSize();
    }

    return jetErr;
}

//
/////////////////////////////////////////////////////////////
//
typedef enum {
    RECORD_ENUM_ERROR=0,
    RECORD_ENUM_MORE_DATA,
    RECORD_ENUM_END
} RECORD_ENUM_RETCODE;


template<class T>
class TLSTable : public JBTable {
/*
    Virtual base template class for table used in TLSLicensing 
    database, template is due to 

    1) Static member variable which include column and indexes 
       in the table.
    2) Type checking - KEYPACK structure only good for one
       table.

    Class derive from this template must define 

    1) static g_Columns, g_NumColumns.
    2) static g_TableIndex, g_NumTableIndex.
    3) static g_TableLock (Might not be necessary)
    4) GetTableName()
    5) FetchRecord
    6) InsertRecord
    7) ResolveToTableColumn()
    8) EnumerationBegin()
    9) EqualValue().

    See comment for each member function.
*/
protected:

    //
    // Class derive or inst. from TLSTable<> must define following
    //
    static TLSJBColumn g_Columns[];
    static int g_NumColumns;

    static TLSJBIndex g_TableIndex[];
    static int g_NumTableIndex;

    T m_EnumValue;
    BOOL m_EnumMatchAll;
    DWORD m_EnumParam;
    DWORD m_EnumState; // HIWORD - in enumeration, TRUE/FALSE 
                       // LOWORD - MoveToNext record before fetch.

    BYTE  m_Key[sizeof(T)];
    DWORD m_KeyLength;
    BOOL m_bCompareKey; // should we compare key?

    BOOL 
    IsInEnumeration() {
        return HIWORD(m_EnumState);
    }

    BOOL
    IsMoveBeforeFetch() {
        return LOWORD(m_EnumState);
    }

    void 
    SetInEnumeration(
        BOOL b
        ) 
    {
        m_EnumState = MAKELONG(LOWORD(m_EnumState), b);
    }

    void 
    SetMoveBeforeFetch(
        BOOL b
        ) 
    {
        m_EnumState = MAKELONG(b, HIWORD(m_EnumState));
    }
        

public:

    //
    // JetBlue has its own locking
    //
    static CCriticalSection g_TableLock;

    CCriticalSection&
    GetTableLock()
    {
        return g_TableLock;
    }

    //-------------------------------------------------------
    static void
    LockTable() 
    /*

        Lock table for exclusive access, JBTable provides
        ReadLock/WriteLock for current record

    */
    {
        g_TableLock.Lock();
    }

    //-------------------------------------------------------
    static void
    UnlockTable() 
    /*

        Unlock table.

    */
    {
        g_TableLock.UnLock();
    }

    //-------------------------------------------------------
    TLSTable(
        JBDatabase& database
        ) : 
        JBTable(database),
        m_EnumMatchAll(FALSE),
        m_EnumParam(0),
        m_EnumState(0),
        m_KeyLength(0)
    /*

        Constructor, must have JBDatabase object.

    */
    {
        memset(&m_EnumValue, 0, sizeof(T));
        memset(m_Key, 0, sizeof(m_Key));
    }

    
    //-------------------------------------------------------
    virtual BOOL
    CreateTable() 
    /*
        
        Create the table, must have g_Columns and g_NumColumns
        defined.
    
    */
    {
        DebugOutput(
                _TEXT("TLSTable - Creating Table %s...\n"),
                GetTableName()
            );

        if(BeginTransaction() == FALSE)
            return FALSE;
    
        if(CreateOpenTable(GetTableName()) == TRUE)
        {
            //
            // AddColumn() return num of col. created if successful
            //
            if(AddColumn(g_NumColumns, g_Columns) == g_NumColumns)
            {
                //
                // AddIndex() return 0 if success
                //
                AddIndex(g_NumTableIndex, g_TableIndex);
            }
        }

        if(IsSuccess() == TRUE)
        {
            CloseTable();
            CommitTransaction();
        }
        else
        {
            RollbackTransaction();
        }

        return IsSuccess();
    }

    //--------------------------------------------------------
    virtual BOOL
    UpgradeTable(
        IN DWORD dwOldVersion,
        IN DWORD dwNewVersion
        )
    /*++

    ++*/
    {
        if(dwOldVersion == 0)
        {
            if(OpenTable(TRUE, JET_bitTableUpdatable) == FALSE)
                return FALSE;

            return CloseTable();
        }
        else if(dwOldVersion == dwNewVersion)
        {
            return TRUE;
        }

        // We only have one version.
        JB_ASSERT(FALSE);
        return FALSE;
    }


    //--------------------------------------------------------
    virtual BOOL
    OpenTable(
        IN BOOL bCreateIfNotExist,
        IN JET_GRBIT grbit
        ) 
    /*

    Abstract:

        Open the table for access.

    Parameter:

        bCreateIfNoExist - TRUE, if table does not exist, create it,
                           FALSE return error if table not exist
    */
    {
        if( JBTable::OpenTable(GetTableName(), NULL, 0, grbit) == FALSE && 
            GetLastJetError() == JET_errObjectNotFound && 
            bCreateIfNotExist)
        {
            //
            // Close table after it created it
            //
            if( CreateTable() == FALSE || 
                JBTable::OpenTable(GetTableName(), NULL, 0, grbit) == FALSE ) 
            {
                return FALSE;
            }
        }

        if(IsSuccess() == TRUE)
        {
            ResolveToTableColumn();
        }

        return IsSuccess();
    }

    //---------------------------------------------------------
    //
    // pure virtual function to return table name
    //
    virtual LPCTSTR
    GetTableName() = 0;

    //---------------------------------------------------------
    virtual BOOL
    UpdateTable(
        IN DWORD dwOldVersion,  // unuse
        IN DWORD dwNewVersion
        )
    /*

    Abstract:

        Upgrade the table.

    Parameter:

        dwOldVersion - previous table version.
        dwNewVersion - current table version.

    */
    {
        // currently nothing to upgrade.

        return TRUE;
    }

    //
    // should have fetch/insert record with buffer passed in
    //
    //---------------------------------------------------------
    virtual BOOL
    InsertRecord(
        T& value,
        DWORD dwParam = PROCESS_ALL_COLUMNS
    ) = 0;

    virtual BOOL
    UpdateRecord(
        T& value,
        DWORD dwParam = PROCESS_ALL_COLUMNS
    ) = 0;

    //--------------------------------------------------------
    virtual BOOL
    FetchRecord(
        T& value,
        DWORD dwParam = PROCESS_ALL_COLUMNS
    ) = 0;

    //---------------------------------------------------------
    virtual BOOL
    Cleanup() 
    {
        EnumerateEnd();
        return TRUE;
    }  

    //---------------------------------------------------------
    virtual BOOL
    ResolveToTableColumn() = 0;

    //---------------------------------------------------------
    virtual JBKeyBase* 
    EnumerationIndex(
        BOOL bMatchAll,
        DWORD dwParam,
        T* value,
        BOOL* bCompareKey
    ) = 0;

    //------------------------------------------------------
    virtual BOOL
    EqualValue(
        T& src, 
        T& dest, 
        BOOL bMatchAll,
        DWORD dwMatchParam
    ) = 0;

    //-------------------------------------------------------
    //
    // Use user defined comparision function instead of calling
    // EqualValue() ???
    //
    virtual BOOL
    EnumerateBegin( 
        BOOL bMatchAll,
        DWORD dwParam,
        T* start_value
        )
    /*
    */
    {
        return EnumerateBegin(
                    bMatchAll,
                    dwParam,
                    start_value,
                    JET_bitSeekGE
                    );
    }

    virtual BOOL
    EnumerateBegin( 
        BOOL bMatchAll,
        DWORD dwParam,
        T* start_value,
        JET_GRBIT jet_seek_grbit
        )
    /*
    */
    {
        BOOL bRetCode = FALSE;
        
        if(dwParam != ENUMERATE_COMPARE_NO_FIELDS && start_value == NULL)
        {
            SetLastJetError(JET_errInvalidParameter);
            JB_ASSERT(FALSE);
            return FALSE;
        }

        if(IsInEnumeration() == TRUE)
        {
            SetLastJetError(JET_errInvalidObject);
            JB_ASSERT(FALSE);
            return FALSE;
        }

        JBKeyBase* index;

        index = EnumerationIndex(
                            bMatchAll, 
                            dwParam, 
                            start_value, 
                            &m_bCompareKey
                        );

        if(index == NULL)
        {
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        if(start_value == NULL || dwParam == ENUMERATE_COMPARE_NO_FIELDS)
        {
            //
            // position the cursor to first record
            // 
            bRetCode = JBTable::EnumBegin(index);

            m_EnumParam = ENUMERATE_COMPARE_NO_FIELDS;
            m_EnumMatchAll = FALSE;

            // enumerate all record
            m_bCompareKey = FALSE;
        }
        else
        {
            bRetCode = JBTable::SeekToKey(
                                    index, 
                                    dwParam, 
                                    jet_seek_grbit
                                );

            if(bRetCode == TRUE && m_bCompareKey)
            {
                bRetCode = JBTable::RetrieveKey(
                                        m_Key, 
                                        sizeof(m_Key), 
                                        &m_KeyLength
                                    );

                JB_ASSERT(bRetCode == TRUE);
            }

        }

        if(bRetCode == FALSE)
        {
            if(GetLastJetError() == JET_errRecordNotFound)
            {
                //
                // reset error code to provide same functionality as SQL
                //
                SetLastJetError(JET_errSuccess);
                bRetCode = TRUE;
            }
            else
            {
                DebugOutput(
                        _TEXT("Enumeration on table %s failed with error %d\n"),
                        GetTableName(),
                        GetLastJetError()
                    );

                JB_ASSERT(bRetCode);
            }
        }

        if(bRetCode == TRUE)
        {
            m_EnumParam = dwParam;
            m_EnumMatchAll = bMatchAll;

            if(start_value)
            {
                m_EnumValue = *start_value;
            }

            SetInEnumeration(TRUE);

            // cursor in on the the record we want.
            SetMoveBeforeFetch(FALSE);
        }

        delete index;
        return bRetCode;
    }

    //------------------------------------------------------
    virtual RECORD_ENUM_RETCODE
    EnumerateNext(
        IN OUT T& retBuffer,
        IN BOOL bReverse=FALSE,
        IN BOOL bAnyRecord = FALSE
        )
    /*
    */
    {
        if(IsInEnumeration() == FALSE)
        {
            SetLastJetError(JET_errInvalidParameter);
            return RECORD_ENUM_ERROR;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        RECORD_ENUM_RETCODE retCode=RECORD_ENUM_MORE_DATA;
        BYTE current_key[sizeof(T)];
        unsigned long current_key_length=0;
        //
        // Support for matching  
        //
        while(TRUE)
        {
            if(IsMoveBeforeFetch() == TRUE)
            {
                //
                // Position the cursor to next record for next fetch
                //
                JBTable::ENUM_RETCODE enumCode;
                enumCode = EnumNext(
                                    (bReverse == TRUE) ? JET_MovePrevious : JET_MoveNext
                                );

                switch(enumCode)
                {
                    case JBTable::ENUM_SUCCESS:
                        retCode = RECORD_ENUM_MORE_DATA;
                        break;
            
                    case JBTable::ENUM_ERROR:
                        retCode = RECORD_ENUM_ERROR;
                        break;

                    case JBTable::ENUM_END:
                        retCode = RECORD_ENUM_END;
                }

                if(retCode != RECORD_ENUM_MORE_DATA)
                    break;

            }

            // fetch entire record
            // TODO - fetch necessary fields for comparision, if
            //        equal then fetch remaining fields
            if(FetchRecord(retBuffer, PROCESS_ALL_COLUMNS) == FALSE)
            {
                retCode = (GetLastJetError() == JET_errNoCurrentRecord || 
                           GetLastJetError() == JET_errRecordNotFound) ? RECORD_ENUM_END : RECORD_ENUM_ERROR;
                break;
            }

            SetMoveBeforeFetch(TRUE);

            // compare the value
            if( bAnyRecord == TRUE ||
                m_EnumParam == ENUMERATE_COMPARE_NO_FIELDS ||
                EqualValue(retBuffer, m_EnumValue, m_EnumMatchAll, m_EnumParam) == TRUE )
            {
                break;
            }

            if(m_bCompareKey == TRUE)
            {
                // compare key to break out of loop
                if(JBTable::RetrieveKey(current_key, sizeof(current_key), &current_key_length) == FALSE)
                {
                    retCode = RECORD_ENUM_ERROR;
                    break;
                }

                if(memcmp(current_key, m_Key, min(m_KeyLength, current_key_length)) != 0)
                {
                    retCode = RECORD_ENUM_END;
                    break;
                }
            }
        }
    
        //
        // Terminate enumeration if end
        //
        //if(retCode != RECORD_ENUM_MORE_DATA)
        //{
        //    EnumerateEnd();
        //}

        return retCode;
    }

    //------------------------------------------------------
    virtual BOOL
    EnumerateEnd() {
        SetInEnumeration(FALSE);
        SetMoveBeforeFetch(FALSE);
        m_bCompareKey = FALSE;
        return TRUE;
    }

    //-------------------------------------------------------
    virtual DWORD
    GetCount(
        BOOL bMatchAll,
        DWORD dwParam,
        T* searchValue
        )
    /*
    */
    {
        DWORD count = 0;
        T value;
        RECORD_ENUM_RETCODE retCode;


        if(EnumerateBegin(bMatchAll, dwParam, searchValue) == TRUE)
        {
            while( (retCode=EnumerateNext(value)) == RECORD_ENUM_MORE_DATA )
            {
                count++;
            }

            if(retCode == RECORD_ENUM_ERROR)
            {
                DebugOutput(
                        _TEXT("GetCount for table %s : EnumerationNext() return %d\n"),
                        GetTableName(),
                        GetLastJetError()
                    );

                JB_ASSERT(FALSE);
            }

            EnumerateEnd();
        }
        else
        {
            DebugOutput(
                    _TEXT("GetCount for table %s : EnumerationBegin return %d\n"),
                    GetTableName(),
                    GetLastJetError()
                );

            JB_ASSERT(FALSE);
        }

        return count;
    }

    //-----------------------------------------------------
    virtual BOOL
    FindRecord(
        BOOL bMatchAll,
        DWORD dwParam,
        T& seachValue,
        T& retValue
        )
    /*
    */
    {
        RECORD_ENUM_RETCODE retCode;
        BOOL bSuccess=TRUE;

        //CCriticalSectionLocker Lock(GetTableLock());

        if(EnumerateBegin(bMatchAll, dwParam, &seachValue) == FALSE)
        {
            DebugOutput(
                    _TEXT("SearchValue for table %s : EnumerationBegin return %d\n"),
                    GetTableName(),
                    GetLastJetError()
                );

            JB_ASSERT(FALSE);

            bSuccess = FALSE;
            goto cleanup;
        }

        retCode = EnumerateNext(retValue);
        EnumerateEnd();

        if(retCode == RECORD_ENUM_ERROR)
        {
            DebugOutput(
                    _TEXT("SearchValue for table %s : EnumerationNext() return %d\n"),
                    GetTableName(),
                    GetLastJetError()
                );
        
            bSuccess = FALSE;
            JB_ASSERT(FALSE);
        }
        else if(retCode == RECORD_ENUM_END)
        {
            SetLastJetError(JET_errRecordNotFound);
            bSuccess = FALSE;
        }


    cleanup:

        return bSuccess;
    }

    //-------------------------------------------------
    virtual BOOL
    DeleteRecord()
    {
        //CCriticalSectionLocker Lock(GetTableLock());

        return JBTable::DeleteRecord();
    }

    //-------------------------------------------------
    virtual BOOL
    DeleteRecord(
        DWORD dwParam,
        T& value
        )
    /*
    */
    {
        BOOL bSuccess;
        T Dummy;

        //CCriticalSectionLocker Lock(GetTableLock());

        //
        // Position the current record
        bSuccess = FindRecord(
                            TRUE,
                            dwParam,
                            value,
                            Dummy
                        );

        if(bSuccess == FALSE)
            return FALSE;


        //
        // Delete the record
        bSuccess = JBTable::DeleteRecord();
        return bSuccess;
    }

    //----------------------------------------------
    virtual BOOL
    DeleteAllRecord(
        BOOL bMatchAll,
        DWORD dwParam,
        T& searchValue
        )
    /*
    */
    {
        int count=0;
        BOOL bSuccess;
        JET_ERR jetErr=JET_errSuccess;
        RECORD_ENUM_RETCODE retCode;
        T value;

        //CCriticalSectionLocker Lock(GetTableLock());

        if(EnumerateBegin(bMatchAll, dwParam, &searchValue) == TRUE)
        {
            while( (retCode=EnumerateNext(value)) == RECORD_ENUM_MORE_DATA )
            {
                count++;
                if(JBTable::DeleteRecord() == FALSE)
                {
                    DebugOutput(
                            _TEXT("DeleteAllRecord for table %s : return %d\n"),
                            GetTableName(),
                            GetLastJetError()
                        );

                    JB_ASSERT(FALSE);
                    jetErr = GetLastJetError();
                    break;
                }
            }

            //
            // End the enumeration
            //
            if(retCode == RECORD_ENUM_ERROR)
            {
                DebugOutput(
                        _TEXT("DeleteAllRecord for table %s : EnumerationNext() return %d\n"),
                        GetTableName(),
                        GetLastJetError()
                    );

                JB_ASSERT(FALSE);
            }

            if(EnumerateEnd() == TRUE)
            {
                // restore error code from DeleteRecord();
                SetLastJetError(jetErr);
            }
        }
        else
        {
            DebugOutput(
                    _TEXT("DeleteAllRecord for table %s : EnumerationBegin return %d\n"),
                    GetTableName(),
                    GetLastJetError()
                );
        }

        // return code is based on number of record deleted and its operation
        if(IsSuccess() == TRUE)
        {
            if(count == 0)
                SetLastJetError(JET_errRecordNotFound);
        }

        return IsSuccess();
    }
};


#ifdef __cplusplus
extern "C" {
#endif

    BOOL
    TLSDBCopySid(
        PSID pbSrcSid,
        DWORD cbSrcSid, 
        PSID* pbDestSid, 
        DWORD* cbDestSid
    );

    BOOL
    TLSDBCopyBinaryData(
        PBYTE pbSrcData,
        DWORD cbSrcData, 
        PBYTE* ppbDestData, 
        DWORD* pcbDestData
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tlsdb\lictab.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       lictab.cpp 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include "Licensed.h"


LPCTSTR __LicensedIndexOnLicenseId::pszIndexName = LICENSE_ID_INDEXNAME;
LPCTSTR __LicensedIndexOnLicenseId::pszIndexKey = LICENSE_ID_INDEXNAME_INDEXKEY;

LPCTSTR __LicensedIndexOnKeyPackId::pszIndexName = LICENSE_KEYPACKID_INDEXNAME;
LPCTSTR __LicensedIndexOnKeyPackId::pszIndexKey = LICENSE_KEYPACKID_INDEXNAME_INDEXKEY;

LPCTSTR __LicensedIndexOnLastModifyTime::pszIndexName = LICENSE_KEYPACKID_INDEXNAME;
LPCTSTR __LicensedIndexOnLastModifyTime::pszIndexKey = LICENSE_KEYPACKID_INDEXNAME_INDEXKEY;

LPCTSTR __LicensedIndexOnMachineName::pszIndexName = LICENSE_CLIENT_MACHINENAME_INDEXNAME;
LPCTSTR __LicensedIndexOnMachineName::pszIndexKey = LICENSE_CLIENT_MACHINENAME_INDEXNAME_INDEXKEY;

LPCTSTR __LicensedIndexOnUserName::pszIndexName = LICENSE_CLIENT_USERNAME_INDEXNAME;
LPCTSTR __LicensedIndexOnUserName::pszIndexKey = LICENSE_CLIENT_USERNAME_INDEXNAME_INDEXKEY;

LPCTSTR __LicensedIndexOnHwid::pszIndexName = LICENSE_CLIENT_HWID_INDEXNAME;
LPCTSTR __LicensedIndexOnHwid::pszIndexKey = LICENSE_CLIENT_HWID_INDEXNAME_INDEXKEY;

LPCTSTR __LicensedIndexOnMatchHwid::pszIndexName = LICENSE_MATCHHWID_INDEXNAME;
LPCTSTR __LicensedIndexOnMatchHwid::pszIndexKey = LICENSE_MATCHHWID_INDEXNAME_INDEXKEY;

LPCTSTR __LicensedIndexOnExpireDate::pszIndexName = LICENSE_EXPIREDATE_INDEXNAME;
LPCTSTR __LicensedIndexOnExpireDate::pszIndexKey = LICENSE_EXPIREDATE_INDEXNAME_INDEXKEY;

CCriticalSection LicensedTable::g_TableLock;
LPCTSTR LicensedTable::pszTableName = LICENSE_TABLE_NAME;

//-------------------------------------------------------------------

TLSJBIndex
LicensedTable::g_TableIndex[] = 
{
    // Index on license ID.
    {
        LICENSE_ID_INDEXNAME,
        LICENSE_ID_INDEXNAME_INDEXKEY,
        -1,
        JET_bitIndexPrimary,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },

    //
    // Index on licensed keypack id.
    {
        LICENSE_KEYPACKID_INDEXNAME,
        LICENSE_KEYPACKID_INDEXNAME_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },

    // index on last modify time.
    {
        LICENSE_LASTMODIFY_INDEXNAME,
        LICENSE_LASTMODIFY_INDEXNAME_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },

    // Index on machine name
    {
        LICENSE_CLIENT_MACHINENAME_INDEXNAME,
        LICENSE_CLIENT_MACHINENAME_INDEXNAME_INDEXKEY,
        -1,
        0,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },

    // index on user name
    {
        LICENSE_CLIENT_USERNAME_INDEXNAME,
        LICENSE_CLIENT_USERNAME_INDEXNAME_INDEXKEY,
        -1,
        0,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },

    // index on client machine's hardware id
    {
        LICENSE_CLIENT_HWID_INDEXNAME,
        LICENSE_CLIENT_HWID_INDEXNAME_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },

    // index on client hardware id matching hint
    {
        LICENSE_MATCHHWID_INDEXNAME,
        LICENSE_MATCHHWID_INDEXNAME_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },

    // index on license expiration date
    {
        LICENSE_EXPIREDATE_INDEXNAME,
        LICENSE_EXPIREDATE_INDEXNAME_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },
};

int
LicensedTable::g_NumTableIndex = sizeof(LicensedTable::g_TableIndex) / sizeof(LicensedTable::g_TableIndex[0]);

TLSJBColumn
LicensedTable::g_Columns[] = 
{
    //
    // Entry status
    {
        LICENSE_COLUMN_ENTRYSTATUS,
        JET_coltypUnsignedByte,
        0,
        JET_bitColumnFixed,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // Licensed ID
    {
        LICENSE_COLUMN_ID_COLUMN,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    //  KeyPackId
    {
        LICENSE_COLUMN_KEYPACKID,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //  
    // KeyPackLicenseId
    {
        LICENSE_COLUMN_LICENSEID,
        JET_coltypLong,
        0,
        JET_bitColumnFixed,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // Last modify time
    {
        LICENSE_COLUMN_LASTMODIFYTIME,
        JET_coltypBinary,
        sizeof(FILETIME),
        JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },
        
    //
    // SystemBios
    {
        LICENSE_COLUMN_SYSTEMBIOS,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // Video Bios
    {
        LICENSE_COLUMN_VIDEOBIOS,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },
        
    //
    // Floppy Bios
    {
        LICENSE_COLUMN_FLOPPYBIOS,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // Harddisk size
    {
        LICENSE_COLUMN_HARDDISKSIZE,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // RAM size
    {
        LICENSE_COLUMN_RAMSIZE,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // Match HWID 
    {
        LICENSE_COLUMN_MATCHHWID,
        JET_coltypIEEEDouble,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // Machine name
    {
        LICENSE_COLUMN_MACHINENAME,
        //JET_coltypLongText,
        JB_COLTYPE_TEXT,
        (MAX_JETBLUE_TEXT_LENGTH + 1)*sizeof(TCHAR),
        0,
        JBSTRING_NULL,
        _tcslen(JBSTRING_NULL),
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // User Name
    {
        LICENSE_COLUMN_USERNAME,
        //JET_coltypLongText,
        JB_COLTYPE_TEXT,
        (MAX_JETBLUE_TEXT_LENGTH + 1)*sizeof(TCHAR),
        0,
        JBSTRING_NULL,
        _tcslen(JBSTRING_NULL),
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // Number of licenses for this client
    {
        LICENSE_COLUMN_NUMLICENSES,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // IssuedDate
    {
        LICENSE_COLUMN_ISSUEDATE,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // ExpireDate
    {
        LICENSE_COLUMN_EXPIREDATE,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // License Status
    {
        LICENSE_COLUMN_LICENSESTATUS,
        JET_coltypUnsignedByte,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    }
};

int
LicensedTable::g_NumColumns=sizeof(LicensedTable::g_Columns) / sizeof(LicensedTable::g_Columns[0]);

///////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------
BOOL
LicensedTable::ResolveToTableColumn()
/*
*/
{
    m_JetErr = ucEntryStatus.AttachToTable(
                            *this,
                            LICENSE_COLUMN_ENTRYSTATUS
                        );
    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwKeyPackLicenseId.AttachToTable(
                            *this,
                            LICENSE_COLUMN_LICENSEID
                        );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = ftLastModifyTime.AttachToTable(
                        *this,
                        LICENSE_COLUMN_LASTMODIFYTIME
                    );
    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwLicenseId.AttachToTable(
                        *this,
                        LICENSE_COLUMN_ID_COLUMN
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;
    
    m_JetErr = dwKeyPackId.AttachToTable(
                        *this,
                        LICENSE_COLUMN_KEYPACKID
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = szMachineName.AttachToTable(
                        *this,
                        LICENSE_COLUMN_MACHINENAME
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = szUserName.AttachToTable(
                        *this,
                        LICENSE_COLUMN_USERNAME
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = ftIssueDate.AttachToTable(
                        *this,
                        LICENSE_COLUMN_ISSUEDATE
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = ftExpireDate.AttachToTable(
                        *this,
                        LICENSE_COLUMN_EXPIREDATE
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = ucLicenseStatus.AttachToTable(
                        *this,
                        LICENSE_COLUMN_LICENSESTATUS
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwNumLicenses.AttachToTable(
                        *this,
                        LICENSE_COLUMN_NUMLICENSES
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwSystemBiosChkSum.AttachToTable(
                        *this,
                        LICENSE_COLUMN_SYSTEMBIOS
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwVideoBiosChkSum.AttachToTable(
                        *this,
                        LICENSE_COLUMN_VIDEOBIOS
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwFloppyBiosChkSum.AttachToTable(
                        *this,
                        LICENSE_COLUMN_FLOPPYBIOS
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwHardDiskSize.AttachToTable(
                        *this,
                        LICENSE_COLUMN_HARDDISKSIZE
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwRamSize.AttachToTable(
                        *this,
                        LICENSE_COLUMN_RAMSIZE
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dbLowerBound.AttachToTable(
                        *this,
                        LICENSE_COLUMN_MATCHHWID
                    );
cleanup:

    return IsSuccess();
}

//------------------------------------------------------------
inline CLASS_PRIVATE BOOL
LicensedTable::ProcessSingleColumn(
    BOOL bFetch,
    TLSColumnBase& column,
    DWORD offset,
    PVOID pbData,
    DWORD cbData,
    PDWORD pcbDataReturn,
    LPCTSTR szColumnName
    )
/*
*/
{
    if(bFetch) 
    {
        m_JetErr = column.FetchColumnValue(
                                    pbData, 
                                    cbData, 
                                    offset, 
                                    pcbDataReturn
                                );
    }
    else
    {
        m_JetErr = column.InsertColumnValue(
                                    pbData, 
                                    cbData, 
                                    offset
                                );
    }

    REPORTPROCESSFAILED(
            bFetch,
            GetTableName(),
            szColumnName,
            m_JetErr
        );
    return IsSuccess();
}

//------------------------------------------------------------
    
CLASS_PRIVATE BOOL
LicensedTable::ProcessRecord(
    LICENSEDCLIENT* licensed,
    BOOL bFetch,
    DWORD dwParam,
    BOOL bUpdate
    )
/*
*/
{
    DWORD dwSize;

    if(bFetch == FALSE)
    {
        BeginUpdate(bUpdate);

        // any update will require update on lastmodifytime column
        if(!(dwParam & LICENSE_PROCESS_LASTMODIFYTIME))
        {
            JB_ASSERT(FALSE);
            dwParam |= LICENSE_PROCESS_LASTMODIFYTIME;
        }
    }
    else
    {
        SetLastJetError(JET_errSuccess);
    }

    if(IsSuccess() == FALSE)
        goto cleanup;            

    if(dwParam & LICENSE_PROCESS_KEYPACKLICENSEID)
    {
        ProcessSingleColumn(
                    bFetch, 
                    dwKeyPackLicenseId, 
                    0,
                    &(licensed->dwKeyPackLicenseId),
                    sizeof(licensed->dwKeyPackLicenseId),
                    &dwSize,
                    LICENSE_COLUMN_LICENSEID
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;


    if(dwParam & LICENSE_PROCESS_LASTMODIFYTIME)
    {
        ProcessSingleColumn(
                    bFetch, 
                    ftLastModifyTime, 
                    0,
                    &(licensed->ftLastModifyTime),
                    sizeof(licensed->ftLastModifyTime),
                    &dwSize,
                    LICENSE_COLUMN_LASTMODIFYTIME
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;


    if(dwParam & LICENSE_PROCESS_LICENSEID)
    {
        // primary index, can't change
        if(bUpdate == FALSE)
        {
            ProcessSingleColumn(
                    bFetch, 
                    dwLicenseId, 
                    0,
                    &(licensed->dwLicenseId),
                    sizeof(licensed->dwLicenseId),
                    &dwSize,
                    LICENSE_COLUMN_ID_COLUMN
                );
        }
    }

    if(IsSuccess() == FALSE)
        goto cleanup;            

    if(dwParam & LICENSE_PROCESS_KEYPACKID)
    {
        ProcessSingleColumn(
                    bFetch, 
                    dwKeyPackId, 
                    0,
                    &(licensed->dwKeyPackId),
                    sizeof(licensed->dwKeyPackId),
                    &dwSize,
                    LICENSE_COLUMN_KEYPACKID
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;

    if(dwParam & LICENSE_PROCESS_MACHINENAME)
    {
        ProcessSingleColumn(
                    bFetch, 
                    szMachineName, 
                    0,
                    licensed->szMachineName,
                    sizeof(licensed->szMachineName),
                    &dwSize,
                    LICENSE_COLUMN_MACHINENAME
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;

    if(dwParam & LICENSE_PROCESS_USERNAME)
    {
        ProcessSingleColumn(
                    bFetch, 
                    szUserName, 
                    0,
                    licensed->szUserName,
                    sizeof(licensed->szUserName),
                    &dwSize,
                    LICENSE_COLUMN_USERNAME
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;


    if(dwParam & LICENSE_PROCESS_ISSUEDATE)
    {
        ProcessSingleColumn(
                    bFetch, 
                    ftIssueDate, 
                    0,
                    &(licensed->ftIssueDate),
                    sizeof(licensed->ftIssueDate),
                    &dwSize,
                    LICENSE_COLUMN_ISSUEDATE
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;

    if(dwParam & LICENSE_PROCESS_EXPIREDATE)
    {
        ProcessSingleColumn(
                    bFetch, 
                    ftExpireDate, 
                    0,
                    &(licensed->ftExpireDate),
                    sizeof(licensed->ftExpireDate),
                    &dwSize,
                    LICENSE_COLUMN_EXPIREDATE
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;

    if(dwParam & LICENSE_PROCESS_NUMLICENSES)
    {
        ProcessSingleColumn(
                    bFetch, 
                    dwNumLicenses, 
                    0,
                    &(licensed->dwNumLicenses),
                    sizeof(licensed->dwNumLicenses),
                    &dwSize,
                    LICENSE_COLUMN_NUMLICENSES
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;

    if(dwParam & LICENSE_PROCESS_LICENSESTATUS)
    {
        ProcessSingleColumn(
                    bFetch, 
                    ucLicenseStatus, 
                    0,
                    &(licensed->ucLicenseStatus),
                    sizeof(licensed->ucLicenseStatus),
                    &dwSize,
                    LICENSE_COLUMN_LICENSESTATUS
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;


    if(dwParam & LICENSE_PROCESS_SYSTEMBIOS)
    {
        ProcessSingleColumn(
                    bFetch, 
                    dwSystemBiosChkSum, 
                    0,
                    &(licensed->dwSystemBiosChkSum),
                    sizeof(licensed->dwSystemBiosChkSum),
                    &dwSize,
                    LICENSE_COLUMN_SYSTEMBIOS
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;

    if(dwParam & LICENSE_PROCESS_VIDEOBIOS)
    {
        ProcessSingleColumn(
                    bFetch, 
                    dwVideoBiosChkSum, 
                    0,
                    &(licensed->dwVideoBiosChkSum),
                    sizeof(licensed->dwVideoBiosChkSum),
                    &dwSize,
                    LICENSE_COLUMN_VIDEOBIOS
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;

    if(dwParam & LICENSE_PROCESS_FLOPPYBIOS)
    {
        ProcessSingleColumn(
                    bFetch, 
                    dwFloppyBiosChkSum, 
                    0,
                    &(licensed->dwFloppyBiosChkSum),
                    sizeof(licensed->dwFloppyBiosChkSum),
                    &dwSize,
                    LICENSE_COLUMN_FLOPPYBIOS
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;

    if(dwParam & LICENSE_PROCESS_HARDDISKSIZE)
    {
        ProcessSingleColumn(
                    bFetch, 
                    dwHardDiskSize, 
                    0,
                    &(licensed->dwHardDiskSize),
                    sizeof(licensed->dwHardDiskSize),
                    &dwSize,
                    LICENSE_COLUMN_HARDDISKSIZE
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;

    if(dwParam & LICENSE_PROCESS_RAMSIZE)
    {
        ProcessSingleColumn(
                    bFetch, 
                    dwRamSize, 
                    0,
                    &(licensed->dwRamSize),
                    sizeof(licensed->dwRamSize),
                    &dwSize,
                    LICENSE_COLUMN_RAMSIZE
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;

    if(dwParam & LICENSE_PROCESS_ENTRYSTATUS)
    {
        ProcessSingleColumn(
                    bFetch, 
                    ucEntryStatus, 
                    0,
                    &(licensed->ucEntryStatus),
                    sizeof(licensed->ucEntryStatus),
                    &dwSize,
                    LICENSE_COLUMN_ENTRYSTATUS
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;

    if(dwParam & LICENSE_PROCESS_MATCHHWID)
    {
        ProcessSingleColumn(
                    bFetch, 
                    dbLowerBound, 
                    0,
                    &(licensed->dbLowerBound),
                    sizeof(licensed->dbLowerBound),
                    &dwSize,
                    LICENSE_COLUMN_MATCHHWID
                );
    }

cleanup:

    // 
    // For inserting/updating record
    if(bFetch == FALSE)
    {
        JET_ERR jetErr;
        jetErr = GetLastJetError();

        EndUpdate(IsSuccess() == FALSE);

        if(jetErr != JET_errSuccess  && IsSuccess() == FALSE)
            SetLastJetError(jetErr);
    }

    return IsSuccess();
}


//-------------------------------------------------------
JBKeyBase*
LicensedTable::EnumerationIndex( 
    BOOL bMatchAll,
    DWORD dwParam,
    LICENSEDCLIENT* pLicensed,
    BOOL* bCompareKey
    )
/*
*/
{
    JBKeyBase* index=NULL;

    *bCompareKey = bMatchAll;

    if(dwParam == LICENSE_COLUMN_SEARCH_HWID)
    {
        if(bMatchAll)
        {
            index = new TLSLicensedIndexHwid(pLicensed); 
        }
        else
        {
            index = new TLSLicensedIndexMatchHwid(pLicensed);
        }
    }
    else if(dwParam & LICENSE_PROCESS_KEYPACKID)
    {
        index = new TLSLicensedIndexKeyPackId(pLicensed);
    }
    else if(dwParam & LICENSE_PROCESS_MACHINENAME)
    {
        index = new TLSLicensedIndexMachineName(pLicensed);
    }
    else if(dwParam & LICENSE_PROCESS_USERNAME)
    {
        index = new TLSLicensedIndexUserName(pLicensed);
    }
    else if(dwParam & LICENSE_PROCESS_LASTMODIFYTIME)
    {
        index = new TLSLicensedIndexLastModifyTime(pLicensed);
    }
    else if(dwParam & LICENSE_PROCESS_EXPIREDATE)
    {
        index = new TLSLicensedIndexExpireDate(pLicensed);
    }
    else
    {
        // use default primary index for iteration, compare key
        // is depends on whether primary index column is in the 
        // field.
        index = new TLSLicensedIndexLicenseId(pLicensed);

        *bCompareKey = (bMatchAll && (dwParam & LICENSE_PROCESS_LICENSEID));
    }   

    return index;
}

//-------------------------------------------------------
BOOL
LicensedTable::EqualValue(
    LICENSEDCLIENT& s1,
    LICENSEDCLIENT& s2,
    BOOL bMatchAll,
    DWORD dwParam
    )  
/*
*/
{
    BOOL bRetCode = TRUE;

    if(dwParam & LICENSE_PROCESS_ENTRYSTATUS)
    {
        bRetCode = (s1.ucEntryStatus == s2.ucEntryStatus);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSE_PROCESS_KEYPACKLICENSEID)
    {
        bRetCode = (s1.dwKeyPackLicenseId == s2.dwKeyPackLicenseId);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSE_PROCESS_LASTMODIFYTIME)
    {
        bRetCode = (CompareFileTime(&s1.ftLastModifyTime, &s2.ftLastModifyTime) == 0);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSE_PROCESS_LICENSEID)
    {
        bRetCode = (s1.dwLicenseId == s2.dwLicenseId);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }


    if(dwParam & LICENSE_PROCESS_KEYPACKID)
    {
        bRetCode = (s1.dwKeyPackId == s2.dwKeyPackId);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }


    if(dwParam & LICENSE_PROCESS_MACHINENAME)
    {
        bRetCode = (_tcscmp(s1.szMachineName, s2.szMachineName) == 0);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }


    if(dwParam & LICENSE_PROCESS_USERNAME)
    {
        bRetCode = (_tcscmp(s1.szUserName, s2.szUserName) == 0);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }


    if(dwParam & LICENSE_PROCESS_ISSUEDATE)
    {
        bRetCode = (s1.ftIssueDate == s2.ftIssueDate);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }


    if(dwParam & LICENSE_PROCESS_EXPIREDATE)
    {
        bRetCode = (s1.ftExpireDate == s2.ftExpireDate);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }


    if(dwParam & LICENSE_PROCESS_NUMLICENSES)
    {
        bRetCode = (s1.dwNumLicenses == s2.dwNumLicenses);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }


    if(dwParam & LICENSE_PROCESS_LICENSESTATUS)
    {
        bRetCode = (s1.ucLicenseStatus == s2.ucLicenseStatus);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }


    if(dwParam & LICENSE_PROCESS_SYSTEMBIOS)
    {
        bRetCode = (s1.dwSystemBiosChkSum == s2.dwSystemBiosChkSum);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSE_PROCESS_VIDEOBIOS)
    {
        bRetCode = (s1.dwVideoBiosChkSum == s2.dwVideoBiosChkSum);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }


    if(dwParam & LICENSE_PROCESS_FLOPPYBIOS)
    {
        bRetCode = (s1.dwFloppyBiosChkSum == s2.dwFloppyBiosChkSum);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }


    if(dwParam & LICENSE_PROCESS_HARDDISKSIZE)
    {
        bRetCode = (s1.dwHardDiskSize == s2.dwHardDiskSize);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSE_PROCESS_RAMSIZE)
    {
        bRetCode = (s1.dwRamSize == s2.dwRamSize);
    }

    if(dwParam & LICENSE_PROCESS_MATCHHWID)
    {
        bRetCode = (s1.dbLowerBound == s2.dbLowerBound);
    }

cleanup:

    return bRetCode;
}

//--------------------------------------------------------
BOOL
LicensedTable::UpgradeTable(
        IN DWORD dwOldVersion,
        IN DWORD dwNewVersion
        )
/*++
 
++*/
{
    int nExpDate = g_NumTableIndex-1;
    unsigned long keylength;
    BOOL fRet = TRUE;

    if(dwOldVersion > dwNewVersion)
    {
        // We don't know how to handle later versions
        JB_ASSERT(FALSE);
        return FALSE;
    }

    if(OpenTable(TRUE, JET_bitTableUpdatable) == FALSE)
        return FALSE;

    //
    // check if expiration date index exists
    //

    if (DoesIndexExist(g_TableIndex[nExpDate].pszIndexName))
    {
        goto cleanup;
    }

    //
    // Insert new index for expiration date
    //

    if (g_TableIndex[nExpDate].cbKey == -1)
    {
        // calculate index key length
        keylength = 2;
        
        while(g_TableIndex[nExpDate].pszIndexKey[keylength-1] != _TEXT('\0') ||
              (g_TableIndex[nExpDate].pszIndexKey[keylength-2] != _TEXT('\0')))
        {
            keylength++;
        }

        if(keylength >= TLS_JETBLUE_MAX_INDEXKEY_LENGTH)
        {
            fRet = FALSE;
            goto cleanup;
        }
    }
    else
    {
        keylength = g_TableIndex[nExpDate].cbKey;
    }

    AddJetIndex(g_TableIndex[nExpDate].pszIndexName,
                g_TableIndex[nExpDate].pszIndexKey,
                keylength,
                g_TableIndex[nExpDate].jbGrbit,
                g_TableIndex[nExpDate].ulDensity
                );

cleanup:
    return CloseTable() && fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tlsdb\vertab.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       vertab.cpp 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include "version.h"

LPCTSTR __VersionIndexOnVersionId::pszIndexName = VERSION_ID_INDEXNAME;
LPCTSTR __VersionIndexOnVersionId::pszIndexKey = VERSION_ID_INDEXNAME_INDEXKEY;

//----------------------------------------------------
CCriticalSection VersionTable::g_TableLock;
LPCTSTR VersionTable::pszTableName = VERSION_TABLE_NAME;


//----------------------------------------------------
TLSJBIndex
VersionTable::g_TableIndex[] =
{
    {
        VERSION_ID_INDEXNAME,
        VERSION_ID_INDEXNAME_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    }
};

int 
VersionTable::g_NumTableIndex = sizeof(VersionTable::g_TableIndex) / sizeof(VersionTable::g_TableIndex[0]);

TLSJBColumn
VersionTable::g_Columns[] =
{
    {
        VERSION_TABLE_VERSION,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    {
        VERSION_TABLE_DOMAINID,
        JET_coltypLongBinary,
        TLSTABLE_MAX_BINARY_LENGTH,
        0,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    {
        VERSION_TABLE_INSTALLID,
        JB_COLTYPE_TEXT,
        (MAX_JETBLUE_TEXT_LENGTH + 1)*sizeof(TCHAR),
        0,
        JBSTRING_NULL,
        _tcslen(JBSTRING_NULL),
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    }
};

int
VersionTable::g_NumColumns=sizeof(VersionTable::g_Columns) / sizeof(VersionTable::g_Columns[0]);

//-------------------------------------------------------------
JBKeyBase* 
VersionTable::EnumerationIndex( 
    BOOL bMatchAll,
    DWORD dwSearchParam,
    TLSVersion* pVersion,
    BOOL* bCompareKey
    )
/*
*/
{
    // not expecting more than one row.
    *bCompareKey = (bMatchAll && (dwSearchParam & VERSION_TABLE_PROCESS_VERSION));
    
    return new TLSVersionIndexVersionId(pVersion);
}    

//------------------------------------------------------------
BOOL
VersionTable::EqualValue(
    TLSVersion& s1,
    TLSVersion& s2,
    BOOL bMatchAll,
    DWORD dwParam
    )
/*
*/
{
    BOOL bRetCode = TRUE;


    if(dwParam & VERSION_TABLE_PROCESS_VERSION)
    {
        bRetCode = (s1.dwVersion == s2.dwVersion);

        if(bRetCode != bMatchAll)
            goto cleanup;
    }

    if(dwParam & VERSION_TABLE_PROCESS_INSTALLID)
    {
        bRetCode = (_tcscmp(s1.szInstallId, s2.szInstallId) == 0);
        
        if(bRetCode != bMatchAll)
            goto cleanup;
    }

    //if(dwParam & VERSION_TABLE_PROCESS_DOMAINID)
    //{
    //    bRetCode = EqualSid(s1.pbDomainSid, s2.pbDomainSid);
    //}

cleanup:
    return bRetCode;
}

//----------------------------------------------------
BOOL
VersionTable::ResolveToTableColumn()
/*
*/
{
    m_JetErr = dwVersion.AttachToTable(
                            *this,
                            VERSION_TABLE_VERSION
                        );

    if(IsSuccess() == FALSE)
    {
        DebugOutput(
                _TEXT("Can't find column %s in table %s\n"),
                VERSION_TABLE_VERSION,
                GetTableName()
            );

        return FALSE;
    }
    
    m_JetErr = szInstallId.AttachToTable(
                            *this,
                            VERSION_TABLE_INSTALLID
                        );

    if(IsSuccess() == FALSE)
    {
        DebugOutput(
                _TEXT("Can't find column %s in table %s\n"),
                VERSION_TABLE_INSTALLID,
                GetTableName()
            );

        return FALSE;
    }

    m_JetErr = pbDomainSid.AttachToTable(
                            *this,
                            VERSION_TABLE_DOMAINID
                        );


    if(IsSuccess() == FALSE)
    {
        DebugOutput(
                _TEXT("Can't find column %s in table %s\n"),
                VERSION_TABLE_DOMAINID,
                GetTableName()
            );
    }


    return IsSuccess();
}

//----------------------------------------------------
BOOL
VersionTable::FetchRecord(
    TLSVersion& v,
    DWORD dwParam
    )
/*
*/
{    
    if(dwParam & VERSION_TABLE_PROCESS_VERSION)
    {
        m_JetErr = dwVersion.FetchColumnValue(
                                &(v.dwVersion),
                                sizeof(v.dwVersion),
                                0,
                                NULL
                            );
        REPORT_IF_FETCH_FAILED(GetTableName(),
                     VERSION_TABLE_VERSION,
                     m_JetErr);

        if(IsSuccess() == FALSE)
            goto cleanup;
    }

    if(dwParam & VERSION_TABLE_PROCESS_INSTALLID)
    {
        m_JetErr = szInstallId.FetchColumnValue(
                                v.szInstallId,
                                sizeof(v.szInstallId),
                                0,
                                NULL
                            );
        REPORT_IF_FETCH_FAILED(
                GetTableName(),
                VERSION_TABLE_INSTALLID,
                m_JetErr
            );

        if(IsSuccess() == FALSE)
            goto cleanup;
    }

#if 0
    if(dwParam & VERSION_TABLE_PROCESS_DOMAINID)
    {
        DWORD size;

        m_JetErr = pbDomainSid.FetchColumnValue(
                                NULL,
                                0,
                                0,
                                &size
                            );
        
        if(size > v.cbDomainSid || v.pbDomainSid == NULL)
        {
            FreeMemory(v.pbDomainSid);

            v.pbDomainSid = (PBYTE)AllocateMemory(v.cbDomainSid = size);
            if(v.pbDomainSid == NULL)
            {
                SetLastJetError(JET_errOutOfMemory);
                goto cleanup;
            }
        }

        m_JetErr = pbDomainSid.FetchColumnValue(
                                v.pbDomainSid,
                                v.cbDomainSid,
                                0,
                                &v.cbDomainSid
                            );

        REPORT_IF_FETCH_FAILED(
                GetTableName(),
                VERSION_TABLE_DOMAINID,
                m_JetErr
            );
    }
#endif

cleanup:
    return IsSuccess();
}

//----------------------------------------------------
BOOL
VersionTable::InsertUpdateRecord(
    TLSVersion* v,
    DWORD dwParam
    )
/*
*/
{
    if(dwParam & VERSION_TABLE_PROCESS_VERSION)
    {
        m_JetErr = dwVersion.InsertColumnValue(
                                    &(v->dwVersion),
                                    sizeof(v->dwVersion),
                                    0
                                );
        REPORT_IF_INSERT_FAILED(GetTableName(),
                     VERSION_TABLE_VERSION,
                     m_JetErr);

        if(IsSuccess() == FALSE)
            goto cleanup;
    }

    if(dwParam & VERSION_TABLE_PROCESS_INSTALLID)
    {
        m_JetErr = szInstallId.InsertColumnValue(
                                    v->szInstallId,
                                    _tcslen(v->szInstallId) * sizeof(TCHAR),
                                    0
                                );
        REPORT_IF_INSERT_FAILED(
                GetTableName(),
                VERSION_TABLE_INSTALLID,
                m_JetErr
            );

        if(IsSuccess() == FALSE)
            goto cleanup;
    }

    #if 0
    // no more domain SID
    if(dwParam & VERSION_TABLE_PROCESS_DOMAINID)
    {
        m_JetErr = pbDomainSid.InsertColumnValue(
                                    v->pbDomainSid,
                                    v->cbDomainSid,
                                    0
                                );

        REPORT_IF_INSERT_FAILED(
                GetTableName(),
                VERSION_TABLE_DOMAINID,
                m_JetErr
            );
    }
    #endif


cleanup:
    return IsSuccess();
}
    
//----------------------------------------------------
BOOL
VersionTable::InsertRecord(
    TLSVersion& v,
    DWORD dwParam
    )
/*
*/
{
    if(BeginUpdate(FALSE) == FALSE)
        return FALSE;

    InsertUpdateRecord(&v, dwParam);
    EndUpdate(IsSuccess() == FALSE);
    return IsSuccess();
}

//----------------------------------------------------
BOOL
VersionTable::UpdateRecord(
    TLSVersion& v,
    DWORD dwParam
    )
/*
*/
{
    if(BeginUpdate(TRUE) == FALSE)
        return FALSE;

    InsertUpdateRecord(&v, dwParam);

    EndUpdate(IsSuccess() == FALSE);
    return IsSuccess();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tlsdb\workitem.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        workitem.cpp
//
// Contents:    workitem Table
//
// History:     
//              
//---------------------------------------------------------------------------
#include "workitem.h"


//----------------------------------------------------
CCriticalSection WorkItemTable::g_TableLock;

//----------------------------------------------------
TLSJBIndex
WorkItemTable::g_TableIndex[] =
{
    {
        WORKITEM_INDEX_JOBTIME_INDEXNAME,
        WORKITEM_INDEX_JOBTIME_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    }
};

int 
WorkItemTable::g_NumTableIndex = sizeof(WorkItemTable::g_TableIndex) / sizeof(WorkItemTable::g_TableIndex[0]);

TLSJBColumn
WorkItemTable::g_Columns[] =
{
    {
        WORKITEM_COLUMN_JOBTIME,
        JET_coltypLong,
        sizeof(DWORD),
        JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    {
        WORKITEM_COLUMN_JOBRESTARTTIME,
        JET_coltypLong,
        sizeof(DWORD),
        JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    {
        WORKITEM_COLUMN_JOBTYPE,
        JET_coltypLong,
        0,
        JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    {
        WORKITEM_COLUMN_DATA,
        JET_coltypLongBinary,
        WORKITEM_MAX_DATA_SIZE, // 0x8FFFFFFF,     // no limit on data size.
        0,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    }
};

int
WorkItemTable::g_NumColumns=sizeof(WorkItemTable::g_Columns) / sizeof(WorkItemTable::g_Columns[0]);

//-------------------------------------------------------------
JBKeyBase* 
WorkItemTable::EnumerationIndex( 
    BOOL bMatchAll,
    DWORD dwSearchParam,
    WORKITEMRECORD* pRecord,
    BOOL* bCompareKey
    )
/*
*/
{
    *bCompareKey = bMatchAll;
    return new TLSWorkItemIdxModifyTime(pRecord);
}    

//------------------------------------------------------------
BOOL
WorkItemTable::EqualValue(
    WORKITEMRECORD& s1,
    WORKITEMRECORD& s2,
    BOOL bMatchAll,
    DWORD dwParam
    )
/*
*/
{
    BOOL bRetCode = TRUE;


    if(dwParam & WORKITEM_PROCESS_JOBTIME)
    {
        bRetCode = (s1.dwScheduledTime == s2.dwScheduledTime);
        if(bRetCode != bMatchAll)
            goto cleanup;
    }

    if(dwParam & WORKITEM_PROCESS_JOBRESTARTTIME)
    {
        bRetCode = (s1.dwRestartTime == s2.dwRestartTime);
        if(bRetCode != bMatchAll)
            goto cleanup;
    }

    if(dwParam & WORKITEM_PROCESS_JOBTYPE)
    {
        bRetCode = (s1.dwJobType == s2.dwJobType);
        if(bRetCode != bMatchAll)
            goto cleanup;
    }

    //
    // process data must accompany by process data size.
    //
    if(dwParam & WORKITEM_PROCESS_DATA)
    {
        bRetCode = (s1.cbData == s2.cbData);
        if(bRetCode != bMatchAll)
            goto cleanup;

        bRetCode = (memcmp(s1.pbData, s2.pbData, s1.cbData) == 0);
    }

cleanup:
    return bRetCode;
}

//----------------------------------------------------
BOOL
WorkItemTable::ResolveToTableColumn()
/*
*/
{
    m_JetErr = dwScheduledTime.AttachToTable(
                            *this,
                            WORKITEM_COLUMN_JOBTIME
                        );

    if(IsSuccess() == FALSE)
    {
        DebugOutput(
                _TEXT("Can't find column %s in table %s\n"),
                WORKITEM_COLUMN_JOBTIME,
                GetTableName()
            );

        goto cleanup;
    }

    m_JetErr = dwRestartTime.AttachToTable(
                            *this,
                            WORKITEM_COLUMN_JOBRESTARTTIME
                        );

    if(IsSuccess() == FALSE)
    {
        DebugOutput(
                _TEXT("Can't find column %s in table %s\n"),
                WORKITEM_COLUMN_JOBRESTARTTIME,
                GetTableName()
            );

        goto cleanup;
    }
    
    m_JetErr = dwJobType.AttachToTable(
                            *this,
                            WORKITEM_COLUMN_JOBTYPE
                        );

    if(IsSuccess() == FALSE)
    {
        DebugOutput(
                _TEXT("Can't find column %s in table %s\n"),
                WORKITEM_COLUMN_JOBTYPE,
                GetTableName()
            );

        goto cleanup;
    }

    m_JetErr = pbData.AttachToTable(
                            *this,
                            WORKITEM_COLUMN_DATA
                        );

    if(IsSuccess() == FALSE)
    {
        DebugOutput(
                _TEXT("Can't find column %s in table %s\n"),
                WORKITEM_COLUMN_DATA,
                GetTableName()
            );
    }

cleanup:
    return IsSuccess();
}

//----------------------------------------------------
CLASS_PRIVATE BOOL
WorkItemTable::ProcessSingleColumn(
    IN BOOL bFetch,
    IN TLSColumnBase& column,
    IN DWORD offset,
    IN PVOID pbData,
    IN DWORD cbData,
    IN PDWORD pcbDataReturn,
    IN LPCTSTR szColumnName
    )
/*

Abstract:

    Fetch/Insert/Update a particular column.

Parameter:

    bFetch - TRUE if fetch, FALSE if update/insert.
    column - Intended column for operation, reference pointer to TLSColumn
    szColumnName - name of the column, for debugging print purpose only

Returns:

    TRUE if successful, FALSE otherwise.
*/
{
    if(bFetch) 
    {
        m_JetErr = column.FetchColumnValue(
                                    pbData, 
                                    cbData, 
                                    offset, 
                                    pcbDataReturn
                                );
    }
    else
    {
        m_JetErr = column.InsertColumnValue(
                                    pbData, 
                                    cbData, 
                                    offset
                                );
    }

    REPORTPROCESSFAILED(
            bFetch,
            GetTableName(),
            szColumnName,
            m_JetErr
        );
    return IsSuccess();
}

//---------------------------------------------------------
CLASS_PRIVATE BOOL
WorkItemTable::ProcessRecord(
    WORKITEMRECORD* pRecord,
    BOOL bFetch,
    DWORD dwParam,
    BOOL bUpdate
    )
/*
*/
{ 
    DWORD dwSize;

    if(bFetch == FALSE)
    {
        BeginUpdate(bUpdate);

        if(!(dwParam & WORKITEM_PROCESS_JOBTIME))
        {
            JB_ASSERT(FALSE);
            dwParam |= WORKITEM_PROCESS_JOBTIME;
        }
    }
    else
    {
        SetLastJetError(JET_errSuccess);
    }

    if(IsSuccess() == FALSE)
        goto cleanup;            

    if(dwParam & WORKITEM_PROCESS_JOBTIME)
    {
        ProcessSingleColumn(
                    bFetch,
                    dwScheduledTime,
                    0,
                    &(pRecord->dwScheduledTime),
                    sizeof(pRecord->dwScheduledTime),
                    &dwSize,
                    WORKITEM_COLUMN_JOBTIME
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;            

    if(dwParam & WORKITEM_PROCESS_JOBRESTARTTIME)
    {
        ProcessSingleColumn(
                    bFetch,
                    dwRestartTime,
                    0,
                    &(pRecord->dwRestartTime),
                    sizeof(pRecord->dwRestartTime),
                    &dwSize,
                    WORKITEM_COLUMN_JOBRESTARTTIME
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;            

    
    if(dwParam & WORKITEM_PROCESS_JOBTYPE)
    {
        ProcessSingleColumn(
                    bFetch,
                    dwJobType,
                    0,
                    &(pRecord->dwJobType),
                    sizeof(pRecord->dwJobType),
                    &dwSize,
                    WORKITEM_COLUMN_JOBTYPE
                );

    }

    if(IsSuccess() == FALSE)
        goto cleanup;            

    if(dwParam & WORKITEM_PROCESS_DATA)
    {
        if(bFetch == TRUE)
        {
            m_JetErr = pbData.FetchColumnValue(
                                        NULL,
                                        0,
                                        0,
                                        &dwSize  // &pRecord->cbData
                                    );

            if( pRecord->pbData == NULL || pRecord->cbData < dwSize )
            {
                if( pRecord->pbData != NULL )
                {
                    FreeMemory(pRecord->pbData);
                    pRecord->pbData = NULL;
                }
                   
                pRecord->pbData = (PBYTE)AllocateMemory(dwSize);
                if(pRecord->pbData == NULL)
                {
                    pRecord->cbData = 0;
                    SetLastJetError(JET_errOutOfMemory);
                    goto cleanup;
                }

                pRecord->cbData = dwSize;
            }

            //
            // actual memory allocated might be bigger then pRecord->cbData
            //
            m_JetErr = pbData.FetchColumnValue(
                                        pRecord->pbData,
                                        pRecord->cbData,
                                        0,
                                        &pRecord->cbData
                                    );
        }
        else
        {
            ProcessSingleColumn(
                        bFetch,
                        pbData,
                        0,
                        pRecord->pbData,
                        pRecord->cbData,
                        &dwSize,
                        WORKITEM_COLUMN_DATA
                    );
        }
    }

cleanup:
    // 
    // For inserting/updating record
    if(bFetch == FALSE)
    {
        JET_ERR jetErr;
        jetErr = GetLastJetError();

        EndUpdate(IsSuccess() == FALSE);

        if(jetErr != JET_errSuccess  && IsSuccess() == FALSE)
            SetLastJetError(jetErr);
    }

    return IsSuccess();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tlsdb\workitem.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        workitem.h
//
// Contents:    backupsource Table
//
// History:     
//              
//---------------------------------------------------------------------------
#ifndef __WORKITEM_H__
#define __WORKITEM_H__
#include "tlsdb.h"

//
//
#define WORKITEM_PROCESS_JOBTIME                0x00000001
#define WORKITEM_PROCESS_JOBRESTARTTIME         (WORKITEM_PROCESS_JOBTIME << 1)
#define WORKITEM_PROCESS_JOBTYPE                (WORKITEM_PROCESS_JOBTIME << 2)
#define WORKITEM_PROCESS_DATA                   (WORKITEM_PROCESS_JOBTIME << 3)

//
// Table structure
//
#define WORKITEM_TABLE_NAME                     _TEXT("WorkStorage")
#define WORKITEM_COLUMN_JOBTIME                 _TEXT("ScheduledTime")
#define WORKITEM_COLUMN_JOBRESTARTTIME          _TEXT("RestartTime")
#define WORKITEM_COLUMN_JOBTYPE                 _TEXT("JobType")
#define WORKITEM_COLUMN_DATA                    _TEXT("Data")

#define WORKITEM_MAX_DATA_SIZE                  16 * 1024  // max of 32 K 

typedef struct __WorkItemRecord : public TLSReplWorkItem 
{
    __WorkItemRecord&
    operator=(const __WorkItemRecord& v)
    {
        DWORD bSuccess;

        PBYTE pbOldData=pbData;
        DWORD cbOldData=cbData;

        if(this == &v)
            return *this;

        *(TLSReplWorkItem *)this = *(TLSReplWorkItem *)&v;
        
        pbData = pbOldData;
        cbData = cbOldData;

        bSuccess = TLSDBCopyBinaryData(
                        v.pbData,
                        v.cbData,
                        &pbData,
                        &cbData
                    );

        JB_ASSERT(bSuccess == TRUE);
        return *this;
    }        

    __WorkItemRecord&
    operator=(const TLSReplWorkItem& v)
    {
        DWORD bSuccess;

        PBYTE pbOldData=pbData;
        DWORD cbOldData=cbData;

        *(TLSReplWorkItem *)this = *(TLSReplWorkItem *)&v;
        
        pbData = pbOldData;
        cbData = cbOldData;

        bSuccess = TLSDBCopyBinaryData(
                        v.pbData,
                        v.cbData,
                        &pbData,
                        &cbData
                    );

        JB_ASSERT(bSuccess == TRUE);
        return *this;
    }        

    __WorkItemRecord() 
    {
        pbData = NULL;
        cbData = 0;
    }

    ~__WorkItemRecord() 
    {
        if(pbData)
        {
            FreeMemory(pbData);
        }
    }
} WORKITEMRECORD;

typedef WORKITEMRECORD* LPWORKITEMRECORD;
typedef WORKITEMRECORD* PWORKITEMRECORD;


/////////////////////////////////////////////////////////
//
// Index structure
//
/////////////////////////////////////////////////////////

// 
//
#define WORKITEM_INDEX_JOBTIME_INDEXNAME \
    WORKITEM_TABLE_NAME SEPERATOR WORKITEM_COLUMN_JOBTIME SEPERATOR INDEXNAME

//
// Primary Index on KeyPack ID "+KeyPackId\0"
//
#define WORKITEM_INDEX_JOBTIME_INDEXKEY \
    INDEX_SORT_ASCENDING WORKITEM_COLUMN_JOBTIME INDEX_END_COLNAME

typedef struct __WorkItemIdxOnJobTime : public JBKeyBase {
    DWORD dwScheduledTime;

    //--------------------------------------------------------
    __WorkItemIdxOnJobTime(
        const WORKITEMRECORD& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //--------------------------------------------------------
    __WorkItemIdxOnJobTime(
        const WORKITEMRECORD* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //--------------------------------------------------------
    __WorkItemIdxOnJobTime&
    operator=(const WORKITEMRECORD& v) 
    {
        dwScheduledTime = v.dwScheduledTime;
        SetEmptyValue(FALSE);
        return *this;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexName() 
    {
        static LPTSTR pszIndexName=WORKITEM_INDEX_JOBTIME_INDEXNAME;
        return pszIndexName;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexKey() 
    {
        static LPTSTR pszIndexKey=WORKITEM_INDEX_JOBTIME_INDEXKEY;
        return pszIndexKey;
    }

    //--------------------------------------------------------
    DWORD
    GetNumKeyComponents() 
    { 
        return 1; 
    }

    //--------------------------------------------------------
    BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*++
    ++*/
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &dwScheduledTime;
        *cbData = sizeof(dwScheduledTime);
        *grbit = JET_bitNewKey;
        return TRUE;
    }
} TLSWorkItemIdxModifyTime;

// -----------------------------------------------------------
//
//  LicensedPackStatus Table
//
// -----------------------------------------------------------
class WorkItemTable : public TLSTable<WORKITEMRECORD>  {
private:

    BOOL
    ProcessSingleColumn(
        BOOL bFetch,
        TLSColumnBase& column,
        DWORD offset,
        PVOID pbData,
        DWORD cbData,
        PDWORD pcbDataReturn,
        LPCTSTR szColumnName
    );

    BOOL
    ProcessRecord(
        WORKITEMRECORD* v,
        BOOL bFetch,        // TRUE - fetch, FALSE insert
        DWORD dwParam,
        BOOL bUpdate
    );    

public:
    TLSColumnDword      dwScheduledTime;
    TLSColumnDword      dwRestartTime;
    TLSColumnDword      dwJobType;
    TLSColumnBinary     pbData;

    //-----------------------------------------------------
    virtual LPCTSTR
    GetTableName() 
    {
        static LPTSTR pszTableName=WORKITEM_TABLE_NAME;
        return pszTableName;
    }
   

    //-----------------------------------------------------
    WorkItemTable(
        JBDatabase& database
        ) : 
        TLSTable<WORKITEMRECORD>(database)
    /*
    */
    {
    }

    //-----------------------------------------------------
    virtual BOOL
    ResolveToTableColumn();

    //-----------------------------------------------------
    virtual BOOL
    FetchRecord(
        WORKITEMRECORD& v,
        DWORD dwParam=PROCESS_ALL_COLUMNS
        )
    /*
    */
    {
        if(IsValid() == FALSE)
        {
            DebugOutput( 
                    _TEXT("Table %s is not valid...\n"),
                    GetTableName()
                );

            JB_ASSERT(FALSE);
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        return ProcessRecord(&v, TRUE, dwParam, FALSE);
    }

    //-----------------------------------------------------
    virtual BOOL
    InsertRecord(
        WORKITEMRECORD& v,
        DWORD dwParam=PROCESS_ALL_COLUMNS
        )
    /*
    */
    {
        if(IsValid() == FALSE)
        {
            DebugOutput( 
                    _TEXT("Table %s is not valid...\n"),
                    GetTableName()
                );

            JB_ASSERT(FALSE);
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        return ProcessRecord(&v, FALSE, dwParam, FALSE);
    }

    //-----------------------------------------------------
    virtual BOOL
    UpdateRecord(
        WORKITEMRECORD& v,
        DWORD dwParam=PROCESS_ALL_COLUMNS
        )
    /*
    */
    {
        if(IsValid() == FALSE)
        {
            DebugOutput( 
                    _TEXT("Table %s is not valid...\n"),
                    GetTableName()
                );

            JB_ASSERT(FALSE);
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        return ProcessRecord(&v, FALSE, dwParam, TRUE);
    }

    //-------------------------------------------------------
    virtual BOOL
    Initialize() 
    { 
        return TRUE; 
    }

    //-------------------------------------------------------
    virtual JBKeyBase*
    EnumerationIndex( 
        IN BOOL bMatchAll,
        IN DWORD dwParam,
        IN WORKITEMRECORD* kp,
        IN OUT BOOL* bCompareKey
    );
    
    virtual BOOL
    EqualValue(
        WORKITEMRECORD& s1,
        WORKITEMRECORD& s2,
        BOOL bMatchAll,
        DWORD dwParam
    );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\upg4to5\hydra4db.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       hydra4db.h 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __HYDRA4_DB_H__
#define __HYDRA4_DB_H__

#include "license.h"

//----------------------------------------------------------------------
//
// NT4 Hydra specific
//
//
#define NT4SZSERVICENAME               _TEXT("TermServLicensing")

#define NT4LSERVER_DEFAULT_DSN         _TEXT("Hydra License")
#define NT4LSERVER_DEFAULT_USER        _TEXT("sa")
#define NT4LSERVER_DEFAULT_PWD         _TEXT("password")

//---------------------------------------------------------------------------
//
// Server specified Registry Entry
//
#define NT4LSERVER_REGISTRY_BASE  \
    _TEXT("SYSTEM\\CurrentControlSet\\Services")

#define NT4LSERVER_PARAMETERS \
    _TEXT("Parameters")

#define NT4LSERVER_REGKEY \
    NT4LSERVER_REGISTRY_BASE _TEXT("\\") NT4SZSERVICENAME _TEXT("\\") NT4LSERVER_PARAMETERS

#define NT4LSERVER_PARAMETERS_DSN       _TEXT("Dsn")
#define NT4LSERVER_PARAMETERS_USER      _TEXT("User")

#ifdef __cplusplus
extern "C" {
#endif

DWORD 
GetNT4DbConfig(
    LPTSTR pszDsn,
    LPTSTR pszUserName,
    LPTSTR pszPwd,
    LPTSTR pszMdbFile
);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\upg4to5\upg.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       upg.cpp 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include "upg.h"
#include <time.h>

//----------------------------------------------------
//
// Global variables
//
//

TCHAR           g_szOdbcDsn[128]=NT4LSERVER_DEFAULT_DSN;   // ODBC DSN
TCHAR           g_szOdbcUser[128]=NT4LSERVER_DEFAULT_USER;  // ODBC User Name
TCHAR           g_szOdbcPwd[128]=NT4LSERVER_DEFAULT_PWD;   // ODBC Password
TCHAR           g_szMdbFile[MAX_PATH+1];


//--------------------------------------------------------------------------

DWORD 
GetNT4DbConfig(
    LPTSTR pszDsn,
    LPTSTR pszUserName,
    LPTSTR pszPwd,
    LPTSTR pszMdbFile
    )
/*++

++*/
{
    HKEY hKey = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    TCHAR szOdbcDsn[128]=NT4LSERVER_DEFAULT_DSN;   // ODBC DSN
    TCHAR szOdbcUser[128]=NT4LSERVER_DEFAULT_USER;  // ODBC User Name
    TCHAR szOdbcPwd[128]=NT4LSERVER_DEFAULT_PWD;   // ODBC Password

    TCHAR szMdbFile[MAX_PATH+1];
    DWORD dwBuffer=0;

    PBYTE pbData = NULL;
    DWORD cbData = 0;

    BOOL bSuccess;


    //
    // Open NT4 license server specific registry key
    //
    dwStatus = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        NT4LSERVER_REGKEY,
                        0,
                        KEY_ALL_ACCESS,    
                        &hKey
                    );

    if(dwStatus != ERROR_SUCCESS)
    {
        dwStatus = ERROR_INVALID_NT4_SETUP;
        goto cleanup;
    }

    //
    // Load ODBC DSN and User name from registry,
    // ignore error return and use default value.
    //
    dwBuffer = sizeof(szOdbcDsn);
    dwStatus = RegQueryValueEx(
                        hKey,
                        NT4LSERVER_PARAMETERS_DSN,
                        NULL,
                        NULL,
                        (LPBYTE)szOdbcDsn,
                        &dwBuffer
                    );
    if(dwStatus == ERROR_SUCCESS && pszDsn)
    {
        lstrcpy(pszDsn, szOdbcDsn);
    }

    dwBuffer = sizeof(szOdbcUser);
    dwStatus = RegQueryValueEx(
                        hKey,
                        NT4LSERVER_PARAMETERS_USER,
                        NULL,
                        NULL,
                        (LPBYTE)szOdbcUser,
                        &dwBuffer
                    );

    if(dwStatus == ERROR_SUCCESS && pszUserName)
    {
        lstrcpy(pszUserName, szOdbcUser);
    }

   
    //
    // Load database password from LSA
    //
    dwStatus = RetrieveKey(
                        LSERVER_LSA_PASSWORD_KEYNAME,
                        &pbData,
                        &cbData
                    );

#ifndef PRIVATE_DBG
    if(dwStatus != ERROR_SUCCESS)
    {
        //
        // Invalid NT4 license server setup or hydra beta2 
        // license server which we don't support.
        //
        dwStatus = ERROR_INVALID_NT4_SETUP;
        goto cleanup;
    }
#endif

    dwStatus = ERROR_SUCCESS;
    memset(szOdbcPwd, 0, sizeof(szOdbcPwd));
    memcpy(
            (PBYTE)szOdbcPwd,
            pbData,
            min(cbData, sizeof(szOdbcPwd) - sizeof(TCHAR))
        );

    if(pszPwd != NULL)
    {
        lstrcpy(pszPwd, szOdbcPwd);
    }

    //
    // Verify data source is properly installed
    //
    bSuccess = IsDataSourceInstalled(
                            szOdbcDsn,
                            ODBC_SYSTEM_DSN,
                            szMdbFile,
                            MAX_PATH
                        );

    if(bSuccess == FALSE)
    {
        dwStatus = ERROR_INVALID_NT4_SETUP;
        goto cleanup;
    }        

    if(pszMdbFile != NULL)
    {
        _tcscpy(pszMdbFile, szMdbFile);
    }

cleanup:

    if(hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    if(pbData != NULL)
    {
        LocalFree(pbData);
    }

    return dwStatus;
}

//--------------------------------------------------------------------------
DWORD
DeleteNT4ODBCDataSource()
/*++

--*/
{
    BOOL bSuccess;
    DWORD dwStatus = ERROR_SUCCESS;

    //
    // Get Hydra 4 DB configuration, make sure 
    // data source is properly config.
    //
    dwStatus = GetNT4DbConfig(
                            g_szOdbcDsn,
                            g_szOdbcUser,
                            g_szOdbcPwd,
                            g_szMdbFile
                        );

    if(dwStatus == ERROR_SUCCESS)
    {
        bSuccess = ConfigDataSource( 
                                NULL,
                                FALSE,
                                _TEXT(SZACCESSDRIVERNAME),
                                g_szOdbcDsn,
                                g_szOdbcUser,
                                g_szOdbcPwd,
                                g_szMdbFile
                            );

        if(bSuccess == FALSE)
        {
            dwStatus = ERROR_DELETE_ODBC_DSN;
        }
    }

    return dwStatus;
}    

//--------------------------------------------------------------------------

#define LSERVER_SOFTWARE_REGBASE \
    _TEXT("SOFTWARE\\Microsoft\\") _TEXT(SZSERVICENAME)

#define LSERVER_CERTIFICATE_STORE           _TEXT("Certificates")

#define LSERVER_SERVER_CERTIFICATE_REGKEY \
    LSERVER_SOFTWARE_REGBASE _TEXT("\\") LSERVER_CERTIFICATE_STORE

#define LSERVER_CLIENT_CERTIFICATE_ISSUER   _TEXT("Parm0")
#define LSERVER_SIGNATURE_CERT_KEY          _TEXT("Parm1")
#define LSERVER_EXCHANGE_CERT_KEY           _TEXT("Parm2")


void
CleanLicenseServerSecret()

/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    HKEY hKey = NULL;
    
    //
    // Wipe out SPK in LSA
    //
    dwStatus = StoreKey(
                    LSERVER_LSA_LSERVERID,
                    (PBYTE) NULL,
                    0
                );

    dwStatus = StoreKey(
                    LSERVER_LSA_LASTRUN, 
                    (PBYTE) NULL,
                    0
                );

    dwStatus = StoreKey(
                    LSERVER_LSA_PRIVATEKEY_EXCHANGE, 
                    (PBYTE) NULL,
                    0
                );


    dwStatus = StoreKey(
                    LSERVER_LSA_PRIVATEKEY_SIGNATURE, 
                    (PBYTE) NULL,
                    0
                );

    dwStatus=RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    LSERVER_SERVER_CERTIFICATE_REGKEY,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                );
    if(dwStatus == ERROR_SUCCESS)
    {
        //
        // Ignore error
        RegDeleteValue(
                    hKey,
                    LSERVER_SIGNATURE_CERT_KEY
                );

        RegDeleteValue(
                    hKey,
                    LSERVER_EXCHANGE_CERT_KEY
                );

        RegDeleteValue(
                    hKey,
                    LSERVER_CLIENT_CERTIFICATE_ISSUER
                );
    }

    if(hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    return;
}

DWORD
MigrateOneSecret(PWCHAR wszSecretName, PWCHAR wszSecretNameOld)
/*++

--*/
{
    DWORD dwErr = ERROR_SUCCESS;
    PBYTE pbValue = NULL;
    DWORD cbValue = 0;

    dwErr = RetrieveKey(wszSecretNameOld,&pbValue,&cbValue);
    if (dwErr == ERROR_SUCCESS)
    {
        dwErr = StoreKey(wszSecretName,
                 pbValue,
                 cbValue
                 );

        if (dwErr == ERROR_SUCCESS)
        {
            StoreKey(wszSecretNameOld,
                     (PBYTE) NULL,
                     0
                     );
        }
        else
        {
            goto done;
        }
    }
    else if (dwErr == ERROR_FILE_NOT_FOUND)
    {
        dwErr = ERROR_SUCCESS;
    }
    else
    {
        goto done;
    }


done:

    if (NULL != pbValue)
    {
        LocalFree(pbValue);
    }

    return dwErr;
}

DWORD
MigrateLsaSecrets()
/*++

--*/
{
    DWORD dwErr = ERROR_SUCCESS;

    dwErr = MigrateOneSecret(LSERVER_LSA_PASSWORD_KEYNAME, LSERVER_LSA_PASSWORD_KEYNAME_OLD);

    if (dwErr != ERROR_SUCCESS)
    {
        goto done;
    }

    dwErr = MigrateOneSecret(LSERVER_LSA_LASTRUN, LSERVER_LSA_LASTRUN_OLD);

    if (dwErr != ERROR_SUCCESS)
    {
        goto done;
    }

    dwErr = MigrateOneSecret(LSERVER_LSA_SETUPID, LSERVER_LSA_SETUPID_OLD);

    if (dwErr != ERROR_SUCCESS)
    {
        goto done;
    }

    dwErr = MigrateOneSecret(LSERVER_LSA_PRIVATEKEY_SIGNATURE, LSERVER_LSA_PRIVATEKEY_SIGNATURE_OLD);

    if (dwErr != ERROR_SUCCESS)
    {
        goto done;
    }

    dwErr = MigrateOneSecret(LSERVER_LSA_PRIVATEKEY_EXCHANGE, LSERVER_LSA_PRIVATEKEY_EXCHANGE_OLD);

    if (dwErr != ERROR_SUCCESS)
    {
        goto done;
    }

    dwErr = MigrateOneSecret(LSERVER_LSA_LSERVERID, LSERVER_LSA_LSERVERID_OLD);

    if (dwErr != ERROR_SUCCESS)
    {
        goto done;
    }

done:
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\trust\trust.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       trust.cpp 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include <windows.h>
#include <wincrypt.h>
#include <tchar.h>
#include <stdlib.h>
#include "license.h"
#include "tlsapip.h"
#include "trust.h"


LPCTSTR g_pszServerGuid = _TEXT("d63a773e-6799-11d2-96ae-00c04fa3080d");
const DWORD g_cbServerGuid = (_tcslen(g_pszServerGuid) * sizeof(TCHAR));

LPCTSTR g_pszLrWizGuid = _TEXT("d46b4bf2-686d-11d2-96ae-00c04fa3080d");
const DWORD g_cbLrWizGuid = (_tcslen(g_pszLrWizGuid) * sizeof(TCHAR));

//----------------------------------------------------------------

DWORD
HashChallengeData(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwClientType,
    IN DWORD dwRandom,
    IN PBYTE pbChallengeData,
    IN DWORD cbChallengeData,
    IN PBYTE pbReserved,
    IN DWORD cbReserved,
    OUT PBYTE* ppbHashedData,
    OUT PDWORD pcbHashedData
    )

/*++


--*/

{
    DWORD dwStatus = ERROR_SUCCESS;
    HCRYPTHASH hCryptHash = NULL;

    PBYTE pbHashData = NULL;
    DWORD cbHashData = 0;

    DWORD cbHashGuidSize;
    LPCTSTR pszHashGuid;

    BOOL bSuccess;



    //
    // Generate MD5 hash
    //
    bSuccess = CryptCreateHash(
                            hCryptProv, 
                            CALG_MD5, 
                            0, 
                            0, 
                            &hCryptHash
                        );

    if(bSuccess == FALSE)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    //
    // Pick the right hash type
    //
    if(dwClientType == CLIENT_TYPE_LRWIZ)
    {
        pszHashGuid = g_pszLrWizGuid;
        cbHashGuidSize = g_cbLrWizGuid;
    }
    else
    {
        pszHashGuid = g_pszServerGuid;
        cbHashGuidSize = g_cbServerGuid;
    }

    //
    // TODO : Consider hash a few times...
    //
    bSuccess = CryptHashData(
                            hCryptHash,
                            (PBYTE) pbChallengeData,
                            dwRandom,
                            0
                        );

    if(bSuccess == FALSE)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }


    bSuccess = CryptHashData( 
                            hCryptHash,
                            (PBYTE) pszHashGuid,
                            cbHashGuidSize,
                            0
                        );
    
    if(bSuccess == FALSE)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }


    bSuccess = CryptHashData(
                            hCryptHash,
                            (PBYTE) pbChallengeData + dwRandom,
                            cbChallengeData - dwRandom,
                            0
                        );

    if(bSuccess == FALSE)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    
    //
    // Get the size of hased data
    //
    bSuccess = CryptGetHashParam(
                            hCryptHash,
                            HP_HASHVAL,
                            NULL,
                            &cbHashData,
                            0
                        ); 

    if(bSuccess == FALSE && GetLastError() != ERROR_MORE_DATA)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    pbHashData = (PBYTE)LocalAlloc(LPTR, cbHashData);
    if(pbHashData == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    bSuccess = CryptGetHashParam(
                            hCryptHash,
                            HP_HASHVAL,
                            pbHashData,
                            &cbHashData,
                            0
                        );

    if(bSuccess == FALSE)
    {
        dwStatus = GetLastError();
    }

cleanup:

    if(hCryptHash)
    {
        CryptDestroyHash( hCryptHash );
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        *ppbHashedData = pbHashData;
        *pcbHashedData = cbHashData;
        pbHashData = NULL;
    }

    if(pbHashData != NULL)
    {
        LocalFree(pbHashData);
    }

    return dwStatus;

}

//----------------------------------------------------------------

DWORD WINAPI
TLSVerifyChallengeResponse(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwClientType,
    IN PTLSCHALLENGEDATA pClientChallengeData,
    IN PTLSCHALLENGERESPONSEDATA pServerChallengeResponseData
    )
/*++

--*/

{
    DWORD dwStatus = ERROR_SUCCESS;
    PBYTE pbData = NULL;
    DWORD cbData = 0;
    
    //
    // base on our challenge data, generate a corresponding
    // hash data
    //
    dwStatus = HashChallengeData(
                        hCryptProv,
                        dwClientType,
                        pClientChallengeData->dwRandom,
                        pClientChallengeData->pbChallengeData,
                        pClientChallengeData->cbChallengeData,
                        pClientChallengeData->pbReservedData,
                        pClientChallengeData->cbReservedData,
                        &pbData,
                        &cbData
                    );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

                        
    //
    // Compare our hash with response data
    //
    if(pServerChallengeResponseData->cbResponseData != cbData)
    {
        dwStatus = ERROR_INVALID_DATA;
    }

    if(memcmp(pServerChallengeResponseData->pbResponseData, pbData, cbData) != 0)
    {
        dwStatus = ERROR_INVALID_DATA;
    }

cleanup:

    if(pbData != NULL)
        LocalFree(pbData);        
    
    return dwStatus;
}


//----------------------------------------------------------------

DWORD
TLSGenerateChallengeResponseData(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwClientType,
    IN PTLSCHALLENGEDATA pChallengeData,
    OUT PBYTE* pbResponseData,
    OUT PDWORD cbResponseData
    )

/*++


--*/

{
    DWORD dwStatus = ERROR_SUCCESS;

    dwStatus = HashChallengeData(
                            hCryptProv,
                            dwClientType,
                            pChallengeData->dwRandom,
                            pChallengeData->pbChallengeData,
                            pChallengeData->cbChallengeData,
                            pChallengeData->pbReservedData,
                            pChallengeData->cbReservedData,
                            pbResponseData,
                            cbResponseData
                        );

    return dwStatus;
}


//----------------------------------------------------------------

DWORD WINAPI
TLSGenerateRandomChallengeData(
    IN HCRYPTPROV hCryptProv,
    IN PBYTE* ppbChallengeData,
    IN PDWORD pcbChallengeData
    )

/*++

Abstract:

    Generate two random 128 bit challenge data and concatenate it 
    before returning.

Parameters:

    hCryptProv : Crypto. provider.
    pcbChallengeData :  Pointer to DWORD receiving size 
                        of challenge data.
    ppbChallengeData :  Pointer to BYTE receiving randomly 
                        generated challege data.

Returns:

    ERROR_SUCCESS or error code.

Note:

    All memory allocation via LocalAlloc(). 

--*/

{
    DWORD dwLen = RANDOM_CHALLENGE_DATASIZE;
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bSuccess;
    PBYTE pbRandomData = NULL;

    if( ppbChallengeData == NULL || 
        pcbChallengeData == NULL ||
        hCryptProv == NULL )
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }
    
    pbRandomData = (PBYTE)LocalAlloc(LPTR, dwLen * 2);
    if(pbRandomData == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    //
    // generate two random 128 bit data
    //
    bSuccess = CryptGenRandom(
                            hCryptProv,
                            dwLen,
                            pbRandomData
                        );
        
    if(bSuccess == TRUE)
    {
        memcpy(
                pbRandomData + dwLen, 
                pbRandomData,
                dwLen
            );

        bSuccess = CryptGenRandom(
                                hCryptProv,
                                dwLen,
                                pbRandomData + dwLen
                            );
    }        

    if(bSuccess == FALSE)
    {
        dwStatus = GetLastError();
    }

cleanup:

    if(dwStatus == ERROR_SUCCESS)
    {
        *ppbChallengeData = pbRandomData;
        *pcbChallengeData = dwLen * 2;
    }
    else
    {
        if(pbRandomData != NULL)
        {
            LocalFree(pbRandomData);
        }
    }

    return dwStatus;
}

//----------------------------------------------------------------

DWORD WINAPI
TLSEstablishTrustWithServer(
    IN TLS_HANDLE hHandle,
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwClientType,
    OUT PDWORD pdwErrCode
    )
/*++

Abstract:

    Establish trust relationship with License Server, trust is 
    based on two way challenge/response.  License Server and LrWiz 
    can't use certificate-base trust verification as anyone can get 
    TermSrv certificate from registry and also be the administrator 
    of system to invoke server side administrative RPC call to mess 
    up license server setup.  This challenge/response scheme should be 
    kept secret (user can reverse engineer to figure out our algorithm
    but this user probably smart enough to alter executable to return 
    SUCCESS in all case too.)

Parameters:

    hHandle : Connection handle to License Server.
    hCryptProv : handle to CSP to do hashing.
    dwClientType : Caller type, License Server, LrWiz, or TermSrv.
    pdwErrCode : Pointer to DWORD to receive License Server return code.

Return:

    ERROR_SUCCESS or RPC error code. Caller should also verify pdwErrCode.

Note:

    TermSrv's certificate is issued by license server.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    PBYTE pbClientRandomChallengeData = NULL;
    DWORD cbClientRandomChallengeData = 0;

    PBYTE pbChallengeResponseData = NULL;
    DWORD cbChallengeResponseData = 0;
    
    TLSCHALLENGEDATA ClientChallengeData;
    TLSCHALLENGERESPONSEDATA* pServerChallengeResponseData=NULL;

    TLSCHALLENGEDATA* pServerChallengeData=NULL;
    TLSCHALLENGERESPONSEDATA ClientChallengeResponseData;

    //
    // Verify input parameters
    //
    if(hHandle == NULL || hCryptProv == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    //
    // Only three type supported
    //
    if( dwClientType != CLIENT_TYPE_TLSERVER &&
        dwClientType != CLIENT_TYPE_LRWIZ &&
        dwClientType != CLIENT_TYPE_TERMSRV )
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    //
    // Generate a random challenge data 
    //
    dwStatus = TLSGenerateRandomChallengeData(
                                    hCryptProv,
                                    &pbClientRandomChallengeData,
                                    &cbClientRandomChallengeData
                                );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //
    // 
    //
    memset(
            &ClientChallengeData,
            0,
            sizeof(TLSCHALLENGEDATA)
        );

    memset(
            &ClientChallengeResponseData,
            0,
            sizeof(TLSCHALLENGERESPONSEDATA)
        );

    //
    // Send this challenge data to server
    //
    ClientChallengeData.dwVersion = TLS_CURRENT_CHALLENGE_VERSION;

    if (!CryptGenRandom(hCryptProv,sizeof(ClientChallengeData.dwRandom), (BYTE *)&(ClientChallengeData.dwRandom))) {
        dwStatus = GetLastError();
        goto cleanup;
	}

    //
    // This must range from 1 to 128, as it's used as an offset into the
    // challenge data buffer
    //

    ClientChallengeData.dwRandom %= RANDOM_CHALLENGE_DATASIZE;
    ClientChallengeData.dwRandom++;

    ClientChallengeData.cbChallengeData = cbClientRandomChallengeData;
    ClientChallengeData.pbChallengeData = pbClientRandomChallengeData;

    dwStatus = TLSChallengeServer(
                                hHandle,
                                dwClientType,
                                &ClientChallengeData,
                                &pServerChallengeResponseData,
                                &pServerChallengeData,
                                pdwErrCode
                            );

    if(dwStatus != RPC_S_OK || *pdwErrCode >= LSERVER_ERROR_BASE)
    {
        goto cleanup;
    }

    if(pServerChallengeResponseData == NULL || pServerChallengeData == NULL)
    {
        dwStatus = LSERVER_E_INTERNAL_ERROR;
        goto cleanup;
    }

    //
    // Verify Server Challege Data.
    //
    dwStatus = TLSVerifyChallengeResponse(
                                    hCryptProv,
                                    dwClientType,
                                    &ClientChallengeData,
                                    pServerChallengeResponseData
                                );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //
    // Generate Client side responses data
    //
    dwStatus = TLSGenerateChallengeResponseData(
                                        hCryptProv,
                                        dwClientType,
                                        pServerChallengeData,
                                        &pbChallengeResponseData,
                                        &cbChallengeResponseData
                                    );
    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }


    //
    // Response to server's challenge
    //
    ClientChallengeResponseData.dwVersion = TLS_CURRENT_CHALLENGE_VERSION;
    ClientChallengeResponseData.cbResponseData = cbChallengeResponseData;
    ClientChallengeResponseData.pbResponseData = pbChallengeResponseData;

    dwStatus = TLSResponseServerChallenge(
                                    hHandle,
                                    &ClientChallengeResponseData,
                                    pdwErrCode
                                );

cleanup:
    //
    // Cleanup memory allocated.
    //
    if(pbClientRandomChallengeData != NULL)
    {
        LocalFree(pbClientRandomChallengeData);
    }

    if(pbChallengeResponseData != NULL)
    {
        LocalFree(pbChallengeResponseData);
    }

    if(pServerChallengeData != NULL)
    {
        if(pServerChallengeData->pbChallengeData)
        {
            midl_user_free(pServerChallengeData->pbChallengeData);
        }

        if(pServerChallengeData->pbReservedData)
        {
            midl_user_free(pServerChallengeData->pbReservedData);
        }

        midl_user_free(pServerChallengeData);
    }

    if(pServerChallengeResponseData != NULL)
    {
        if(pServerChallengeResponseData->pbResponseData)
        {
            midl_user_free(pServerChallengeResponseData->pbResponseData);
        }

        if(pServerChallengeResponseData->pbReservedData)
        {
            midl_user_free(pServerChallengeResponseData->pbReservedData);
        }
    
        midl_user_free(pServerChallengeResponseData);
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\upg4to5\dbsetup.c ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:
//
// Contents:    
//
// History:     
//---------------------------------------------------------------------------
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <odbcinst.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#define szSQLSetConfigMode              "SQLSetConfigMode"

//---------------------------------------------------------------------------
// various installation routine we use, can't link with library as it will
// cause 
#ifdef  UNICODE
#define  szSQLInstallDriver             "SQLInstallDriverW"
#define  szSQLGetInstalledDrivers       "SQLGetInstalledDriversW"
#define  szSQLConfigDataSource          "SQLConfigDataSourceW"
#define  szSQLGetPrivateProfileString   "SQLGetPrivateProfileStringW"
#define  szSQLConfigDriver              "SQLConfigDriverW"
#define  szSQLInstallerError            "SQLInstallerErrorW"
#else
#define  szSQLInstallDriver             "SQLInstallDriver"
#define  szSQLGetInstalledDrivers       "SQLGetInstalledDrivers"
#define  szSQLConfigDataSource          "SQLConfigDataSource"
#define  szSQLGetPrivateProfileString   "SQLGetPrivateProfileString"
#define  szSQLConfigDriver              "SQLConfigDriver"
#define  szSQLInstallerError            "SQLInstallerError"
#endif

//
// ODBC install functions - To prevent system to 'force' odbccp32.dll
// odbccp32 may not present on the system nor it is available at the 
// time setup got kick off.
//
typedef BOOL (* SQLCONFIGDATASOURCE)(HWND, WORD, LPCTSTR, LPCTSTR);

typedef SQLRETURN (* SQLINSTALLERERROR)(WORD , DWORD*, LPTSTR, WORD, WORD*);

typedef int (* SQLGETPRIVATEPROFILESTRING)( LPCTSTR lpszSection,
                                            LPCTSTR lpszEntry,
                                            LPCTSTR lpszDefault,
                                            LPTSTR  lpszRetBuffer,
                                            int    cbRetBuffer,
                                            LPCTSTR lpszFilename);

typedef BOOL (* SQLINSTALLDRIVER)(LPCTSTR  lpszInfFile,
                                  LPCTSTR  lpszDriver,
                                  LPTSTR   lpszPath,
                                  WORD     cbPathMax,
                                  WORD*    pcbPathOut);

typedef BOOL (* SQLGETINSTALLEDDRIVER)(LPTSTR  lpszBuf,
                                       WORD    cbBufMax,
                                       WORD*   pcbBufOut);

typedef BOOL (* SQLSETCONFIGMODE)(UWORD wConfigMode);

static SQLCONFIGDATASOURCE          fpSQLConfigDataSource=NULL;
static SQLINSTALLDRIVER             fpSQLInstallDriver=NULL;
static SQLINSTALLERERROR            fpSQLInstallerError=NULL;
static SQLGETPRIVATEPROFILESTRING   fpSQLGetPrivateProfileString=NULL;
static SQLSETCONFIGMODE             fpSQLSetConfigMode=NULL;
static SQLGETINSTALLEDDRIVER        fpSQLGetInstalledDriver=NULL;
static HINSTANCE                    hODBCCP32=NULL;

//------------------------------------------------------------

void
ReportError(
    IN HWND hWnd, 
    IN LPTSTR pszDefaultMsg
    )
/*++

Abstract:

    Popup a error message.

Parameters:

    hWnd - Parent window handle.
    pszDefaultMsg - ignore.

Returns:

    None.
    
++*/
{
#if DBG
    DWORD dwErrCode;
    TCHAR szErrMsg[2048];
    WORD  szErrMsgSize=sizeof(szErrMsg)/sizeof(szErrMsg[0]);
    WORD  cbErrMsg;

    fpSQLInstallerError(
                    1, 
                    &dwErrCode, 
                    szErrMsg, 
                    szErrMsgSize, 
                    &cbErrMsg
                );

    MessageBox(hWnd, szErrMsg, _TEXT("Setup Error"), MB_OK);
#else
    return;
#endif
}


//------------------------------------------------------------

BOOL 
InitODBCSetup()
/*++


++*/
{
    hODBCCP32 = LoadLibrary(_TEXT("odbccp32"));
    if(hODBCCP32)
    {
        fpSQLConfigDataSource=(SQLCONFIGDATASOURCE)GetProcAddress(
                                                            hODBCCP32, 
                                                            szSQLConfigDataSource
                                                        );

        fpSQLInstallDriver=(SQLINSTALLDRIVER)GetProcAddress(
                                                            hODBCCP32, 
                                                            szSQLInstallDriver
                                                        );

        fpSQLInstallerError=(SQLINSTALLERERROR)GetProcAddress(
                                                            hODBCCP32, 
                                                            szSQLInstallerError
                                                        );

        fpSQLGetPrivateProfileString=(SQLGETPRIVATEPROFILESTRING)GetProcAddress(
                                                                        hODBCCP32, 
                                                                        szSQLGetPrivateProfileString
                                                                    );

        fpSQLSetConfigMode=(SQLSETCONFIGMODE)GetProcAddress(
                                                        hODBCCP32, 
                                                        szSQLSetConfigMode
                                                    );

        fpSQLGetInstalledDriver=(SQLGETINSTALLEDDRIVER)GetProcAddress(
                                                                hODBCCP32, 
                                                                szSQLGetInstalledDrivers
                                                            );
    }

    if( hODBCCP32 == NULL || fpSQLConfigDataSource == NULL || 
        fpSQLInstallDriver == NULL || fpSQLInstallerError == NULL || 
        fpSQLGetPrivateProfileString == NULL || fpSQLSetConfigMode == NULL ||
        fpSQLGetInstalledDriver == NULL)
    {
        ReportError(NULL, _TEXT("Can't load odbccp32.dll "));
        return FALSE;
    } 

    return TRUE;
}

//------------------------------------------------------------

void 
CleanupODBCSetup()
/*++

++*/
{
    if(hODBCCP32)
        FreeLibrary(hODBCCP32);

    fpSQLConfigDataSource=NULL;
    fpSQLInstallDriver=NULL;
    fpSQLInstallerError=NULL;
    fpSQLGetPrivateProfileString=NULL;
    fpSQLSetConfigMode=NULL;
    fpSQLGetInstalledDriver=NULL;
    hODBCCP32=NULL;

    return;
}

//---------------------------------------------------------------------------
//
// Access Driver installation
//
LPTSTR szAccessDriver=_TEXT("Microsoft Access Driver (*.mdb)\0")
                      _TEXT("Driver=odbcjt32.dll\0")
                      _TEXT("Setup=odbcjt32.dll\0")
                      _TEXT("Name=Microsoft Access Driver (*.mdb)\0")
                      _TEXT("APILevel=1\0")
                      _TEXT("ConnectFunctions=YYN\0")
                      _TEXT("DriverODBCVer=02.50\0")
                      //_TEXT("FileUsage=2\0")
                      _TEXT("FileExtns=*.mdb\0")
                      _TEXT("SQLLevel=0\0");


//---------------------------------------------------------------------------

BOOL 
IsDriverInstalled( 
    IN LPTSTR szDriverName 
    )
/*++

Abstract:

    Check if a ODBC driver installed on system.

Parameters:

    szDriveName - Name of the drive.

Returns:

    TRUE if driver installed, FALSE otherwise.

++*/
{
    TCHAR szBuf[8096];  // this got to be enough
    WORD cbBufMax=sizeof(szBuf)/sizeof(szBuf[0]);
    WORD cbBufOut;
    LPTSTR pszBuf=szBuf;

    if(hODBCCP32 == NULL && !InitODBCSetup())
        return FALSE;

    if(fpSQLGetInstalledDriver(szBuf, cbBufMax, &cbBufOut))
    {
        ReportError(NULL, _TEXT("SQLGetInstalledDrivers"));
    }
    else
    {
        do {
            if(_tcsnicmp(szDriverName, pszBuf, min(lstrlen(szDriverName), lstrlen(pszBuf))) == 0)
                break;

            pszBuf += lstrlen(pszBuf) + 1;
        } while(pszBuf[1] != _TEXT('\0'));
    }

    return (pszBuf[1] != _TEXT('\0'));
}
    
//---------------------------------------------------------------------------

BOOL 
IsDataSourceInstalled( 
    IN LPTSTR pszDataSource, 
    IN UWORD wConfigMode, 
    IN OUT LPTSTR pszDbFile, 
    IN DWORD cbBufSize 
    )

/*++

Abstract:

    Check if a ODBC datasource are installed.

Parameters:

    pszDataSource - name of data source.
    wConfigMode - configuration mode, refer to ODBC for detail, 
                  license server uses ODBC_SYSTEM_DSN.
    pszDbFile - Pointer to buffer for receving full path to database file 
                if data source is installed.
    cbBufSize - size of buffer in characters.

    
Returns:

    TRUE if datasource is installed, FALSE otherwise.

++*/

{
    BOOL bSuccess = TRUE;

    if(hODBCCP32 == NULL && !InitODBCSetup())
    {
        bSuccess = FALSE;
        goto cleanup;
    }

    if(fpSQLSetConfigMode(wConfigMode) == FALSE)
    {
        ReportError(NULL, _TEXT("SQLSetConfigMode failed"));
        bSuccess = FALSE;
        goto cleanup;
    }

    if(fpSQLGetPrivateProfileString(
                    pszDataSource, 
                    _TEXT("DBQ"), 
                    _TEXT(""), 
                    pszDbFile, 
                    cbBufSize, 
                    _TEXT("ODBC.INI")
                ) == 0)
    {
        bSuccess = FALSE;
    }

cleanup:

    return bSuccess;
}

//---------------------------------------------------------------------------

BOOL
ConfigDataSource( 
    HWND     hWnd, 
    BOOL     bInstall,       // TRUE to install FALSE to remove
    LPTSTR   pszDriver,       // driver
    LPTSTR   pszDsn,          // DSN
    LPTSTR   pszUser,         // User
    LPTSTR   pszPwd,          // Password
    LPTSTR   pszMdbFile       // MDB file
    )

/*++

Abstract:

    Routine to add/remove ODBC data source.

Parameters:

    hWnd - Parent window handle.
    bInstall - TRUE if installing ODBC data source, FALSE otherwise.
    pszDrive - Name of the ODBC drive to be used on data source.
    pszDsn - ODBC Data Source Name.
    pszUser - Login use name.
    pszPwd - Login password.
    pszMdbFile - Name of the Database file.
    
Returns:

    TRUE if successfule, FALSE otherwise.

++*/

{
    TCHAR   szAttributes[MAX_PATH*6+1];
    BOOL    bConfig=TRUE;
    TCHAR   *pszAttributesEnd;
    HRESULT hr;
    size_t  cbRemaining;

    if(hODBCCP32 == NULL && !InitODBCSetup())
        return FALSE;

    //
    // for attribute string
    //
    memset(szAttributes, 0, sizeof(szAttributes));

    hr = StringCbCopyEx(szAttributes,sizeof(szAttributes),_TEXT("DSN="),&pszAttributesEnd, &cbRemaining,0);

    if (FAILED(hr))
    {
        return FALSE;
    }

    hr = StringCbCopyEx(pszAttributesEnd,cbRemaining,pszDsn,&pszAttributesEnd, &cbRemaining,0);

    if (FAILED(hr))
    {
        return FALSE;
    }

    hr = StringCbCopyEx(pszAttributesEnd,cbRemaining,_TEXT("UID="),&pszAttributesEnd, &cbRemaining,0);

    if (FAILED(hr))
    {
        return FALSE;
    }

    hr = StringCbCopyEx(pszAttributesEnd,cbRemaining,pszUser,&pszAttributesEnd, &cbRemaining,0);

    if (FAILED(hr))
    {
        return FALSE;
    }

    if(pszPwd)
    {
        hr = StringCbCopyEx(pszAttributesEnd,cbRemaining,_TEXT("PASSWORD="),&pszAttributesEnd, &cbRemaining,0);

        if (FAILED(hr))
        {
            return FALSE;
        }

        hr = StringCbCopyEx(pszAttributesEnd,cbRemaining,pszPwd,&pszAttributesEnd, &cbRemaining,0);

        if (FAILED(hr))
        {
            return FALSE;
        }
    }

    hr = StringCbCopyEx(pszAttributesEnd,cbRemaining,_TEXT("DBQ="),&pszAttributesEnd, &cbRemaining,0);

    if (FAILED(hr))
    {
        return FALSE;
    }

    hr = StringCbCopyEx(pszAttributesEnd,cbRemaining,pszMdbFile,&pszAttributesEnd, &cbRemaining,0);

    if (FAILED(hr))
    {
        return FALSE;
    }

    bConfig=fpSQLConfigDataSource(NULL,
                                  (WORD)((bInstall) ? ODBC_ADD_SYS_DSN : ODBC_REMOVE_SYS_DSN),
                                  pszDriver,
                                  szAttributes);
    // ignore error on uninstall
    if(!bConfig && bInstall)
    {
        ReportError(hWnd, _TEXT("Can't config data source"));
    }

    return bConfig;
}


BOOL
RepairDataSource( 
    HWND     hWnd, 
    LPTSTR   pszDriver,
    LPTSTR   pszDsn,          // DSN
    LPTSTR   pszUser,         // User
    LPTSTR   pszPwd,          // Password
    LPTSTR   pszMdbFile       // MDB file
    )

/*++

Abstract:

    Routine to Compact/Repair a database file

Parameters:

    hWnd - Parent window handle.
    pszDsn - ODBC Data Source Name.
    pszUser - Login use name.
    pszPwd - Login password.
    pszMdbFile - Name of the Database file.
    
Returns:

    TRUE if successfule, FALSE otherwise.

++*/

{
    TCHAR   szAttributes[MAX_PATH*6+1];
    BOOL    bConfig=TRUE;
    TCHAR*  pszAttributesEnd;
    size_t  cbRemaining;
    HRESULT hr;

    if(hODBCCP32 == NULL && !InitODBCSetup())
        return FALSE;

    //
    // for attribute string
    //
    memset(szAttributes, 0, sizeof(szAttributes));

    hr = StringCbCopyEx(szAttributes,sizeof(szAttributes),_TEXT("DSN="),&pszAttributesEnd, &cbRemaining,0);

    if (FAILED(hr))
    {
        return FALSE;
    }

    hr = StringCbCopyEx(pszAttributesEnd,cbRemaining,pszDsn,&pszAttributesEnd, &cbRemaining,0);

    if (FAILED(hr))
    {
        return FALSE;
    }

    hr = StringCbCopyEx(pszAttributesEnd,cbRemaining,_TEXT("UID="),&pszAttributesEnd, &cbRemaining,0);

    if (FAILED(hr))
    {
        return FALSE;
    }

    hr = StringCbCopyEx(pszAttributesEnd,cbRemaining,pszUser,&pszAttributesEnd, &cbRemaining,0);

    if (FAILED(hr))
    {
        return FALSE;
    }

    if(pszPwd)
    {
        hr = StringCbCopyEx(pszAttributesEnd,cbRemaining,_TEXT("PASSWORD="),&pszAttributesEnd, &cbRemaining,0);

        if (FAILED(hr))
        {
            return FALSE;
        }

        hr = StringCbCopyEx(pszAttributesEnd,cbRemaining,pszPwd,&pszAttributesEnd, &cbRemaining,0);

        if (FAILED(hr))
        {
            return FALSE;
        }
    }

    hr = StringCbCopyEx(pszAttributesEnd,cbRemaining,_TEXT("DBQ="),&pszAttributesEnd, &cbRemaining,0);

    if (FAILED(hr))
    {
        return FALSE;
    }

    hr = StringCbCopyEx(pszAttributesEnd,cbRemaining,pszMdbFile,&pszAttributesEnd, &cbRemaining,0);

    if (FAILED(hr))
    {
        return FALSE;
    }

    hr = StringCbCopyEx(pszAttributesEnd,cbRemaining,_TEXT("REPAIR_DB="),&pszAttributesEnd, &cbRemaining,0);

    if (FAILED(hr))
    {
        return FALSE;
    }

    hr = StringCbCopyEx(pszAttributesEnd,cbRemaining,pszMdbFile,&pszAttributesEnd, &cbRemaining,0);

    if (FAILED(hr))
    {
        return FALSE;
    }

    bConfig=fpSQLConfigDataSource(
                            NULL,
                            (WORD)ODBC_CONFIG_SYS_DSN,
                            pszDriver,
                            szAttributes
                        );

    // ignore error on uninstall
    if(bConfig == FALSE)
    {
        ReportError(hWnd, _TEXT("Can't repair data source"));
    }

    return bConfig;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\upg4to5\misc.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       misc.cpp 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include "upg.h"
#include <lm.h>

//-----------------------------------------------------------

void 
DBGPrintf(
    IN LPTSTR format, ... 
    )

/*

Abstract:

    Similar to printf() except it goes to debugger and messages 
    is limited to 8K

Parameters:

    format - format string, refer to printf.

Returns:

    None

*/

{
    va_list marker;
    TCHAR  buf[8096];
    DWORD  dump;

    va_start(marker, format);

    __try {
        memset(buf, 0, sizeof(buf));
        _vsntprintf(
                buf, 
                sizeof(buf) / sizeof(buf[0]) - 1, 
                format, 
                marker
            );

        OutputDebugString(buf);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
    }

    va_end(marker);

    return;
}


//--------------------------------------------------------------------

BOOL
FileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATA findData;
    HANDLE FindHandle;
    DWORD Error;

    FindHandle = FindFirstFile(FileName,&findData);
    if(FindHandle == INVALID_HANDLE_VALUE) 
    {
        Error = GetLastError();
    } 
    else 
    {
        FindClose(FindHandle);
        if(FindData) 
        {
            *FindData = findData;
        }
        Error = NO_ERROR;
    }

     SetLastError(Error);
    return (Error == NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\upg4to5\upg.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        upg.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __TLSUPG4TO5_H__
#define __TLSUPG4TO5_H__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>

#include <stdio.h>
#include <tchar.h>
#include <esent.h>

#include "lscommon.h"
#include "secstore.h"
#include "odbcinst.h"

#include "hydra4db.h"

#include "backup.h"
#include "KPDesc.h"
#include "Licensed.h"
#include "licpack.h"
#include "version.h"
#include "workitem.h"
#include "upgdef.h"

//
//
//
#define AllocateMemory(size) \
    LocalAlloc(LPTR, size)

#define FreeMemory(ptr) \
    if(ptr)             \
    {                   \
        LocalFree(ptr); \
        ptr=NULL;       \
    }

#define SAFESTRCPY(dest, source) \
    _tcsncpy(dest, source, min(_tcslen(source), sizeof(dest)/sizeof(TCHAR))); \
    dest[min(_tcslen(source), (sizeof(dest)/sizeof(TCHAR) -1))] = _TEXT('\0');

//--------------------------------------------------------------------------
//
// Upgrade Error Code, should move into resource file.
//
#define UPGRADE_SETUP_ERROR_BASE    0xD0000000

//
// File not exist or directory not exist
//
#define ERROR_TARGETFILE_NOT_FOUND      (UPGRADE_SETUP_ERROR_BASE)

//
// Destination file already exist
//
#define ERROR_DEST_FILE_EXIST           (UPGRADE_SETUP_ERROR_BASE + 1)    

//
// Source database file does not exist
//
#define ERROR_SRC_FILE_NOT_EXIST        (UPGRADE_SETUP_ERROR_BASE + 2)


//
// Hydra ODBC datasource not exist
//
#define ERROR_ODBC_DATASOURCE_NOTEXIST  (UPGRADE_SETUP_ERROR_BASE + 3)

//
// Invalid setup or unsupported version
//
#define ERROR_INVALID_NT4_SETUP         (UPGRADE_SETUP_ERROR_BASE + 4)

//
// Internal Error in upgrade
//
#define ERROR_INTERNAL                  (UPGRADE_SETUP_ERROR_BASE + 5)

//
// Unsupport NT4 database version, for example, beta 2
//
#define ERROR_NOTSUPPORT_DB_VERSION     (UPGRADE_SETUP_ERROR_BASE + 6)

//
// JetBlue database file exists
//
#define ERROR_JETBLUE_DBFILE_ALREADY_EXISTS (UPGRADE_SETUP_ERROR_BASE + 1)

//
// JetBlue database file exists and corrupted
//
#define ERROR_CORRUPT_JETBLUE_DBFILE        (UPGRADE_SETUP_ERROR_BASE + 2)

//
// Can't delete ODBC datasource
//
#define ERROR_DELETE_ODBC_DSN               (UPGRADE_SETUP_ERROR_BASE + 7)

//---------------------------------------------------
//
// ODBC related error code
//
//---------------------------------------------------
#define UPGRADE_ODBC_ERROR_BASE    0xD8000000

//
// General ODBC error
//
#define ERROR_ODBC_GENERAL              (UPGRADE_ODBC_ERROR_BASE + 1)

//
// ODBC class internal error
//
#define ERROR_ODBC_INTERNAL             (UPGRADE_ODBC_ERROR_BASE + 2)

//
// ODBC Record not found
//
#define ERROR_ODBC_NO_DATA_FOUND        (UPGRADE_ODBC_ERROR_BASE + 3)

//
// SQLConnect() failed.
//
#define ERROR_ODBC_CONNECT              (UPGRADE_ODBC_ERROR_BASE + 4)

//
// SQLAllocConnect() failed
//
#define ERROR_ODBC_ALLOC_CONNECT        (UPGRADE_ODBC_ERROR_BASE + 5)

//
// SQLAllocEnv() failed
//
#define ERROR_ODBC_ALLOC_ENV            (UPGRADE_ODBC_ERROR_BASE + 6)

//
// SQLAllocStmt() failed.
//
#define ERROR_ODBC_ALLOC_STMT           (UPGRADE_ODBC_ERROR_BASE + 7)

//
// SQTransact() failed on commit
//
#define ERROR_ODBC_COMMIT               (UPGRADE_ODBC_ERROR_BASE + 8)

//
// SQTransact() failed on rollback
//
#define ERROR_ODBC_ROLLBACK             (UPGRADE_ODBC_ERROR_BASE + 9)

//
// Cant' allocate ODBC handle, all handle are in use.
//
#define ERROR_ODBC_ALLOCATE_HANDLE      (UPGRADE_ODBC_ERROR_BASE + 10)

//
// SQLPrepare() failed
//
#define ERROR_ODBC_PREPARE              (UPGRADE_ODBC_ERROR_BASE + 11)

//
// Execute() failed
//
#define ERROR_ODBC_EXECUTE              (UPGRADE_ODBC_ERROR_BASE + 12)

//
// ExecDirect() failed
//
#define ERROR_ODBC_EXECDIRECT           (UPGRADE_ODBC_ERROR_BASE + 13)

//
// BindCol failed.
//
#define ERROR_ODBC_BINDCOL              (UPGRADE_ODBC_ERROR_BASE + 14)

//
// BindInputParm() failed.
//
#define ERROR_ODBC_BINDINPUTPARM        (UPGRADE_ODBC_ERROR_BASE + 15)

//
// GetData() failed.
//
#define ERROR_ODBC_GETDATA              (UPGRADE_ODBC_ERROR_BASE + 16)

//
// ParmData() failed.
//
#define ERROR_ODBC_PARMDATA             (UPGRADE_ODBC_ERROR_BASE + 17)

//
// PutData() failed.
//
#define ERROR_ODBC_PUTDATA              (UPGRADE_ODBC_ERROR_BASE + 18)

//
// Corrupted database
//
#define ERROR_ODBC_CORRUPTDATABASEFILE  (UPGRADE_ODBC_ERROR_BASE + 19)   

//
// SQLFtch() failed.
//
#define ERROR_ODBC_FETCH                (UPGRADE_ODBC_ERROR_BASE + 20)   

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\validdp\inc\validdp.h ===
// ValidateDigPid is given a Digital PID that contains a binary
// representation of the ProductKey.  It needs to validate that key
// against the static Public Key table

typedef enum {
    pkstatOk = 0,
    pkstatInvalidCrc,
    pkstatSecurityFailure,
    pkstatUnknownGroupID,
    pkstatInvalidProdKey,
    pkstatInvalidKeyLen,
    pkstatOutOfMemory,
} ProdKeyStatus;


// return value is a ProdKeyStatus (see above)
extern "C" int STDAPICALLTYPE  ValidateDigitalPid(
	PDIGITALPID pDigPid,  // [IN]  DigitalPid to validate
    PDWORD pdwSequence,   // [OUT] Sequence
    PBOOL  pfCCP);        // [OUT] upgrade flag

// return value is a PidGenError (see PidGen.h)
extern "C" DWORD STDAPICALLTYPE PIDGenStaticA(
    LPSTR   lpstrSecureCdKey,   // [IN] 25-character Secure CD-Key (gets U-Cased)
    LPCSTR  lpstrRpc,           // [IN] 5-character Release Product Code
    LPCSTR  lpstrSku,           // [IN] Stock Keeping Unit (formatted like 123-12345)
    LPCSTR  lpstrOemId,         // [IN] 4-character OEM ID or NULL
    BOOL    fOem,               // [IN] is this an OEM install?

    LPSTR   lpstrPid2,          // [OUT] PID 2.0, pass in ptr to 24 character array
    LPBYTE  lpbPid3,            // [OUT] pointer to binary PID3 buffer. First DWORD is the length
    LPDWORD lpdwSeq,            // [OUT] optional ptr to sequence number (can be NULL)
    LPBOOL  pfCCP);             // [OUT] optional ptr to Compliance Checking flag (can be NULL)

// return value is a PidGenError (see PidGen.h)
extern "C" DWORD STDAPICALLTYPE PIDGenStaticW(
    LPWSTR  lpstrSecureCdKey,   // [IN] 25-character Secure CD-Key (gets U-Cased)
    LPCWSTR lpstrRpc,           // [IN] 5-character Release Product Code
    LPCWSTR lpstrSku,           // [IN] Stock Keeping Unit (formatted like 123-12345)
    LPCWSTR lpstrOemId,         // [IN] 4-character OEM ID or NULL
    LPBYTE  lpbPublicKey,       // [IN] pointer to optional public key or NULL
    DWORD   dwcbPublicKey,      // [IN] byte length of optional public key
    DWORD   dwKeyIdx,           // [IN] key pair index optional public key
    BOOL    fOem,               // [IN] is this an OEM install?

    LPWSTR  lpstrPid2,          // [OUT] PID 2.0, pass in ptr to 24 character array
    LPBYTE  lpbPid3,            // [OUT] pointer to binary PID3 buffer. First DWORD is the length
    LPDWORD lpdwSeq,            // [OUT] optional ptr to sequence number (can be NULL)
    LPBOOL  pfCCP);             // [OUT] optional ptr to Compliance Checking flag (can be NULL)

#ifdef UNICODE
    #define PIDGenStatic PIDGenStaticW
#else
    #define PIDGenStatic PIDGenStaticA
#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\upg4to5\upgdef.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        upgdef.h
//
// Contents:
//
// History:
//
//---------------------------------------------------------------------------
#ifndef __TLSUPG4TO5DEF_H__
#define __TLSUPG4TO5DEF_H__

#ifdef __cplusplus
extern "C" {
#endif

void
__cdecl
DBGPrintf(
    LPTSTR format, ...
);


BOOL
IsDataSourceInstalled(
    LPTSTR szDataSource,
    unsigned short wConfigMode,
    LPTSTR szDbFile,
    DWORD cbBufSize
);


BOOL
ConfigDataSource(
    HWND     hWnd,
    BOOL     bInstall,
    LPTSTR   szDriver,
    LPTSTR   szDsn,
    LPTSTR   szUser,
    LPTSTR   szPwd,
    LPTSTR   szMdbFile
);

BOOL
RepairDataSource(
    HWND     hWnd,
    LPTSTR   pszDriver,
    LPTSTR   pszDsn,
    LPTSTR   pszUser,
    LPTSTR   pszPwd,
    LPTSTR   pszMdbFile
);


BOOL
FileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData
);

DWORD
GetNT4DbConfig(
    LPTSTR pszDsn,
    LPTSTR pszUserName,
    LPTSTR pszPwd,
    LPTSTR pszMdbFile
);

void
CleanLicenseServerSecret();

DWORD
DeleteNT4ODBCDataSource();

DWORD
MigrateLsaSecrets();

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\place32.inc ===
#
#  Places all of the tshare client binaries into the tshrclnt tree
#

BINPLACE_PLACEFILE=$(TSHRCLNT_ROOT)\Placefil.txt

_TSHRCLNT_TREE=TSClient

!ifdef _NTX86TREE
!if [if not exist $(_NTX86TREE)\$(_TSHRCLNT_TREE) mkdir $(_NTX86TREE)\$(_TSHRCLNT_TREE)]
!endif
!if [if not exist $(_NTX86TREE)\$(_TSHRCLNT_TREE)\win32 mkdir $(_NTX86TREE)\$(_TSHRCLNT_TREE)\win32]
!endif
!if [if not exist $(_NTX86TREE)\$(_TSHRCLNT_TREE)\win32\i386 mkdir $(_NTX86TREE)\$(_TSHRCLNT_TREE)\win32\i386]
!endif
_NTX86TREE=$(_NTX86TREE)\$(_TSHRCLNT_TREE)\win32\i386
_NTTREE=$(_NTX86TREE)
!endif

!ifdef _NTAMD64TREE
!if [if not exist $(_NTAMD64TREE)\$(_TSHRCLNT_TREE) mkdir $(_NTAMD64TREE)\$(_TSHRCLNT_TREE)]
!endif
!if [if not exist $(_NTAMD64TREE)\$(_TSHRCLNT_TREE)\win32 mkdir $(_NTAMD64TREE)\$(_TSHRCLNT_TREE)\win32]
!endif
!if [if not exist $(_NTAMD64TREE)\$(_TSHRCLNT_TREE)\win32\AMD64 mkdir $(_NTAMD64TREE)\$(_TSHRCLNT_TREE)\win32\AMD64]
!endif
_NTAMD64TREE=$(_NTAMD64TREE)\$(_TSHRCLNT_TREE)\win32\AMD64
_NTTREE=$(_NTAMD64TREE)
!endif

!ifdef _NTIA64TREE
!if [if not exist $(_NTIA64TREE)\$(_TSHRCLNT_TREE) mkdir $(_NTIA64TREE)\$(_TSHRCLNT_TREE)]
!endif
!if [if not exist $(_NTIA64TREE)\$(_TSHRCLNT_TREE)\win32 mkdir $(_NTIA64TREE)\$(_TSHRCLNT_TREE)\win32]
!endif
!if [if not exist $(_NTIA64TREE)\$(_TSHRCLNT_TREE)\win32\ia64 mkdir $(_NTIA64TREE)\$(_TSHRCLNT_TREE)\win32\ia64]
!endif
_NTIA64TREE=$(_NTIA64TREE)\$(_TSHRCLNT_TREE)\win32\ia64
_NTTREE=$(_NTIA64TREE)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\autocmpl.h ===
//
// autocmpl.h: provides server autocomplete functionality to an edit box
//
// Copyright Microsoft Corporation 2000
//

#ifndef _autocmpl_h_
#define _autocmpl_h_

#include "sh.h"

class CAutoCompl
{
public:
    static HRESULT EnableServerAutoComplete(CTscSettings* pTscSet, HWND hwndEdit);
};

#endif //_autocmpl_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\aboutdlg.h ===
//
// aboutdlg.h: about dialog class
//

#ifndef _aboutdlg_h_
#define _aboutdlg_h_

#include "dlgbase.h"
#include "sh.h"

class CAboutDlg : public CDlgBase
{
public:
    CAboutDlg(HWND hwndOwner, HINSTANCE hInst, DCINT cipherStrength, PDCTCHAR szControlVer);
    ~CAboutDlg();

    virtual DCINT   DoModal();
    virtual INT_PTR CALLBACK DialogBoxProc(HWND hwndDlg, UINT uMsg,WPARAM wParam, LPARAM lParam);
    static  INT_PTR CALLBACK StaticDialogBoxProc(HWND hwndDlg, UINT uMsg,WPARAM wParam, LPARAM lParam);

    static CAboutDlg* _pAboutDlgInstance;
    
private:
    DCINT _cipherStrength;
    DCTCHAR _szControlVer[SH_DISPLAY_STRING_MAX_LENGTH];
};


#endif //_aboutdlg_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\axhostwnd.cpp ===
//
// axhostwnd.cpp: ActiveX control host window
//             (For ts activeX control)
//
// Copyright Microsoft Corportation 2000
// (nadima)
//

#include "stdafx.h"

#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "axhostwnd.cpp"
#include <atrcapi.h>

#define TSC_AX_HOSTWND_CLS TEXT("TSCAXHOST")
#define TSC_CONTROL_DLL    TEXT("mstscax.dll")

#include "axhostwnd.h"
#ifndef OS_WINCE
#include "ntverp.h"
#else
#include "ceconfig.h"
#endif

CAxHostWnd::CAxHostWnd(CContainerWnd*  pParentWnd) : _pParentWnd(pParentWnd)
{
    DC_BEGIN_FN("CAxHostWnd");

    _hWnd = NULL;
    _pTsc = NULL;
    _cRef = 1;
    _hLib = NULL;
    _piEventSink = NULL;
    _piOleClientSite = NULL;
    _piOleInPlaceSiteEx = NULL;
    _piOleObject = NULL;
    _piOleInPlaceActiveObject = NULL;
    _piOleInPlaceObject = NULL;
    _dwConCookie = 0;
    TRC_ASSERT(_pParentWnd,(TB,_T("_pParentWnd not set")));

    DC_END_FN();
}

CAxHostWnd::~CAxHostWnd()
{
    DC_BEGIN_FN("~CAxHostWnd");

    TRC_ASSERT(_piEventSink == NULL,(TB,_T("Exit without cleanup")));
    TRC_ASSERT(_piOleClientSite == NULL,(TB,_T("Exit without cleanup")));
    TRC_ASSERT(_piOleInPlaceSiteEx == NULL,(TB,_T("Exit without cleanup")));
    TRC_ASSERT(_piOleObject == NULL,(TB,_T("Exit without cleanup")));
    TRC_ASSERT(_piOleInPlaceActiveObject == NULL,(TB,_T("Exit without cleanup")));
    TRC_ASSERT(_piOleInPlaceObject == NULL,(TB,_T("Exit without cleanup")));
    TRC_ASSERT(_pTsc == NULL,(TB,_T("Exit without cleanup")));

    DC_END_FN();
}

STDMETHODIMP CAxHostWnd::QueryInterface( REFIID riid, void ** ppv )
{
    DC_BEGIN_FN("QueryInterface");

    TRC_ASSERT(ppv != NULL,(TB,_T("ppv null")));
    TRC_ASSERT(_piOleClientSite != NULL,
               (TB,_T("QI needs IOleClientSite object")));
    TRC_ASSERT(_piOleInPlaceSiteEx != NULL,
               (TB,_T("QI needs _piOleInPlaceSiteEx object")));

    if (ppv)
    {
        *ppv = NULL;
    }
    else
    {
        return E_INVALIDARG;
    }

    if (IID_IUnknown == riid)
        *ppv = this;
    else if (IID_IOleClientSite == riid)
        *ppv = (void *)_piOleClientSite;
    else if (IID_IOleInPlaceSiteEx == riid)
        *ppv = (void *)_piOleInPlaceSiteEx;

    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    DC_END_FN();
    return ResultFromScode(E_NOINTERFACE); 
}


STDMETHODIMP_(ULONG) CAxHostWnd::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}


STDMETHODIMP_(ULONG) CAxHostWnd::Release(void)
{
    if (0L != InterlockedDecrement(&_cRef))
    {
        return _cRef;
    }

    delete this;
    return 0L;
} 

CAxHostWnd::Init()
{
    DC_BEGIN_FN("Init");

    _piOleClientSite = new COleClientSite((IUnknown *)this);
    if (!_piOleClientSite)
    {
        Cleanup();
        return FALSE;
    }
    _piOleClientSite->AddRef();

    _piOleInPlaceSiteEx = new COleInPlaceSiteEx((IUnknown *)this);
    if (!_piOleInPlaceSiteEx)
    {
        Cleanup();
        return FALSE;
    }
    _piOleInPlaceSiteEx->AddRef();

    DC_END_FN();
    return TRUE;
}

//
// Create the child window that directly hosts the control
//
BOOL CAxHostWnd::CreateHostWnd(HWND hwndParent, HINSTANCE hInst)
{
    DC_BEGIN_FN("CreateHostWnd");

#ifndef OS_WINCE
    WNDCLASSEX wndclass;
#else
    WNDCLASS wndclass;
#endif
    int hr = GetLastError();
#ifndef OS_WINCE
    wndclass.cbSize         = sizeof (wndclass);
#endif
    wndclass.style          = 0;
    wndclass.lpfnWndProc    = CAxHostWnd::StaticAxHostWndProc;
    wndclass.cbClsExtra     = 0;
    wndclass.cbWndExtra     = 0;
    wndclass.hInstance      = hInst;
    wndclass.hIcon          = NULL;
    wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground  = (HBRUSH) GetStockObject(NULL_BRUSH);
    wndclass.lpszMenuName   = NULL;
    wndclass.lpszClassName  = TSC_AX_HOSTWND_CLS;
#ifndef OS_WINCE
    wndclass.hIconSm        = NULL;
#endif

#ifndef OS_WINCE
    if ((0 == RegisterClassEx(&wndclass)) &&
#else
    if ((0 == RegisterClass(&wndclass)) &&
#endif
        (ERROR_CLASS_ALREADY_EXISTS != GetLastError()))
    {
        TRC_ERR((TB,_T("RegisterClassEx failed: %d"),GetLastError()));
        return FALSE;
    }
    RECT rc;
    GetClientRect(hwndParent, &rc);

    _hWnd = CreateWindow(TSC_AX_HOSTWND_CLS,
                         NULL,
                         WS_CHILD,
                         0,
                         0,
                         rc.right - rc.left,
                         rc.bottom - rc.top,
                         hwndParent,
                         NULL,
                         hInst,
                         this);
    if (_hWnd)
    {
        // put a reference to the current object into the hwnd
        // so we can access the object from the WndProc
        SetWindowLongPtr(_hWnd, GWLP_USERDATA, (LONG_PTR)this);

        // put the newly created hwnd into the client site objects also
        TRC_ASSERT(_piOleInPlaceSiteEx,
                   (TB,_T("Don't create window until container is created")));
        TRC_ASSERT(_pTsc && _piEventSink,
                   (TB,_T("Shouldn't create window until Control is instantiated")));

        if (_piOleInPlaceSiteEx)
        {
            _piOleInPlaceSiteEx->SetHwnd(_hWnd);
        }
        //
        // Show the control
        //
        hr = _piOleObject->DoVerb(OLEIVERB_PRIMARY,
                                  NULL,
                                  _piOleClientSite,
                                  0,
                                  _hWnd, &rc);
        TRC_ASSERT(SUCCEEDED(hr),(TB,_T("DoVerb OLEIVERB_PRIMARY failed: %d"),hr));
        if(SUCCEEDED(hr))
        {
            ShowWindow(_hWnd, SW_SHOWNORMAL);
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        TRC_ERR((TB,_T("CreateHost wnd failed")));
        return FALSE;
    }

    DC_END_FN();
}

//
// return one of 
// AXHOST_SUCCESS,
// ERR_AXHOST_DLLNOTFOUND,
// ERR_AXHOST_VERSIONMISMATCH
// ERR_AXHOST_ERROR
// so caller can display appropriate error msg
//
INT CAxHostWnd::CreateControl(IMsRdpClient** ppTscCtl)
{
    DC_BEGIN_FN("CreateControl");

    LPFNGETTSCCTLVER   pfnDllGetTscCtlVer   = NULL;
    LPFNGETCLASSOBJECT pfnDllGetClassObject = NULL;
    IClassFactory *piClassFactory = NULL;
    IConnectionPointContainer *piConnectionPointContainer = NULL;
    IConnectionPoint *piConnectionPoint = NULL;

    TRC_ASSERT(ppTscCtl,(TB,_T("ppTscCtl param is null")));
    if(!ppTscCtl)
    {
        return ERR_AXHOST_ERROR;
    }

    // get an interface to the control without CoCreateInstance
    _hLib = LoadLibrary(TSC_CONTROL_DLL);
    if (_hLib == NULL)
    {
        TRC_ABORT((TB, _T("LoadLibrary of the control failed")));
        return ERR_AXHOST_DLLNOTFOUND;
    }

    //
    // First do a version check to ensure ctl and shell match
    //
    pfnDllGetTscCtlVer = (LPFNGETTSCCTLVER)GetProcAddress(_hLib,
                                    CE_WIDETEXT("DllGetTscCtlVer"));
    if(NULL == pfnDllGetTscCtlVer)
    {
        TRC_ABORT((TB, _T("GetProcAddress (DllGetTscCtlVer) failed")));
        return ERR_AXHOST_ERROR;
    }
    DWORD dwCtlVer = pfnDllGetTscCtlVer();
    #ifndef OS_WINCE
    DWORD dwShellVer = VER_PRODUCTVERSION_DW;
    #else
    DWORD dwShellVer = CE_TSC_BUILDNO;
    #endif
    
    TRC_ASSERT(dwShellVer == dwCtlVer,
               (TB,_T("Control and shell versions do not match")));
    if(dwShellVer != dwCtlVer)
    {
        return ERR_AXHOST_VERSIONMISMATCH;
    }


    pfnDllGetClassObject = (LPFNGETCLASSOBJECT)GetProcAddress(_hLib,
                                         CE_WIDETEXT("DllGetClassObject"));
    if (NULL == pfnDllGetClassObject)
    {
        TRC_ABORT((TB, _T("GetProcAddress failed")));
        return ERR_AXHOST_ERROR;
    }

    if (FAILED(pfnDllGetClassObject(CLSID_MsRdpClient, IID_IClassFactory,
                                                  (void **)&piClassFactory)))
    {
        TRC_ABORT((TB, _T("pfnDllGetClassObject failed")));
        return ERR_AXHOST_ERROR;
    }

    if (FAILED(piClassFactory->CreateInstance(NULL, IID_IMsRdpClient,
                                                  (void **)&_pTsc)))
    {
        piClassFactory->Release();
        TRC_ERR((TB, _T("CreateInstance failed")));
        return ERR_AXHOST_ERROR;
    }
    piClassFactory->Release();

    // set up our notification event sink
    if (FAILED(_pTsc->QueryInterface(IID_IConnectionPointContainer,
                                 (void **)&piConnectionPointContainer)))
    {
        TRC_ABORT((TB, _T("Couldn't find IConnectionPointContainer")));
        return ERR_AXHOST_ERROR;
    }

    if (FAILED(piConnectionPointContainer->FindConnectionPoint(
        DIID_IMsTscAxEvents,
        &piConnectionPoint)))
    {
        piConnectionPointContainer->Release();
        TRC_ABORT((TB, _T("Couldn't find ConnectionPoint for Event Sink")));
        return ERR_AXHOST_ERROR;
    }

    piConnectionPointContainer->Release();

    _piEventSink = new CEventSink(_pParentWnd);
    if (!_piEventSink)
    {
        piConnectionPoint->Release();
        TRC_ABORT((TB, _T("Unable to create event sink")));
        return ERR_AXHOST_ERROR;
    }
    _piEventSink->AddRef();

    if (FAILED(piConnectionPoint->Advise((IUnknown *)_piEventSink,
                                          &_dwConCookie)))
    {
        piConnectionPoint->Release();

        //
        // we have to release and clean up this pointer here in case of failure
        // because cleanup code assumes that existence of this pointer means
        // successful advise, and it tries to do the full Unadvise business in
        // that case

        _piEventSink->Release();
        _piEventSink = NULL;

        TRC_ABORT((TB, _T("Unable to advise ConnectionPoint of Event Sink")));
        return ERR_AXHOST_ERROR;
    }

    piConnectionPoint->Release();

    if ((FAILED(_pTsc->QueryInterface(IID_IOleObject, (void **)&_piOleObject))) ||
        (FAILED(_pTsc->QueryInterface(IID_IOleInPlaceActiveObject,
                                      (void **)&_piOleInPlaceActiveObject))))
    {
        TRC_ABORT((TB, _T("QI for IOleObject and IOleInPlaceObject failed")));
        return ERR_AXHOST_ERROR;
    }

    if((FAILED(_pTsc->QueryInterface(IID_IOleInPlaceObject,
                                     (void **)&_piOleInPlaceObject))))
    {
        TRC_ABORT((TB, _T("QI for IID_IOleInPlaceObject failed")));
        return ERR_AXHOST_ERROR;
    }

    if (FAILED(_piOleObject->SetClientSite(_piOleClientSite)))
    {
        TRC_ABORT((TB, _T("Couldn't Set Client Site")));
        return ERR_AXHOST_ERROR;
    }

    *ppTscCtl = _pTsc;
    _pTsc->AddRef();

    DC_END_FN();
    return AXHOST_SUCCESS;
}

BOOL CAxHostWnd::Cleanup()
{
    DC_BEGIN_FN("Cleanup");

    if (_piEventSink)
    {
        TRC_ASSERT(_pTsc, (TB,_T("Event sink can't exist without tsc pointer!")));
        if (_pTsc)
        {
            IConnectionPointContainer *piConnectionPointContainer = NULL;
            IConnectionPoint *piConnectionPoint = NULL;

            if (FAILED(_pTsc->QueryInterface(IID_IConnectionPointContainer,
                                          (void **)&piConnectionPointContainer)))
            {
                TRC_ABORT((TB,_T("Couldn't find IConnectionPointContainer")));
            }
            else
            {
                if (FAILED(piConnectionPointContainer->FindConnectionPoint(
                                                      DIID_IMsTscAxEvents,
                                                      &piConnectionPoint)))
                {
                    TRC_ABORT((TB,_T("Couldn't find connection point for ev sink")));
                }
                else
                {
                    if (FAILED(piConnectionPoint->Unadvise(_dwConCookie)))
                    {
                        TRC_ERR((TB,_T("Unadvise connection point failed!")));
                    }
                    piConnectionPoint->Release();
                }
                piConnectionPointContainer->Release();
            }
        }
		_piEventSink->Release();
		_piEventSink = NULL;
    }

    if (_piOleInPlaceActiveObject)
        _piOleInPlaceActiveObject->Release();
    if (_piOleObject)
        _piOleObject->Release();
    if (_pTsc)
        _pTsc->Release();
    if (_piOleInPlaceSiteEx)
        _piOleInPlaceSiteEx->Release();
    if (_piOleClientSite)
        _piOleClientSite->Release();
    if(_piOleInPlaceObject)
        _piOleInPlaceObject->Release();

    if (_hWnd && IsWindow(_hWnd))
        DestroyWindow(_hWnd);

    _piEventSink = NULL;
    _piOleInPlaceSiteEx = NULL;
    _piOleClientSite = NULL;
    _pTsc = NULL;
    _piOleObject = NULL;
    _piOleInPlaceActiveObject = NULL;
    _piOleInPlaceObject = NULL;

    if (_hLib)
    {
        LPFNCANUNLOADNOW pfnDllCanUnloadNow = (LPFNCANUNLOADNOW)
                        GetProcAddress(_hLib, CE_WIDETEXT("DllCanUnloadNow"));
        if (pfnDllCanUnloadNow == NULL)
        {
            TRC_ABORT((TB,_T("GetProcAddress failed")));
            FreeLibrary(_hLib);
        }
		else
		{
			if (S_OK == pfnDllCanUnloadNow())
			{
				FreeLibrary(_hLib);
			}
			else
			{
				TRC_ABORT((TB,_T("Library not ready for unloading @ cleanup time")));
			}
		}
    }

    _hLib = NULL;

    DC_END_FN();
    return TRUE;
}

HWND CAxHostWnd::GetHwnd()
{
    DC_BEGIN_FN("GetHwnd");

    DC_END_FN();
    return _hWnd;
}

IMsRdpClient* CAxHostWnd::GetTscCtl()
{
    DC_BEGIN_FN("GetTscCtl");
    if (_pTsc)
    {
        _pTsc->AddRef();
        return _pTsc;
    }

    DC_END_FN();
    return NULL;
}

LRESULT CALLBACK CAxHostWnd::StaticAxHostWndProc(HWND hwnd,
                                                 UINT uMsg,
                                                 WPARAM wParam,
                                                 LPARAM lParam)
{
    DC_BEGIN_FN("StaticAxHostWndProc");

	// pull out the pointer to the container object associated with this hwnd
	CAxHostWnd *piAxHst = (CAxHostWnd *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if(piAxHst)
    {
        return piAxHst->AxHostWndProc( hwnd, uMsg, wParam, lParam);
    }
    else
    {
        return DefWindowProc (hwnd, uMsg, wParam, lParam);
    }

    DC_END_FN();
}

LRESULT CALLBACK CAxHostWnd::AxHostWndProc(HWND hwnd,
                                           UINT uMsg,
                                           WPARAM wParam,
                                           LPARAM lParam)
{
    DC_BEGIN_FN("AxHostWndProc");

    //
    // Reflect appropriate messages to control
    //
    switch (uMsg)
    {
#ifndef OS_WINCE
        case WM_ACTIVATEAPP:
        {
            _piOleInPlaceActiveObject->OnFrameWindowActivate((BOOL)wParam);
        }
        break;
#endif

        case WM_SETFOCUS:
        {
            HWND hwndObj;
            _piOleInPlaceActiveObject->GetWindow(&hwndObj);
            SetFocus(hwndObj);
        }
        break;

        case WM_PALETTECHANGED:     // intentional fallthru
        case WM_QUERYNEWPALETTE:    // intentional fallthru
        case WM_SYSCOLORCHANGE:
        {
            HWND hwndObj;
            //
            // Forward the message directly to the control
            //
            if (_piOleInPlaceActiveObject)
            {
                _piOleInPlaceActiveObject->GetWindow(&hwndObj);
                SendMessage(hwndObj, uMsg, wParam, lParam);
            }
            return 1;
        }
        break;

        case WM_SIZE:
        {
            int nWidth = LOWORD(lParam);
            int nHeight = HIWORD(lParam);
            RECT rcPos;
            rcPos.bottom = nHeight;
            rcPos.right  = nWidth;
            rcPos.left   = 0;
            rcPos.top    = 0;
            if(_piOleInPlaceObject)
                _piOleInPlaceObject->SetObjectRects(&rcPos,&rcPos);
            HWND hwndObj;
            _piOleInPlaceActiveObject->GetWindow(&hwndObj);
            SendMessage(hwndObj, WM_SIZE, wParam, lParam);
            return 0;
        }
        break;

        default:
        {
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
        }
        break;
    }

    DC_END_FN();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\aboutdlg.cpp ===
//
// aboutdlg.cpp: about dialog box
//

#include "stdafx.h"

#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "aboutdlg"
#include <atrcapi.h>

#include "aboutdlg.h"
#include "sh.h"

#include "aver.h"

CAboutDlg* CAboutDlg::_pAboutDlgInstance = NULL;

CAboutDlg::CAboutDlg( HWND hwndOwner, HINSTANCE hInst,  DCINT cipherStrength, PDCTCHAR szControlVer) :
           CDlgBase( hwndOwner, hInst, UI_IDD_ABOUT)
{
    DC_BEGIN_FN("CAboutDlg");
    TRC_ASSERT((NULL == CAboutDlg::_pAboutDlgInstance), 
               (TB,_T("Clobbering existing dlg instance pointer\n")));

    _cipherStrength = cipherStrength;
    DC_TSTRNCPY(_szControlVer, szControlVer, sizeof(_szControlVer)/sizeof(DCTCHAR));

    CAboutDlg::_pAboutDlgInstance = this;
    DC_END_FN();
}

CAboutDlg::~CAboutDlg()
{
    CAboutDlg::_pAboutDlgInstance = NULL;
}

DCINT CAboutDlg::DoModal()
{
    DCINT retVal = 0;
    DC_BEGIN_FN("DoModal");

    retVal = DialogBox(_hInstance, MAKEINTRESOURCE(_dlgResId),
                       _hwndOwner, StaticDialogBoxProc);
    TRC_ASSERT((retVal != 0 && retVal != -1), (TB, _T("DialogBoxParam failed\n")));

    DC_END_FN();
    return retVal;
}

INT_PTR CALLBACK CAboutDlg::StaticDialogBoxProc (HWND hwndDlg, UINT uMsg,WPARAM wParam, LPARAM lParam)
{
    //
    // Delegate to appropriate instance (only works for single instance dialogs)
    //
    DC_BEGIN_FN("StaticDialogBoxProc");
    DCINT retVal = 0;

    TRC_ASSERT(_pAboutDlgInstance, (TB, _T("About dialog has NULL static instance ptr\n")));
    if(_pAboutDlgInstance)
    {
        retVal = _pAboutDlgInstance->DialogBoxProc( hwndDlg, uMsg, wParam, lParam);
    }

    DC_END_FN();
    return retVal;
}

/****************************************************************************/
/* Name: DialogBoxProc                                                      */
/*                                                                          */
/* Purpose: Handles About Box dialog                                        */
/*                                                                          */
/* Returns: TRUE if message dealt with                                      */
/*          FALSE otherwise                                                 */
/*                                                                          */
/* Params: See window documentation                                         */
/*                                                                          */
/****************************************************************************/
INT_PTR CALLBACK CAboutDlg::DialogBoxProc (HWND hwndDlg, UINT uMsg,WPARAM wParam, LPARAM lParam)
{
    USES_CONVERSION;
    DCTCHAR buildNumberStr[SH_BUILDNUMBER_STRING_MAX_LENGTH];
    DCTCHAR fullBuildNumberStr[SH_BUILDNUMBER_STRING_MAX_LENGTH +
                                   SH_INTEGER_STRING_MAX_LENGTH];

    DCTCHAR versionNumberStr[SH_VERSION_STRING_MAX_LENGTH];
    DCTCHAR fullVersionNumberStr[SH_VERSION_STRING_MAX_LENGTH +
                                   SH_INTEGER_STRING_MAX_LENGTH];

    DCTCHAR cipherStrengthStr[SH_DISPLAY_STRING_MAX_LENGTH];

    INT_PTR rc = FALSE;
    DCUINT intRC ;
    DCTCHAR VersionBuildstr[SH_BUILDNUMBER_STRING_MAX_LENGTH + SH_VERSION_STRING_MAX_LENGTH +
                                  2 * SH_INTEGER_STRING_MAX_LENGTH];

    DC_BEGIN_FN("DialogBoxProc");

    TRC_DBG((TB, _T("AboutBox dialog")));

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            _hwndDlg = hwndDlg;
            /****************************************************************/
            /* Center the dialog                                            */
            /****************************************************************/
            //Center the about dialog on the screen
            CenterWindow(NULL);
            SetDialogAppIcon(hwndDlg);

            //
            // First load the shell version number
            //
            intRC = LoadString( _hInstance,
                                UI_IDS_SHELL_VERSION,
                                versionNumberStr,
                                SH_VERSION_STRING_MAX_LENGTH );

#ifndef OS_WINCE
            LPTSTR szShellVersion = A2T(VER_PRODUCTVERSION_STRING);
#else
            LPTSTR szShellVersion = _T("SAMPLE v1.0");
#endif
            if (0 == intRC)
            {
                //Problem with resources
                TRC_SYSTEM_ERROR("LoadString");
                TRC_ERR((TB, _T("Failed to load string ID:%u"), UI_IDS_SHELL_VERSION));
            }
            else
            {
                //Get the version number
                if(szShellVersion)
                {
                    DC_TSPRINTF(fullVersionNumberStr, versionNumberStr,
                                szShellVersion);
                }
                else
                {
                    DC_TSTRCPY(fullVersionNumberStr, _T(""));
                }

                TRC_DBG((TB, _T("versionNumberStr = %s"), versionNumberStr));
            }

            intRC = LoadString( _hInstance,
                                UI_IDS_BUILDNUMBER,
                                buildNumberStr,
                                SH_BUILDNUMBER_STRING_MAX_LENGTH );

            if (0 == intRC)
            {
                //Problem with resources
                TRC_SYSTEM_ERROR("LoadString");
                TRC_ERR((TB, _T("Failed to load string ID:%u"), UI_IDS_BUILDNUMBER));
            }
            else
            {
                /************************************************************/
                /* Get the build number                                     */
                /************************************************************/
                DC_TSPRINTF(fullBuildNumberStr, buildNumberStr, DCVER_BUILD_NUMBER);

                TRC_DBG((TB, _T("buildNumberStr = %s"), buildNumberStr));

                /************************************************************/
                /* concatenate the version number and build number to one   */
                /* string                                                   */
                /************************************************************/
                DC_TSTRCPY(VersionBuildstr, fullVersionNumberStr);
                DC_TSTRCAT(VersionBuildstr, fullBuildNumberStr);

                /************************************************************/
                /* Set the textual description.                             */
                /************************************************************/
                if(hwndDlg)
                {
                    SetDlgItemText(hwndDlg,
                                   UI_ID_VERSIONBUILD_STRING,
                                   VersionBuildstr);
                }
            }

            //
            // Now the control version
            //
            intRC = LoadString( _hInstance,
                    UI_IDS_CONTROL_VERSION,
                    versionNumberStr,
                    SH_VERSION_STRING_MAX_LENGTH );

            if (0 == intRC)
            {
                 /***********************************************************/
                 /* Some problem with the resources.                        */
                 /***********************************************************/
                 TRC_SYSTEM_ERROR("LoadString");
                 TRC_ERR((TB, _T("Failed to load string ID:%u"), UI_IDS_CONTROL_VERSION));
            }
            else
            {
                /************************************************************/
                /* Get the version number                                   */
                /************************************************************/
                DC_TSPRINTF(fullVersionNumberStr, versionNumberStr,  _szControlVer);
                TRC_DBG((TB, _T("versionNumberStr = %s"), versionNumberStr));
            }

            if(hwndDlg)
            {
                SetDlgItemText(hwndDlg,
                               UI_ID_CONTROL_VERSION,
                               fullVersionNumberStr);
            }


            //
            // Now set the cipher strength
            //
            intRC = LoadString( _hInstance,
                    UI_IDS_CIPHER_STRENGTH,
                    cipherStrengthStr,
                    SH_DISPLAY_STRING_MAX_LENGTH );

            DCTCHAR fullCipherStr[SH_DISPLAY_STRING_MAX_LENGTH];
            if (0 == intRC)
            {
                 /***********************************************************/
                 /* Some problem with the resources.                        */
                 /***********************************************************/
                 TRC_SYSTEM_ERROR("LoadString");
                 TRC_ERR((TB, _T("Failed to load string ID:%u"), UI_IDS_CIPHER_STRENGTH));
            }
            else
            {
                /************************************************************/
                /* Set the cipher strength number                           */
                /************************************************************/
                DC_TSPRINTF(fullCipherStr, cipherStrengthStr,  _cipherStrength);
                TRC_DBG((TB, _T("cipher string = %s"), fullCipherStr));
            }

            if(hwndDlg)
            {
                SetDlgItemText(hwndDlg,
                               UI_ID_CIPHER_STRENGTH,
                               fullCipherStr);
            }





            rc = TRUE;
        }
        break;

        default:
        {
            rc = CDlgBase::DialogBoxProc(hwndDlg,
                                      uMsg,
                                      wParam,
                                      lParam);
        }
        break;

    }

    DC_END_FN();

    return(rc);

} /* UIAboutDialogBox */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\autocmpl.cpp ===
//
// autocmpl.cpp: provides autocomplete functionality to and edit box
//
// Copyright Microsoft Corporation 2000
//
// nadima

#include "stdafx.h"

#ifndef OS_WINCE

#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "proplocalres"
#include <atrcapi.h>

#include "autocmpl.h"

#include "enumsrvmru.h"
#include "shldisp.h"
#include "shlguid.h"
#include "sh.h"


HRESULT CAutoCompl::EnableServerAutoComplete(CTscSettings* pTscSet, HWND hwndEdit)
{
    DC_BEGIN_FN("EnableAutoComplete");
    HRESULT hr = E_FAIL;
    IAutoComplete* pac = NULL;
    IAutoComplete2* pac2 = NULL;
    IUnknown* punkSource = NULL;
    CEnumSrvMru* penSrvMru = NULL;

    if(!pTscSet || !hwndEdit)
    {
        return E_INVALIDARG;
    }

    //
    // Enable server autocomplete on the edit box
    // this invloves setting up a custom autocomplete source
    //
    
    hr = CoCreateInstance(CLSID_AutoComplete, NULL, CLSCTX_INPROC_SERVER,
                     IID_IAutoComplete, (LPVOID*)&pac);
    if(FAILED(hr))
    {
        TRC_ERR((TB,(_T("create CLSID_AutoComplete failed"))));
        DC_QUIT;
    }

    hr = pac->QueryInterface(IID_IAutoComplete2, (LPVOID*)&pac2);
    if(FAILED(hr))
    {
        TRC_ERR((TB,_T("QI for IID_IAutoComplete2 failed 0x%x"),
                hr));

        //
        // It is CRITICAL to bail out of we can't get this interface
        // because lower platforms seem to mess up completely
        // and corrupt everything if they don't have the full support
        // for IAutoComplete2.
        //
        DC_QUIT;
    }

    //
    // Create custom autocomplete source
    //
    penSrvMru = new CEnumSrvMru(); 
    if(!penSrvMru)
    {
        hr = E_OUTOFMEMORY;
        DC_QUIT;
    }
    if(!penSrvMru->InitializeFromTscSetMru( pTscSet))
    {
        TRC_ERR((TB,(_T("InitializeFromTscSetMru failed"))));
        hr = E_FAIL;
        DC_QUIT;
    }

    hr = penSrvMru->QueryInterface(IID_IUnknown, (void**) &punkSource);
    if(FAILED(hr))
    {
        TRC_ERR((TB,(_T("QI custom autocomplete src for IUnknown failed"))));
        DC_QUIT;
    }
    //We're done with penSrvMru we'll just use the IUnknown interface
    //from now one
    penSrvMru->Release();
    penSrvMru = NULL;

    hr  = pac->Init( hwndEdit, punkSource, NULL, NULL);
    if(FAILED(hr))
    {
        TRC_ERR((TB,(_T("Autocomplete Init failed"))));
        DC_QUIT;
    }

    hr = pac2->SetOptions(ACO_AUTOSUGGEST | ACO_AUTOAPPEND);
    if(FAILED(hr))
    {
        TRC_ERR((TB,_T("IAutoComplete2::SetOptions failed 0x%x"),
                hr));
        DC_QUIT;
    }

    //Success
    TRC_NRM((TB,(_T("Autocomplete Init SUCCEEDED"))));
    hr = S_OK;

DC_EXIT_POINT:
    DC_END_FN();
    if(pac2)
    {
        pac2->Release();
        pac2 = NULL;
    }
    if(pac)
    {
        pac->Release();
        pac = NULL;
    }
    if(penSrvMru)
    {
        penSrvMru->Release();
        penSrvMru = NULL;
    }
    if(punkSource)
    {
        punkSource->Release();
        punkSource = NULL;
    }
    return hr;
}

#endif //OS_WINCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\browsedlg.cpp ===
//
//browsedlg.cpp: browse for servers dialog
//
#include "stdafx.h"

#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "browsesrv"
#include <atrcapi.h>


#include "browsedlg.h"
#include "resource.h"

#include "wuiids.h"



CBrowseDlg* CBrowseDlg::m_pThis = NULL;
CBrowseDlg::CBrowseDlg(HWND hWndOwner, HINSTANCE hInst) : m_hWnd(hWndOwner), m_hInst(hInst)
{
	m_pThis = this;
    _pBrowseSrvCtl = NULL;
    _tcscpy( m_szServer, _T(""));
}

CBrowseDlg::~CBrowseDlg()
{
}

int
CBrowseDlg::DoModal()
{
	int retVal;

    //
    // Init owner draw servers list box
    //
    _pBrowseSrvCtl = new CBrowseServersCtl(m_hInst);
    if(!_pBrowseSrvCtl)
    {
        return 0;
    }
    
    _pBrowseSrvCtl->AddRef();
    
	retVal = DialogBox( m_hInst,MAKEINTRESOURCE(IDD_DIALOG_BROWSESERVERS),
                        m_hWnd, StaticDlgProc);

    //Object self deletes when refcount reaches 0
    //done so object is still around if list box population thread is still running
    _pBrowseSrvCtl->Release();

	return retVal;
}

INT_PTR CALLBACK CBrowseDlg::StaticDlgProc(HWND hDlg,UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	//
	// need access to class variables so redirect to non-static version of callback
	//
	return m_pThis->DlgProc(hDlg,uMsg,wParam,lParam);
}

INT_PTR
CBrowseDlg::DlgProc(HWND hwndDlg,UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    DC_BEGIN_FN("DlgProc");

    BOOL rc = FALSE;
    static ServerListItem *plbi = NULL;
    static HANDLE hThread = NULL;
    static DCUINT DomainCount = 0;

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            //Set the parent dialog handle of the browse for servers listbox
            _pBrowseSrvCtl->SetDialogHandle( hwndDlg);

            _pBrowseSrvCtl->Init( hwndDlg );

            if(hwndDlg)
            {
                DWORD dwResult = 0, dwThreadId;
                LPVOID lpMsgBuf = NULL;
                _bLBPopulated = FALSE;                   	
                //create an event to signal the worker thread
                //auto reset and initial state is nonsignalled
                _hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
                
                if(!_hEvent)
                {
                    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                        FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL,
                        GetLastError(),
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (LPTSTR) & lpMsgBuf, 0, NULL);
                    
                    TRC_ERR((TB, _T("CreateEvent returned %s"), lpMsgBuf));
                }
                else
                {
                    //Set the event handle for notification
                    //the _BrowseSrvListBox will CloseHandle the event when it is done
                    _pBrowseSrvCtl->SetEventHandle(_hEvent);

                    //
                    // Need to set the wait cursor on the UI thread
                    // dismiss it in the LB_POPULATE message handler
                    //
                    SetCursor(LoadCursor(NULL, IDC_WAIT));

                    /* Create a worker thread to do the browsing for servers */
                    
                    hThread = CreateThread(NULL, 0,
                                           &CBrowseServersCtl::UIStaticPopListBoxThread,
                                           _pBrowseSrvCtl, 0, &dwThreadId);
                                           
                }
                
                if(lpMsgBuf)
                {
                    LocalFree(lpMsgBuf);
                }
                
                if(NULL == hThread)
                {
                    // Since the CreateThread failed, populate the list box directly
                    _pBrowseSrvCtl->LoadLibraries();
                    plbi = _pBrowseSrvCtl->PopulateListBox(hwndDlg, &DomainCount);
                }
                else
                {
                    //
                    // Add a reference to the list box object for the new thread
                    // so the object doesn't get deleted before the thread is done
                    // the Release() is in the function called on this new thread
                    //
                    _pBrowseSrvCtl->AddRef();
                    CloseHandle(hThread);
                }
            }

            rc = TRUE;
        }
        break;

        
        //Notification from server list control
        case UI_LB_POPULATE_START:
        {
            //Set a cursor for the wait state
            SetCursor(LoadCursor(NULL, IDC_WAIT));
        }
        break;

        //Notification from server list control
        case UI_LB_POPULATE_END:
        {
            _bLBPopulated = TRUE;
            SetCursor(LoadCursor(NULL, IDC_ARROW));
        }
        break;

        case WM_CLOSE:
        {
            EndDialog(hwndDlg, IDCANCEL);
        }
        break;

        case WM_NOTIFY:
        {
            //
            // Don't forward tree view notifications
            // untill the async enumeration thread has finished
            // populating (_bLBPopulated is set)
            //
            if(UI_IDC_SERVERS_TREE == wParam &&
               _bLBPopulated)
            {
                LPNMHDR pnmh = (LPNMHDR) lParam;
                if(pnmh)
                {
                    if(pnmh->code == NM_DBLCLK)
                    {
                        //
                        // If the current selection is a server
                        // then we're done
                        //
                        if(_pBrowseSrvCtl->GetServer( m_szServer,
                                                      SIZECHAR(m_szServer) ))
                        {
                            EndDialog( hwndDlg, IDOK );
                            rc = TRUE;
                        }
                        else
                        {
                            _tcscpy( m_szServer, _T(""));
                        }
                    }
                }

                return _pBrowseSrvCtl->OnNotify( hwndDlg, wParam, lParam );
            }
        }
        break;

        case WM_COMMAND:
        {
            switch(DC_GET_WM_COMMAND_ID(wParam))
            {
                case IDCANCEL:
                {
                    EndDialog(hwndDlg, IDCANCEL);
                    rc = TRUE;
                }
                break;
                
                case IDOK:
                {
                    if(_pBrowseSrvCtl->GetServer( m_szServer,
                                                  SIZECHAR(m_szServer) ))
                    {
                        EndDialog(hwndDlg, IDOK);
                    }
                    else
                    {
                        EndDialog(hwndDlg, IDCANCEL);

                    }
                    
                    rc = TRUE;
                }
                break;
            }
        }
        break;

        case WM_DESTROY:
        {
            /* Since we are in WM_DESTROY signal to the worker thread to discontinue. */
            if(_hEvent)
            {
                SetEvent(_hEvent);
            }
            rc = FALSE;
        }
        break;
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\browsedlg.h ===
#ifndef _BROWSEDLG_H_
#define _BROWSEDLG_H_

//
// Browse for servers dialog
//

//
// Include the browse for servers listbox
//
#include "browsesrv.h"

class CBrowseDlg
{
private:
    HWND m_hWnd;
	HINSTANCE m_hInst;

//private methods
private:
	TCHAR	m_szServer[MAX_PATH];

public:
    CBrowseDlg(HWND hWndOwner, HINSTANCE hInst);
    ~CBrowseDlg();
	int	DoModal();

	static CBrowseDlg* m_pThis;

	static INT_PTR APIENTRY StaticDlgProc(HWND, UINT, WPARAM, LPARAM);
	INT_PTR DlgProc(HWND, UINT, WPARAM, LPARAM);

	LPTSTR	GetServer()	{return m_szServer;}

private:
    CBrowseServersCtl* _pBrowseSrvCtl;

    DCBOOL     _bLBPopulated;
    HANDLE     _hEvent;
};

#endif // _BROWSEDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\axhostwnd.h ===
//
// axhostwnd.h: TscActiveX control host window
//
// Copyright Microsoft Corportation 2000
// (nadima)
//

#ifndef _axhostwnd_h_
#define _axhostwnd_h_

#include "olecli.h"
#include "evsink.h"

#define AXHOST_SUCCESS              1
#define ERR_AXHOST_DLLNOTFOUND     -1
#define ERR_AXHOST_VERSIONMISMATCH -2
#define ERR_AXHOST_ERROR           -3

typedef DWORD (STDAPICALLTYPE * LPFNGETTSCCTLVER) (VOID);

class CAxHostWnd : public IUnknown
{
public:
    CAxHostWnd(CContainerWnd* pParentWnd);
    ~CAxHostWnd();

	// IUnknown methods
	STDMETHODIMP QueryInterface(THIS_ REFIID riid, LPVOID *ppvObj);
	STDMETHODIMP_(ULONG) AddRef(THIS);
	STDMETHODIMP_(ULONG) Release(THIS);

    BOOL    Init();
    BOOL    CreateHostWnd(HWND hwndParent, HINSTANCE hInst);
    INT     CreateControl(IMsRdpClient** ppTscCtl);
    BOOL    Cleanup();

    HWND      GetHwnd();
    IMsRdpClient* GetTscCtl();

    static LRESULT CALLBACK StaticAxHostWndProc(HWND hwnd,
                                                UINT uMsg,
                                                WPARAM wParam,
                                                LPARAM lParam);
    LRESULT CALLBACK AxHostWndProc(HWND hwnd,
                                   UINT uMsg,
                                   WPARAM wParam,
                                   LPARAM lParam);
private:
    LONG      _cRef;// Reference count
    HWND      _hWnd;
    IMsRdpClient* _pTsc;
    DWORD     _dwConCookie;

    // Module handle for the control library
	HMODULE	  _hLib;
    // pointer to EventSink for this container
	CEventSink*          _piEventSink;
    // pointer to OleClientSite for this container
	COleClientSite*      _piOleClientSite;
    // pointer to OleInPlaceSiteEx for this container
	COleInPlaceSiteEx*   _piOleInPlaceSiteEx;
    // pointer to object's IOleObject
	IOleObject*          _piOleObject;
    // pointer to object's IOleInPlaceActiveObject
	IOleInPlaceActiveObject* _piOleInPlaceActiveObject;
    // pointer to object's IOleInPlaceObject
    IOleInPlaceObject*    _piOleInPlaceObject;

    CContainerWnd*        _pParentWnd;
};

#endif //_axhostwnd_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\cachewrndlg.h ===
//
// cachewrndlg.h: cachewrn dialog class
// Bitmap Cache Warning dialog
//

#ifndef _cachewrndlg_h_
#define _cachewrndlg_h_

#include "dlgbase.h"
#include "sh.h"


class CCacheWrnDlg : public CDlgBase
{
public:
    CCacheWrnDlg(HWND hwndOwner, HINSTANCE hInst);
    ~CCacheWrnDlg();

    virtual DCINT   DoModal();
    virtual INT_PTR CALLBACK DialogBoxProc(HWND hwndDlg, UINT uMsg,WPARAM wParam, LPARAM lParam);
    static  INT_PTR CALLBACK StaticDialogBoxProc(HWND hwndDlg, UINT uMsg,WPARAM wParam, LPARAM lParam);

    static CCacheWrnDlg* _pCacheWrnDlgInstance;

private:
    HICON _hWarningIcon;
    RECT  _warningIconRect;
};
#endif //_cachewrndlg_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\cachewrndlg.cpp ===
//
// cachewrndlg.cpp: cachewrn dialog box
// bitmap cache error dialog box
//

#include "stdafx.h"

#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "cachewrndlg"
#include <atrcapi.h>

#include "cachewrndlg.h"
#include "sh.h"

CCacheWrnDlg* CCacheWrnDlg::_pCacheWrnDlgInstance = NULL;

CCacheWrnDlg::CCacheWrnDlg( HWND hwndOwner, HINSTANCE hInst) :
           CDlgBase( hwndOwner, hInst, UI_IDD_BITMAPCACHEERROR)
{
    DC_BEGIN_FN("CCacheWrnDlg");
    TRC_ASSERT((NULL == CCacheWrnDlg::_pCacheWrnDlgInstance), 
               (TB,_T("Clobbering existing dlg instance pointer\n")));

    CCacheWrnDlg::_pCacheWrnDlgInstance = this;
    DC_END_FN();
}

CCacheWrnDlg::~CCacheWrnDlg()
{
    CCacheWrnDlg::_pCacheWrnDlgInstance = NULL;
}

DCINT CCacheWrnDlg::DoModal()
{
    DCINT retVal = 0;
    DC_BEGIN_FN("DoModal");

    retVal = DialogBox(_hInstance, MAKEINTRESOURCE(_dlgResId),
                       _hwndOwner, StaticDialogBoxProc);
    TRC_ASSERT((retVal != 0 && retVal != -1), (TB, _T("DialogBoxParam failed\n")));

    DC_END_FN();
    return retVal;
}

INT_PTR CALLBACK CCacheWrnDlg::StaticDialogBoxProc (HWND hwndDlg, UINT uMsg,WPARAM wParam, LPARAM lParam)
{
    //
    // Delegate to appropriate instance (only works for single instance dialogs)
    //
    DC_BEGIN_FN("StaticDialogBoxProc");
    DCINT retVal = 0;

    TRC_ASSERT(_pCacheWrnDlgInstance, (TB, _T("CacheWrn dialog has NULL static instance ptr\n")));
    if(_pCacheWrnDlgInstance)
    {
        retVal = _pCacheWrnDlgInstance->DialogBoxProc( hwndDlg, uMsg, wParam, lParam);
    }

    DC_END_FN();
    return retVal;
}

/****************************************************************************/
/* Name: DialogBoxProc                                                      */
/*                                                                          */
/* Purpose: Handles CacheWrn Box dialog  (Random Failure dialog)           */
/*                                                                          */
/* Returns: TRUE if message dealt with                                      */
/*          FALSE otherwise                                                 */
/*                                                                          */
/* Params: See window documentation                                         */
/*                                                                          */
/****************************************************************************/
INT_PTR CALLBACK CCacheWrnDlg::DialogBoxProc (HWND hwndDlg, UINT uMsg,WPARAM wParam, LPARAM lParam)
{
    INT_PTR rc = FALSE;

    DC_BEGIN_FN("UIBitmapCacheErrorDialogProc");

#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))

    DC_IGNORE_PARAMETER(lParam);

    /************************************************************************/
    /* Handle dialog messages                                               */
    /************************************************************************/
    switch(uMsg)
    {
        case WM_INITDIALOG:
        {
            _hwndDlg = hwndDlg;
            HWND hStatic = NULL;

            SetDialogAppIcon(hwndDlg);

#ifndef OS_WINCE
            // load warning icon to _hWarningIcon
            _hWarningIcon = LoadIcon(NULL, IDI_EXCLAMATION);

            // Get the window position for the warning icon
            if (hwndDlg != NULL) {
                hStatic = GetDlgItem(hwndDlg, UI_IDC_WARNING_ICON_HOLDER);
                if (hStatic != NULL) {
                    GetWindowRect(hStatic, &(_warningIconRect));
                    MapWindowPoints(NULL, hwndDlg, (LPPOINT)&(_warningIconRect), 2);
                    DestroyWindow(hStatic);
                }
            }
#endif
            rc = TRUE;
        }
        break;

        case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC         hDC = NULL;

            if (hwndDlg != NULL) {
                hDC = BeginPaint(hwndDlg, &ps);

                // draw the warning icon for our dialog
                if (hDC != NULL && _hWarningIcon != NULL) {
                    DrawIcon(hDC, _warningIconRect.left, _warningIconRect.top,
                            _hWarningIcon);
                }

                EndPaint(hwndDlg, &ps);
            }

            rc = TRUE;
        }
        break;

        case WM_COMMAND:
        {
            switch(DC_GET_WM_COMMAND_ID(wParam))
            {
                case IDOK:
                {
                    /********************************************************/
                    /* Closes the dialog                                    */
                    /********************************************************/
                    TRC_NRM((TB, _T("Close dialog")));

                    if(hwndDlg != NULL)
                    {
                        EndDialog(hwndDlg, IDOK);
                    }

                    rc = TRUE;
                }
                break;

                default:
                {
                    /********************************************************/
                    /* Do Nothing                                           */
                    /********************************************************/
                }
                break;
            }
        }
        break;

        case WM_CLOSE:
        {
            /****************************************************************/
            /* Closes the dialog                                            */
            /****************************************************************/
            TRC_NRM((TB, _T("Close dialog")));
            if(IsWindow(hwndDlg))
            {
                EndDialog(hwndDlg, IDCANCEL);
            }

            rc = TRUE;
        }
        break;

        default:
        {
            /****************************************************************/
            /* Do Nothing                                                   */
            /****************************************************************/
        }
    }

#endif // ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))

    DC_END_FN();

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\clshell.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    core.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Nadim Abdo - Dec 8 1999

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

C_DEFINES = \
    $(C_DEFINES) \
    $(CLIENT_EXE_CDEFS) \
    -DDC_HICOLOR \
    -DDRAW_NINEGRID

DISABLE_SHADOW_IN_FULLSCREEN = 1
!IFDEF DISABLE_SHADOW_IN_FULLSCREEN
C_DEFINES=$(C_DEFINES) -DDISABLE_SHADOW_IN_FULLSCREEN
!ENDIF

SMART_SIZING=1
!IFDEF SMART_SIZING
C_DEFINES=$(C_DEFINES) -DSMART_SIZING
!ENDIF

INCLUDES = \
    $(INCLUDES); \
    $(SDK_INC_PATH)\atl30; \
    $(TERMSRV_ROOT)\common\inc; \
    $(TERMSRV_ROOT)\common\license\inc; \
    $(TSHRCLNT_ROOT)\newinc; \
    $(BASEDIR)\public\sdk\inc; \
    $(BASEDIR)\public\sdk\inc\hydra; \
    $(TERMSRV_ROOT)\common\clientidl\tsax\$(O); \
    $(INCLUDES)


#
# List of sources
#

SOURCES_PLATFORM =

CLIENT_SOURCES_RC = \
    ..\uires.rc

CLIENT_SOURCES_COMMON =  \
    ..\contwnd.cpp       \
    ..\axhostwnd.cpp     \
    ..\olecli.cpp        \
    ..\shapi.cpp         \
    ..\shint.cpp         \
    ..\dlgbase.cpp       \
    ..\aboutdlg.cpp      \
    ..\validatedlg.cpp   \
    ..\connectingdlg.cpp \
    ..\discodlg.cpp      \
    ..\shutdowndlg.cpp   \
    ..\mallocdbgdlg.cpp  \
    ..\thruputdlg.cpp    \
    ..\cachewrndlg.cpp   \
    ..\evsink.cpp        \
    ..\tscsetting.cpp    \
    ..\rdpfstore.cpp     \
    ..\rmigrate.cpp      \
    ..\tscapp.cpp        \
    ..\propgeneral.cpp   \
    ..\propdisplay.cpp   \
    ..\propperf.cpp      \
    ..\proprun.cpp       \
    ..\proplocalres.cpp  \
    ..\autocmpl.cpp      \
    ..\enumsrvmru.cpp    \
    ..\browsedlg.cpp     \
    ..\maindlg.cpp       \
    ..\framewnd.cpp      \
    ..\fstream.cpp       \
    ..\security.cpp      \
    ..\constr.cpp        \
    ..\rdrwrndlg.cpp

CLIENT_SOURCES_LAST  = \
    ..\clshell.cpp

SOURCES = \
    $(CLIENT_SOURCES_RC) \
    $(SOURCES_PLATFORM) \
    $(CLIENT_SOURCES_COMMON) \
    $(CLIENT_SOURCES_LAST)

#
# Precompiled specs
#
PRECOMPILED_INCLUDE = ..\stdafx.h
PRECOMPILED_SOURCEFILE = ..\stdafx.cpp
PRECOMPILED_CXX=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\clshell_ce.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    core.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Nadim Abdo - Dec 8 1999

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

C_DEFINES = \
    $(C_DEFINES) \
    $(CLIENT_EXE_CDEFS) \
    -DDC_HICOLOR

#   -DDRAW_NINEGRID  #-- CE doesnt support the functionality required by this

DISABLE_SHADOW_IN_FULLSCREEN = 1
!IFDEF DISABLE_SHADOW_IN_FULLSCREEN
C_DEFINES=$(C_DEFINES) -DDISABLE_SHADOW_IN_FULLSCREEN
!ENDIF


# SMART_SIZING=1  -- remove for WinCE

!IFDEF SMART_SIZING
C_DEFINES=$(C_DEFINES) -DSMART_SIZING
!ENDIF

INCLUDES = \
    $(INCLUDES); \
    $(SDK_INC_PATH)\atl30; \
    $(TERMSRV_ROOT)\common\inc; \
    $(TERMSRV_ROOT)\common\license\inc; \
    $(TSHRCLNT_ROOT)\newinc; \
    $(BASEDIR)\public\sdk\inc; \
    $(BASEDIR)\public\sdk\inc\hydra; \
    $(TERMSRV_ROOT)\common\clientidl\tsax\$(O); \
    $(INCLUDES)


#
# List of sources
#

SOURCES_PLATFORM =

CLIENT_SOURCES_RC = \
      ..\uires_ce.rc

CLIENT_SOURCES_COMMON =  \
    ..\contwnd.cpp       \
    ..\axhostwnd.cpp     \
    ..\olecli.cpp        \
    ..\shapi.cpp         \
    ..\shint.cpp         \
    ..\dlgbase.cpp       \
    ..\aboutdlg.cpp      \
    ..\validatedlg.cpp   \
    ..\connectingdlg.cpp \
    ..\discodlg.cpp      \
    ..\shutdowndlg.cpp   \
    ..\mallocdbgdlg.cpp  \
    ..\thruputdlg.cpp    \
    ..\cachewrndlg.cpp   \
    ..\evsink.cpp        \
    ..\tscsetting.cpp    \
    ..\rdpfstore.cpp     \
    ..\rmigrate.cpp      \
    ..\tscapp.cpp        \
    ..\propgeneral.cpp   \
    ..\propdisplay.cpp   \
    ..\propperf.cpp      \
    ..\proprun.cpp       \
    ..\proplocalres.cpp  \
    ..\autocmpl.cpp      \
    ..\enumsrvmru.cpp    \
    ..\browsedlg.cpp     \
    ..\maindlg.cpp       \
    ..\framewnd.cpp      \
    ..\fstream.cpp       \
    ..\security.cpp      \
    ..\rdrwrndlg.cpp

CLIENT_SOURCES_LAST  = \
    ..\clshell.cpp

SOURCES = \
    $(CLIENT_SOURCES_RC) \
    $(SOURCES_PLATFORM) \
    $(CLIENT_SOURCES_COMMON) \
    $(CLIENT_SOURCES_LAST)

#
# Precompiled specs
#
#PRECOMPILED_INCLUDE=
#PRECOMPILED_SOURCEFILE=
#PRECOMPILED_CXX=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\clshell.cpp ===
//
// clshell.cpp
//
// Main entry point for the tsc client shell
// This is an ActiveX client container that hosts an IMsRdpClient control
//
// Copyright(C) Microsoft Corporation 1997-2000
// Author: Nadim Abdo (nadima)
//
//

#include "stdafx.h"

#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "clshell"
#include <atrcapi.h>

#include "resource.h"
#include "tscapp.h"

//Unicode wrapper
#include "wraputl.h"

#ifdef OS_WINCE
#include <ceconfig.h>
#endif

#ifdef OS_WINCE
DECLARE_TRACKER_VARS();
#endif

//
// Name:      WinMain
//
// Purpose:   Main procedure
//
// Returns:   See Windows documentation
//
//

int WINAPI WinMain(HINSTANCE    hInstance,
                   HINSTANCE  hPrevInstance,
#ifndef OS_WINCE
                   LPSTR      lpCmdLine,
#else
                   LPWSTR     lpwszCmdLine,
#endif
                   int        nCmdShow)
{
    #ifdef UNIWRAP
    //UNICODE Wrapper intialization has to happen first,
    //before anything ELSE. Even DC_BEGIN_FN, which does tracing
    CUnicodeWrapper uwrp;
    uwrp.InitializeWrappers();
    #endif //UNIWRAP

    DC_BEGIN_FN("WinMain");

    UNREFERENCED_PARAMETER(nCmdShow);
#ifndef OS_WINCE
    UNREFERENCED_PARAMETER(lpCmdLine);
#else 
    UNREFERENCED_PARAMETER(lpwszCmdLine);
#endif  

    MSG msg;
#ifndef OS_WINCE
    HRESULT hr;
#endif
    HACCEL  hAccel;

#ifndef OS_WINCE
    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        return 0;
    }
#endif

    TSRNG_Initialize();

    //
    // Don't bother failing the load if we can't get accels
    //
    hAccel = (HACCEL)
     LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACCELERATORS));
    TRC_ASSERT(hAccel, (TB,_T("Could not load accelerators")));

    //Ensure CTscApp and all child objects
    //get destroyed before the CoUninitalize call below.
    //Yes, I could use a function but this has much less overheard
    {
        CTscApp app;
        //GetCommandLineW is available on all platforms.
#ifndef OS_WINCE
        LPWSTR lpszCmd = GetCommandLineW();
        if (lpszCmd)
        {
            //
            // GetCommandLine also includes the app path, so strip that off
            // (walk past the first space)
            // 
            if ( *lpszCmd == TEXT('\"') ) {
                //
                // Scan, and skip over, subsequent characters until
                // another double-quote or a null is encountered.
                //
                while ( *++lpszCmd && (*lpszCmd!= TEXT('\"')) );
                //
                // If we stopped on a double-quote (usual case), skip
                // over it.
                //
                if ( *lpszCmd == TEXT('\"') )
                    lpszCmd++;
            }
            else {
                while (*lpszCmd > TEXT(' '))
                    lpszCmd++;
            }

            //
            // Skip past any white space preceeding the second token.
            //
            while (*lpszCmd && (*lpszCmd <= TEXT(' '))) {
                lpszCmd++;
            }

        }
        else
        {
            TRC_ERR((TB,_T("cmd line is NULL\n")));
            return 0;
        }
#else
        /************************************************************************/
        /*  On Windows CE, we have only one binary that works for WBT, Maxall,  */
        /*  Minshell, and Rapier devices.  We have to get info about what       */
        /*  config we're running on and if we have to use software UUIDs here.  */
        /************************************************************************/
        CEInitialize();
        g_CEConfig = CEGetConfigType(&g_CEUseScanCodes);

        if (g_CEConfig == CE_CONFIG_WBT)
        {
            UTREG_UI_DEDICATED_TERMINAL_DFLT = TRUE;
        }
        else
        {
            UTREG_UI_DEDICATED_TERMINAL_DFLT = FALSE;   
        }
        RETAILMSG(1,(L"MSTSC client started, g_CEConfig = %d, g_CEUseScanCodes = %d\r\n",g_CEConfig, g_CEUseScanCodes));

        // CE directly gives us the cmd line in the format we want
        LPWSTR lpszCmd = lpwszCmdLine;
#endif
        //
        // GetCommandLine also includes the app path, so strip that off
        //
        if(!app.StartShell(hInstance, hPrevInstance, lpszCmd))
        {
            TRC_ERR((TB,_T("Error: app.StartShell returned FALSE. Exiting\n")));
            return 1;
        }
    
        HWND hwndMainDlg = app.GetTscDialogHandle();
    
        //
        // Main message pump
        //
        while (GetMessage(&msg, 0, 0, 0))
        {
            //
            // Translate accelerators for the main dialog
            // so that CTRL-TAB can be used to switch between
            // tabs.
            //
            if(!TranslateAccelerator(hwndMainDlg, hAccel, &msg))
            {
                if(!IsDialogMessage( hwndMainDlg, &msg))
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
        }
    
        if(!app.EndShell())
        {
            TRC_ERR((TB,_T("Error: app.EndShell returned FALSE.")));
        }
    }

#ifndef OS_WINCE
    CoUninitialize();
#endif

    TSRNG_Shutdown();

    DC_END_FN();

    #ifdef UNIWRAP
    uwrp.CleanupWrappers();
    #endif //UNIWRAP
    return 0;
}


#ifndef OS_WINCE
#ifdef DEBUG
//
// Purpose:  Redirect all debug messages to our tracing
//
extern "C"
_CRTIMP int __cdecl _CrtDbgReport(int nRptType, 
                                  const char * szFile, 
                                  int nLine,
                                  const char * szModule,
                                  const char * szFormat, 
                                  ...)
{
    static CHAR bigBuf[2048];
    va_list vargs;

    DC_BEGIN_FN("AtlTraceXXX");
    
    va_start(vargs, szFormat);

    wvsprintfA(bigBuf, szFormat, vargs);
    
    va_end( vargs );

#ifdef OS_WINCE
#ifndef _CRT_ASSERT
#define _CRT_ASSERT 2
#endif
#endif
    if (_CRT_ASSERT == nRptType)
    {
        #ifdef UNICODE
        TRC_ABORT((TB,_T("_CrtDbgReport. File:%S line:%d - %S"), szFile,
                      nLine, bigBuf));
        #else
        TRC_ABORT((TB,_T("_CrtDbgReport. File:%s line:%d - %s"), szFile,
                      nLine, bigBuf));
        #endif
    }
    else
    {
        #ifdef UNICODE
        TRC_ERR((TB,_T("_CrtDbgReport. File:%S line:%d - %S"), szFile,
                      nLine, bigBuf));
        #else
        TRC_ERR((TB,_T("_CrtDbgReport. File:%s line:%d - %s"), szFile,
                      nLine, bigBuf));
        #endif
    }

    DC_END_FN();

    return 0;
}
#endif
#endif //OS_WINCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\connectingdlg.h ===
//
// connectingdlg.h: connecting dialog box
//

#ifndef _connectingdlg_h_
#define _connectingdlg_h_

#include "dlgbase.h"
#include "contwnd.h"

class CConnectingDlg : public CDlgBase
{
public:
    CConnectingDlg(HWND hwndOwner, HINSTANCE hInst,
                   CContainerWnd* pContWnd, PDCTCHAR szServer);
    ~CConnectingDlg();

    virtual DCINT   DoModal();
    virtual INT_PTR CALLBACK DialogBoxProc(HWND hwndDlg, UINT uMsg,WPARAM wParam, LPARAM lParam);
    static  INT_PTR CALLBACK StaticDialogBoxProc(HWND hwndDlg, UINT uMsg,WPARAM wParam, LPARAM lParam);

    static CConnectingDlg* _pConnectingDlgInstance;

private:
    CContainerWnd* _pContainerWnd;
    DCTCHAR    _szServer[SH_MAX_ADDRESS_LENGTH];
};


#endif //_connectingdlg_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\connectingdlg.cpp ===
//
// connectingdlg.cpp: connecting dialog box
//

#include "stdafx.h"

#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "connectingdlg"
#include <atrcapi.h>

#include "connectingdlg.h"
#include "sh.h"

CConnectingDlg* CConnectingDlg::_pConnectingDlgInstance = NULL;

CConnectingDlg::CConnectingDlg( HWND hwndOwner, HINSTANCE hInst,
                                CContainerWnd* pContWnd, PDCTCHAR szServer) :
                CDlgBase( hwndOwner, hInst, UI_IDD_CONNECTING), _pContainerWnd(pContWnd)
{
    DC_BEGIN_FN("CConnectingDlg");
    TRC_ASSERT((NULL == CConnectingDlg::_pConnectingDlgInstance), 
               (TB,_T("Clobbering existing dlg instance pointer\n")));
    
    TRC_ASSERT(_pContainerWnd, (TB,_T("_pContainerWnd is NULL")));
    TRC_ASSERT(szServer, (TB,_T("szServer not set\n")));

    if(szServer)
    {
        DC_TSTRNCPY(_szServer, szServer, sizeof(_szServer)/sizeof(DCTCHAR));
    }
    else
    {
        DC_TSTRNCPY(_szServer, TEXT(""), sizeof(_szServer)/sizeof(DCTCHAR));
    }

    CConnectingDlg::_pConnectingDlgInstance = this;
    DC_END_FN();
}

CConnectingDlg::~CConnectingDlg()
{
    CConnectingDlg::_pConnectingDlgInstance = NULL;
}

DCINT CConnectingDlg::DoModal()
{
    DCINT retVal = 0;
    DC_BEGIN_FN("DoModal");

    retVal = DialogBox(_hInstance, MAKEINTRESOURCE(_dlgResId),
                       _hwndOwner, StaticDialogBoxProc);

    if (retVal == -1)
    {
        TRC_ERR((TB, _T("DialogBoxParam failed\n")));
    }

    DC_END_FN();
    return retVal;
}

INT_PTR CALLBACK CConnectingDlg::StaticDialogBoxProc (HWND hwndDlg, UINT uMsg,WPARAM wParam, LPARAM lParam)
{
    //
    // Delegate to appropriate instance (only works for single instance dialogs)
    //
    DC_BEGIN_FN("StaticDialogBoxProc");
    DCINT retVal = 0;

    TRC_ASSERT(_pConnectingDlgInstance, (TB, _T("Connecting dialog has NULL static instance ptr\n")));
    if(_pConnectingDlgInstance)
    {
        retVal = _pConnectingDlgInstance->DialogBoxProc( hwndDlg, uMsg, wParam, lParam);
    }

    DC_END_FN();
    return retVal;
}

/****************************************************************************/
/* Name: DialogBoxProc                                                      */
/*                                                                          */
/* Purpose: Handles Connecting Box dialog                                   */
/*                                                                          */
/* Returns: TRUE if message dealt with                                      */
/*          FALSE otherwise                                                 */
/*                                                                          */
/* Params: See window documentation                                         */
/*                                                                          */
/****************************************************************************/
INT_PTR CALLBACK CConnectingDlg::DialogBoxProc (HWND hwndDlg, UINT uMsg,WPARAM wParam, LPARAM lParam)
{
    INT_PTR rc = FALSE;
    DCUINT intRC;
    DCTCHAR connectingString[SH_VERSION_STRING_MAX_LENGTH];

    DC_BEGIN_FN("DialogProc");

    /************************************************************************/
    /* Handle dialog messages                                               */
    /************************************************************************/
    switch(uMsg)
    {
        case WM_INITDIALOG:
        {
            _hwndDlg = hwndDlg;
            _pContainerWnd->SetStatusDialogHandle( hwndDlg);

            if(hwndDlg)
            {
                DCTCHAR temp[SH_DISPLAY_STRING_MAX_LENGTH+SH_MAX_ADDRESS_LENGTH];

                CenterWindow(_hwndOwner);
                ::ShowWindow( _hwndDlg, SW_RESTORE);
                SetDialogAppIcon(hwndDlg);
                intRC = LoadString( _hInstance,
                                    UI_IDS_CONNECTING_TO_SERVER,
                                    connectingString,
                                    SH_DISPLAY_STRING_MAX_LENGTH );
                if(0 == intRC)
                {
                    TRC_ERR((TB,_T("Failed to find UI connecting string")));
                    connectingString[0] = (DCTCHAR) 0;
                    break;
                }
                _stprintf(temp, connectingString, _szServer);
                SetDlgItemText(hwndDlg, UI_IDC_CONN_STATIC, temp);

                SetCursor(LoadCursor(NULL, IDC_ARROW));
            }

            rc = TRUE;
        }
        break;

        case WM_COMMAND:
        {
            switch(DC_GET_WM_COMMAND_ID(wParam))
            {
                case IDCANCEL:
                case UI_ID_CANCELCONNECT:
                {
                    TRC_NRM((TB, _T("User cancelled connection - ")
                                 _T("calling UIInitiateDisconnection")));

                    _pContainerWnd->Disconnect();
                    _pContainerWnd->SetStatusDialogHandle( NULL);
                    EndDialog(hwndDlg, IDCANCEL);
                }
                break;

                default:
                {
                    if(hwndDlg)
                    {
                        rc = CDlgBase::DialogBoxProc(hwndDlg,
                                                  uMsg,
                                                  wParam,
                                                  lParam);
                    }
                }
                break;
            }
        }
        break;

#ifndef OS_WINCE
        case WM_WINDOWPOSCHANGING:
        {
            //Prevent the dialog from being
            //sized. This can happen if the app
            //is laucnhed with a .RDP shortcut that
            //specifies the app should be maximized
            LPWINDOWPOS lpwp;
            lpwp = (LPWINDOWPOS)lParam;
            lpwp->flags |= SWP_NOSIZE;
        }
        break;
#endif

        default:
        {
            if(hwndDlg)
            {
                rc = CDlgBase::DialogBoxProc(hwndDlg,
                                          uMsg,
                                          wParam,
                                          lParam);
            }
        }
        break;
    }

    DC_END_FN();

    return(rc);
} /* DialogBoxProc */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\constr.cpp ===
//
// constr.cpp
//
// Implementation of CRdpConnectionString
// 
// CRdpConnectionString implements a generic connection string
// that can specify a server name and optionally a port and other
// connection parameters
//
// Copyright(C) Microsoft Corporation 2002
// Author: Nadim Abdo (nadima)
//


#include "stdafx.h"
#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "constr.cpp"
#include <atrcapi.h>

#include "constr.h"
#include "autil.h"

CRdpConnectionString::CRdpConnectionString()
{
    DC_BEGIN_FN("CRdpConnectionString");

    memset(_szFullConnectionString, 0, sizeof(_szFullConnectionString));

    DC_END_FN();
}

CRdpConnectionString::CRdpConnectionString(LPCTSTR szConString)
{
    DC_BEGIN_FN("CRdpConnectionString");

    SetFullConnectionString(szConString);

    DC_END_FN();
}

CRdpConnectionString::~CRdpConnectionString()
{
    DC_BEGIN_FN("~CRdpConnectionString");

    DC_END_FN();
}


HRESULT
CRdpConnectionString::SetFullConnectionString(
    IN LPCTSTR szConString
    )
{
    HRESULT hr;

    DC_BEGIN_FN("SetFullConnectionString");

    hr = StringCchCopy(
                _szFullConnectionString,
                SIZE_TCHARS(_szFullConnectionString),
                szConString
                );
    DC_END_FN();
    return hr;
}

LPTSTR
CRdpConnectionString::GetFullConnectionString(
    )
{
    DC_BEGIN_FN("GetFullConnectionString");

    DC_END_FN();
    return _szFullConnectionString;
}

//
// Retreive the server portion of the connect string e.g. if
//
// 'nadima3:3389 /connect" then get "nadima3:3389"
//
HRESULT
CRdpConnectionString::GetServerPortion(
    OUT LPTSTR szServerPortion,
    IN ULONG cchServerPortionLen
    )
{
    HRESULT hr;
    DC_BEGIN_FN("GetServerPortion");

    hr = CUT::GetCanonicalServerNameFromConnectString(
                    _szFullConnectionString,
                    szServerPortion,
                    cchServerPortionLen
                    );

    DC_END_FN();
    return hr;
}

//
// Retreive the server name portion of the connect string e.g. if
//
// 'nadima3:3389 /connect" then get "nadima3"
//
HRESULT
CRdpConnectionString::GetServerNamePortion(
    OUT LPTSTR szServerPortion,
    IN ULONG cchServerPortionLen
    )
{
    HRESULT hr;
    TCHAR szServerPort[TSC_MAX_ADDRESS_LENGTH];

    DC_BEGIN_FN("GetServerNamePortion");

    hr = GetServerPortion(
                    szServerPort,
                    SIZE_TCHARS(szServerPort)
                    );
    if (SUCCEEDED(hr)) {
        CUT::GetServerNameFromFullAddress(
                        szServerPort,
                        szServerPortion,
                        cchServerPortionLen
                        );
    }

    DC_END_FN();
    return hr;
}



//
// Retreive the args portion of the connect string e.g. if
//
// 'nadima3:3389 /connect" then get "/connect"
//
HRESULT
CRdpConnectionString::GetArgumentsPortion(
    OUT LPTSTR szArguments,
    IN ULONG cchArgLen
    )
{
    HRESULT hr = E_FAIL;
    TCHAR szServerPortion[TSC_MAX_ADDRESS_LENGTH];

    DC_BEGIN_FN("GetArgumentsPortion");

    if (cchArgLen) {
        memset(szArguments, 0, sizeof(szArguments));
    }
    else {
        hr = E_INVALIDARG;
        DC_QUIT;
    }

    hr = GetServerPortion(
                    szServerPortion,
                    SIZE_TCHARS(szServerPortion)
                    );
    if (SUCCEEDED(hr)) {

        ULONG cchLenServerPortion = _tcslen(szServerPortion);
        ULONG cchLenFull = _tcslen(_szFullConnectionString);

        if (cchLenFull > cchLenServerPortion) {
            
            //
            // There is stuff after the server name.
            // Return it as the arguments
            //
            LPTSTR szArgStart = _szFullConnectionString + cchLenServerPortion;
            hr = StringCchCopy(szArguments, cchArgLen, szArgStart);
        }
    }

    if (FAILED(hr) && cchArgLen) {
        szArguments[0] = 0;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}

//
// Validate the server portion
//
BOOL
CRdpConnectionString::ValidateServerPart(
    IN LPTSTR szConnectionString
    )
{
    HRESULT hr;
    BOOL fIsValid = FALSE;
    CRdpConnectionString stringToTest;

    DC_BEGIN_FN("ValidateServerPart");

    if (NULL == szConnectionString[0]) {
        TRC_ERR((TB,_T("0 length server string")));
        DC_QUIT;
    }

    TCHAR szServer[TSC_MAX_ADDRESS_LENGTH];
    hr = stringToTest.SetFullConnectionString(
        szConnectionString
        );
    if (SUCCEEDED(hr)) {
        hr = stringToTest.GetServerPortion(
            szServer,
            SIZE_TCHARS(szServer)
            );
        if (FAILED(hr)) {
            TRC_ERR((TB,_T("Fail to get server portion")));
            DC_QUIT;
        }

        if(CUT::ValidateServerName( szServer, TRUE)) {
            fIsValid = TRUE;
        }
        else {
            TRC_ERR((TB,_T("ValidateServerName failed")));
        }
    }
    else {
        TRC_ERR((TB,_T("Fail to setfull conn string:0x%x"), hr));
    }

    DC_END_FN();
DC_EXIT_POINT:
    return fIsValid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\constr.h ===
//
// constr.h
//
// Definition of CRdpConnectionString
// 
// CRdpConnectionString implements a generic connection string
// that can specify a server name and optionally a port and other
// connection parameters
//
// Copyright(C) Microsoft Corporation 2002
// Author: Nadim Abdo (nadima)
//

#ifndef _constr_h_
#define _constr_h_

class CRdpConnectionString
{
public:
    CRdpConnectionString();
    CRdpConnectionString(LPCTSTR szConString);
    ~CRdpConnectionString();

    //
    // Properties
    //
    HRESULT
    SetFullConnectionString(
        IN LPCTSTR szConString
        );
    LPTSTR
    GetFullConnectionString(
        );

    //
    // Retreive the server+port portion of the connect string e.g. if
    //
    // 'nadima3:3389 /connect" then get "nadima3:3389"
    //
    HRESULT
    GetServerPortion(
        OUT LPTSTR szServerPortion,
        IN ULONG cchServerPortionLen
        );

    //
    // Retreive the server name portion of the connect string e.g. if
    //
    // 'nadima3:3389 /connect" then get "nadima3"
    //
    HRESULT
    GetServerNamePortion(
        OUT LPTSTR szServerPortion,
        IN ULONG cchServerPortionLen
        );

    //
    // Retreive the args portion of the connect string e.g. if
    //
    // 'nadima3:3389 /connect" then get "/connect"
    //
    HRESULT
    GetArgumentsPortion(
        OUT LPTSTR szArguments,
        IN ULONG cchArgLen
        );

    static BOOL
    ValidateServerPart(
        IN LPTSTR szConnectionString
        );

private:
    TCHAR _szFullConnectionString[TSC_MAX_ADDRESS_LENGTH];
};

#endif  //_constr_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\discodlg.h ===
//
// discodlg.h: Disconnected dlg
//

#ifndef _disconnecteddlg_h_
#define _disconnecteddlg_h_

#include "dlgbase.h"

class CContainerWnd;

class CDisconnectedDlg
{
public:
    CDisconnectedDlg(HWND hwndOwner, HINSTANCE hInst, CContainerWnd* pContWnd);
    ~CDisconnectedDlg();

    virtual DCINT   DoModal();

    VOID  SetDisconnectReason(UINT id)  {_disconnectReason=id;}
    VOID  SetExtendedDiscReason(ExtendedDisconnectReasonCode extDiscReason)
                                        {_extendedDiscReason = extDiscReason;}

private:
    static BOOL
    MapErrorToString(
        HINSTANCE hInstance,
        INT disconnectReason,
        ExtendedDisconnectReasonCode extendedDisconnectReason,
        LPTSTR szErrorMsg,
        INT cchErrorLen
        );

private:
    UINT           _disconnectReason;
    ExtendedDisconnectReasonCode _extendedDiscReason;
    CContainerWnd* _pContWnd;
    HINSTANCE      _hInstance;
    HWND           _hwndOwner;
};


#endif //_disconnecteddlg_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\contwnd.cpp ===
//
// contwnd.cpp
//
// Implementation of CContainerWnd
// TS Client Shell Top-Level ActiveX container window
//
// Copyright(C) Microsoft Corporation 2000
// Author: Nadim Abdo (nadima)
//
//

#include "stdafx.h"

#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "contwnd"
#include <atrcapi.h>


#include "contwnd.h"

#include "maindlg.h"
#include "discodlg.h"
#include "aboutdlg.h"
#include "shutdowndlg.h"
#ifdef DC_DEBUG
#include "mallocdbgdlg.h"
#include "thruputdlg.h"
#endif //DC_DEBUG
#include "cachewrndlg.h"
#include "tscsetting.h"

#include "commctrl.h"

#include "security.h"
//
// COMPILE_MULTIMON_STUBS must be defined in only one
// file. Any other file that wants to use multimon
// enabled functions should re-include multimon.h
//

#ifdef OS_WINNT
#define COMPILE_MULTIMON_STUBS
#include <multimon.h>
#endif

#ifdef OS_WINCE
#include <ceconfig.h>
#endif

//
// maximum string length for menu strings
//
#define UI_MENU_STRING_MAX_LENGTH      256

CContainerWnd::CContainerWnd()
{
    DC_BEGIN_FN("CContainerWnd");

    _pTsClient = NULL;
    _hwndMainDialog = NULL;
    _hwndStatusDialog  = NULL;
    _fLoginComplete = FALSE;

    _bContainerIsFullScreen = FALSE;
    _fPreventClose = FALSE;
    _fBeenThroughDestroy = FALSE;
    _fBeenThroughNCDestroy = FALSE;
    _PostedQuit=0;
    _pWndView = NULL;
    _fFirstTimeToLogonDlg = TRUE;
    _cInEventHandlerCount = 0;
    _fInOnCloseHandler    = FALSE;
    _pMainDlg = NULL;
    _pTscSet  = NULL;
    _pSh      = NULL;
    memset(_szAppName, 0, sizeof(_szAppName));
    _fHaveConnected = FALSE;
    _fClosePending = FALSE;

#ifndef OS_WINCE
    _pTaskBarList2 = NULL;
    _fQueriedForTaskBarList2 = FALSE;
#endif

    _fInSizeMove = FALSE;
    _maxMainWindowSize.width = 100;
    _maxMainWindowSize.height = 100;

    SetCurrentDesktopWidth(DEFAULT_DESKTOP_WIDTH);
    SetCurrentDesktopHeight(DEFAULT_DESKTOP_HEIGHT);

    _fClientWindowIsUp = FALSE;
    _successConnectCount = 0;
    _fRunningOnWin9x = FALSE;
    SET_CONTWND_STATE(stateNotInitialized); 
    ResetConnectionSuccessFlag();

    DC_END_FN();
}

CContainerWnd::~CContainerWnd()
{
    //
    // Release our cached interface ptr to the taskbar
    //
#ifndef OS_WINCE
    if (_pTaskBarList2)
    {
        _pTaskBarList2->Release();
        _pTaskBarList2 = NULL;
    }
#endif

    delete _pMainDlg;

    if (_pWndView)
    {
        _pWndView->Cleanup();
        delete _pWndView;
        _pWndView = NULL;
    }
}

DCBOOL CContainerWnd::Init(HINSTANCE hInstance, CTscSettings* pTscSet, CSH* pSh)
{
    HRESULT hr;

    DC_BEGIN_FN("Init");

    TRC_ASSERT(hInstance && pTscSet && pSh,
               (TB,_T("Invalid param(s)")));
    if (!(hInstance && pTscSet && pSh))
    {
        return FALSE;
    }

    _fRunningOnWin9x = CSH::SH_IsRunningOn9x();
    TRC_NRM((TB,_T("Running on 9x :%d"), _fRunningOnWin9x));

    _pSh = pSh;
    _hInst = hInstance;
    //
    // Window is created with dummy size, it is resized before
    // connection
    //
    RECT rcNormalizedPos = {0,0,1,1};

    INITCOMMONCONTROLSEX cmCtl;
    cmCtl.dwSize = sizeof(INITCOMMONCONTROLSEX);

    #ifndef OS_WINCE
    //Load ComboBoxEx class
    cmCtl.dwICC  = ICC_USEREX_CLASSES;
    if (!InitCommonControlsEx( &cmCtl))
    {
        TRC_ABORT((TB, _T("InitCommonControlsEx failed")));
        return FALSE;
    }
    #endif

    _pTscSet = pTscSet;

    if (!LoadString(hInstance,
                    UI_IDS_APP_NAME,
                    _szAppName,
                    SIZECHAR(_szAppName)))
    {
        TRC_ERR((TB,_T("LoadString UI_IDS_APP_NAME failed"))); 
    }

    //
    // Cache the path to the default file
    //
    #ifndef OS_WINCE
    _pSh->SH_GetPathToDefaultFile(_szPathToDefaultFile,
                                  SIZECHAR(_szPathToDefaultFile));
    #else
    _tcscpy(_szPathToDefaultFile, _T(""));
    #endif

    //Create invisible top level container window
    if(!CreateWnd(hInstance, NULL,
                  MAIN_CLASS_NAME,
                  _pSh->_fullFrameTitleStr,
#ifndef OS_WINCE
                  WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS |
                  WS_EX_APPWINDOW | WS_EX_WINDOWEDGE,
#else
                  WS_OVERLAPPED | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_EX_WINDOWEDGE,
#endif
                  &rcNormalizedPos,
                  _pSh->GetAppIcon()))
    {
        TRC_ERR((TB,_T("Failed to create top level window")));
        return FALSE;
    }

    //
    // Load the Ax control
    //
    // CreateTsControl pops message boxes to indicate
    // common failures
    //
    hr = CreateTsControl();
    if (FAILED(hr))
    {
        TRC_ERR((TB, _T("Failed to create control\n")));
        DestroyWindow();
        return FALSE;
    }

    TRC_ASSERT(_pTsClient, (TB,_T(" _pTsClient not created")));
    if (!_pTsClient)
    {
        DestroyWindow();
        return FALSE;
    }
    if (!_pSh->SH_ReadControlVer( _pTsClient))
    {
        _pTsClient->Release();
        _pTsClient=NULL;
        DestroyWindow();
        return FALSE;
    }

    IMsRdpClientAdvancedSettings* pAdvSettings;
    hr = _pTsClient->get_AdvancedSettings2( &pAdvSettings);
    if (FAILED(hr) || !pAdvSettings)
    {
        _pTsClient->Release();
        _pTsClient=NULL;
        DestroyWindow();
        return FALSE;
    }

    //
    // Set the container handled fullscreen prop
    //
    hr = pAdvSettings->put_ContainerHandledFullScreen( TRUE);
    if (FAILED(hr))
    {
        _pTsClient->Release();
        pAdvSettings->Release();
        _pTsClient=NULL;

        DestroyWindow();
        return FALSE;
    }
    pAdvSettings->Release();

    SetupSystemMenu();

    SET_CONTWND_STATE(stateNotConnected);

    if (_pSh->GetAutoConnect() && _pSh->SH_ValidateParams(_pTscSet))
    {
        //Auto connect
        if (!StartConnection())
        {
            //
            // Autoconnection failed, this could have been because
            // the user cancelled out of a security warning dialog
            // in which case we brought up the main UI - in that
            // case do not exit, all other cases bail out.
            //
            if (!IsUsingDialogUI())
            {
                TRC_ERR((TB,_T("StartConnection failed")));
                DestroyWindow();
                return FALSE;
            }
        }
    }
    else
    {
        //Start the main dialog
        TRC_NRM((TB, _T("Bringing up connection dialog")));

        //
        // Start the dialog in the expanded state if the file
        // was opened for edit (first parameter)
        //
        if (!StartConnectDialog(_pSh->SH_GetCmdFileForEdit(), TAB_GENERAL_IDX))
        {
            TRC_ERR((TB,_T("Error bringing up connect dialog")));
            DestroyWindow();
            return FALSE;
        }
    }

    DC_END_FN();
    return TRUE;
}

//
// Exit and quit the app
//
void CContainerWnd::ExitAndQuit()
{
    DC_BEGIN_FN("ExitAndQuit");
    if (_pTsClient)
    {
        _pTsClient->Release();
        _pTsClient = NULL;
    }

    if (::IsWindow(_hwndMainDialog))
    {
        ::DestroyWindow(_hwndMainDialog);
        _hwndMainDialog = NULL;
    }

    _PostedQuit=2;
    ::PostQuitMessage(0);

    DC_END_FN();
}

BOOL CContainerWnd::SetupSystemMenu()
{
    HRESULT hr = E_FAIL;
#ifndef OS_WINCE
    HMENU         hHelpMenu;
    DCTCHAR menuStr[UI_MENU_STRING_MAX_LENGTH];
#if DC_DEBUG
    HMENU         hDebugMenu;
#endif // DC_DEBUG
#endif // OS_WINCE

    DC_BEGIN_FN("SetupSystemMenu");


#ifndef OS_WINCE // These won't work in full screen anyway

    // Set up the main window's menu information.
    _hSystemMenu = GetSystemMenu(GetHwnd(), FALSE);
    if (_hSystemMenu)
    {
        // Update the System Menu Alt-F4 menu text
        if (LoadString(_hInst,
                       UI_MENU_APPCLOSE,
                       menuStr,
                       UI_MENU_STRING_MAX_LENGTH) != 0)
        {
            if (!ModifyMenu(_hSystemMenu, SC_CLOSE, MF_BYCOMMAND |
                            MF_STRING, SC_CLOSE, menuStr))
            {
                TRC_ERR((TB, _T("Unable to ModifyMenu")));
            }
        }
        else
        {
            TRC_ERR((TB, _T("Unable to Load App close text")));
        }

        // Add Help Menu to the System Menu
        hHelpMenu = CreateMenu();

        if (hHelpMenu)
        {
            //load the string from the resources
            if (LoadString(_hInst,
                           UI_MENU_MAINHELP,
                           menuStr,
                           UI_MENU_STRING_MAX_LENGTH) != 0)
            {
                AppendMenu(_hSystemMenu, MF_POPUP | MF_STRING,
                           (INT_PTR)hHelpMenu, menuStr);

                //load the string for the client help sub menu
                if (LoadString(_hInst,
                               UI_MENU_CLIENTHELP,
                               menuStr,
                               UI_MENU_STRING_MAX_LENGTH) != 0)
                {
                    AppendMenu(hHelpMenu, MF_UNCHECKED|MF_STRING,
                               UI_IDM_HELP_ON_CLIENT,
                               menuStr);
                }
                else
                {
                    //failed to load the sub menu string
                    TRC_ERR((TB, _T("Failed to load Client Help Sub Menu string ID:%u"),
                             UI_MENU_CLIENTHELP));
                }

                //load the string for the about help sub menu
                if (LoadString(_hInst,
                               UI_MENU_ABOUT,
                               menuStr,
                               UI_MENU_STRING_MAX_LENGTH) != 0)
                {
                    AppendMenu(hHelpMenu, MF_UNCHECKED|MF_STRING, UI_IDM_ABOUT,
                               menuStr);
                }
                else
                {
                    //failed to load the sub menu string
                    TRC_ERR((TB, _T("Failed to load About Help Sub Menu string ID:%u"),
                             UI_MENU_ABOUT));
                }
            }

            else
            {
                //load string for the main help menu failed

                TRC_ERR((TB, _T("Failed to load Main Help Menu string ID:%u"),
                         UI_MENU_MAINHELP));
            }

            _hHelpMenu = hHelpMenu;
        }


        // Add Debug Menu to the System Menu
#ifdef DC_DEBUG
        hDebugMenu = CreateMenu();

        if (hDebugMenu)
        {
            //load the string for the DEBUG menu
            if (LoadString(_hInst,
                           UI_MENU_DEBUG,
                           menuStr,
                           UI_MENU_STRING_MAX_LENGTH) != 0)
            {
                AppendMenu(_hSystemMenu, MF_POPUP | MF_STRING,
                           (INT_PTR)hDebugMenu, menuStr);

                //load the string for the hatch Bitmap pdu debug menu
                if (LoadString(_hInst,
                               UI_MENU_BITMAPPDU,
                               menuStr,
                               UI_MENU_STRING_MAX_LENGTH) != 0)
                {
                    AppendMenu(hDebugMenu, MF_UNCHECKED|MF_STRING,
                               UI_IDM_HATCHBITMAPPDUDATA,
                               menuStr);
                }
                else
                {
                    //failed to load the sub menu string
                    TRC_ERR((TB, _T("Failed to load Debug Sub Menu string ID:%u"),
                             UI_MENU_BITMAPPDU));
                }

                //load the string for the hatch SS Border data debug menu
                if (LoadString(_hInst,
                               UI_MENU_SSBORDER,
                               menuStr,
                               UI_MENU_STRING_MAX_LENGTH) != 0)
                {
                    AppendMenu(hDebugMenu, MF_UNCHECKED|MF_STRING,
                               UI_IDM_HATCHSSBORDERDATA,
                               menuStr);
                }
                else
                {
                    //failed to load the sub menu string
                    TRC_ERR((TB, _T("Failed to load Debug Sub Menu string ID:%u"),
                             UI_MENU_SSBORDER));
                }

                //load the string for the Hatch MemBlt order data debug menu
                if (LoadString(_hInst,
                               UI_MENU_HATCHMEMBIT,
                               menuStr,
                               UI_MENU_STRING_MAX_LENGTH) != 0)
                {
                    AppendMenu(hDebugMenu, MF_UNCHECKED|MF_STRING,
                               UI_IDM_HATCHMEMBLTORDERDATA,
                               menuStr);
                }
                else
                {
                    //failed to load the sub menu string
                    TRC_ERR((TB, _T("Failed to load Debug Sub Menu string ID:%u"),
                             UI_MENU_HATCHMEMBIT));
                }

                //load the string for the hatch index pdu debug menu
                if (LoadString(_hInst,
                               UI_MENU_INDEXPDU,
                               menuStr,
                               UI_MENU_STRING_MAX_LENGTH) != 0)
                {
                    AppendMenu(hDebugMenu, MF_UNCHECKED|MF_STRING,
                               UI_IDM_HATCHINDEXPDUDATA,
                               menuStr);
                }
                else
                {
                    //failed to load the sub menu string
                    TRC_ERR((TB, _T("Failed to load Debug Sub Menu string ID:%u"),
                             UI_MENU_INDEXPDU));
                }

                //load the string for the label Membit data debug menu
                if (LoadString(_hInst,
                               UI_MENU_LABELMEMBIT,
                               menuStr,
                               UI_MENU_STRING_MAX_LENGTH) != 0)
                {
                    AppendMenu(hDebugMenu, MF_UNCHECKED|MF_STRING,
                               UI_IDM_LABELMEMBLTORDERS,
                               menuStr);
                }
                else
                {
                    //failed to load the sub menu string
                    TRC_ERR((TB, _T("Failed to load Debug Sub Menu string ID:%u"),
                             UI_MENU_LABELMEMBIT));
                }

                //load the string for the hatch Bitmap Cahche Monitor debug menu
                if (LoadString(_hInst,
                               UI_MENU_CACHE,
                               menuStr,
                               UI_MENU_STRING_MAX_LENGTH) != 0)
                {
                    AppendMenu(hDebugMenu, MF_UNCHECKED|MF_STRING,
                               UI_IDM_BITMAPCACHEMONITOR,
                               menuStr);
                }
                else
                {
                    //failed to load the sub menu string
                    TRC_ERR((TB, _T("Failed to load Debug Sub Menu string ID:%u"),
                             UI_MENU_CACHE));
                }

                //load the string for the malloc Failure debug menu
                if (LoadString(_hInst,
                               UI_MENU_MALLOC,
                               menuStr,
                               UI_MENU_STRING_MAX_LENGTH) != 0)
                {
                    AppendMenu(hDebugMenu, MF_UNCHECKED|MF_STRING,
                               UI_IDM_MALLOCFAILURE,
                               menuStr);
                }
                else
                {
                    //failed to load the sub menu string
                    TRC_ERR((TB, _T("Failed to load Debug Sub Menu string ID:%u"),
                             UI_MENU_MALLOC));
                }

                //load the string for the Malloc Huge Failure debug menu
                if (LoadString(_hInst,
                               UI_MENU_MALLOCHUGE,
                               menuStr,
                               UI_MENU_STRING_MAX_LENGTH) != 0)
                {
                    AppendMenu(hDebugMenu, MF_UNCHECKED|MF_STRING,
                               UI_IDM_MALLOCHUGEFAILURE,
                               menuStr);
                }
                else
                {
                    //failed to load the sub menu string
                    TRC_ERR((TB, _T("Failed to load Debug Sub Menu string ID:%u"),
                             UI_MENU_MALLOCHUGE));
                }

                //load the string for the network Throughput.. debug menu
                if (LoadString(_hInst,
                               UI_MENU_NETWORK,
                               menuStr,
                               UI_MENU_STRING_MAX_LENGTH) != 0)
                {
                    AppendMenu(hDebugMenu, MF_UNCHECKED|MF_STRING,
                               UI_IDM_NETWORKTHROUGHPUT,
                               menuStr);
                }
                else
                {
                    //failed to load the sub menu string
                    TRC_ERR((TB, _T("Failed to load Debug Sub Menu string ID:%u"),
                             UI_MENU_NETWORK));
                }

                TRC_ASSERT(_pTsClient,(TB, _T("_pTsClient is NULL on syscommand")));

#ifdef SMART_SIZING
                //load the string for the SmartSize debug menu
                if (LoadString(_hInst,
                               UI_MENU_SMARTSIZING,
                               menuStr,
                               UI_MENU_STRING_MAX_LENGTH) != 0)
                {
                    UINT flags;
                    flags = MF_STRING;
                    if (_fRunningOnWin9x) {
                        flags |= MF_GRAYED;
                    }

                    AppendMenu(hDebugMenu, flags,
                               UI_IDM_SMARTSIZING,
                               menuStr);
                }
                else
                {
                    //failed to load the sub menu string
                    TRC_ERR((TB, _T("Failed to load Debug Sub Menu string ID:%u"),
                             UI_MENU_HATCHMEMBIT));
                }
#endif // SMART_SIZING

                TRC_ASSERT(_pTsClient,(TB, _T("_pTsClient is NULL on syscommand")));
                if (!_pTsClient)
                {
                    return FALSE;
                }

                IMsTscDebug* pDebugger = NULL;
                TRACE_HR(_pTsClient->get_Debugger(&pDebugger));
                if(SUCCEEDED(hr) && pDebugger)
                {
                    //
                    // Now check the menu items as needed
                    //
                    BOOL bEnabled;
                    TRACE_HR(pDebugger->get_HatchBitmapPDU(&bEnabled));
                    if(SUCCEEDED(hr))
                    {
                        CheckMenuItem(hDebugMenu,
                                      UI_IDM_HATCHBITMAPPDUDATA,
                                      bEnabled ? MF_CHECKED :
                                      MF_UNCHECKED);
                    }

                    TRACE_HR(pDebugger->get_HatchIndexPDU(&bEnabled));
                    if(SUCCEEDED(hr))
                    {
                        CheckMenuItem(hDebugMenu,
                                      UI_IDM_HATCHINDEXPDUDATA,
                                      bEnabled ? MF_CHECKED :
                                      MF_UNCHECKED);
                    }

                    TRACE_HR(pDebugger->get_HatchSSBOrder(&bEnabled));
                    if(SUCCEEDED(hr))
                    {
                        CheckMenuItem(hDebugMenu,
                                      UI_IDM_HATCHSSBORDERDATA,
                                      bEnabled ? MF_CHECKED :
                                      MF_UNCHECKED);
                    }

                    TRACE_HR(pDebugger->get_HatchMembltOrder(&bEnabled));
                    if(SUCCEEDED(hr))
                    {
                        CheckMenuItem(hDebugMenu,
                                      UI_IDM_HATCHMEMBLTORDERDATA,
                                      bEnabled ? MF_CHECKED :
                                      MF_UNCHECKED);
                    }

                    TRACE_HR(pDebugger->get_LabelMemblt(&bEnabled));
                    if(SUCCEEDED(hr))
                    {
                        CheckMenuItem(hDebugMenu,
                                      UI_IDM_LABELMEMBLTORDERS,
                                      bEnabled ? MF_CHECKED :
                                      MF_UNCHECKED);
                    }

                    TRACE_HR(pDebugger->get_BitmapCacheMonitor(&bEnabled));
                    if(SUCCEEDED(hr))
                    {
                        CheckMenuItem(hDebugMenu,
                                      UI_IDM_BITMAPCACHEMONITOR,
                                      bEnabled ? MF_CHECKED :
                                      MF_UNCHECKED);
                    }
                    pDebugger->Release();
                }
            }
            else
            {
                //failed to load the debug menu string
                TRC_ERR((TB, _T("Failed to load Debug menu string ID:%u"),
                         UI_MENU_DEBUG));
            }

            _hDebugMenu = hDebugMenu;
        }
#endif // DC_DEBUG
    }
#endif // OS_WINCE
    DC_END_FN();
    return TRUE;
}


LRESULT CContainerWnd::OnCreate(UINT uMsg, WPARAM wParam,
                                LPARAM lParam)
{
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);

    DC_BEGIN_FN("OnCreate");

    SetCursor(LoadCursor(NULL, IDC_WAIT));

    DC_END_FN();
    return 0;
}

//
// Create TS Control Window.
//
HRESULT CContainerWnd::CreateTsControl()
{
    HRESULT hr = S_OK;
    DC_BEGIN_FN("CreateTsControl");

    if (_pWndView)
    {
        return E_FAIL;
    }

    _pWndView = new CAxHostWnd(this);
    if (!_pWndView)
    {
        return E_OUTOFMEMORY;
    }

    if (!_pWndView->Init())
    {
        TRC_ABORT((TB,_T("Init of AxHostWnd failed")));
        return E_FAIL;
    }

    //
    // CreateControl is the crucial part that goes
    // and loads the control dll.
    //
    INT rc = _pWndView->CreateControl(&_pTsClient);
    if (AXHOST_SUCCESS == rc)
    {
        if (!_pWndView->CreateHostWnd(GetHwnd(), _hInst))
        {
            TRC_ABORT((TB,_T("CreateHostWnd failed")));
            return E_FAIL;
        }
    }
    else
    {
        TRC_ERR((TB,_T("CreateControl failed")));
        //
        // Pop meaningful errmsg boxes to the user
        // as this is a fatal error and we can't go on
        //
        INT errStringID;
        switch (rc)
        {
        case ERR_AXHOST_DLLNOTFOUND:
            errStringID = UI_IDS_ERR_DLLNOTFOUND;
            break;
        case ERR_AXHOST_VERSIONMISMATCH:
            errStringID = UI_IDS_ERR_DLLBADVERSION;
            break;
        default:
            errStringID = UI_IDS_ERR_LOADINGCONTROL;
            break;
        }

        TCHAR errLoadingControl[MAX_PATH];
        if (LoadString(_hInst,
                       errStringID,
                       errLoadingControl,
                       SIZECHAR(errLoadingControl)) != 0)
        {
            MessageBox(GetHwnd(), errLoadingControl, _szAppName, 
                       MB_ICONERROR | MB_OK);
        }

        return E_FAIL;
    }


    DC_END_FN();
    return hr;
}

//
// Kick off a connection with the current settings
//
BOOL CContainerWnd::StartConnection()
{
    DC_BEGIN_FN("StartConnection");
    USES_CONVERSION;

    HRESULT hr;
    PWINDOWPLACEMENT pwndplc;
    BOOL fResult = FALSE;
    IMsTscDebug* pDebugger = NULL;
    TCHAR szPlainServerName[TSC_MAX_ADDRESS_LENGTH];

    TRC_ASSERT(_pTsClient, (TB,_T(" Ts client control does not exist!\n")));
    if (!_pTsClient)
    {
        return FALSE;
    }
    TRC_ASSERT(_pTscSet, (TB,_T(" tsc settings does not exist!\n")));

    TRC_ASSERT(_state != stateConnecting &&
               _state != stateConnected,
               (TB,_T("Can't connect in connecting state: 0x%d"),
                _state));


    ResetConnectionSuccessFlag();

    pwndplc = _pTscSet->GetWindowPlacement();
    //
    // Positition the window before connecting
    // so that if it's a fullscreen connection
    // we can determine the correct resolution to connect at.
    // This has to be set before the connection starts
    // 
#ifndef OS_WINCE
    TRC_ASSERT(pwndplc->rcNormalPosition.right - pwndplc->rcNormalPosition.left,
               (TB,_T("0 width")));

    TRC_ASSERT(pwndplc->rcNormalPosition.bottom - pwndplc->rcNormalPosition.top,
       (TB,_T("0 height")));
#endif

    //
    // For fullscreen force the deskwidth/height
    // to match the monitor we're going to connect on
    //
    if (_pTscSet->GetStartFullScreen())
    {
        RECT    rcMonitor;
        int     deskX,deskY;

        CSH::MonitorRectFromNearestRect(&pwndplc->rcNormalPosition,
                                        &rcMonitor);

        deskX = min(rcMonitor.right - rcMonitor.left,MAX_DESKTOP_WIDTH);
        deskY = min(rcMonitor.bottom - rcMonitor.top,MAX_DESKTOP_HEIGHT);
        _pTscSet->SetDesktopWidth( deskX );
        _pTscSet->SetDesktopHeight( deskY );
    }

    //
    // Do security checks on the plain server name (no port, no params)
    //
    hr = _pTscSet->GetConnectString().GetServerNamePortion(
                            szPlainServerName,
                            SIZE_TCHARS(szPlainServerName)
                            );
    if (FAILED(hr)) {
        TRC_ERR((TB,_T("Failed to get plain server name 0x%x"), hr));
        DC_QUIT;
    }

    if (!CTSSecurity::AllowConnection(_hwndMainDialog, _hInst,
                                      szPlainServerName,
                                     _pTscSet->GetDriveRedirection(),
                                     _pTscSet->GetCOMPortRedirection()))
    {
        TRC_ERR((TB,_T("AllowConnection check returned FALSE. Skip connect")));
        fResult = FALSE;

        //
        // If this was an autoconnection then start the dialog
        // up at the LocalResources tab so the user can easily change
        // device redirection options
        //
        if (_pSh->GetAutoConnect())
        {
            //
            // From now on this is not an autoconnection
            //
            _pSh->SetAutoConnect(FALSE);

#ifdef OS_WINCE //dont bring up mstsc ui on WBT.
            if (g_CEConfig == CE_CONFIG_WBT)
                DC_QUIT;
#endif
            //
            // Start the dialog expanded at the local resources tab
            //
            if (!StartConnectDialog(TRUE, TAB_LOCAL_RESOURCES_IDX))
            {
                TRC_ERR((TB,_T("Error bringing up connect dialog")));
                DestroyWindow();
                fResult = FALSE;
            }
        }

        DC_QUIT;
    }

    hr = _pTscSet->ApplyToControl(_pTsClient);
    if (FAILED(hr))
    {
        TRC_ERR((TB,_T("Failed ApplyToControl: %d"), hr));
        fResult = FALSE;
        DC_QUIT;
    }

    //The desktop size from the settings can
    //change during the connection..e.g when a shadow happens.
    //CurrentDesktopWidth/Height stores the instantaneous values
    SetCurrentDesktopWidth( _pTscSet->GetDesktopWidth());
    SetCurrentDesktopHeight( _pTscSet->GetDesktopHeight());

    RecalcMaxWindowSize();

    //Now apply settings that don't come from the settings collection
    hr = _pTsClient->get_Debugger(&pDebugger);
    if (FAILED(hr) || !pDebugger)
    {
        fResult = FALSE;
        DC_QUIT;
    }
    hr = pDebugger->put_CLXCmdLine( T2OLE(_pSh->GetClxCmdLine()));
    if (FAILED(hr))
    {
        TRC_ERR((TB,_T("Failed put_CLXCmdLine: %d"), hr));
        fResult = FALSE;
        DC_QUIT;
    }
    pDebugger->Release();
    pDebugger = NULL;

    //Reset the login complete flag (login event occurs after connect)
    _fLoginComplete = FALSE;

    //Initiate the connection
    hr = _pTsClient->Connect();
    if (SUCCEEDED(hr))
    {
        SET_CONTWND_STATE(stateConnecting);
    }
    else
    {
        TRC_ERR((TB,_T("Connect method failed: %d"), hr));

        TCHAR errConnecting[MAX_PATH];
        if (LoadString(_hInst,
                       UI_IDS_ERR_CONNECTCALLFAILED,
                       errConnecting,
                       SIZECHAR(errConnecting)) != 0)
        {
            MessageBox(GetHwnd(), errConnecting, _szAppName, 
                       MB_ICONERROR | MB_OK);
        }

        fResult = FALSE;
        DC_QUIT;
    }

    //Bring up the connecting dialog and wait for the Connected event
    SetCursor(LoadCursor(NULL, IDC_WAIT));

    if(!IsUsingDialogUI())
    {
        //
        // Only bring this up if we're not using the
        // dialog UI. E.g for autolaunched connections.
        //
        // The dialog UI displays it's own progress indicator
        //
        TCHAR szServerName[TSC_MAX_ADDRESS_LENGTH];
        _pTscSet->GetConnectString().GetServerPortion(
                                szServerName,
                                SIZE_TCHARS(szServerName)
                                );
        CConnectingDlg connectingDlg(
                                _hwndMainDialog, _hInst,
                                this, szServerName
                                );
        connectingDlg.DoModal();
    }

    fResult = TRUE;

DC_EXIT_POINT:
    if (pDebugger)
    {
        pDebugger->Release();
        pDebugger = NULL;
    }

    DC_END_FN();
    return fResult;
}

DCBOOL CContainerWnd::Disconnect()
{
    HRESULT hr;
    short   connectionState = 0;
    DC_BEGIN_FN("Disconnect");
    TRC_ASSERT(_pTsClient, (TB,_T(" Ts client control does not exist!\n")));
    if (!_pTsClient)
    {
        return FALSE;
    }

    TRC_NRM((TB,_T("Container calling control's disconnect")));

    //
    // In some cases the control might already be disconnected
    // check for that
    //
    // NOTE that becasue we are in a STA the connected state
    // of the control can't change after the get_Connected call
    // (untill we go back to pumping messages) so there are no
    // timing issues here.
    //
    TRACE_HR(_pTsClient->get_Connected( & connectionState ));
    if(SUCCEEDED(hr))
    {
        if( connectionState )
        {
            // Still connected disconnect
            hr = _pTsClient->Disconnect();
            if(SUCCEEDED(hr))
            {
                //
                // Successfully initiated disconnect (note it is async)
                // need to wait for OnDisconnected
                //
                return TRUE;
            }
            else
            {
                TRC_ERR((TB,_T("Disconnect() failed 0x%x\n"), hr));
                return FALSE;
            }
        }
        else
        {
            TRC_NRM((TB,_T("Not calling disconnected because already discon")));
            return TRUE; // success
        }
    }
    else
    {
        return FALSE;
    }

    DC_END_FN();
}

LRESULT CContainerWnd::OnDestroy(HWND hWnd, UINT uMsg,
                                 WPARAM wParam, LPARAM lParam)
{
    DC_BEGIN_FN("OnDestroy");

    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    BOOL fShouldDestroy = FALSE;

    if (_fBeenThroughDestroy)
    {
        TRC_ERR((TB,_T("Been through WM_DESTROY before!!!")));
        return 0;
    }
    _fBeenThroughDestroy = TRUE;

    if (InControlEventHandler())
    {
        //
        // Don't allow the close. We are in a code path that fired
        // from the control. Without this, we sometimes see the client
        // receiving close notifications from tclient while a disconnected
        // dialog is up (i.e in an OnDicsconnected handler) - destroying
        // the control at this time causes bad things to happen during 
        // the return into the control (which has now been deleted).
        //
        TRC_ERR((TB,_T("OnDestroy called during a control event handler")));
        return 0;
    }
    else
    {
        fShouldDestroy = TRUE;
    }

#ifdef OS_WINCE
    LRESULT lResult = 0;
#endif
    if(fShouldDestroy)
    {
        //Terminate the app
        _PostedQuit=1;
#ifdef OS_WINCE
        lResult = DefWindowProc( hWnd, uMsg, wParam, lParam);
#else
        return DefWindowProc( hWnd, uMsg, wParam, lParam);
#endif
    }

#ifdef OS_WINCE //CE does not support WM_NCDESTROY. So destroy the activex control and send a WM_NCDESTROY
    if (_pWndView)
    {
        HWND hwndCtl = _pWndView->GetHwnd();
        ::DestroyWindow(hwndCtl);
        SendMessage(hWnd, WM_NCDESTROY, 0, 0L);
    }
#endif

    DC_END_FN();
#ifdef OS_WINCE
    return lResult;
#else
    return 0;
#endif
}

LRESULT CContainerWnd::OnNCDestroy(HWND hWnd, UINT uMsg,
                                   WPARAM wParam, LPARAM lParam)
{
    DC_BEGIN_FN("OnNCDestroy");

    //This is the right time to call postquit message.
    //As the child windows (e.g the control) have been
    //completely destroyed and cleaned up by this point
    if(_fBeenThroughNCDestroy)
    {
        TRC_ERR((TB,_T("Been through WM_NCDESTROY before!!!")));
        return 1L;
    }
    _fBeenThroughNCDestroy = TRUE;
    ExitAndQuit();

    DC_END_FN();
    return 0L;
}

//
// Name:      SetMinMaxPlacement
//                                                                          
// Purpose:   Reset the minimized / maximized placement
//                                                                          
// Returns:   None
//                                                                          
// Params:    windowplacement structure to update
//                                                                          
// Operation: Allow for the window border width.
//                                                                          
//
VOID CContainerWnd::SetMinMaxPlacement(WINDOWPLACEMENT& windowPlacement)
{
    DC_BEGIN_FN("UISetMinMaxPlacement");

    //
    // Set the maximized position to the top left - allow for the window
    // frame width.
    //
#if !defined(OS_WINCE) || defined(OS_WINCE_NONFULLSCREEN)
    windowPlacement.ptMaxPosition.x = -GetSystemMetrics(SM_CXFRAME);
    windowPlacement.ptMaxPosition.y = -GetSystemMetrics(SM_CYFRAME);
#else // !defined(OS_WINCE) || defined(OS_WINCE_NONFULLSCREEN)
    windowPlacement.ptMaxPosition.x = 0;
    windowPlacement.ptMaxPosition.y = 0;
#endif // !defined(OS_WINCE) || defined(OS_WINCE_NONFULLSCREEN)

    //
    // Minimized position is 0, 0
    //
    windowPlacement.ptMinPosition.x = 0;
    windowPlacement.ptMinPosition.y = 0;

#ifndef OS_WINCE
    if (IsZoomed(GetHwnd()))
    {
        windowPlacement.flags |= WPF_RESTORETOMAXIMIZED;
    }
#endif

    DC_END_FN();
    return;
} // UISetMinMaxPlacement

//
// Name:      RecalcMaxWindowSize
//                                                                          
// Purpose:   Recalculates _maxMainWindowSize given the current remote desktop
//            size and frame style. The maximum main window size is the
//            size of window needed such that the client area is the same
//            size as the container.
//                                                                          
// Params:    None
//                                                                          
// Returns:   Nothing
//                                                                          
//
VOID CContainerWnd::RecalcMaxWindowSize(DCVOID)
{
    #ifndef OS_WINCE
    RECT    rect;
    #ifdef OS_WIN32
    BOOL    errorRc;
    #endif
    #endif

    DC_BEGIN_FN("RecalcMaxWindowSize");

    //
    // If current mode is full screen, then the maximum window size is the
    // same as the screen size - unless the container is larger still,
    // which is possible if we're shadowing a session larger than
    // ourselves.
    //                                                                      
    // In this case, or if the current mode is not full screen then we want
    // the size of window which is required for a client area of the size
    // of the container.  Passing the container size to AdjustWindowRect
    // returns this window size.  Such a window may be bigger than the
    // screen, eg server and client are 640x480, container is 640x480.
    // AdjustWindowRect adds on the border, title bar and menu sizes and
    // returns something like 648x525.  So, UI.maxMainWindowSize can only
    // match the actual window size when the client screen is bigger than
    // the server screen or when operating in full screen mode.  This means
    // that UI.maxMainWindowSize should *never* be used to set the window
    // size, eg by passing it to SetWindowPos.  It can be used to determine
    // whether scroll bars are required, ie they are needed if the current
    // window size is less than UI.maxMainWindowSize (in other words,
    // always unless in full screen mode or client screen is larger than
    // server screen).
    //                                                                      
    // To set the window size, calculate a value based on:
    // - the desired window size given the container size
    // - the size of the client screen.
    //
#ifndef OS_WINCE
    //
    // Recalc window size based on container
    //
    rect.left   = 0;
    rect.right  = GetCurrentDesktopWidth();
    rect.top    = 0;
    rect.bottom = GetCurrentDesktopHeight();

#ifdef OS_WIN32
    errorRc = AdjustWindowRect(&rect, WS_OVERLAPPEDWINDOW, FALSE);
    TRC_ASSERT((errorRc != 0), (TB, _T("AdjustWindowRect failed")));
#else
    AdjustWindowRect(&rect, WS_OVERLAPPEDWINDOW, FALSE);
#endif

    _maxMainWindowSize.width = rect.right - rect.left;
    _maxMainWindowSize.height = rect.bottom - rect.top;
#endif

    TRC_NRM((TB, _T("Main Window maxSize (%d,%d)"),
             _maxMainWindowSize.width,
             _maxMainWindowSize.height));

    DC_END_FN();
    return;
}

//
// Name:     GetMaximizedWindowSize
//                                                                          
// Purpose:  Calculates the size to which the main window should be
//           maximized, base on the screen size and the size of window
//           which would have a client area the same size as the
//           container (UI.maxMainWindowSize).
//                                                                          
// Returns:  The calculated size.
//                                                                          
// Params:   None.
//                                                                          
//
DCSIZE CContainerWnd::GetMaximizedWindowSize(DCSIZE& maximizedSize)
{
    DCUINT xSize;
    DCUINT ySize;
    RECT   rc;

    DC_BEGIN_FN("UIGetMaximizedWindowSize");

    //
    // The maximum size we set a window to is the smaller of:
    // -  UI.maxMainWindowSize
    // -  the screen size plus twice the border width (so the borders are
    //    not visible).
    // Always query the monitor rect as it may change
    // width, as these can change dynamically.
    //
    CSH::MonitorRectFromHwnd(GetHwnd(), &rc);

    xSize = rc.right - rc.left;
    ySize = rc.bottom - rc.top;

#ifdef OS_WINCE
    maximizedSize.width  =  DC_MIN(_maxMainWindowSize.width,xSize);

    maximizedSize.height =  DC_MIN(_maxMainWindowSize.height,ySize);

#else // This section NOT OS_WINCE
    maximizedSize.width = DC_MIN(_maxMainWindowSize.width,
                                 xSize + (2 * GetSystemMetrics(SM_CXFRAME)));

    maximizedSize.height = DC_MIN(_maxMainWindowSize.height,
                                  ySize + (2 * GetSystemMetrics(SM_CYFRAME)));
#endif // OS_WINCE

    TRC_NRM((TB, _T("Main Window maxSize (%d,%d) maximizedSize (%d,%d) "),
             _maxMainWindowSize.width,
             _maxMainWindowSize.height,
             maximizedSize.width,
             maximizedSize.height));

    DC_END_FN();

    return(maximizedSize);
}

LRESULT CContainerWnd::OnMove(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    DC_BEGIN_FN("OnMove");

    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);

    #ifndef OS_WINCE

    //No-op when fullscreen
    if (!_bContainerIsFullScreen)
    {
        WINDOWPLACEMENT* pWindowPlacement = NULL;

        pWindowPlacement = _pTscSet->GetWindowPlacement();
        TRC_ASSERT(pWindowPlacement, (TB, _T("pWindowPlacement is NULL\n")));
        if (pWindowPlacement)
        {
            GetWindowPlacement(GetHwnd(), pWindowPlacement);
        }
    }
    
    #endif

    DC_END_FN();
    DC_EXIT_POINT:
    return 0;
}

LRESULT CContainerWnd::OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = E_FAIL;
    DC_BEGIN_FN("OnSize");

    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);

    WINDOWPLACEMENT* pWindowPlacement = NULL;

#ifndef OS_WINCE
    if (!_bContainerIsFullScreen)
    {
        // We're non-fullscreen, so keep the window placement structure
        // up-to-date
        pWindowPlacement = _pTscSet->GetWindowPlacement();
        TRC_ASSERT(pWindowPlacement, (TB, _T("pWindowPlacement is NULL\n")));
        if (!pWindowPlacement)
        {
            return 0;
        }
        //
        // Update ShellUtil's current windowplacement info
        //
        GetWindowPlacement(GetHwnd(), pWindowPlacement);

        TRC_DBG((TB, _T("Got window placement in WM_SIZE")));

        if (wParam == SIZE_MAXIMIZED)
        {
            TRC_DBG((TB, _T("Maximize")));

#if !defined(OS_WINCE) || defined(OS_WINCE_WINDOWPLACEMENT)
            //
            // Override the maximized / minimized positions with our
            // hardcoded valued - required if the maximized window is
            // moved.
            //
            if (pWindowPlacement)
            {
                SetMinMaxPlacement(*pWindowPlacement);
                SetWindowPlacement(GetHwnd(), pWindowPlacement);
            }
#endif // !defined(OS_WINCE) || defined(OS_WINCE_WINDOWPLACEMENT)

            //
            // We need to be accurate about the maximized window size.
            // It is not possible to use UI.maxMainWindowSize as this
            // may be greater than screen size, eg server and client
            // are 640x480, container is 640x480 then UI.maxWindowSize
            // (obtained via AdjustWindowRect in UIRecalcMaxMainWindow)
            // is something like 648x525.
            // Passing this value to SetWindowPos has results which
            // vary with different shells:
            // Win95/NT4.0: the resulting window is 648x488 at -4, -4,
            //              ie all the window, except the border, is
            //              on-screen
            // Win31/NT3.51: the resulting window is 648x525 at -4, -4,
            //               ie the size passed to SetWindowPos, so
            //               the bottom 40 pixels are off-screen.
            // To avoid such differences calculate a maximized window
            // size value which takes account of both the physical
            // screen size and the ideal window size.
            //
            RecalcMaxWindowSize();
            DCSIZE maximized;
            GetMaximizedWindowSize(maximized);
            SetWindowPos( GetHwnd(),
                          NULL,
                          0, 0,
                          maximized.width,
                          maximized.height,
                          SWP_NOZORDER | SWP_NOMOVE |
                          SWP_NOACTIVATE | SWP_NOOWNERZORDER );
        }
    }
#endif
    //
    // Size the child window (activeX control) accordingly
    //

    RECT rcClient;
    GetClientRect(GetHwnd(), &rcClient);
    if (_pWndView)
    {
        HWND hwndCtl = _pWndView->GetHwnd();
        ::MoveWindow(hwndCtl,rcClient.left, rcClient.top,
                     rcClient.right, rcClient.bottom,
                     TRUE);
    }

    DC_END_FN();
    DC_EXIT_POINT:
    return 0;
}

LRESULT CContainerWnd::OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    DC_BEGIN_FN("OnCommand");

    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(lParam);

    switch (DC_GET_WM_COMMAND_ID(wParam))
    {
    case UI_IDM_CONNECT:
        {
            if (!StartConnectDialog())
            {
                return 1;
            }
        }
        break;
    }

    DC_END_FN();
    return 0;
}

//
// StartConnectionDialog
// Params: fStartExpanded - startup the dialog in the expanded state
//         nStartTabIndex - index of the tab to show on startup (only applies
//                          if fStartExpanded is set)
//
//
BOOL CContainerWnd::StartConnectDialog(BOOL fStartExpanded,
                                       INT  nStartTabIndex)
{
    DC_BEGIN_FN("StartConnectDialog");

    TRC_DBG((TB, _T("Connect selected")));
    SetCursor(LoadCursor(NULL, IDC_WAIT));

    //Show the dialog box only if auto connect is not enabled or
    //if UIValidateCurrentParams fails.
    if (!_pSh->GetAutoConnect() || !_pSh->SH_ValidateParams(_pTscSet))
    {
        if (!_pMainDlg)
        {
            _pMainDlg = new CMainDlg( NULL, _hInst, _pSh,
                                      this,
                                      _pTscSet,
                                      fStartExpanded,
                                      nStartTabIndex);
        }

        TRC_ASSERT(_pMainDlg, (TB,_T("Could not create main dialog")));
        if (_pMainDlg)
        {
            if (_fFirstTimeToLogonDlg)
            {
                TRC_ASSERT(_hwndMainDialog == NULL,
                           (TB,(_T("Dialog exists before first time create!!!\n"))));

                _pSh->SH_AutoFillBlankSettings(_pTscSet);

                _hwndMainDialog = _pMainDlg->StartModeless();
                ::ShowWindow( _hwndMainDialog, SW_RESTORE);
            }
            else
            {
                //
                // Just show the dialog
                //
                TRC_ASSERT(_hwndMainDialog,
                           (TB,_T("_hwndMainDialog is not present")));
                ::ShowWindow( _hwndMainDialog, SW_RESTORE);
                SetForegroundWindow(_hwndMainDialog);
            }

            _fFirstTimeToLogonDlg = FALSE;
        }
        else
        {
#ifdef OS_WINCE
            SetCursor(LoadCursor(NULL, IDC_ARROW));
#endif
            return FALSE;
        }
    }

#ifdef OS_WINCE
    SetCursor(LoadCursor(NULL, IDC_ARROW));
#endif

    DC_END_FN();
    return TRUE;
}

LRESULT CContainerWnd::OnSysCommand(UINT uMsg, WPARAM wParam,
                                    LPARAM lParam)
{
    HRESULT hr = E_FAIL;
    ULONG scCode = 0;
    DC_BEGIN_FN("OnSysCommand");

    #ifndef OS_WINCE
    scCode = (LOWORD(wParam) & 0xFFF0);
    if (scCode == SC_MAXIMIZE)
    {
        //
        // If the remote resolution matches
        // the current monitor then maximize
        // becomes 'go fullscreen'
        //
        if ( IsRemoteResMatchMonitorSize() )
        {
            hr = _pTsClient->put_FullScreen( VARIANT_TRUE );
            if (FAILED(hr))
            {
                TRC_ERR((TB,_T("put_FullScreen failed 0x%x\n"),
                         hr));
            }
            return 0;
        }
        else
        {
            //
            // Default maximize behavior
            //
            return DefWindowProc( GetHwnd(), uMsg, wParam, lParam);
        }
    }
    else if (scCode == SC_MINIMIZE)
    {
        //
        // If we are minimizing while still fullscreen tell the shell
        // we are no longer fullscreen otherwise it treats us as a rude
        // app and nasty stuff happens. E.g. we get switched to and maximized
        // on a timer.
        //
        if (_bContainerIsFullScreen) {
            CUT::NotifyShellOfFullScreen( GetHwnd(),
                                          FALSE,
                                          &_pTaskBarList2,
                                          &_fQueriedForTaskBarList2 );
        }
    }
    else if (scCode == SC_RESTORE)
    {
        //
        // If we are restoring and going back to Fscreen
        // tell the shell to mark us
        //
        if (_bContainerIsFullScreen) {
            CUT::NotifyShellOfFullScreen( GetHwnd(),
                                          TRUE,
                                          &_pTaskBarList2,
                                          &_fQueriedForTaskBarList2 );
        }
    }


    #endif

    switch (DC_GET_WM_COMMAND_ID(wParam))
    {
    case UI_IDM_ABOUT:
        {
            // Show the about box dialog
            CAboutDlg aboutDialog( GetHwnd(),
                                   _hInst,
                                   _pSh->GetCipherStrength(),
                                   _pSh->GetControlVersionString());
            aboutDialog.DoModal();
        }
        break;

    case UI_IDM_HELP_ON_CLIENT:
        {
            //
            // Display help for the connect dialog.
            //
#ifndef OS_WINCE
            TRC_NRM((TB, _T("Display the appropriate help page")));

            if (GetHwnd() && _pSh)
            {
                _pSh->SH_DisplayClientHelp(
                    GetHwnd(),
                    HH_DISPLAY_TOPIC);
            }
#endif
        }
        break;

#ifdef DC_DEBUG
    case UI_IDM_BITMAPCACHEMONITOR:
        {
            //
            // Toggle the Bitmap Cache Monitor setting.
            //
            TRC_ASSERT(_pTsClient,(TB, _T("_pTsClient is NULL on syscommand")));
            if (_pTsClient)
            {
                IMsTscDebug* pDebugger = NULL;
                TRACE_HR(_pTsClient->get_Debugger(&pDebugger));
                if(SUCCEEDED(hr))
                {
                    BOOL bmpCacheMonitor;
                    TRACE_HR(pDebugger->get_BitmapCacheMonitor(&bmpCacheMonitor));
                    if(SUCCEEDED(hr))
                    {
                        bmpCacheMonitor = !bmpCacheMonitor;
                        TRACE_HR(pDebugger->put_BitmapCacheMonitor(bmpCacheMonitor));

                        if(SUCCEEDED(hr))
                        {
                            CheckMenuItem(_hSystemMenu,
                                          UI_IDM_BITMAPCACHEMONITOR,
                                         bmpCacheMonitor ? MF_CHECKED : MF_UNCHECKED);
                        }
                    }
                    pDebugger->Release();
                }
            }
        }
        break;

    case UI_IDM_HATCHBITMAPPDUDATA:
        {
            //
            // Toggle the hatch bitmap PDU data setting.
            //
            TRC_ASSERT(_pTsClient,(TB, _T("_pTsClient is NULL on syscommand")));
            if (_pTsClient)
            {
                IMsTscDebug* pDebugger = NULL;
                TRACE_HR(_pTsClient->get_Debugger(&pDebugger));
                if(SUCCEEDED(hr))
                {
                    BOOL hatchBitmapPDU;
                    TRACE_HR(pDebugger->get_HatchBitmapPDU(&hatchBitmapPDU));
                    if(SUCCEEDED(hr))
                    {
                        hatchBitmapPDU = !hatchBitmapPDU;
                        TRACE_HR(pDebugger->put_HatchBitmapPDU(hatchBitmapPDU));
                        if(SUCCEEDED(hr))
                        {
                            CheckMenuItem(_hSystemMenu,
                                          UI_IDM_HATCHBITMAPPDUDATA,
                                          hatchBitmapPDU ? MF_CHECKED : MF_UNCHECKED);
                        }
                    }
                    pDebugger->Release();
                }
            }
        }
        break;

    case UI_IDM_HATCHINDEXPDUDATA:
        {
            //
            // Toggle the hatch index PDU data setting.
            //
            TRC_ASSERT(_pTsClient,(TB, _T("_pTsClient is NULL on syscommand")));
            if (_pTsClient)
            {
                IMsTscDebug* pDebugger = NULL;
                TRACE_HR(_pTsClient->get_Debugger(&pDebugger));
                if(SUCCEEDED(hr))
                {
                    BOOL hatchIndexPDU;
                    TRACE_HR(pDebugger->get_HatchIndexPDU(&hatchIndexPDU));
                    if(SUCCEEDED(hr))
                    {
                        hatchIndexPDU = !hatchIndexPDU;
                        TRACE_HR(pDebugger->put_HatchIndexPDU(hatchIndexPDU));
                        if(SUCCEEDED(hr))
                        {
                            CheckMenuItem(_hSystemMenu,
                                          UI_IDM_HATCHINDEXPDUDATA,
                                          hatchIndexPDU ? MF_CHECKED : MF_UNCHECKED);
                        }
                    }
                    pDebugger->Release();
                }
            }
        }
        break;

    case UI_IDM_HATCHSSBORDERDATA:
        {
            //
            // Toggle the hatch SSB order data setting.
            //
            TRC_ASSERT(_pTsClient,(TB, _T("_pTsClient is NULL on syscommand")));
            if (_pTsClient)
            {
                IMsTscDebug* pDebugger = NULL;
                TRACE_HR(_pTsClient->get_Debugger(&pDebugger));
                if(SUCCEEDED(hr))
                {
                    BOOL hatchSSBorder;
                    TRACE_HR(pDebugger->get_HatchSSBOrder(&hatchSSBorder));
                    if(SUCCEEDED(hr))
                    {
                        hatchSSBorder = !hatchSSBorder;
                        TRACE_HR(pDebugger->put_HatchSSBOrder(hatchSSBorder));
                        if(SUCCEEDED(hr))
                        {
                            CheckMenuItem(_hSystemMenu,
                                          UI_IDM_HATCHSSBORDERDATA,
                                          hatchSSBorder ? MF_CHECKED : MF_UNCHECKED);
                        }
                    }
                    pDebugger->Release();
                }
            }
        }
        break;

    case UI_IDM_HATCHMEMBLTORDERDATA:
        {
            //
            // Toggle the hatch memblt order data setting.
            //
            TRC_ASSERT(_pTsClient,(TB, _T("_pTsClient is NULL on syscommand")));
            if (_pTsClient)
            {
                IMsTscDebug* pDebugger = NULL;
                TRACE_HR(_pTsClient->get_Debugger(&pDebugger));
                if(SUCCEEDED(hr))
                {
                    BOOL hatchMemBlt;
                    TRACE_HR(pDebugger->get_HatchMembltOrder(&hatchMemBlt));
                    if(SUCCEEDED(hr))
                    {
                        hatchMemBlt = !hatchMemBlt;
                        hr = pDebugger->put_HatchMembltOrder(hatchMemBlt);
                        if(SUCCEEDED(hr))
                        {
                            CheckMenuItem(_hSystemMenu,
                                          UI_IDM_HATCHMEMBLTORDERDATA,
                                          hatchMemBlt ? MF_CHECKED : MF_UNCHECKED);
                        }
                    }
                    pDebugger->Release();
                }
            }
        }
        break;

    case UI_IDM_LABELMEMBLTORDERS:
        {
            //
            // Toggle the label memblt orders setting.
            //
            TRC_ASSERT(_pTsClient,(TB, _T("_pTsClient is NULL on syscommand")));
            if (_pTsClient)
            {
                IMsTscDebug* pDebugger = NULL;
                TRACE_HR(_pTsClient->get_Debugger(&pDebugger));
                if(SUCCEEDED(hr))
                {
                    BOOL labelMemBltOrders;
                    TRACE_HR(pDebugger->get_LabelMemblt(&labelMemBltOrders));
                    if(SUCCEEDED(hr))
                    {
                        labelMemBltOrders = !labelMemBltOrders;
                        hr = pDebugger->put_LabelMemblt(labelMemBltOrders);
                        if(SUCCEEDED(hr))
                        {
                            CheckMenuItem(_hSystemMenu,
                                          UI_IDM_LABELMEMBLTORDERS,
                                          labelMemBltOrders ? MF_CHECKED : MF_UNCHECKED);
                        }
                    }
                    pDebugger->Release();
                }
            }
        }
        break;

    case UI_IDM_MALLOCFAILURE:
        {
            //
            // Malloc failures dialog box
            //
            TRC_ASSERT(_pTsClient,(TB, _T("_pTsClient is NULL on syscommand")));
            if (_pTsClient)
            {
                IMsTscDebug* pDebugger = NULL;
                TRACE_HR(_pTsClient->get_Debugger(&pDebugger));
                if(SUCCEEDED(hr))
                {
                    LONG failPercent;
                    TRACE_HR(pDebugger->get_MallocFailuresPercent(&failPercent));
                    if(SUCCEEDED(hr))
                    {
                        CMallocDbgDlg mallocFailDialog(GetHwnd(), _hInst, (DCINT)failPercent,
                                                       FALSE); //don't use malloc huge dialog
                        if (IDOK == mallocFailDialog.DoModal())
                        {
                            failPercent = mallocFailDialog.GetFailPercent();
                            TRC_NRM((TB,_T("Setting malloc FAILURE PERCENT to:%d"), failPercent));
                            TRACE_HR(pDebugger->put_MallocFailuresPercent(failPercent));
                        }
                    }
                    pDebugger->Release();
                }
            }
        }
        break;

    case UI_IDM_MALLOCHUGEFAILURE:
        {
            TRC_ASSERT(_pTsClient,(TB, _T("_pTsClient is NULL on syscommand")));
            if (_pTsClient)
            {
                IMsTscDebug* pDebugger = NULL;
                TRACE_HR(_pTsClient->get_Debugger(&pDebugger));
                if(SUCCEEDED(hr))
                {
                    LONG failPercent;
                    TRACE_HR(pDebugger->get_MallocHugeFailuresPercent(&failPercent));
                    if(SUCCEEDED(hr))
                    {
                        CMallocDbgDlg mallocFailDialog(GetHwnd(), _hInst, (DCINT)failPercent,
                                                       TRUE); //use malloc huge dialog
                        if (IDOK == mallocFailDialog.DoModal())
                        {
                            failPercent = mallocFailDialog.GetFailPercent();
                            TRC_NRM((TB,_T("Setting malloc FAILURE PERCENT to:%d"), failPercent));
                            TRACE_HR(pDebugger->put_MallocHugeFailuresPercent(failPercent));
                        }
                    }
                    pDebugger->Release();
                }
            }
        }
        break;

    case UI_IDM_NETWORKTHROUGHPUT:
        {
            //
            // Limit net thruput
            //
            TRC_ASSERT(_pTsClient,(TB, _T("_pTsClient is NULL on syscommand")));
            if (_pTsClient)
            {
                IMsTscDebug* pDebugger = NULL;
                TRACE_HR(_pTsClient->get_Debugger(&pDebugger));
                if(SUCCEEDED(hr))
                {
                    LONG netThruPut;
                    TRACE_HR(pDebugger->get_NetThroughput(&netThruPut));
                    if(SUCCEEDED(hr))
                    {
                        CThruPutDlg thruPutDialog(GetHwnd(), _hInst, (DCINT)netThruPut);

                        if (IDOK == thruPutDialog.DoModal())
                        {
                            netThruPut = thruPutDialog.GetNetThruPut();
                            TRC_NRM((TB,_T("Setting thruput to:%d"), netThruPut));
                            TRACE_HR(pDebugger->put_NetThroughput(netThruPut));

                        }
                    }
                    pDebugger->Release();
                }
            }
        }
        break;

#ifdef SMART_SIZING
    case UI_IDM_SMARTSIZING:
        {
            TRC_ASSERT(_pTsClient,(TB, _T("_pTsClient is NULL on syscommand")));
            if (_pTsClient)
            {
                IMsRdpClientAdvancedSettings* pAdvSettings = NULL;
                HRESULT hr = _pTsClient->get_AdvancedSettings2(&pAdvSettings);

                VARIANT_BOOL fSmartSizing;
                if (SUCCEEDED(hr)) {
                    hr = pAdvSettings->get_SmartSizing(&fSmartSizing);
                }

                if (SUCCEEDED(hr)) {
                    fSmartSizing = !fSmartSizing;
                    hr = pAdvSettings->put_SmartSizing(fSmartSizing);
                }

                if (SUCCEEDED(hr)) {
#ifndef OS_WINCE // no menus available
                    CheckMenuItem(_hSystemMenu,
                                  UI_IDM_SMARTSIZING,
                                  fSmartSizing ? MF_CHECKED : MF_UNCHECKED);
#endif

                    _pTscSet->SetSmartSizing(fSmartSizing);
                }


                if (pAdvSettings != NULL) {
                    pAdvSettings->Release();
                }
            }
        }
        break;

#endif // SMART_SIZING

#endif //DC_DEBUG

    default:
        {
            DefWindowProc(GetHwnd(), uMsg, wParam, lParam);
        }
        break;
    }

    DC_END_FN();
    return 0;
}
#ifndef OS_WINCE
LRESULT CContainerWnd::OnInitMenu(UINT uMsg, WPARAM wParam, LPARAM lParam)
{

    ::EnableMenuItem((HMENU)wParam,  SC_MOVE , 
                     _bContainerIsFullScreen ? MF_GRAYED : MF_ENABLED);
    return 0;
}

LRESULT CContainerWnd::OnGetMinMaxInfo(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    DC_BEGIN_FN("OnGetMinMaxInfo");

    LPMINMAXINFO pinfo = (LPMINMAXINFO)lParam;
    DCSIZE maxTrack;

    RECT rc;
    GetClientRect( GetHwnd(), &rc);
    CalcTrackingMaxWindowSize( rc.right - rc.left,
                               rc.bottom - rc.top,
                               &maxTrack.width,
                               &maxTrack.height );

    pinfo->ptMaxTrackSize.x = maxTrack.width;
    pinfo->ptMaxTrackSize.y = maxTrack.height;

    DC_END_FN();

    return 0;
}
#endif //OS_WINCE

LRESULT CContainerWnd::OnSetFocus(UINT  uMsg, WPARAM wParam, LPARAM lParam)
{
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    
    DC_BEGIN_FN("OnSetFocus");

    //
    // Give focus to the control when we get activated
    // Except when we are in a size/move modal loop
    //
    if (IsOkToToggleFocus() && !_fInSizeMove)
    {
        TRC_NRM((TB,_T("Passing focus to control")));
        ::SetFocus(_pWndView->GetHwnd());
    }

    DC_END_FN();
    return 0;
}

LRESULT CContainerWnd::OnActivate(UINT  uMsg, WPARAM wParam, LPARAM lParam)
{
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(lParam);

    DC_BEGIN_FN("OnActivate");

    if (WA_INACTIVE != wParam)
    {
        //Give focus to the control when we get activated
        if (IsOkToToggleFocus() && !_fInSizeMove)
        {
            TRC_NRM((TB,_T("Passing focus to control")));
            ::SetFocus(_pWndView->GetHwnd());
        }
    }
#ifdef OS_WINCE
    AutoHideCE(_pWndView->GetHwnd(), wParam);
#endif

    DC_END_FN();
    return 0;
}

LRESULT CContainerWnd::OnWindowPosChanging(UINT  uMsg, WPARAM wParam, LPARAM lParam)
{
    DC_BEGIN_FN("OnWindowPosChanging");

#ifndef OS_WINCE
    LPWINDOWPOS lpwp;
    DCUINT      maxWidth;
    DCUINT      maxHeight;
    DCUINT cliWidth, cliHeight;

    if (_bContainerIsFullScreen)
    {
        TRC_DBG((TB, _T("WM_WINDOWPOSCHANGING; no-op when fullscreen")));
        DC_QUIT;
    }


    lpwp = (LPWINDOWPOS)lParam;

    if (lpwp->flags & SWP_NOSIZE)
    {
        //
        // We're not sizing so we don't care.
        //
        TRC_DBG((TB, _T("WM_WINDOWPOSCHANGING, but no sizing")));
        DC_QUIT;
    }

    TRC_DBG((TB, _T("WM_WINDOWPOSCHANGING, new size %dx%d"),
             lpwp->cx, lpwp->cy));

    //
    // Max size of the window changes depending on w/not scroll bars are
    // visible. The control has properties for scroll bar visibility but
    // we can't use these because the control is a child window so there is
    // no guarantee that it has update it's scroll bar visilibity in response
    // to this message yet.
    // which means there could be a moment where a gray border appears around the
    // client container window.
    // instead we just compute if scroll bars would be visible in the core.
    //

    cliWidth = lpwp->cx;
    cliHeight = lpwp->cy;

    CalcTrackingMaxWindowSize( cliWidth, cliHeight, &maxWidth, &maxHeight);

    //
    // Restrict size of window
    //
    if ((DCUINT)lpwp->cx > maxWidth)
    {
        RECT rect;

        //
        // Clip the width - reset SWP_NOSIZE as a size change is
        // required.
        //
        TRC_NRM((TB, _T("Clip cx from %u to %u"), lpwp->cx, maxWidth));
        lpwp->cx = maxWidth;
        lpwp->flags &= ~SWP_NOSIZE;

        GetWindowRect(GetHwnd(), &rect);

        if (lpwp->x < rect.left)
        {
            //
            // If dragging left then we need to stop at the point
            // where the window is maxWidth wide.  Reset SWP_NOMOVE
            // as a move is required.
            //
            TRC_NRM((TB, _T("Reset x from %d to %d"),
                     lpwp->x, rect.right-maxWidth));
            lpwp->x = rect.right - maxWidth;
            lpwp->flags &= ~SWP_NOMOVE;
        }
    }

    if ((DCUINT)lpwp->cy > maxHeight)
    {
        RECT rect;

        //
        // Clip the height - reset SWP_NOSIZE as a size change is
        // required.
        //
        TRC_NRM((TB, _T("Clip cy from %u to %u"), lpwp->cy, maxHeight));
        lpwp->cy = maxHeight;
        lpwp->flags &= ~SWP_NOSIZE;

        GetWindowRect( GetHwnd(),&rect);

        if (lpwp->y < rect.top)
        {
            //
            // If dragging upward then we need to stop at the point
            // where the window is maxHeight high. Reset SWP_NOMOVE
            // as a move is required.
            //
            TRC_NRM((TB, _T("Reset y from %d to %d"),
                     lpwp->y, rect.bottom-maxHeight));
            lpwp->y = rect.bottom - maxHeight;
            lpwp->flags &= ~SWP_NOMOVE;
        }
    }
#endif //OS_WINCE

    DC_EXIT_POINT:
    DC_END_FN();
    return 0;
}

DCVOID CContainerWnd::OnConnected()
{
    USES_CONVERSION;

    HRESULT hr;
    BOOL fFullScreen = FALSE;
    VARIANT_BOOL vbfFScreen = VARIANT_FALSE;

    DC_BEGIN_FN("OnConnected");

    EnterEventHandler();

    //Signal that we've connected at least once
    _fHaveConnected = TRUE;

    SET_CONTWND_STATE(stateConnected);

    _successConnectCount++;
    SetConnectionSuccessFlag();

    //
    /// Make sure the 'connecting...' dialog is gone.
    //
    if (!IsUsingDialogUI() && ::IsWindow(_hwndStatusDialog))
    {
        PostMessage( _hwndStatusDialog, WM_CLOSE, __LINE__, 0xBEEBBAAB);
    }
    if (::IsWindow(_hwndMainDialog))
    {
        //
        //Inform the dialog that connection has happened
        //
        PostMessage(_hwndMainDialog, WM_TSC_CONNECTED, 0, 0);
        ShowWindow( _hwndMainDialog, SW_HIDE);
    }

    TCHAR fullFrameTitleStr[SH_FRAME_TITLE_RESOURCE_MAX_LENGTH +
                              SH_REGSESSION_MAX_LENGTH];

    TCHAR frameTitleString[SH_FRAME_TITLE_RESOURCE_MAX_LENGTH];

    //
    // Set the window title.
    // include the session name (unless we're on the default file)
    //
    if (_tcscmp(_szPathToDefaultFile,
                _pTscSet->GetFileName()))
    {
        if (LoadString( _hInst,
                        UI_IDS_FRAME_TITLE_CONNECTED,
                        frameTitleString,
                        SH_FRAME_TITLE_RESOURCE_MAX_LENGTH ))
        {
            TCHAR szSessionName[MAX_PATH];
            if (!_pSh->GetRegSessionSpecified())
            {
                //
                // Session name is parsed from the current
                // connection file.
                //
                CSH::SH_GetNameFromPath(_pTscSet->GetFileName(),
                                        szSessionName,
                                        SIZECHAR(szSessionName));
            }
            else
            {
                _tcsncpy(szSessionName, _pSh->GetRegSession(),
                         SIZECHAR(szSessionName));
            }
            DC_TSPRINTF(fullFrameTitleStr,
                        frameTitleString,
                        szSessionName,
                        _pTscSet->GetFlatConnectString());
        }
        else
        {
            TRC_ERR((TB,_T("Failed to find UI frame title")));
            fullFrameTitleStr[0] = (DCTCHAR) 0;
        }
    }
    else
    {
        // Title does not include session name
        if (LoadString( _hInst,
                        UI_IDS_FRAME_TITLE_CONNECTED_DEFAULT,
                        frameTitleString,
                        SH_FRAME_TITLE_RESOURCE_MAX_LENGTH ))
        {
            DC_TSPRINTF(fullFrameTitleStr,
                        frameTitleString,
                        _pTscSet->GetFlatConnectString());
        }
        else
        {
            TRC_ERR((TB,_T("Failed to find UI frame title")));
            fullFrameTitleStr[0] = (DCTCHAR) 0;
        }
    }

    SetWindowText( GetHwnd(), fullFrameTitleStr);

    //
    // Inform the control of the window title (used when it goes fullscreen)
    //

    OLECHAR* poleTitle = T2OLE(fullFrameTitleStr);
    TRC_ASSERT( poleTitle, (TB, _T("T2OLE failed on poleTitle\n")));
    if (poleTitle)
    {
        hr = _pTsClient->put_FullScreenTitle( poleTitle);
        if (FAILED(hr))
        {
            TRC_ABORT((TB,_T("put_FullScreenTitle failed\n")));
        }
    }

    hr = _pTsClient->get_FullScreen( &vbfFScreen);
    if (SUCCEEDED(hr))
    {
        fFullScreen = (vbfFScreen != VARIANT_FALSE);
    }
    else
    {
        TRC_ABORT((TB,_T("get_FullScreen failed\n")));
    }

    PWINDOWPLACEMENT pwndplc = _pTscSet->GetWindowPlacement();
    if (pwndplc)
    {
#ifndef OS_WINCE
        EnsureWindowIsCompletelyOnScreen( &pwndplc->rcNormalPosition );

        TRC_ASSERT(pwndplc->rcNormalPosition.right -
                   pwndplc->rcNormalPosition.left,
                   (TB,_T("0 width")));

        TRC_ASSERT(pwndplc->rcNormalPosition.bottom -
                   pwndplc->rcNormalPosition.top,
           (TB,_T("0 height")));
#endif
    }

#ifndef OS_WINCE
    if (!fFullScreen)
    {
        if (!SetWindowPlacement( GetHwnd(), pwndplc))
        {
            TRC_ABORT((TB,_T("Failed to set window placement")));
        }
    }
#endif

#ifndef OS_WINCE
    WINDOWPLACEMENT* pWndPlc = _pTscSet->GetWindowPlacement();
    INT defaultShowWindowFlag = SW_SHOWNORMAL;
    if(1 == _successConnectCount)
    {
        //On first connection, override the
        //window placement with startup info (if specified)
        
        //Use the 'A' version to avoid wrapping
        //we only care about numeric fields anyway
        STARTUPINFOA si;
        GetStartupInfoA(&si);
        if((si.dwFlags & STARTF_USESHOWWINDOW) &&
            si.wShowWindow != SW_SHOWNORMAL)
        {
            defaultShowWindowFlag = si.wShowWindow;
        }
    }
    if (pWndPlc)
    {
        if(SW_SHOWNORMAL != defaultShowWindowFlag)
        {
            pWndPlc->showCmd = defaultShowWindowFlag;
        }

        ShowWindow( GetHwnd(), pWndPlc->showCmd);
    }
    else
    {
        ShowWindow( GetHwnd(), defaultShowWindowFlag);
    }
#else //OS_WINCE
    ShowWindow( GetHwnd(), SW_SHOWNORMAL); 
#endif //OS_WINCE

    _fClientWindowIsUp = TRUE;

    LeaveEventHandler();
    DC_END_FN();
}

DCVOID CContainerWnd::OnLoginComplete()
{
    DC_BEGIN_FN("OnLoginComplete");

    EnterEventHandler();

    _fLoginComplete = TRUE;

    LeaveEventHandler();

    DC_END_FN();
}

DCVOID CContainerWnd::OnDisconnected(DCUINT discReason)
{
    DC_BEGIN_FN("OnDisconnected");

#ifndef OS_WINCE
    HRESULT hr;
#endif
    UINT  mainDiscReason;
    ExtendedDisconnectReasonCode extendedDiscReason;

    EnterEventHandler();

    if(FAILED(_pTsClient->get_ExtendedDisconnectReason(&extendedDiscReason)))
    {
        extendedDiscReason = exDiscReasonNoInfo;
    }

    //
    // We just got disconnected as part of the connection
    //
    SET_CONTWND_STATE(stateNotConnected);


    //
    // Once we've been disconnected can go through
    // close again
    //
    _fPreventClose = FALSE;

    //
    // Make sure the 'connecting...' dialog is gone.
    //
    if (!IsUsingDialogUI() && ::IsWindow(_hwndStatusDialog))
    {
        ::PostMessage(_hwndStatusDialog, WM_CLOSE, 0, 0);
    }
    
    if (IsUsingDialogUI() && ::IsWindow(_hwndMainDialog))
    {
        //Inform dialog of disconnection
        PostMessage(_hwndMainDialog, WM_TSC_DISCONNECTED, 0, 0);
    }

    //
    // If this is a user-initiated disconnect, don't do a popup.
    //
    mainDiscReason = NL_GET_MAIN_REASON_CODE(discReason);
    if (((discReason != UI_MAKE_DISCONNECT_ERR(UI_ERR_NORMAL_DISCONNECT)) &&
         (mainDiscReason != NL_DISCONNECT_REMOTE_BY_USER) &&
         (mainDiscReason != NL_DISCONNECT_LOCAL)) ||
         (exDiscReasonReplacedByOtherConnection == extendedDiscReason))
    {
        TRC_ERR((TB, _T("Unexpected disconnect - inform user")));

        //Normal disconnect dialog displayed
        if (!_fClientWindowIsUp && ::IsWindow(_hwndMainDialog))
        {
            // If the connection dialog is around, we need to get that to
            // display the error popup, otherwise the popup won't be modal
            // and could get left lying around.  That can cause state
            // problems with the client.
            //
            // It would be nice to use SendMessage here, so that we always
            // block at this point when displaying the dialog.  However,
            // using SendMessage results in a disconnect dialog that is not
            // modal with respect to the connect dialog.
            //
            // However, because PostMessage is asynchronous, the dialog box
            // procedure calls back into CContainerWnd to finish the disconnection
            // process.
            TRC_NRM((TB, _T("Connection dialog present - use it to show popup")));
            ::PostMessage(_hwndMainDialog, UI_SHOW_DISC_ERR_DLG,
                          discReason,
                          (LPARAM)extendedDiscReason);
        }
        else
        {
            TRC_NRM((TB, _T("Connection dialog not present - do popup here")));
            CDisconnectedDlg disconDlg(GetHwnd(), _hInst, this);
            disconDlg.SetDisconnectReason( discReason);
            disconDlg.SetExtendedDiscReason( extendedDiscReason);
            disconDlg.DoModal();
        }
    }
    else
    {
        //
        // Pickup settings that the server may have updated
        //
        HRESULT hr = _pTscSet->GetUpdatesFromControl(_pTsClient);
        if (FAILED(hr))
        {
            TRC_ERR((TB,_T("GetUpdatesFromControl failed")));
        }

        if( GetConnectionSuccessFlag() )
        {
            //
            // Update the MRU list if we just
            // disconnected from a successful connect
            //
            _pTscSet->UpdateRegMRU((LPTSTR)_pTscSet->GetFlatConnectString());
        }

        if (::IsWindow(_hwndMainDialog))
        {
            ::SendMessage( _hwndMainDialog, WM_UPDATEFROMSETTINGS,0,0);
        }

        //
        // If login has completed then we should exit the app on
        // disconnection.
        //
        FinishDisconnect(_fLoginComplete); 
    }

    _fClientWindowIsUp = FALSE;

    LeaveEventHandler();
    DC_END_FN();
}

LRESULT CContainerWnd::OnClose(UINT  uMsg, WPARAM wParam, LPARAM lParam)
{
    DC_BEGIN_FN("OnClose");

    HRESULT hr;
    BOOL fShouldClose = FALSE;

    //Don't allow more than one close
    //This mainly fixes problem in stress where
    //we get posted more than one close message
    if (_fPreventClose)
    {
        fShouldClose = FALSE;
        TRC_ERR((TB,_T("More than one WM_CLOSE msg was received!!!")));
        return 0;
    }
    _fPreventClose = TRUE;

    if (InControlEventHandler())
    {
        //
        // Don't allow the close we are in a code path that fired
        // from the control. Without this, we sometimes see the client
        // receiving close notifications from tclient while a disconnected
        // dialog is up (i.e in an OnDicsconnected handler) - destroying
        // the control at this time causes bad things to happen during 
        // the return into the control (which has now been deleted).
        //
        TRC_ERR((TB,_T("OnClose called during a control event handler")));
        fShouldClose = FALSE;
        return 0;
    }

    if (_fInOnCloseHandler)
    {
        //
        // STRESS fix:
        // Don't allow nested Closes
        // can happen if the main window receives a WM_CLOSE
        // message while a dialog is up... Somehow the stress dll
        // sends us repeated WM_CLOSE
        // 
        //
        TRC_ERR((TB,_T("Nested OnClose detected, bailing out")));
        fShouldClose = FALSE;
        return 0;
    }
    _fInOnCloseHandler = TRUE;

    if (_pTsClient)
    {
        ControlCloseStatus ccs;
        hr = _pTsClient->RequestClose( &ccs );
        if(SUCCEEDED(hr))
        {
            if (controlCloseCanProceed == ccs)
            {
                //Immediate close
                fShouldClose = TRUE;
            }
            else if (controlCloseWaitForEvents == ccs)
            {
                // Wait for events from control
                // e.g ConfirmClose
                fShouldClose = FALSE;
                _fClosePending = TRUE;
            }
        }
    }
    else
    {
        //
        // Allow close to prevent hang if client load failed
        //
        TRC_ERR((TB,_T("No _pTsClient loaded, allow close anyway")));
        fShouldClose = TRUE;
    }

    if (fShouldClose)
    {
        //
        // Only save out MRU if last connection
        // was successful
        //
        if (GetConnectionSuccessFlag())
        {
            DCBOOL bRet = _pTscSet->SaveRegSettings();
            TRC_ASSERT(bRet, (TB, _T("SaveRegSettings\n")));
        }
        //Proceed with the close.
        return DefWindowProc( GetHwnd(), uMsg, wParam, lParam);
    }


    _fInOnCloseHandler = FALSE;

    DC_END_FN();
    return 0;
}

//
// This handles the tail end of the disconnection.
// it may be called back from the Disconnecting dialog box
//
// Params:
//  fExit - If true exit the app otherwise go back
//          to the connection UI
//
DCBOOL CContainerWnd::FinishDisconnect(BOOL fExit)
{
    DC_BEGIN_FN("FinishDisconnect");

    //
    // Hide the main window, do this twice because the first ShowWindow
    // may be ignored if the window is maximized
    //
    if (GetHwnd())
    {
        ShowWindow( GetHwnd(),SW_HIDE);
        ShowWindow( GetHwnd(),SW_HIDE);
    }

    //
    // Just exit if:
    // 1) we autoconnected
    // or
    // 2) A close is pending e.g we got disconnected
    //    because the user hit the close button
    // or
    // 3) The caller has determined that the client should exit
    //
    if (_pSh->GetAutoConnect() || _fClosePending || fExit)
    {
        PostMessage( GetHwnd(),WM_CLOSE, __LINE__, 0xBEEBBEEB);
    }
    else if (::IsWindow(_hwndMainDialog))
    {
        //
        // Bring up the connect dialog for
        // the next connections
        //
        ::ShowWindow( _hwndMainDialog, SW_SHOWNORMAL);
        SetForegroundWindow(_hwndMainDialog);

        //
        // Trigger an update
        //
        InvalidateRect(_hwndMainDialog, NULL, TRUE);
        UpdateWindow(_hwndMainDialog);

        SendMessage(_hwndMainDialog, WM_TSC_RETURNTOCONUI,
                    0L, 0L);
    }
    else
    {
        //If we get here it means we didn't autoconnect
        //i.e we started with the connect UI, but somehow the 
        //connect UI has now disappeared
        TRC_ABORT((TB,_T("Connect dialog is gone")));
    }

    DC_END_FN();
    return TRUE;
}

//
// Handle event from control requesting
// we go fullscreen
//
//
DCVOID CContainerWnd::OnEnterFullScreen()
{
    DCUINT32  style;
    LONG      wID;
    WINDOWPLACEMENT* pWindowPlacement = NULL;
    HRESULT   hr = E_FAIL;

    // multi-monitor support
    RECT screenRect;

    DC_BEGIN_FN("OnEnterFullScreen");

    //
    //Go full screen
    //

    EnterEventHandler();

    //Save setting for next connection
    _pTscSet->SetStartFullScreen(TRUE);

    if (_bContainerIsFullScreen)
    {
        //Nothing to do
        DC_QUIT;
    }
#ifndef OS_WINCE
    ::LockWindowUpdate(GetHwnd());
#endif
    _bContainerIsFullScreen = TRUE;

    #if !defined(OS_WINCE)
    if (_hSystemMenu)
    {
        //
        // We need to show the system menu so that the ts icon
        // appears in the taskbar. But we need MOVE to be disabled
        // when fullscreen
        //
        //EnableMenuItem(_hSystemMenu, SC_MOVE, MF_GRAYED);
    }
    #endif

#ifndef OS_WINCE
    pWindowPlacement = _pTscSet->GetWindowPlacement();
    TRC_ASSERT(pWindowPlacement, (TB, _T("pWindowPlacement is NULL\n")));

    //
    // Store the current window state (only if the client window is up)
    //
    if (pWindowPlacement && _fClientWindowIsUp)
    {
        GetWindowPlacement(GetHwnd(), pWindowPlacement);
    }
#endif

    //
    // Take away the title bar and borders
    //
    style = GetWindowLong( GetHwnd(),GWL_STYLE );

#if !defined(OS_WINCE) || defined(OS_WINCE_NONFULLSCREEN)
    style &= ~(WS_DLGFRAME |
               WS_THICKFRAME | WS_BORDER |
               WS_MAXIMIZEBOX);

#else // !defined(OS_WINCE) || defined(OS_WINCE_NONFULLSCREEN)
    style &= ~(WS_DLGFRAME | WS_SYSMENU | WS_BORDER);
#endif // !defined(OS_WINCE) || defined(OS_WINCE_NONFULLSCREEN)
    SetWindowLong( GetHwnd(),GWL_STYLE, style );

    //
    // Set the window ID (to remove the menu titles).
    //
    wID = SetWindowLong( GetHwnd(),GWL_ID, 0 );

    //
    // Note that two calls to SetWindowPos are required here in order to
    // adjust the position to allow for frame removal and also to correctly
    // set the Z-ordering.
    //

    // default screen size
    CSH::MonitorRectFromNearestRect(
        &pWindowPlacement->rcNormalPosition, &screenRect );
    
    //
    // Reposition and size the window with the frame changes, and place at
    // the top of the Z-order (by not setting SWP_NOOWNERZORDER or
    // SWP_NOZORDER and specifying HWND_TOP).
    //
    SetWindowPos( GetHwnd(),
                HWND_TOP,
                screenRect.left, screenRect.top,
                screenRect.right - screenRect.left,
                screenRect.bottom - screenRect.top,
                SWP_NOACTIVATE | SWP_FRAMECHANGED );

    //
    // Reposition the window again - otherwise the fullscreen window is
    // positioned as if it still had borders.
    //
    SetWindowPos( GetHwnd(),
                  NULL,
                  screenRect.left, screenRect.top,
                  0, 0,
                  SWP_NOZORDER | SWP_NOACTIVATE |
                  SWP_NOOWNERZORDER | SWP_NOSIZE );

#ifndef OS_WINCE
    ::LockWindowUpdate(NULL);
    //Notify the shell that we've gone fullscreen
    CUT::NotifyShellOfFullScreen( GetHwnd(),
                                  TRUE,
                                  &_pTaskBarList2,
                                  &_fQueriedForTaskBarList2 );
#endif //OS_WINCE
    
    DC_EXIT_POINT:

    LeaveEventHandler();

    DC_END_FN();
}

DCVOID CContainerWnd::OnLeaveFullScreen()
{
    DC_BEGIN_FN("OnLeaveFullScreen");

#ifndef OS_WINCE
    DCUINT32  style;
    RECT      rect;
    DCUINT    width;
    DCUINT    height;
    WINDOWPLACEMENT* pWindowPlacement = NULL;

    TRC_NRM((TB, _T("Entering Windowed Mode")));

    EnterEventHandler();

    //Save setting for next connection
    _pTscSet->SetStartFullScreen(FALSE);

    if (!_bContainerIsFullScreen)
    {
        //Nothing to do
        DC_QUIT;
    }
    ::LockWindowUpdate(GetHwnd());
    _bContainerIsFullScreen = FALSE;
    RecalcMaxWindowSize();

    //
    // Check that the saved window placement values aren't too big for the
    // client size we're using, and set the window placement accordingly.
    //
    pWindowPlacement = _pTscSet->GetWindowPlacement();
    TRC_ASSERT(pWindowPlacement, (TB, _T("pWindowPlacement is NULL\n")));
    if (!pWindowPlacement)
    {
        DC_QUIT;
    }

    width = pWindowPlacement->rcNormalPosition.right -
            pWindowPlacement->rcNormalPosition.left;
    height = pWindowPlacement->rcNormalPosition.bottom -
             pWindowPlacement->rcNormalPosition.top;
    if (width > _maxMainWindowSize.width)
    {
        pWindowPlacement->rcNormalPosition.right =
        pWindowPlacement->rcNormalPosition.left +
        _maxMainWindowSize.width;
    }
    if (height > _maxMainWindowSize.height)
    {
        pWindowPlacement->rcNormalPosition.bottom =
        pWindowPlacement->rcNormalPosition.top +
        _maxMainWindowSize.height;
    }

    if (!::SetWindowPlacement( GetHwnd(), pWindowPlacement))
    {
        TRC_ABORT((TB,_T("Failed to set window placement")));
    }

    //
    // In case the window is maximised make sure it knows what size to be
    //
    GetWindowRect( GetHwnd(),&rect);

    //
    // Reset the style
    //
    style = GetWindowLong( GetHwnd(),GWL_STYLE );

    style |= (WS_DLGFRAME |
              WS_THICKFRAME | WS_BORDER |
              WS_MAXIMIZEBOX);

    SetWindowLong( GetHwnd(),GWL_STYLE,
                   style );

    #if !defined(OS_WINCE)
    if (_hSystemMenu)
    {
        //
        // We need to show the system menu so that the ts icon
        // appears in the taskbar. But we need MOVE to be disabled
        // when fullscreen
        //
        //EnableMenuItem(_hSystemMenu, SC_MOVE, MF_ENABLED);
    }
    #endif


    //
    // Tell the window frame to recalculate its size.
    // Position below any topmost windows (but above any non-topmost
    // windows.
    //
    SetWindowPos( GetHwnd(),
                  HWND_NOTOPMOST,
                  0, 0,
                  rect.right - rect.left,
                  rect.bottom - rect.top,
                  SWP_NOMOVE | SWP_NOACTIVATE | SWP_FRAMECHANGED );

    //
    // If we are in res match mode
    // then after a leave full screen
    // restore the window so the next state
    // is 'maximize' i.e get back in fullscreen
    //
    if(IsRemoteResMatchMonitorSize())
    {
        ShowWindow( GetHwnd(), SW_SHOWNORMAL);
    }

    ::LockWindowUpdate(NULL);
    // Notify shell that we've left fullscreen
    //Notify the shell that we've gone fullscreen
    CUT::NotifyShellOfFullScreen( GetHwnd(),
                                  FALSE,
                                  &_pTaskBarList2,
                                  &_fQueriedForTaskBarList2 );

    DC_EXIT_POINT:
    LeaveEventHandler();
#else //OS_WINCE
    TRC_ABORT((TB,_T("clshell can't leave fullscreen in CE")));
#endif

    DC_END_FN();
    return;
}

//
// Notify the server a device change, either a new device comes online
// or an existing redirected device goes away
//
LRESULT CContainerWnd::OnDeviceChange(HWND hWnd,
                                      UINT uMsg,
                                      WPARAM wParam,
                                      LPARAM lParam)
{
    HRESULT hr;
    IMsRdpClientNonScriptable *pNonScriptable;
    UNREFERENCED_PARAMETER(hWnd);

    DC_BEGIN_FN("OnDeviceChange");

    if(_pTsClient)
    {
        hr = _pTsClient->QueryInterface(IID_IMsRdpClientNonScriptable,
                (PVOID *)&pNonScriptable);

        if (SUCCEEDED(hr)) {
            pNonScriptable->NotifyRedirectDeviceChange(wParam, lParam);
            pNonScriptable->Release();        
        }
    }
    else
    {
        TRC_NRM((TB,_T("Got OnDeviceChange but _pTsClient not available")));
    }
    
    DC_END_FN();
    return 0;
}


//
// Invoked to handle WM_HELP (i.e F1 key)
//
LRESULT CContainerWnd::OnHelp(HWND hWnd,
                              UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam)
{
    DC_BEGIN_FN("OnHelp");

    //
    // Don't pop help if we are connected
    // as the F1 should then go to the session. Otherwise
    // you get both local and remote help. Note the user can
    // still launch help while connected but they need to
    // select it from the system menu.
    //
    if (GetHwnd() && _pSh && !IsConnected())
    {
        _pSh->SH_DisplayClientHelp(
            GetHwnd(),
            HH_DISPLAY_TOPIC);
    }

    DC_END_FN();
    return 0L;
}

//
//  Forward the palette change to the control
//
LRESULT CContainerWnd::OnPaletteChange(UINT uMsg,
                                      WPARAM wParam,
                                      LPARAM lParam)
{
    DC_BEGIN_FN("OnPaletteChange");

    if (_pWndView) {
    
        HWND hwndCtl = _pWndView->GetHwnd();
        return SendMessage(hwndCtl, uMsg, wParam, lParam);                
    }
    
    DC_END_FN();
    return 0;
}

//
// Give focus back to the control
// when the system menu is dismissed
//
LRESULT CContainerWnd::OnExitMenuLoop(UINT uMsg,
                                      WPARAM wParam,
                                      LPARAM lParam)
{
    DC_BEGIN_FN("OnExitMenuLoop");

    //Give focus to the control when we get activated
    if (IsOkToToggleFocus())
    {
        TRC_NRM((TB,_T("Setting focus to control")));
        ::SetFocus(_pWndView->GetHwnd());
    }

    DC_END_FN();
    return 0;
}

LRESULT CContainerWnd::OnCaptureChanged(UINT uMsg,
                                        WPARAM wParam,
                                        LPARAM lParam)
{
    DC_BEGIN_FN("OnCaptureChanged");

    //
    // We don't always get WM_EXITSIZE move but we seem
    // to always get WM_CAPTURECHANGED so go on that
    //
    if (_fInSizeMove)
    {
        TRC_NRM((TB, _T("Capture Changed when in Size/Move")));
        _fInSizeMove = FALSE;

        if (IsOkToToggleFocus())
        {
            TRC_NRM((TB,_T("Setting focus to control")));
            ::SetFocus(_pWndView->GetHwnd());
        }
    }

    DC_END_FN();
    return 0;
}

LRESULT CContainerWnd::OnEnterSizeMove(UINT uMsg,
                                       WPARAM wParam,
                                       LPARAM lParam)
{
    DC_BEGIN_FN("OnEnterSizeMove");

    //
    // We're entering the modal size/move loop
    // need to give the focus back to the frame window
    // otherwise win9x will not move the window because
    // the IH is on another thread and the modal loop on 9x
    // will never see the arrow keystrokes
    //
    _fInSizeMove = TRUE;

    //
    // Note: Only do this toggle on 9x as that is
    // where it is needed. NT can handle the async modal
    // size/move loop and so there is no problem with ALT-SPACE.
    //
    // The reason for not doing this toggle on NT is that
    // it causes multiple a flurry of focus gain/loses
    // that rapidly hide/unhide the Cicero language bar.
    //
    if (IsOkToToggleFocus() && _fRunningOnWin9x)
    {
        TRC_NRM((TB,_T("Setting focus to frame")));
        ::SetFocus(GetHwnd());
    }

    DC_END_FN();
    return 0;
}

LRESULT CContainerWnd::OnExitSizeMove(UINT uMsg,
                                      WPARAM wParam,
                                      LPARAM lParam)
{
    DC_BEGIN_FN("OnExitSizeMove");

    _fInSizeMove = FALSE;

    //
    // Note: Only do this toggle on 9x as that is
    // where it is needed. NT can handle the async modal
    // size/move loop and so there is no problem with ALT-SPACE.
    //
    // The reason for not doing this toggle on NT is that
    // it causes multiple a flurry of focus gain/loses
    // that rapidly hide/unhide the Cicero language bar.
    //
    if (IsOkToToggleFocus() && _fRunningOnWin9x)
    {
        TRC_NRM((TB,_T("Setting focus to control")));
        ::SetFocus(_pWndView->GetHwnd());
    }

    DC_END_FN();
    return 0;
}

//
// Handle system color change notifications
//
LRESULT CContainerWnd::OnSysColorChange(UINT uMsg,
                                        WPARAM wParam,
                                        LPARAM lParam)
{
    DC_BEGIN_FN("OnSysColorChange");

    //
    // Foward the message to the ActiveX control
    //

    if (_pWndView && _pWndView->GetHwnd())
    {
        return SendMessage(_pWndView->GetHwnd(), uMsg, wParam, lParam);
    }

    DC_END_FN();
    return 0;
}


//
// Predicate that returns true if it's ok to toggle
// focus between the control and the frame
//
BOOL CContainerWnd::IsOkToToggleFocus()
{
    DC_BEGIN_FN("IsOkToToggleFocus");

    BOOL fDialogIsUp = ::IsWindow(_hwndMainDialog);
    if (_fClientWindowIsUp &&
        (!fDialogIsUp ||
        (fDialogIsUp && !::IsWindowVisible(_hwndMainDialog))))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }

    DC_END_FN();
}


//
// Notification from control that a fatal error has occurred
//
DCVOID  CContainerWnd::OnFatalError(LONG errorCode)
{
    DC_BEGIN_FN("OnFatalError");

    EnterEventHandler();

    DisplayFatalError(GetFatalString(errorCode), errorCode);

    LeaveEventHandler();

    DC_END_FN();
}

//
// Warning notifcation from control
// e.g if bitmap cache is corrutpted a warning is fired
// these are non-fatal errors
//
DCVOID  CContainerWnd::OnWarning(LONG warnCode)
{
    DC_BEGIN_FN("OnWarning");

    EnterEventHandler();

    TRC_ERR((TB, _T("WARNING recevived from core: %d"), warnCode));
    switch (warnCode)
    {
    case DC_WARN_BITMAPCACHE_CORRUPTED:
        {
            //
            // Display the bitmap cache warning dialog
            //
            CCacheWrnDlg bmpCacheWrn(GetHwnd(), _hInst);
            bmpCacheWrn.DoModal();
        }
        break;
    }

    LeaveEventHandler();

    DC_END_FN();
}

//Notification from the control
//of new width/height of the desktop
//this can change from the requested width/height in the event
//of a shadow operation
DCVOID  CContainerWnd::OnRemoteDesktopSizeNotify(long width, long height)
{
    DC_BEGIN_FN("OnRemoteDesktopSizeNotify");

    EnterEventHandler();

    TRC_NRM((TB, _T("OnRemoteDesktopSizeNotify: width %d. height %d"), width, height));

    SetCurrentDesktopWidth(width);
    SetCurrentDesktopHeight(height);
    RecalcMaxWindowSize();

    //
    //Trigger an update of the window size
    //in response to the shadow
    //but only do this if the client window is up otherwise the following
    //bug can happen:
    // -Launch connection
    // -As part of initial connection but before OnConnected is fired we
    //  get a RemoteDesktopSizeNotify. This causes us to update the
    //  windowplacement
    // -thrashing user selected options
    //
    if(_fClientWindowIsUp && !_bContainerIsFullScreen)
    {
        SetWindowPos( GetHwnd(),
                      NULL,
                      0, 0,
                      width,
                      height,
                      SWP_NOZORDER | SWP_NOMOVE |
                      SWP_NOACTIVATE | SWP_NOOWNERZORDER );
    }

    LeaveEventHandler();

    DC_END_FN();
}

//
// Calculate the current maximum tracking
// size limits for the window's client area given
// a current client area size (cliWidth, cliHeight).
//
// Returns the maxX, maxY values in *pMaxX, *pMaxY
//
// The max is not static because we have logic that
// expands the width/height if only one scroll bar
// is visible.
//
// This value is _not_ the same as the Maximized size
// of the window
//
void  CContainerWnd::CalcTrackingMaxWindowSize(UINT  /*in*/  cliWidth,
                                               UINT  /*in*/  cliHeight,
                                               UINT* /*out*/ pMaxWidth,
                                               UINT* /*out*/ pMaxHeight)
{
    BOOL fHScroll, fVScroll;
    DC_BEGIN_FN("CalcTrackingMaxWindowSize");

    //
    // Calculate the neccessity for the scrollbars
    //
    fHScroll = fVScroll = FALSE;
    if ( (cliWidth >= GetCurrentDesktopWidth()) &&
         (cliHeight >= GetCurrentDesktopHeight()) )
    {
        fHScroll = fVScroll = FALSE;
    }
    else if ( (cliWidth < GetCurrentDesktopWidth()) &&
              (cliHeight >=
               (GetCurrentDesktopHeight() + GetSystemMetrics(SM_CYHSCROLL))) )
    {
        fHScroll = TRUE;
    }
    else if ( (cliHeight < GetCurrentDesktopHeight()) &&
              (cliWidth >=
               (GetCurrentDesktopWidth() + GetSystemMetrics(SM_CXVSCROLL))) )
    {
        fVScroll = TRUE;
    }
    else
    {
        fHScroll = fVScroll = TRUE;
    }


    *pMaxWidth  = _maxMainWindowSize.width;
    *pMaxHeight = _maxMainWindowSize.height;

    if (fHScroll)
    {
        *pMaxHeight += GetSystemMetrics(SM_CYHSCROLL);
    }

    if (fVScroll)
    {
        *pMaxWidth += GetSystemMetrics(SM_CXVSCROLL);
    }

    TRC_NRM((TB,_T("Calculated max width/height - %d,%d"),
             *pMaxWidth, *pMaxHeight));
    DC_END_FN();
}



//
// Name:      GetFatalString
//                                                                          
// Purpose:   Return the specified error string
//                                                                          
// Returns:   Error string
//                                                                          
// Params:    IN      errorID  - error code
//                                                                          
//
LPTSTR CContainerWnd::GetFatalString(DCINT errorID)
{
    DC_BEGIN_FN("GetFatalString");
    DC_IGNORE_PARAMETER(errorID);

    //
    // Load the fatal error string from resources - this is more specific
    // for a debug build.
    //
    if (LoadString(_hInst,
#ifdef DC_DEBUG
                   UI_ERR_STRING_ID(errorID),
#else
                   UI_FATAL_ERROR_MESSAGE,
#endif
                   _errorString,
                   UI_ERR_MAX_STRLEN) == 0)
    {
        TRC_ABORT((TB, _T("Missing resource string (Fatal Error) %d"),
                   errorID));
        DC_TSTRCPY(_errorString, _T("Invalid resources"));
    }

    DC_END_FN();
    return(_errorString);
} // UI_GetFatalString


//
// Name:      UI_DisplayFatalError
//                                                                          
// Purpose:   Display a fatal error popup
//                                                                          
// Returns:   None
//                                                                          
// Params:    IN     errorString - error text
//                                                                          
//
VOID CContainerWnd::DisplayFatalError(PDCTCHAR errorString, DCINT error)
{
    DCINT   action;
    DCTCHAR titleString[UI_ERR_MAX_STRLEN];
    DCTCHAR fullTitleString[UI_ERR_MAX_STRLEN];

    DC_BEGIN_FN("UI_DisplayFatalError");

    //
    // Load the title string from resources.
    //
    if (LoadString(_hInst,
                   UI_FATAL_ERR_TITLE_ID,
                   titleString,
                   UI_ERR_MAX_STRLEN) == 0)
    {
        //
        // Continue to display the error anyway on retail build.
        //
        TRC_ABORT((TB, _T("Missing resource string (Fatal Error title)")));
        DC_TSTRCPY(titleString, _T("Fatal Error"));
    }

    DC_TSPRINTF(fullTitleString, titleString, error);

    action = MessageBox( GetHwnd(), errorString,
                         fullTitleString,
#ifdef DC_DEBUG
                         MB_ABORTRETRYIGNORE |
#else
                         MB_OK |
#endif
                         MB_ICONSTOP |
                         MB_APPLMODAL |
                         MB_SETFOREGROUND );

    TRC_NRM((TB, _T("Action %d selected"), action));
    switch (action)
    {
    case IDOK:
    case IDABORT:
        {
#ifdef OS_WIN32
            TerminateProcess(GetCurrentProcess(), 0);
#else //OS_WIN32
            exit(1);
#endif //OS_WIN32
        }
        break;

    case IDRETRY:
        {
            DebugBreak();
        }
        break;

    case IDIGNORE:
    default:
        {
            TRC_ALT((TB, _T("User chose to ignore fatal error!")));
        }
        break;
    }

    DC_END_FN();
    return;
} // UI_DisplayFatalError


//
// Called to flag entry into an event handler
// Does not need to use InterlockedIncrement
// only called on the STA thread.
//
LONG CContainerWnd::EnterEventHandler()
{
    return ++_cInEventHandlerCount;
}

//
// Called to flag leaving an event handler
// Does not need to use InterlockedIncrement
// only called on the STA thread.
//
LONG CContainerWnd::LeaveEventHandler()
{
    DC_BEGIN_FN("LeaveEventHandler");
    _cInEventHandlerCount--;
    TRC_ASSERT(_cInEventHandlerCount >= 0,
               (TB,_T("_cInEventHandlerCount went negative %d"),
                _cInEventHandlerCount));

    DC_END_FN();
    return _cInEventHandlerCount;
}

//
// Tests if we are in an event handler
//
BOOL CContainerWnd::InControlEventHandler()
{
    return _cInEventHandlerCount;
}

//
// Return TRUE if we're using the connection UI
// note that when autoconnecting to a connectoid, we
// don't use the UI
//
BOOL CContainerWnd::IsUsingDialogUI()
{
    return _hwndMainDialog ? TRUE : FALSE;
}

VOID CContainerWnd::OnRequestMinimize()
{
    HWND hwnd = GetHwnd();
    if(::IsWindow(hwnd))
    {
    #ifndef OS_WINCE
        //
        // Mimimize the window (don't just use CloseWindow() as
        // that doesn't pass the focus on to the next app
        //
        PostMessage( hwnd, WM_SYSCOMMAND, SC_MINIMIZE, 0L);
    #else
        ShowWindow(hwnd, SW_MINIMIZE);
    #endif
    }
}

//
// Event handler from control
// prompt user if they really want to close their session
//
//
HRESULT CContainerWnd::OnConfirmClose(BOOL* pfConfirmClose)
{
    EnterEventHandler();

    CShutdownDlg shutdownDlg(GetHwnd(), _hInst, _pSh);
    INT dlgRetVal = shutdownDlg.DoModal();

    //If the message is not handled then the default proc destroys the window
    if ( IDCANCEL == dlgRetVal )
    {
        *pfConfirmClose = FALSE; //reset this
        _fPreventClose = FALSE;
        _fClosePending = FALSE;
    }
    else
    {
        *pfConfirmClose = TRUE;

        //
        // Allow close to go thru
        // we will receive an OnDisconnected when it
        // has completed
        //
    }

    LeaveEventHandler();

    return S_OK;
}

//
// Check if the remote desktop size
// matches the current monitor's size
// return TRUE on match
//
//
BOOL CContainerWnd::IsRemoteResMatchMonitorSize()
{
    RECT rc;
    DC_BEGIN_FN("IsRemoteResMatchMonitorSize");
    CSH::MonitorRectFromHwnd(GetHwnd(),&rc);
    
    if( (rc.right - rc.left) == (LONG)GetCurrentDesktopWidth() &&
        (rc.bottom - rc.top) == (LONG)GetCurrentDesktopHeight() )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }

    DC_END_FN();
}

#ifndef OS_WINCE
BOOL CALLBACK GetDesktopRegionEnumProc (HMONITOR hMonitor, HDC hdcMonitor,
                                        RECT* prc, LPARAM lpUserData)

{
    MONITORINFO     monitorInfo;

    monitorInfo.cbSize = sizeof(monitorInfo);
    if (GetMonitorInfo(hMonitor, &monitorInfo) != 0)
    {
        HRGN    hRgnDesktop;
        CRGN    rgnMonitorWork(monitorInfo.rcWork);

        hRgnDesktop = *reinterpret_cast<CRGN*>(lpUserData);
        CombineRgn(hRgnDesktop, hRgnDesktop, rgnMonitorWork, RGN_OR);
    }
    return(TRUE);
}
#endif

#ifndef OS_WINCE
//
// This code shamelessley modified from shell code
// \shell\browseui\shbrows2.cpp
// 
//  from vtan: This function exists because user32 only determines
//  whether ANY part of the window is visible on the screen. It's possible to
//  place a window without an accessible title. Pretty useless when using the
//  mouse and forces the user to use the VERY un-intuitive alt-space.
//
void CContainerWnd::EnsureWindowIsCompletelyOnScreen(RECT *prc)
{
    HMONITOR        hMonitor;
    MONITORINFO     monitorInfo;

    DC_BEGIN_FN("EnsureWindowIsCompletelyOnScreen");

    // First find the monitor that the window resides on using GDI.

    hMonitor = MonitorFromRect(prc, MONITOR_DEFAULTTONEAREST);
    TRC_ASSERT(hMonitor, (TB,_T("hMonitor is null")));
    monitorInfo.cbSize = sizeof(monitorInfo);
    if (GetMonitorInfo(hMonitor, &monitorInfo) != 0)
    {
        LONG    lOffsetX, lOffsetY;
        RECT    *prcWorkArea, rcIntersect;
        CRGN    rgnDesktop, rgnIntersect, rgnWindow;

        // Because the WINDOWPLACEMENT rcNormalPosition field is in WORKAREA
        // co-ordinates this causes a displacement problem. If the taskbar is
        // at the left or top of the primary monitor the RECT passed even though
        // at (0, 0) may be at (100, 0) on the primary monitor in GDI co-ordinates
        // and GetMonitorInfo() will return a MONITORINFO in GDI co-ordinates.
        // The safest generic algorithm is to offset the WORKAREA RECT into GDI
        // co-ordinates and apply the algorithm in that system. Then offset the
        // WORKAREA RECT back into WORKAREA co-ordinates.

        prcWorkArea = &monitorInfo.rcWork;
        if (EqualRect(&monitorInfo.rcMonitor, &monitorInfo.rcWork) == 0)
        {

            // Taskbar is on this monitor - offset required.

            lOffsetX = prcWorkArea->left - monitorInfo.rcMonitor.left;
            lOffsetY = prcWorkArea->top - monitorInfo.rcMonitor.top;
        }
        else
        {

            // Taskbar is NOT on this monitor - no offset required.

            lOffsetX = lOffsetY = 0;
        }
        OffsetRect(prc, lOffsetX, lOffsetY);

        // WORKAREA RECT is in GDI co-ordinates. Apply the algorithm.

        // Check to see if this window already fits the current visible screen
        // area. This is a direct region comparison.

        // This enumeration may cause a performance problem. In the event that
        // a cheap and simple solution is required it would be best to do a
        // RECT intersection with the monitor and the window before resorting
        // to the more expensive region comparison. Get vtan if necessary.

        EnumDisplayMonitors(NULL, NULL, GetDesktopRegionEnumProc,
                            reinterpret_cast<LPARAM>(&rgnDesktop));
        rgnWindow.SetRegion(*prc);
        CombineRgn(rgnIntersect, rgnDesktop, rgnWindow, RGN_AND);
        if (EqualRgn(rgnIntersect, rgnWindow) == 0)
        {
            LONG    lDeltaX, lDeltaY;

            // Some part of the window is not within the visible desktop region
            // Move it until it all fits. Size it if it's too big.

            lDeltaX = lDeltaY = 0;
            if (prc->left < prcWorkArea->left)
                lDeltaX = prcWorkArea->left - prc->left;
            if (prc->top < prcWorkArea->top)
                lDeltaY = prcWorkArea->top - prc->top;
            if (prc->right > prcWorkArea->right)
                lDeltaX = prcWorkArea->right - prc->right;
            if (prc->bottom > prcWorkArea->bottom)
                lDeltaY = prcWorkArea->bottom - prc->bottom;
            OffsetRect(prc, lDeltaX, lDeltaY);
            IntersectRect(&rcIntersect, prc, prcWorkArea);
            CopyRect(prc, &rcIntersect);
        }

        // Put WORKAREA RECT back into WORKAREA co-ordinates.
        OffsetRect(prc, -lOffsetX, -lOffsetY);
    }
    DC_END_FN();
}
#endif

//
// Predicate returns TRUE if connected
//
BOOL CContainerWnd::IsConnected()
{
    BOOL fConnected = FALSE;
    HRESULT hr = E_FAIL;
    short  connectionState = 0;

    DC_BEGIN_FN("IsConnected");

    if (_pTsClient)
    {
        TRACE_HR(_pTsClient->get_Connected( & connectionState ));
        if(SUCCEEDED(hr))
        {
            fConnected = (connectionState != 0);
        }
    }

    DC_END_FN();
    return fConnected;
}

//
// Main window procedure for the top-level window
//
LRESULT CALLBACK CContainerWnd::WndProc(HWND hwnd,UINT uMsg,
                                        WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
        case WM_CREATE:
            return OnCreate( uMsg, wParam, lParam);
            break;
        case WM_DESTROY:
            return OnDestroy( hwnd, uMsg, wParam, lParam);
            break;
        case WM_SIZE:
            return OnSize( uMsg, wParam, lParam);
            break;
        case WM_MOVE:
            return OnMove( uMsg, wParam, lParam);
            break;
        case WM_COMMAND:
            return OnCommand( uMsg, wParam, lParam);
            break;
#ifndef OS_WINCE
        case WM_WINDOWPOSCHANGING:
            return OnWindowPosChanging(uMsg, wParam, lParam);
            break;
#endif
        case WM_CLOSE:
            return OnClose(uMsg, wParam, lParam);
            break;
        case WM_SETFOCUS:
            return OnSetFocus(uMsg, wParam, lParam);
            break;
        case WM_ACTIVATE:
            return OnActivate(uMsg, wParam, lParam);
            break;
        case WM_SYSCOMMAND:
            return OnSysCommand(uMsg, wParam, lParam);
            break;
#ifndef OS_WINCE
        case WM_INITMENU:
            return OnInitMenu(uMsg, wParam, lParam);
            break;
        case WM_GETMINMAXINFO:
            return OnGetMinMaxInfo(uMsg, wParam, lParam);
            break;
#endif
        case WM_NCDESTROY:
            return OnNCDestroy(hwnd, uMsg, wParam, lParam);
            break;
#ifndef OS_WINCE
        case WM_DEVICECHANGE:
            return OnDeviceChange(hwnd, uMsg, wParam, lParam);
            break;
#endif
        case WM_HELP:
            return OnHelp(hwnd, uMsg, wParam, lParam);
            break;
#ifdef OS_WINCE
        case WM_QUERYNEWPALETTE: //intentional fall through. OnPaletteChange only calls SendMessage
#endif
        case WM_PALETTECHANGED:
            return OnPaletteChange(uMsg, wParam, lParam);
            break;
        case WM_EXITMENULOOP:
            return OnExitMenuLoop(uMsg, wParam, lParam);
            break;
#ifndef OS_WINCE
        case WM_ENTERSIZEMOVE:
            return OnEnterSizeMove(uMsg, wParam, lParam);
            break;
        case WM_EXITSIZEMOVE:
            return OnExitSizeMove(uMsg, wParam, lParam);
            break;
#endif
        case WM_CAPTURECHANGED:
            return OnCaptureChanged(uMsg, wParam, lParam);
            break;

        case WM_SYSCOLORCHANGE:
            return OnSysColorChange(uMsg, wParam, lParam);
            break;

        default:
            return DefWindowProc (hwnd, uMsg, wParam, lParam);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\dlgbase.h ===
//
// dlgbase.h: base class for dialogs
//            (modal and modeless)
//
// Copyright (C) Microsoft Corporation 1999-2000
// (nadima)
//

#ifndef _dlgbase_h_
#define _dlgbase_h_

class CDlgBase
{
public:
    CDlgBase(HWND hwndOwner, HINSTANCE hInst, DCINT dlgResId);
    virtual ~CDlgBase();

    virtual INT_PTR CALLBACK DialogBoxProc (HWND hwndDlg, UINT uMsg,WPARAM wParam, LPARAM lParam);

    BOOL   GetPosition(int* pLeft, int* pTop);
    BOOL   SetPosition(int left, int top);
    void   SetStartupPosLeft(int left) {_startupLeft = left;}
    void   SetStartupPosTop(int top)   {_startupTop = top;}
    int    GetStartupPosLeft()         {return _startupLeft;}
    int    GetStartupPosTop()          {return _startupTop;}
    HWND   GetHwnd()                   {return _hwndDlg;}
    HWND   GetOwner()                  {return _hwndOwner;}

protected:
    //
    // Protected dialog utility functions
    //
    void SetDialogAppIcon(HWND hwndDlg);
    DCVOID DCINTERNAL EnableDlgItem(HWND    hwndDlg,
                                    DCUINT  dlgItemId,
                                    DCBOOL  enabled);
    VOID CenterWindow(HWND hwndCenterOn, INT xRatio=2, INT yRatio=2);

protected:
    void    RepositionControls(int moveDeltaX, int moveDeltaY, UINT* ctlIDs, int numID);
    void    EnableControls(UINT* ctlIDs, int numID, BOOL bEnable);
    DLGTEMPLATE* DoLockDlgRes(LPCTSTR lpszResName);

    HWND        _hwndDlg;
    HWND        _hwndOwner;
    HINSTANCE   _hInstance;
    DCINT       _dlgResId;

    //
    // Start position
    //
    int         _startupLeft;
    int         _startupTop;

    //
    // End positon on exit
    //
    int         _Left;
    int         _Top;
};


#endif //_dlgbase_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\contwnd.h ===
//
// contwnd.h: TS client Shell Container window
//            hosts TS ActiveX control
// Copyright Microsoft Corporation 1999-2000
//

#ifndef _CONTWND_H_
#define	_CONTWND_H_

#include "sh.h"
#include "evsink.h" //Event sink
#include "connectingdlg.h"
#include "auierr.h"
#include "axhostwnd.h"
#include "framewnd.h"

#include "shlobj.h"

#define MAIN_CLASS_NAME TEXT("TSSHELLWND")

typedef enum logonDlgState
{
    dlgUnexpanded       = 0,
    dlgTabGeneral       = 1,
    dlgTabLocalResources= 2
} LOGONDLGSTATE;
typedef struct tagLOGONDLGSTARTUPINFO
{
    LOGONDLGSTATE   state;
    int             xPos;
    int             yPos;
} LOGONDLGSTARTUPINFO, *PLOGONDLGSTARTUPINFO;

class CMainDlg;

class CRGN
{
    public:
    CRGN (void)                     {   mRgn = CreateRectRgn(0, 0, 0, 0);}
    CRGN (const RECT& rc)           {   mRgn = CreateRectRgnIndirect(&rc);}
    ~CRGN (void)                    {   DeleteObject(mRgn);}

    operator HRGN (void)    const   {   return(mRgn);}
    void    SetRegion (const RECT& rc) {
        SetRectRgn(mRgn, rc.left, rc.top, rc.right, rc.bottom);}
    private:
        HRGN    mRgn;
};

#define SET_CONTWND_STATE(x)                                        \
    TRC_NRM((TB,_T("Set contwnd state from %d to %d"), _state, x)); \
    _state = x;                                                     \


class CContainerWnd : public CTscFrameWnd
{
public:
    CContainerWnd();
    ~CContainerWnd();

    //
    // API Methods
    //

    DCBOOL  Init(HINSTANCE hInstance, CTscSettings* pTscSet, CSH* pSh);
    BOOL    StartConnection();
    DCBOOL  Disconnect();
    DCBOOL  FinishDisconnect(BOOL fExit = FALSE);

    //
    // Window proc
    //
    LRESULT CALLBACK WndProc(HWND hwnd,UINT uMsg,
                             WPARAM wParam, LPARAM lParam);

    //
    // Property accessers
    //
    DCVOID  SetConnectDialogHandle(HWND hwnd)
    {
        _hwndMainDialog = hwnd;
    }

    HWND    GetConnectDialogHandle()
    {
        return _hwndMainDialog;
    }
    DCVOID  SetStatusDialogHandle(HWND hwnd)
    {
        _hwndStatusDialog = hwnd;
    }
    BOOL    GetHaveConnected()  {return _fHaveConnected;}
    HWND    GetWndHandle()      {return _hWnd;}

    VOID    ResetConnectionSuccessFlag() {_fConnectionSuccess = FALSE;}
    VOID    SetConnectionSuccessFlag()   {_fConnectionSuccess = TRUE;}
    BOOL    GetConnectionSuccessFlag()   {return _fConnectionSuccess;}
    BOOL    IsConnected();

    //
    // Message handlers
    //

    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT OnDestroy(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT OnSize(UINT  uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT OnMove(UINT  uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT OnCommand(UINT  uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT OnSysCommand(UINT  uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT OnInitMenu(UINT  uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT OnWindowPosChanging(UINT  uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT OnSetFocus(UINT  uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT OnActivate(UINT  uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT OnClose(UINT  uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT OnGetMinMaxInfo(UINT  uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT OnNCDestroy(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT OnDeviceChange(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT OnHelp(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT OnPaletteChange(UINT  uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT OnExitMenuLoop(UINT  uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT OnCaptureChanged(UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT OnEnterSizeMove(UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT OnExitSizeMove(UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT OnSysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam);

    VOID ExitAndQuit();

    //
    // Event notification handlers (called by _eventSink)
    //
    LONG    EnterEventHandler();
    LONG    LeaveEventHandler();

    VOID  OnConnected();
    VOID  OnLoginComplete();
    VOID  OnDisconnected(DCUINT discReason);
    VOID  OnEnterFullScreen();
    VOID  OnLeaveFullScreen();
    VOID  OnFatalError(LONG errorCode);
    VOID  OnWarning(LONG WarnCode);
    VOID  OnRemoteDesktopSizeNotify(long width, long height);
    VOID  OnRequestMinimize();
    HRESULT OnConfirmClose(BOOL* pfConfirmClose);
    
    BOOL    _fPreventClose;
    BOOL    _fBeenThroughDestroy;
    BOOL    _fBeenThroughNCDestroy;
    DCINT   _PostedQuit;
private:

    HRESULT CreateTsControl();
    BOOL    SetupSystemMenu();
    void    SetMinMaxPlacement(WINDOWPLACEMENT& windowPlacement);
    void    RecalcMaxWindowSize(DCVOID);
    DCSIZE  GetMaximizedWindowSize(DCSIZE& maximizedSize);
    LPTSTR  GetFatalString(DCINT errorID);
    void    DisplayFatalError(PDCTCHAR errorString, DCINT error);
    BOOL    InControlEventHandler();
    BOOL    StartConnectDialog(BOOL fStartExpanded = FALSE,
                               INT  nStartTabIndex = 0);
    void    CalcTrackingMaxWindowSize(UINT cliWidth,
                                      UINT cliHeight,
                                      UINT* pMaxX,
                                      UINT* pMaxY);

    ULONG   GetCurrentDesktopWidth()        {return  _curDesktopWidth;}
    ULONG   GetCurrentDesktopHeight()       {return _curDesktopHeight;}
    void    SetCurrentDesktopWidth(LONG w)  {_curDesktopWidth = w;}
    void    SetCurrentDesktopHeight(LONG h) {_curDesktopHeight = h;}

    BOOL    IsUsingDialogUI();
    BOOL    IsRemoteResMatchMonitorSize();
#ifndef OS_WINCE
    void    EnsureWindowIsCompletelyOnScreen(RECT *prc);
#endif

    BOOL    IsOkToToggleFocus();

private:
    HMENU      _hSystemMenu;
    HMENU      _hHelpMenu;

// The activeX view window (child of the container)
#ifdef USE_ATL_CONTAINER
	CAxWindow* _pWndView;
#else
    CAxHostWnd* _pWndView;
#endif


    CSH*       _pSh;
    HINSTANCE  _hInst;
    DCBOOL            _bContainerIsFullScreen;
#ifdef DC_DEBUG
    HMENU     _hDebugMenu;
#endif

    // ActiveX control instance pointer
    IMsRdpClient*	_pTsClient;
    
    HWND       _hwndMainDialog;
    HWND       _hwndStatusDialog;

    DCSIZE     _maxMainWindowSize;

    //
    // Current desktop width and height
    // these can change in response to an
    // event from the control (e.g on shadow)
    //
    ULONG      _curDesktopWidth, _curDesktopHeight;

    //Active tab on the connect dialog
    //used to return to that tab when the dialog
    //is relaunched.
    DCBOOL               _fFirstTimeToLogonDlg;
    LOGONDLGSTARTUPINFO  _logonDlgStartupInfo;

    //
    // Flag signals that the login phase has completed for this
    // connection
    //
    DCBOOL               _fLoginComplete;
    DCTCHAR              _errorString[UI_ERR_MAX_STRLEN];

    //
    // Count of how many times we entered
    // an event handler.
    // This is used to protect entry into non-rentrant
    // code paths.
    //
    LONG                 _cInEventHandlerCount;
    BOOL                 _fInOnCloseHandler;

    CMainDlg*            _pMainDlg;
    CTscSettings*        _pTscSet;

    BOOL                 _fClientWindowIsUp;
    TCHAR                _szAppName[MAX_PATH];
    BOOL                 _fHaveConnected;
    TCHAR                _szPathToDefaultFile[MAX_PATH];
    INT                  _successConnectCount;
    BOOL                 _fConnectionSuccess;
    BOOL                 _fClosePending;

#ifndef OS_WINCE
    //Cached interface pointer to shell task bar
    ITaskbarList2*       _pTaskBarList2;
    //Flag indicaticating we already tried to get the TaskBarList2
    //so we shouldn't bother trying again
    BOOL                 _fQueriedForTaskBarList2;
#endif
    //
    // Are we in the modal size/move loop
    //
    BOOL                 _fInSizeMove;

    BOOL                 _fRunningOnWin9x;

    typedef enum 
    {
        stateNotInitialized     = 0x0,
        stateNotConnected       = 0x1,
        stateConnecting         = 0x2,
        stateConnected          = 0x3,
    } contWndState;

    contWndState         _state;
};

#endif //	_CONTWND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\discodlg.cpp ===
//
// discodlg.cpp: disconnected dialog
//
//

#include "stdafx.h"

#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "disconnecteddlg"
#include <atrcapi.h>

#include "discodlg.h"
#include "sh.h"

#include "contwnd.h"

//For error code decoding
#define DC_DEFINE_GLOBAL_ERROR_STRINGS 1
#include "tscerrs.h"

//
// Protocol errors
//
#include "rdperr.h"

CDisconnectedDlg::CDisconnectedDlg( HWND hwndOwner, HINSTANCE hInst,
                                    CContainerWnd* pContWnd) :
                                   _pContWnd(pContWnd),
                                   _hInstance(hInst),
                                   _hwndOwner(hwndOwner)
{
    DC_BEGIN_FN("CDisconnectedDlg");
    TRC_ASSERT(_pContWnd, (TB,_T("_pContWnd not set\n")));

    _disconnectReason = 0;
    _extendedDiscReason = exDiscReasonNoInfo;

    DC_END_FN();
}

CDisconnectedDlg::~CDisconnectedDlg()
{
}

#define MAX_DISCOMSG_LEN SH_DISCONNECT_RESOURCE_MAX_LENGTH*3

DCINT CDisconnectedDlg::DoModal()
{
    DCINT retVal = 0;

    LPTSTR   szOverallMsgString = NULL;
    INT_PTR  rc = FALSE;
    DCUINT   intRC;
    DC_BEGIN_FN("DoModal");

    szOverallMsgString = (LPTSTR) LocalAlloc(LPTR,
                          MAX_DISCOMSG_LEN*sizeof(TCHAR));
    if (!szOverallMsgString)
    {
        return -1;
    }

    if (MapErrorToString(_hInstance, _disconnectReason,
                        _extendedDiscReason,
                        szOverallMsgString,
                        MAX_DISCOMSG_LEN))
    {
        TCHAR szDialogCaption[64];
        intRC = LoadString(_hInstance,
                           UI_IDS_DISCONNECTED_CAPTION,
                           szDialogCaption,
                           SIZECHAR(szDialogCaption));
        if(0 == intRC)
        {
            TRC_SYSTEM_ERROR("LoadString");
            TRC_ERR((TB, _T("Failed to load string ID:%u"),
                     UI_IDS_DISCONNECTED_CAPTION));
            szDialogCaption[0] = 0;
        }


        MessageBox( _hwndOwner,
                    szOverallMsgString,
                    szDialogCaption,
#ifndef OS_WINCE
                    MB_OK | MB_HELP | MB_ICONSTOP);
#else
                    MB_OK | MB_ICONSTOP);
#endif

        // Do the cleanup.  This is hackerific but has to happen
        // from here because the disconnect dialog could be initiated
        // in the context of the main dialog via a PostMessage
        // see comment in contwnd.cpp

        TRC_ASSERT(_pContWnd, (TB,_T("_pContWnd not set\n")));
        if(_pContWnd)
        {
            _pContWnd->FinishDisconnect();
        }
    }
    

    DC_END_FN();
    
    if (szOverallMsgString)
    {
        LocalFree(szOverallMsgString);
    }
    return retVal;
}

//Returns error string for this message in szErrorMsg
//szErrorMsg must be large enough to hold error string
INT
CDisconnectedDlg::MapErrorToString(
    HINSTANCE hInstance,
    INT disconnectReason,
    ExtendedDisconnectReasonCode extendedDisconnectReason,
    LPTSTR szErrorMsg,
    INT    cchErrorMsgLen
    )
{
    UINT stringID = 0;
    UINT errorCode;
    int  rc;
    TCHAR szDisconnectedString[SH_DISCONNECT_RESOURCE_MAX_LENGTH];
    LPTSTR pszDebugErrorCodeText = _T("");

    DC_BEGIN_FN("MapErrorToString");

    TRC_NRM((TB, _T("Main disconnect reason code is:%u"),
             NL_GET_MAIN_REASON_CODE(disconnectReason)));
    TRC_ASSERT(szErrorMsg, (TB, _T("szErrorMsg is null")));

    //
    // If extended disconnect reason is set we may
    // just be able to figure out the error right away
    //
    if(extendedDisconnectReason != exDiscReasonNoInfo)
    {
        switch(extendedDisconnectReason)
        {
            case exDiscReasonAPIInitiatedDisconnect:
            {
                //An RPC call on the server initiated the disconnect
                //most likely is that it was an admin tool that kicked
                //off the disconnect
                stringID = UI_IDS_DISCONNECT_REMOTE_BY_SERVER_TOOL;
            }
            break;

            case exDiscReasonAPIInitiatedLogoff:
            {
                //An RPC call on the server initiated the disconnect
                //most likely is that it was an admin tool that kicked
                //off the disconnect
                stringID = UI_IDS_LOGOFF_REMOTE_BY_SERVER;
            }
            break;

            case exDiscReasonServerIdleTimeout:
            {
                // Idle timeout expired on server
                stringID = UI_IDS_DISCONNECT_IDLE_TIMEOUT;
            }
            break;
    
            case exDiscReasonServerLogonTimeout:
            {
                // Total logon timeout expired on server
                stringID = UI_IDS_DISCONNECT_LOGON_TIMEOUT;
            }
            break;

            case exDiscReasonReplacedByOtherConnection:
            {
                TRC_NRM((TB, _T("Disconnected by other connection")));
                stringID = UI_IDS_DISCONNECT_BYOTHERCONNECTION;
            }
            break;
    
            case exDiscReasonOutOfMemory:
            {
                // Server is out of memory
                stringID = UI_IDS_SERVER_OUT_OF_MEMORY;
            }
            break;

            case exDiscReasonServerDeniedConnection:
            {
                stringID = UI_IDS_SERVER_DENIED_CONNECTION;
            }
            break;

            case exDiscReasonServerDeniedConnectionFips:
            {
                stringID = UI_IDS_SERVER_DENIED_CONNECTION_FIPS;
            }
            break;

            case exDiscReasonLicenseInternal:
            {
                // Internal error in licensing protocol
                stringID = UI_IDS_LICENSE_INTERNAL;
            }
            break;

            case exDiscReasonLicenseNoLicenseServer:
            {
                // No license server available
                stringID = UI_IDS_LICENSE_NO_LICENSE_SERVER;
            }
            break;

            case exDiscReasonLicenseNoLicense:
            {
                // No license available for this client
                stringID = UI_IDS_LICENSE_NO_LICENSE;
            }
            break;

            case exDiscReasonLicenseErrClientMsg:
            {
                // Server got bad message from client
                stringID = UI_IDS_LICENSE_BAD_CLIENT_MSG;
            }
            break;

            case exDiscReasonLicenseHwidDoesntMatchLicense:
            {
                // HWID in license doesn't match the one sent
                stringID = UI_IDS_LICENSE_HWID_DOESNT_MATCH_LICENSE;
            }
            break;

            case exDiscReasonLicenseErrClientLicense:
            {
                // Server couldn't decode client license
                stringID = UI_IDS_LICENSE_BAD_CLIENT_LICENSE;
            }
            break;

            case exDiscReasonLicenseCantFinishProtocol:
            {
                // Server couldn't send final licensing packets
                stringID = UI_IDS_LICENSE_CANT_FINISH_PROTOCOL;
            }
            break;

            case exDiscReasonLicenseClientEndedProtocol:
            {
                // Client sent licensing error to server
                stringID = UI_IDS_LICENSE_CLIENT_ENDED_PROTOCOL;
            }
            break;

            case exDiscReasonLicenseErrClientEncryption:
            {
                // Server couldn't decrypt client message
                stringID = UI_IDS_LICENSE_BAD_CLIENT_ENCRYPTION;
            }
            break;

            case exDiscReasonLicenseCantUpgradeLicense:
            {
                // Client's license couldn't be upgraded
                stringID = UI_IDS_LICENSE_CANT_UPGRADE_LICENSE;
            }
            break;

            case exDiscReasonLicenseNoRemoteConnections:
            {
                // Server is in null mode - expired or not enough Per-CPU CALs
                stringID = UI_IDS_LICENSE_NO_REMOTE_CONNECTIONS;
            }
            break;

            default:
            {
                if(extendedDisconnectReason >= exDiscReasonProtocolRangeStart &&
                   extendedDisconnectReason <= exDiscReasonProtocolRangeEnd)
                {
                    //
                    // It's a protocol error detected (E.g rdpwd broke the link
                    // because it detected an error).
                    //
                    
                    //
                    // For most of these we just return status codes, more common
                    // ones get their own message
                    //
                    if (Log_RDP_ENC_DecryptFailed ==
                        (ULONG)(extendedDisconnectReason -
                                exDiscReasonProtocolRangeStart))
                    {
                        stringID = UI_IDS_SERVER_DECRYPTION_ERROR;

                    }
                    else
                    {
                        stringID = UI_IDS_PROTOCOL_ERROR_WITH_CODE;
                    }
                }
            }
            break;
        }
    }

    //
    // If we still haven't got the string to load then
    // crack the error code to figure out which stringID to load
    //
    if(0 == stringID)
    {
        switch (NL_GET_MAIN_REASON_CODE(disconnectReason))
        {
            case UI_DISCONNECT_ERROR:          // ??08
            {
                errorCode = NL_GET_ERR_CODE(disconnectReason);
    #ifdef DC_DEBUG
                //
                // Extra debugging info for this error
                //
                pszDebugErrorCodeText = (PDCTCHAR) uiUIErrorText[errorCode-1];
                TRC_ALT((TB, _T("UI error occurred - cause:%#x '%s'"),
                         errorCode,
                         pszDebugErrorCodeText));
    #endif /* DC_DEBUG */
    
                switch (errorCode)
                {
                    case UI_ERR_DISCONNECT_TIMEOUT:
                    {
                        TRC_NRM((TB, _T("Connection timed out")));
                        stringID = UI_IDS_CONNECTION_TIMEOUT;
                    }
                    break;
    
                    case UI_ERR_GHBNFAILED:
                    case UI_ERR_BADIPADDRESS:
                    case UI_ERR_DNSLOOKUPFAILED:
                    {
                        TRC_NRM((TB, _T("Bad IP address")));
                        stringID = UI_IDS_BAD_SERVER_NAME;
                    }
                    break;
    
                    case UI_ERR_ANSICONVERT:
                    {
                        TRC_NRM((TB, _T("An internal error has occurred.")));
                        stringID = UI_IDS_ILLEGAL_SERVER_NAME;
                    }
                    break;
    
                    case UI_ERR_NOTIMER:
                    {
                        /************************************************/
                        /* Failed to create a timer.                    */
                        /************************************************/
                        TRC_NRM((TB, _T("Failed to create a timer")));
                        stringID = UI_IDS_LOW_MEMORY;
                    }
                    break;
    
                    case UI_ERR_LOOPBACK_CONSOLE_CONNECT:
                    {
                        TRC_NRM((TB, _T("Console loopback connect!!!")));
                        stringID = UI_IDS_CANNOT_LOOPBACK_CONNECT;
                    }
                    break;
    
                    case UI_ERR_LICENSING_TIMEOUT:
                    {
                        TRC_NRM((TB, _T("Licensing timed out")));
                        stringID = UI_IDS_LICENSING_TIMEDOUT;
                    }
                    break;
    
                    case UI_ERR_LICENSING_NEGOTIATION_FAIL:
                    {
                        TRC_NRM((TB, _T("Licensing negotiation failed")));
                        stringID = UI_IDS_LICENSING_NEGOT_FAILED;
                    }
                    break;

                    case UI_ERR_DECOMPRESSION_FAILURE:
                    {
                        TRC_NRM((TB,_T("Client decompression failure")));
                        stringID = UI_IDS_CLIENT_DECOMPRESSION_FAILED;
                    }
                    break;

                    case UI_ERR_UNEXPECTED_DISCONNECT:
                    {
                        TRC_NRM((TB,_T("Received 'UnexpectedDisconnect' code")));
                        stringID = UI_IDS_INTERNAL_ERROR;
                    }
                    break;
                    
    
                    default:
                    {
                        TRC_ABORT((TB, _T("Unrecognized UI error %#x"),
                                        errorCode));
                        stringID = UI_IDS_INTERNAL_ERROR;
                    }
                    break;
                }
            }
            break;
    
            case NL_DISCONNECT_REMOTE_BY_SERVER:        // 0003
            {
                //The server has remotely disconnected us

                TRC_NRM((TB, _T("Remote disconnection by server")));
                //Unable to get more information
                stringID = UI_IDS_DISCONNECT_REMOTE_BY_SERVER;
            }
            break;
    
            case SL_DISCONNECT_ERROR:                   // ??06
            {
                errorCode = NL_GET_ERR_CODE(disconnectReason);
    #ifdef DC_DEBUG
                /********************************************************/
                /* Set up the error code text.                          */
                /********************************************************/
                pszDebugErrorCodeText = (PDCTCHAR) uiSLErrorText[errorCode-1];
                TRC_ALT((TB, _T("SL error occurred - cause:%#x '%s'"),
                         errorCode,
                         pszDebugErrorCodeText));
    #endif /* DC_DEBUG */
    
                /********************************************************/
                /* An SL error has occurred.  Work out what the actual  */
                /* code is.                                             */
                /********************************************************/
                switch (errorCode)
                {
                    /****************************************************/
                    /* The following codes all map onto an "out of      */
                    /* memory" string.                                  */
                    /****************************************************/
                    case SL_ERR_NOMEMFORSENDUD:         // 0106
                    case SL_ERR_NOMEMFORRECVUD:         // 0206
                    case SL_ERR_NOMEMFORSECPACKET:      // 0306
                    {
                        TRC_NRM((TB, _T("Out of memory")));
                        stringID = UI_IDS_LOW_MEMORY;
                    }
                    break;
    
                    /****************************************************/
                    /* The following codes all map onto a "security     */
                    /* error" string.                                   */
                    /****************************************************/
                    case SL_ERR_NOSECURITYUSERDATA:     // 0406
                    case SL_ERR_INVALIDENCMETHOD:       // 0506
                    case SL_ERR_INVALIDSRVRAND:         // 0606
                    case SL_ERR_INVALIDSRVCERT:         // 0706
                    case SL_ERR_GENSRVRANDFAILED:       // 0806
                    case SL_ERR_MKSESSKEYFAILED:        // 0906
                    case SL_ERR_ENCCLNTRANDFAILED:      // 0A06 
                    {
                        TRC_NRM((TB, _T("Security error")));
                        stringID = UI_IDS_SECURITY_ERROR;
                    }
                    break;
    
                    case SL_ERR_ENCRYPTFAILED:          // 0B06
                    case SL_ERR_DECRYPTFAILED:          // 0C06
                    {
                        TRC_NRM((TB, _T("Encryption error")));
                        stringID = UI_IDS_ENCRYPTION_ERROR;
                    }
                    break;

                    case SL_ERR_INVALIDPACKETFORMAT:    // 0D06
                    {
                        TRC_NRM((TB, _T("Invalid packet format")));
                        stringID = UI_IDS_PROTOCOL_ERROR;
                    }
                    break;

                    case SL_ERR_INITFIPSFAILED:
                    {
                        TRC_NRM((TB, _T("Init FIPS encryption failed")));
                        stringID = UI_IDS_FIPS_ERROR;
                    }
                    break;

                    default:
                    {
                        /************************************************/
                        /* Whoops - shouldn't get here.  We should be   */
                        /* capable of correctly decoding every error    */
                        /* value.                                       */
                        /************************************************/
                        TRC_ABORT((TB, _T("Unrecognized SL error code:%#x"),
                                   disconnectReason));
                        stringID = UI_IDS_INTERNAL_ERROR;
                    }
                    break;
                }
            }
            break;
    
            case NL_DISCONNECT_ERROR:                   // ??04
            {
    #ifdef DC_DEBUG
                DCUINT lowByte;
                DCUINT highByte;
    #endif /* DC_DEBUG */
    
                errorCode = NL_GET_ERR_CODE(disconnectReason);
    #ifdef DC_DEBUG
                /********************************************************/
                /* Set up the error code text.                          */
                /********************************************************/
                highByte = errorCode >> 4;
                lowByte  = (errorCode & 0xF) - 1;
                pszDebugErrorCodeText =
                              (PDCTCHAR) uiNLErrorText[highByte][lowByte];
                TRC_ALT((TB, _T("NL error occurred - cause:%u '%s'"),
                         errorCode,
                         pszDebugErrorCodeText));
    #endif /* DC_DEBUG */
    
                /********************************************************/
                /* An NL error has occurred.  Work out what the actual  */
                /* code is.                                             */
                /********************************************************/
                switch (NL_GET_ERR_CODE(disconnectReason))
                {
                    /****************************************************/
                    /* The following codes all map onto a "bad IP       */
                    /* address" string.                                 */
                    /****************************************************/
                    case NL_ERR_TDDNSLOOKUPFAILED:      // 0104
                    case NL_ERR_TDGHBNFAILED:           // 0604
                    case NL_ERR_TDBADIPADDRESS:         // 0804
                    {
                        TRC_NRM((TB, _T("Bad IP address")));
                        stringID = UI_IDS_BAD_SERVER_NAME;
                    }
                    break;
    
                    /****************************************************/
                    /* The following code maps onto a "connect failed"  */
                    /* string.                                          */
                    /****************************************************/
                    case NL_ERR_TDSKTCONNECTFAILED:     // 0204
                    case NL_ERR_TDTIMEOUT:              // 0704
                    case NL_ERR_NCATTACHUSERFAILED:     // 3604
                    case NL_ERR_NCCHANNELJOINFAILED:    // 3704
                    {
                        TRC_NRM((TB, _T("Failed to establish a connection")));
                        stringID = UI_IDS_NOT_RESPONDING;
                    }
                    break;
    
                    case NL_ERR_MCSNOUSERIDINAUC:       // 2704
                    case NL_ERR_MCSNOCHANNELIDINCJC:    // 2804
                    case NL_ERR_NCBADMCSRESULT:         // 3104
                    case NL_ERR_NCNOUSERDATA:           // 3304
                    case NL_ERR_NCINVALIDH221KEY:       // 3404
                    case NL_ERR_NCNONETDATA:            // 3504
                    case NL_ERR_NCJOINBADCHANNEL:       // 3804
                    case NL_ERR_NCNOCOREDATA:           // 3904
                    {
                        TRC_NRM((TB, _T("Protocol Error")));
                        stringID = UI_IDS_CONNECT_FAILED_PROTOCOL;
                    }
                    break;
    
                    /****************************************************/
                    /* The following codes all map onto a "network      */
                    /* error has occurred" string.                      */
                    /****************************************************/
                    case NL_ERR_TDONCALLTOSEND:         // 0304
                    case NL_ERR_TDONCALLTORECV:         // 0404
                    {
                        TRC_NRM((TB, _T("A network error has occurred")));
                        stringID = UI_IDS_NETWORK_ERROR;
                    }
                    break;
    
                    case NL_ERR_XTBADTPKTVERSION:       // 1104
                    case NL_ERR_XTBADHEADER:            // 1204
                    case NL_ERR_XTUNEXPECTEDDATA:       // 1304
                    case NL_ERR_MCSUNEXPECTEDPDU:       // 2104
                    case NL_ERR_MCSNOTCRPDU:            // 2204
                    case NL_ERR_MCSBADCRLENGTH:         // 2304
                    case NL_ERR_MCSBADCRFIELDS:         // 2404
                    case NL_ERR_MCSINVALIDPACKETFORMAT: // 2904
                    {
                        TRC_NRM((TB, _T("A protocol error has occurred")));
                        stringID = UI_IDS_CLIENTSIDE_PROTOCOL_ERROR;
                    }
                    break;
    
                    /****************************************************/
                    /* This code relates to an incompatible server      */
                    /* version.                                         */
                    /****************************************************/
                    case NL_ERR_MCSBADMCSREASON:        // 2604
                    case NL_ERR_NCVERSIONMISMATCH:      // 3A04
                    {
                        TRC_NRM((TB, _T("Client/Server version mismatch")));
                        stringID = UI_IDS_VERSION_MISMATCH;
                    }
                    break;
    
                    /****************************************************/
                    /* The following codes map onto an "illegal server  */
                    /* name" string.                                    */
                    /****************************************************/
                    case NL_ERR_TDANSICONVERT:          // 0A04
                    {
                        TRC_NRM((TB, _T("Couldn't convert name to ANSI")));
                        stringID = UI_IDS_ILLEGAL_SERVER_NAME;
                    }
                    break;
    
                    case NL_ERR_TDFDCLOSE:              // 0904
                    {
                        TRC_NRM((TB, _T("Socket closed")));
                        stringID = UI_IDS_CONNECTION_BROKEN;
                    }
                    break;
    
                    default:
                    {
                        /************************************************/
                        /* Woops - shouldn't get here.  We should be    */
                        /* capable of correctly decoding every error    */
                        /* value.                                       */
                        /************************************************/
                        TRC_ABORT((TB, _T("Unrecognized NL error code:%#x"),
                                   disconnectReason));
                        stringID = UI_IDS_INTERNAL_ERROR;
                    }
                    break;
                }
    
            }
            break;
    
            default:
            {
                /********************************************************/
                /* Woops - shouldn't get here.  We should be capable    */
                /* of correctly decoding every disconnection reason     */
                /* code.                                                */
                /********************************************************/
                TRC_ABORT((TB, _T("Unexpected disconnect ID:%#x"),
                           disconnectReason));
                stringID = UI_IDS_INTERNAL_ERROR;
            }
            break;
        }
    }


    //
    // First of all get the textual version of the string - we have
    // just worked out which string we need to load.
    //
    rc = LoadString(hInstance,
                    stringID,
                    szDisconnectedString,
                    SIZECHAR(szDisconnectedString));
    if (0 == rc)
    {
         //Oops!  Some problem with the resources.
         TRC_SYSTEM_ERROR("LoadString");
         TRC_ERR((TB, _T("Failed to load string ID:%u"), stringID));
         return FALSE;
    }
    

    if(UI_IDS_PROTOCOL_ERROR_WITH_CODE == stringID)
    {
        //
        // Need to add the specific protocol error
        // code to the string
        //
        DC_TSPRINTF(szErrorMsg, szDisconnectedString,
                    extendedDisconnectReason);
    }
    else if (UI_IDS_CLIENTSIDE_PROTOCOL_ERROR == stringID)
    {
        //
        // Client side protocol error, add the appropriate
        // code to the string
        //
        DC_TSPRINTF(szErrorMsg, szDisconnectedString,
                    disconnectReason);
    }
	else
    {
        //
        // Static error string (doesn't need codes appended)
        //
        _tcscpy(szErrorMsg, szDisconnectedString);
    }


    #ifdef DC_DEBUG
    
    //
    // In Check builds display the disconnect
    // codes as well as the debug disconnect reason string
    //

    TCHAR szDebugDisconnectInfo[128];

    // Add the numerical reason code.

    _stprintf(szDebugDisconnectInfo,
          _T("DEBUG ONLY: Disconnect code: 0x%x - ") \
          _T("Extended Disconnect code: 0x%x\n"),
          disconnectReason,
          extendedDisconnectReason);

    //
    // Add the error code text to the end of the string.
    //
    _tcscat(szErrorMsg, _T("\n\n"));
    _tcscat(szErrorMsg, szDebugDisconnectInfo);
    if (pszDebugErrorCodeText)
    {
        _tcscat(szErrorMsg, pszDebugErrorCodeText);
    }
    #endif

    DC_END_FN();
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\dlgbase.cpp ===
//
// dlgbase.cpp: base class for dialogs
//

#include "stdafx.h"
#include "dlgbase.h"
#include "resource.h"
#include "wuiids.h"

#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "dlgbase"
#include <atrcapi.h>


CDlgBase::CDlgBase(HWND hwndOwner, HINSTANCE hInst, DCINT dlgResId) :
                         _hwndOwner(hwndOwner), _hInstance(hInst), _dlgResId(dlgResId)
{
    _hwndDlg = NULL;
    _startupLeft = _startupTop = 0;
}

CDlgBase::~CDlgBase()
{
}

/****************************************************************************/
/* Name:      DialogBoxProc                                                 */
/*                                                                          */
/* Purpose:   Provides message handling for basic operation                 */
/*                                                                          */
/* Returns:   TRUE - if message dealt with                                  */
/*            FALSE otherwise                                               */
/*                                                                          */
/* Params:    See windows documentation                                     */
/*                                                                          */
/****************************************************************************/
INT_PTR CALLBACK CDlgBase::DialogBoxProc(HWND hwndDlg,
                                         UINT uMsg,
                                         WPARAM wParam,
                                         LPARAM lParam)
{
    INT_PTR rc = FALSE;

    DC_BEGIN_FN("DialogBoxProc");

    DC_IGNORE_PARAMETER(lParam);

    /************************************************************************/
    /* Handle dialog messages                                               */
    /************************************************************************/
    switch(uMsg)
    {
        case WM_INITDIALOG:
        {
            SetDialogAppIcon(hwndDlg);
            rc = TRUE;
        }
        break;

        case WM_COMMAND:
        {
            switch(DC_GET_WM_COMMAND_ID(wParam))
            {
                case IDCANCEL:
                {
                    /********************************************************/
                    /* Closes the dialog                                    */
                    /********************************************************/
                    TRC_NRM((TB, _T("Close dialog")));

                    if(hwndDlg)
                    {
                        EndDialog(hwndDlg, IDCANCEL);
                    }

                    rc = TRUE;
                }
                break;

                default:
                {
                    /********************************************************/
                    /* Do Nothing                                           */
                    /********************************************************/
                }
                break;
            }
        }
        break;

        case WM_CLOSE:
        {
            /****************************************************************/
            /* Closes the dialog                                            */
            /****************************************************************/
            TRC_NRM((TB, _T("Close dialog")));
            if(IsWindow(hwndDlg))
            {
                EndDialog(hwndDlg, IDCANCEL);
            }
            rc = 0;
        }
        break;

        default:
        {
            /****************************************************************/
            /* Do Nothing                                                   */
            /****************************************************************/
        }
        break;
    }

    DC_END_FN();

    return(rc);

} /* DialogBoxProc */


/****************************************************************************/
/* Name:      SetDialogAppIcon                                              */
/*                                                                          */
/* Purpose:   Sets the icon for the dialog to the application icon          */
/*                                                                          */
/* Returns:   Yes, it does                                                  */
/*                                                                          */
/* Params:    IN   HWND   the dialog for which we want to set the icon      */
/*                                                                          */
/*                                                                          */
/****************************************************************************/
void CDlgBase::SetDialogAppIcon(HWND hwndDlg)
{
#ifdef OS_WINCE
    DC_IGNORE_PARAMETER(hwndDlg);
#else // !OS_WINCE
    HICON hIcon = NULL;

    hIcon = LoadIcon(_hInstance, MAKEINTRESOURCE(UI_IDI_ICON));
    if(hIcon)
    {
#ifdef OS_WIN32
        SendMessage(hwndDlg, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
#else //OS_WIN32
        SetClassWord(hwndDlg, GCW_HICON, (WORD)hIcon);
#endif //OS_WIN32
    }
#endif // OS_WINCE
} /* UISetDialogAppIcon */


/****************************************************************************/
/* Name:      EnableDlgItem                                                 */
/*                                                                          */
/* Purpose:   Enables or disables a specified dialog control                */
/*                                                                          */
/* Returns:   Nothing.                                                      */
/*                                                                          */
/* Params:    hwndDlg   - dialog window handle                              */
/*            dlgItemId - dialog control id                                 */
/*            enabled   - TRUE enables the control, FALSE disables it       */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL CDlgBase::EnableDlgItem( HWND    hwndDlg,
                                   DCUINT  dlgItemId,
                                   DCBOOL  enabled )
{
    HWND  hwndDlgItem = NULL;

    DC_BEGIN_FN("EnableDlgItem");

    if(hwndDlg)
    {
        hwndDlgItem = GetDlgItem(hwndDlg, dlgItemId);
    }

    if(hwndDlgItem)
    {
        EnableWindow(hwndDlgItem, enabled);
    }

    DC_END_FN();
    return;
}

/****************************************************************************/
/* Name:      CenterWindowOnParent                                          */
/*                                                                          */
/* Purpose:   Center a window inside another                                */
/*                                                                          */
/* Returns:   None                                                          */
/*                                                                          */
/* Params:    HWND hwndCenterOn (window to center on)                       */
/*            xRatio - horizontal centering factor e.g 2 for (1/2)          */
/*            yRatio - vertical   centering factor e.g 3 for (1/3)
/*                                                                          */
/*                                                                          */
/****************************************************************************/
VOID CDlgBase::CenterWindow(HWND hwndCenterOn,
                              INT xRatio,
                              INT yRatio)
{
    RECT  childRect;
    RECT  parentRect;
    DCINT xPos;
    DCINT yPos;

    LONG  desktopX = GetSystemMetrics(SM_CXSCREEN);
    LONG  desktopY = GetSystemMetrics(SM_CYSCREEN);

    BOOL center = TRUE;

    DC_BEGIN_FN("CenterWindowOnParent");

    TRC_ASSERT(_hwndDlg, (TB, _T("_hwndDlg is NULL...was it set in WM_INITDIALOG?\n")));
    if (!_hwndDlg)
    {
        TRC_ALT((TB, _T("Window doesn't exist")));
        DC_QUIT;
    }
    if (!xRatio)
    {
        xRatio = 2;
    }
    if (!yRatio)
    {
        yRatio = 2;
    }

#ifndef OS_WINCE

    if(!hwndCenterOn)
    {
        hwndCenterOn = GetDesktopWindow();
    }

    GetWindowRect(hwndCenterOn, &parentRect);

#else /*OS_WINCE*/

    if(!hwndCenterOn)
    {
        //
        // WinCE doesn't have GetDesktopWindow()
        //
#if 0
        if (g_CEConfig != CE_CONFIG_WBT)
        {
            SystemParametersInfo(SPI_GETWORKAREA, 0, (PVOID)&parentRect, 0);
        }
        else
#endif
        {
            parentRect.left   = 0;
            parentRect.top    = 0;
            parentRect.right  = desktopX;
            parentRect.bottom = desktopY;
        }
    }
    else
    {
        GetWindowRect(hwndCenterOn, &parentRect);
    }

#endif/*OS_WINCE*/

    GetWindowRect(_hwndDlg, &childRect);

    /************************************************************************/
    /* Calculate the top left - centered in the parent window.              */
    /************************************************************************/
    xPos = ( (parentRect.right + parentRect.left) -
             (childRect.right - childRect.left)) / xRatio;
    yPos = ( (parentRect.bottom + parentRect.top) -
             (childRect.bottom - childRect.top)) / yRatio;

    /************************************************************************/
    /* Constrain to the desktop                                             */
    /************************************************************************/
    if (xPos < 0)
    {
        xPos = 0;
    }
    else if (xPos > (desktopX - (childRect.right - childRect.left)))
    {
        xPos = desktopX - (childRect.right - childRect.left);
    }
    if (yPos < 0)
    {
        yPos = 0;
    }
    else if (yPos > (desktopY - (childRect.bottom - childRect.top)))
    {
        yPos = desktopY - (childRect.bottom - childRect.top);
    }

    TRC_DBG((TB, _T("Set dialog position to %u %u"), xPos, yPos));
    SetWindowPos(_hwndDlg,
                 NULL,
                 xPos, yPos,
                 0, 0,
                 SWP_NOSIZE | SWP_NOACTIVATE);

DC_EXIT_POINT:
    DC_END_FN();

    return;

} /* CenterWindowOnParent */

#ifndef OS_WINCE
//
// Retreive current dialog position
//
BOOL CDlgBase::GetPosition(int* pLeft, int* pTop)
{
    if(!pLeft || !pTop)
    {
        return FALSE;
    }

    if(!_hwndDlg)
    {
        return FALSE;
    }

    WINDOWPLACEMENT wndPlc;
    wndPlc.length = sizeof(WINDOWPLACEMENT);
    if(GetWindowPlacement(_hwndDlg, &wndPlc))
    {
        *pLeft = wndPlc.rcNormalPosition.left;
        *pTop  = wndPlc.rcNormalPosition.top;
        return TRUE;
    }
    return FALSE;
}
#endif

BOOL CDlgBase::SetPosition(int left, int top)
{
    if(!_hwndDlg)
    {
        return FALSE;
    }
    if(!::SetWindowPos(_hwndDlg,
                       NULL,
                       left,
                       top,
                       0,
                       0,
                       SWP_NOZORDER | SWP_NOSIZE))
    {
        return FALSE;
    }
    return TRUE;
}

//
// Move the dialog controls
//
void CDlgBase::RepositionControls(int moveDeltaX, int moveDeltaY, UINT* ctlIDs, int numID)
{
    if(_hwndDlg)
    {
        for(int i=0; i< numID; i++)
        {
            HWND hwndCtrl = GetDlgItem(_hwndDlg, ctlIDs[i]);
            if( hwndCtrl)
            {
                RECT rc;
                GetWindowRect( hwndCtrl, &rc);
                MapWindowPoints( NULL, _hwndDlg, (LPPOINT)&rc, 2);
                OffsetRect( &rc, moveDeltaX, moveDeltaY);
                SetWindowPos( hwndCtrl, NULL, rc.left, rc.top, 0, 0, 
                              SWP_NOZORDER | SWP_NOSIZE);
            }
        }
    }
}

//
// Shows+enable or Hide+disable controls
//
void CDlgBase::EnableControls(UINT* ctlIDs, int numID, BOOL bEnable)
{
    if(_hwndDlg)
    {
        for(int i=0; i< numID; i++)
        {
            HWND hwndCtrl = GetDlgItem(_hwndDlg, ctlIDs[i]);
            if( hwndCtrl)
            {
                EnableWindow( hwndCtrl, bEnable);
                ShowWindow(hwndCtrl, bEnable ? SW_SHOW : SW_HIDE);
            }
        }
    }
}

//
// DoLockDlgRes - loads and locks a dialog template
// returns address of locked resource
// lpszResName - name of resource
//
DLGTEMPLATE* CDlgBase::DoLockDlgRes(LPCTSTR lpszResName)
{
#ifdef OS_WINCE
	HRSRC hrsrc = FindResource(GetModuleHandle(NULL), lpszResName, RT_DIALOG);
#else
    HRSRC hrsrc = FindResource(NULL, lpszResName, RT_DIALOG);
#endif

    if(!hrsrc)
    {
        return NULL;
    }
    HGLOBAL hglb = LoadResource( _hInstance, hrsrc);
    return (DLGTEMPLATE*) LockResource(hglb);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\evsink.cpp ===
//
// evsink.cpp: event sink class
//

#include "stdafx.h"

#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "evsink"
#include <atrcapi.h>

#include "evsink.h"
#include "contwnd.h"

CEventSink::CEventSink(CContainerWnd* pContainerWnd) :
            _pContainerWnd(pContainerWnd)
{
    _cRef = 0;
}

CEventSink::~CEventSink()
{
}

STDMETHODIMP CEventSink::QueryInterface( REFIID riid, void ** ppv )
{
    DC_BEGIN_FN("QueryInterface");
    TRC_ASSERT(ppv,(TB,_T("ppv is null")));

    *ppv = NULL;

    if (IID_IUnknown == riid || IID_IDispatch == riid || DIID_IMsTscAxEvents == riid)
        *ppv = this;

    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    DC_END_FN();
    return ResultFromScode(E_NOINTERFACE); 
}


STDMETHODIMP_(ULONG) CEventSink::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}


STDMETHODIMP_(ULONG) CEventSink::Release(void)
{
    if (0L != InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0L;
}

STDMETHODIMP CEventSink::GetTypeInfoCount(UINT *pctInfo)
{
    *pctInfo = 0;
    return NOERROR;
}

STDMETHODIMP CEventSink::GetTypeInfo(UINT itInfo, LCID lcid, ITypeInfo **ppTypeInfo)
{
    DC_BEGIN_FN("GetTypeInfo");

    TRC_ABORT((TB,_T("GetTypeInfo should not get called")));
    *ppTypeInfo = NULL;
    DC_END_FN();
    return E_NOTIMPL;
}

STDMETHODIMP CEventSink::GetIDsOfNames(REFIID riid, OLECHAR **rgwzNames,
                                       UINT cNames, LCID lcid, DISPID *rgDispID)
{
    DC_BEGIN_FN("GetIDsOfNames");
    TRC_ABORT((TB,_T("GetIDsOfNames should not get called")));
    DC_END_FN();
    return E_NOTIMPL;
}

STDMETHODIMP CEventSink::Invoke(DISPID dispidMember, REFIID riid,
                                LCID lcid, WORD /*wFlags*/,
                                DISPPARAMS* pdispparams, VARIANT* pvarResult,
                                EXCEPINFO* /*pexcepinfo*/, UINT* /*puArgErr*/)
{
    HRESULT hr = E_NOTIMPL;
    switch (dispidMember)
    {
    case DISPID_CONNECTED:
        hr = OnConnected();
        break;
    case DISPID_DISCONNECTED:
        hr = OnDisconnected(pdispparams->rgvarg->lVal);
        break;
    case DISPID_LOGINCOMPLETE:
        hr = OnLoginComplete();
        break;
    case DISPID_REQUESTGOFULLSCREEN:
        hr = OnRequestEnterFullScreen();
        break;
    case DISPID_REQUESTLEAVEFULLSCREEN:
        hr = OnRequestLeaveFullScreen();
        break;
    case DISPID_FATALERROR:
        hr = OnFatalError(pdispparams->rgvarg->lVal);
        break;
    case DISPID_WARNING:
        hr = OnWarning(pdispparams->rgvarg->lVal);
        break;
    case DISPID_REMOTEDESKTOPSIZECHANGE:
        hr = OnRemoteDesktopSizeChange(pdispparams->rgvarg[1].lVal,
                                       pdispparams->rgvarg[0].lVal);
        break;
    case DISPID_REQUESTCONTAINERMINIMIZE:
        hr = OnRequestContainerMinimize();
        break;

    case DISPID_CONFIRMCLOSE:
        hr = OnConfirmClose( pdispparams->rgvarg[0].pboolVal );
        break;
    }
    return hr;
}

HRESULT __stdcall CEventSink::OnConnected()
{
    DC_BEGIN_FN("OnConnected");
    TRC_NRM((TB,_T("CEventSink::OnConnected\n")));

    TRC_ASSERT(_pContainerWnd, (TB,_T("_pContainerWnd is NULL")));
    if (_pContainerWnd)
    {
        _pContainerWnd->OnConnected();
    }

    DC_END_FN();
    return S_OK;
}

HRESULT __stdcall CEventSink::OnLoginComplete()
{
    DC_BEGIN_FN("OnConnected");
    TRC_NRM((TB,_T("CEventSink::OnConnected\n")));

    TRC_ASSERT(_pContainerWnd, (TB,_T("_pContainerWnd is NULL")));
    if (_pContainerWnd)
    {
        _pContainerWnd->OnLoginComplete();
    }

    DC_END_FN();
    return S_OK;
}

HRESULT __stdcall CEventSink::OnDisconnected(long disconReason)
{
    DC_BEGIN_FN("OnDisonnected");
    TRC_NRM((TB,_T("CEventSink::OnDisonnected\n")));

    TRC_ASSERT(_pContainerWnd, (TB,_T("_pContainerWnd is NULL")));
    if (_pContainerWnd)
    {
        _pContainerWnd->OnDisconnected(disconReason);
    }

    DC_END_FN();
    return S_OK;
}

HRESULT __stdcall CEventSink::OnRequestEnterFullScreen()
{
    DC_BEGIN_FN("OnEnterFullScreen");

    TRC_ASSERT(_pContainerWnd, (TB,_T("_pContainerWnd is NULL")));
    if (_pContainerWnd)
    {
        _pContainerWnd->OnEnterFullScreen();
    }

    DC_END_FN();
    return S_OK;
}

HRESULT __stdcall CEventSink::OnRequestLeaveFullScreen()
{
    DC_BEGIN_FN("OnLeaveFullScreen");

    TRC_ASSERT(_pContainerWnd, (TB,_T("_pContainerWnd is NULL")));
    if (_pContainerWnd)
    {
        _pContainerWnd->OnLeaveFullScreen();
    }

    DC_END_FN();
    return S_OK;
}

HRESULT __stdcall CEventSink::OnFatalError(long errorCode)
{
    DC_BEGIN_FN("OnFatalError");
    TRC_NRM((TB,_T("CEventSink::OnFatalError\n")));

    TRC_ASSERT(_pContainerWnd, (TB,_T("_pContainerWnd is NULL")));
    if (_pContainerWnd)
    {
        _pContainerWnd->OnFatalError(errorCode);
    }

    DC_END_FN();
    return S_OK;
}

HRESULT __stdcall CEventSink::OnWarning(long warnCode)
{
    DC_BEGIN_FN("OnFatalError");
    TRC_NRM((TB,_T("CEventSink::OnFatalError\n")));

    TRC_ASSERT(_pContainerWnd, (TB,_T("_pContainerWnd is NULL")));
    if (_pContainerWnd)
    {
        _pContainerWnd->OnWarning(warnCode);
    }

    DC_END_FN();
    return S_OK;
}

HRESULT __stdcall CEventSink::OnRemoteDesktopSizeChange(long width, long height)
{
    DC_BEGIN_FN("OnFatalError");
    TRC_NRM((TB,_T("CEventSink::OnFatalError\n")));

    TRC_ASSERT(_pContainerWnd, (TB,_T("_pContainerWnd is NULL")));
    if (_pContainerWnd)
    {
        _pContainerWnd->OnRemoteDesktopSizeNotify(width,height);
    }

    DC_END_FN();
    return S_OK;
}

//
// Just minimize the container window
//
HRESULT __stdcall CEventSink::OnRequestContainerMinimize()
{
    DC_BEGIN_FN("OnRequestContainerMinimize");
    TRC_NRM((TB,_T("CEventSink::OnFatalError\n")));

    TRC_ASSERT(_pContainerWnd, (TB,_T("_pContainerWnd is NULL")));
    if (_pContainerWnd)
    {
        _pContainerWnd->OnRequestMinimize();
    }

    DC_END_FN();
    return S_OK;
}

HRESULT __stdcall CEventSink::OnConfirmClose(VARIANT_BOOL* pvbConfirmClose)
{
    BOOL fConfirmClose;
    HRESULT hr = E_FAIL;
    DC_BEGIN_FN("OnConfirmClose");

    TRC_NRM((TB,_T("CEventSink::OnConfirmClose\n")));

    TRC_ASSERT(_pContainerWnd, (TB,_T("_pContainerWnd is NULL")));
    if(pvbConfirmClose)
    {
        if (_pContainerWnd)
        {
            hr = _pContainerWnd->OnConfirmClose( &fConfirmClose );
            if (SUCCEEDED(hr))
            {
                *pvbConfirmClose = fConfirmClose ? VARIANT_TRUE :
                                                   VARIANT_FALSE;
            }
        }
    }
    else
    {
        return E_INVALIDARG;
    }

    DC_END_FN();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\enumsrvmru.h ===
//
// enumsrvmru.h: IEnumStr for the server MRU. Used by autocomplete
//
// Copyright Microsoft Corporation 2000

#ifndef _enumsrvmru_h_
#define _enumsrvmru_h_

#include "sh.h"
#include "objidl.h"

class CTscSettings;

class CEnumSrvMru : public IEnumString
{
public:

    CEnumSrvMru()
    : _iCurrEnum(0),
      _refCount(1)
    {
    }

    //
    // IUnknown methods.
    //
    STDMETHOD(QueryInterface) (THIS_ REFIID riid,LPVOID *ppiuk );
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release)();

    //
    // IEnumString methods.
    //

    STDMETHOD(Next) (
        ULONG celt,
        LPOLESTR  *rgelt,
        ULONG  *pceltFetched);

    STDMETHOD(Skip)(ULONG celt);
    STDMETHOD(Reset) (void)
    {
        _iCurrEnum = 0;
        return S_OK;
    }
    STDMETHOD(Clone) (
        IEnumString  ** ppenum);

    //
    // Private methods
    //
    BOOL InitializeFromTscSetMru( CTscSettings* pTscSet);

private:
    long                _refCount;
    // WCHAR versions of strings in server MRU list
    WCHAR               _szMRU[SH_NUM_SERVER_MRU][SH_MAX_ADDRESS_LENGTH];
    ULONG               _iCurrEnum; // Current enumeration context
};

#endif //_enumsrvmru_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\enumsrvmru.cpp ===
//
// enumsrvmru.cpp: Implements IEnumStr for the server MRU list
//                 used by autocomplete code
//
// Copyright Microsoft Corporation 2000

#include "stdafx.h"

#ifndef OS_WINCE

#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "enumsrvmru"
#include <atrcapi.h>

#include "enumsrvmru.h"


STDMETHODIMP CEnumSrvMru::QueryInterface(
    REFIID riid,
    void **ppvObject)
{
    DC_BEGIN_FN("QueryInterface");

    TRC_ASSERT(ppvObject, (TB,_T("ppvObject is NULL\n")));
    if(!ppvObject)
    {
        return E_INVALIDARG;
    }

    if ( IID_IEnumString == riid )
        *ppvObject = (void *)((IEnumString*)this);
    else if ( IID_IUnknown == riid )
        *ppvObject = (void *)((IUnknown *)this);
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();

    DC_END_FN();
    return S_OK;
} //QueryInterface

STDMETHODIMP_(ULONG) CEnumSrvMru::AddRef()
{
    return InterlockedIncrement(&_refCount);
} //AddRef


STDMETHODIMP_(ULONG) CEnumSrvMru::Release()
{
    DC_BEGIN_FN("Release");
    TRC_ASSERT(_refCount > 0, (TB,_T("_refCount invalid %d"), _refCount));

    LONG refCount = InterlockedDecrement(&_refCount);

    if (  refCount <= 0 )
        delete this;

    DC_END_FN();
    return (ULONG) refCount;
}  //Release


//Clone a copy of this object
STDMETHODIMP CEnumSrvMru::Clone(IEnumString ** ppEnumStr)
{
    return E_NOTIMPL;
}

//
// Next enum
// celt - number of elements requested
// rgelt - array of elements to return
// pceltFetched - pointer to number of elements actually supplied
//
STDMETHODIMP CEnumSrvMru::Next( ULONG celt,
                                LPOLESTR * rgelt,
                                ULONG * pceltFetched )
{
    DC_BEGIN_FN("Next");
    *pceltFetched = 0;

    while( _iCurrEnum < SH_NUM_SERVER_MRU &&
           *pceltFetched < celt)
    {
        //Need to allocate powerful COM memory
        //caller frees
        LPOLESTR pwzMRU= (LPOLESTR)CoTaskMemAlloc(SH_MAX_ADDRESS_LENGTH*sizeof(OLECHAR));
        if(!pwzMRU)
        {
            return E_OUTOFMEMORY;
        }
        DC_WSTRNCPY(pwzMRU, _szMRU[_iCurrEnum++], SH_MAX_ADDRESS_LENGTH);
        rgelt[(*pceltFetched)++] = pwzMRU;
    }

    //
    // Fill in remaining request items with NULLS
    //
    ULONG cAdded = *pceltFetched;
    while (cAdded < celt)
    {
        rgelt[cAdded++] = NULL;
    }


    DC_END_FN();
    return *pceltFetched == celt ? S_OK : S_FALSE;
}

//
// Skips celt elements
// if cannot skip as many as requested don't skip any
//
STDMETHODIMP CEnumSrvMru::Skip( ULONG celt )
{
    DC_BEGIN_FN("Next");
    TRC_ASSERT(_iCurrEnum < SH_NUM_SERVER_MRU, (TB,_T("_iCurEnum out of range: %d"),
                                                _iCurrEnum));

    if(_iCurrEnum + celt < SH_NUM_SERVER_MRU)
    {
        _iCurrEnum += celt;
        return S_OK;
    }

    DC_END_FN();
    return S_FALSE;
}

//
// Initialize the string collection with strings
// from the TscSettings's server MRU list
//
BOOL CEnumSrvMru::InitializeFromTscSetMru( CTscSettings* pTscSet)
{
    DC_BEGIN_FN("InitializeFromSHMru");
    USES_CONVERSION;
    TRC_ASSERT(pTscSet, (TB,_T("pTscSet NULL")));
    if(!pTscSet)
    {
        return FALSE;
    }

    for(int i=0; i<TSC_NUM_SERVER_MRU; i++)
    {
        PWCHAR wszServer = T2W( (LPTSTR)pTscSet->GetMRUServer(i));
        if(!wszServer)
        {
            return FALSE;
        }
        DC_WSTRNCPY(_szMRU[i], wszServer, SH_MAX_ADDRESS_LENGTH);
    }

    DC_END_FN();
    return TRUE;
}


#endif //OS_WINCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\framewnd.h ===
//
// framewnd.h: Implemenation of a window frame class
// Copyright Microsoft Corporation 1999-2000
//
// This is a super lite wrapper. It doesn't go and wrap
// every win32 window API under the sun like MFC or ATL.
//

#ifndef _FRAMEWND_H_
#define	_FRAMEWND_H_

class CTscFrameWnd
{
public:
    CTscFrameWnd();
    virtual ~CTscFrameWnd();

    //
    // API Methods
    //
    HWND        CreateWnd(HINSTANCE hInstance,HWND hwndParent,
                          LPTSTR szClassName, LPTSTR szTitle,
                          DWORD dwStyle, LPRECT lpInitialRect,
                          HICON hIcon);
    HWND        GetHwnd()       {return _hWnd;}
    HINSTANCE   GetInstance()   {return _hInstance;}

    virtual LRESULT CALLBACK WndProc(HWND hwnd,
                                     UINT uMsg,
                                     WPARAM wParam,
                                     LPARAM lParam) = 0;
    BOOL        DestroyWindow() {return ::DestroyWindow(_hWnd);}
private:
    //Private methods
    static LRESULT CALLBACK StaticTscFrameWndProc(HWND hwnd,
                                                  UINT uMsg,
                                                  WPARAM wParam,
                                                  LPARAM lParam);
protected:
    //Protected members
    HWND        _hWnd;
private:
    //Private members
    HINSTANCE   _hInstance;
};

#endif //	_CONTWND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\framewnd.cpp ===
//
// framewnd.cpp
//
// Implementation of CTscFrameWnd
// Frame window class
//
// Copyright(C) Microsoft Corporation 2000
// Author: Nadim Abdo (nadima)
//
//

#include "stdafx.h"

#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "framewnd"
#include <atrcapi.h>


#include "framewnd.h"

CTscFrameWnd::CTscFrameWnd()
{
    _hWnd = NULL;
}

CTscFrameWnd::~CTscFrameWnd()
{
}

//
// Create the window
// params:
//  hInstance   - app instance
//  hWndParent  - parent window
//  szClassName - window class name (will create)
//  dwStyle     - window style
// returns:
//  window handle
//
HWND CTscFrameWnd::CreateWnd(HINSTANCE hInstance,HWND hwndParent,
                          LPTSTR szClassName, LPTSTR szTitle,
                          DWORD dwStyle, LPRECT lpInitialRect,
                          HICON hIcon)
{
    BOOL rc = FALSE;
    DC_BEGIN_FN("CreateWnd");

    TRC_ASSERT(hInstance, (TB, _T("hInstance is null")));
    TRC_ASSERT(szClassName, (TB, _T("szClassName is null")));
    TRC_ASSERT(lpInitialRect, (TB, _T("lpInitialRect is null")));
    if(!hInstance || !szClassName || !lpInitialRect)
    {
        return NULL;
    }

    TRC_ASSERT(!_hWnd, (TB,_T("Double create window. Could be leaking!!!")));
    _hInstance = hInstance;
#ifndef OS_WINCE
    WNDCLASSEX wndclass;
    wndclass.cbSize         = sizeof (wndclass);
#else //OS_WINCE
    WNDCLASS wndclass;
#endif
    wndclass.style          = 0;
    wndclass.lpfnWndProc    = CTscFrameWnd::StaticTscFrameWndProc;
    wndclass.cbClsExtra     = 0;
    wndclass.cbWndExtra     = 0;
    wndclass.hInstance      = hInstance;
    wndclass.hIcon          = hIcon;
    wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground  = (HBRUSH) GetStockObject(NULL_BRUSH);
    wndclass.lpszMenuName   = NULL;
    wndclass.lpszClassName  = szClassName;
#ifndef OS_WINCE
    wndclass.hIconSm        = NULL;
#endif

#ifndef OS_WINCE
    if ((0 == RegisterClassEx(&wndclass)) &&
#else
    if ((0 == RegisterClass(&wndclass)) &&
#endif
        (ERROR_CLASS_ALREADY_EXISTS != GetLastError()))
    {
        TRC_ERR((TB,_T("RegisterClassEx failed: %d"),GetLastError()));
        return NULL;
    }
    _hWnd = CreateWindow(szClassName,
                         szTitle,
                         dwStyle,
                         0,
                         0,
                         lpInitialRect->right - lpInitialRect->left,
                         lpInitialRect->bottom - lpInitialRect->top,
                         hwndParent,
                         NULL,
                         hInstance,
                         this);

    if(_hWnd)
    {
        // put a reference to the current object into the hwnd
        // so we can access the object from the WndProc
        SetLastError(0);
        if(!SetWindowLongPtr(_hWnd, GWLP_USERDATA, (LONG_PTR)this))
        {
            if(GetLastError())
            {
                TRC_ERR((TB,_T("SetWindowLongPtr failed 0x%x"),
                         GetLastError()));
                return NULL;
            }
        }
    }
    else
    {
        TRC_ERR((TB,_T("CreateWindow failed 0x%x"), GetLastError()));
        return NULL;
    }
                         
    
    DC_END_FN();
    return _hWnd;
}


LRESULT CALLBACK CTscFrameWnd::StaticTscFrameWndProc(HWND hwnd,
                                                     UINT uMsg,
                                                     WPARAM wParam,
                                                     LPARAM lParam)
{
    DC_BEGIN_FN("StaticTscFrameWndProc");
	// pull out the pointer to the container object associated with this hwnd
	CTscFrameWnd *pwnd = (CTscFrameWnd *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if(pwnd)
    {
        return pwnd->WndProc( hwnd, uMsg, wParam, lParam);
    }
    else
    {
        return DefWindowProc (hwnd, uMsg, wParam, lParam);
    }
    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\evsink.h ===
//
// evsink.h: Event Sink Object class
//

#ifndef _sinkobj_h_
#define _sinkobj_h_

//fwd declaration
class CContainerWnd;

class CEventSink : public IMsTscAxEvents
{
public:
    // constructor and destructor
    CEventSink(CContainerWnd* pContainerWnd);
    ~CEventSink();

    // IUnknown methods
    STDMETHODIMP QueryInterface (THIS_ REFIID riid, LPVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef (THIS);
    STDMETHODIMP_(ULONG) Release(THIS);

    // IDispatch methods
    STDMETHODIMP GetTypeInfoCount(THIS_ UINT *);
    STDMETHODIMP GetTypeInfo     (THIS_ UINT, LCID, ITypeInfo **);
    STDMETHODIMP GetIDsOfNames   (THIS_ REFIID, OLECHAR **, UINT, LCID, DISPID *);
    STDMETHODIMP Invoke          (THIS_ DISPID, REFIID, LCID, WORD,
                                  DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);
    //Event sinks
    HRESULT inline __stdcall OnConnected();
    HRESULT inline __stdcall OnLoginComplete();
    HRESULT inline __stdcall OnDisconnected(long disconReason);
    HRESULT inline __stdcall OnRequestEnterFullScreen();
    HRESULT inline __stdcall OnRequestLeaveFullScreen();
    HRESULT inline __stdcall OnFatalError(long errorCode);
    HRESULT inline __stdcall OnWarning(long errorCode);
    HRESULT inline __stdcall OnRemoteDesktopSizeChange(long width, long height);
    HRESULT inline __stdcall OnRequestContainerMinimize();
    HRESULT inline __stdcall OnConfirmClose(VARIANT_BOOL* pvbConfirmClose);

private:
    LONG           _cRef;
    CContainerWnd* _pContainerWnd;
};


#endif // _sinkobj_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\fstream.cpp ===
//
// fsteam.cpp
// Implements a file stream
// for reading text files line by line.
// the standard C streams, only support
// unicode as binary streams which are a pain to work
// with).
//
// This class reads/writes both ANSI and UNICODE files
// and converts to/from UNICODE internally
//
// Does not do any CR/LF translations either on input
// or output.
//
// Copyright(C) Microsoft Corporation 2000
// Author: Nadim Abdo (nadima)
//

#include "stdafx.h"
#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "fstream.cpp"
#include <atrcapi.h>

#include "fstream.h"

#ifndef UNICODE
//
// Adding ansi support is just a matter of converting
// from UNICODE file to ANSI internal if the file
// has a UNICODE BOM
//
#error THIS MODULE ASSUMES BEING COMPILED UNICODE, ADD ANSI IF NEEDED
#endif


CTscFileStream::CTscFileStream()
{
    DC_BEGIN_FN("~CFileStream");
    _hFile = INVALID_HANDLE_VALUE;
    _pBuffer  = NULL;
    _fOpenForRead = FALSE;
    _fOpenForWrite = FALSE;
    _fReadToEOF = FALSE;
    _fFileIsUnicode = FALSE;
    _fAtStartOfFile = TRUE;
    _pAnsiLineBuf = NULL;
    _cbAnsiBufSize = 0;
    DC_END_FN();
}

CTscFileStream::~CTscFileStream()
{
    DC_BEGIN_FN("~CFileStream");
    
    Close();

    if(_hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(_hFile);
        _hFile = INVALID_HANDLE_VALUE;
    }
    if(_pBuffer)
    {
        LocalFree(_pBuffer);
        _pBuffer = NULL;
    }
    if(_pAnsiLineBuf)
    {
        LocalFree(_pAnsiLineBuf);
        _pAnsiLineBuf = NULL;
    }
    DC_END_FN();
}

INT CTscFileStream::OpenForRead(LPTSTR szFileName)
{
    DC_BEGIN_FN("OpenForRead");
    INT err;

    err = Close();
    if(err != ERR_SUCCESS)
    {
        return err;
    }

    //Alloc read buffers
    if(!_pBuffer)
    {
        _pBuffer = (PBYTE)LocalAlloc(LPTR, READ_BUF_SIZE);
        if(!_pBuffer)
        {
            return ERR_OUT_OF_MEM;
        }
    }
    if(!_pAnsiLineBuf)
    {
        _pAnsiLineBuf = (PBYTE)LocalAlloc(LPTR, LINEBUF_SIZE);
        if(!_pAnsiLineBuf)
        {
            return ERR_OUT_OF_MEM;
        }
        _cbAnsiBufSize = LINEBUF_SIZE;
    }
    memset(_pBuffer, 0, READ_BUF_SIZE);
    memset(_pAnsiLineBuf, 0, LINEBUF_SIZE); 

    _hFile = CreateFile( szFileName,
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_ALWAYS, //Creates if !exist
                         FILE_ATTRIBUTE_NORMAL,
                         NULL);

    if(INVALID_HANDLE_VALUE == _hFile)
    {
        TRC_ERR((TB, _T("CreateFile failed: %s - err:%x"),
                 szFileName, GetLastError()));
        return ERR_CREATEFILE; 
    }

#ifdef OS_WINCE
    DWORD dwRes;
    dwRes = SetFilePointer( _hFile, 0, NULL, FILE_BEGIN);
    if (dwRes == (DWORD)0xffffffff) {
        DWORD dwErr = GetLastError();
        TRC_ERR((TB, _T("CreateFile failed to reset: %s - err:%x"),
                 szFileName, GetLastError()));
        return ERR_CREATEFILE; 
    }

#endif

    _curBytePtr   = 0;
    _curBufSize   = 0;
    _tcsncpy(_szFileName, szFileName, MAX_PATH-1);
    //Yes this is ok, the size is MAX_PATH+1 ;-)
    _szFileName[MAX_PATH] = 0;
    _fOpenForRead = TRUE;
    _fFileIsUnicode = FALSE;
    _fAtStartOfFile = TRUE;

    DC_END_FN();
    return ERR_SUCCESS;
}

//
// Opens the stream for writing
// always nukes the existing file contents
//
INT CTscFileStream::OpenForWrite(LPTSTR szFileName, BOOL fWriteUnicode)
{
    DC_BEGIN_FN("OpenForWrite");

    INT err;
    DWORD dwAttributes = 0;
    err = Close();
    if(err != ERR_SUCCESS)
    {
        return err;
    }

    if(_pAnsiLineBuf)
    {
        LocalFree(_pAnsiLineBuf);
        _pAnsiLineBuf = NULL;
    }
    _pAnsiLineBuf = (PBYTE)LocalAlloc(LPTR, LINEBUF_SIZE);
    if(!_pAnsiLineBuf)
    {
        return ERR_OUT_OF_MEM;
    }
    _cbAnsiBufSize = LINEBUF_SIZE;

    //
    // Preserve any existing attributes
    //
    dwAttributes = GetFileAttributes(szFileName);
    if (-1 == dwAttributes)
    {
        TRC_ERR((TB,_T("GetFileAttributes for %s failed 0x%x"),
                 szFileName, GetLastError()));
        dwAttributes = FILE_ATTRIBUTE_NORMAL;
    }

    _hFile = CreateFile( szFileName,
                         GENERIC_WRITE,
                         FILE_SHARE_READ,
                         NULL,
                         CREATE_ALWAYS, //Creates and reset
                         dwAttributes,
                         NULL);

    if(INVALID_HANDLE_VALUE == _hFile)
    {
        TRC_ERR((TB, _T("CreateFile failed: %s - err:%x"),
                 szFileName, GetLastError()));
        return ERR_CREATEFILE; 
    }

    _tcsncpy(_szFileName, szFileName, MAX_PATH-1);
    //Yes this is ok, the size is MAX_PATH+1 ;-)
    _szFileName[MAX_PATH] = 0;
    _fOpenForWrite = TRUE;
    _fFileIsUnicode = fWriteUnicode;
    _fAtStartOfFile =  TRUE;

    DC_END_FN();
    return ERR_SUCCESS;
}

INT CTscFileStream::Close()
{
    DC_BEGIN_FN("Close");
    if(_hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(_hFile);
        _hFile = INVALID_HANDLE_VALUE;
    }
    _fOpenForRead = _fOpenForWrite = FALSE;
    _fReadToEOF = FALSE;
    _tcscpy(_szFileName, _T(""));
    //Don't free the read buffers
    //they'll be cached for subsequent use

    DC_END_FN();
    return ERR_SUCCESS;
}

//
// Read a line from the file and return it as UNICODE
//
// Read up to the next newline, or till cbLineSize/sizeof(WCHAR) or
// untill the EOF. Whichever comes first.
//
//
INT CTscFileStream::ReadNextLine(LPWSTR szLine, INT cbLineSize)
{
    BOOL bRet = FALSE;
    INT  cbBytesCopied = 0;
    INT  cbOutputSize  = 0;
    BOOL fDone = FALSE;
    PBYTE pOutBuf = NULL; //where to write the result
    BOOL fFirstIter = TRUE;
    DC_BEGIN_FN("ReadNextLine");

    TRC_ASSERT(_hFile != INVALID_HANDLE_VALUE,
                (TB,_T("No file handle")));
    TRC_ASSERT(_pBuffer, (TB,_T("NO buffer")));

    if(_fOpenForRead && !_fReadToEOF && cbLineSize && szLine)
    {
        //
        //Read up to a line's worth (terminated by \n)
        //but stop short if szLine is too small
        //

        //
        //Check if we've got enough buffered bytes to read from
        //if not go ahead and read another buffer's worth
        //
        while(!fDone)
        {
            if(_curBytePtr >= _curBufSize)
            {
                //Read next buffer full
                DWORD cbRead = 0;
                bRet = ReadFile(_hFile,
                                _pBuffer,
                                READ_BUF_SIZE,
                                &cbRead,
                                NULL);
                if(!bRet && GetLastError() == ERROR_HANDLE_EOF)
                {
                    //cancel error
                    bRet = TRUE;
                    _fReadToEOF = TRUE;
                }
                if(bRet)
                {
                    if(cbRead)
                    {
                        _curBufSize = cbRead;
                        _curBytePtr = 0;
                    }
                    else
                    {
                        _fReadToEOF = TRUE;
                        if(cbBytesCopied)
                        {
                            //reached EOF but we've returned at least
                            //some data
                            return ERR_SUCCESS;
                        }
                        else
                        {
                            //EOF can't read any data
                            return ERR_EOF;
                        }
                    }
                }
                else
                {
                    TRC_NRM((TB,_T("ReadFile returned fail:%x"),
                             GetLastError()));
                    return ERR_FILEOP;
                }
            }
            TRC_ASSERT(_curBytePtr < READ_BUF_SIZE,
                       (TB,_T("_curBytePtr %d exceeds buf size"),
                        _curBytePtr));
            //
            // If we're at the start of the file,
            //
            if(_fAtStartOfFile)
            {
                //CAREFULL this could update the current byte ptr
                CheckFirstBufMarkedUnicode();
                _fAtStartOfFile = FALSE;
            }

            if(fFirstIter)
            {
                if(_fFileIsUnicode)
                {
                    //file is unicode output directly into user buffer
                    pOutBuf = (PBYTE)szLine;
                    //leave a space for a trailing WCHAR null
                    cbOutputSize = cbLineSize - sizeof(WCHAR);
                }
                else
                {
                    //read half as many chars as there are bytes in the output
                    //buf because conversion doubles.
                    
                    //leave a space for a trailing WCHAR null
                    cbOutputSize = cbLineSize/sizeof(WCHAR) - 2;
                    
                    //Alloc ANSI buffer for this line
                    //if cached buffer is too small
                    if(cbOutputSize + 2 > _cbAnsiBufSize)
                    {
                        if ( _pAnsiLineBuf)
                        {
                            LocalFree( _pAnsiLineBuf);
                            _pAnsiLineBuf = NULL;
                        }
                        _pAnsiLineBuf = (PBYTE)LocalAlloc(LPTR,
                                                          cbOutputSize + 2);
                        if(!_pAnsiLineBuf)
                        {
                            return ERR_OUT_OF_MEM;
                        }
                        _cbAnsiBufSize = cbOutputSize + 2;
                    }
                    //file is ANSI output into temporary buffer for conversion
                    pOutBuf = _pAnsiLineBuf;
                }
                fFirstIter = FALSE;
            }

            PBYTE pStartByte = (PBYTE)_pBuffer + _curBytePtr;
            PBYTE pReadByte = pStartByte;
            PBYTE pNewLine  = NULL;
            
            //Find newline. Don't bother scanning further than we can
            //write in the input buffer
            int maxreaddist = min(_curBufSize-_curBytePtr,
                                  cbOutputSize-cbBytesCopied);
            PBYTE pEndByte  = (PBYTE)pStartByte + maxreaddist;
            for(;pReadByte<pEndByte;pReadByte++)
            {
                if(*pReadByte == '\n')
                {
                    if(_fFileIsUnicode)
                    {
                        //
                        // Check if the previous byte was a zero
                        // if so we've hit the '0x0 0xa' byte pair
                        // for a unicode '\n'
                        //
                        if(pReadByte != pStartByte &&
                           *(pReadByte - 1) == 0)
                        {
                            pNewLine = pReadByte;
                            break;
                        }
                    }
                    else
                    {
                        pNewLine = pReadByte;
                        break;
                    }
                }
            }
            if(pNewLine)
            {
                int cbBytesToCopy = (pNewLine - pStartByte) +
                    (_fFileIsUnicode ? sizeof(WCHAR) : sizeof(CHAR));
                if(cbBytesToCopy <= (cbOutputSize-cbBytesCopied))
                {
                    memcpy( pOutBuf + cbBytesCopied, pStartByte,
                            cbBytesToCopy);
                    _curBytePtr += cbBytesToCopy;
                    cbBytesCopied += cbBytesToCopy;
                    fDone = TRUE;
                }
            }
            else
            {
                //Didn't find a newline
                memcpy( pOutBuf + cbBytesCopied, pStartByte,
                        maxreaddist);
                //we're done if we filled up the output
                _curBytePtr += maxreaddist;
                cbBytesCopied += maxreaddist;
                if(cbBytesCopied == cbOutputSize)
                {
                    fDone = TRUE;
                }
            }
        } // iterate over file buffer chunks

        
        //Ensure trailing null
        pOutBuf[cbBytesCopied]   = 0;
        if(_fFileIsUnicode)
        {
            pOutBuf[cbBytesCopied+1] = 0;
        }


        //Done reading line
        if(_fFileIsUnicode)
        {
            EatCRLF( (LPWSTR)szLine, cbBytesCopied/sizeof(WCHAR));
            return ERR_SUCCESS;
        }
        else
        {
            //The file is ANSI. Conv to UNICODE,
            //first copy the contents out of the output
            
            //Now convert to UNICODE
            int ret = 
                MultiByteToWideChar(CP_ACP,
                                MB_PRECOMPOSED,
                                (LPCSTR)_pAnsiLineBuf,
                                -1,
                                szLine,
                                cbLineSize/sizeof(WCHAR));
            if(ret)
            {
                EatCRLF( (LPWSTR)szLine, ret - 1);
                return ERR_SUCCESS;
            }
            else
            {
                TRC_ERR((TB,_T("MultiByteToWideChar failed: %x"),
                               GetLastError()));
                DWORD dwErr = GetLastError();
                if(ERROR_INSUFFICIENT_BUFFER == dwErr)
                {
                    return ERR_BUFTOOSMALL;
                }
                else
                {
                    return ERR_UNKNOWN;
                }
            }
        }
    }
    else
    {
        //error path
        if(_fReadToEOF)
        {
            return ERR_EOF;
        }
        if(!_fOpenForRead)
        {
            return ERR_NOTOPENFORREAD;
        }
        else if (!_pBuffer)
        {
            return ERR_OUT_OF_MEM;
        }
        else
        {
            return ERR_UNKNOWN;
        }
    }

    DC_END_FN();
}

// check for the UNICODE BOM and eat it
void CTscFileStream::CheckFirstBufMarkedUnicode()
{
    DC_BEGIN_FN("CheckFirstBufMarkedUnicode");
    TRC_ASSERT(_pBuffer, (TB,_T("NO buffer")));
    if(_curBufSize >= sizeof(WCHAR))
    {
        LPWSTR pwsz = (LPWSTR)_pBuffer;
        if(UNICODE_BOM == *pwsz)
        {
            TRC_NRM((TB,_T("File is UNICODE")));
            _fFileIsUnicode = TRUE;
            _curBytePtr += sizeof(WCHAR);
        }
        else
        {
            TRC_NRM((TB,_T("File is ANSI")));
            _fFileIsUnicode = FALSE;
        }
    }
    else
    {
        //File to small (less than 2 bytes)
        //can't be unicode
        _fFileIsUnicode = FALSE;
    }
    DC_END_FN();
}

//
// Write string szLine to the file
// converting to ANSI if the file is not a unicode file
// also writeout the UNICODE BOM at the start of the
// the file
//
INT CTscFileStream::Write(LPWSTR szLine)
{
    DC_BEGIN_FN("WriteNext");
    BOOL bRet = FALSE;
    DWORD cbWrite = 0;
    PBYTE pDataOut = NULL;
    DWORD dwWritten;

    if(_fOpenForWrite && szLine)
    {
        TRC_ASSERT(_hFile != INVALID_HANDLE_VALUE,
                    (TB,_T("No file handle")));
        if(_fFileIsUnicode)
        {
            if(_fAtStartOfFile)
            {
                //Write the BOM
                WCHAR wcBOM = UNICODE_BOM;
                bRet = WriteFile( _hFile, &wcBOM, sizeof(wcBOM),
                           &dwWritten, NULL);
                if(!bRet || dwWritten != sizeof(wcBOM))
                {
                    TRC_NRM((TB,_T("WriteFile returned fail:%x"),
                            GetLastError()));
                    return ERR_FILEOP;
                }
                _fAtStartOfFile = FALSE;
            }
            //Write UNICODE data out directly
            pDataOut = (PBYTE)szLine;
            cbWrite = wcslen(szLine) * sizeof(WCHAR);
        }
        else
        {
            //Convert UNICODE data to ANSI
            //before writing it out

            TRC_ASSERT(_pAnsiLineBuf && _cbAnsiBufSize,
                        (TB,_T("ANSI conversion buffer should be allocated")));

            INT ret = WideCharToMultiByte(
                        CP_ACP,
                        WC_COMPOSITECHECK | WC_DEFAULTCHAR,
                        szLine,
                        -1,
                        (LPSTR)_pAnsiLineBuf,
                        _cbAnsiBufSize,
                        NULL,   // system default character.
                        NULL);  // no notification of conversion failure.
            if(ret)
            {
                pDataOut = _pAnsiLineBuf;
                cbWrite = ret - 1; //don't write out the NULL
            }
            else
            {
                TRC_ERR((TB,_T("MultiByteToWideChar failed: %x"),
                               GetLastError()));
                DWORD dwErr = GetLastError();
                if(ERROR_INSUFFICIENT_BUFFER == dwErr)
                {
                    return ERR_BUFTOOSMALL;
                }
                else
                {
                    return ERR_UNKNOWN;
                }
            }
        }

        bRet = WriteFile( _hFile, pDataOut, cbWrite,
                   &dwWritten, NULL);
        if(bRet && dwWritten == cbWrite)
        {
            return ERR_SUCCESS;
        }
        else
        {
            TRC_NRM((TB,_T("WriteFile returned fail:%x"),
                    GetLastError()));
            return ERR_FILEOP;
        }
    }
    else
    {
        if(!_fOpenForWrite)
        {
            return ERR_NOTOPENFORWRITE;
        }
        else
        {
            return ERR_UNKNOWN;
        }
    }

    DC_END_FN();
}

//
// Remap a \r\n pair from the end of the line
// to a \n
//
void CTscFileStream::EatCRLF(LPWSTR szLine, INT nChars)
{
    if(szLine && nChars >= 2)
    {
        if(szLine[nChars-1] == _T('\n') &&
           szLine[nChars-2] == _T('\r'))
        {
            szLine[nChars-2] = _T('\n');
            //this adds a double NULL to the end of the string
            szLine[nChars-1] = 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\fstream.h ===
//
// fsteam.h
// Implements a file stream
// for reading text files line by line with UNICODE
// support (the standard C streams, only support
// unicode as binary streams which are a pain to work
// with)
//
// Copyright(C) Microsoft Corporation 2000
// Author: Nadim Abdo (nadima)
//

#ifndef _fstream_h_
#define _fstream_h_

#define LINEBUF_SIZE  2048
#define READ_BUF_SIZE 8192

#define UNICODE_BOM 0xFEFF

#define ERR_SUCCESS          1
#define ERR_UNKNOWN         -1
#define ERR_OUT_OF_MEM      -2
#define ERR_CREATEFILE      -3
#define ERR_BUFTOOSMALL     -4
#define ERR_EOF             -5
#define ERR_NOTOPENFORREAD  -6
#define ERR_NOTOPENFORWRITE -7
#define ERR_FILEOP          -8


class CTscFileStream
{
public:
    CTscFileStream();
    ~CTscFileStream();

    INT     OpenForRead(LPTSTR szFileName);
    INT     OpenForWrite(LPTSTR szFileName, BOOL fWriteUnicode=TRUE);
    INT     Write(LPWSTR szLine);
    INT     ReadNextLine(LPTSTR szLine, INT lineSize);
    INT     Close();
    BOOL    IsOpenForWrite()    {return _fOpenForWrite;}
    BOOL    IsOpenForRead()     {return _fOpenForRead;}

private:
    inline void CheckFirstBufMarkedUnicode();
    inline void EatCRLF(LPWSTR szLine, INT nChars);

private:
    HANDLE _hFile;
    PBYTE  _pBuffer;
    PBYTE  _pAnsiLineBuf;
    INT    _cbAnsiBufSize;
    BOOL   _fOpenForRead;
    BOOL   _fOpenForWrite;
    BOOL   _fReadToEOF;
    INT    _curBytePtr;
    INT    _curBufSize;
    TCHAR  _szFileName[MAX_PATH+1];
    BOOL   _fFileIsUnicode;
    BOOL   _fAtStartOfFile;
};
#endif  //_fstream_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\mallocdbgdlg.cpp ===
//
// mallocdbgdlg.cpp: mallocdbg dialog box
//

#include "stdafx.h"

#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "mallocdbgdlg"
#include <atrcapi.h>

#include "mallocdbgdlg.h"
#include "sh.h"

#ifdef DC_DEBUG

CMallocDbgDlg* CMallocDbgDlg::_pMallocDbgDlgInstance = NULL;

CMallocDbgDlg::CMallocDbgDlg( HWND hwndOwner, HINSTANCE hInst, DCINT failPercent, DCBOOL mallocHuge) :
           CDlgBase( hwndOwner, hInst, mallocHuge ? UI_IDD_MALLOCHUGEFAILURE : UI_IDD_MALLOCFAILURE)
{
    DC_BEGIN_FN("CMallocDbgDlg");
    TRC_ASSERT((NULL == CMallocDbgDlg::_pMallocDbgDlgInstance), 
               (TB,_T("Clobbering existing dlg instance pointer\n")));

    _failPercent = failPercent;

    CMallocDbgDlg::_pMallocDbgDlgInstance = this;
    DC_END_FN();
}

CMallocDbgDlg::~CMallocDbgDlg()
{
    CMallocDbgDlg::_pMallocDbgDlgInstance = NULL;
}

DCINT CMallocDbgDlg::DoModal()
{
    DCINT retVal = 0;
    DC_BEGIN_FN("DoModal");

    retVal = DialogBox(_hInstance, MAKEINTRESOURCE(_dlgResId),
                       _hwndOwner, StaticDialogBoxProc);
    TRC_ASSERT((retVal != 0 && retVal != -1), (TB, _T("DialogBoxParam failed\n")));

    DC_END_FN();
    return retVal;
}

INT_PTR CALLBACK CMallocDbgDlg::StaticDialogBoxProc (HWND hwndDlg, UINT uMsg,WPARAM wParam, LPARAM lParam)
{
    //
    // Delegate to appropriate instance (only works for single instance dialogs)
    //
    DC_BEGIN_FN("StaticDialogBoxProc");
    DCINT retVal = 0;

    TRC_ASSERT(_pMallocDbgDlgInstance, (TB, _T("MallocDbg dialog has NULL static instance ptr\n")));
    if(_pMallocDbgDlgInstance)
    {
        retVal = _pMallocDbgDlgInstance->DialogBoxProc( hwndDlg, uMsg, wParam, lParam);
    }

    DC_END_FN();
    return retVal;
}

/****************************************************************************/
/* Name: DialogBoxProc                                                      */
/*                                                                          */
/* Purpose: Handles MallocDbg Box dialog  (Random Failure dialog)           */
/*                                                                          */
/* Returns: TRUE if message dealt with                                      */
/*          FALSE otherwise                                                 */
/*                                                                          */
/* Params: See window documentation                                         */
/*                                                                          */
/****************************************************************************/
INT_PTR CALLBACK CMallocDbgDlg::DialogBoxProc (HWND hwndDlg, UINT uMsg,WPARAM wParam, LPARAM lParam)
{
    INT_PTR rc = FALSE;
    DCTCHAR numberString[SH_NUMBER_STRING_MAX_LENGTH];
    DCINT percent = 0;
    DCINT lenchar = 0;

    DC_BEGIN_FN("UIRandomFailureDialogProc");

    TRC_DBG((TB, _T("Random failure dialog")));

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            _hwndDlg = hwndDlg;
            /****************************************************************/
            /* Center the dialog                                            */
            /****************************************************************/
            if(hwndDlg)
            {
                CenterWindow(NULL);
                SetDialogAppIcon(hwndDlg);

                SetFocus(GetDlgItem(hwndDlg, UI_IDC_RANDOMFAILURE_EDIT));
                /************************************************************/
                /* Set edit text with current percentage                    */
                /************************************************************/
                TRC_ASSERT((HIWORD(_failPercent) == 0), (TB,_T("_UI.randomFailureItem")));

                SetDlgItemText(hwndDlg,
                               UI_IDC_RANDOMFAILURE_EDIT,
                               DC_ITOT(LOWORD(_failPercent), numberString, 10));
            }
            rc = TRUE;
        }
        break;

        case WM_COMMAND:
        {
            switch (wParam)
            {
                case UI_IDB_MALLOCFAILURE_OK:
                {
                    rc = TRUE;

                    lenchar = GetWindowText(GetDlgItem(hwndDlg, UI_IDC_RANDOMFAILURE_EDIT),
                                            numberString,
                                            SH_NUMBER_STRING_MAX_LENGTH);

                    if(lenchar)
                    {
                        percent = DC_TTOI(numberString);
                    }

                    if ((percent <= 100) && (percent >= 0))
                    {
                         _failPercent = percent;
                        if(hwndDlg)
                        {
                            EndDialog(hwndDlg, IDOK);
                        }
                    }
                }
                break;

               case UI_IDB_MALLOCHUGEFAILURE_OK:
                {
                    rc = TRUE;

                    lenchar = GetWindowText(GetDlgItem(hwndDlg, UI_IDC_RANDOMFAILURE_EDIT),
                                            numberString,
                                            SH_NUMBER_STRING_MAX_LENGTH);
                    if(lenchar)
                    {
                        percent = DC_TTOI(numberString);
                    }

                    if ((percent <= 100) && (percent >= 0))
                    {
                        _failPercent = percent;
                        if(hwndDlg)
                        {
                            EndDialog(hwndDlg, IDOK);
                        }
                    }
                }
                break;

                default:
                {
                    if(hwndDlg)
                    {
                        rc = CDlgBase::DialogBoxProc(hwndDlg,
                                                  uMsg,
                                                  wParam,
                                                  lParam);
                    }
                }
                break;
            }
        }
        break;

        default:
        {
            rc = CDlgBase::DialogBoxProc(hwndDlg,
                                      uMsg,
                                      wParam,
                                      lParam);
        }
        break;
    }
    DC_END_FN();
    return(rc);
}

#endif //DC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\mallocdbgdlg.h ===
//
// mallocdbgdlg.h: mallocdbg dialog class
// memory allocation failure dialog
//

#ifndef _mallocdbgdlg_h_
#define _mallocdbgdlg_h_

#ifdef DC_DEBUG

#include "dlgbase.h"
#include "sh.h"


class CMallocDbgDlg : public CDlgBase
{
public:
    CMallocDbgDlg(HWND hwndOwner, HINSTANCE hInst, DCINT failPercent, DCBOOL mallocHuge);
    ~CMallocDbgDlg();

    virtual DCINT   DoModal();
    virtual INT_PTR CALLBACK DialogBoxProc(HWND hwndDlg, UINT uMsg,WPARAM wParam, LPARAM lParam);
    static  INT_PTR CALLBACK StaticDialogBoxProc(HWND hwndDlg, UINT uMsg,WPARAM wParam, LPARAM lParam);

    static CMallocDbgDlg* _pMallocDbgDlgInstance;

    DCINT GetFailPercent()      {return _failPercent;}

private:
    DCINT _failPercent;
};

#endif //DC_DEBUG
#endif //_mallocdbgdlg_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\olecli.h ===
//
// olecli.h: Ole Client Site
//
// Copyright Microsoft Corportation 2000
// (nadima)
//

#ifndef _olecli_h_
#define _olecli_h_

#include "ocidl.h"

/*--------------------------------------------------------------------------*/
/*                    The IOleClientSite Class                              */
/*--------------------------------------------------------------------------*/
class COleClientSite : public IOleClientSite
{
public:
	// constructor and destructor
	COleClientSite(IUnknown *pUnkOuter);
	~COleClientSite();

	// IUnknown methods
	STDMETHODIMP QueryInterface(THIS_ REFIID riid, LPVOID *ppvObj);
	STDMETHODIMP_(ULONG) AddRef(THIS);
	STDMETHODIMP_(ULONG) Release(THIS);

	// IOleClientSite methods
	STDMETHODIMP SaveObject(THIS);
	STDMETHODIMP GetMoniker(THIS_ DWORD dwAssign, DWORD dwWhichMoniker, IMoniker ** ppmk);
	STDMETHODIMP GetContainer(THIS_ LPOLECONTAINER FAR* ppContainer);
	STDMETHODIMP ShowObject(THIS);
	STDMETHODIMP OnShowWindow(THIS_ BOOL fShow);
	STDMETHODIMP RequestNewObjectLayout(THIS);


private:
	int			m_cRef;			// Reference count
	IUnknown	*m_pUnkOuter;	// pointer to main container class
};

/*--------------------------------------------------------------------------*/
/*                   The IOleInPlaceSiteEx Class                            */
/*--------------------------------------------------------------------------*/

class COleInPlaceSiteEx : public IOleInPlaceSiteEx
{
public:
	// constructor and destructor
	COleInPlaceSiteEx(IUnknown *pUnkOuter);
	~COleInPlaceSiteEx();

	// IUnknown methods
	STDMETHODIMP QueryInterface(THIS_ REFIID riid, LPVOID *ppvObj);
	STDMETHODIMP_(ULONG) AddRef(THIS);
	STDMETHODIMP_(ULONG) Release(THIS);

	STDMETHODIMP_(VOID)	SetHwnd(THIS_ HWND hwnd);

	// IOleWindow methods
	STDMETHODIMP GetWindow(THIS_ HWND *pHwnd);
	STDMETHODIMP ContextSensitiveHelp(THIS_ BOOL fEnterMode);

	// IOleInPlaceSite methods
	STDMETHODIMP CanInPlaceActivate(THIS);
	STDMETHODIMP OnInPlaceActivate(THIS);
	STDMETHODIMP OnUIActivate(THIS);
	STDMETHODIMP GetWindowContext(THIS_ IOleInPlaceFrame **ppFrame,
                                  IOleInPlaceUIWindow **ppDoc,
								  LPRECT lprcPosRect,
                                  LPRECT lprcClipRect,
                                  LPOLEINPLACEFRAMEINFO lpFrameInfo);
	STDMETHODIMP Scroll(THIS_ SIZE scrollExtent);
	STDMETHODIMP OnUIDeactivate(THIS_ BOOL fUndoable);
	STDMETHODIMP OnInPlaceDeactivate(THIS);
	STDMETHODIMP DiscardUndoState(THIS);
	STDMETHODIMP DeactivateAndUndo(THIS);
	STDMETHODIMP OnPosRectChange(THIS_ LPCRECT lprcPosRect);

	// IOleInPlaceSiteEx methods
	STDMETHODIMP OnInPlaceActivateEx(THIS_ BOOL *pfNoRedraw, DWORD dwFlags);
	STDMETHODIMP OnInPlaceDeactivateEx(THIS_ BOOL fNoRedraw);
	STDMETHODIMP RequestUIActivate(THIS);

private:
	int			m_cRef;			// Reference count
	IUnknown	*m_pUnkOuter;	// pointer to main container class
	HWND		m_hwnd;			// hwnd to use for GetWindow method
};


#endif //_olecli_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\olecli.cpp ===
//
// olecli.cpp: Ole Client site
//             (For ts activeX control)
//
// Copyright Microsoft Corportation 2000
// (nadima)
//

#include "stdafx.h"

#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "olecli.cpp"
#include <atrcapi.h>

#include "olecli.h"

/*--------------------------------------------------------------------------*/
/* 
 * COleClientSite::COleClientSite
 * COleClientSite::~COleClientSite 
 * 
 * Constructor Parameters: 
 *  IUnknown to main container interface 
 */ 

COleClientSite::COleClientSite(IUnknown *pUnkOuter)
{
    m_cRef = 0;
    m_pUnkOuter = pUnkOuter;
    m_pUnkOuter->AddRef();
}

COleClientSite::~COleClientSite()
{
    m_pUnkOuter->Release();
    return;
}

/*--------------------------------------------------------------------------*/
/* 
 * COleClientSite::QueryInterface 
 * COleClientSite::AddRef 
 * COleClientSite::Release 
 */ 
STDMETHODIMP COleClientSite::QueryInterface( REFIID riid, void ** ppv )
{
    return m_pUnkOuter->QueryInterface(riid, ppv);
}


STDMETHODIMP_(ULONG) COleClientSite::AddRef(void)
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) COleClientSite::Release(void)
{
    if (0L != --m_cRef)
        return m_cRef;

    delete this;
    return 0L;
} 

/*--------------------------------------------------------------------------*/
/* 
 * COleClientSite::SaveObject
 * COleClientSite::GetMoniker
 * COleClientSite::GetContainer
 * COleClientSite::ShowObject
 * COleClientSite::OnShowWindow
 * COleClientSite::RequestNewObjectLayout
 */ 
STDMETHODIMP COleClientSite::SaveObject(void)
{
    return NOERROR;
}

STDMETHODIMP COleClientSite::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker,
                                        IMoniker ** ppmk)
{
    *ppmk = NULL;
    return ResultFromScode(E_NOTIMPL);
}

STDMETHODIMP COleClientSite::GetContainer(LPOLECONTAINER FAR* ppContainer)
{
    *ppContainer = NULL;
    return ResultFromScode(E_NOTIMPL);
}

STDMETHODIMP COleClientSite::ShowObject(void)
{
    return NOERROR;
}
STDMETHODIMP COleClientSite::OnShowWindow(BOOL fShow)
{
    return NOERROR;
}

STDMETHODIMP COleClientSite::RequestNewObjectLayout(void)
{
    return ResultFromScode(E_NOTIMPL);
}

/*--------------------------------------------------------------------------*/
/* 
 * COleInPlaceSiteEx::COleInPlaceSiteEx
 * COleInPlaceSiteEx::~COleInPlaceSiteEx 
 * 
 * Constructor Parameters: 
 *  IUnknown to main container interface 
 */ 

COleInPlaceSiteEx::COleInPlaceSiteEx(IUnknown *pUnkOuter)
{
    m_cRef = 0;
    m_pUnkOuter = pUnkOuter;
    m_pUnkOuter->AddRef();
    m_hwnd = NULL;
}

COleInPlaceSiteEx::~COleInPlaceSiteEx()
{
    m_pUnkOuter->Release();
    return;
}

/*--------------------------------------------------------------------------*/
/* 
 * COleInPlaceSiteEx::QueryInterface 
 * COleInPlaceSiteEx::AddRef 
 * COleInPlaceSiteEx::Release 
 */ 
STDMETHODIMP COleInPlaceSiteEx::QueryInterface( REFIID riid, void ** ppv )
{
    return m_pUnkOuter->QueryInterface(riid, ppv);
}


STDMETHODIMP_(ULONG) COleInPlaceSiteEx::AddRef(void)
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) COleInPlaceSiteEx::Release(void)
{
    if (0L != --m_cRef)
        return m_cRef;

    delete this;
    return 0L;
} 

/*--------------------------------------------------------------------------*/
/* 
 * COleInPlaceSiteEx::SetHwnd
 */
STDMETHODIMP_(VOID) COleInPlaceSiteEx::SetHwnd(HWND hwnd)
{
    m_hwnd = hwnd;
}

/*--------------------------------------------------------------------------*/
/* 
 * COleInPlaceSiteEx::GetWindow
 * COleInPlaceSiteEx::ContextSensitiveHelp
 * COleInPlaceSiteEx::CanInPlaceActivate
 * COleInPlaceSiteEx::OnInPlaceActivate
 * COleInPlaceSiteEx::OnUIActivate
 * COleInPlaceSiteEx::GetWindowContext
 * COleInPlaceSiteEx::Scroll
 * COleInPlaceSiteEx::OnUIDeactivate
 * COleInPlaceSiteEx::OnInPlaceDeactivate
 * COleInPlaceSiteEx::DiscardUndoState
 * COleInPlaceSiteEx::DeactivateAndUndo
 * COleInPlaceSiteEx::OnPosRectChange
 * COleInPlaceSiteEx::OnInPlaceActivateEx
 * COleInPlaceSiteEx::OnInPlaceDeactivateEx
 * COleInPlaceSiteEx::RequestUIActivate
 */ 
STDMETHODIMP COleInPlaceSiteEx::GetWindow(HWND *pHwnd)
{
    DC_BEGIN_FN("GetWindow");
    TRC_ASSERT(m_hwnd != NULL,
          (TB,_T("Somebody called GetWindow before set the Hwnd in InPlaceSite")));
    *pHwnd = m_hwnd;
    DC_END_FN();
    return NOERROR;
}

STDMETHODIMP COleInPlaceSiteEx::ContextSensitiveHelp (BOOL fEnterMode)
{
    return NOERROR;
}

STDMETHODIMP COleInPlaceSiteEx::CanInPlaceActivate (void)
{
    return NOERROR;
}

STDMETHODIMP COleInPlaceSiteEx::OnInPlaceActivate (void)
{
    return NOERROR;
}

STDMETHODIMP COleInPlaceSiteEx::OnUIActivate (void)
{
    return NOERROR;
}

STDMETHODIMP COleInPlaceSiteEx::GetWindowContext (IOleInPlaceFrame **ppFrame,
                                                  IOleInPlaceUIWindow **ppDoc,
                                                  LPRECT lprcPosRect,
                                                  LPRECT lprcClipRect,
                                                  LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    DC_BEGIN_FN("GetWindowContext");
    TRC_ASSERT(lprcPosRect,(TB,_T("lprcPosRect is null")));
    TRC_ASSERT(lprcClipRect,(TB,_T("lprcClipRect is null")));

    *ppFrame = NULL;
    *ppDoc = NULL;
    RECT rc;
    if(GetClientRect(m_hwnd, &rc))
    {
        int x = rc.right - rc.left;
        int y = rc.bottom - rc.top;
        SetRect(lprcClipRect, 0, 0, x, y);
        SetRect(lprcPosRect, 0, 0, x, y);
    }
    else
    {
        TRC_ERR((TB,_T("GetClientRect returned error:%d"),GetLastError()));
    }
#ifndef OS_WINCE
    lpFrameInfo = NULL;
#else
	//ATL tries to destroy the accelerator table pointed to by lpFrameInfo->hAccel
    TRC_ASSERT(lpFrameInfo,(TB,_T("lpFrameInfo is null")));
    lpFrameInfo->haccel = NULL;
#endif

    DC_END_FN();
    return NOERROR;
}

STDMETHODIMP COleInPlaceSiteEx::Scroll (SIZE scrollExtent)
{
    return NOERROR;
}

STDMETHODIMP COleInPlaceSiteEx::OnUIDeactivate (BOOL fUndoable)
{
    return NOERROR;
}

STDMETHODIMP COleInPlaceSiteEx::OnInPlaceDeactivate (void)
{
    return NOERROR;
}

STDMETHODIMP COleInPlaceSiteEx::DiscardUndoState (void)
{
    return NOERROR;
}

STDMETHODIMP COleInPlaceSiteEx::DeactivateAndUndo (void)
{
    return NOERROR;
}

STDMETHODIMP COleInPlaceSiteEx::OnPosRectChange (LPCRECT lprcPosRect)
{
    return NOERROR;
}

STDMETHODIMP COleInPlaceSiteEx::OnInPlaceActivateEx (BOOL *pfNoRedraw, DWORD dwFlags)
{
    *pfNoRedraw = TRUE;

    return NOERROR;
}

STDMETHODIMP COleInPlaceSiteEx::OnInPlaceDeactivateEx (BOOL fNoRedraw)
{
    return NOERROR;
}

STDMETHODIMP COleInPlaceSiteEx::RequestUIActivate (void)
{
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\maindlg.h ===
//
// maindlg.h: main dialog box
//              gathers connection info and hosts tabs
//
// Copyright Microsoft Corportation 2000
// (nadima)
//

#ifndef _maindlg_h_
#define _maindlg_h_

#include "dlgbase.h"
#include "sh.h"
#include "tscsetting.h"
#include "contwnd.h"
#include "progband.h"

#define OPTIONS_STRING_MAX_LEN  64

//
// Dialog expand/contract amount in dlus
// compute this val is the vertical delta in dlus
// between the two valid heights of the main dialog
//
#define LOGON_DLG_EXPAND_AMOUNT 177

#ifdef OS_WINCE
#define LOGON_DLG_EXPAND_AMOUNT_VGA 65
#endif

#define NUM_TABS                5

#define TAB_GENERAL_IDX             0
#define TAB_DISPLAY_IDX             1
#define TAB_LOCAL_RESOURCES_IDX     2

typedef struct tag_TABDLGINFO
{
    HWND hwndCurPropPage;
    DLGTEMPLATE *pdlgTmpl[NUM_TABS];
    DLGPROC     pDlgProc[NUM_TABS];
} TABDLGINFO, *PTABDLGINFO;

class CPropGeneral;
class CPropLocalRes;
class CPropDisplay;
class CPropRun;
class CPropPerf;


class CMainDlg : public CDlgBase
{
    typedef enum 
    {
        stateNotConnected = 0x0,
        stateConnecting   = 0x1,
        stateConnected    = 0x2
    } mainDlgConnectionState;

public:
    CMainDlg(HWND hwndOwner, HINSTANCE hInst, CSH* pSh,
             CContainerWnd* pContainerWnd,
             CTscSettings*  pTscSettings,
             BOOL           fStartExpanded=FALSE,
             INT            nStartTab = 0);
    ~CMainDlg();

    virtual HWND StartModeless();
    virtual INT_PTR CALLBACK DialogBoxProc(HWND hwndDlg,
                                           UINT uMsg,
                                           WPARAM wParam,
                                           LPARAM lParam);
    static  INT_PTR CALLBACK StaticDialogBoxProc(HWND hwndDlg,
                                                 UINT uMsg,
                                                 WPARAM wParam,
                                                 LPARAM lParam);
    static  CMainDlg* _pMainDlgInstance;

private:
    //
    // Private member functions
    //
    void DlgToSettings();
    void SettingsToDlg();
    HBITMAP LoadBitmapGetSize(HINSTANCE hInstance, UINT resid, SIZE* pSize);
    BOOL    PaintBrandImage(HWND hwnd, HDC hdc, INT bgColor);

    VOID    SetConnectionState(mainDlgConnectionState newState);

    BOOL    OnStartConnection();
    BOOL    OnEndConnection(BOOL fConnected);

#ifndef OS_WINCE
    BOOL    PaintBrandingText(HBITMAP hbmBrandImage);
#endif


    VOID    PropagateMsgToChildren(HWND hwndDlg,
                                   UINT uMsg,
                                   WPARAM wParam,
                                   LPARAM lParam);

    //
    // Font related helpers
    //
    void    SetFontFaceFromResource(PLOGFONT plf, UINT idFaceName);
    void    SetFontSizeFromResource(PLOGFONT plf, UINT idSizeName);

#ifndef OS_WINCE
    HFONT   LoadFontFromResourceInfo(UINT idFace, UINT idSize, BOOL fBold);
    BOOL    InitializeBmps();
    BOOL    BrandingQueryNewPalette(HWND hDlg);
    BOOL    BrandingPaletteChanged(HWND hDlg, HWND hWndPalChg);
#endif

    BOOL    InitializePerfStrings();

protected:
    //
    // Protected member functions
    //
    void ToggleExpandedState();
    BOOL InitTabs();
    BOOL OnTabSelChange();

#ifndef OS_WINCE
    void SetupDialogSysMenu();
#endif

    void SaveDialogStartupInfo();


private:
    CSH* _pSh;
    CTscSettings*  _pTscSettings;
    //
    // Container window (parent of this dialog)
    //
    CContainerWnd* _pContainerWnd;

    //
    // Dialog is 'expanded' version
    //
    BOOL           _fShowExpanded;

    TCHAR          _szOptionsMore[OPTIONS_STRING_MAX_LEN];
    TCHAR          _szOptionsLess[OPTIONS_STRING_MAX_LEN];

    //
    // In 256 color and lower mode we use 'low color' bitmaps
    // for palette issues (and bandwidth reduction for nested clients)
    //
    BOOL           _fUse16ColorBitmaps;

    //
    // Screen depth the images are valid for
    //
    UINT           _lastValidBpp;

    //
    // Tab control bounds
    //
    RECT           _rcTab;
    TABDLGINFO     _tabDlgInfo;

    //
    // Progress band
    //
    INT            _nBrandImageHeight;
    INT            _nBrandImageWidth;

    TCHAR          _szCloseText[128];
    TCHAR          _szCancelText[128];

    BOOL           _fStartExpanded;
    //
    // Tab to start on
    //
    INT            _nStartTab;

    //
    // Brand img
    //
    HBITMAP        _hBrandImg;
    HPALETTE       _hBrandPal;

    //
    // Current connection state
    //
    mainDlgConnectionState _connectionState;

    //
    // Control to restore the focus to since we force
    // it to the cancel button during connection
    //
    HWND           _hwndRestoreFocus;

#ifdef OS_WINCE
    BOOL            _fVgaDisplay;
#endif

private:
    //
    // Property pages
    //
    CPropGeneral*   _pGeneralPg;
    CPropDisplay*   _pPropDisplayPg;
    CPropLocalRes*  _pLocalResPg;
    CPropRun*       _pRunPg;
    CPropPerf*      _pPerfPg;

    //
    // Progress band
    //
    CProgressBand*  _pProgBand;
};

#endif // _maindlg_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\propdisplay.cpp ===
//
// propdisplay.cpp: display property sheet dialog proc
//
// Tab B
//
// Copyright Microsoft Corporation 2000
// nadima

#include "stdafx.h"


#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "propdisplay"
#include <atrcapi.h>

#include "sh.h"

#include "commctrl.h"
#include "propdisplay.h"


COLORSTRINGMAP g_ColorStringTable[] =
{
    {8,  UI_IDS_COLOR_256,   UI_IDB_COLOR8, UI_IDB_COLOR8_DITHER, TEXT("")},
#ifndef OS_WINCE
    {15, UI_IDS_COLOR_15bpp, UI_IDB_COLOR16, UI_IDB_COLOR8_DITHER, TEXT("")},
#endif
    {16, UI_IDS_COLOR_16bpp, UI_IDB_COLOR16, UI_IDB_COLOR8_DITHER, TEXT("")},
    {24, UI_IDS_COLOR_24bpp, UI_IDB_COLOR24, UI_IDB_COLOR8_DITHER, TEXT("")}
};

#define NUM_COLORSTRINGS sizeof(g_ColorStringTable)/sizeof(COLORSTRINGMAP)

//
// LUT of valid screen resolutions
//
const SCREENRES g_ScreenResolutions[] =
{
    {640,480},
    {800,600},
    {1024,768},
    {1152,864},
    {1280,1024},
    {1600,1200}
};
#define NUM_SCREENRES sizeof(g_ScreenResolutions)/sizeof(SCREENRES)


//
// Controls that need to be disabled/enabled
// during connection (for progress animation)
//
CTL_ENABLE connectingDisableCtlsPDisplay[] = {
#ifndef OS_WINCE
                        {IDC_RES_SLIDER, FALSE},
#endif
                        {IDC_CHECK_DISPLAY_BBAR, FALSE},
                        {IDC_COMBO_COLOR_DEPTH, FALSE}
                        };

const UINT numConnectingDisableCtlsPDisplay =
                        sizeof(connectingDisableCtlsPDisplay)/
                        sizeof(connectingDisableCtlsPDisplay[0]);


CPropDisplay* CPropDisplay::_pPropDisplayInstance = NULL;

CPropDisplay::CPropDisplay(HINSTANCE hInstance, CTscSettings* pTscSet, CSH* pSh)
{
    DC_BEGIN_FN("CPropDisplay");
    _hInstance = hInstance;
    CPropDisplay::_pPropDisplayInstance = this;
    _pTscSet = pTscSet;
    _pSh = pSh;

    TRC_ASSERT(_pTscSet,(TB,_T("_pTscSet is null")));
    TRC_ASSERT(_pSh,(TB,_T("_pSh is null")));

    if(!LoadDisplayourcesPgStrings())
    {
        TRC_ERR((TB, _T("Failed LoadDisplayourcesPgStrings()")));
    }
    _fSwitchedColorComboBmp = FALSE;

    DC_END_FN();
}

CPropDisplay::~CPropDisplay()
{
    CPropDisplay::_pPropDisplayInstance = NULL;
}

INT_PTR CALLBACK CPropDisplay::StaticPropPgDisplayDialogProc(HWND hwndDlg,
                                                               UINT uMsg,
                                                               WPARAM wParam,
                                                               LPARAM lParam)
{
    //
    // Delegate to appropriate instance (only works for single instance dialogs)
    //
    DC_BEGIN_FN("StaticDialogBoxProc");
    DCINT retVal = 0;

    TRC_ASSERT(_pPropDisplayInstance, (TB, _T("Display dialog has NULL static instance ptr\n")));
    retVal = _pPropDisplayInstance->PropPgDisplayDialogProc( hwndDlg,
                                                               uMsg,
                                                               wParam,
                                                               lParam);

    DC_END_FN();
    return retVal;
}


INT_PTR CALLBACK CPropDisplay::PropPgDisplayDialogProc (HWND hwndDlg,
                                                          UINT uMsg,
                                                          WPARAM wParam,
                                                          LPARAM lParam)
{
    DC_BEGIN_FN("PropPgDisplayDialogProc");

    switch(uMsg)
    {
        case WM_INITDIALOG:
        {
#ifndef OS_WINCE
            int i;
#endif
            //
            // Position the dialog within the tab
            //
            SetWindowPos( hwndDlg, HWND_TOP, 
                          _rcTabDispayArea.left, _rcTabDispayArea.top,
                          _rcTabDispayArea.right - _rcTabDispayArea.left,
                          _rcTabDispayArea.bottom - _rcTabDispayArea.top,
                          0);

            _fSwitchedColorComboBmp = FALSE;

            //
            // Fill the color combo up to the current
            // supported screen depth
            //
            InitColorCombo(hwndDlg);

            InitScreenResTable();
            
#ifndef OS_WINCE            
            HWND hwndResTrackBar = GetDlgItem( hwndDlg, IDC_RES_SLIDER);
            if(!hwndResTrackBar)
            {
                return FALSE;
            }
            SendMessage(hwndResTrackBar, TBM_SETRANGE,
                        (WPARAM) TRUE,
                        (LPARAM) MAKELONG(0, _numScreenResOptions-1));

            SendMessage(hwndResTrackBar, TBM_SETPAGESIZE,
                        (WPARAM) 0,
                        (LPARAM) 1);

            //
            // Choose the current entry on the trackbar
            //
            int deskWidth  = _pTscSet->GetDesktopWidth();
            int deskHeight = _pTscSet->GetDesktopHeight();

            int curSelection = 0;

            if(_pTscSet->GetStartFullScreen())
            {
                //Fullscreen is the last option
                curSelection = _numScreenResOptions - 1;
            }
            else
            {
                for(i=0; i<_numScreenResOptions; i++)
                {
                    if(deskWidth  == _screenResTable[i].width &&
                       deskHeight == _screenResTable[i].height)
                    {
                        curSelection = i;
                        break;
                    }
                }
            }

            SendMessage(hwndResTrackBar, TBM_SETSEL,
                        (WPARAM) TRUE, //redraw
                        (LPARAM) 0);

            SendMessage(hwndResTrackBar, TBM_SETPOS,
                        (WPARAM) TRUE, //redraw
                        (LPARAM) curSelection);

            OnUpdateResTrackBar(hwndDlg);
#endif
            CheckDlgButton(hwndDlg, IDC_CHECK_DISPLAY_BBAR,
                           _pTscSet->GetDisplayBBar() ?
                           BST_CHECKED : BST_UNCHECKED);


            OnUpdateColorCombo(hwndDlg);

            _pSh->SH_ThemeDialogWindow(hwndDlg, ETDT_ENABLETAB);
            return TRUE;
        }
        break; //WM_INITDIALOG

#ifndef OS_WINCE
        case WM_DISPLAYCHANGE:
        {
            OnUpdateResTrackBar(hwndDlg);
            OnUpdateColorCombo(hwndDlg);
        }
        break;

        case WM_HSCROLL:
        {
            OnUpdateResTrackBar(hwndDlg);
        }
        break; //WM_HSCROLL
#endif

        case WM_TSC_ENABLECONTROLS:
        {
            //
            // wParam is TRUE to enable controls,
            // FALSE to disable them
            //
            CSH::EnableControls( hwndDlg,
                                 connectingDisableCtlsPDisplay,
                                 numConnectingDisableCtlsPDisplay,
                                 wParam ? TRUE : FALSE);
        }
        break;

        //
        // On return to connection UI
        // (e.g after a disconnection)
        //
        case WM_TSC_RETURNTOCONUI:
        {
            //
            // Update the controls
            //
#ifndef OS_WINCE
            OnUpdateResTrackBar(hwndDlg);
#endif
            OnUpdateColorCombo(hwndDlg);
        }
        break;

        case WM_SAVEPROPSHEET: //Intentional fallthru
        case WM_DESTROY:
        {
            //
            // Save page settings
            //
#ifndef OS_WINCE
            HWND hwndResTrackBar = GetDlgItem( hwndDlg, IDC_RES_SLIDER);
            int maxRes = (int)SendMessage( hwndResTrackBar,
                                           TBM_GETRANGEMAX,
                                           TRUE, 0);
            int iRes = (int)SendMessage( hwndResTrackBar, TBM_GETPOS, 0, 0);
#else
            int iRes = _numScreenResOptions - 1;
            int maxRes = iRes;
#endif
            int bppIdx = (int)SendMessage(
                GetDlgItem(hwndDlg,IDC_COMBO_COLOR_DEPTH),
                CB_GETCURSEL, 0, 0);
            _pTscSet->SetColorDepth(g_ColorStringTable[bppIdx].bpp);

            //rightmost setting, display 'fullscreen'
            _pTscSet->SetStartFullScreen(iRes == maxRes);
            _pTscSet->SetDesktopWidth(_screenResTable[iRes].width);
            _pTscSet->SetDesktopHeight(_screenResTable[iRes].height);

            BOOL fShowBBar = IsDlgButtonChecked(hwndDlg,
                                                IDC_CHECK_DISPLAY_BBAR);
            _pTscSet->SetDisplayBBar(fShowBBar);

            //
            // Flag that we've switched this to allow
            // proper cleanup on dialog termination
            //
            if (_fSwitchedColorComboBmp)
            {
                HBITMAP hbmOld = (HBITMAP) SendDlgItemMessage(hwndDlg, 
                                                      IDC_COLORPREVIEW, STM_GETIMAGE,
                                                      IMAGE_BITMAP, (LPARAM)0);
                //
                // Cleanup
                //
                if (hbmOld)
                {
                    DeleteObject(hbmOld);
                }
            }
        }
        break; //WM_DESTROY

        case WM_COMMAND:
        {
            switch(LOWORD(wParam))
            {
                case IDC_COMBO_COLOR_DEPTH:
                {
                    if(HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        OnUpdateColorCombo( hwndDlg);
                    }
                }
                break;

            }
        }
        break; //WM_COMMAND
    
    }

    DC_END_FN();
    return 0;
}

//
// Load resources for the local resources dialog
//
BOOL CPropDisplay::LoadDisplayourcesPgStrings()
{
    DC_BEGIN_FN("LoadDisplayourcesPgStrings");

    //
    // Load color strings
    //
    for(int i = 0; i< NUM_COLORSTRINGS; i++)
    {
        if (!LoadString( _hInstance,
                 g_ColorStringTable[i].resID,
                 g_ColorStringTable[i].szString,
                 COLOR_STRING_MAXLEN ))
        {
            TRC_ERR((TB, _T("Failed to load color string %d"),
                     g_ColorStringTable[i].resID));
            return FALSE;
        }
    }

    //
    // Load display resolution strings
    //
    if (!LoadString( _hInstance,
                    UI_IDS_SUPPORTED_RES,
                    _szScreenRes,
                    SH_SHORT_STRING_MAX_LENGTH))
    {
        TRC_ERR((TB, _T("Failed to load UI_IDS_SUPPORTED_RES")));
        return FALSE;
    }

    if (!LoadString(_hInstance,
                    UI_IDS_FULLSCREEN,
                    _szFullScreen,
                    SH_SHORT_STRING_MAX_LENGTH))
    {
        TRC_ERR((TB, _T("Failed to load UI_IDS_FULLSCREEN")));
        return FALSE;
    }


    DC_END_FN();
    return TRUE;
}

#ifndef OS_WINCE
BOOL CPropDisplay::OnUpdateResTrackBar(HWND hwndPropPage)
{
    DC_BEGIN_FN("OnUpdateResTrackBar");

    HWND hwndResTrackBar = GetDlgItem( hwndPropPage, IDC_RES_SLIDER);
    int maxRes = (int)SendMessage( hwndResTrackBar, TBM_GETRANGEMAX, TRUE, 0);
    int iRes = (int)SendMessage( hwndResTrackBar, TBM_GETPOS, 0, 0);

    if(iRes == maxRes)
    {
        //rightmost setting, display 'fullscreen'
        SetDlgItemText( hwndPropPage, IDC_LABEL_SCREENRES,
                        _szFullScreen);
    }
    else
    {
        LPTSTR szResString = NULL;
        TRC_ASSERT( iRes < NUM_SCREENRES,
                    (TB,_T("Track bar gives out of range screen res:%d"),
                     iRes));
        if(iRes < NUM_SCREENRES)
        {
            INT res[2];
            res[0] = _screenResTable[iRes].width;
            res[1] = _screenResTable[iRes].height;

            szResString = CSH::FormatMessageVArgs(_szScreenRes,
                                                  res[0],
                                                  res[1] );
            if (szResString)
            {
                SetDlgItemText( hwndPropPage, IDC_LABEL_SCREENRES,
                               szResString);
                LocalFree(szResString);
                szResString = NULL;
            }
            else
            {
                TRC_ERR((TB,_T("FormatMessage failed 0x%x"),
                         GetLastError()));
            }
        }
    }

    DC_END_FN();
    return TRUE;
}
#endif

BOOL CPropDisplay::OnUpdateColorCombo(HWND hwndPropPage)
{
    //
    // Update the color picker
    //
    HWND hwndColorCombo = GetDlgItem( hwndPropPage, IDC_COMBO_COLOR_DEPTH);
    int curColorSel = SendMessage( (HWND)hwndColorCombo, CB_GETCURSEL, 0, 0);
    UINT screenBpp = 0;
    if(curColorSel >= 0 && curColorSel < NUM_COLORSTRINGS)
    {
        int bmpResID = g_ColorStringTable[curColorSel].bitmapResID;

        HBITMAP hbm = NULL;
        screenBpp = CSH::SH_GetScreenBpp();
        if(screenBpp <= 8)
        {
            //
            // Low color
            //
            bmpResID = g_ColorStringTable[curColorSel].bitmapLowColorResID;
        }

#ifdef OS_WINCE
        hbm = (HBITMAP)LoadImage(_hInstance,
            MAKEINTRESOURCE(bmpResID),
            IMAGE_BITMAP,
            0, 0, 0);
#else
        hbm = (HBITMAP)LoadImage(_hInstance,
            MAKEINTRESOURCE(bmpResID),
            IMAGE_BITMAP,
            0, 0, LR_CREATEDIBSECTION);
#endif

        if (hbm)
        {
            HBITMAP hbmOld = (HBITMAP) SendDlgItemMessage(hwndPropPage, 
                                                  IDC_COLORPREVIEW, STM_SETIMAGE,
                                                  IMAGE_BITMAP, (LPARAM)hbm);
            //
            // Flag that we've switched this to allow
            // proper cleanup on dialog termination
            //
            _fSwitchedColorComboBmp = TRUE;

            if (hbmOld)
            {
                DeleteObject(hbmOld);
            }
        }
    }
    return TRUE;
}

//
// Build the table of valid screen size settings
// The table (_screenResTable) is the union of:
//     - entries of g_ScreenResolutions up to and including max resolution
//     - the system max resolution (if not present in g_ScreenResolutions)
//     - a fullscreen entry (max resolution in fullscreen)
//
void CPropDisplay::InitScreenResTable()
{
    DC_BEGIN_FN("InitScreenResTable");

    RECT rcMaxScreen;
    _numScreenResOptions = 0;
    int xMaxSize = 0;
    int yMaxSize = 0;

    if (CSH::GetLargestMonitorRect(&rcMaxScreen))
    {
        xMaxSize = rcMaxScreen.right - rcMaxScreen.left;
        yMaxSize = rcMaxScreen.bottom - rcMaxScreen.top;
    }
    else
    {
        xMaxSize = GetSystemMetrics(SM_CXSCREEN);
        yMaxSize = GetSystemMetrics(SM_CYSCREEN);
    }

    xMaxSize = xMaxSize > MAX_DESKTOP_WIDTH ? MAX_DESKTOP_WIDTH : xMaxSize;
    yMaxSize = yMaxSize > MAX_DESKTOP_HEIGHT ? MAX_DESKTOP_HEIGHT : yMaxSize;
    BOOL bAddedLargest = FALSE;
    for(int i=0; i<NUM_SCREENRES; i++)
    {
        if(g_ScreenResolutions[i].width  > xMaxSize ||
           g_ScreenResolutions[i].height > yMaxSize)
        {
            break;
        }
        else if (g_ScreenResolutions[i].width  == xMaxSize &&
                 g_ScreenResolutions[i].height == yMaxSize)
        {
            bAddedLargest = TRUE;
        }
        
        _screenResTable[i].width = g_ScreenResolutions[i].width;
        _screenResTable[i].height = g_ScreenResolutions[i].height;
        _numScreenResOptions++;
    }

    if(!bAddedLargest)
    {
        //Screen size is not in the table so add it
        _screenResTable[_numScreenResOptions].width  = xMaxSize;
        _screenResTable[_numScreenResOptions].height = yMaxSize;
        _numScreenResOptions++;
    }

    //
    // Now add an entry for fullscreen
    //
    _screenResTable[_numScreenResOptions].width  = xMaxSize;
    _screenResTable[_numScreenResOptions].height = yMaxSize;
    _numScreenResOptions++;

    DC_END_FN();
}

void CPropDisplay::InitColorCombo(HWND hwndPropPage)
{
    DC_BEGIN_FN("InitColorCombo");

    HDC hdc = GetDC(NULL);
    TRC_ASSERT((NULL != hdc), (TB,_T("Failed to get DC")));
    int screenBpp = 8;
    if(hdc)
    {
        screenBpp = GetDeviceCaps(hdc, BITSPIXEL);
        TRC_NRM((TB, _T("HDC %p has %u bpp"), hdc, screenBpp));
        ReleaseDC(NULL, hdc);
    }

    // 
    // We support only 256 color or higher, so on 16 color, we will 
    // display 256 color
    //
    if (screenBpp < 8) {
        screenBpp = 8;
    }

    int selectedBpp = _pTscSet->GetColorDepth();
    int selectedBppIdx = 0;


    //
    // This call can be used to re-intialize a combo
    // so delete any items first
    //
#ifndef OS_WINCE
    INT ret = 1;
    while(ret && ret != CB_ERR)
    {
        ret = SendDlgItemMessage(hwndPropPage,
                                 IDC_COMBO_COLOR_DEPTH,
                                 CBEM_DELETEITEM,
                                 0,0);
    }
#else
    SendDlgItemMessage(hwndPropPage, IDC_COMBO_COLOR_DEPTH, CB_RESETCONTENT, 0, 0);
#endif

    for(int i=0; i<NUM_COLORSTRINGS; i++)
    {
        if(g_ColorStringTable[i].bpp > screenBpp)
        {
            break;
        }
        else
        {
            if(selectedBpp == g_ColorStringTable[i].bpp)
            {
                selectedBppIdx = i;
            }
            SendDlgItemMessage(hwndPropPage,
                IDC_COMBO_COLOR_DEPTH,
                CB_ADDSTRING,
                0,
                (LPARAM)(PDCTCHAR)g_ColorStringTable[i].szString);
        }
    }
    SendDlgItemMessage(hwndPropPage, IDC_COMBO_COLOR_DEPTH,CB_SETCURSEL,
                      (WPARAM)selectedBppIdx,0);
    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\maindlg.cpp ===
//
// maindlg.cpp: main dialog box
//              gathers connection info and hosts tabs
//
// Copyright Microsoft Corportation 2000
// (nadima)
//

#include "stdafx.h"

#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "maindlg.cpp"
#include <atrcapi.h>

#include "maindlg.h"
#include "discodlg.h"
#include "validatedlg.h"
#include "aboutdlg.h"
#include "sh.h"

#include "commctrl.h"

#include "browsedlg.h"
#include "propgeneral.h"
#include "proplocalres.h"
#include "propdisplay.h"
#include "proprun.h"
#include "propperf.h"

//
// Background color to fill padding area after branding img
//
#define IMAGE_BG_COL    RGB(0x29,0x47,0xDA)
// Low color
#define IMAGE_BG_COL_16 RGB(0,0,0xFF)

//
// Controls which need to be moved when dialog
// is resized
//
UINT moveableControls[]  = {IDOK,
                            IDCANCEL,
                            ID_BUTTON_LOGON_HELP,
                            ID_BUTTON_OPTIONS};
UINT numMoveableControls = sizeof(moveableControls)/sizeof(UINT);

//
// Controls that are only visible/enabled on less
//
UINT lessUI[] = { UI_IDC_COMPUTER_NAME_STATIC,
                  IDC_COMBO_SERVERS
                };
UINT numLessUI = sizeof(lessUI)/sizeof(UINT);

//
// Controls that are only visibile/enabled on more
//
UINT moreUI[] = {IDC_TABS};
UINT numMoreUI = sizeof(moreUI)/sizeof(UINT);

//
// Controls that need to be disabled/enabled
// during connection
//
UINT connectingDisableControls[] = {IDOK,
                                    ID_BUTTON_LOGON_HELP,
                                    ID_BUTTON_OPTIONS,
                                    IDC_TABS,
                                    IDC_COMBO_SERVERS,
                                    IDC_COMBO_MAIN_OPTIMIZE,
                                    UI_IDC_COMPUTER_NAME_STATIC,
                                    UI_IDC_MAIN_OPTIMIZE_STATIC};
const UINT numConnectingDisableControls = sizeof(connectingDisableControls) /
                                    sizeof(UINT);

BOOL g_fPropPageStringMapInitialized = FALSE;
PERFOPTIMIZESTRINGMAP g_PerfOptimizeStringTable[] =
{
    {UI_IDS_OPTIMIZE_28K, TEXT("")},
    {UI_IDS_OPTIMIZE_56K, TEXT("")},
    {UI_IDS_OPTIMIZE_BROADBAND, TEXT("")},
    {UI_IDS_OPTIMIZE_LAN, TEXT("")},
    {UI_IDS_OPTIMIZE_MAIN_CUSTOM, TEXT("")},
    {UI_IDS_OPTIMIZE_CUSTOM, TEXT("")}
};

#define NUM_PERFSTRINGS sizeof(g_PerfOptimizeStringTable) / \
                        sizeof(PERFOPTIMIZESTRINGMAP)


CMainDlg* CMainDlg::_pMainDlgInstance = NULL;

//
// UNIWRAP WARNING ~*~*~*~*~*~*~*~*~*~*~*~*~*~~*~*~*~*~*~*~*~*~**~*~*~
// TabControl messages need to be wrapped in the SendMessageThunk
// in uniwrap so the tab control works on 9x with an ANSI comctl32.dll.
//
// If you add anything to the tab control code, make sure it is
// handled by the wrapper.
//
//

CMainDlg::CMainDlg( HWND hwndOwner, HINSTANCE hInst, CSH* pSh,
                    CContainerWnd* pContainerWnd,
                    CTscSettings*  pTscSettings,
                    BOOL           fStartExpanded,
                    INT            nStartTab) :
                    CDlgBase( hwndOwner, hInst, UI_IDD_TS_LOGON),
                    _pSh(pSh),
                    _pContainerWnd(pContainerWnd),
                    _pTscSettings(pTscSettings),
                    _fStartExpanded(fStartExpanded),
                    _nStartTab(nStartTab)
{
    DC_BEGIN_FN("CMainDlg");
    TRC_ASSERT((NULL == CMainDlg::_pMainDlgInstance), 
               (TB,_T("Clobbering existing dlg instance pointer\n")));

    TRC_ASSERT((_pSh), 
               (TB,_T("CMainDlg was passed null _pSh\n")));

    TRC_ASSERT(pContainerWnd,
               (TB, _T("Null container wnd pointer\n")));

    TRC_ASSERT(_pTscSettings,
               (TB, _T("NULL _pTscSettings pointer\n")));


    CMainDlg::_pMainDlgInstance = this;
    _fShowExpanded = FALSE;

    _pGeneralPg     = NULL;
    _pLocalResPg    = NULL;
    _pPropDisplayPg = NULL;
    _pRunPg         = NULL;
    _pPerfPg    = NULL;
    _nBrandImageHeight = 0;
    _nBrandImageWidth  = 0;
    _lastValidBpp = 0;
    _hBrandPal = NULL;
    _hBrandImg = NULL;
    _hwndRestoreFocus = NULL;
#ifndef OS_WINCE
    _pProgBand = NULL;
#endif

    _connectionState = stateNotConnected;

#ifdef OS_WINCE
    _fVgaDisplay = (GetSystemMetrics(SM_CYSCREEN) < 480);
    //use a small dialog template if we are running in a smaller screen 
    if (_fVgaDisplay)
    {
        _dlgResId = UI_IDD_TS_LOGON_VGA;
    }
#endif

    InitializePerfStrings();

    DC_END_FN();
}

CMainDlg::~CMainDlg()
{
    CMainDlg::_pMainDlgInstance = NULL;

    delete _pGeneralPg;
    delete _pLocalResPg;
    delete _pPropDisplayPg;
    delete _pRunPg;
    delete _pPerfPg;

#ifndef OS_WINCE
    if (_pProgBand) {
        delete _pProgBand;
    }
#endif
}

HWND CMainDlg::StartModeless()
{
    DC_BEGIN_FN("StartModeless");

#ifdef OS_WINCE

    INITCOMMONCONTROLSEX cex;

    cex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    cex.dwICC  = ICC_TAB_CLASSES;

    if(!InitCommonControlsEx( &cex ))
    {
        TRC_ABORT((TB,_T("InitCommonControlsEx failed 0x%x"),
                   GetLastError()));
    }

#endif

    _hwndDlg = CreateDialog(_hInstance, MAKEINTRESOURCE(_dlgResId),
                       _hwndOwner, StaticDialogBoxProc);

    TRC_ASSERT(_hwndDlg, (TB,_T("CreateDialog failed")));

    DC_END_FN();
    return _hwndDlg;
}


INT_PTR CALLBACK CMainDlg::StaticDialogBoxProc (HWND hwndDlg,
                                                UINT uMsg,
                                                WPARAM wParam,
                                                LPARAM lParam)
{
    //
    // Delegate to appropriate instance (only works for single instance dialogs)
    //
    DC_BEGIN_FN("StaticDialogBoxProc");
    DCINT retVal = 0;

    TRC_ASSERT(_pMainDlgInstance, (TB, _T("Logon dialog has NULL static instance ptr\n")));
    if(_pMainDlgInstance)
    {
        retVal = _pMainDlgInstance->DialogBoxProc( hwndDlg, uMsg, wParam, lParam);
    }

    DC_END_FN();
    return retVal;
}

//
// Name: DialogBoxProc
//
// Purpose: Handles Main dialog
//
// Returns: TRUE if message dealt with
//          FALSE otherwise
//
// Params: See window documentation
//
//
INT_PTR CALLBACK CMainDlg::DialogBoxProc (HWND hwndDlg,
                                          UINT uMsg,
                                          WPARAM wParam,
                                          LPARAM lParam)
{
    INT_PTR rc = FALSE;
#ifndef OS_WINCE
    DCUINT  intRC ;
#endif
    DC_BEGIN_FN("DialogBoxProc");

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            _hwndDlg = hwndDlg;
            SetDialogAppIcon(hwndDlg);
            if(!_pSh || !_pContainerWnd)
            {
                return FALSE;
            }

            CenterWindow(NULL, 2, 4);

            SetForegroundWindow(hwndDlg);

            //turn off maximize box
            LONG style = GetWindowLong(hwndDlg, GWL_STYLE);
            style &= ~(WS_MAXIMIZEBOX);
            SetWindowLong( hwndDlg, GWL_STYLE, style); 



            //
            // Bind this dialog to the container window
            // there is logic where these two windows need to interact
            // e.g during a connect:
            // if error occurs the error dialog is brought up modal wrt
            // to the connect dialog
            // also when connect completes it is the container window
            // that dismisses this dialog
            //
            _pContainerWnd->SetConnectDialogHandle( hwndDlg);


            _lastValidBpp = CSH::SH_GetScreenBpp();

#ifndef OS_WINCE
            if(!InitializeBmps())
            {
                TRC_ERR((TB,_T("InitializeBmps failed")));
            }

            _pProgBand = new CProgressBand(hwndDlg,
                                           _hInstance,
                                           _nBrandImageHeight,
                                           UI_IDB_PROGRESS_BAND8,
                                           UI_IDB_PROGRESS_BAND4,
                                           _hBrandPal);
            if (_pProgBand) {
                if (!_pProgBand->Initialize()) {
                    TRC_ERR((TB,_T("Progress band failed to init")));
                    delete _pProgBand;
                    _pProgBand = NULL;
                }
            }


            SetupDialogSysMenu();

#endif //OS_WINCE

            //
            // Setup the server combo box
            //
            HWND hwndSrvCombo = GetDlgItem(hwndDlg, IDC_COMBO_SERVERS);
            CSH::InitServerAutoCmplCombo( _pTscSettings, hwndSrvCombo);

            SetWindowText(
                hwndSrvCombo,
                _pTscSettings->GetFlatConnectString()
                );
            
            SetFocus(GetDlgItem(hwndDlg, IDC_COMBO_SERVERS));
            SetForegroundWindow(hwndDlg);

            // 
            // Load the button text for the Options button
            //
            
            if (!LoadString( _hInstance,
                             UI_IDS_OPTIONS_MORE,
                             _szOptionsMore,
                             OPTIONS_STRING_MAX_LEN ))
            {
                 
                 // Some problem with the resources.
                 TRC_SYSTEM_ERROR("LoadString");
                 TRC_ERR((TB, _T("Failed to load string ID:%u"),
                           UI_IDS_OPTIONS_MORE));
                 //
                 // splat something in to keep running
                 //
                 DC_TSTRCPY(_szOptionsMore, TEXT(""));
            }
            
            if (!LoadString( _hInstance,
                             UI_IDS_CLOSE_TEXT,
                             _szCloseText,
                             SIZECHAR(_szCloseText)))
            {
                 // Some problem with the resources.
                 TRC_ERR((TB, _T("Failed to load string ID:%u : err:%d"),
                           UI_IDS_CLOSE_TEXT, GetLastError()));
                 DC_TSTRCPY(_szCloseText, TEXT(""));
            }

            if (!LoadString( _hInstance,
                             UI_IDS_CANCEL_TEXT,
                             _szCancelText,
                             SIZECHAR(_szCancelText)))
            {
                 // Some problem with the resources.
                 TRC_ERR((TB, _T("Failed to load string ID:%u : err:%d"),
                           UI_IDS_CANCEL_TEXT, GetLastError()));
                 DC_TSTRCPY(_szCancelText, TEXT(""));
            }


            if (!LoadString( _hInstance,
                 UI_IDS_OPTIONS_LESS,
                 _szOptionsLess,
                 OPTIONS_STRING_MAX_LEN ))
            {
                 // Some problem with the resources.
                 TRC_SYSTEM_ERROR("LoadString");
                 TRC_ERR((TB, _T("Failed to load string ID:%u"),
                           UI_IDS_OPTIONS_LESS));
                 //
                 // splat something in to keep running
                 //
                 DC_TSTRCPY(_szOptionsLess, TEXT(""));
            }

            SetWindowText(GetDlgItem(_hwndDlg,ID_BUTTON_OPTIONS),
                          _fShowExpanded ? _szOptionsLess : _szOptionsMore);

            //
            // Make sure the 'more' UI is disabled
            //
            EnableControls(moreUI, numMoreUI, FALSE);

            InitTabs();

            if(_fStartExpanded)
            {
                //go expanded
                ToggleExpandedState();
                int foo = TabCtrl_SetCurSel(GetDlgItem(hwndDlg, IDC_TABS),
                                            _nStartTab);
                //SetCurSel does not send a TCN_SELCHANGE
                OnTabSelChange();
            }

#ifdef OS_WINCE
            if ((GetFileAttributes(PEGHELP_EXE) == -1)||
                (GetFileAttributes(TSC_HELP_FILE) == -1))
            {
                LONG lRetVal = 0;

                lRetVal = GetWindowLong(_hwndDlg,
                                        GWL_STYLE);
                SetWindowLong(_hwndDlg,
                             GWL_EXSTYLE,
                             WS_EX_WINDOWEDGE);
                if (lRetVal != 0)
                {
                    SetWindowLong(_hwndDlg,
                                  GWL_STYLE,
                                  lRetVal);
                }
                rc = SetWindowPos(_hwndDlg,NULL,0,0,0,0,
                                  SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER);
            }
#endif
            rc = TRUE;
        }
        break;

#ifdef OS_WINCE
        case WM_CLOSE:
        {
            if(stateConnecting == _connectionState)
            {
                //Cancel the connection
                TRC_NRM((TB, _T("User cancel connect from maindlg")));
                _pContainerWnd->Disconnect();
            }
            else
            {
                DlgToSettings();
                EndDialog(hwndDlg, IDCANCEL);
                PostMessage(_pContainerWnd->GetWndHandle(), WM_CLOSE, 0, 0);
            }
        }
        break;
#endif
        case UI_SHOW_DISC_ERR_DLG:
        {
            //
            // If this assert fired something went wrong in the states
            // because we should have left the connecting state as the
            // first step of receiving an OnDisconnected notification
            // with WM_TSC_DISCONNECTED.
            //
            TRC_ASSERT(_connectionState != stateConnecting,
                       (TB,_T("In connecting state when received Err Dlg popup")));
            SetConnectionState( stateNotConnected );

            CDisconnectedDlg disconDlg(hwndDlg, _hInstance, _pContainerWnd);
            disconDlg.SetDisconnectReason( wParam);
            disconDlg.SetExtendedDiscReason(
                (ExtendedDisconnectReasonCode) lParam );
            disconDlg.DoModal();
        }
        break;

        case WM_TSC_DISCONNECTED:  //intentional fallthru
        case WM_TSC_CONNECTED:
        {
            //
            // Either we connected or got disconnected
            // while connecting. In either case the connection
            // has ended so leave the connecting state.
            //
            if (stateNotConnected != _connectionState)
            {
                //
                // Only end connecting if we're not already disconnected
                //
                OnEndConnection((WM_TSC_CONNECTED == uMsg));
            }
        }
        break;

        //
        // On return to connection UI
        // (e.g after a disconnection)
        //
        case WM_TSC_RETURNTOCONUI:
        {
            //
            // Reset the server combo to force it to repaint
            // this is a minor hack to fix the ComboBoxEx
            // which doesn't want to repaint itself on return
            // to the dialog.
            //
            HWND hwndSrvCombo = GetDlgItem(hwndDlg, IDC_COMBO_SERVERS);
            SetWindowText( hwndSrvCombo,
                           _pTscSettings->GetFlatConnectString());

            //
            // Notify the active property page
            //
            if(_fShowExpanded && _tabDlgInfo.hwndCurPropPage)
            {
                SendMessage(_tabDlgInfo.hwndCurPropPage,
                            WM_TSC_RETURNTOCONUI,
                            0,
                            0);
            }

            //
            // Give the default button style back to the connect
            // button and remove it from the cancel button.
            // While connecting we disable the connect (IDOK) button
            // so it is possible that the style goes to the Close/Cancel
            // button which confuses the user since the IDOK handler
            // is always for the connect button
            //
            SendDlgItemMessage(hwndDlg, IDCANCEL, BM_SETSTYLE,
                               BS_PUSHBUTTON, MAKELPARAM(TRUE,0));
            SendDlgItemMessage(hwndDlg, IDOK, BM_SETSTYLE,
                               BS_DEFPUSHBUTTON, MAKELPARAM(TRUE,0));
        }
        break;

#ifndef OS_WINCE
        case WM_ERASEBKGND:
        {
            HDC hDC = (HDC)wParam;
            HPALETTE oldPalette = NULL;

            if (_hBrandPal) {
                oldPalette = SelectPalette(hDC, _hBrandPal, FALSE);
                RealizePalette(hDC);
            }

            rc = PaintBrandImage(hwndDlg,
                                 (HDC)wParam,
                                 COLOR_BTNFACE );

            if (_pProgBand) {
                _pProgBand->OnEraseParentBackground((HDC)wParam);
            }

            if ( oldPalette ) {
                SelectPalette(hDC, oldPalette, TRUE);
            }
        }
        break;

        case WM_TIMER:
        {
            if (_pProgBand) {
                _pProgBand->OnTimer((INT)wParam);
            }
        }
        break;
#endif // OS_WINCE

        case WM_COMMAND:
        {
            switch(DC_GET_WM_COMMAND_ID(wParam))
            {
                case IDOK:
                {
                    //
                    // Update dialog with properties from active prop page
                    //
                    if(_fShowExpanded && _tabDlgInfo.hwndCurPropPage)
                    {
                        SendMessage(_tabDlgInfo.hwndCurPropPage,
                                    WM_SAVEPROPSHEET, 0, 0);
                    }

                    if(!_fShowExpanded)
                    {
                        //We're on the minimal tab
                        //copy dlg settings tscSettings
                        DlgToSettings();
                    }
                    TCHAR szServer[TSC_MAX_ADDRESS_LENGTH];
                    _tcsncpy(szServer, _pTscSettings->GetFlatConnectString(),
                             SIZECHAR(szServer));
                    _pSh->SH_CanonicalizeServerName(szServer);

                    BOOL bValidate = 
                        CRdpConnectionString::ValidateServerPart(szServer);

                    if(!bValidate)
                    {
                        //
                        // context sensitive help in validatedlg
                        // needs in handle to main window
                        //
                        CValidateDlg validateDlg(hwndDlg, _hInstance,
                                                 _pContainerWnd->GetWndHandle(),
                                                 _pSh);
                        validateDlg.DoModal();

                        //
                        // Clear and set the focus on the server edit well
                        //
                        HWND hwndSrvItem = NULL;
                        if(_fShowExpanded)
                        {
                            hwndSrvItem = GetDlgItem(_tabDlgInfo.hwndCurPropPage,
                                                     IDC_GENERAL_COMBO_SERVERS);
                        }
                        else
                        {
                            hwndSrvItem = GetDlgItem(hwndDlg, IDC_COMBO_SERVERS);
                        }
                        if(hwndSrvItem)
                        {
                            SetWindowText(hwndSrvItem, _T(""));
                            TRC_DBG((TB, _T("Set focus to edit box")));
                            SetFocus(hwndSrvItem);
                        }
                        break;
                    }
                    else
                    {
                        //
                        // It's all good
                        //
                        _pTscSettings->SetConnectString(szServer);

                        //
                        // We have to kick off the connection
                        // while the dialog is still active
                        // in case it fails, we want the error message
                        // to be parented off the connection dialog.
                        //
                        // Code in the parent window will dismiss this
                        // dialog when the connection (which is asynchronous)
                        // completes.
                        //

                        OnStartConnection();

                        if(!_pContainerWnd->StartConnection())
                        {
                            TRC_ERR((TB,_T("StartConnection failed")));
                            //Async connection start failed so end
                            OnEndConnection(FALSE);
                            break;
                        }
                    }
                }
                break;
                case IDCANCEL:
                {
                    if(stateConnecting == _connectionState)
                    {
                        //Cancel the connection
                        TRC_NRM((TB, _T("User cancel connect from maindlg")));
                        _pContainerWnd->Disconnect();
                    }
                    else
                    {
                        DlgToSettings();
                        EndDialog(hwndDlg, IDCANCEL);
                        PostMessage(_pContainerWnd->GetWndHandle(), WM_CLOSE, 0, 0);
                    }
                }
                break;
                
                case ID_BUTTON_LOGON_HELP:
                {
                    TRC_NRM((TB, _T("Display the appropriate help page")));

                    if(_pContainerWnd->GetWndHandle())
                    {
#ifndef OS_WINCE
                        _pSh->SH_DisplayClientHelp(
                            _pContainerWnd->GetWndHandle(),
                            HH_DISPLAY_TOPIC);
#endif // OS_WINCE
                    }
                }
                break;

                case ID_BUTTON_OPTIONS:
                {
                    //
                    // Need to do the switch to/from the expanded dialog
                    //
                    ToggleExpandedState();

                }
                break;

                case IDC_NEXTTAB:
                case IDC_PREVTAB:
                {
                    //
                    // Only allow toggle of UI tabs while not connected
                    // since in the connecting state the UI elements other
                    // than the cancel button are meant to be disabled
                    //
                    if(_fShowExpanded && (_connectionState == stateNotConnected))
                    {
                        int iSel = TabCtrl_GetCurSel( GetDlgItem( _hwndDlg, IDC_TABS));
                        iSel +=  (DC_GET_WM_COMMAND_ID(wParam) == IDC_NEXTTAB) ? 1 : -1;

                        if(iSel >= NUM_TABS)
                        {
                            iSel = 0;
                        }
                        else if(iSel < 0)
                        {
                            iSel = NUM_TABS - 1;
                        }

                        TabCtrl_SetCurSel( GetDlgItem( _hwndDlg, IDC_TABS), iSel);

                        //SetCurSel does not send a TCN_SELCHANGE
                        OnTabSelChange();
                    }
                }
                break;

                case IDC_COMBO_SERVERS:
                {
                    //
                    // Bring up the brwse for servers dlg
                    // if the user chose the last item in the combo
                    //
                    if(HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        CSH::HandleServerComboChange(
                                (HWND)lParam,
                                hwndDlg,
                                _hInstance,
                                (LPTSTR)_pTscSettings->GetFlatConnectString()
                                );
                    }
                }
                break;
            }
        }
        break; //WM_COMMAND

        //
        // tab notification
        //
        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;
            if(pnmh)
            {
                switch( pnmh->code)
                {
                    case TCN_SELCHANGE:
                    {
                        OnTabSelChange();
                    }
                    break;
                }
            }
            
        }
        break;

        case WM_SYSCOMMAND:
        {
            if(UI_IDM_ABOUT == DC_GET_WM_COMMAND_ID(wParam))
            {
                // Show the about box dialog
                CAboutDlg aboutDialog( hwndDlg, _hInstance, 
                                       _pSh->GetCipherStrength(),
                                       _pSh->GetControlVersionString());
                aboutDialog.DoModal();
            }
        }
        break;

        case WM_UPDATEFROMSETTINGS:
        {
            SettingsToDlg();

            //
            // Update the server MRU list
            //
            HWND hwndSrvCombo = GetDlgItem(hwndDlg, IDC_COMBO_SERVERS);
            CSH::InitServerAutoCmplCombo( _pTscSettings, hwndSrvCombo);
            SetWindowText(
                hwndSrvCombo,
                _pTscSettings->GetFlatConnectString()
                );

            if(_fShowExpanded && _tabDlgInfo.hwndCurPropPage)
            {
                SendMessage(_tabDlgInfo.hwndCurPropPage, WM_INITDIALOG, 0, 0);
            }
        }
        break;

        case WM_SETTINGCHANGE:  //fall thru
        case WM_SYSCOLORCHANGE: //fall thru
#ifndef OS_WINCE
        case WM_DISPLAYCHANGE:  //fall thru
#endif
        {
            UINT screenBpp = CSH::SH_GetScreenBpp();
            if(_lastValidBpp != screenBpp)
            {
                //Screen color depth changed
                TRC_NRM((TB,_T("Detected color depth change from:%d to %d"),
                         _lastValidBpp, screenBpp));

#ifndef OS_WINCE
                //
                // Reload the bitmaps
                //
                TRC_NRM((TB,_T("Reloading images")));

                if (_pProgBand) {
                    if (!_pProgBand->ReLoadBmps()) {
                        TRC_ERR((TB,_T("ReLoadBitmaps failed")));
                    }
                }

                if(InitializeBmps()) {
                    //trigger a repaint
                    InvalidateRect( _hwndDlg, NULL, TRUE);
                }
                else {
                    TRC_ERR((TB,_T("InitializeBmps failed")));
                }
#endif
            }
            PropagateMsgToChildren(hwndDlg, uMsg, wParam, lParam);
        }
        break;

#ifndef OS_WINCE
        case WM_QUERYNEWPALETTE:
        {
            rc = BrandingQueryNewPalette(hwndDlg);
            InvalidateRect(hwndDlg, NULL, TRUE);
            UpdateWindow(hwndDlg);
        }
        break;

        case WM_PALETTECHANGED:
        {
            rc = BrandingPaletteChanged(hwndDlg, (HWND)wParam);
            InvalidateRect(hwndDlg, NULL, TRUE);
            UpdateWindow(hwndDlg);
        }
        break;
#endif 

        case WM_HELP:
        {
            _pSh->SH_DisplayClientHelp(
                hwndDlg,
                HH_DISPLAY_TOPIC);
        }
        break;

        case WM_DESTROY:
        {
            if (_hBrandPal)
            {
                DeleteObject(_hBrandPal);
                _hBrandPal = NULL;
            }

            if (_hBrandImg)
            {
                DeleteObject(_hBrandImg);
                _hBrandImg = NULL;
            }
        }
        break;

        default:
        {
            rc = CDlgBase::DialogBoxProc(hwndDlg,
                                      uMsg,
                                      wParam,
                                      lParam);
        }
        break;

    }

    DC_END_FN();

    return(rc);

} /* UILogonDialogBox */

//
// save from UI->tscSettings
//
void CMainDlg::DlgToSettings()
{
    TCHAR szServer[SH_MAX_ADDRESS_LENGTH];
    int optLevel = 0;

    DC_BEGIN_FN("DlgToSettings");
    TRC_ASSERT(_pTscSettings, (TB,_T("_pTscSettings is null")));
    TRC_ASSERT(_hwndDlg, (TB,_T("_hwndDlg is null")));


    //
    // Get the server
    //
    GetDlgItemText( _hwndDlg, IDC_COMBO_SERVERS,
                    szServer, SIZECHAR(szServer));
    _pTscSettings->SetConnectString(szServer);

    DC_END_FN();
}

//
// save from UI->tscSettings
//
void CMainDlg::SettingsToDlg()
{
    DC_BEGIN_FN("SettingsToDlg");
    TRC_ASSERT(_pTscSettings, (TB,_T("_pTscSettings is null")));
    TRC_ASSERT(_hwndDlg, (TB,_T("_hwndDlg is null")));
    
    SetDlgItemText(_hwndDlg, IDC_COMBO_SERVERS,
       (LPCTSTR) _pTscSettings->GetFlatConnectString());

    DC_END_FN();
}

//
// Toggles the expanded state of the dialog
//
void CMainDlg::ToggleExpandedState()
{
    DC_BEGIN_FN("ToggleExpandedState");

    WINDOWPLACEMENT wndPlc;
    wndPlc.length = sizeof(WINDOWPLACEMENT);

    _fShowExpanded = !_fShowExpanded;

#ifndef OS_WINCE
    //
    // Expand/contract the dlg height
    //
    GetWindowPlacement( _hwndDlg, &wndPlc);
    int cx = wndPlc.rcNormalPosition.right - wndPlc.rcNormalPosition.left;
    int cy = wndPlc.rcNormalPosition.bottom - wndPlc.rcNormalPosition.top;
#else
    RECT wndRect;

    GetWindowRect(_hwndDlg, &wndRect);
    int cx = wndRect.right - wndRect.left;
    int cy = wndRect.bottom - wndRect.top;
#endif

#ifndef OS_WINCE

    int dlgExpDlu = LOGON_DLG_EXPAND_AMOUNT;
#else
    int dlgExpDlu = (_fVgaDisplay) ? LOGON_DLG_EXPAND_AMOUNT_VGA : LOGON_DLG_EXPAND_AMOUNT;
#endif

    RECT rc;
    rc.left  = 0;
    rc.right = 100; //don't care about horiz, dummy vals
    rc.top   = 0;
    rc.bottom = dlgExpDlu;
    if(!MapDialogRect(_hwndDlg, &rc))
    {
        TRC_ASSERT(NULL,(TB,_T("MapDialogRect failed")));
    }
    int dlgExpandAmountPels = rc.bottom - rc.top;

    //
    // Compute the dialog vertical expand amount in pixels
    // given a dlu based expand size
    //
    cy += _fShowExpanded ? dlgExpandAmountPels : -dlgExpandAmountPels;
    SetWindowPos( _hwndDlg, NULL, 0, 0, cx, cy,
                  SWP_NOMOVE | SWP_NOZORDER);

    //
    // Reposition the controls that need to be moved
    //
    RepositionControls( 0, _fShowExpanded ? dlgExpandAmountPels :
                                           -dlgExpandAmountPels,
                        moveableControls, numMoveableControls);
    if(_fShowExpanded)
    {
        //we're going expanded save to settings so more 
        //tab can initiliaze from most recent values.
        //must happen before tab sel change (prop pg init)
        DlgToSettings();
    }

    //
    // Kill/activate prop page on tab dlg
    //
    OnTabSelChange();


    if(!_fShowExpanded)
    {
        //going to less mode, init dialog with settings
        SettingsToDlg();
    }

    //
    // Options button text
    //
    SetWindowText(GetDlgItem(_hwndDlg,ID_BUTTON_OPTIONS),
          _fShowExpanded ? _szOptionsLess : _szOptionsMore);

    //
    // Disable+Hide uneeded UI for this mode
    //
    EnableControls(lessUI, numLessUI, !_fShowExpanded);
    EnableControls(moreUI, numMoreUI, _fShowExpanded);
    SetFocus(GetDlgItem(_hwndDlg,ID_BUTTON_OPTIONS));

    DC_END_FN();
}

//
// Initialize the tabs on the main dialog
//
BOOL CMainDlg::InitTabs()
{
    TCITEM tie;

#ifndef OS_WINCE
    INITCOMMONCONTROLSEX cex;
    RECT rcTabDims;
#endif

    POINT tabDims;
    int ret = -1;
    DC_BEGIN_FN("InitTabs");

    if(!_hwndDlg)
    {
        return FALSE;
    }
    HWND hwndTab = GetDlgItem( _hwndDlg, IDC_TABS);
    if(!hwndTab)
    {
        return FALSE;
    }

#ifndef OS_WINCE
    cex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    cex.dwICC  = ICC_TAB_CLASSES;

    if(!InitCommonControlsEx( &cex ))
    {
        TRC_ABORT((TB,_T("InitCommonControlsEx failed 0x%x"),
                   GetLastError()));
    }
#endif

    _pGeneralPg = new CPropGeneral(_hInstance, _pTscSettings, _pSh);
    if(!_pGeneralPg)
    {
        return FALSE;
    }

    _pLocalResPg = new CPropLocalRes(_hInstance, _pTscSettings, _pSh);
    if(!_pLocalResPg)
    {
        return FALSE;
    }

    _pPropDisplayPg = new CPropDisplay(_hInstance, _pTscSettings, _pSh);
    if(!_pPropDisplayPg)
    {
        return FALSE;
    }

    _pRunPg = new CPropRun(_hInstance, _pTscSettings, _pSh);
    if(!_pRunPg)
    {
        return FALSE;
    }

    _pPerfPg = new CPropPerf(_hInstance, _pTscSettings, _pSh);
    if(!_pPerfPg)
    {
        return FALSE;
    }

    tie.mask    =  TCIF_TEXT | TCIF_IMAGE;
    tie.iImage  = -1;


    TCHAR szTabName[MAX_PATH];
    //general tab
    if (!LoadString( _hInstance,
                     UI_IDS_GENERAL_TAB_NAME,
                     szTabName,
                     SIZECHAR(szTabName) ))
    {
        return FALSE;
    }
    tie.pszText = szTabName;
    ret = TabCtrl_InsertItem( hwndTab, 0, &tie);
    TRC_ASSERT(ret != -1,
               (TB,_T("TabCtrl_InsertItem failed %d"),
                      GetLastError()));

    //display tab
    if (!LoadString( _hInstance,
                     UI_IDS_DISPLAY_TAB_NAME,
                     szTabName,
                     SIZECHAR(szTabName)))
    {
        return FALSE;
    }
    tie.pszText = szTabName;
    ret = TabCtrl_InsertItem( hwndTab, 1, &tie);
    TRC_ASSERT(ret != -1,
               (TB,_T("TabCtrl_InsertItem failed %d"),
                      GetLastError()));


    //local resources tab
    if (!LoadString( _hInstance,
                     UI_IDS_LOCAL_RESOURCES_TAB_NAME,
                     szTabName,
                     SIZECHAR(szTabName)))
    {
        return FALSE;
    }
    tie.pszText = szTabName;
    ret = TabCtrl_InsertItem( hwndTab, 2, &tie);
    TRC_ASSERT(ret != -1,
               (TB,_T("TabCtrl_InsertItem failed %d"),
                      GetLastError()));


    //run tab
    if (!LoadString( _hInstance,
                     UI_IDS_RUN_TAB_NAME,
                     szTabName,
                     SIZECHAR(szTabName)))
    {
        return FALSE;
    }
    tie.pszText = szTabName;
    ret = TabCtrl_InsertItem( hwndTab, 3, &tie);
    TRC_ASSERT(ret != -1,
               (TB,_T("TabCtrl_InsertItem failed %d"),
                      GetLastError()));


    //advanced tab
    if (!LoadString( _hInstance,
                     UI_IDS_PERF_TAB_NAME,
                     szTabName,
                     SIZECHAR(szTabName)))
    {
        return FALSE;
    }
    tie.pszText = szTabName;
    ret = TabCtrl_InsertItem( hwndTab, 4, &tie);
    TRC_ASSERT(ret != -1,
               (TB,_T("TabCtrl_InsertItem failed %d"),
                      GetLastError()));



    //
    // Determine bounding rect for child dialogs
    //
#ifndef OS_WINCE
    
    RECT winRect;
#endif
    GetWindowRect(  hwndTab ,&_rcTab);
    TabCtrl_AdjustRect( hwndTab, FALSE, &_rcTab);
    
    MapWindowPoints( NULL, _hwndDlg, (LPPOINT)&_rcTab, 2);

    tabDims.x = _rcTab.right  - _rcTab.left;
    tabDims.y = _rcTab.bottom  - _rcTab.top;


    _tabDlgInfo.pdlgTmpl[0] = DoLockDlgRes(MAKEINTRESOURCE(UI_IDD_PROPPAGE_GENERAL));
    _tabDlgInfo.pDlgProc[0] = CPropGeneral::StaticPropPgGeneralDialogProc;
    _tabDlgInfo.pdlgTmpl[1] = DoLockDlgRes(MAKEINTRESOURCE(UI_IDD_PROPPAGE_DISPLAY));
    _tabDlgInfo.pDlgProc[1] = CPropDisplay::StaticPropPgDisplayDialogProc;
    _tabDlgInfo.pdlgTmpl[2] = DoLockDlgRes(MAKEINTRESOURCE(UI_IDD_PROPPAGE_LOCALRESOURCES));
    _tabDlgInfo.pDlgProc[2] = CPropLocalRes::StaticPropPgLocalResDialogProc;
    _tabDlgInfo.pdlgTmpl[3] = DoLockDlgRes(MAKEINTRESOURCE(UI_IDD_PROPPAGE_RUN));
    _tabDlgInfo.pDlgProc[3] = CPropRun::StaticPropPgRunDialogProc;
    _tabDlgInfo.pdlgTmpl[4] = DoLockDlgRes(MAKEINTRESOURCE(UI_IDD_PROPPAGE_PERF));
    _tabDlgInfo.pDlgProc[4] = CPropPerf::StaticPropPgPerfDialogProc;
    
#ifdef OS_WINCE
    if (_fVgaDisplay)
    {
        _tabDlgInfo.pdlgTmpl[0] = DoLockDlgRes(MAKEINTRESOURCE(UI_IDD_PROPPAGE_GENERAL_VGA));
        _tabDlgInfo.pdlgTmpl[1] = DoLockDlgRes(MAKEINTRESOURCE(UI_IDD_PROPPAGE_DISPLAY_VGA));
        _tabDlgInfo.pdlgTmpl[2] = DoLockDlgRes(MAKEINTRESOURCE(UI_IDD_PROPPAGE_LOCALRESOURCES_VGA));
        _tabDlgInfo.pdlgTmpl[3] = DoLockDlgRes(MAKEINTRESOURCE(UI_IDD_PROPPAGE_RUN_VGA));
        _tabDlgInfo.pdlgTmpl[4] = DoLockDlgRes(MAKEINTRESOURCE(UI_IDD_PROPPAGE_PERF_VGA));
    }
#endif
    
    _tabDlgInfo.hwndCurPropPage = NULL;

    _pGeneralPg->SetTabDisplayArea(_rcTab);
    _pPropDisplayPg->SetTabDisplayArea(_rcTab);
    _pLocalResPg->SetTabDisplayArea(_rcTab);
    _pRunPg->SetTabDisplayArea(_rcTab);
    _pPerfPg->SetTabDisplayArea(_rcTab);

    //
    // Trigger first tab selection
    //
    OnTabSelChange();

    DC_END_FN();
    return TRUE;
}

//
// Tab selection has changed
//
BOOL CMainDlg::OnTabSelChange()
{
    DC_BEGIN_FN("OnTabSelChange");

    int iSel = TabCtrl_GetCurSel( GetDlgItem( _hwndDlg, IDC_TABS));

    //
    // Destroy current child dialog if any
    //
    TRC_ASSERT( iSel >=0 && iSel < NUM_TABS, 
                (TB,_T("Tab selection out of range %d"), iSel));
    if(iSel < 0 || iSel > NUM_TABS)
    {
        return FALSE;
    }

    if(_tabDlgInfo.hwndCurPropPage)
    {
        DestroyWindow(_tabDlgInfo.hwndCurPropPage);
    }
    
    //
    // Only bring in a new tab if we are in expanded mode
    //
    if(_fShowExpanded)
    {
        _tabDlgInfo.hwndCurPropPage = 
            CreateDialogIndirect( _hInstance, _tabDlgInfo.pdlgTmpl[iSel],
                                  _hwndDlg, _tabDlgInfo.pDlgProc[iSel]);
        ShowWindow(_tabDlgInfo.hwndCurPropPage, SW_SHOW);
#ifdef OS_WINCE
        SetFocus (GetDlgItem (_hwndDlg, IDOK));
#endif
    }

    DC_END_FN();
    return TRUE;
}

#ifndef OS_WINCE
//
// Add an 'About' entry to the dialog's system menu
//
void CMainDlg::SetupDialogSysMenu()
{
    DC_BEGIN_FN("SetupDialogSysMenu");

    HANDLE hSystemMenu = GetSystemMenu(_hwndDlg, FALSE);
    DCTCHAR menuStr[SH_SHORT_STRING_MAX_LENGTH];
    if(hSystemMenu)
    {
        //
        // Disable sizing and maximizing
        //
        EnableMenuItem((HMENU)hSystemMenu,  SC_MAXIMIZE,
                 MF_GRAYED | MF_BYCOMMAND);
        EnableMenuItem((HMENU)hSystemMenu,  SC_SIZE,
                 MF_GRAYED | MF_BYCOMMAND);


        //load the string for the about help sub menu
        if (LoadString(_hInstance,
                       UI_MENU_ABOUT,
                       menuStr,
                       SH_SHORT_STRING_MAX_LENGTH) != 0)
        {
            AppendMenu((HMENU)hSystemMenu, MF_UNCHECKED|MF_STRING, UI_IDM_ABOUT,
                       menuStr);
        }
        else
        {
            //failed to load the sub menu string
            TRC_ERR((TB, _T("Failed to load About Help Sub Menu string ID:%u"),
                    UI_MENU_ABOUT));
        }
    }
    DC_END_FN();
}
#endif // OS_WINCE


//
// Load the image returning the given HBITMAP, having done this we can
// then get the size from it.
//
// In:
//   hInstance,resid - object to be loaded.
//   pSize - filled with size information about the object
//
// Out:
//   HBITMAP - NULL if nothing loaded
//
HBITMAP CMainDlg::LoadBitmapGetSize(HINSTANCE hInstance,UINT resid,SIZE* pSize)
{
    HBITMAP hResult = NULL;
    DIBSECTION ds = {0};

    //
    // Load the image from the resource then lets get the DIBSECTION header
    // from the bitmap object we can then read the size from it and
    // return that to the caller.
    //

#ifndef OS_WINCE
    hResult = (HBITMAP)LoadImage(hInstance, MAKEINTRESOURCE(resid),
                            IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
#else
    hResult = (HBITMAP)LoadImage(hInstance, MAKEINTRESOURCE(resid),
                            IMAGE_BITMAP, 0, 0, 0);
#endif

    if ( hResult )
    {
        GetObject(hResult, sizeof(ds), &ds);

        pSize->cx = ds.dsBmih.biWidth;
        pSize->cy = ds.dsBmih.biHeight;

        //
        // pSize->cy -ve then make +ve, -ve indicates bits are vertically
        // flipped (bottom left, top left).
        //

        if ( pSize->cy < 0 )
            pSize->cy -= 0;
    }

    return hResult;
}

#ifndef OS_WINCE

BOOL CMainDlg::PaintBrandImage(HWND hwnd,
                               HDC hDC,
                               INT bgColor)
{
    DC_BEGIN_FN("PaintBrandImage");

    HBRUSH hBrushBlue;
    HDC hdcBitmap;
    HBITMAP oldBitmap;
    RECT rc = { 0 };
    INT cxRect, cxBand;
    HBITMAP* phbmBrand;

    hdcBitmap = CreateCompatibleDC(hDC);

    if (!hdcBitmap)
    {
        return FALSE;
    }
        

    GetClientRect(hwnd, &rc);

    HBRUSH hbrBg;
    //Repaint the rest of the background

    //First the portion under the band
    rc.top = _nBrandImageHeight;
    if (_pProgBand) {
        rc.top += _pProgBand->GetBandHeight();
    }
    FillRect(hDC, &rc, (HBRUSH)IntToPtr(1+bgColor));

    //
    // Now paint the brand image
    //
    if (_hBrandImg)
    {
        SelectObject(hdcBitmap, _hBrandImg);
        BitBlt(hDC, 0, 0, _nBrandImageWidth,
               _nBrandImageHeight, hdcBitmap,
               0,0,SRCCOPY);
    }

    DeleteDC(hdcBitmap);

    DC_END_FN();
    return TRUE;
}

#endif

BOOL CMainDlg::OnStartConnection()
{
    DC_BEGIN_FN("OnStartConnection");

    TRC_ASSERT(stateNotConnected == _connectionState,
               (TB,_T("Start connecting while already connecting. State %d"),
                _connectionState));

    SetConnectionState( stateConnecting );

#ifndef OS_WINCE
    //Kick off the progress band animation timer
    if (_pProgBand) {
        _pProgBand->StartSpinning();
    }
#endif

    //
    // Change the cancel dialog button text to "Cancel"
    // to abort the connection
    //
    SetDlgItemText( _hwndDlg, IDCANCEL, _szCancelText);
    _hwndRestoreFocus = SetFocus(GetDlgItem( _hwndDlg, IDCANCEL));


    CSH::EnableControls( _hwndDlg,
                         connectingDisableControls,
                         numConnectingDisableControls,
                         FALSE );

    //
    // Inform the current property page
    // to disable all it's controls
    //
    if(_fShowExpanded && _tabDlgInfo.hwndCurPropPage)
    {
        SendMessage(_tabDlgInfo.hwndCurPropPage,
                    WM_TSC_ENABLECONTROLS,
                    FALSE, //disable controls
                    0);
    }

    DC_END_FN();
    return TRUE;
}

//
// Event that fires when the process of connecting ends
// fConnected - flag that is TRUE if we are now connected
//              FALSE if we are now disconnected (e.g if
//              if the connection failed.
//
BOOL CMainDlg::OnEndConnection(BOOL fConnected)
{
    DC_BEGIN_FN("OnEndConnection");

    //
    // If we're already disconnected then do nothing
    // e.g EndConnecting can be called once to indicate
    // successful connection and then again on disconnection
    //
    if( stateNotConnected != _connectionState)
    {
        if (fConnected)
        {
            SetConnectionState( stateConnected );
        }
        else
        {
            SetConnectionState( stateNotConnected );
        }
        

#ifndef OS_WINCE
        //
        // End the animation
        //
        if (_pProgBand) {
            _pProgBand->StopSpinning();
        }
#endif

        //
        // Change the cancel dialog button text to "Close"
        // because we have connected at least once
        //
        SetDlgItemText( _hwndDlg, IDCANCEL, _szCloseText);

#ifndef OS_WINCE
        // Reset band offset
        if (_pProgBand) {
            _pProgBand->ResetBandOffset();
        }
#endif

        CSH::EnableControls( _hwndDlg,
                             connectingDisableControls,
                             numConnectingDisableControls,
                             TRUE );

        //
        // Inform the current property page
        // to renable all controls it needs enabled
        //
        if(_fShowExpanded && _tabDlgInfo.hwndCurPropPage)
        {
            SendMessage(_tabDlgInfo.hwndCurPropPage,
                        WM_TSC_ENABLECONTROLS,
                        TRUE, //enable controls
                        0);
        }

        //
        // Make sure to correctly disable or enable
        // less UI items to prevent mnemomincs (e.g ALT-C)
        // leaking thru to the non-expanded dialog
        //
        CSH::EnableControls(_hwndDlg, lessUI, numLessUI,
                            !_fShowExpanded);


        //
        // Trigger a repaint to reposition the bar
        //
        InvalidateRect( _hwndDlg, NULL, TRUE);

        //
        // If we just went disconnected (fConnected is false)
        // then restore the focus to the control that
        // had it before the connection
        //
        if (!fConnected && _hwndRestoreFocus)
        {
            SetFocus(_hwndRestoreFocus);
        }
    }

    DC_END_FN();
    return TRUE;
}

VOID CMainDlg::SetConnectionState(mainDlgConnectionState newState)
{
    DC_BEGIN_FN("SetConnectionState");

    TRC_NRM((TB,_T("Prev state = %d. New State = %d"),
             _connectionState, newState ));

    _connectionState = newState;

    DC_END_FN();
}

#ifndef OS_WINCE

BOOL CMainDlg::PaintBrandingText(HBITMAP hbmBrandImage)
{
    HDC hdcBitmap;
    HBITMAP hbmOld;
    RECT    rc;
    COLORREF oldCol;
    INT      oldMode;
    RECT    textRc;
    INT     textHeight = 0;
    TCHAR   szBrandLine1[MAX_PATH];
    TCHAR   szBrandLine2[MAX_PATH];
    TCHAR   szLineDelta[20];
    HFONT   hOldFont = NULL;
    HFONT   hFontBrandLine1 = NULL;
    HFONT   hFontBrandLine2 = NULL;
    BOOL    bRet = FALSE;
    INT     rightEdge = 0;
    INT     nTextLineDelta = 0;
    UINT    dtTextAlign = DT_LEFT;

    //
    // These values determined based on the branding
    // bitmap, they are constant and don't change with 
    // font sizes. But if the branding bitmap is updated
    // the values may need to be tweaked
    //
    static const int TextLine1Top  = 8;
    static const int TextLine1Left = 80;
    static const int TextLineDistFromRightEdge = 20;
    static const int TextLineDelta = 5;

    DC_BEGIN_FN("PaintBrandingText");

    if(!LoadString( _hInstance, UI_IDS_BRANDING_LINE1,
                    szBrandLine1, SIZECHAR(szBrandLine1) ))
    {
        TRC_ERR((TB,_T("LoadString for UI_IDS_BRANDING_LINE1 failed 0x%x"),
                 GetLastError()));
        return FALSE;
    }

    if(!LoadString( _hInstance, UI_IDS_BRANDING_LINE2,
                    szBrandLine2, SIZECHAR(szBrandLine2)))
    {
        TRC_ERR((TB,_T("LoadString for UI_IDS_BRANDING_LINE2 failed 0x%x"),
                 GetLastError()));
        return FALSE;
    }

    //
    // Figure out if this is Bidi, if so flip text alignment
    //
    if (GetWindowLongPtr(_hwndDlg, GWL_EXSTYLE) & WS_EX_LAYOUTRTL)
    {
        TRC_NRM((TB,_T("RTL layout detected, flip text alignment")));
        dtTextAlign = DT_RIGHT;
    }
    else
    {
        dtTextAlign = DT_LEFT;
    }


    hFontBrandLine1 = LoadFontFromResourceInfo( UI_IDS_BRANDING_LN1FONT,
                                                UI_IDS_BRANDING_LN1SIZE,
                                                FALSE );
    if(!hFontBrandLine1)
    {
        TRC_ERR((TB,_T("LoadFontFromResourceInfo for brandln1 failed")));
        DC_QUIT;
    }
    hFontBrandLine2 = LoadFontFromResourceInfo( UI_IDS_BRANDING_LN2FONT,
                                                UI_IDS_BRANDING_LN2SIZE,
                                                TRUE );
    if(!hFontBrandLine2)
    {
        TRC_ERR((TB,_T("LoadFontFromResourceInfo for brandln1 failed")));
        DC_QUIT;
    }

    if (LoadString( _hInstance, UI_IDS_LINESPACING_DELTA,
                     szLineDelta, SIZECHAR(szLineDelta)))
    {
        nTextLineDelta = _ttol(szLineDelta);
    }
    else
    {
        TRC_ERR((TB,_T("Failed to load text line delta using default")));
        nTextLineDelta = TextLineDelta;
    }


    hdcBitmap = CreateCompatibleDC(NULL);
    if(hdcBitmap)
    {
        hbmOld = (HBITMAP)SelectObject(hdcBitmap, hbmBrandImage);
        hOldFont = (HFONT)SelectObject( hdcBitmap, hFontBrandLine1);

        // Set text transparency and color
        //White text
        SetTextColor(hdcBitmap, RGB(255,255,255));
        
        SetBkMode(hdcBitmap, TRANSPARENT);
        SetMapMode(hdcBitmap, MM_TEXT);

        GetClientRect( _hwndDlg, &rc );

        rightEdge = min(_nBrandImageWidth, rc.right); 

        textRc.right = rightEdge - TextLineDistFromRightEdge;
        textRc.top   = TextLine1Top;
        textRc.bottom = 40;
        textRc.left = TextLine1Left;

        //
        // Draw first branding line
        //
        textHeight = DrawText(hdcBitmap,
                              szBrandLine1,
                              _tcslen(szBrandLine1),
                              &textRc, //rect
                              dtTextAlign);
        if(!textHeight)
        {
            TRC_ERR((TB,_T("DrawText for brand line1 failed 0x%x"),
                     GetLastError()));
        }

        textRc.top += textHeight - nTextLineDelta;
        textRc.bottom += textHeight - nTextLineDelta;

        SelectObject( hdcBitmap, hFontBrandLine2);

        //
        // Draw second branding line
        //
        textHeight = DrawText(hdcBitmap,
                              szBrandLine2,
                              _tcslen(szBrandLine2),
                              &textRc, //rect
                              dtTextAlign);
        if(!textHeight)
        {
            TRC_ERR((TB,_T("DrawText for brand line1 failed 0x%x"),
                     GetLastError()));
        }

        SelectObject( hdcBitmap, hOldFont );
        SelectObject(hdcBitmap, hbmOld);


        DeleteDC(hdcBitmap);
        bRet = TRUE;
    }
    else
    {
        DC_QUIT;
    }

DC_EXIT_POINT:
    DC_END_FN();
    if(hFontBrandLine1)
    {
        DeleteObject( hFontBrandLine1 );
    }

    if(hFontBrandLine2)
    {
        DeleteObject( hFontBrandLine2 );
    }
    return bRet;
}

#endif

void CMainDlg::SetFontFaceFromResource(PLOGFONT plf, UINT idFaceName)
{
    DC_BEGIN_FN("SetFontFaceFromResource");

    // Read the face name and point size from the resource file
    if (LoadString(_hInstance, idFaceName, plf->lfFaceName, LF_FACESIZE) == 0)
    {
        _tcscpy(plf->lfFaceName, TEXT("Tahoma"));
        TRC_ERR((TB,_T("Could not read welcome font face from resource")));
    }

    DC_END_FN();
}

//
// Note this is pixel size and not font size
//
void CMainDlg::SetFontSizeFromResource(PLOGFONT plf, UINT idSizeName)
{
    DC_BEGIN_FN("SetFontFaceFromResource");

    TCHAR szPixelSize[10];
    LONG nSize;

    if (LoadString(_hInstance, idSizeName, szPixelSize, SIZECHAR(szPixelSize)) != 0)
    {
        nSize = _ttol(szPixelSize);
    }
    else
    {
        // Make it really obvious something is wrong
        nSize = 40;
    }

    plf->lfHeight = -nSize;
    DC_END_FN();
}

#ifndef OS_WINCE

HFONT CMainDlg::LoadFontFromResourceInfo(UINT idFace, UINT idSize, BOOL fBold)
{
    LOGFONT lf = {0};
    CHARSETINFO csInfo;
    HFONT hFont;

    DC_BEGIN_FN("LoadFontFromResourceInfo");

    lf.lfWidth = 0;
    lf.lfWeight = fBold ? FW_HEAVY : FW_NORMAL;
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = DEFAULT_QUALITY;
    lf.lfPitchAndFamily = DEFAULT_PITCH;

    // Set charset
    if (TranslateCharsetInfo((LPDWORD)UIntToPtr(GetACP()), &csInfo,
        TCI_SRCCODEPAGE) == 0)
    {
        TRC_ASSERT(0,(TB,_T("TranslateCharsetInfo failed")));
        csInfo.ciCharset = 0;
    }

    lf.lfCharSet = (UCHAR)csInfo.ciCharset;
    SetFontFaceFromResource(&lf, idFace);
    SetFontSizeFromResource(&lf, idSize);

    hFont = CreateFontIndirect(&lf);

    TRC_ASSERT(hFont, (TB,_T("CreateFontIndirect failed")));

    DC_END_FN();
    return hFont;
}

#endif

//
// Propagates a message to all child windows
// used so common controls get notifications
// e.g of color changes
//
VOID CMainDlg::PropagateMsgToChildren(HWND hwndDlg,
                                    UINT uMsg,
                                    WPARAM wParam,
                                    LPARAM lParam)
{
    HWND hwndChild;
    DC_BEGIN_FN("PropagateMsgToChildren");

    for( hwndChild = GetWindow(hwndDlg, GW_CHILD);
         hwndChild != NULL;
         hwndChild = GetWindow(hwndChild, GW_HWNDNEXT) )
    {

        #ifdef DC_DEBUG
        /* GetClassName doesn't have a uniwrap wrapper yet...
        TCHAR szTmp[256];
        GetClassName(hwndChild, szTmp, 256);

        TRC_DBG((TB,
         _T("PropagateMessage: ( 0x%08lX cls:%s, 0x%08X, 0x%08lX, 0x%08lX )\n"),
            hwndChild, uMsg, wParam, lParam ));
        */
        #endif

        SendMessage(hwndChild, uMsg, wParam, lParam);
    }

    DC_END_FN();
}

#ifndef OS_WINCE

//
// Initializes the images (branding and band bitmap)
// taking into account the current color depth.
//
// This function can be recalled if there is a color
// depth change
//
//
BOOL CMainDlg::InitializeBmps()
{
    HBITMAP hbmBrandImage = NULL;
    UINT screenBpp;
    UINT imgResID;
    HBITMAP hbmFromRsrc = NULL;
    INT     nBmpWidth = 0;
    INT     nBmpHeight = 0;
    BOOL    fDeepImgs = FALSE;
    RECT rc;
    INT nDlgWidth;

    DC_BEGIN_FN("InitializeBmps");

    //
    // _hwndDlg should be set early in WM_INITDIALOG
    //
    TRC_ASSERT(_hwndDlg,
               (TB,_T("_hwndDlg is null")));

    screenBpp = CSH::SH_GetScreenBpp();

    if (screenBpp <= 8)
    {
        _fUse16ColorBitmaps = TRUE;
        imgResID = UI_IDB_BRANDIMAGE_16; 
    }
    else
    {
        _fUse16ColorBitmaps = FALSE;
        imgResID = UI_IDB_BRANDIMAGE;
    }

    GetClientRect( _hwndDlg, &rc );
    nDlgWidth = rc.right - rc.left;
    if (!nDlgWidth)
    {
        //
        // We've seen cases in FUS where the client area is returned
        // as 0. Be robust to that and just bail out of initilizing
        // the bmp with a fail code
        //
        TRC_ERR((TB,_T("Got 0 client width")));
        return FALSE;
    }


    if (screenBpp >= 8)
    {
        fDeepImgs = TRUE;
    }

    TRC_NRM((TB,_T("Use16 color bmp :%d. Img res id:%d"),
            _fUse16ColorBitmaps,imgResID));

    hbmFromRsrc = (HBITMAP)LoadImage(_hInstance,
        MAKEINTRESOURCE(imgResID),IMAGE_BITMAP,
                        0, 0, LR_CREATEDIBSECTION);
    if (hbmFromRsrc)
    {
        //
        // Figure out the dimensions of the resrc bmp
        //
        DIBSECTION ds = {0};
        if (GetObject(hbmFromRsrc, sizeof(ds), &ds))
        {
            nBmpHeight = ds.dsBm.bmHeight;
            if(nBmpHeight < 0)
            {
                nBmpHeight -= 0;
            }
            nBmpWidth = ds.dsBm.bmWidth;
        }

        //
        // Create a new brand bitmap that spans
        // the width of the dialog. This is necessary
        // so that we can just set it up once e.g
        // drawing branding text etc. The bitmap has to match
        // the dialog width because on localized builds the dialog
        // can be much wider than the resource version of the bitmap
        // and the text can span a wider area.
        //
        HDC hDC = GetWindowDC(_hwndDlg);
        if (hDC)
        {
            hbmBrandImage = CreateCompatibleBitmap(hDC,
                                                   nDlgWidth,
                                                   nBmpHeight);
            HDC hMemDCSrc  = CreateCompatibleDC(hDC);
            HDC hMemDCDest = CreateCompatibleDC(hDC);
            if (hMemDCSrc && hMemDCDest)
            {
                RECT rcFill;
                RGBQUAD rgb[256];
                HBITMAP hbmDestOld = NULL;
                LPLOGPALETTE pLogPalette = NULL;
                HPALETTE hScreenPalOld = NULL;
                HPALETTE hMemPalOld =  NULL;
                UINT nCol = 0;

                //
                // Get brand img palette
                //
                _hBrandPal = CUT::UT_GetPaletteForBitmap(hDC, hbmFromRsrc);

                if (_hBrandPal) {
                    hScreenPalOld = SelectPalette(hDC, _hBrandPal, FALSE);
                    hMemPalOld = SelectPalette(hMemDCDest, _hBrandPal, FALSE);
                    RealizePalette(hDC);
                }

                HBITMAP hbmSrcOld = (HBITMAP)SelectObject(
                    hMemDCSrc, hbmFromRsrc);

                hbmDestOld = (HBITMAP)SelectObject(
                    hMemDCDest, hbmBrandImage);
                
                rcFill.left = 0;
                rcFill.top = 0;
                rcFill.bottom = nBmpHeight;
                rcFill.right = nDlgWidth;

                HBRUSH hSolidBr = CreateSolidBrush( 
                    _fUse16ColorBitmaps ? IMAGE_BG_COL_16 : IMAGE_BG_COL);
                if (hSolidBr)
                {
                    FillRect(hMemDCDest,
                             &rcFill,
                             hSolidBr);
                    DeleteObject( hSolidBr );
                }
                
                BitBlt(hMemDCDest, 0, 0, nDlgWidth, nBmpHeight,
                       hMemDCSrc,  0, 0, SRCCOPY);

                if (hbmDestOld)
                {
                    SelectObject(hMemDCDest, hbmDestOld);
                }

                if (hbmSrcOld)
                {
                    SelectObject(hMemDCSrc, hbmSrcOld);
                }

                if (hScreenPalOld)
                {
                    SelectPalette(hDC, hScreenPalOld, TRUE);
                }

                if (hMemPalOld)
                {
                    SelectPalette(hDC, hMemPalOld, TRUE);
                }

                DeleteDC(hMemDCSrc);
                DeleteDC(hMemDCDest);
            }

            ReleaseDC(_hwndDlg, hDC);
        }
        else
        {
            TRC_ERR((TB,_T("GetDC failed 0x%x"),
                     GetLastError()));
        }
        DeleteObject( hbmFromRsrc );

        _nBrandImageWidth  = nDlgWidth;
        _nBrandImageHeight = nBmpHeight;
    }

    if(!hbmBrandImage)
    {
        TRC_ERR((TB,_T("Error setting up brand bmp")));
        return FALSE;
    }

    if(hbmBrandImage)
    {
        PaintBrandingText( hbmBrandImage );
    }

    //
    // Delete any old brand img and keep track of this one
    //
    if (_hBrandImg)
    {
        DeleteObject(_hBrandImg); 
    }
    _hBrandImg = hbmBrandImage;

    TRC_ASSERT(_nBrandImageHeight,
               (TB,_T("_nBrandImageHeight is 0!")));

    _lastValidBpp = screenBpp;


    DC_END_FN();
    return TRUE;
}

//
// BrandingQueryNewPalette / BrandingPaletteChanged
// code 'borrowed' from winlogon
//  Handle palette change messages from the system so that we can work correctly
//  on <= 8 bit per pixel devices.
//
// In:
//   -
// Out:
// -
//

BOOL CMainDlg::BrandingQueryNewPalette(HWND hDlg)
{
    HDC hDC;
    HPALETTE oldPalette;

    DC_BEGIN_FN("BrandingQueryNewPalette");

    if ( !_hBrandPal )
        return FALSE;

    hDC = GetDC(hDlg);

    if ( !hDC )
        return FALSE;

    oldPalette = SelectPalette(hDC, _hBrandPal, FALSE);
    RealizePalette(hDC);
    UpdateColors(hDC);

    //
    // Update the window
    //
    UpdateWindow(hDlg);

    if ( oldPalette )
        SelectPalette(hDC, oldPalette, FALSE);

    ReleaseDC(hDlg, hDC);

    DC_END_FN();
    return TRUE;
}

BOOL CMainDlg::BrandingPaletteChanged(HWND hDlg, HWND hWndPalChg)
{
    HDC hDC;
    HPALETTE oldPalette;

    DC_BEGIN_FN("BrandingPaletteChanged");

    if ( !_hBrandPal )
    {
        return FALSE;
    }

    if ( hDlg != hWndPalChg )
    {
        hDC = GetDC(hDlg);

        if ( !hDC )
            return FALSE;

        oldPalette = SelectPalette(hDC, _hBrandPal, FALSE);
        RealizePalette(hDC);
        UpdateColors(hDC);

        if ( oldPalette )
            SelectPalette(hDC, oldPalette, FALSE);

        ReleaseDC(hDlg, hDC);
    }

    DC_END_FN();

    return FALSE;
}

#endif

//
// Load the perf strings into a global table
// that will also be used by the perf property page
//
BOOL CMainDlg::InitializePerfStrings()
{
    DC_BEGIN_FN("InitializePerfStrings");

    if (!g_fPropPageStringMapInitialized)
    {
        //
        // Load color strings
        //
        for(int i = 0; i< NUM_PERFSTRINGS; i++)
        {
            if (!LoadString( _hInstance,
                     g_PerfOptimizeStringTable[i].resID,
                     g_PerfOptimizeStringTable[i].szString,
                     PERF_OPTIMIZE_STRING_LEN ))
            {
                TRC_ERR((TB, _T("Failed to load color string %d"),
                         g_PerfOptimizeStringTable[i].resID));
                return FALSE;
            }
        }

        g_fPropPageStringMapInitialized = TRUE;

        TRC_NRM((TB,_T("Successfully loaded perf strings")));

        return TRUE;
    }
    else
    {
        TRC_NRM((TB,_T("Strings were already loaded")));
        return TRUE;
    }

    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\propdisplay.h ===
//
// propdisplay.h: Display prop pg
//                Tab B
//
// Copyright Microsoft Corportation 2000
// (nadima)
//

#ifndef _propdisplay_h_
#define _propdisplay_h_

#include "sh.h"
#include "tscsetting.h"

#define COLOR_STRING_MAXLEN  32
#define MAX_SCREEN_RES_OPTIONS  10

typedef struct tag_COLORSTRINGMAP
{
    int     bpp;
    int     resID;
    //resource ID of the corresponding color bitmap
    int     bitmapResID;
    int     bitmapLowColorResID;
    TCHAR   szString[COLOR_STRING_MAXLEN];
} COLORSTRINGMAP, *PCOLORSTRINGMAP;

typedef struct tagSCREENRES
{
    int width;
    int height;
} SCREENRES, *PSCREENRES;


class CPropDisplay
{
public:
    CPropDisplay(HINSTANCE hInstance, CTscSettings* pTscSet, CSH* pSh);
    ~CPropDisplay();

    static CPropDisplay* CPropDisplay::_pPropDisplayInstance;
    static INT_PTR CALLBACK StaticPropPgDisplayDialogProc (HWND hwndDlg,
                                                            UINT uMsg,
                                                            WPARAM wParam,
                                                            LPARAM lParam);
    void SetTabDisplayArea(RECT& rc) {_rcTabDispayArea = rc;}
private:
    //Local resources tab
    INT_PTR CALLBACK PropPgDisplayDialogProc (HWND hwndDlg,
                                               UINT uMsg,
                                               WPARAM wParam,
                                               LPARAM lParam);

    //
    // Tab property page helpers
    //
    BOOL LoadDisplayourcesPgStrings();
#ifndef OS_WINCE
    BOOL OnUpdateResTrackBar(HWND hwndPropPage);
#endif
    BOOL OnUpdateColorCombo(HWND hwndPropPage);
    void InitColorCombo(HWND hwndPropPage);
    void InitScreenResTable();

private:
    CTscSettings*  _pTscSet;
    CSH*           _pSh;
    RECT           _rcTabDispayArea;
    HINSTANCE      _hInstance;

    //localized 'x by x pixels'
    TCHAR          _szScreenRes[SH_SHORT_STRING_MAX_LENGTH];
    //localized 'Fullscreen'
    TCHAR          _szFullScreen[SH_SHORT_STRING_MAX_LENGTH];

    int            _numScreenResOptions;
    SCREENRES      _screenResTable[MAX_SCREEN_RES_OPTIONS];

    BOOL           _fSwitchedColorComboBmp;
};


#endif // _propdisplay_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\propgeneral.h ===
//
// propgeneral.h: general property page
//                Tab A
//
// Copyright Microsoft Corportation 2000
// (nadima)
//

#ifndef _propgen_h_
#define _propgen_h_

#include "sh.h"
#include "tscsetting.h"

class CPropGeneral
{
public:
    CPropGeneral(HINSTANCE hInstance, CTscSettings* pTscSet,CSH* pSh);
    ~CPropGeneral();

    //General tab
    static INT_PTR CALLBACK StaticPropPgGeneralDialogProc (HWND hwndDlg,
                                                           UINT uMsg,
                                                           WPARAM wParam,
                                                           LPARAM lParam);
    INT_PTR CALLBACK PropPgGeneralDialogProc(HWND hwndDlg,
                                             UINT uMsg,
                                             WPARAM wParam,
                                             LPARAM lParam);
    void SetTabDisplayArea(RECT& rc) {_rcTabDispayArea = rc;}

private:
    BOOL LoadGeneralPgStrings();
    BOOL OnSave(HWND hwndDlg);
    BOOL OnLoad(HWND hwndDlg);
    BOOL OnChangeUserName(HWND hwndDlg);
    void DlgToSettings(HWND hwndDlg);

private:
    //Private members
    CTscSettings* _pTscSet;
    static CPropGeneral* _pPropGeneralInstance;
    HINSTANCE  _hInstance;

    //Resource string that describes remote desktop files
    TCHAR          _szFileTypeDescription[MAX_PATH];

    CSH*           _pSh;
    RECT           _rcTabDispayArea;
};

#endif //_propgen_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\propperf.cpp ===
//
// propperf.cpp: local resources property sheet dialog proc
//
// Tab E
//
// Copyright Microsoft Corporation 2000
// nadima

#include "stdafx.h"


#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "propperf"
#include <atrcapi.h>

#include "sh.h"

#include "commctrl.h"
#include "propperf.h"


CPropPerf* CPropPerf::_pPropPerfInstance = NULL;

//
// Lookup tables
//

//
// Controls that need to be disabled/enabled
// during connection (for progress animation)
//
CTL_ENABLE connectingDisableCtlsPPerf[] = {
                        {UI_IDC_STATIC_CHOOSE_SPEED, FALSE},
                        {IDC_COMBO_PERF_OPTIMIZE, FALSE},
                        {UI_IDC_STATIC_OPTIMIZE_PERF, FALSE},
                        {IDC_CHECK_DESKTOP_BKND, FALSE},
                        {IDC_CHECK_SHOW_FWD, FALSE},
                        {IDC_CHECK_MENU_ANIMATIONS, FALSE},
                        {IDC_CHECK_THEMES, FALSE},
                        {IDC_CHECK_BITMAP_CACHING, FALSE},
                        {IDC_CHECK_ENABLE_ARC, FALSE}
                        };

const UINT numConnectingDisableCtlsPPerf =
                        sizeof(connectingDisableCtlsPPerf)/
                        sizeof(connectingDisableCtlsPPerf[0]);

//
// MAP from optimization level to disabled feature list
// Disabled features list
//
// Index is the optimization level, entry is the disabled feature list
//
DWORD g_dwMapOptLevelToDisabledList[NUM_PERF_OPTIMIZATIONS] =
{
    // 28K
    TS_PERF_DISABLE_WALLPAPER      |
    TS_PERF_DISABLE_FULLWINDOWDRAG |
    TS_PERF_DISABLE_MENUANIMATIONS |
    TS_PERF_DISABLE_THEMING,

    // 56K
    TS_PERF_DISABLE_WALLPAPER      |
    TS_PERF_DISABLE_FULLWINDOWDRAG |
    TS_PERF_DISABLE_MENUANIMATIONS,

    // Broadband
    TS_PERF_DISABLE_WALLPAPER,

    // LAN
    TS_PERF_DISABLE_NOTHING,

    //
    // CUSTOM (defaults to same as 56K
    // 56K
    //
    // NOTE: This value gets changed at runtime
    //       to reflect the current custom settings
    //

    TS_PERF_DISABLE_WALLPAPER      |
    TS_PERF_DISABLE_FULLWINDOWDRAG |
    TS_PERF_DISABLE_MENUANIMATIONS
};


//
// Mask of flags that can be set by checkboxes
//
#define CHECK_BOX_PERF_MASK  (TS_PERF_DISABLE_WALLPAPER      | \
                              TS_PERF_DISABLE_FULLWINDOWDRAG | \
                              TS_PERF_DISABLE_MENUANIMATIONS | \
                              TS_PERF_DISABLE_THEMING        | \
                              TS_PERF_DISABLE_BITMAPCACHING  |  \
                              TS_PERF_DISABLE_CURSORSETTINGS) \

CPropPerf::CPropPerf(HINSTANCE hInstance, CTscSettings*  pTscSet, CSH* pSh)
{
    DC_BEGIN_FN("CPropPerf");
    _hInstance = hInstance;
    CPropPerf::_pPropPerfInstance = this;
    _pTscSet = pTscSet;
    _hwndDlg = NULL;
    _fSyncingCheckboxes = FALSE;
    _pSh = pSh;

    TRC_ASSERT(_pTscSet,(TB,_T("_pTscSet is null")));
    TRC_ASSERT(_pSh,(TB,_T("_pSh is null")));

    DC_END_FN();
}

CPropPerf::~CPropPerf()
{
    CPropPerf::_pPropPerfInstance = NULL;
}

INT_PTR CALLBACK CPropPerf::StaticPropPgPerfDialogProc(HWND hwndDlg,
                                                               UINT uMsg,
                                                               WPARAM wParam,
                                                               LPARAM lParam)
{
    //
    // Delegate to appropriate instance (only works for single instance dialogs)
    //
    DC_BEGIN_FN("StaticDialogBoxProc");
    DCINT retVal = 0;

    TRC_ASSERT(_pPropPerfInstance, (TB,
        _T("perf dialog has NULL static instance ptr\n")));
    retVal = _pPropPerfInstance->PropPgPerfDialogProc( hwndDlg,
                                                               uMsg,
                                                               wParam,
                                                               lParam);

    DC_END_FN();
    return retVal;
}


INT_PTR CALLBACK CPropPerf::PropPgPerfDialogProc (HWND hwndDlg,
                                                          UINT uMsg,
                                                          WPARAM wParam,
                                                          LPARAM lParam)
{
    DC_BEGIN_FN("PropPgPerfDialogProc");

    switch(uMsg)
    {
        case WM_INITDIALOG:
        {
#ifndef OS_WINCE
            int i;
#endif
            _hwndDlg = hwndDlg;
            //
            // Position the dialog within the tab
            //
            SetWindowPos( hwndDlg, HWND_TOP, 
                          _rcTabDispayArea.left, _rcTabDispayArea.top,
                          _rcTabDispayArea.right - _rcTabDispayArea.left,
                          _rcTabDispayArea.bottom - _rcTabDispayArea.top,
                          0);

            InitPerfCombo();
            SyncCheckBoxesToPerfFlags(
                _pTscSet->GetPerfFlags());

            //
            // AutoReconnection checkbox
            //
            CheckDlgButton(hwndDlg, IDC_CHECK_ENABLE_ARC,
                           _pTscSet->GetEnableArc() ?
                           BST_CHECKED : BST_UNCHECKED);


            _pSh->SH_ThemeDialogWindow(hwndDlg, ETDT_ENABLETAB);
            return TRUE;
        }
        break; //WM_INITDIALOG

        case WM_TSC_ENABLECONTROLS:
        {
            //
            // wParam is TRUE to enable controls,
            // FALSE to disable them
            //
            CSH::EnableControls( hwndDlg,
                                 connectingDisableCtlsPPerf,
                                 numConnectingDisableCtlsPPerf,
                                 wParam ? TRUE : FALSE);
        }
        break;


        case WM_SAVEPROPSHEET: //Intentional fallthru
        case WM_DESTROY:
        {
            BOOL fEnableArc;
            //
            // Save page settings
            //
            DWORD dwCheckBoxPerfFlags = GetPerfFlagsFromCheckboxes();
            DWORD dwPerfFlags = MergePerfFlags( dwCheckBoxPerfFlags,
                                                _pTscSet->GetPerfFlags(),
                                                CHECK_BOX_PERF_MASK );

            fEnableArc = IsDlgButtonChecked(hwndDlg, IDC_CHECK_ENABLE_ARC);
            _pTscSet->SetEnableArc(fEnableArc);

            

            _pTscSet->SetPerfFlags(dwPerfFlags); 
        }
        break; //WM_DESTROY

        case WM_COMMAND:
        {
            switch(DC_GET_WM_COMMAND_ID(wParam))
            {
                case IDC_COMBO_PERF_OPTIMIZE:
                {
                    if(HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        OnPerfComboSelChange();
                    }
                }
                break;

                default:
                {
                    if (HIWORD(wParam) == BN_CLICKED)
                    {
                        //
                        // One of the checkboxes has been checked
                        // (prevent recursive looping due to feedback)
                        //
                        if (!_fSyncingCheckboxes)
                        {
                            OnCheckBoxStateChange((int)LOWORD(wParam));
                        }
                    }
                }
                break;
            }
        }
        break;
    }

    DC_END_FN();
    return 0;
}

BOOL CPropPerf::InitPerfCombo()
{
    INT ret = 1;
    DC_BEGIN_FN("InitPerfCombo");

    TRC_ASSERT(g_fPropPageStringMapInitialized,
               (TB,_T("Perf strings not loaded")));

    TRC_ASSERT(_hwndDlg,
               (TB,_T("_hwndDlg not set")));

    if (!g_fPropPageStringMapInitialized)
    {
        return FALSE;
    }

#ifndef OS_WINCE
    while (ret && ret != CB_ERR)
    {
        ret = SendDlgItemMessage(_hwndDlg,
                                 IDC_COMBO_PERF_OPTIMIZE,
                                 CBEM_DELETEITEM,
                                 0,0);
    }

#else
    SendDlgItemMessage(_hwndDlg, IDC_COMBO_PERF_OPTIMIZE, CB_RESETCONTENT, 0, 0);
#endif
    //
    // Only set up to the last but one string in the table
    // as the last string is only used in the perf page
    //
    for (int i=0; i<NUM_PERF_OPTIMIZATIONS+1; i++)
    {
        if (NUM_PERF_OPTIMIZATIONS-1 == i)
        {
            //
            // Skip the last but one string it's the
            // custom entry for the main dialog
            //
            continue;
        }
        SendDlgItemMessage(_hwndDlg,
            IDC_COMBO_PERF_OPTIMIZE,
            CB_ADDSTRING,
            0,
            (LPARAM)(PDCTCHAR)g_PerfOptimizeStringTable[i].szString);
    }

    //
    // Set the optimization level according to the disabled feature list
    //
    DWORD dwPerfFlags = _pTscSet->GetPerfFlags();
    int optLevel = MapPerfFlagsToOptLevel(dwPerfFlags);
    TRC_ASSERT(optLevel >= 0 && optLevel < NUM_PERF_OPTIMIZATIONS,
               (TB,_T("optlevel %d out of range"), optLevel));

    SendDlgItemMessage(_hwndDlg, IDC_COMBO_PERF_OPTIMIZE,CB_SETCURSEL,
                      (WPARAM)optLevel,0);

    DC_END_FN();
    return TRUE;
}

//
// Notification that the perf combo's selection has changed
//
VOID CPropPerf::OnPerfComboSelChange()
{
    int curSel = 0;
    DWORD dwDisableFeatureList = 0;
    DC_BEGIN_FN("OnPerfComboSelChange");

    //
    // Figure out what the new selected item is
    //
    curSel = SendDlgItemMessage(_hwndDlg,
                                IDC_COMBO_PERF_OPTIMIZE,
                                CB_GETCURSEL,
                                0,0);
    if (curSel < 0)
    {
        curSel = 0;
    }

    TRC_ASSERT(curSel < NUM_PERF_OPTIMIZATIONS,
               (TB,_T("curSel (%d) > NUM_PERF_OPTIMIZATIONS (%d)"),
                curSel,NUM_PERF_OPTIMIZATIONS));
    if (curSel >= NUM_PERF_OPTIMIZATIONS)
    {
        curSel = NUM_PERF_OPTIMIZATIONS - 1;
    }

    //
    // Map that to a list of disabled features
    //
    dwDisableFeatureList = MapOptimizationLevelToPerfFlags(curSel);

    //
    // Check and uncheck the checkboxes
    //
    SyncCheckBoxesToPerfFlags(dwDisableFeatureList);

    DC_END_FN();
}

//
// Static method. Maps an optimization to the disabled feature list
// (packed in a DWORD)
// Params:
// [in] optLevel - optimization level from 0 to NUM_PERF_OPTIMIZATIONS-1
// [return] DWORD feature list
//
DWORD CPropPerf::MapOptimizationLevelToPerfFlags(int optLevel)
{
    DWORD dwPerfFlags = 0;
    DC_BEGIN_FN("MapOptimizationLevelToPerfFlags");

    if (optLevel < 0)
    {
        TRC_ERR((TB,_T("Opt level out of range %d"),optLevel));
        optLevel = 0;
    }
    if (optLevel >= NUM_PERF_OPTIMIZATIONS)
    {
        TRC_ERR((TB,_T("Opt level out of range %d"),optLevel));
        optLevel = NUM_PERF_OPTIMIZATIONS - 1;
    }

    dwPerfFlags = g_dwMapOptLevelToDisabledList[optLevel];

    TRC_NRM((TB,_T("Return disable list 0x%x"),dwPerfFlags));

    DC_END_FN();
    return dwPerfFlags;
}

//
// Toggles checkboxes to match the disabled feature list
// NOTE: the checkboxes represent 'enabled' features i.e the negation
// of the list
//
VOID CPropPerf::SyncCheckBoxesToPerfFlags(DWORD dwPerfFlagss)
{
    DC_BEGIN_FN("SyncCheckBoxesToPerfFlags");

    //
    // Prevent recursive sets based on change notifications
    // for the checkboxes (As they could change the combo leading
    // to a subsequent change in the checkboxes, etc...)
    //

    _fSyncingCheckboxes = TRUE;

    //
    // Wallpaper (Desktop background)
    //
    CheckDlgButton(_hwndDlg, IDC_CHECK_DESKTOP_BKND,
            (dwPerfFlagss & TS_PERF_DISABLE_WALLPAPER ?
             BST_UNCHECKED : BST_CHECKED));

    //
    // Fullwindow drag
    //
    CheckDlgButton(_hwndDlg, IDC_CHECK_SHOW_FWD,
            (dwPerfFlagss & TS_PERF_DISABLE_FULLWINDOWDRAG ?
             BST_UNCHECKED : BST_CHECKED));

    //
    // Menu animations
    //
    CheckDlgButton(_hwndDlg, IDC_CHECK_MENU_ANIMATIONS,
            (dwPerfFlagss & TS_PERF_DISABLE_MENUANIMATIONS ?
             BST_UNCHECKED : BST_CHECKED));

    //
    // Theming
    //
    CheckDlgButton(_hwndDlg, IDC_CHECK_THEMES,
            (dwPerfFlagss & TS_PERF_DISABLE_THEMING ?
             BST_UNCHECKED : BST_CHECKED));

    //
    // Bitmap caching
    //
    CheckDlgButton(_hwndDlg, IDC_CHECK_BITMAP_CACHING,
            (dwPerfFlagss & TS_PERF_DISABLE_BITMAPCACHING ?
             BST_UNCHECKED : BST_CHECKED));

    _fSyncingCheckboxes = FALSE;

    DC_END_FN();
}

//
// Maps the disabled feature list to the appropriate optimization level
//
INT CPropPerf::MapPerfFlagsToOptLevel(DWORD dwPerfFlags)
{
    DC_BEGIN_FN("MapPerfFlagsToOptLevel");

    for (int i=0;i<NUM_PERF_OPTIMIZATIONS;i++)
    {
        if (g_dwMapOptLevelToDisabledList[i] == dwPerfFlags)
        {
            return i;
        }
    }

    DC_END_FN();
    //
    // Didn't find an entry so return the last optimization level (custom)
    //
    return (NUM_PERF_OPTIMIZATIONS-1);
}

//
// Called whenever a checkbox's state changes (Checked or unchecked)
//
//
VOID CPropPerf::OnCheckBoxStateChange(int checkBoxID)
{
    DWORD dwCheckBoxPerfFlags = 0;
    DWORD dwPerfFlags = 0;
    int optLevel = 0;
    int curSel = 0;
    DC_BEGIN_FN("OnCheckBoxStateChange");

    //
    // Pickup the current disabled feature list from the
    // checkboxes
    //
    dwCheckBoxPerfFlags = GetPerfFlagsFromCheckboxes();
    dwPerfFlags = MergePerfFlags( dwCheckBoxPerfFlags,
                                  _pTscSet->GetPerfFlags(),
                                  CHECK_BOX_PERF_MASK );



    //
    // Figure out the optimization level
    //
    optLevel = MapPerfFlagsToOptLevel(dwPerfFlags);

    TRC_ASSERT(optLevel >= 0 && optLevel < NUM_PERF_OPTIMIZATIONS,
               (TB,_T("optlevel %d out of range"), optLevel));

    //
    // If the combo is at a different opt level then switch it to
    // the new level
    //
    curSel = SendDlgItemMessage(_hwndDlg,
                                IDC_COMBO_PERF_OPTIMIZE,
                                CB_GETCURSEL,
                                0,0);

    //
    // Update the custom disabled list based on the current
    // settings
    //
    UpdateCustomDisabledList(dwPerfFlags);

    if (curSel != optLevel)
    {
        SendDlgItemMessage(_hwndDlg, IDC_COMBO_PERF_OPTIMIZE,CB_SETCURSEL,
                          (WPARAM)optLevel,0);
    }

    DC_END_FN();
}

//
// Queries the checkboxes and returns the disabled feature list
// as a DWORD of flags
//
DWORD CPropPerf::GetPerfFlagsFromCheckboxes()
{
    DWORD dwPerfFlags = 0;
    DC_BEGIN_FN("GetPerfFlagsFromCheckboxes");

    //
    // Wallpaper (Desktop background)
    //
    if (!IsDlgButtonChecked(_hwndDlg,IDC_CHECK_DESKTOP_BKND))
    {
        dwPerfFlags |= TS_PERF_DISABLE_WALLPAPER; 
    }

    //
    // Fullwindow drag
    //
    if (!IsDlgButtonChecked(_hwndDlg,IDC_CHECK_SHOW_FWD))
    {
        dwPerfFlags |= TS_PERF_DISABLE_FULLWINDOWDRAG; 
    }

    //
    // Menu animations
    //
    if (!IsDlgButtonChecked(_hwndDlg,IDC_CHECK_MENU_ANIMATIONS))
    {
        dwPerfFlags |= TS_PERF_DISABLE_MENUANIMATIONS; 
    }

    //
    // Themeing
    //
    if (!IsDlgButtonChecked(_hwndDlg,IDC_CHECK_THEMES))
    {
        dwPerfFlags |= TS_PERF_DISABLE_THEMING; 
    }

    //
    // Bitmap caching
    //
    if (!IsDlgButtonChecked(_hwndDlg,IDC_CHECK_BITMAP_CACHING))
    {
        dwPerfFlags |= TS_PERF_DISABLE_BITMAPCACHING; 
    }

    TRC_NRM((TB,_T("Return disable list 0x%x"),dwPerfFlags));

    DC_END_FN();
    return dwPerfFlags;
}

//
// Called to initialize the 'custom' disabled property
// list (e.g called at initialization time or after loading
// new settings
//
VOID CPropPerf::UpdateCustomDisabledList(DWORD dwPerfFlags)
{
    DC_BEGIN_FN("InitCustomDisabledList");

    //
    //
    //
    INT optLevel = MapPerfFlagsToOptLevel(dwPerfFlags);
    if (CUSTOM_OPTIMIZATION_LEVEL == optLevel)
    {
        //
        // Store this as the new set of custom settings
        //
        TRC_NRM((TB,_T("Recording new custom setting: 0x%x"),
                 dwPerfFlags));
        g_dwMapOptLevelToDisabledList[CUSTOM_OPTIMIZATION_LEVEL] =
            dwPerfFlags;
    }

    DC_END_FN();
}

BOOL CPropPerf::EnableCheckBoxes(BOOL fEnable)
{
    DC_BEGIN_FN("EnableCheckBoxes");

    //
    // Wallpaper (Desktop background)
    //
    EnableWindow( GetDlgItem(_hwndDlg, IDC_CHECK_DESKTOP_BKND),
                  fEnable );

    //
    // Fullwindow drag
    //
    EnableWindow( GetDlgItem(_hwndDlg, IDC_CHECK_SHOW_FWD),
                  fEnable );
    //
    // Menu animations
    //
    EnableWindow( GetDlgItem(_hwndDlg, IDC_CHECK_MENU_ANIMATIONS),
                  fEnable );

    //
    // Theming
    //
    EnableWindow( GetDlgItem(_hwndDlg, IDC_CHECK_THEMES),
                  fEnable );

    //
    // Bitmap caching
    //
    EnableWindow( GetDlgItem(_hwndDlg, IDC_CHECK_BITMAP_CACHING),
                  fEnable );

    //
    // Title static control
    //
    EnableWindow( GetDlgItem(_hwndDlg, UI_IDC_STATIC_OPTIMIZE_PERF),
                  fEnable );

    DC_END_FN();
    return TRUE;
}

//
// Merge perf flags from two sources
// 1) dwCheckBoxFlags - flags that come from the checkboxes
// 2) dwOrig set of passed in flags
//
// Use dwMask to preserve original flags that should not be affected
// by the checkboxes
//
// return - merged flags
//
DWORD CPropPerf::MergePerfFlags(DWORD dwCheckBoxFlags,
                                DWORD dwOrig,
                                DWORD dwMask)
{
    DWORD dwNewFlags;
    DC_BEGIN_FN("MergePerfFlags");

    dwNewFlags = (dwOrig & ~dwMask) | (dwCheckBoxFlags & dwMask);

    DC_END_FN();
    return dwNewFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\propperf.h ===
//
// propperf.h: local resources prop pg
//             Tab E - Performance TAB
//
// Copyright Microsoft Corportation 2000
// (nadima)
//

#ifndef _propperf_h_
#define _propperf_h_

#include "sh.h"
#include "tscsetting.h"
#include "tsperf.h"

//
// String table resources are cached in a global table
// and shared between this prop page and the main dialog
// page
//
#define PERF_OPTIMIZE_STRING_LEN    128
extern BOOL g_fPropPageStringMapInitialized;
typedef struct tag_PERFOPTIMIZESTRINGMAP
{
    int     resID;
    TCHAR   szString[PERF_OPTIMIZE_STRING_LEN];
} PERFOPTIMIZESTRINGMAP, *PPERFOPTIMIZESTRINGMAP;

extern PERFOPTIMIZESTRINGMAP g_PerfOptimizeStringTable[];

//
// Number of optimization levels
// these are
// 	Modem (28.8 Kbps)
//	Modem (56kbps)
//  Broadband (128 Kbps - 1.5 Mbps)
//	LAN (10Mbps or higher)
//	Custom (Defined in Options / Performance)

//
// The number of perf strings in g_PerfOptimizeStringTable must correspond
// to the number of optimzation levels
//
#define NUM_PERF_OPTIMIZATIONS    5
#define CUSTOM_OPTIMIZATION_LEVEL (NUM_PERF_OPTIMIZATIONS-1)

class CPropPerf
{
public:
    CPropPerf(HINSTANCE hInstance, CTscSettings* pTscSet, CSH* pSh);
    ~CPropPerf();

    static CPropPerf* CPropPerf::_pPropPerfInstance;
    static INT_PTR CALLBACK StaticPropPgPerfDialogProc (HWND hwndDlg,
                                                            UINT uMsg,
                                                            WPARAM wParam,
                                                            LPARAM lParam);
    void SetTabDisplayArea(RECT& rc) {_rcTabDispayArea = rc;}

    static DWORD MapOptimizationLevelToPerfFlags(int optLevel);
    static INT   MapPerfFlagsToOptLevel(DWORD dwDisableFeatureList);
    static VOID  UpdateCustomDisabledList(DWORD dwDisableFeatureList);
private:
    //Perf proppage
    INT_PTR CALLBACK PropPgPerfDialogProc (HWND hwndDlg,
                                               UINT uMsg,
                                               WPARAM wParam,
                                               LPARAM lParam);

    BOOL InitPerfCombo();
    VOID OnPerfComboSelChange();
    VOID OnCheckBoxStateChange(int checkBoxID);
    VOID SyncCheckBoxesToPerfFlags(DWORD dwDisableFeatureList);
    DWORD GetPerfFlagsFromCheckboxes();
    DWORD MergePerfFlags(DWORD dwCheckBoxFlags, DWORD dwOrig, DWORD dwMask);
    BOOL EnableCheckBoxes(BOOL fEnable);
private:
    CTscSettings*  _pTscSet;
    CSH*           _pSh;
    RECT           _rcTabDispayArea;
    HINSTANCE      _hInstance;
    HWND           _hwndDlg;
    BOOL           _fSyncingCheckboxes;
};


#endif // _propperf_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\propgeneral.cpp ===
//
// propgeneral.cpp: general property sheet dialog proc
// This is Tab A
//
// Copyright (C) Microsoft Corporation 2000
// (nadima)
//

#include "stdafx.h"


#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "propgeneral"
#include <atrcapi.h>

#include "propgeneral.h"
#include "sh.h"

#include "browsedlg.h"
#include "rdpfstore.h"

#define DUMMY_PASSWORD_TEXT TEXT("*||||||||@")

CPropGeneral* CPropGeneral::_pPropGeneralInstance = NULL;


//
// Controls that need to be disabled/enabled
// during connection (for progress animation)
//
CTL_ENABLE connectingDisableCtlsPGeneral[] = {
                        {IDC_GENERAL_COMBO_SERVERS, FALSE},
                        {IDC_GENERAL_EDIT_USERNAME, FALSE},
                        {IDC_GENERAL_EDIT_PASSWORD, FALSE},
                        {IDC_STATIC_PASSWORD, FALSE},
                        {IDC_GENERAL_EDIT_DOMAIN, FALSE},
                        {IDC_GENERAL_CHECK_SAVE_PASSWORD, FALSE},
                        {IDC_BUTTON_SAVE, FALSE},
                        {IDC_BUTTON_OPEN, FALSE}};

const UINT numConnectingDisableCtlsPGeneral =
                        sizeof(connectingDisableCtlsPGeneral)/
                        sizeof(connectingDisableCtlsPGeneral[0]);


CPropGeneral::CPropGeneral(HINSTANCE hInstance, CTscSettings* pTscSet, CSH* pSh) :
               _pSh(pSh)
{
    DC_BEGIN_FN("CPropGeneral");
    _hInstance = hInstance;
    CPropGeneral::_pPropGeneralInstance = this;

    _pTscSet = pTscSet;
    TRC_ASSERT(_pTscSet, (TB,_T("_pTscSet is null")));
    TRC_ASSERT(_pSh, (TB,_T("_pSh is null")));

    LoadGeneralPgStrings();

    DC_END_FN();
}

CPropGeneral::~CPropGeneral()
{
    CPropGeneral::_pPropGeneralInstance = NULL;
}

INT_PTR CALLBACK CPropGeneral::StaticPropPgGeneralDialogProc(HWND hwndDlg,
                                                             UINT uMsg,
                                                             WPARAM wParam,
                                                             LPARAM lParam)
{
    //
    // Delegate to appropriate instance (only works for single instance dialogs)
    //
    DC_BEGIN_FN("StaticDialogBoxProc");
    DCINT retVal = 0;

    TRC_ASSERT(_pPropGeneralInstance,
               (TB, _T("Logon dlg has NULL static inst ptr\n")));
    retVal = _pPropGeneralInstance->PropPgGeneralDialogProc( hwndDlg, uMsg,
                                                             wParam, lParam);

    DC_END_FN();
    return retVal;
}


INT_PTR CALLBACK CPropGeneral::PropPgGeneralDialogProc (
                                            HWND hwndDlg, UINT uMsg,
                                            WPARAM wParam, LPARAM lParam)
{
    DC_BEGIN_FN("PropPgGeneralDialogProc");

    switch(uMsg)
    {
        case WM_INITDIALOG:
        {
            //
            // Position the dialog within the tab
            //
            SetWindowPos( hwndDlg, HWND_TOP, 
                          _rcTabDispayArea.left, _rcTabDispayArea.top,
                          _rcTabDispayArea.right - _rcTabDispayArea.left,
                          _rcTabDispayArea.bottom - _rcTabDispayArea.top,
                          0);

            //
            // Setup username edit box
            //
            SetDlgItemText(hwndDlg, IDC_GENERAL_EDIT_USERNAME,
                (PDCTCHAR) _pTscSet->GetLogonUserName());

            //
            // Setup the server combo box
            //
            HWND hwndSrvCombo = GetDlgItem(hwndDlg,IDC_GENERAL_COMBO_SERVERS);
            CSH::InitServerAutoCmplCombo( _pTscSet, hwndSrvCombo);

            //
            // Update server combo edit field
            //
            SetDlgItemText(hwndDlg, IDC_GENERAL_COMBO_SERVERS,
                           _pTscSet->GetFlatConnectString());

            //Domain
            SendDlgItemMessage(hwndDlg,
                               IDC_GENERAL_EDIT_DOMAIN,
                               EM_LIMITTEXT,
                               SH_MAX_DOMAIN_LENGTH-1,
                               0);
            SetDlgItemText(hwndDlg, IDC_GENERAL_EDIT_DOMAIN,
                           _pTscSet->GetDomain());

            //password
            SendDlgItemMessage(hwndDlg,
                               IDC_GENERAL_EDIT_PASSWORD,
                               EM_LIMITTEXT,
                               SH_MAX_PASSWORD_LENGTH-1,
                               0);

#ifdef OS_WINCE
            SendDlgItemMessage(hwndDlg,
                               IDC_GENERAL_COMBO_SERVERS,
                               EM_LIMITTEXT,
                               SH_MAX_ADDRESS_LENGTH-1,
                               0);

            SendDlgItemMessage(hwndDlg,
                               IDC_GENERAL_EDIT_USERNAME,
                               EM_LIMITTEXT,
                               SH_MAX_USERNAME_LENGTH-1,
                               0);
#endif

            //
            // We're using an encrypted password directly from
            // the tscsettings, fill in the edit well with dummy
            // characters. This is to avoid having to fill
            // with the real password which can give a length
            // indication.
            //
            // Have to be carefull though, if the user changed
            // or added a password then we have a clear text
            // password present.
            //

            BOOL bPrevPassEdited = _pTscSet->GetUIPasswordEdited();
            if (_pTscSet->GetPasswordProvided() &&
                !_pTscSet->GetUIPasswordEdited())
            {
                SetDlgItemText(hwndDlg, IDC_GENERAL_EDIT_PASSWORD,
                               DUMMY_PASSWORD_TEXT);
            }
            else
            {
                HRESULT hr;
                TCHAR szClearPass[TSC_MAX_PASSLENGTH_TCHARS];
                memset(szClearPass, 0, sizeof(szClearPass));
                hr = _pTscSet->GetClearTextPass(szClearPass,
                                                sizeof(szClearPass));
                if (SUCCEEDED(hr))
                {
                    SetDlgItemText(hwndDlg, IDC_GENERAL_EDIT_PASSWORD,
                                   szClearPass);
                }
                else
                {
                    SetDlgItemText(hwndDlg, IDC_GENERAL_EDIT_PASSWORD,
                                   _T(""));
                }

                // Wipe stack copy.
                SecureZeroMemory( szClearPass, sizeof(szClearPass));
            }
            _pTscSet->SetUIPasswordEdited(bPrevPassEdited);

            if (_pSh->IsCryptoAPIPresent())
            {
                CheckDlgButton(hwndDlg, IDC_GENERAL_CHECK_SAVE_PASSWORD,
                    (_pTscSet->GetSavePassword() ? BST_CHECKED : BST_UNCHECKED));
            }
            else
            {
                CheckDlgButton(hwndDlg, IDC_GENERAL_CHECK_SAVE_PASSWORD,
                                BST_UNCHECKED);
                //
                // Disable the save password checkbox if no crypto api (e.g 9x)
                //
                EnableWindow(GetDlgItem(hwndDlg,
                                        IDC_GENERAL_CHECK_SAVE_PASSWORD),
                             FALSE);
            }

            OnChangeUserName( hwndDlg);

            _pSh->SH_ThemeDialogWindow(hwndDlg, ETDT_ENABLETAB);
            return TRUE;
        }
        break; //WM_INITDIALOG

        case WM_SAVEPROPSHEET: //Intentional fallthru
        case WM_DESTROY:
        {

            //
            // Save fields for when page reactivates
            //
            DlgToSettings(hwndDlg);
        }
        break; //WM_DESTROY

        case WM_TSC_ENABLECONTROLS:
        {
            //
            // wParam is TRUE to enable controls,
            // FALSE to disable them
            //
            CSH::EnableControls( hwndDlg,
                                 connectingDisableCtlsPGeneral,
                                 numConnectingDisableCtlsPGeneral,
                                 wParam ? TRUE : FALSE);
        }
        break;

        //
        // On return to connection UI
        // (e.g after a disconnection)
        //
        case WM_TSC_RETURNTOCONUI:
        {
            //
            // Reset the server combo to force it to repaint
            // this is a minor hack to fix the ComboBoxEx
            // which doesn't want to repaint itself on return
            // to the dialog.
            //
            HWND hwndSrvCombo = GetDlgItem(hwndDlg, IDC_GENERAL_COMBO_SERVERS);
            SetWindowText( hwndSrvCombo, _pTscSet->GetFlatConnectString());
        }
        break;

        case WM_COMMAND:
        {
            switch(DC_GET_WM_COMMAND_ID(wParam))
            {
                case IDC_GENERAL_COMBO_SERVERS:
                {
                    //
                    // Bring up the brwse for servers dlg
                    // if the user chose the last item in the combo
                    //
                    if(HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        CSH::HandleServerComboChange(
                                (HWND)lParam,
                                hwndDlg,
                                _hInstance,
                                (LPTSTR)_pTscSet->GetFlatConnectString()
                                );
                    }

                }
                break;

                case IDC_BUTTON_OPEN:
                {
                    OnLoad(hwndDlg);
                }
                break;

                case IDC_BUTTON_SAVE:
                {
                    OnSave(hwndDlg);
                }
                break;

                case IDC_GENERAL_EDIT_USERNAME:
                {
                    if(HIWORD(wParam) == EN_CHANGE)
                    {
                        OnChangeUserName(hwndDlg);
                    }
                }
                break;

                case IDC_GENERAL_EDIT_PASSWORD:
                {
                    if(HIWORD(wParam) == EN_CHANGE)
                    {
                        _pTscSet->SetUIPasswordEdited(TRUE);
                    }
                }
                break;
            }
        }
        break; //WM_COMMAND
    
    }

    DC_END_FN();
    return 0;
}

BOOL CPropGeneral::LoadGeneralPgStrings()
{
    DC_BEGIN_FN("LoadGeneralPgStrings");

    memset(_szFileTypeDescription, 0, sizeof(_szFileTypeDescription));
    if(!LoadString(_hInstance,
                   UI_IDS_REMOTE_DESKTOP_FILES,
                   _szFileTypeDescription,
                   SIZECHAR(_szFileTypeDescription)))
    {
        TRC_ERR((TB, _T("Failed to load UI_IDS_REMOTE_DESKTOP_FILES")));
        return FALSE;
    }

    DC_END_FN();
    return TRUE;
}

//
// OnSave event handler
// returns bool indiciating error
//
BOOL CPropGeneral::OnSave(HWND hwndDlg)
{
    DC_BEGIN_FN("OnSave");

    //
    // Bring up the save as dialog
    // and if necessary, save the file
    //

    TCHAR szPath[MAX_PATH];
    OPENFILENAME ofn;
    int         cchLen = 0;
    memset(&ofn, 0, sizeof(ofn));

    _tcsncpy(szPath, _pTscSet->GetFileName(), SIZECHAR(szPath)-1);
    szPath[SIZECHAR(szPath)-1] = 0;

#ifdef OS_WINCE
    ofn.lStructSize = sizeof( ofn );
#else
    ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400;
#endif

    ofn.hwndOwner = hwndDlg;
    ofn.hInstance = _hInstance;
    ofn.lpstrFile = szPath;
    ofn.nMaxFile  = SIZECHAR(szPath);
    ofn.lpstrFilter = _szFileTypeDescription;
    ofn.lpstrDefExt = RDP_FILE_EXTENSION_NODOT;
    ofn.Flags = OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;

    BOOL fRet = FALSE;
    if(GetSaveFileName(&ofn))
    {
        cchLen = _tcslen(szPath);
        if(cchLen >= MAX_PATH - SIZECHAR(RDP_FILE_EXTENSION))
        {
            //
            // If the path entered is too long, the common dlg
            // will not truncate and not append the .RDP extension
            // we don't want that so check and make the user
            // enter a shorter path
            //
            LPTSTR sz = szPath + cchLen - SIZECHAR(RDP_FILE_EXTENSION);
            if(_tcsicmp(sz, RDP_FILE_EXTENSION))
            {
                _pSh->SH_DisplayErrorBox(NULL,
                                         UI_IDS_PATHTOLONG,
                                         szPath);
                return FALSE;
            }
        }

        DlgToSettings(hwndDlg);

        CRdpFileStore rdpf;
        if(rdpf.OpenStore(szPath))
        {
            HRESULT hr = E_FAIL;
            hr = _pTscSet->SaveToStore(&rdpf);
            if(SUCCEEDED(hr))
            {
                if(rdpf.CommitStore())
                {
                    //Save last filename
                    _pTscSet->SetFileName(szPath);
                    fRet = TRUE;
                }
                else
                {
                    TRC_ERR((TB,_T("Unable to CommitStore settings")));
                }
            }
            else
            {
                TRC_ERR((TB,_T("Unable to save settings to store %d, %s"),
                          hr, szPath));
            }
            if(!fRet)
            {
                _pSh->SH_DisplayErrorBox(NULL,
                                         UI_IDS_ERR_SAVE,
                                         szPath);
            }

            rdpf.CloseStore();
            return fRet;
        }
        else
        {
            TRC_ERR((TB,_T("Unable to OpenStore for save %s"), szPath));
            _pSh->SH_DisplayErrorBox(NULL,
                                     UI_IDS_ERR_OPEN_FILE,
                                     szPath);
            return FALSE;
        }
    }
    else
    {
        //User canceled out, this is not a failure
        return TRUE;
    }


    DC_END_FN();
}

BOOL CPropGeneral::OnLoad(HWND hwndDlg)
{
    DC_BEGIN_FN("OnLoad");

    //
    // Bring up the Open dialog
    // and if necessary, save the file
    //

    TCHAR szPath[MAX_PATH];
    OPENFILENAME ofn;
    memset(&ofn, 0, sizeof(ofn));

    _tcsncpy(szPath, _pTscSet->GetFileName(), SIZECHAR(szPath)-1);
    szPath[SIZECHAR(szPath)-1] = 0;

#ifdef OS_WINCE
    ofn.lStructSize = sizeof( ofn );
#else
    ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400;
#endif

    ofn.hwndOwner = hwndDlg;
    ofn.hInstance = _hInstance;
    ofn.lpstrFile = szPath;
    ofn.nMaxFile  = SIZECHAR(szPath);
    ofn.lpstrFilter = _szFileTypeDescription;
    ofn.lpstrDefExt = TEXT("RDP");
    ofn.Flags = OFN_OVERWRITEPROMPT | OFN_FILEMUSTEXIST;

    BOOL fRet = FALSE;
    if(GetOpenFileName(&ofn))
    {
        CRdpFileStore rdpf;
        if(rdpf.OpenStore(szPath))
        {
            HRESULT hr = E_FAIL;
            hr = _pTscSet->LoadFromStore(&rdpf);
            if(SUCCEEDED(hr))
            {
                //Save last filename
                _pTscSet->SetFileName(szPath);

                //Need to trigger an update of the current dialog
                SendMessage(hwndDlg, WM_INITDIALOG, 0, 0);
                fRet = TRUE;
            }
            else
            {
                TRC_ERR((TB,_T("Unable LoadFromStore %d, %s"), hr, szPath));
                _pSh->SH_DisplayErrorBox(NULL,
                                         UI_IDS_ERR_LOAD,
                                         szPath);
            }

            rdpf.CloseStore();
            return fRet;
        }
        else
        {
            TRC_ERR((TB,_T("Unable to OpenStore for load %s"), szPath));
            _pSh->SH_DisplayErrorBox(NULL,
                                     UI_IDS_ERR_OPEN_FILE,
                                     szPath);
            return FALSE;
        }
    }
    else
    {
        //User canceled out, this is not a failure
        return TRUE;
    }

    DC_END_FN();
}

//
// Behave like winlogon for UPN
// Disable the Domain field if the user has entered an '@'
//
//
BOOL CPropGeneral::OnChangeUserName(HWND hwndDlg)
{
    DC_BEGIN_FN("OnChangeUserName");

    TCHAR szUserName[SH_MAX_USERNAME_LENGTH];
    GetDlgItemText( hwndDlg, IDC_GENERAL_EDIT_USERNAME,
                    szUserName, SIZECHAR(szUserName));

    BOOL fDisableDomain = FALSE;
    if(!_tcsstr(szUserName, TEXT("@")))
    {
        fDisableDomain = TRUE;
    }
    EnableWindow(GetDlgItem(hwndDlg, IDC_GENERAL_EDIT_DOMAIN),
                 fDisableDomain);

    DC_END_FN();
    return TRUE;
}

void CPropGeneral::DlgToSettings(HWND hwndDlg)
{
    TCHAR szServer[SH_MAX_ADDRESS_LENGTH];
    TCHAR szDomain[SH_MAX_DOMAIN_LENGTH];
    TCHAR szUserName[SH_MAX_USERNAME_LENGTH];
    BOOL  fSavePassword;

    GetDlgItemText( hwndDlg, IDC_GENERAL_EDIT_USERNAME,
                    szUserName, SIZECHAR(szUserName));
    _pTscSet->SetLogonUserName(szUserName);
                                   
    GetDlgItemText( hwndDlg, IDC_GENERAL_COMBO_SERVERS,
                    szServer, SIZECHAR(szServer));
    _pTscSet->SetConnectString(szServer);
    
    
    //
    // Pickup the password
    //
    if (_pTscSet->GetUIPasswordEdited())
    {
        TCHAR szClearPass[MAX_PATH];
        GetDlgItemText(hwndDlg, IDC_GENERAL_EDIT_PASSWORD,
                       szClearPass, SIZECHAR(szClearPass));
        _pTscSet->SetClearTextPass(szClearPass);

        // Wipe stack copy.
        SecureZeroMemory(szClearPass, sizeof(szClearPass));
    }

    fSavePassword = IsDlgButtonChecked(hwndDlg,
                                       IDC_GENERAL_CHECK_SAVE_PASSWORD);
    _pTscSet->SetSavePassword(fSavePassword);

    GetDlgItemText(hwndDlg, IDC_GENERAL_EDIT_DOMAIN,
       szDomain, SIZECHAR(szDomain));
    _pTscSet->SetDomain(szDomain);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\proprun.cpp ===
//
// proprun.cpp: local resources property sheet dialog proc
//
// Tab D
//
// Copyright Microsoft Corporation 2000
// nadima

#include "stdafx.h"


#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "proprun"
#include <atrcapi.h>

#include "sh.h"

#include "commctrl.h"
#include "proprun.h"

CPropRun* CPropRun::_pPropRunInstance = NULL;

//
// Controls that need to be disabled/enabled
// during connection (for progress animation)
//
CTL_ENABLE connectingDisableCtlsPRun[] = {
                        {IDC_CHECK_START_PROGRAM, FALSE},
                        {IDC_EDIT_STARTPROGRAM, FALSE},
                        {IDC_EDIT_WORKDIR, FALSE},
                        {IDC_STATIC_STARTPROGRAM, FALSE},
                        {IDC_STATIC_WORKDIR, FALSE},
                        };

const UINT numConnectingDisableCtlsPRun =
                        sizeof(connectingDisableCtlsPRun)/
                        sizeof(connectingDisableCtlsPRun[0]);


CPropRun::CPropRun(HINSTANCE hInstance, CTscSettings* pTscSet, CSH* pSh)
{
    DC_BEGIN_FN("CPropRun");
    _hInstance = hInstance;
    CPropRun::_pPropRunInstance = this;
    _pTscSet = pTscSet;
    _pSh = pSh;

    TRC_ASSERT(_pTscSet,(TB,_T("_pTscSet is null")));
    TRC_ASSERT(_pSh,(TB,_T("pSh is null")));

    DC_END_FN();
}

CPropRun::~CPropRun()
{
    CPropRun::_pPropRunInstance = NULL;
}

INT_PTR CALLBACK CPropRun::StaticPropPgRunDialogProc(HWND hwndDlg,
                                                               UINT uMsg,
                                                               WPARAM wParam,
                                                               LPARAM lParam)
{
    //
    // Delegate to appropriate instance (only works for single instance dialogs)
    //
    DC_BEGIN_FN("StaticDialogBoxProc");
    DCINT retVal = 0;

    TRC_ASSERT(_pPropRunInstance, (TB, _T("run dialog has NULL static instance ptr\n")));
    retVal = _pPropRunInstance->PropPgRunDialogProc( hwndDlg,
                                                               uMsg,
                                                               wParam,
                                                               lParam);

    DC_END_FN();
    return retVal;
}


INT_PTR CALLBACK CPropRun::PropPgRunDialogProc (HWND hwndDlg,
                                                          UINT uMsg,
                                                          WPARAM wParam,
                                                          LPARAM lParam)
{
    DC_BEGIN_FN("PropPgRunDialogProc");

    switch(uMsg)
    {
        case WM_INITDIALOG:
        {
#ifndef OS_WINCE
            int i;
#endif
            //
            // Position the dialog within the tab
            //
            SetWindowPos( hwndDlg, HWND_TOP, 
                          _rcTabDispayArea.left, _rcTabDispayArea.top,
                          _rcTabDispayArea.right - _rcTabDispayArea.left,
                          _rcTabDispayArea.bottom - _rcTabDispayArea.top,
                          0);

            //
            // Get settings
            //
            SetDlgItemText(hwndDlg, IDC_EDIT_STARTPROGRAM,
                (LPCTSTR) _pTscSet->GetStartProgram());

            SetDlgItemText(hwndDlg, IDC_EDIT_WORKDIR,
                (LPCTSTR) _pTscSet->GetWorkDir());

            CheckDlgButton(hwndDlg, IDC_CHECK_START_PROGRAM,
                           _pTscSet->GetEnableStartProgram() ?
                           BST_CHECKED : BST_UNCHECKED);

            EnableWindow(GetDlgItem(hwndDlg,
                                    IDC_EDIT_STARTPROGRAM),
                                    _pTscSet->GetEnableStartProgram());
            EnableWindow(GetDlgItem(hwndDlg,
                                    IDC_EDIT_WORKDIR),
                                    _pTscSet->GetEnableStartProgram());
            EnableWindow(GetDlgItem(hwndDlg,
                                    IDC_STATIC_STARTPROGRAM),
                                    _pTscSet->GetEnableStartProgram());
            EnableWindow(GetDlgItem(hwndDlg,
                                    IDC_STATIC_WORKDIR),
                                    _pTscSet->GetEnableStartProgram());

            _pSh->SH_ThemeDialogWindow(hwndDlg, ETDT_ENABLETAB);
            return TRUE;
        }
        break; //WM_INITDIALOG

        case WM_TSC_ENABLECONTROLS:
        {
            //
            // wParam is TRUE to enable controls,
            // FALSE to disable them
            //
            CSH::EnableControls( hwndDlg,
                                 connectingDisableCtlsPRun,
                                 numConnectingDisableCtlsPRun,
                                 wParam ? TRUE : FALSE);
        }
        break;


        case WM_SAVEPROPSHEET: //Intentional fallthru
        case WM_DESTROY:
        {
            //
            // Save page settings
            //
            BOOL fStartProgEnabled = IsDlgButtonChecked(hwndDlg,
                                                    IDC_CHECK_START_PROGRAM);
            _pTscSet->SetEnableStartProgram(fStartProgEnabled);
            TCHAR szStartProg[MAX_PATH];
            TCHAR szWorkDir[MAX_PATH];
            GetDlgItemText(hwndDlg,
                           IDC_EDIT_STARTPROGRAM,
                           szStartProg,
                           SIZECHAR(szStartProg));
            GetDlgItemText(hwndDlg,
                           IDC_EDIT_WORKDIR,
                           szWorkDir,
                           SIZECHAR(szWorkDir));

            _pTscSet->SetStartProgram(szStartProg);
            _pTscSet->SetWorkDir(szWorkDir);
        }
        break; //WM_DESTROY

        case WM_COMMAND:
        {
            if(BN_CLICKED == HIWORD(wParam) &&
               IDC_CHECK_START_PROGRAM == (int)LOWORD(wParam))
            {
                BOOL fStartProgEnabled = IsDlgButtonChecked(hwndDlg,
                                      IDC_CHECK_START_PROGRAM);

                EnableWindow(GetDlgItem(hwndDlg,
                                        IDC_EDIT_STARTPROGRAM),
                                        fStartProgEnabled);
                EnableWindow(GetDlgItem(hwndDlg,
                                        IDC_EDIT_WORKDIR),
                                        fStartProgEnabled);

                EnableWindow(GetDlgItem(hwndDlg,
                                        IDC_STATIC_STARTPROGRAM),
                                        fStartProgEnabled);
                EnableWindow(GetDlgItem(hwndDlg,
                                        IDC_STATIC_WORKDIR),
                                        fStartProgEnabled);

                _pTscSet->SetEnableStartProgram(fStartProgEnabled);
            }

        }
        break;
    }

    DC_END_FN();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\proplocalres.h ===
//
// proplocalres.h: local resources prop pg
//                Tab C
//
// Copyright Microsoft Corportation 2000
// (nadima)
//

#ifndef _proplocalres_h_
#define _proplocalres_h_

#include "sh.h"
#include "tscsetting.h"

class CPropLocalRes
{
public:
    CPropLocalRes(HINSTANCE hInstance, CTscSettings* pTscSet, CSH* pSh);
    ~CPropLocalRes();

    static CPropLocalRes* CPropLocalRes::_pPropLocalResInstance;
    static INT_PTR CALLBACK StaticPropPgLocalResDialogProc (HWND hwndDlg,
                                                            UINT uMsg,
                                                            WPARAM wParam,
                                                            LPARAM lParam);
    void SetTabDisplayArea(RECT& rc) {_rcTabDispayArea = rc;}
private:
    //Local resources tab
    INT_PTR CALLBACK PropPgLocalResDialogProc (HWND hwndDlg,
                                               UINT uMsg,
                                               WPARAM wParam,
                                               LPARAM lParam);

    //
    // Tab property page helpers
    //
    BOOL LoadLocalResourcesPgStrings();
    void InitSendKeysToServerCombo(HWND hwndPropPage);
    void InitPlaySoundCombo(HWND hwndPropPage);
    int  MapComboIdxSoundRedirMode(int idx);

private:
    CTscSettings*  _pTscSet;
    CSH*           _pSh;
    RECT           _rcTabDispayArea;
    HINSTANCE      _hInstance;

    //Strings for keyboard hooking feature
    TCHAR          _szSendKeysInFScreen[SH_DISPLAY_STRING_MAX_LENGTH];
    TCHAR          _szSendKeysAlways[SH_DISPLAY_STRING_MAX_LENGTH];
    TCHAR          _szSendKeysNever[SH_DISPLAY_STRING_MAX_LENGTH];

    //Strings for sound options
    TCHAR          _szPlaySoundLocal[SH_DISPLAY_STRING_MAX_LENGTH];
    TCHAR          _szPlaySoundRemote[SH_DISPLAY_STRING_MAX_LENGTH];
    TCHAR          _szPlaySoundNowhere[SH_DISPLAY_STRING_MAX_LENGTH];
    BOOL           _fRunningOnWin9x;
};


#endif // _proplocalres_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\proplocalres.cpp ===
//
// proplocalres.cpp: local resources property sheet dialog proc
//
// Tab B
//
// Copyright Microsoft Corporation 2000
// nadima

#include "stdafx.h"


#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "proplocalres"
#include <atrcapi.h>

#include "sh.h"

#include "commctrl.h"
#include "proplocalres.h"

#ifdef OS_WINCE
#include <ceconfig.h>
#endif

//
// Controls that need to be disabled/enabled
// during connection (for progress animation)
//
CTL_ENABLE connectingDisableCtlsPLocalRes[] = {
                        {IDC_COMBO_SOUND_OPTIONS, FALSE},
                        {IDC_COMBO_SEND_KEYS, FALSE},
                        {IDC_CHECK_REDIRECT_DRIVES, FALSE},
                        {IDC_CHECK_REDIRECT_PRINTERS, FALSE},
                        {IDC_CHECK_REDIRECT_COM, FALSE},
                        {IDC_CHECK_REDIRECT_SMARTCARD, FALSE}
                        };

const UINT numConnectingDisableCtlsPLocalRes =
                        sizeof(connectingDisableCtlsPLocalRes)/
                        sizeof(connectingDisableCtlsPLocalRes[0]);


CPropLocalRes* CPropLocalRes::_pPropLocalResInstance = NULL;

CPropLocalRes::CPropLocalRes(HINSTANCE hInstance, CTscSettings* pTscSet, CSH* pSh)
{
    DC_BEGIN_FN("CPropLocalRes");
    _hInstance = hInstance;
    CPropLocalRes::_pPropLocalResInstance = this;
    _pTscSet = pTscSet;
    _pSh = pSh;

    TRC_ASSERT(_pTscSet,(TB,_T("_pTscSet is null")));
    TRC_ASSERT(_pSh,(TB,_T("_pSh is null")));

    if(!LoadLocalResourcesPgStrings())
    {
        TRC_ERR((TB, _T("Failed LoadLocalResourcesPgStrings()")));
    }

    //
    // Disable keyb hook on win9x.
    //
    _fRunningOnWin9x = FALSE;

#ifdef OS_WINCE
    OSVERSIONINFO   osVersionInfo;
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
#else
    OSVERSIONINFOA   osVersionInfo;
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
#endif

    //call A version to avoid wrapping
#ifdef OS_WINCE
    if(GetVersionEx(&osVersionInfo))
#else
    if(GetVersionExA(&osVersionInfo))
#endif
    {
        _fRunningOnWin9x = (osVersionInfo.dwPlatformId ==
                            VER_PLATFORM_WIN32_WINDOWS);
    }
    else
    {
        _fRunningOnWin9x = FALSE;
        TRC_ERR((TB,_T("GetVersionEx failed: %d\n"), GetLastError()));
    }


    DC_END_FN();
}

CPropLocalRes::~CPropLocalRes()
{
    CPropLocalRes::_pPropLocalResInstance = NULL;
}

INT_PTR CALLBACK CPropLocalRes::StaticPropPgLocalResDialogProc(HWND hwndDlg,
                                                               UINT uMsg,
                                                               WPARAM wParam,
                                                               LPARAM lParam)
{
    //
    // Delegate to appropriate instance (only works for single instance dialogs)
    //
    DC_BEGIN_FN("StaticDialogBoxProc");
    DCINT retVal = 0;

    TRC_ASSERT(_pPropLocalResInstance, (TB, _T("localres dialog has NULL static instance ptr\n")));
    retVal = _pPropLocalResInstance->PropPgLocalResDialogProc( hwndDlg,
                                                               uMsg,
                                                               wParam,
                                                               lParam);

    DC_END_FN();
    return retVal;
}


INT_PTR CALLBACK CPropLocalRes::PropPgLocalResDialogProc (HWND hwndDlg,
                                                          UINT uMsg,
                                                          WPARAM wParam,
                                                          LPARAM lParam)
{
    DC_BEGIN_FN("PropPgLocalResDialogProc");

    switch(uMsg)
    {
        case WM_INITDIALOG:
        {
#ifndef OS_WINCE
            int i;
#endif
            //
            // Position the dialog within the tab
            //
            SetWindowPos( hwndDlg, HWND_TOP, 
                          _rcTabDispayArea.left, _rcTabDispayArea.top,
                          _rcTabDispayArea.right - _rcTabDispayArea.left,
                          _rcTabDispayArea.bottom - _rcTabDispayArea.top,
                          0);
            
            InitSendKeysToServerCombo(hwndDlg);
            InitPlaySoundCombo(hwndDlg);

            BOOL fDriveRedir = _pTscSet->GetDriveRedirection();
            CheckDlgButton(hwndDlg, IDC_CHECK_REDIRECT_DRIVES,
                (fDriveRedir ? BST_CHECKED : BST_UNCHECKED));

            BOOL fPrinterRedir = _pTscSet->GetPrinterRedirection();
            CheckDlgButton(hwndDlg, IDC_CHECK_REDIRECT_PRINTERS,
                (fPrinterRedir ? BST_CHECKED : BST_UNCHECKED));

            BOOL fCOMRedir = _pTscSet->GetCOMPortRedirection();
            CheckDlgButton(hwndDlg, IDC_CHECK_REDIRECT_COM,
                (fCOMRedir ? BST_CHECKED : BST_UNCHECKED));

            BOOL fScardRedir = _pTscSet->GetSCardRedirection();
            CheckDlgButton(hwndDlg, IDC_CHECK_REDIRECT_SMARTCARD,
                (fScardRedir ? BST_CHECKED : BST_UNCHECKED));

#ifdef OS_WINCE
            if ((GetFileAttributes(PRINTER_APPLET_NAME) == -1) ||
                (g_CEConfig == CE_CONFIG_WBT))
            {
                ShowWindow(GetDlgItem(hwndDlg,IDC_SETUP_PRINTER),SW_HIDE);
            }
#endif
            if(!CUT::IsSCardReaderInstalled())
            {
                //
                // Hide the SCard checkbox
                //
                ShowWindow(GetDlgItem(hwndDlg,IDC_CHECK_REDIRECT_SMARTCARD),
                           SW_HIDE);
            }

            _pSh->SH_ThemeDialogWindow(hwndDlg, ETDT_ENABLETAB);
            return TRUE;
        }
        break; //WM_INITDIALOG

        case WM_TSC_ENABLECONTROLS:
        {
            //
            // wParam is TRUE to enable controls,
            // FALSE to disable them
            //
            CSH::EnableControls( hwndDlg,
                                 connectingDisableCtlsPLocalRes,
                                 numConnectingDisableCtlsPLocalRes,
                                 wParam ? TRUE : FALSE);
        }
        break;

#ifdef OS_WINCE
        case WM_COMMAND:
        {
            switch(DC_GET_WM_COMMAND_ID(wParam))
            {
                case IDC_SETUP_PRINTER:
                    SHELLEXECUTEINFO sei;

                    memset(&sei,0,sizeof(SHELLEXECUTEINFO));
                    sei.cbSize = sizeof(sei);
                    sei.hwnd = hwndDlg;
                    sei.lpFile = L"ctlpnl.EXE";
                    sei.lpParameters = _T("wbtprncpl.dll,0");
                    sei.lpDirectory = NULL;
                    sei.nShow = SW_SHOWNORMAL;

                    ShellExecuteEx(&sei);

                    break;

                default:
                {
                    if ( (HIWORD(wParam) == BN_CLICKED) && (IDC_CHECK_REDIRECT_PRINTERS == (int)LOWORD(wParam)))
                    {
                        LRESULT lResult = SendMessage(GetDlgItem(hwndDlg,IDC_CHECK_REDIRECT_PRINTERS),
                                                      BM_GETCHECK,
                                                      0,
                                                      0);
                        if ((lResult == BST_CHECKED) && (GetFileAttributes(PRINTER_APPLET_NAME) != -1))
                        {
                            EnableWindow(GetDlgItem(hwndDlg,IDC_SETUP_PRINTER),TRUE);
                        }
                        else if (lResult == BST_UNCHECKED)
                        {
                            EnableWindow(GetDlgItem(hwndDlg,IDC_SETUP_PRINTER),FALSE);
                        }
                    }
                }
            }
        }
        break;
#endif

        case WM_SAVEPROPSHEET: //Intentional fallthru
        case WM_DESTROY:
        {
            //
            // Save page settings
            //
            
            //keyboard hook
            int keyboardHookMode = (int)SendMessage(
                GetDlgItem(hwndDlg, IDC_COMBO_SEND_KEYS),
                CB_GETCURSEL, 0, 0);
            _pTscSet->SetKeyboardHookMode(keyboardHookMode);

            //sound redirection
            int soundRedirIdx = (int)SendMessage(
                GetDlgItem(hwndDlg, IDC_COMBO_SOUND_OPTIONS),
                CB_GETCURSEL, 0, 0);

            int soundMode = MapComboIdxSoundRedirMode(soundRedirIdx);
            _pTscSet->SetSoundRedirectionMode( soundMode);

            //drive redirection
            BOOL fDriveRedir = IsDlgButtonChecked(hwndDlg, 
               IDC_CHECK_REDIRECT_DRIVES);
            _pTscSet->SetDriveRedirection(fDriveRedir);

            //printer redirection
            BOOL fPrinterRedir = IsDlgButtonChecked(hwndDlg, 
               IDC_CHECK_REDIRECT_PRINTERS);
            _pTscSet->SetPrinterRedirection(fPrinterRedir);

            //com port
            BOOL fCOMPortRedir = IsDlgButtonChecked(hwndDlg, 
               IDC_CHECK_REDIRECT_COM);
            _pTscSet->SetCOMPortRedirection(fCOMPortRedir);

            //scard
            BOOL fSCardRedir = IsDlgButtonChecked(hwndDlg,
               IDC_CHECK_REDIRECT_SMARTCARD);
            _pTscSet->SetSCardRedirection(fSCardRedir);

        }
        break; //WM_DESTROY
    }

    DC_END_FN();
    return 0;
}

//
// Load resources for the local resources dialog
//
BOOL CPropLocalRes::LoadLocalResourcesPgStrings()
{
    DC_BEGIN_FN("LoadLocalResourcesPgStrings");

    //
    // Load sendkeys strings
    //

#ifndef OS_WINCE
    if(!LoadString(_hInstance,
                   UI_IDS_SENDKEYS_FSCREEN,
                   _szSendKeysInFScreen,
                   sizeof(_szSendKeysInFScreen)/sizeof(TCHAR)))
    {
        TRC_ERR((TB, _T("Failed to load UI_IDS_FULLSCREEN")));
        return FALSE;
    }
#endif

    if(!LoadString(_hInstance,
                   UI_IDS_SENDKEYS_ALWAYS,
                   _szSendKeysAlways,
                   sizeof(_szSendKeysAlways)/sizeof(TCHAR)))
    {
        TRC_ERR((TB, _T("Failed to load UI_IDS_FULLSCREEN")));
        return FALSE;
    }

    if(!LoadString(_hInstance,
               UI_IDS_SENDKEYS_NEVER,
               _szSendKeysNever,
               sizeof(_szSendKeysNever)/sizeof(TCHAR)))
    {
        TRC_ERR((TB, _T("Failed to load UI_IDS_FULLSCREEN")));
        return FALSE;
    }

    //
    // Load playsound strings
    //
#ifdef OS_WINCE
    HINSTANCE hLibInst = NULL;
    if ((hLibInst = LoadLibrary(_T("WaveApi.dll"))) != NULL)
    {
#endif
        if(!LoadString(_hInstance,
                       UI_IDS_PLAYSOUND_LOCAL,
                       _szPlaySoundLocal,
                       sizeof(_szPlaySoundLocal)/sizeof(TCHAR)))
        {
            TRC_ERR((TB, _T("Failed to load UI_IDS_PLAYSOUND_LOCAL")));
            return FALSE;
        }
#ifdef OS_WINCE
        FreeLibrary(hLibInst);
    }
#endif

    if(!LoadString(_hInstance,
                   UI_IDS_PLAYSOUND_REMOTE,
                   _szPlaySoundRemote,
                   sizeof(_szPlaySoundRemote)/sizeof(TCHAR)))
    {
        TRC_ERR((TB, _T("Failed to load UI_IDS_PLAYSOUND_REMOTE")));
        return FALSE;
    }

    if(!LoadString(_hInstance,
               UI_IDS_PLAYSOUND_NOSOUND,
               _szPlaySoundNowhere,
               sizeof(_szPlaySoundNowhere)/sizeof(TCHAR)))
    {
        TRC_ERR((TB, _T("Failed to load UI_IDS_PLAYSOUND_NOSOUND")));
        return FALSE;
    }

    DC_END_FN();
    return TRUE;
}

void CPropLocalRes::InitSendKeysToServerCombo(HWND hwndPropPage)
{

    //
    // This call can be used to re-intialize a combo
    // so delete any items first
    //
#ifndef OS_WINCE
    INT ret = 1;
    while(ret && ret != CB_ERR)
    {
        ret = SendDlgItemMessage(hwndPropPage,
                                 IDC_COMBO_SEND_KEYS,
                                 CBEM_DELETEITEM,
                                 0,0);
    }
#else
    SendDlgItemMessage(hwndPropPage, IDC_COMBO_SEND_KEYS, CB_RESETCONTENT, 0, 0);
#endif

    //Order of the string has to match the keyboard
    //hook mode options.
    SendDlgItemMessage(hwndPropPage,
        IDC_COMBO_SEND_KEYS,
        CB_ADDSTRING,
        0,
        (LPARAM)(PDCTCHAR)_szSendKeysNever);

    SendDlgItemMessage(hwndPropPage,
        IDC_COMBO_SEND_KEYS,
        CB_ADDSTRING,
        0,
        (LPARAM)(PDCTCHAR)_szSendKeysAlways);

#ifndef OS_WINCE
    SendDlgItemMessage(hwndPropPage,
        IDC_COMBO_SEND_KEYS,
        CB_ADDSTRING,
        0,
        (LPARAM)(PDCTCHAR)_szSendKeysInFScreen);
#endif
    

    if(!_fRunningOnWin9x)
    {
        SendDlgItemMessage(hwndPropPage, IDC_COMBO_SEND_KEYS,
                           CB_SETCURSEL,
                           (WPARAM)_pTscSet->GetKeyboardHookMode(),0);
    }
    else
    {
        //Feature disabled on 9x, force selection to first option
        //and disable UI so it can't be changed.
        SendDlgItemMessage(hwndPropPage, IDC_COMBO_SEND_KEYS,
                           CB_SETCURSEL,
                           (WPARAM)0,0);
        EnableWindow(GetDlgItem(hwndPropPage,IDC_COMBO_SEND_KEYS), FALSE);
    }

}

void CPropLocalRes::InitPlaySoundCombo(HWND hwndPropPage)
{

    //
    // This call can be used to re-intialize a combo
    // so delete any items first
    //
#ifndef OS_WINCE
    INT ret = 1;
    while(ret && ret != CB_ERR)
    {
        ret = SendDlgItemMessage(hwndPropPage,
                                 IDC_COMBO_SOUND_OPTIONS,
                                 CBEM_DELETEITEM,
                                 0,0);
    }
#else
    SendDlgItemMessage(hwndPropPage, IDC_COMBO_SOUND_OPTIONS, CB_RESETCONTENT, 0, 0);
#endif


    //Order of the string has to match the sound
    //mode options.
#ifdef OS_WINCE
    HINSTANCE hLibInst = NULL;
    if ((hLibInst = LoadLibrary(_T("WaveApi.dll"))) != NULL)
    {
#endif
        SendDlgItemMessage(hwndPropPage,
            IDC_COMBO_SOUND_OPTIONS,
            CB_ADDSTRING,
            0,
            (LPARAM)(PDCTCHAR)_szPlaySoundLocal);
#ifdef OS_WINCE
        FreeLibrary(hLibInst);
    }
#endif
    SendDlgItemMessage(hwndPropPage,
        IDC_COMBO_SOUND_OPTIONS,
        CB_ADDSTRING,
        0,
        (LPARAM)(PDCTCHAR)_szPlaySoundNowhere);

    SendDlgItemMessage(hwndPropPage,
        IDC_COMBO_SOUND_OPTIONS,
        CB_ADDSTRING,
        0,
        (LPARAM)(PDCTCHAR)_szPlaySoundRemote);

    int soundIdx = MapComboIdxSoundRedirMode(_pTscSet->GetSoundRedirectionMode());
    SendDlgItemMessage(hwndPropPage, IDC_COMBO_SOUND_OPTIONS,
                       CB_SETCURSEL,(WPARAM)(WPARAM)
                       soundIdx,0);

}

//
// Maps from the sound combo index to the
// appropriate sound mode value
// what happened here is that the two bottom strings
// in the combo were flipped (the function is bidirectional)
//
int CPropLocalRes::MapComboIdxSoundRedirMode(int idx)
{
    int ret=0;
    switch (idx)
    {
    case 0:
        return 0;
    case 1:
        return 2;
    case 2:
        return 1;
    default:
        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\proprun.h ===
//
// proprun.h: local resources prop pg
//                Tab D
//
// Copyright Microsoft Corportation 2000
// (nadima)
//

#ifndef _proprun_h_
#define _proprun_h_

#include "sh.h"
#include "tscsetting.h"

class CPropRun
{
public:
    CPropRun(HINSTANCE hInstance, CTscSettings* pTscSet, CSH* pSh);
    ~CPropRun();

    static CPropRun* CPropRun::_pPropRunInstance;
    static INT_PTR CALLBACK StaticPropPgRunDialogProc (HWND hwndDlg,
                                                            UINT uMsg,
                                                            WPARAM wParam,
                                                            LPARAM lParam);

    void SetTabDisplayArea(RECT& rc) {_rcTabDispayArea = rc;}
private:
    //Local resources tab
    INT_PTR CALLBACK PropPgRunDialogProc (HWND hwndDlg,
                                               UINT uMsg,
                                               WPARAM wParam,
                                               LPARAM lParam);
private:
    CTscSettings*  _pTscSet;
    CSH*           _pSh;
    RECT           _rcTabDispayArea;
    HINSTANCE      _hInstance;
};


#endif // _proprun_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\rdrwrndlg.cpp ===
//
// rdrwrndlg.cpp Device redirection security warning dialog
//

#include "stdafx.h"

#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "rdrwrndlg"
#include <atrcapi.h>

#include "rdrwrndlg.h"
#include "autreg.h"

CRedirectPromptDlg* CRedirectPromptDlg::_pRedirectPromptDlgInstance = NULL;

CRedirectPromptDlg::CRedirectPromptDlg( HWND hwndOwner, HINSTANCE hInst,
                                        DWORD dwRedirectionsSpecified) :
                    CDlgBase( hwndOwner, hInst, UI_IDD_RDC_SECURITY_WARN),
                    _dwRedirectionsSpecified(dwRedirectionsSpecified)
{
    DC_BEGIN_FN("CRedirectPromptDlg");
    TRC_ASSERT((NULL == CRedirectPromptDlg::_pRedirectPromptDlgInstance), 
               (TB,_T("Clobbering existing dlg instance pointer\n")));

    TRC_ASSERT(_dwRedirectionsSpecified,(TB,
        _T("Redirection security dialog called with no redirs enabled")));

    CRedirectPromptDlg::_pRedirectPromptDlgInstance = this;

    _fNeverPromptMeAgain = FALSE;

    DC_END_FN();
}

CRedirectPromptDlg::~CRedirectPromptDlg()
{
    CRedirectPromptDlg::_pRedirectPromptDlgInstance = NULL;
}

DCINT CRedirectPromptDlg::DoModal()
{
    DCINT retVal = 0;
    DC_BEGIN_FN("DoModal");

    retVal = DialogBox(_hInstance, MAKEINTRESOURCE(_dlgResId),
                       _hwndOwner, StaticDialogBoxProc);
    TRC_ASSERT((retVal != 0 && retVal != -1), (TB, _T("DialogBoxParam failed\n")));

    DC_END_FN();
    return retVal;
}

INT_PTR CALLBACK CRedirectPromptDlg::StaticDialogBoxProc(HWND hwndDlg,
                                                         UINT uMsg,
                                                         WPARAM wParam,
                                                         LPARAM lParam)
{
    //
    // Delegate to appropriate instance (only works for single instance dialogs)
    //
    DC_BEGIN_FN("StaticDialogBoxProc");
    DCINT retVal = 0;

    TRC_ASSERT(_pRedirectPromptDlgInstance,
               (TB, _T("Redirect warn dialog has NULL static instance ptr\n")));
    if(_pRedirectPromptDlgInstance)
    {
        retVal = _pRedirectPromptDlgInstance->DialogBoxProc(hwndDlg,
                                                            uMsg,
                                                            wParam,
                                                            lParam);
    }

    DC_END_FN();
    return retVal;
}

//
// Name: DialogBoxProc
//
// Purpose: Handles CRedirectPromptDlg dialog box
//
// Returns: TRUE if message dealt with
//          FALSE otherwise
//
// Params: See window documentation
//
//
INT_PTR CALLBACK CRedirectPromptDlg::DialogBoxProc(HWND hwndDlg,
                                                   UINT uMsg,
                                                   WPARAM wParam,
                                                   LPARAM lParam)
{
    INT_PTR rc = FALSE;

    DC_BEGIN_FN("DialogBoxProc");

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            _hwndDlg = hwndDlg;
            //Center the redirectprompt dialog on the screen
            CenterWindow(NULL);
            SetDialogAppIcon(hwndDlg);

            TCHAR szRedirectList[MAX_PATH];

            //
            // Get a string representing the redirection options
            //
            if (GetRedirectListString( szRedirectList, MAX_PATH - 1))
            {
                szRedirectList[MAX_PATH-1] = 0;
                SetDlgItemText(hwndDlg,
                               UI_IDC_STATIC_DEVICES,
                               szRedirectList);
            }

            rc = TRUE;
        }
        break;

        case WM_COMMAND:
        {
            switch (DC_GET_WM_COMMAND_ID(wParam))
            {
                case IDOK:
                {
                    _fNeverPromptMeAgain = IsDlgButtonChecked(hwndDlg,
                                                UI_IDC_CHECK_NOPROMPT);
                    EndDialog(hwndDlg, IDOK);
                }
                break;

                case IDCANCEL:
                {
                    EndDialog(hwndDlg, IDCANCEL);
                }
                break;
            }
        }
        break;

        default:
        {
            rc = CDlgBase::DialogBoxProc(hwndDlg,
                                      uMsg,
                                      wParam,
                                      lParam);
        }
        break;

    }

    DC_END_FN();

    return(rc);

} /* CRedirectPromptDlg::DialogBoxProc */

BOOL CRedirectPromptDlg::GetRedirectListString(LPTSTR szBuf, UINT len)
{
    TCHAR szTemp[SH_DISPLAY_STRING_MAX_LENGTH];
    BOOL fResult = FALSE;
    INT lenRemain = (INT)len;

    DC_BEGIN_FN("GetRedirectListString");

    memset(szBuf, 0, len);
    
    if (_dwRedirectionsSpecified & REDIRSEC_DRIVES)
    {
        memset(szTemp, 0, sizeof(szTemp));
        if (LoadString(_hInstance,
                   UI_IDS_REDIRPROMPT_DRIVES,
                   szTemp,
                   SIZECHAR(szTemp) - 1))
        {
            _tcsncat(szBuf, szTemp, lenRemain);
            lenRemain -= (_tcslen(szTemp) + 2);

            if (lenRemain > 2)
            {
                _tcscat(szBuf, _T("\n"));
                lenRemain -= 2;
            }
            else
            {
                fResult = FALSE;
                DC_QUIT;
            }
        }
        else
        {
            fResult = FALSE;
            DC_QUIT;
        }
    }

    if (_dwRedirectionsSpecified & REDIRSEC_PORTS)
    {
        memset(szTemp, 0, sizeof(szTemp));
        if (LoadString(_hInstance,
                   UI_IDS_REDIRPROMPT_PORTS,
                   szTemp,
                   SIZECHAR(szTemp) - 1))
        {
            _tcsncat(szBuf, szTemp, lenRemain);
            lenRemain -= (_tcslen(szTemp) + 2);

            if (lenRemain > 2)
            {
                _tcscat(szBuf, _T("\n"));
                lenRemain -= 2;
            }
            else
            {
                fResult = FALSE;
                DC_QUIT;
            }
        }
        else
        {
            fResult = FALSE;
            DC_QUIT;
        }
    }

    fResult = TRUE;

DC_EXIT_POINT:    
    DC_END_FN();
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\resrc1.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by devuires.rc
//
#define IDC_CHECK_ENABLE_ARC            1148

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        136
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by devuires.rc
//
#define DS_WINCE_SPECIFIC               0
#define RESOLUTION_OFFSET               0
#define UI_CONNECTBTN_LEFT              7
#define IDI_COOLPC_ICON                 133
#define IDI_FOLDER_ICON                 134
#define IDC_BUTTON1                     1001
#define IDC_BUTTON2                     1002

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        136
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\rmigrate.h ===
//
// rmigrate.h
//
// Implementation of CTscRegMigrate
// 
// CTscRegMigrate migrates Tsc settings from the registry
// to .RDP files
//
// Copyright(C) Microsoft Corporation 2000
// Author: Nadim Abdo (nadima)
//
//

#ifndef _rmigrate_h_
#define _rmigrate_h_

#include "setstore.h"

class CTscRegMigrate
{
public:
    CTscRegMigrate();
    ~CTscRegMigrate();

    BOOL MigrateAll(LPTSTR szRootDirectory);
    BOOL MigrateSession(LPTSTR szSessionName, ISettingsStore* pStore,
                        BOOL fDeleteUnsafeRegKeys = FALSE);

private:
    BOOL MigrateHiveSettings(HKEY hKey,
                    LPCTSTR szRootName,
                    ISettingsStore* pSto);

    BOOL MigrateAsRealBinary(LPCTSTR szName);
    BOOL FilterStringMigrate(LPTSTR szName);

    BOOL MungeForWin2kDefaults(ISettingsStore* pSto);
#ifndef OS_WINCE
    BOOL ConvertPasswordFormat(ISettingsStore* pSto);
#endif

    BOOL DeleteRegValue(HKEY hKeyRoot,
                            LPCTSTR szRootName,
                            LPCTSTR szValueName);
    BOOL RemoveUnsafeRegEntries(HKEY hKeyRoot,
                                LPCTSTR szRootName);

};

#endif  _rmigrate_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\rdrwrndlg.h ===
//
// redirectpromptdlg.h: redirectprompt dialog class
//

#ifndef _redirectpromptdlg_h_
#define _redirectpromptdlg_h_

#include "dlgbase.h"
#include "sh.h"

class CRedirectPromptDlg : public CDlgBase
{
public:
    CRedirectPromptDlg(HWND hwndOwner, HINSTANCE hInst,
                       DWORD dwRedirectionsSpecified);
    ~CRedirectPromptDlg();

    virtual DCINT   DoModal();
    virtual INT_PTR CALLBACK DialogBoxProc(HWND hwndDlg,
                                           UINT uMsg,
                                           WPARAM wParam,
                                           LPARAM lParam);
    static  INT_PTR CALLBACK StaticDialogBoxProc(HWND hwndDlg,
                                                 UINT uMsg,
                                                 WPARAM wParam,
                                                 LPARAM lParam);

    
    BOOL    GetNeverPrompt()      {return _fNeverPromptMeAgain;}

    static CRedirectPromptDlg* _pRedirectPromptDlgInstance;

protected:
    BOOL   GetRedirectListString(LPTSTR szBuf, UINT len);


    
private:
    DWORD   _dwRedirectionsSpecified;
    BOOL    _fNeverPromptMeAgain;
};


#endif //_redirectpromptdlg_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\rdpfstore.cpp ===
//
// rdpfstore.cpp
//
// Implementation of CRdpFileStore, implements ISettingsStore
// 
// CRdpFileStore implements a persistent settings store for
// ts client settings.
//
//
// Copyright(C) Microsoft Corporation 2000
// Author: Nadim Abdo (nadima)
//

//
// Notes for improvement:
// Can add a hash lookup table to speedup FindRecord.
// (FindRecord is called at least once for each property that
//  is read/written during OpenStore/SaveStore operations)
// Most files contain maybe 5-10 records so speeding up
// the find is probably not that important.
//
// Copyright(C) Microsoft Corporation 2000
// Author: Nadim Abdo (nadima)
//

#include "stdafx.h"
#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "rdpfstore.cpp"
#include <atrcapi.h>

#include "rdpfstore.h"
#include "autil.h" //for StringToBinary/BinaryToString

//
// Index values must match RDPF_RECTYPE_*
//
LPCTSTR g_szTypeCodeMap[] =
{
    TEXT(":i:"),  //RDPF_RECTYPE_UINT
    TEXT(":s:"),  //RDPF_RECTYPE_SZ
    TEXT(":b:")   //RDPF_RECTYPE_BINARY
};

CRdpFileStore::CRdpFileStore()
{
    _cRef          = 1;
    _fReadOnly     = FALSE;
    _fOpenForRead  = FALSE;
    _fOpenForWrite = FALSE;
    _fIsDirty      = FALSE;
    _pRecordListHead= NULL;
    _pRecordListTail= NULL;
    _szFileName[0] = 0;
}

CRdpFileStore::~CRdpFileStore()
{
    DeleteRecords();
}

ULONG __stdcall CRdpFileStore::AddRef()
{
    DC_BEGIN_FN("AddRef");
    ULONG cref = InterlockedIncrement(&_cRef);
    TRC_ASSERT(cref > 0, (TB,_T("AddRef: cref is not > 0!")));
    DC_END_FN();
    return cref;
}

ULONG __stdcall CRdpFileStore::Release()
{
    DC_BEGIN_FN("Release");
    TRC_ASSERT(_cRef > 0, (TB,_T("AddRef: cref is not > 0!")));
    ULONG cref = InterlockedDecrement(&_cRef);
    if(0 == cref)
    {
        TRC_DBG((TB,_T("CRdpFileStore::Release deleting object")));
        delete this;
    }
    
    DC_END_FN();
    return cref;
}

STDMETHODIMP CRdpFileStore::QueryInterface(REFIID iid, void** p)
{
    UNREFERENCED_PARAMETER(iid);
    UNREFERENCED_PARAMETER(p);
    return E_NOTIMPL;
}

//
// OpenStore
// opens the RDP file, creating one if one doesn't exist
// The file existed it is parsed and readied for fast queries
//
// parameters:
//  szStoreMoniker - path to file
//  bReadyOnly     - specifies if file is to be opened readonly
//
BOOL CRdpFileStore::OpenStore(LPCTSTR szStoreMoniker, BOOL bReadOnly)
{
    DC_BEGIN_FN("OpenStore");

    TRC_ASSERT(szStoreMoniker, (TB, _T("szStoreMoniker parameter is NULL")));
    if(szStoreMoniker)
    {
        _fReadOnly = bReadOnly;
        
        HRESULT hr = StringCchCopy(_szFileName, SIZECHAR(_szFileName), szStoreMoniker);
        if (FAILED(hr)) {
            TRC_ERR((TB, _T("String copy failed: hr = 0x%x"), hr));
            memset(_szFileName, 0, sizeof(_szFileName));
            return FALSE;
        }

        //
        // Open the file, creating it if it doesn't exist
        //

        //
        // First try to open existing for rw
        //
        if (ERR_SUCCESS == _fs.OpenForRead( (LPTSTR)szStoreMoniker))
        {
            _fOpenForRead  = _fs.IsOpenForRead();
            _fOpenForWrite = !bReadOnly;
        }
        else
        {
            TRC_DBG((TB, _T("OpenStore could not _tfopen: %s."),
                                szStoreMoniker));
            return FALSE;
        }
        ParseFile();
    }
    else
    {
        return FALSE;
    }


    DC_END_FN();
    return TRUE;
}

//
// CommitStore
// commits the in memory representation of the file to the store
// this overwrites any existing contents in the file.
//
// File MUST have been opened with OpenStore
//
BOOL CRdpFileStore::CommitStore()
{
    DC_BEGIN_FN("CommitStore");
    PRDPF_RECORD node = NULL;
    TCHAR szBuf[LINEBUF_SIZE];
    int ret;

    if(_fOpenForWrite)
    {
        if(_fs.IsOpenForRead() || _fs.IsOpenForWrite())
        {
            _fs.Close();
        }
        //Reopen for write, nuking previous contents
        //Open as binary to allow UNICODE output
        if(ERR_SUCCESS == _fs.OpenForWrite(_szFileName, TRUE))
        {
            node = _pRecordListHead;
            while(node)
            {
                if(RecordToString(node, szBuf, LINEBUF_SIZE))
                {
                    ret = _fs.Write(szBuf);
                    if(ERR_SUCCESS != ret)
                    {
                        TRC_ABORT((TB,_T("Error writing to _fs: %d"),ret));
                        return FALSE;
                    }
                }
                else
                {
                    return FALSE;
                }
                node = node->pNext;
            }
            return TRUE;
        }
        else
        {
            TRC_ERR((TB,_T("OpenForWrite failed on file:%s"),_szFileName));
            return FALSE;
        }
    }
    else
    {
        TRC_ERR((TB,_T("Files was not opened for write:%s"),_szFileName));
        return FALSE;
    }

    DC_END_FN();
}

//
// CloseStore
// Closes the file, does NOT do a commit.
//
BOOL CRdpFileStore::CloseStore()
{
    DC_BEGIN_FN("CloseStore");
    if(_fs.IsOpenForRead() || _fs.IsOpenForWrite())
    {
        if(ERR_SUCCESS == _fs.Close())
        {
            _fReadOnly     = FALSE;
            _fOpenForRead  = FALSE;
            _fOpenForWrite = FALSE;
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }
    DC_END_FN();
}

BOOL CRdpFileStore::IsOpenForRead()
{
    return _fOpenForRead;
}

BOOL CRdpFileStore::IsOpenForWrite()
{
    return _fOpenForWrite;
}

BOOL CRdpFileStore::IsDirty()
{
    return _fIsDirty;
}

BOOL CRdpFileStore::SetDirtyFlag(BOOL bIsDirty)
{
    _fIsDirty = bIsDirty;
    return _fIsDirty;
}

//
// Typed read/write functions
//
BOOL CRdpFileStore::ReadString(LPCTSTR szName, LPTSTR szDefault,
                               LPTSTR szOutBuf, UINT strLen)
{
    PRDPF_RECORD node = NULL;
    HRESULT hr;
    
    DC_BEGIN_FN("ReadString");

    TRC_ASSERT(szName && szDefault && szOutBuf && strLen,
               (TB,_T("Invalid params to ReadString")));
    if(szName && szDefault && szOutBuf && strLen)
    {
        node = FindRecord(szName);
        if(node && node->recType == RDPF_RECTYPE_SZ)
        {
            hr = StringCchCopy(szOutBuf, strLen, node->u.szVal);
            if (SUCCEEDED(hr)) {
                return TRUE;
            } else {
                TRC_ERR((TB, _T("String copy failed: hr = 0x%x"), hr));
                return FALSE;
            }
        }
        else
        {
            //Fill with default
            hr = StringCchCopy(szOutBuf, strLen, szDefault);
            if (SUCCEEDED(hr)) {
                return TRUE;
            } else {
                TRC_ERR((TB, _T("String copy failed: hr = 0x%x"), hr));
                return FALSE;
            }
        }
    }
    else
    {
        return FALSE;
    }

    DC_END_FN();
}

//
// Writes a string to the store
// params
//  szName - key name
//  szDefault - default value (if writing default settings gets deleted)
//  szValue - value to write out
//  fIgnoreDefault - if set then always write ignoring szDefault
//
BOOL CRdpFileStore::WriteString(LPCTSTR szName, LPTSTR szDefault, LPTSTR szValue,
                                BOOL fIgnoreDefault)
{
    DC_BEGIN_FN("WriteString");
    TRC_ASSERT(szName && szValue,
               (TB,_T("Invalid params to WriteString")));
    if(szName && szValue)
    {
        if(szDefault && !fIgnoreDefault && !_tcscmp(szDefault,szValue))
        {
            //
            // Don't write out defaults
            //
            PRDPF_RECORD node = FindRecord(szName);
            if(node)
            {
                return DeleteRecord(node);
            }
            return TRUE;
        }
        else
        {
            BOOL bRet =
                InsertRecord(szName, RDPF_RECTYPE_SZ, szValue);
            return bRet;
        }
    }
    else
    {
        return FALSE;
    }

    DC_END_FN();
}

BOOL CRdpFileStore::ReadBinary(LPCTSTR szName, PBYTE pOutBuf, UINT cbBufLen)
{
    PRDPF_RECORD node = NULL;
    DC_BEGIN_FN("ReadBinary");

    TRC_ASSERT(szName && pOutBuf && cbBufLen,
               (TB,_T("Invalid params to ReadBinary")));
    if(szName && pOutBuf && cbBufLen)
    {
        node = FindRecord(szName);
        if(node && node->recType == RDPF_RECTYPE_BINARY)
        {
            if(node->dwBinValLen <= cbBufLen)
            {
                memcpy(pOutBuf, node->u.pBinVal, node->dwBinValLen);
                return TRUE;
            }
            else
            {
                TRC_ERR((TB,_T("Insufficient space in outbuf buf")));
                return FALSE;
            }
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }

    DC_END_FN();
}

BOOL CRdpFileStore::WriteBinary(LPCTSTR szName,PBYTE pBuf, UINT cbBufLen)
{
    DC_BEGIN_FN("WriteInt");

    TRC_ASSERT(szName && pBuf,
               (TB,_T("Invalid params to WriteBinary")));

    if(!cbBufLen)
    {
        return TRUE;
    }

    if(szName && pBuf)
    {
        BOOL bRet =
            InsertBinaryRecord(szName, pBuf, (DWORD)cbBufLen);
        return bRet;
    }
    else
    {
        return FALSE;
    }

    DC_END_FN();
}


BOOL CRdpFileStore::ReadInt(LPCTSTR szName, UINT defaultVal, PUINT pval)
{
    PRDPF_RECORD node = NULL;
    DC_BEGIN_FN("ReadInt");

    TRC_ASSERT(szName && pval,
               (TB,_T("Invalid params to ReadInt")));
    if(szName && pval)
    {
        node = FindRecord(szName);
        if(node && node->recType == RDPF_RECTYPE_UINT)
        {
            *pval = node->u.iVal;
            return TRUE;
        }
        else
        {
            *pval = defaultVal;
            return TRUE;
        }
    }
    else
    {
        return FALSE;
    }

    DC_END_FN();
}

//
// Writes an int to the store
// params
//  szName - key name
//  defaultVal - default value (if writing default settings gets deleted)
//  val - value to write out
//  fIgnoreDefault - if set then always write ignoring szDefault
//
BOOL CRdpFileStore::WriteInt(LPCTSTR szName, UINT defaultVal, UINT val,
                             BOOL fIgnoreDefault)
{
    DC_BEGIN_FN("WriteInt");

    TRC_ASSERT(szName,
               (TB,_T("Invalid params to WriteInt")));
    if(szName)
    {
        if(!fIgnoreDefault && defaultVal == val)
        {
            //
            // Don't write out default
            //
            PRDPF_RECORD node = FindRecord(szName);
            if(node)
            {
                return DeleteRecord(node);
            }
            return TRUE;
        }
        else
        {
            BOOL bRet =
                InsertIntRecord(szName, val);
            return bRet;
        }
    }
    else
    {
        return FALSE;
    }

    DC_END_FN();
}


BOOL CRdpFileStore::ReadBool(LPCTSTR szName, UINT defaultVal, PBOOL pbVal)
{
    DC_BEGIN_FN("ReadBool");
    UINT val;
    TRC_ASSERT(szName && pbVal,
               (TB,_T("Invalid params to ReadBool")));
    if(szName && pbVal)
    {
        if(ReadInt(szName, defaultVal, &val))
        {
            *pbVal = (BOOL)val;
            return TRUE;
        }
    }
    else
    {
        return FALSE;
    }

    DC_END_FN();
    return TRUE;
}

//
// Writes a bool to the store
// params
//  szName - key name
//  defaultVal - default value (if writing default settings gets deleted)
//  bVal - value to write out
//  fIgnoreDefault - if set then always write ignoring szDefault
//
BOOL CRdpFileStore::WriteBool(LPCTSTR szName, UINT defaultVal,BOOL bVal,
                              BOOL fIgnoreDefault)
{
    DC_BEGIN_FN("WriteBool");
    UINT iVal = bVal;
    BOOL bRet =
        WriteInt( szName, defaultVal, iVal, fIgnoreDefault);
    return bRet;

    DC_END_FN();
}



//
// ParseFile
// parses the _hFile into a reclist and associated namemap hash
//
BOOL CRdpFileStore::ParseFile()
{
    DC_BEGIN_FN("ParseFile");
    TRC_ASSERT(_fs.IsOpenForRead(), (TB,_T("Can't ParseFile on a closed FS")));
    if(!_fs.IsOpenForRead())
    {
        return FALSE;
    }

    //
    // Nuke any current in-memory state
    //
    DeleteRecords();

    //
    // Parse the file line by line into a RDPF_RECORD list
    //

    TCHAR szBuf[LINEBUF_SIZE];
    while(ERR_SUCCESS == _fs.ReadNextLine(szBuf, sizeof(szBuf)))
    {
        if(!InsertRecordFromLine(szBuf))
        {
            TRC_DBG((TB,_T("Parse error, aborting file parse")));
            return FALSE;
        }
    }

    _fs.Close();

    DC_END_FN();
    return TRUE;
}

//
// InsertRecordFromLine
// parses szLine into a record and adds to the record list
//
BOOL CRdpFileStore::InsertRecordFromLine(LPTSTR szLine)
{
    DC_BEGIN_FN("InsertRecordFromLine");
    TCHAR szNameField[LINEBUF_SIZE];
    UINT typeCode;
    TCHAR szValueField[LINEBUF_SIZE];
    BOOL fParseOk = FALSE;

    memset(szNameField,0,sizeof(szNameField));
    memset(szValueField,0,sizeof(szValueField));
    fParseOk = ParseLine(szLine, &typeCode, szNameField, szValueField);

    TRC_DBG((TB,_T("Parsed line into fields- name:'%s', value:'%s', typecode:'%d'"),
             szNameField,
             szValueField,
             typeCode));

    TRC_ASSERT(IS_VALID_RDPF_TYPECODE(typeCode),
               (TB,_T("typeCode %d is invalid"), typeCode));
    if(IS_VALID_RDPF_TYPECODE(typeCode))
    {
        //Create a new record for this line
        //and insert it into the reclist
        if(typeCode == RDPF_RECTYPE_UNPARSED)
        {
            //Unparsed line: Value is the whole line. Name ignored
            HRESULT hr = StringCchCopy(szValueField, SIZECHAR(szValueField), szLine);
            if (FAILED(hr)) {
                TRC_ERR((TB, _T("String copy failed: hr = 0x%x"), hr));
                return FALSE;
            }
        }
        //names are always lower case
        if(InsertRecord(_tcslwr(szNameField), typeCode, szValueField))
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        //
        // Invalid typecode
        //
        return FALSE;
    }

    DC_END_FN();
    return TRUE;
}

//
// ParseLine
// parses the lines into tokens, returns false
// if the line does not match the expected format
// 
// params
//    szLine        - line to parse
//    pTypeCode     - [OUT] typecode
//    szNameField   - [OUT] name field. (must be at least LINEBUF_SIZE)
//    szValueField  - [OUT] value field. (must be at least LINEBUF_SIZE)
//
//
BOOL CRdpFileStore::ParseLine(LPTSTR szLine,
                              PUINT pTypeCode,
                              LPTSTR szNameField,
                              LPTSTR szValueField)
{
    PTCHAR szWrite = NULL;
    TCHAR  szTypeCode;
    INT    writeCount = 0;
    DC_BEGIN_FN("ParseLine");

    //
    // Try to parse the line, if unable to parse it return
    // false.
    //
    // Format is "fieldname:szTypeCode:value"
    // e.g "server:s:localhost"
    //
    // szTypeCodes are:
    // s - string
    // i - UINT
    // b - binary blob (encoded)
    //
    TRC_ASSERT(szLine, (TB,_T("szLine is null")));
    TRC_ASSERT(pTypeCode, (TB,_T("pTypeCode is null")));
    TRC_ASSERT(szNameField, (TB,_T("szNameField is null")));
    TRC_ASSERT(szValueField, (TB,_T("szValueField is null")));
    if(szLine && pTypeCode && szNameField && szValueField)
    {
        //
        // parse the whole line in one pass
        // goto used on error case to avoid horrible nesting
        //
        PTCHAR sz = szLine;
        while(*sz && *sz == TCHAR(' '))
            sz++; //eat leading whitespace

        if(!*sz)
        {
            goto parse_error;
        }
        //Copy field 1
        PTCHAR szWrite = szNameField;
        writeCount = 0;
        while(*sz && *sz != TCHAR(':'))
        {
            *szWrite++ = *sz++;
            if(++writeCount > LINEBUF_SIZE)
            {
                TRC_ERR((TB,_T("Field1 exceeds max size. size: %d"),
                         writeCount));
                goto parse_error;
            }
        }
        *szWrite = NULL;

        if(*sz != TCHAR(':'))
        {
            goto parse_error;
            sz++;
        }
        sz++; //eat ':'
        while(*sz && *sz == TCHAR(' '))
            sz++; //eat whitespace
        if( *sz )
        {
            szTypeCode = isupper(*sz) ?
#ifndef OS_WINCE
                _tolower(*sz++)
#else
                towlower(*sz++)
#endif
            : *sz++;
            switch(szTypeCode)
            {
                case TCHAR('s'):
                    *pTypeCode = RDPF_RECTYPE_SZ;
                    break;
                case TCHAR('i'):
                    *pTypeCode = RDPF_RECTYPE_UINT;
                    break;
                case TCHAR('b'):
                    *pTypeCode = RDPF_RECTYPE_BINARY;
                    break;
                default:
                    TRC_ERR((TB,_T("Invalid szTypeCode in szLine '%s'"), szLine));
                    *pTypeCode = RDPF_RECTYPE_UNPARSED;
                    goto parse_error;
                    break;
            }
        }
        else
        {
            TRC_ERR((TB,_T("Invalid szTypeCode in szLine '%s'"), szLine));
            goto parse_error;
        }
        while(*sz && *sz == TCHAR(' '))
            sz++; //eat whitespace
        if(*sz != TCHAR(':'))
        {
            goto parse_error;
        }
        sz++; //eat ':'
        while(*sz && *sz == TCHAR(' '))
            sz++; //eat leading whitespace
        //rest of line is field3
        szWrite = szValueField;
        writeCount = 0;
        while(*sz && *sz != TCHAR('\n'))
        {
            *szWrite++ = *sz++;
            if(++writeCount > LINEBUF_SIZE)
            {
                TRC_ERR((TB,_T("Field1 exceeds max size. size: %d"),
                         writeCount));
                goto parse_error;
            }
        }
        *szWrite = NULL;
        return TRUE;
    }

parse_error:
    TRC_ERR((TB,_T("Parse error in line")));
    //Add an unknown record..it will be persisted back out to
    //the file (it could be from a newer file version)
    *pTypeCode = RDPF_RECTYPE_UNPARSED;
    DC_END_FN();
    return FALSE;
}

//
// InsertRecord
// inserts new record, modifies existing record
// if one exists with the same name field
//
BOOL CRdpFileStore::InsertRecord(LPCTSTR szName, UINT TypeCode, LPCTSTR szValue)
{
    DC_BEGIN_FN("InsertRecord");

    TRC_ASSERT(IS_VALID_RDPF_TYPECODE(TypeCode),
           (TB,_T("typeCode %d is invalid"), TypeCode));
    TRC_ASSERT(szName && szValue,
               (TB,_T("Invalid szName or szValue")));
    if(szName && szValue)
    {
        PRDPF_RECORD node;
        node = FindRecord(szName);
        if(node)
        {
            if(node->recType == TypeCode)
            {
                //
                // Existing record found, modify it's contents
                // first free any allocated memory in the current
                // node.
                //
                switch(TypeCode)
                {
                case RDPF_RECTYPE_SZ:
                    {
                        if(node->u.szVal)
                        {
                            LocalFree(node->u.szVal);
                        }
                    }
                    break;
                case RDPF_RECTYPE_BINARY:
                    {
                        if(node->u.pBinVal)
                        {
                            LocalFree(node->u.pBinVal);
                        }
                    }
                    break;
                case RDPF_RECTYPE_UNPARSED:
                    {
                        if(node->u.szUnparsed)
                        {
                            LocalFree(node->u.szUnparsed);
                        }
                    }
                    break;
                default:
                    {
                        return FALSE;
                    }
                    break;
                }

                //
                // Set the node value from the typecode
                //
                if(SetNodeValue(node, TypeCode, szValue))
                {
                    return TRUE;
                }
            }
            else
            {
                //
                // dup record of differing type
                //
                TRC_ASSERT(FALSE,(TB,_T("found duplicate record of differing type")));
                return FALSE;
            }
        }
        else
        {
            PRDPF_RECORD node = NewRecord(szName, TypeCode);
            if(node)
            {
                if(SetNodeValue(node, TypeCode, szValue))
                {
                    //Append the node to the end of the reclist
                    if(AppendRecord(node))
                    {
                        return TRUE;
                    }
                }
            }
            return FALSE;
        }
    }

    DC_END_FN();
    return FALSE;
}

//
// Sets node value based on a typecode
// this coaxes the value from the string form
//
// This function is the generic version that accepts the value as a string
// parameter. Automatic conversion are done to the appropriate type.
//
inline BOOL CRdpFileStore::SetNodeValue(PRDPF_RECORD pNode,
                                        RDPF_RECTYPE TypeCode,
                                        LPCTSTR szValue)
{
    DC_BEGIN_FN("SetNodeValue");

    TRC_ASSERT(pNode && szValue && IS_VALID_RDPF_TYPECODE(TypeCode),
               (TB,_T("Invalid SetNodeValue params")));
    if(pNode && szValue)
    {
        switch(TypeCode)
        {
            case RDPF_RECTYPE_UINT:
                {
                    pNode->u.iVal = _ttol(szValue);
                    return TRUE;
                }
                break;
    
            case RDPF_RECTYPE_SZ:
                {
                    pNode->u.szVal = (LPTSTR)LocalAlloc(LPTR,
                        sizeof(TCHAR)*(_tcslen(szValue)+1));
                    if(pNode->u.szVal)
                    {
                        _tcscpy(pNode->u.szVal,szValue);
                        return TRUE;
                    }
                    else
                    {
                        return FALSE;
                    }
                }
                break;
    
            case RDPF_RECTYPE_BINARY:
                {
                    //Convert from string form to actual binary bits
                    UINT strLen = _tcslen(szValue);
                    DWORD dwLen = 0;

                    //
                    // First get the buffer length
                    // (binaryToString returns the wrong length when the
                    //  null parameter is passed in).
                    dwLen = (strLen >> 1) + 2;

                    pNode->u.pBinVal = (PBYTE) LocalAlloc(LPTR, dwLen);
                    if(!pNode->u.pBinVal)
                    {
                        TRC_ERR((TB,_T("Failed to alloc %d bytes"), dwLen));
                        return FALSE;
                    }
                    memset(pNode->u.pBinVal,0,dwLen);
                    //
                    // Do the conversion
                    //
                    if(!CUT::BinarytoString( strLen, (LPTSTR)szValue,
                                        (PBYTE)pNode->u.pBinVal, &dwLen))
                    {
                        TRC_ERR((TB,_T("BinaryToString conversion failed")));
                        return FALSE;
                    }
                    pNode->dwBinValLen = dwLen;
                }
                break;
    
            case RDPF_RECTYPE_UNPARSED:
                {
                    pNode->u.szUnparsed = (LPTSTR)LocalAlloc(LPTR,
                           sizeof(TCHAR)*(_tcslen(szValue)+1));
                    if(pNode->u.szUnparsed)
                    {
                        _tcscpy(pNode->u.szUnparsed,szValue);
                        return TRUE;
                    }
                    else
                    {
                        return FALSE;
                    }
                }
                break;
    
            default:
                {
                    return FALSE;
                }
                break;
        }
    }
    else
    {
        return FALSE;
    }

    DC_END_FN();
    return TRUE;
}

//
// Inserts an int record (RDPF_RECTYPE_UINT)
// modifies existing record if one is found
//
BOOL CRdpFileStore::InsertIntRecord(LPCTSTR szName, UINT value)
{
    DC_BEGIN_FN("InsertIntRecord");

    TRC_ASSERT(szName,
               (TB,_T("Invalid szName")));
    if(szName)
    {
        PRDPF_RECORD node;
        node = FindRecord(szName);
        if(node)
        {
            if(node->recType == RDPF_RECTYPE_UINT)
            {
                //
                // Existing record found, modify it's contents
                //

                node->u.iVal = value;
                return TRUE;
            }
            else
            {
                //
                // dup record of differing type
                //
                TRC_ASSERT(FALSE,(TB,_T("found duplicate record of differing type")));
                return FALSE;
            }
        }
        else
        {
            PRDPF_RECORD node = NewRecord(szName, RDPF_RECTYPE_UINT);
            if(node)
            {
                node->u.iVal = value;
                //Append the node to the end of the reclist
                if(AppendRecord(node))
                {
                    return TRUE;
                }
            }
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }

    DC_END_FN();
}

//
// Insert a binary buffer record (RDPF_RECTYPE_BINARY)
// modifies existing record if one found
//
BOOL CRdpFileStore::InsertBinaryRecord(LPCTSTR szName, PBYTE pBuf, DWORD dwLen)
{
    DC_BEGIN_FN("InsertBinaryRecord");

    TRC_ASSERT(szName && pBuf && dwLen,
               (TB,_T("Invalid szName or pBuf")));
    if(szName)
    {
        PRDPF_RECORD node;
        node = FindRecord(szName);
        if(node)
        {
            if(node->recType == RDPF_RECTYPE_BINARY)
            {
                //
                // Existing record found, modify its contents
                //
                if(node->u.pBinVal)
                {
                    LocalFree(node->u.pBinVal);
                }

                node->u.pBinVal = (PBYTE) LocalAlloc(LPTR, dwLen);
                if(node->u.pBinVal)
                {
                    memcpy(node->u.pBinVal, pBuf, dwLen);
                    node->dwBinValLen = dwLen;
                    return TRUE;
                }
                else
                {
                    return FALSE;
                }

                return TRUE;
            }
            else
            {
                //
                // dup record of differing type
                //
                TRC_ASSERT(FALSE,(TB,_T("found duplicate record of differing type")));
                return FALSE;
            }
        }
        else
        {
            PRDPF_RECORD node = NewRecord(szName, RDPF_RECTYPE_BINARY);
            if(node)
            {
                node->u.pBinVal = (PBYTE) LocalAlloc(LPTR, dwLen);
                if(node->u.pBinVal)
                {
                    memcpy(node->u.pBinVal, pBuf, dwLen);
                    node->dwBinValLen = dwLen;
                    if(AppendRecord(node))
                    {
                        return TRUE;
                    }
                    else
                    {
                        return FALSE;
                    }
                }
                else
                {
                    return FALSE;
                }

            }
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }

    DC_END_FN();
}

//
// A worker function to make life easier in RecordToString. This function
// takes a source string, cats it to a destination string, and then appends
// a carriage return and line-feed.
//

HRESULT StringCchCatCRLF(LPTSTR pszDest, size_t cchDest, LPCTSTR pszSrc) 
{
    HRESULT hr = E_FAIL;
    
    DC_BEGIN_FN("StringCchCatCRLF");

    hr = StringCchCat(pszDest, cchDest, pszSrc);
    if (FAILED(hr)) {
        DC_QUIT;
    }
    hr = StringCchCat(pszDest, cchDest, _T("\r\n"));
    if (FAILED(hr)) {
        DC_QUIT;
    }

DC_EXIT_POINT:
    
    DC_END_FN();

    return hr;
}

//
// Flatten a record to a string (szBuf) using format:
// name:type:value\r\n
//
BOOL CRdpFileStore::RecordToString(PRDPF_RECORD pNode, LPTSTR szBuf, UINT strLen)
{
    DC_BEGIN_FN("RecordToString");
    TRC_ASSERT(pNode && szBuf && strLen,
               (TB,_T("Invalid parameters to RecordToString")));
    TCHAR szTemp[LINEBUF_SIZE];
    INT lenRemain = strLen;
    HRESULT hr;

    if(pNode && szBuf && strLen)
    {
        TRC_ASSERT(IS_VALID_RDPF_TYPECODE(pNode->recType),
                   (TB,_T("Invalid typecode %d"),pNode->recType));

        if(pNode->recType != RDPF_RECTYPE_UNPARSED)
        {
            // Space for name field, typecode, two delimiters and a NULL.
            lenRemain -= _tcslen(pNode->szName) + 4;
            if(lenRemain >= 0)
            {
                hr = StringCchPrintf(szBuf, strLen, _T("%s%s"), 
                                     pNode->szName,
                                     g_szTypeCodeMap[pNode->recType]);
                if (FAILED(hr)) {
                    TRC_ERR((TB, _T("String printf failed: hr = 0x%x"), hr));
                    return FALSE;
                }

                switch(pNode->recType)
                {
                    case RDPF_RECTYPE_UINT:
                    {
                        _stprintf(szTemp,TEXT("%d"),pNode->u.iVal);
                        // Need space for a "\r\n" sequence.
                        lenRemain -= _tcslen(szTemp) + 2; 
                        if(lenRemain >= 0)
                        {
                            hr = StringCchCatCRLF(szBuf, strLen, szTemp);
                            if (FAILED(hr)) {
                                TRC_ERR((TB, _T("String concatenation failed: hr = 0x%x"), hr));
                                return FALSE;
                            }
                            return TRUE;
                        }
                        else
                        {
                            return FALSE;
                        }
                    }
                    break;

                    case RDPF_RECTYPE_SZ:
                    {
                        // Need space for a "\r\n" sequence.
                        lenRemain -= _tcslen(pNode->u.szVal) + 2;
                        if(lenRemain >= 0)
                        {
                            hr = StringCchCatCRLF(szBuf, strLen, pNode->u.szVal);
                            if (FAILED(hr)) {
                                TRC_ERR((TB, _T("String concatenation failed: hr = 0x%x"), hr));
                                return FALSE;
                            }
                            return TRUE;
                        }
                        else
                        {
                            return FALSE;
                        }
                    }
                    break;

                    case RDPF_RECTYPE_BINARY:
                    {
                        DWORD dwLen;
                        //
                        // Convert the binary buffer to string form
                        //

                        //
                        // First get the buffer length
                        //
                        if(!CUT::StringtoBinary( pNode->dwBinValLen,
                                            (PBYTE)pNode->u.pBinVal,
                                             NULL, &dwLen))
                        {
                            TRC_ERR((TB,
                               _T("Failed to get StringtoBinary buffer len")));
                            return FALSE;
                        }
                        lenRemain -= dwLen;
                        if(lenRemain >= 0 && dwLen < LINEBUF_SIZE)
                        {
                            //
                            // Do the conversion
                            //
                            if(CUT::StringtoBinary( pNode->dwBinValLen,
                                               (PBYTE)pNode->u.pBinVal,
                                               (LPTSTR) szTemp, &dwLen))
                            {
                                //String to binary appends two trailing
                                //'0' characters. get rid of them.
                                szTemp[dwLen-2] = NULL;

                                hr = StringCchCatCRLF(szBuf, strLen, szTemp);
                                if (FAILED(hr)) {
                                    TRC_ERR((TB, _T("String concatenation failed: hr = 0x%x"), hr));
                                    return FALSE;
                                }
                                
                                return TRUE;
                            }
                            else
                            {
                                TRC_ERR((TB,_T("StringtoBinary conversion failed")));
                                return FALSE;
                            }
                        }
                        else
                        {
                            return FALSE;
                        }
                    }
                    break;
                }
                return FALSE;
            }
            else
            {
                return FALSE;
            }
        }
        else
        {
            //Unparsed record, just splat the value
            hr = StringCchCopy(szBuf, strLen, pNode->u.szUnparsed);
            if (SUCCEEDED(hr)) {
                return TRUE;
            } else {
                TRC_ERR((TB, _T("String copy failed: hr = 0x%x"), hr));
                return FALSE;
            }
        }
    }
    else
    {
        return FALSE;
    }

    DC_END_FN();
}

//
// Search the record list
// for the first record with the given name 
//
PRDPF_RECORD CRdpFileStore::FindRecord(LPCTSTR szName)
{
    DC_BEGIN_FN("FindRecord");

    if(szName && _pRecordListHead)
    {
        TCHAR szCmpName[RDPF_NAME_LEN];
        
        HRESULT hr = StringCchCopy(szCmpName, SIZECHAR(szCmpName), szName);
        if (FAILED(hr)) {
            TRC_ERR((TB, _T("String copy failed: hr = 0x%x"), hr));
            return NULL;
        }
        _tcslwr(szCmpName);

        PRDPF_RECORD node = _pRecordListHead;
        while(node)
        {
            if(!_tcscmp(szCmpName, node->szName))
            {
                return node;
            }
            node=node->pNext;
        }
        return NULL;
    }
    else
    {
        return NULL;
    }
    DC_END_FN();
}

//
// Append record to the end of the record list
// for a record with the given name
//
BOOL CRdpFileStore::AppendRecord(PRDPF_RECORD node)
{
    DC_BEGIN_FN("AppendRecord");
    if(node)
    {
        node->pNext = NULL;
        if(_pRecordListHead && _pRecordListTail)
        {
            node->pPrev = _pRecordListTail;
            _pRecordListTail->pNext= node;
            _pRecordListTail = node;
            return TRUE;
        }
        else
        {
            _pRecordListHead = _pRecordListTail = node;
            node->pPrev = NULL;
            return TRUE;
        }
    }
    else
    {
        return FALSE;
    }
    DC_END_FN();
}

//
// Create a new record with name szName
//
PRDPF_RECORD CRdpFileStore::NewRecord(LPCTSTR szName, UINT TypeCode)
{
    DC_BEGIN_FN("NewRecord");
    PRDPF_RECORD node = NULL;

    if(szName)
    {
        //Need to insert new node
        node = (PRDPF_RECORD)LocalAlloc(LPTR,
                                        sizeof(RDPF_RECORD));
        if(node)
        {
            node->recType = TypeCode;
            
            HRESULT hr = StringCchCopy(node->szName, SIZECHAR(node->szName), szName); 
            if (FAILED(hr)) {
                TRC_ERR((TB, _T("String copy failed: hr = 0x%x"), hr));
                return NULL;
            }
            _tcslwr(node->szName);
            
            node->pPrev= node->pNext= NULL;
        }
    }

    DC_END_FN();
    return node;
}

//
// DeleteRecords
// deletes and resets all inmemory record structures
//
BOOL CRdpFileStore::DeleteRecords()
{
    DC_BEGIN_FN("DeleteRecords");
    PRDPF_RECORD node = _pRecordListHead;
    PRDPF_RECORD prev;
    while(node)
    {
        prev = node;
        node = node->pNext;

        switch(prev->recType)
        {
            case RDPF_RECTYPE_SZ:
                LocalFree(prev->u.szVal);
                break;
            case RDPF_RECTYPE_BINARY:
                LocalFree(prev->u.pBinVal);
                break;
            case RDPF_RECTYPE_UNPARSED:
                LocalFree(prev->u.szUnparsed);
                break;
        }
        LocalFree(prev);
    }
    _pRecordListHead = NULL;
    _pRecordListTail = NULL;

    DC_END_FN();
    return TRUE;
}

inline BOOL CRdpFileStore::DeleteRecord(PRDPF_RECORD node)
{
    DC_BEGIN_FN("DeleteRecord");

    TRC_ASSERT(node,(TB,_T("node is null")));

    if(node)
    {
        if(_pRecordListTail == node)
        {
            _pRecordListTail = node->pPrev;
        }
        if(_pRecordListHead == node)
        {
            _pRecordListHead = node->pNext;
        }

        if(node->pPrev)
        {
            node->pPrev->pNext = node->pNext;
        }
        if(node->pNext)
        {
            node->pNext->pPrev = node->pPrev;
        }

        switch(node->recType)
        {
            case RDPF_RECTYPE_SZ:
                LocalFree(node->u.szVal);
                break;
            case RDPF_RECTYPE_BINARY:
                LocalFree(node->u.pBinVal);
                break;
            case RDPF_RECTYPE_UNPARSED:
                LocalFree(node->u.szUnparsed);
                break;
        }
        LocalFree(node);
        return TRUE;
    }
    else
    {
        return FALSE;
    }

    DC_END_FN();
    return FALSE;
}

BOOL CRdpFileStore::DeleteValueIfPresent(LPCTSTR szName)
{
    DC_BEGIN_FN("DeleteValueIfPresent");
    TRC_ASSERT(szName,(TB,_T("szName is null")));
    
    if(szName)
    {
        PRDPF_RECORD node = FindRecord(szName);
        if(node)
        {
            return DeleteRecord(node);
        }
        else
        {
            return TRUE;
        }
    }
    else
    {
        return FALSE;
    }

    DC_END_FN();
}

//
// Initialize to a NULL store that is readable
//
BOOL CRdpFileStore::SetToNullStore()
{
    DC_BEGIN_FN("SetToNullStore");
    DeleteRecords();
    _fOpenForRead = TRUE;
    _fOpenForWrite = TRUE;
    DC_END_FN();
    return TRUE;
}

//
// Return TRUE if the record is present
//
BOOL CRdpFileStore::IsValuePresent(LPTSTR szName)
{
    DC_BEGIN_FN("IsValuePresent");

    if(szName)
    {
        PRDPF_RECORD node = FindRecord(szName);
        if(node)
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }

    DC_END_FN();
}

DWORD CRdpFileStore::GetDataLength(LPCTSTR szName)
{
    if(szName)
    {
        PRDPF_RECORD node = FindRecord(szName);
        if(node)
        {
            switch (node->recType)
            {
            case RDPF_RECTYPE_UINT:
                return sizeof(UINT);
                break;
            case RDPF_RECTYPE_SZ:
                return _tcslen(node->u.szVal) * sizeof(TCHAR);
                break;
            case RDPF_RECTYPE_BINARY:
                return node->dwBinValLen;
                break;
            default:
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    else
    {
        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\rdpfstore.h ===
//
// rdpfstore.h
//
// Definition of CRdpFileStore, implements ISettingsStore
// 
// CRdpFileStore implements a persistent settings store for
// ts client settings.
//
// Copyright(C) Microsoft Corporation 2000
// Author: Nadim Abdo (nadima)
//

#ifndef _rdpfstore_h_
#define _rdpfstore_h_

#include "setstore.h"
#include "fstream.h"

//
// rdpfile record
//
typedef UINT RDPF_RECTYPE;
#define RDPF_RECTYPE_UINT     0
#define RDPF_RECTYPE_SZ       1
#define RDPF_RECTYPE_BINARY   2
#define RDPF_RECTYPE_UNPARSED 3

#define RDPF_NAME_LEN         32

#define IS_VALID_RDPF_TYPECODE(x)    \
        (x == RDPF_RECTYPE_UINT   || \
         x == RDPF_RECTYPE_SZ     || \
         x == RDPF_RECTYPE_BINARY || \
         x == RDPF_RECTYPE_UNPARSED)

typedef struct tagRDPF_RECORD
{
    tagRDPF_RECORD* pNext;
    tagRDPF_RECORD* pPrev;

    TCHAR szName[RDPF_NAME_LEN];
    //
    // works like a variant
    //
    RDPF_RECTYPE recType;
    union {
        UINT   iVal;       // RDPF_RECTYPE_UINT
        LPTSTR szVal;      // RDPF_RECTYPE_SZ
        PBYTE  pBinVal;    // RDPF_RECTYPE_BINARY
        LPTSTR szUnparsed; // RDPF_RECTYPE_UNPARSED
    } u;

    //length of RDPF_RECTYPE_BINARY
    DWORD dwBinValLen; 

    DWORD flags;
} RDPF_RECORD, *PRDPF_RECORD;

class CRdpFileStore : public ISettingsStore
{
public:
    CRdpFileStore();
    virtual ~CRdpFileStore();

    //
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)
    (   THIS_
        IN      REFIID,
        OUT     PVOID *
    );

    STDMETHOD_(ULONG,AddRef)
    (   THIS
    );

    STDMETHOD_(ULONG,Release)
    (   THIS
    );

    //
    // ISettingsStore methods
    //
    
    //
    // Open a store..Moniker is store specific info that points to the store
    //
    virtual BOOL OpenStore(LPCTSTR szStoreMoniker, BOOL bReadOnly=FALSE);
    //
    // Commit the current in-memory contents of the store
    //
    virtual BOOL CommitStore();
    
    //
    // Close the store
    //
    virtual BOOL CloseStore();
    
    //
    // State access functions
    //
    virtual BOOL IsOpenForRead();
    virtual BOOL IsOpenForWrite();
    virtual BOOL IsDirty();
    virtual BOOL SetDirtyFlag(BOOL bIsDirty);

    //
    // Typed read and write functions, writes are not commited until a ComitStore()
    // Values equal to the default are not persisted out
    // On read error (e.g if Name key is not found, the specified default value is returned)
    //

    virtual BOOL ReadString(LPCTSTR szName, LPTSTR szDefault, LPTSTR szOutBuf, UINT strLen);
    virtual BOOL WriteString(LPCTSTR szName, LPTSTR szDefault, LPTSTR szValue,
                             BOOL fIgnoreDefault=FALSE);

    virtual BOOL ReadBinary(LPCTSTR szName, PBYTE pOutuf, UINT cbBufLen);
    virtual BOOL WriteBinary(LPCTSTR szName,PBYTE pBuf, UINT cbBufLen);

    virtual BOOL ReadInt(LPCTSTR szName, UINT defaultVal, PUINT pval);
    virtual BOOL WriteInt(LPCTSTR szName, UINT defaultVal, UINT val,
                          BOOL fIgnoreDefault=FALSE);

    virtual BOOL ReadBool(LPCTSTR szName, UINT defaultVal, PBOOL pbVal);
    virtual BOOL WriteBool(LPCTSTR szName, UINT defaultVal, BOOL bVal,
                           BOOL fIgnoreDefault=FALSE);

    virtual BOOL DeleteValueIfPresent(LPCTSTR szName);
    virtual BOOL IsValuePresent(LPTSTR szName);

    //
    // Initiliaze to an empty store that can be read from
    //
    virtual BOOL SetToNullStore();

    virtual DWORD GetDataLength(LPCTSTR szName);

protected:
    //
    // Protected member functions
    //
    BOOL ParseFile();
    BOOL DeleteRecords();
    BOOL InsertRecordFromLine(LPTSTR szLine);
    BOOL ParseLine(LPTSTR szLine, PUINT pTypeCode, LPTSTR szNameField, LPTSTR szValueField);
    inline BOOL SetNodeValue(PRDPF_RECORD pNode, RDPF_RECTYPE TypeCode, LPCTSTR szValue);
    BOOL RecordToString(PRDPF_RECORD pNode, LPTSTR szBuf, UINT strLen);
    
    //
    // Record list fns
    //
    BOOL InsertRecord(LPCTSTR szName, UINT TypeCode, LPCTSTR szValue);
    BOOL InsertIntRecord(LPCTSTR szName, UINT value);
    BOOL InsertBinaryRecord(LPCTSTR szName, PBYTE pBuf, DWORD dwLen);

    inline PRDPF_RECORD FindRecord(LPCTSTR szName);
    inline PRDPF_RECORD NewRecord(LPCTSTR szName, UINT TypeCode);
    inline BOOL AppendRecord(PRDPF_RECORD node);
    inline BOOL DeleteRecord(PRDPF_RECORD node);
private:
    //
    // Private data members
    //

    LONG   _cRef;
    BOOL   _fReadOnly;
    BOOL   _fOpenForRead;
    BOOL   _fOpenForWrite;
    BOOL   _fIsDirty;

    PRDPF_RECORD _pRecordListHead;
    PRDPF_RECORD _pRecordListTail;

    TCHAR  _szFileName[MAX_PATH];

    //file stream
    CTscFileStream _fs;
};

#endif  //_rdpfstore_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\rmigrate.cpp ===
//
// rmigrate.cpp
//
// Implementation of CTscRegMigrate
// 
// CTscRegMigrate migrates Tsc settings from the registry
// to .RDP files
//
// Copyright(C) Microsoft Corporation 2000
// Author: Nadim Abdo (nadima)
//
//

#include "stdafx.h"
#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "rmigrate.cpp"
#include <atrcapi.h>

#include "rmigrate.h"
#include "autreg.h"
#include "rdpfstore.h"
#include "sh.h"

#ifdef OS_WINCE
#include <ceconfig.h>
#endif

#define TSC_SETTINGS_REG_ROOT TEXT("Software\\Microsoft\\Terminal Server Client\\")

#ifdef OS_WINCE
#define WBT_SETTINGS TEXT("WBT\\Settings")
#endif

CTscRegMigrate::CTscRegMigrate()
{
}

CTscRegMigrate::~CTscRegMigrate()
{
}

//
// Migrates all tsc settings to files in szRootDirectory
//
BOOL CTscRegMigrate::MigrateAll(LPTSTR szRootDirectory)
{
    DC_BEGIN_FN("MigrateAll");
    TRC_ASSERT(szRootDirectory,
               (TB,_T("szRootDirectory is NULL")));
    TCHAR szFileName[MAX_PATH*2];
    TCHAR szKeyName[MAX_PATH+1];
    BOOL  fCreatedRootDir = FALSE;

    if(szRootDirectory)
    {
        
        //
        // Enumerate and migrate all the TS sessions under HKCU
        //
        HKEY hRootKey;
        LONG rc = RegOpenKeyEx(HKEY_CURRENT_USER,
                               TSC_SETTINGS_REG_ROOT,
                               0,
                               KEY_READ,
                               &hRootKey);
        if(ERROR_SUCCESS == rc && hRootKey)
        {
            DWORD dwIndex = 0;
            for(;;)
            {
                    DWORD cName = sizeof(szKeyName)/sizeof(TCHAR) - 1;
                    FILETIME ft;
                    rc = RegEnumKeyEx(hRootKey,
                                        dwIndex,
                                        szKeyName,
                                        &cName,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &ft);
                    if(ERROR_SUCCESS == rc)
                    {
                        //
                        // Ughh..hackalicious, don't migrate
                        // the Trace subkey. or the 'Default'
                        // or LocalDevices
                        // subkey as default connectoids
                        // always use new settings
                        //
                        if(_tcscmp(szKeyName, TEXT("Trace")) &&
                           _tcscmp(szKeyName, SH_DEFAULT_REG_SESSION) &&
                           _tcsicmp(szKeyName, REG_SECURITY_FILTER_SECTION))
                        {
                            _tcscpy(szFileName, szRootDirectory);
                            _tcscat(szFileName, szKeyName);
                            _tcscat(szFileName, RDP_FILE_EXTENSION);
    
                            if (!fCreatedRootDir)
                            {
                                //
                                // Only create RD dir if there are keys to migrate
                                //
                                if(CSH::SH_CreateDirectory(szRootDirectory))
                                {
                                    fCreatedRootDir = TRUE;
                                }
                                else
                                {
                                    TRC_ERR((TB, _T("Error creating directory %s"),szRootDirectory));
                                    RegCloseKey(hRootKey);
                                    return FALSE;
                                }
                            }
    
                            //Carry on migrating whether this migrate
                            //fails or not
                            CRdpFileStore rdpf;
                            if(rdpf.OpenStore( szFileName ) )
                            {
                                if(!MigrateSession(szKeyName,
                                                   &rdpf,
                                                   TRUE))
                                {
                                    TRC_ERR((TB,
                                    _T("Migrate failed session %s - file %s"),
                                    szKeyName, szFileName));
                                }
    
                                if(rdpf.CommitStore())
                                {
                                    rdpf.CloseStore();
                                }
                            }
                    }
                    //next
                    dwIndex++;
                }
                else
                {
                    //done enum
                    break;
                }
            }
            rc = RegCloseKey(hRootKey);
            if(ERROR_SUCCESS == rc)
            {
                return TRUE;
            }
            else
            {
                TRC_ERR((TB,_T("RegCloseKey failed - err:%d"),
                         GetLastError()));
            }
        }
        else
        {
            TRC_ERR((TB,_T("Error opening tsc reg key")));
            return FALSE;
        }
    }


    DC_END_FN();
    return FALSE;
}

//
// Migrates settings in registry to a settings store
// params:
//  szSessionName - session to migrate
//  pSetStore     - settings store to dump the new settings in
//  fDeleteUnsafeRegKeys - set to TRUE to delete old regkeys after migration
//
BOOL CTscRegMigrate::MigrateSession(LPTSTR szSessionName, ISettingsStore* pStore,
                                    BOOL fDeleteUnsafeRegKeys)
{
    DC_BEGIN_FN("MigrateSession");
    TCHAR szRegSection[MAX_PATH];

    //
    // Sessions are migrated by pulling all the registry settings
    // for a session and flattening them into a settings store
    // 
    // In the registry case we used to look for settings under HKCU
    // first, if they were not there we'd try HKLM.
    //
    // The migrate code enumerates all values in the registry under
    // a named session, first for HKLM then for HKCU. By writing the HKCU
    // settings last, they overwrite any exising HKLM settings, giving
    // the correct precedence.
    //
    // Certain subfolders such as HOTKEYS subfolders and ADDINS are not migrated
    // as those values always come from the registry.
    //

    TRC_ASSERT(szSessionName && pStore,
               (TB,_T("Invalid params to MigrateSession")));
    TRC_ASSERT(pStore->IsOpenForWrite(),
               (TB,_T("Settings store not open for write")));

    if(pStore && pStore->IsOpenForWrite() && szSessionName)
    {
        if(!_tcsicmp(szSessionName,SH_DEFAULT_REG_SESSION))
        {
            TRC_ALT((TB,_T("Never migrate 'Default' session")));
            return FALSE;
        }

        _tcscpy(szRegSection, TSC_SETTINGS_REG_ROOT);
        _tcsncat(szRegSection, szSessionName, SIZECHAR(szRegSection) -
                                              SIZECHAR(TSC_SETTINGS_REG_ROOT));
        //
        // Doesn't matter if HKLM migrate fails
        // In face it is pretty common because it is usually
        // not even present
        //
        MigrateHiveSettings(HKEY_LOCAL_MACHINE,
                            szRegSection,
                            pStore);

        if(MigrateHiveSettings(HKEY_CURRENT_USER,
                               szRegSection,
                               pStore))
        {
#ifdef OS_WINCE

            // For a WBT configuration, read some additional registry entries
            // which are common for all the sessions.
            if (g_CEConfig == CE_CONFIG_WBT)
            {
                _tcscpy(szRegSection, TSC_SETTINGS_REG_ROOT);
                _tcsncat(szRegSection, WBT_SETTINGS, SIZECHAR(szRegSection) -
                                                     SIZECHAR(TSC_SETTINGS_REG_ROOT));

                //
                // Doesn't matter if HKLM migrate fails
                // In face it is pretty common because it is usually
                // not even present
                ///
                if (!MigrateHiveSettings(HKEY_LOCAL_MACHINE,
                                         szRegSection,
                                         pStore))
                {
                    TRC_ERR((TB,_T("Unable to read the common settings for WBT")));
                }
            }
#endif

#ifndef OS_WINCE
            if (!ConvertPasswordFormat( pStore ))
            {
                TRC_ERR((TB,_T("ConvertPasswordFormat failed")));
                return FALSE;
            }
#endif

            //
            // Flag controlled as we only want to do this when migrating all settings
            // not necessarily when auto-migrating single settings
            //
            if (fDeleteUnsafeRegKeys) {
                //
                // After all the migration, delete unsafe entries in the registry
                //
                RemoveUnsafeRegEntries(HKEY_LOCAL_MACHINE,
                                       szRegSection);
                RemoveUnsafeRegEntries(HKEY_CURRENT_USER,
                                       szRegSection);
            }

            return MungeForWin2kDefaults(pStore);
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }

    DC_END_FN();
}


//
// Migrate settings from hKey\szRootName to the settings store (pSto)
// It would have been cool if this function could have been completely
// generic, but it has to have specific knowledge of tsc registry layout
// because of how mstsc5.0 bogusly special cased so many things. E.g
// user name is stored as unicode in a binary blob.
//
BOOL CTscRegMigrate::MigrateHiveSettings(HKEY hKey,
                                         LPCTSTR szRootName,
                                         ISettingsStore* pSto)
{
    DC_BEGIN_FN("MigrateHiveSettings");
    USES_CONVERSION;

    HKEY rootKey;
    LONG rc;
    BOOL fRet = FALSE;
    rc = RegOpenKeyEx( hKey,
                       szRootName,
                       0,
                       KEY_READ | KEY_QUERY_VALUE,
                       &rootKey);
    if(ERROR_SUCCESS == rc)
    {
        //
        // Enumerate all the values under this key
        //
        DWORD  dwIndex = 0;
        for(;;)
        {
            TCHAR  szValueName[MAX_PATH];
            DWORD  dwValueLen = MAX_PATH;
            DWORD  dwType;
            BYTE   buf[MAX_PATH];
            DWORD  dwBufLen   = MAX_PATH;

            //
            // It is important to zero the buf
            // because we read some REG_BINARY's that
            // are really 0 encoded unicode strings
            // but tsc4 and 5 had no trailing 0's.
            //
            memset(buf, 0, sizeof(buf));
            
            rc =RegEnumValue( rootKey,
                              dwIndex,
                              szValueName,
                              &dwValueLen,
                              NULL,         //reserved
                              &dwType,
                              (PBYTE)&buf,         //data buffer
                              &dwBufLen);
            if(ERROR_SUCCESS == rc)
            {
                switch(dwType)
                {
                    case REG_DWORD:
                    {
                        // Store as int
                        UINT value = (UINT)(*((LPDWORD)buf));
                        fRet = pSto->WriteInt(szValueName,
                                              -1,    //default ignored
                                              value,
                                              TRUE); //always write
                        if(!fRet)
                        {
                            DC_QUIT;
                        }
                    }
                    break;

                    case REG_SZ:
                    {
                        if(FilterStringMigrate(szValueName))
                        {
                            fRet = pSto->WriteString(szValueName,
                                                     NULL, //no default
                                                     (LPTSTR)buf,
                                                     TRUE); //always write
                            if(!fRet)
                            {
                                DC_QUIT;
                            }
                        }
                    }
                    break;

                    case REG_BINARY:
                    {
                        //
                        // This is where things get yucky
                        // some settings e.g UserName are stored
                        // as 'binary' when they are really unicode strings
                        // No choice but to look those up.
                        //
                        fRet = FALSE;
                        if(MigrateAsRealBinary(szValueName))
                        {
                            fRet = pSto->WriteBinary(szValueName,
                                                     (PBYTE)buf,
                                                     dwBufLen);
                        }
                        else
                        {
                            //
                            // The binary blob is really a unicode string
                            //
                            LPTSTR szString = W2T((LPWSTR)buf);
                            if( szString)
                            {
                                //
                                // If things weren't yucky enough...
                                // strip out the " 50" suffix if it is
                                // present
                                //
                                LPTSTR szSuffix = _tcsstr(szValueName,
                                                          TEXT(" 50"));
                                if(szSuffix)
                                {
                                    *szSuffix = 0;
                                }
                                fRet = pSto->WriteString(szValueName,
                                                         NULL, //no default
                                                         szString,
                                                         TRUE); //always write
                            }
                        }
                        if(!fRet)
                        {
                            DC_QUIT;
                        }
                    }
                    break;
                }

                //Keep enumerating
                dwIndex++;
            }
            else if(ERROR_NO_MORE_ITEMS == rc)
            {
                fRet = TRUE;
                break;
            }
            else
            {
                TRC_ERR((TB,_T("RegEnumValue failed - err:%d"),
                         GetLastError()));
                fRet = FALSE;
                break;
            }
        } //for(;;)
    }
    else
    {
        TRC_ERR((TB,_T("Failed to open reg key - err:%d"),
                 GetLastError()));
        return FALSE;
    }

DC_EXIT_POINT:
    if(ERROR_SUCCESS != RegCloseKey(rootKey))
    {
        TRC_ERR((TB,_T("RegCloseKey failed - err:%d"),
                 GetLastError()));
    }

    DC_END_FN();
    return fRet;
}

//
// Return true if the name (szName) should be migrated as
// a real binary blob.
//
BOOL CTscRegMigrate::MigrateAsRealBinary(LPCTSTR szName)
{
    DC_BEGIN_FN("MigrateAsRealBinary");

    //
    // In Tsc4 and Tsc5, only the password/salt fields
    // were real binary blobs, all other REG_BINARY blobs
    // are really just unicode strings.
    //
    if(!_tcscmp(szName, UTREG_UI_PASSWORD50))
    {
        return TRUE;
    }
    else if(!_tcscmp(szName, UTREG_UI_PASSWORD))
    {
        return TRUE;
    }
    else if(!_tcscmp(szName, UTREG_UI_SALT50))
    {
        return TRUE;
    }
#ifdef OS_WINCE
    else if (!_tcscmp(szName, UI_SETTING_PASSWORD51))
    {
        return TRUE;
    }
#endif
    else
    {
        //
        // Don't migrate as binary
        //
        return FALSE;
    }
    DC_END_FN();
}

//
// Return true if it is ok to migrate the value
// in name
//
BOOL CTscRegMigrate::FilterStringMigrate(LPTSTR szName)
{
    if(szName)
    {
        if(_tcsstr(szName, TEXT("MRU")))
        {
            if(!_tcscmp(szName, UTREG_UI_SERVER_MRU0))
            {
                //Translate MRU0 to fulladdress
                _tcscpy(szName, UTREG_UI_FULL_ADDRESS);
                return TRUE;
            }
            //Don't migrate any other MRU strings.
            //those stay in the registry
            return FALSE;
        }
        else
        {
            //everything else is OK
            return TRUE;
        }
    }
    else
    {
        return FALSE;
    }
}

//
// Munges the settings in the settings store to be consisten
// with win2k's defaults. Win2k's default values were usually
// deleted on write, this means we would instead use whistler
// defaults but we don't want that. Instead the behavior we
// want is that a migrated connectoid has _exactly_ the same
// settings it used to have for those options that had UI in win2k.
//
// Params -
//      pSto - settings store to munge for defaults
// Returns -
//      Success flag
//
//

#define TSC_WIN2K_DEFAULT_DESKTOPSIZE    0 //640x480
#define TSC_WIN2K_DEFAULT_FULLSCREENMODE 1 //windowed
#define TSC_WIN2K_DEFAULT_BITMAPCACHE    0 //off
#define TSC_WIN2K_DEFAULT_COMPRESSION    1 //on
BOOL CTscRegMigrate::MungeForWin2kDefaults(ISettingsStore* pSto)
{
    DC_BEGIN_FN("MungeForWin2kDefaults");

    TRC_ASSERT(pSto,
               (TB,_T("pSto is null")));
    TRC_ASSERT(pSto->IsOpenForRead() && pSto->IsOpenForWrite(),
               (TB,_T("pSto is null")));

    //
    // Munge settings that had conman UI
    // to ensure that we use the user's previous settings (Even
    // if they are win2k defaults i.e could be value not specified).
    //

    // Resolution
    if(!pSto->IsValuePresent(UTREG_UI_DESKTOP_SIZEID))
    {
        //Write out win2k's default desktop size
        if(!pSto->WriteInt(UTREG_UI_DESKTOP_SIZEID,
                       -1,    //default ignored
                       TSC_WIN2K_DEFAULT_DESKTOPSIZE,
                       TRUE)) //always write
        {
            TRC_ERR((TB,_T("WriteInt UTREG_UI_DESKTOP_SIZEID failed")));
            return FALSE;
        }
    }

    // Screen mode
    if(!pSto->IsValuePresent(UTREG_UI_SCREEN_MODE))
    {
        //Write out win2k's default screen mode
        if(!pSto->WriteInt(UTREG_UI_SCREEN_MODE,
                       -1,    //default ignored
                       TSC_WIN2K_DEFAULT_FULLSCREENMODE,
                       TRUE)) //always write
        {
            TRC_ERR((TB,_T("WriteInt UTREG_UI_SCREEN_MODE failed")));
            return FALSE;
        }
    }

    // Bitmap caching
    if(!pSto->IsValuePresent(UTREG_UI_BITMAP_PERSISTENCE))
    {
        //write out win2k's default bmp persistence option
        if(!pSto->WriteInt(UTREG_UI_BITMAP_PERSISTENCE,
                          -1,   //default ignored
                          TSC_WIN2K_DEFAULT_BITMAPCACHE,
                          TRUE))
        {
            TRC_ERR((TB,_T("WriteInt TSC_WIN2K_DEFAULT_BITMAPCACHE failed")));
            return FALSE;
        }
    }

    // Compression
    // Compression is special..We've made a decision that it should
    // always be on for perf reasons (and there are no drawbacks) so
    // change the win2k
    //
    if(!pSto->IsValuePresent(UTREG_UI_COMPRESS))
    {
        //write out win2k's default compression option
        if(!pSto->WriteInt(UTREG_UI_COMPRESS,
                          -1,   //default ignored
                          TSC_WIN2K_DEFAULT_COMPRESSION,
                          TRUE))
        {
            TRC_ERR((TB,_T("WriteInt TSC_WIN2K_DEFAULT_BITMAPCACHE failed")));
            return FALSE;
        }
    }
    

    DC_END_FN();
    return TRUE;
}

#ifndef OS_WINCE
//
// Convert the password format (if password present)
// i.e if the old style TS5 passwords are present then decrypt
// to plain text and then re-encrypt and save out using CryptoAPI's
//
// On Platforms that don't support Crypto-API we just nuke
// the existing password format as we don't support migrating it
// to the RDP files since it's not a secure format (just a hash).
//
// Start fields in pSto - 'Password 50' + 'Salt 50'
// After conversion - (win2k+) 'Password 51'  - binary crypto api password
// After conversion - (less than win2k) = nothing
//
//
BOOL CTscRegMigrate::ConvertPasswordFormat(ISettingsStore* pSto)
{
    BOOL bRet = TRUE;
    DC_BEGIN_FN("ConvertPasswordFormat");

    //Nuke TS4 format
    pSto->DeleteValueIfPresent( UTREG_UI_PASSWORD );

    if ( CSH::IsCryptoAPIPresent() &&
         pSto->IsValuePresent( UTREG_UI_PASSWORD50 ) &&
         pSto->IsValuePresent( UTREG_UI_SALT50 ) )
    {
        BOOL fHavePass = FALSE;
        BYTE Password[TSC_MAX_PASSWORD_LENGTH_BYTES];
        BYTE Salt[TSC_SALT_LENGTH];
        memset( Password, 0, TSC_MAX_PASSWORD_LENGTH_BYTES);

        if (pSto->ReadBinary(UTREG_UI_PASSWORD50,
                       (PBYTE)Password,
                       sizeof(Password))) //size in bytes
        {
            fHavePass = TRUE;
        }
        else
        {
            TRC_NRM((TB,
            _T("ReadBinary for password failed. Maybe password not present")));
        }
        
        //
        // Salt
        //
        if (!pSto->ReadBinary(UTREG_UI_SALT50,
                               (PBYTE)Salt,
                               sizeof(Salt)))
        {
            fHavePass = FALSE;
            TRC_NRM((TB,_T("ReadBinary for salt failed.")));
        }

        if (fHavePass &&
            EncryptDecryptLocalData50( Password,
                                       TSC_WIN2K_PASSWORD_LENGTH_BYTES,
                                       Salt, sizeof(Salt)))
        {
            //Now we have the clear text pass in Password
            //encrypt it with the crypto API and save that back
            //out to the store
            DATA_BLOB din;
            DATA_BLOB dout;
            din.cbData = sizeof(Password);
            din.pbData = (PBYTE)&Password;
            dout.pbData = NULL;
            if (CSH::DataProtect( &din, &dout))
            {
                if (!pSto->WriteBinary(UI_SETTING_PASSWORD51,
                                       dout.pbData,
                                       dout.cbData))
                {
                    bRet = FALSE;
                }
                LocalFree( dout.pbData );
            }
            else
            {
                bRet = FALSE;
            }

            // Wipe from stack
            SecureZeroMemory( Password, TSC_MAX_PASSWORD_LENGTH_BYTES);
        }
    }

    // No longer need the old format so delete them
    pSto->DeleteValueIfPresent( UTREG_UI_PASSWORD50 );
    pSto->DeleteValueIfPresent( UTREG_UI_SALT50 );

    DC_END_FN();
    return bRet;
}
#endif

BOOL
CTscRegMigrate::DeleteRegValue(HKEY hKeyRoot,
                            LPCTSTR szRootName,
                            LPCTSTR szValueName)
{
    HKEY hKey;
    LONG rc;
    BOOL fRet = FALSE;

    DC_BEGIN_FN("DeleteRegValue");

    rc = RegOpenKeyEx( hKeyRoot,
                       szRootName,
                       0,
                       KEY_SET_VALUE, //needed for delete access
                       &hKey);
    if(ERROR_SUCCESS == rc)
    {
        rc = RegDeleteValue(hKey, szValueName); 
        if (ERROR_SUCCESS == rc) {
            fRet = TRUE;
        }

        RegCloseKey(hKey);
    }

    DC_END_FN();
    return fRet;
}

//
// Remove entries we don't want to keep lying around in the registry
// primarily these are passwords in the old 'insecure' obfuscated formats
//
BOOL
CTscRegMigrate::RemoveUnsafeRegEntries(HKEY hKeyRoot,
                                       LPCTSTR szRootName)
{
    BOOL fRet = FALSE;

    DC_BEGIN_FN("RemoveUnsafeRegEntries");

    if (!DeleteRegValue(hKeyRoot, szRootName, UTREG_UI_PASSWORD50)) {
        TRC_ALT((TB,_T("Failed to delete: %s\\%s"), szRootName,
                 UTREG_UI_PASSWORD50));
    }

    if (!DeleteRegValue(hKeyRoot, szRootName, UTREG_UI_PASSWORD)) {
        TRC_ALT((TB,_T("Failed to delete: %s\\%s"), szRootName,
                 UTREG_UI_PASSWORD));
    }

    if (!DeleteRegValue(hKeyRoot, szRootName, UTREG_UI_SALT50)) {
        TRC_ALT((TB,_T("Failed to delete: %s\\%s"), szRootName,
                 UTREG_UI_SALT50));
    }

    fRet = TRUE;

    DC_END_FN();

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\shutdowndlg.h ===
//
// shutdowndlg.h: shutdown dialog
//

#ifndef _shutdowndlg_h_
#define _shutdowndlg_h_

#include "dlgbase.h"

class CSH;

class CShutdownDlg : public CDlgBase
{
public:
    CShutdownDlg(HWND hwndOwner, HINSTANCE hInst, CSH* pSh);
    ~CShutdownDlg();

    virtual DCINT   DoModal();
    virtual INT_PTR CALLBACK DialogBoxProc(HWND hwndDlg, UINT uMsg,WPARAM wParam, LPARAM lParam);
    static  INT_PTR CALLBACK StaticDialogBoxProc(HWND hwndDlg, UINT uMsg,WPARAM wParam, LPARAM lParam);

    static CShutdownDlg* _pShutdownDlgInstance;
private:
    CSH* _pSh;
};


#endif //_shutdowndlg_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\setstore.h ===
//
// setstore.h
//
// Interface definition for an abstract settings store
// 
// This abstraction is meant to allow different store types
// to be plugged in to update the persistence model
//
// Copyright(C) Microsoft Corporation 2000
// Author: Nadim Abdo (nadima)
//

#ifndef _SETSTORE_H_
#define _SETSTORE_H_

class ISettingsStore : public IUnknown
{
public:
    typedef enum {
        storeOpenReadOnly  = 0,
        storeOpenWriteOnly = 1,
        storeOpenRW        = 2,
    } storeOpenState;

    //
    // Open a store..Moniker is store specific info that points to the store
    //
    virtual BOOL OpenStore(LPCTSTR szStoreMoniker, BOOL bReadOnly=FALSE) = 0;
    //
    // Commit the current in-memory contents of the store
    //
    virtual BOOL CommitStore() = 0;
    
    //
    // Close the store
    //
    virtual BOOL CloseStore() = 0;
    
    //
    // State access functions
    //
    virtual BOOL IsOpenForRead() = 0;
    virtual BOOL IsOpenForWrite() = 0;
    virtual BOOL IsDirty() = 0;
    virtual BOOL SetDirtyFlag(BOOL bIsDirty) = 0;

    //
    // Typed read and write functions, writes are not commited until a ComitStore()
    // Values equal to the default are not persisted out
    // On read error (e.g if Name key is not found, the specified default value is returned)
    //

    virtual BOOL ReadString(LPCTSTR szName, LPTSTR szDefault,
                            LPTSTR szOutBuf, UINT strLen) = 0;
    virtual BOOL WriteString(LPCTSTR szName, LPTSTR szDefault,
                             LPTSTR szValue, BOOL fIgnoreDefault=FALSE) = 0;

    virtual BOOL ReadBinary(LPCTSTR szName, PBYTE pOutuf, UINT cbBufLen) = 0;
    virtual BOOL WriteBinary(LPCTSTR szName,PBYTE pBuf, UINT cbBufLen)   = 0;

    virtual BOOL ReadInt(LPCTSTR szName, UINT defaultVal, PUINT pval)  = 0;
    virtual BOOL WriteInt(LPCTSTR szName, UINT defaultVal, UINT val,
                          BOOL fIgnoreDefault=FALSE) = 0;

    virtual BOOL ReadBool(LPCTSTR szName, UINT defaultVal, PBOOL pbVal) = 0;
    virtual BOOL WriteBool(LPCTSTR szName, UINT defaultVal, BOOL bVal,
                           BOOL fIgnoreDefault=FALSE)  = 0;

    virtual BOOL DeleteValueIfPresent(LPCTSTR szName) = 0;
    virtual BOOL IsValuePresent(LPTSTR szName) = 0;

    virtual DWORD GetDataLength(LPCTSTR szName) = 0;
};

#endif //_SETSTORE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\security.h ===
//                      
// security.h
//
// Implementation of CTSSecurity
// TS Client Shell Security functions
//
// Copyright(C) Microsoft Corporation 2001
// Author: Nadim Abdo (nadima)
//
//

#ifndef _TSSECURITY_H_
#define _TSSECURITY_H_

#include "tscsetting.h"

class CTSSecurity
{
public:
    CTSSecurity();
    ~CTSSecurity();
    static DWORD MakePromptFlags(BOOL fRedirectDrives,
                                 BOOL fRedirectPorts);

    static BOOL AllowConnection(HWND hwndOwner,
                                HINSTANCE hInstance,
                                LPCTSTR szServer,
                                BOOL fRedirectDrives,
                                BOOL fRedirectPorts);
};

#endif _TSSECURITY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\shutdowndlg.cpp ===
//
// shutdowndlg.cpp: shutdown dialog
//

#include "stdafx.h"

#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "shutdowndlg"
#include <atrcapi.h>

#include "shutdowndlg.h"
#include "sh.h"

CShutdownDlg* CShutdownDlg::_pShutdownDlgInstance = NULL;

CShutdownDlg::CShutdownDlg( HWND hwndOwner, HINSTANCE hInst, CSH* pSh) :
               CDlgBase( hwndOwner, hInst, UI_IDD_SHUTTING_DOWN),
               _pSh(pSh)
{
    DC_BEGIN_FN("CShutdownDlg");
    TRC_ASSERT((NULL == CShutdownDlg::_pShutdownDlgInstance), 
               (TB,_T("Clobbering existing dlg instance pointer\n")));

    TRC_ASSERT(_pSh,
               (TB,_T("_pSh set to NULL")));

    CShutdownDlg::_pShutdownDlgInstance = this;

    DC_END_FN();
}

CShutdownDlg::~CShutdownDlg()
{
    CShutdownDlg::_pShutdownDlgInstance = NULL;
}

DCINT CShutdownDlg::DoModal()
{
    DCINT retVal = 0;
    DC_BEGIN_FN("DoModal");

    retVal = DialogBox(_hInstance, MAKEINTRESOURCE(_dlgResId),
                       _hwndOwner, StaticDialogBoxProc);
    TRC_ASSERT((retVal != 0 && retVal != -1), (TB, _T("DialogBoxParam failed\n")));

    DC_END_FN();
    return retVal;
}

INT_PTR CALLBACK CShutdownDlg::StaticDialogBoxProc (HWND hwndDlg, UINT uMsg,
                                                    WPARAM wParam, LPARAM lParam)
{
    //
    // Delegate to appropriate instance (only works for single instance dialogs)
    //
    DC_BEGIN_FN("StaticDialogBoxProc");
    DCINT retVal = 0;

    TRC_ASSERT(_pShutdownDlgInstance,
               (TB, _T("Shutdown dialog has NULL static instance ptr\n")));
    if(_pShutdownDlgInstance)
    {
        retVal = _pShutdownDlgInstance->DialogBoxProc( hwndDlg,
                                                       uMsg,
                                                       wParam,
                                                       lParam);
    }

    DC_END_FN();
    return retVal;
}

/****************************************************************************/
/* Name: DialogBoxProc                                                      */
/*                                                                          */
/* Purpose: Handles Shutdown Box dialog                                     */
/*                                                                          */
/* Returns: TRUE if message dealt with                                      */
/*          FALSE otherwise                                                 */
/*                                                                          */
/* Params: See window documentation                                         */
/*                                                                          */
/****************************************************************************/
INT_PTR CALLBACK CShutdownDlg::DialogBoxProc (HWND hwndDlg, UINT uMsg,
                                              WPARAM wParam, LPARAM lParam)
{
    INT_PTR rc = FALSE;

    DC_BEGIN_FN("UIShutdownDialogProc");

    /************************************************************************/
    /* Handle dialog messages                                               */
    /************************************************************************/
    switch(uMsg)
    {
        case WM_INITDIALOG:
        {
            /****************************************************************/
            /* Center the dialog                                            */
            /****************************************************************/
            if(hwndDlg)
            {
                _hwndDlg = hwndDlg;
                CenterWindow(_hwndOwner);
                SetDialogAppIcon(hwndDlg);
            }

            rc = TRUE;
        }
        break;

        case WM_COMMAND:
        {
            switch(DC_GET_WM_COMMAND_ID(wParam))
            {
                case UI_ID_SHUTDOWN_YES:
                {
                    EndDialog(hwndDlg, IDOK);
                    rc = TRUE;
                }
                break;

#ifndef OS_WINCE
                case UI_ID_HELP:
                {
                    //
                    // Pop help
                    //
                    TRC_NRM((TB, _T("Display help")));
                    if(_hwndOwner)
                    {
                        _pSh->SH_DisplayClientHelp(
                            _hwndOwner,
                            HH_DISPLAY_TOPIC);
                    }
                }
                break;
#endif

                default:
                {
                    if(hwndDlg)
                    {
                        rc = CDlgBase::DialogBoxProc(hwndDlg,
                                                  uMsg,
                                                  wParam,
                                                  lParam);
                    }
                }
                break;
            }
        }
        break;

        default:
        {
            if(hwndDlg)
            {
                rc = CDlgBase::DialogBoxProc(hwndDlg,
                                          uMsg,
                                          wParam,
                                          lParam);
            }
        }
        break;
    }

    DC_END_FN();

    return(rc);

} /* UIShutdownDialogBox */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\shint.cpp ===
//
// shint.cpp: client shell utitilies
//            internal functions
//

#include "stdafx.h"

#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "shint.cpp"
#include <atrcapi.h>


#include "sh.h"
#include "rmigrate.h"

//
// Fix union names, because some headers redifine this
// and break STRRET to str field access
//
#undef DUMMYUNIONNAME
#define NONAMELESSUNION

#define CLXSERVER           TEXT("CLXSERVER")
#define CLXCMDLINE          TEXT("CLXCMDLINE")
#define FULLSCREEN          TEXT("FULLSCREEN")
#define SWITCH_EDIT         TEXT("EDIT")
#define SWITCH_MIGRATE      TEXT("MIGRATE")
#define SWITCH_CONSOLE      TEXT("CONSOLE")


#ifdef NONAMELESSUNION
#define NAMELESS_MEMBER(member) DUMMYUNIONNAME.##member
#else
#define NAMELESS_MEMBER(member) member
#endif

#define STRRET_OLESTR  STRRET_WSTR          // same as STRRET_WSTR
#define STRRET_OFFPTR(pidl,lpstrret) \
            ((LPSTR)((LPBYTE)(pidl)+(lpstrret)->NAMELESS_MEMBER(uOffset)))
            



/****************************************************************************/
/* Name:      SHValidateParsedCmdParam                                      */
/*                                                                          */
/* Purpose:   validates settings in _SH that were read from the cmd line    */
/*                                                                          */
/* Returns:   Nothing                                                       */
/*                                                                          */
/* Params:    IN - lpszCmdParam                                             */
/*                                                                          */
/****************************************************************************/
DCBOOL CSH::SHValidateParsedCmdParam()
{
    DC_BEGIN_FN("SHValidateParsedCmdParam");
    //
    //["<session>"]  [-v:<server>] [-f[ullscreen]] [-w[idth]:<wd> -h[eight]:<ht>]
    //

    //
    // if one of width/height is specified but not the other..
    // then fill with defaults
    //
    if (_SH.commandLineHeight != _SH.commandLineWidth)
    {
        if (!_SH.commandLineHeight)
        {
            _SH.commandLineHeight = DEFAULT_DESKTOP_HEIGHT;
        }
        if (!_SH.commandLineWidth)
        {
            _SH.commandLineWidth = DEFAULT_DESKTOP_WIDTH;
        }
    }

    //
    // clamp to min max sizes. 0 means we are not set
    //
    if (_SH.commandLineHeight != 0)
    {
        if (_SH.commandLineHeight < MIN_DESKTOP_HEIGHT)
        {
            _SH.commandLineHeight = MIN_DESKTOP_HEIGHT;
        }
        else if (_SH.commandLineHeight > MAX_DESKTOP_HEIGHT)
        {
            _SH.commandLineHeight = MAX_DESKTOP_HEIGHT;
        }
    }
    if (_SH.commandLineWidth != 0)
    {
        if (_SH.commandLineWidth < MIN_DESKTOP_WIDTH)
        {
            _SH.commandLineWidth = MIN_DESKTOP_WIDTH;
        }
        else if (_SH.commandLineWidth > MAX_DESKTOP_WIDTH)
        {
            _SH.commandLineWidth = MAX_DESKTOP_WIDTH;
        }
    }

    DC_END_FN();
    return TRUE;
}

//*************************************************************
//
//  CLX_SkipWhite()
//
//  Purpose:    Skips whitespace characters
//
//  Parameters: IN [lpszCmdParam]   - Ptr to string
//
//  Return:     Ptr string past whitespace
//
//  History:    09-30-97    BrianTa     Created
//
//*************************************************************

LPTSTR
CLX_SkipWhite(IN LPTSTR lpszCmdParam)
{
    while (*lpszCmdParam)
    {
        if (*lpszCmdParam != ' ')
            break;

        lpszCmdParam++;
    }

    return(lpszCmdParam);
}


//*************************************************************
//
//  CLX_SkipNonWhite()
//
//  Purpose:    Skips non-whitespace characters
//
//  Parameters: IN [lpszCmdParam]   - Ptr to string
//
//  Return:     Ptr string past non-whitespace
//
//  History:    09-30-97    BrianTa     Created
//
//*************************************************************

LPTSTR CLX_SkipNonWhite(LPTSTR lpszCmdParam)
{
    char    Delim;

    Delim = ' ';

    if (*lpszCmdParam == '"')
    {
        Delim = '"';
        lpszCmdParam++;
    }

    while (*lpszCmdParam)
    {
        if (*lpszCmdParam == Delim)
            break;

        lpszCmdParam++;
    }

    if (*lpszCmdParam == Delim)
        lpszCmdParam++;

    return(lpszCmdParam);
}

//*************************************************************
//
//  CLX_GetSwitch_CLXSERVER()
//
//  Purpose:    Processes /CLXSERVER cmdline switch
//
//  Parameters: IN [lpszCmdParam]       - Ptr to cmdline
//
//  Return:     Number of characters consumed
//
//  History:    09-30-97    BrianTa     Created
//
//*************************************************************

UINT
CLX_GetSwitch_CLXSERVER(IN LPTSTR lpszCmdParam)
{
    DC_BEGIN_FN("CLX_GetSwitch_CLXSERVER");

    int         len;
    LPTSTR      pszEnd;
    LPTSTR      pszStart;

    pszStart = CLX_SkipWhite(lpszCmdParam);

    TRC_ASSERT(*pszStart == _T('='),
               (TB,_T("Invalid /clxserver syntax - expected '='\n")));
    pszStart++;

    pszStart = CLX_SkipWhite(pszStart);
    pszEnd   = CLX_SkipNonWhite(pszStart);

    len = (INT) (pszEnd - pszStart);

    DC_END_FN();
    return(UINT) (pszEnd - lpszCmdParam);
}

//*************************************************************
//
//  CLX_GetSwitch_CLXCMDLINE()
//
//  Purpose:    Processes /CLXCMDLINE cmdline switch
//
//  Parameters: IN [lpszCmdParam]       - Ptr to cmdline
//
//  Return:     Number of characters consumed
//
//  History:    09-30-97    BrianTa     Created
//
//*************************************************************

UINT
CSH::CLX_GetSwitch_CLXCMDLINE(IN LPTSTR lpszCmdParam)
{
    int         len;
    LPTSTR       pszEnd;
    LPTSTR       pszStart;
    DC_BEGIN_FN("CLX_GetSwitch_CLXCMDLINE");

    pszStart = CLX_SkipWhite(lpszCmdParam);

    TRC_ASSERT(*pszStart == _T('='),
               (TB,_T("Invalid /clxserver syntax - expected '='\n")));

    pszStart++;

    pszStart = CLX_SkipWhite(pszStart);
    pszEnd   = CLX_SkipNonWhite(pszStart);

    len = (INT) (pszEnd - pszStart);

    if (len > 0)
    {
        memmove(_SH.szCLXCmdLine, pszStart, len*sizeof(TCHAR));
        _SH.szCLXCmdLine[len] = 0;
    }

    DC_END_FN();
    return(UINT) (pszEnd - lpszCmdParam);
}

/****************************************************************************/
/* Name:      SHGetSwitch                                                   */
/*                                                                          */
/* Purpose:   Retrieves cmdline switches                                    */
/*                                                                          */
/* Returns:   Nothing                                                       */
/*                                                                          */
/* Params:    IN - lpszCmdParam                                             */
/*                                                                          */
/****************************************************************************/
LPTSTR CSH::SHGetSwitch(LPTSTR lpszCmdParam)
{
    DCINT       i;
    DCTCHAR     szParam[100];

    DC_BEGIN_FN("SHGetSwitch");

    /************************************************************************/
    /* Retrieve the switch (case insensitive)                               */
    /************************************************************************/
    i=0;

    while (*lpszCmdParam)
    {
        if (*lpszCmdParam == _T(' ') || *lpszCmdParam == _T('=') ||
            *lpszCmdParam == _T(':'))
            break;

        if (i < sizeof(szParam) / sizeof(DCTCHAR) - 1)
        {
#ifdef UNICODE
            szParam[i] = (DCTCHAR) towupper(*lpszCmdParam);
#else // UNICODE
            szParam[i] = (DCTCHAR) toupper(*lpszCmdParam);
#endif // UNICODE

            i++;
        }

        lpszCmdParam++;
    }

    szParam[i] = 0;

#ifndef OS_WINCE
    
    // Are we seeing the "/f"  from /F[ullscreen]
    if (szParam[0] == _T('F'))
    {
        _SH.fCommandStartFullScreen = TRUE;
    }

    
    // Are we seeing the "/W"  from /w[idth]
    else if (szParam[0] == _T('W'))
    {
        lpszCmdParam = SHGetCmdLineInt(lpszCmdParam, &_SH.commandLineWidth);
    }

    // Are we seeing the "/H"  from /h[eight]
    else if (szParam[0] == _T('H'))
    {
        lpszCmdParam = SHGetCmdLineInt(lpszCmdParam, &_SH.commandLineHeight);
    }

    // Are we seeing the "/V"  for server
    else

#endif	
		
	if (szParam[0] == _T('V'))
    {
        lpszCmdParam = SHGetServer(lpszCmdParam);
    }

    // Are we seeing the "/S" 
    else if (memcmp(szParam, "S", i) == 0)
    {
        lpszCmdParam = SHGetSession(lpszCmdParam);
    }

    // Are we seeing the "/C"
    else if (memcmp(szParam, "C", i) == 0)
    {
        lpszCmdParam = SHGetCacheToClear(lpszCmdParam);
    }

    // Are we seeing the "/CLXCMDLINE=xyzzy"
    else if (memcmp(szParam, CLXCMDLINE, i) == 0)
    {
        lpszCmdParam += CLX_GetSwitch_CLXCMDLINE(lpszCmdParam);
    }

    else if (memcmp(szParam, FULLSCREEN, i) == 0)
    {
        lpszCmdParam += SIZECHAR(FULLSCREEN);
    }

    else if (memcmp(szParam, SWITCH_EDIT,i) == 0)
    {
        lpszCmdParam = SHGetFileName(lpszCmdParam);
        _fFileForEdit = TRUE;
        _SH.autoConnectEnabled = FALSE;
    }

    else if (memcmp(szParam, SWITCH_MIGRATE,i) == 0)
    {
        _fMigrateOnly = TRUE;
    }

    else if (memcmp(szParam, SWITCH_CONSOLE,i) == 0)
    {
        SH_SetCmdConnectToConsole(TRUE);
    }



    /************************************************************************/
    /* Not a recognized switch. Bring up usage                              */
    /************************************************************************/
    else
    {
        TRC_NRM((TB,_T("Invalid CmdLine switch - Display Usage AND EXIT %s"),
                       szParam));
        DCTCHAR szCmdLineUsage[4096]; //Long string here.
        DCTCHAR szUsageTitle[256];
        if (!LoadString(_hInstance,
                        UI_IDS_USAGE_TITLE,
                        szUsageTitle,
                        SIZECHAR(szUsageTitle)))
        {
            TRC_ERR((TB,_T("Error loading UI_IDS_USAGE_TITLE")));
            return NULL;
        }

        if (!LoadString(_hInstance,
                        UI_IDS_CMD_LINE_USAGE,
                        szCmdLineUsage,
                        SIZECHAR(szCmdLineUsage)))
        {
            TRC_NRM((TB,_T("Error loading UI_IDS_CMD_LINE_USAGE")));
            return NULL;
        }

        MessageBox(NULL, szCmdLineUsage, szUsageTitle, 
                   MB_ICONINFORMATION | MB_OK);

        return NULL;
    }

    DC_END_FN();

    return(lpszCmdParam);
}

/****************************************************************************/
/* Name:      SHGetServer                                                   */
/*                                                                          */
/* Purpose:   Retrieves the server name (if specified)                      */
/*                                                                          */
/* Returns:   Nothing                                                       */
/*                                                                          */
/* Params:    IN - lpszCmdParam                                             */
/*                                                                          */
/****************************************************************************/
LPTSTR CSH::SHGetServer(LPTSTR lpszCmdParam)
{
    DC_BEGIN_FN("SHGetServer");
    if (!lpszCmdParam)
    {
        return NULL;
    }

    /************************************************************************/
    /* Retrieve the server                                                  */
    /************************************************************************/
    lpszCmdParam = SHGetCmdLineString(lpszCmdParam, _SH.szCommandLineServer,
                                      SIZECHAR(_SH.szCommandLineServer) -1);

    DC_END_FN();
    return lpszCmdParam;
}


/****************************************************************************/
/* Name:      SHGetSession                                                  */
/*                                                                          */
/* Purpose:   Retrieves the session name (if specified)                     */
/*                                                                          */
/* Returns:   Nothing                                                       */
/*                                                                          */
/* Params:    IN - lpszCmdParam                                             */
/*                                                                          */
/****************************************************************************/
LPTSTR CSH::SHGetSession(LPTSTR lpszCmdParam)
{
    BOOL fQuote = FALSE;

    DC_BEGIN_FN("SHGetSession");

    TRC_ASSERT((_SH.fRegDefault == TRUE),
               (TB,_T("Invalid CmdLine syntax - session respecified.")));


    // Retrieve the reg session
    lpszCmdParam = SHGetCmdLineString(lpszCmdParam, _SH.regSession,
                                      SIZECHAR(_SH.regSession) -1);
    
    // In the non-default session, display the session name.  Choose the
    // appropriate connected/disconnected strings.
    TRC_DBG((TB, _T("Named session")));

    _SH.fRegDefault = FALSE;
    _SH.connectedStringID = UI_IDS_FRAME_TITLE_CONNECTED;
    _SH.disconnectedStringID = UI_IDS_FRAME_TITLE_DISCONNECTED;

    DC_END_FN();

    return(lpszCmdParam);
}

LPTSTR CSH::SHGetFileName(LPTSTR lpszCmdParam)
{
    BOOL fQuote = FALSE;

    DC_BEGIN_FN("SHGetSession");

    TRC_ASSERT((_SH.fRegDefault == TRUE),
               (TB,_T("Invalid CmdLine syntax - session respecified.")));


    // Retrieve the filename
    lpszCmdParam = SHGetCmdLineString(lpszCmdParam, _szFileName,
                                      SIZECHAR(_szFileName) -1);
    
    _SH.fRegDefault = FALSE;
    _SH.connectedStringID = UI_IDS_FRAME_TITLE_CONNECTED;
    _SH.disconnectedStringID = UI_IDS_FRAME_TITLE_DISCONNECTED;

    DC_END_FN();

    return(lpszCmdParam);
}

/****************************************************************************/
/* Name:      SHGetCmdLineString                                            */
/*                                                                          */
/* Purpose:   Retrieve a string parameter                                   */
/*                                                                          */
/* Returns:   Nothing                                                       */
/*                                                                          */
/* Params:    IN - lpszCmdParam                                             */
/*                                                                          */
/****************************************************************************/
LPTSTR CSH::SHGetCmdLineString(LPTSTR lpszCmdParam, LPTSTR lpszDest,
                               DCINT cbDestLen)
{
    DCINT       i;
    BOOL fQuote = FALSE;

    DC_BEGIN_FN("SHGetCmdLineString");

    TRC_ASSERT(lpszCmdParam && lpszDest && cbDestLen,
               (TB, _T("SHGetCmdLineString. Invalid param(s)\n")));
    if (!lpszCmdParam || !lpszDest || !cbDestLen)
    {
        return NULL;
    }

    /************************************************************************/
    /* Retrieve a command line string parameter                             */
    /************************************************************************/
    while (*lpszCmdParam == _T(' '))
        lpszCmdParam++;

    if (*lpszCmdParam == _T('=') || *lpszCmdParam == _T(':'))
        lpszCmdParam++;

    while (*lpszCmdParam == _T(' '))
        lpszCmdParam++;

    i=0;

    while (*lpszCmdParam)
    {
        switch (*lpszCmdParam)
        {
        case _T('"'):
            fQuote = !fQuote;
            lpszCmdParam++;
            break;

        case _T(' '):
            if (!fQuote)
            {
                lpszCmdParam++;
                DC_QUIT;
            }
            // else fall through

        default:
            if (i < cbDestLen)
                lpszDest[i++] = *lpszCmdParam;
            lpszCmdParam++;
        }
    }


    DC_EXIT_POINT:
    DC_END_FN();
    lpszDest[i] = 0;
    return lpszCmdParam;
}

/****************************************************************************/
/* Name:      SHGetCmdLineInt                                               */
/*                                                                          */
/* Purpose:   Retrieves an integer parameter                                */
/*                                                                          */
/* Returns:   Nothing                                                       */
/*                                                                          */
/* Params:    IN - lpszCmdParam, OUT- PInt                                  */
/*                                                                          */
/****************************************************************************/
LPTSTR CSH::SHGetCmdLineInt(LPTSTR lpszCmdParam, PDCUINT pInt)
{
    DC_BEGIN_FN("SHGetCmdLineInt");
    if (!pInt)
    {
        return NULL;
    }
    if (!lpszCmdParam)
    {
        return NULL;
    }

    /************************************************************************/
    /* Retrieve an integer parameter                                        */
    /************************************************************************/
    while (*lpszCmdParam == _T(' '))
        lpszCmdParam++;

    if (*lpszCmdParam == _T('=') || *lpszCmdParam == _T(':'))
        lpszCmdParam++;

    while (*lpszCmdParam == _T(' '))
        lpszCmdParam++;

    DCUINT readInt = 0;
    while (*lpszCmdParam)
    {
        if (*lpszCmdParam == _T(' '))
            break;

        if (_istdigit(*lpszCmdParam))
        {
            DCINT digit = *lpszCmdParam - _T('0');
            TRC_ASSERT(digit >=0 && digit <=9, (TB,_T("digit read error\n")));
            if (digit <0 || digit >9)
            {
                break;
            }
            readInt = readInt * 10 + digit;
        }
        else
        {
            break;
        }
        lpszCmdParam++;
    }

    *pInt = readInt;

    DC_END_FN();
    return lpszCmdParam;
}

/****************************************************************************/
/* Name:      SHGetCacheToClear                                             */
/*                                                                          */
/* Purpose:   Retrieves the cache type (e.g. bitmap) to be cleared          */
/*                                                                          */
/* Returns:   Nothing                                                       */
/*                                                                          */
/* Params:    IN - lpszCmdParam                                             */
/*                                                                          */
/****************************************************************************/
LPTSTR CSH::SHGetCacheToClear(LPTSTR lpszCmdParam)
{
    DCINT       i;
    TCHAR       cacheType[10];

    DC_BEGIN_FN("SHGetCacheToClear");

    /************************************************************************/
    /* Retrieve the cache type                                              */
    /************************************************************************/
    while (*lpszCmdParam == _T(' '))
        lpszCmdParam++;

    if (*lpszCmdParam == _T('=') || *lpszCmdParam == _T(':'))
        lpszCmdParam++;

    while (*lpszCmdParam == _T(' '))
        lpszCmdParam++;

    i=0;

    while (*lpszCmdParam)
    {
        if (*lpszCmdParam == _T(' '))
            break;

        if (i < sizeof(cacheType) / sizeof(DCTCHAR) -1)
#ifdef UNICODE
            cacheType[i++] = (DCTCHAR) towupper(*lpszCmdParam);
#else // UNICODE
            cacheType[i++] = (DCTCHAR) toupper(*lpszCmdParam);
#endif // UNICODE

        lpszCmdParam++;
    }

    cacheType[i] = 0;

    if (memcmp(cacheType, "BITMAP", i) == 0)
    {
        _SH.fClearPersistBitmapCache = TRUE;
    }
    else
    {
        TRC_NRM((TB,_T("Invalid Cache Type - %s"), cacheType));
    }

    DC_END_FN();

    return(lpszCmdParam);
}

//
// Take the session in _SH.regSession and figure out
// if it is a file or a registry session
// 
// We need to do this because for compatability reasons
// the client has to be able to support both a file name
// and the registry session name as default command line
// params (enter this logic to determine which is which).
//
//
// Return TRUE if it's a valid reg or connection param
// or FALSE otherwise
//
BOOL CSH::ParseFileOrRegConnectionParam()
{
    BOOL fRet = TRUE;
    DC_BEGIN_FN("ParseFileOrRegConnectionParam");

    //
    // If a connection parameter is specified that is
    // different from the default
    //

    if(_tcscmp(_SH.regSession, SH_DEFAULT_REG_SESSION)) {

        //
        // A connection parameter is specified
        // check for the three possible cases
        // 1) it's an RDP file
        // 2) it's a registry connection
        // 3) it's INVALID!
        //

        //a) check if the session is really a file
        if (SH_FileExists(_SH.regSession)) {
            _tcsncpy(_szFileName, _SH.regSession,
                     SIZECHAR(_szFileName));
            _fFileForConnect = TRUE;
            _SH.autoConnectEnabled = TRUE;
            SetRegSessionSpecified(FALSE);
        }
        else if (SH_TSSettingsRegKeyExists(_SH.regSession)) {

            //Assume it's an old registry style session name
            SetRegSessionSpecified(TRUE);
        }
        else {
            TRC_ERR((TB,_T("Reg session is neither file nore reg key: %s"),
                    _SH.regSession));
            fRet = FALSE;
        }
    }

    DC_END_FN();
    return fRet;
}

#ifndef OS_WINCE
//
// Copy of StrRetToStrW from \shell\shlwapi\strings.c
//
//

// dupe a string using the task allocator for returing from a COM interface
//
HRESULT XSHStrDupA(LPCSTR psz, WCHAR **ppwsz)
{
    WCHAR *pwsz;
    DWORD cch;

    //RIPMSG(psz && IS_VALID_STRING_PTRA(psz, -1), "SHStrDupA: Caller passed invalid psz");

    if (psz)
    {
        cch = MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
        pwsz = (WCHAR *)CoTaskMemAlloc((cch + 1) * sizeof(WCHAR));
    }
    else
        pwsz = NULL;

    *((PVOID UNALIGNED64 *) ppwsz) = pwsz;

    if (pwsz)
    {
        MultiByteToWideChar(CP_ACP, 0, psz, -1, *ppwsz, cch);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

HRESULT XStrRetToStrW(LPSTRRET psr, LPCITEMIDLIST pidl, WCHAR **ppsz)
{
    HRESULT hres = S_OK;

    switch (psr->uType)
    {
    case STRRET_WSTR:
        *ppsz = psr->DUMMYUNIONNAME.pOleStr;
        psr->DUMMYUNIONNAME.pOleStr = NULL;   // avoid alias
        hres = *ppsz ? S_OK : E_FAIL;
        break;

    case STRRET_OFFSET:
        hres = XSHStrDupA(STRRET_OFFPTR(pidl, psr), ppsz);
        break;

    case STRRET_CSTR:
        hres = XSHStrDupA(psr->DUMMYUNIONNAME.cStr, ppsz);
        break;

    default:
        *ppsz = NULL;
        hres = E_FAIL;
    }
    return hres;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\security.cpp ===
//
// security.h
//
// Implementation of CTSSecurity
// TS Client Shell Security functions
//
// Copyright(C) Microsoft Corporation 2001
// Author: Nadim Abdo (nadima)
//
//

#include "stdafx.h"

#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "security"
#include <atrcapi.h>


#include "security.h"
#include "tscsetting.h"
#include "rdrwrndlg.h"
#include "autreg.h"
#include "autil.h"

CTSSecurity::CTSSecurity()
{
}

CTSSecurity::~CTSSecurity()
{
}

DWORD CTSSecurity::MakePromptFlags(BOOL fRedirectDrives,
                                   BOOL fRedirectPorts)
{
    DWORD dwFlags = REDIRSEC_PROMPT_EVERYTHING;
    if (fRedirectDrives)
    {
        dwFlags |= REDIRSEC_DRIVES;
    }

    if (fRedirectPorts)
    {
        dwFlags |= REDIRSEC_PORTS;
    }

    return dwFlags;
}


//
// AllowConnection
// Purpose: Does security cheks to determine if the connection should
//          proceed based on selected redirection options. This function
//          will look at the security policy in the registry for that
//          server and decide if the user needs to be prompted.
//          If so it will pop UI.
//
// Params:
//          hwndOwner - owning window (parents the dialog if we pop UI)
//          hInstance - app instance for loading resources
//          szServer - server name we are connecting to
//          fRedirectDrives - drive redir requested
//          fRedirectPorts  - port redirection requested
//          fRedirectSmartCards - scard redir requested
//
// Returns: BOOLean TRUE if connection is allowed with these settings
//          false otherwise
//
// NOTE:    Can POP Modal UI
//
//
BOOL CTSSecurity::AllowConnection(HWND hwndOwner,
                                  HINSTANCE hInstance,
                                  LPCTSTR szServer,
                                  BOOL fRedirectDrives,
                                  BOOL fRedirectPorts)
{
    BOOL fAllowCon = FALSE;
    CUT ut;
    DWORD dwSecurityLevel;
    DC_BEGIN_FN("AllowConnection");

    //
    // First read the security level policy
    //
    dwSecurityLevel = ut.UT_ReadRegistryInt(
                                UTREG_SECTION,
                                REG_KEYNAME_SECURITYLEVEL,
                                TSC_SECLEVEL_MEDIUM);
    if (TSC_SECLEVEL_LOW == dwSecurityLevel)
    {
        TRC_NRM((TB,_T("Security level policy is set to low: check passed")));
        fAllowCon = TRUE;
        DC_QUIT;
    }

    if (fRedirectDrives ||
        fRedirectPorts)
    {
        DWORD dwSecurityFilter;
        DWORD dwSelectedOptions;
        DWORD dwFlagsToPrompt;
        //
        // Get the security filter for this server name
        //
        dwSecurityFilter = REDIRSEC_PROMPT_EVERYTHING;
        dwSecurityFilter = ut.UT_ReadRegistryInt(
                                REG_SECURITY_FILTER_SECTION,
                                (LPTSTR)szServer,
                                REDIRSEC_PROMPT_EVERYTHING);

        dwSelectedOptions = MakePromptFlags(fRedirectDrives,
                                            fRedirectPorts);

        TRC_ALT((TB,_T("Filter 0x%x Selected:0x%x"),
                       dwSecurityFilter,
                       dwSelectedOptions));

        //
        // Check if the filter allows the selected options
        // thru without prompt. The filter indicates which bits
        // are lalowed without prompt so NOT to see if any bits with
        // prompt remain.
        //
        dwFlagsToPrompt = dwSelectedOptions & ~dwSecurityFilter;
        if (dwFlagsToPrompt)
        {
            INT dlgRet;
            //
            // One or more options need a user prompt 
            // so pop the security UI
            //
            CRedirectPromptDlg rdrPromptDlg(hwndOwner,
                                            hInstance,
                                            dwSelectedOptions);
            dlgRet = rdrPromptDlg.DoModal();
            if (IDOK == dlgRet)
            {
                //
                // User is allowing redirection to happen
                //
                if (rdrPromptDlg.GetNeverPrompt())
                {
                    DWORD dwNewFilterBits;

                    //
                    // We need to modify the filter bits
                    // by OR'ing in the current redirection settings
                    // and writing them back to the registry
                    //
                    dwNewFilterBits = dwSelectedOptions | dwSecurityFilter;
                    if (!ut.UT_WriteRegistryInt(
                                REG_SECURITY_FILTER_SECTION,
                                (LPTSTR)szServer,
                                REDIRSEC_PROMPT_EVERYTHING,
                                dwNewFilterBits))
                    {
                        TRC_ERR((TB,_T("Failed to write prompt bits to reg")));
                    }
                }

                fAllowCon = TRUE;
            }
            else
            {
                //
                // User hit cancel which means don't allow 
                // the connection to proceed
                //
                TRC_NRM((TB,_T("User canceled out of security dialog")));
                fAllowCon = FALSE;
                DC_QUIT;
            }
        }
        else
        {
            //
            // No option is selected that requires a prompt
            //
            fAllowCon = TRUE;
            DC_QUIT;
        }
    }
    else
    {
        //
        // No 'unsafe' device redirections requested so we just
        // allow the connection to go thru
        //

        fAllowCon = TRUE;
    }

    DC_END_FN();
DC_EXIT_POINT:
    return fAllowCon;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\shapi.cpp ===
//
// shapi.cpp: client shell util functions
//
// Copyright(C) Microsoft Corporation 1999-2000
// Author: Nadim Abdo (nadima)
//

#include "stdafx.h"

#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "shapi.cpp"
#include <atrcapi.h>

#include "sh.h"
#include "aboutdlg.h"

#include "commctrl.h"
#include "autocmpl.h"

#include "shlobj.h"
#include "browsedlg.h"
#include "commdlg.h"

#define DEFAULT_RDP_FILE    TEXT("Default.rdp")
#define CHANNEL_SUBKEY_NAME TEXT("Addins")
#define CHANNEL_NAME_KEY    TEXT("Name")
//
// It is necessary to define multimon.h here so that
// the multimon functions in this file go through the
// multimon stubs (COMPILE_MULTIMON_STUBS) is defined
// in contwnd.cpp
//
#ifdef OS_WINNT
#include "multimon.h"
#endif

TCHAR CSH::_szBrowseForMore[SH_DISPLAY_STRING_MAX_LENGTH];

CSH::CSH() : _Ut()
{
    DC_MEMSET(&_SH, 0, sizeof(_SH));
    _tcscpy(_szFileName, TEXT(""));
    _tcscpy(_szAppName,  TEXT(""));
    _hAppIcon = NULL;
    _fFileForConnect = FALSE;
    _fFileForEdit    = FALSE;
    _fMigrateOnly = FALSE;
    _hInstance = NULL;
    _fConnectToConsole = FALSE;
    _fRegSessionSpecified = FALSE;
    _hModHHCTRL = NULL;
    _pFnHtmlHelp = NULL;
    _hUxTheme = NULL;
    _pFnEnableThemeDialogTexture = NULL;
    _fFailedToGetThemeDll = FALSE;
}

CSH::~CSH()
{
    DC_BEGIN_FN("~CSH");

    TRC_ASSERT(_hModHHCTRL == NULL,
               (TB, _T("HtmlHelp was not cleaned up on exit")));

    TRC_ASSERT(_hUxTheme == NULL,
               (TB, _T("uxtheme was not cleaned up on exit")));

    DC_END_FN();
}

//
// Init shell utilities
//
DCBOOL CSH::SH_Init(HINSTANCE hInstance)
{
    DC_BEGIN_FN("SH_Init");
    DC_TSTRCPY(_SH.regSession, _T(""));
    _SH.fRegDefault = TRUE;

    _SH.connectedStringID    = UI_IDS_FRAME_TITLE_CONNECTED_DEFAULT;
    _SH.disconnectedStringID = UI_IDS_APP_NAME;
    _hInstance = hInstance;


    //
    // Load Frequently used resource strings
    //
    if (!LoadString( hInstance,
                    UI_IDS_BROWSE_FOR_COMPUTERS,
                    _szBrowseForMore,
                    SH_DISPLAY_STRING_MAX_LENGTH))
    {
        TRC_ERR((TB, _T("Failed to load UI_IDS_BROWSE_FOR_COMPUTERS")));
        return FALSE;
    }

    if(!LoadString(hInstance,
                  UI_IDS_APP_NAME,
                  _szAppName,
                  SIZECHAR(_szAppName)))
    {
        TRC_ERR((TB,_T("LoadString UI_IDS_APP_NAME failed"))); 
    }


    if (LoadString( hInstance,
                    _SH.disconnectedStringID,
                    _frameTitleStr,
                    SH_FRAME_TITLE_RESOURCE_MAX_LENGTH ) != 0)
    {
        //
        // Successfully loaded the string.  Now include the registry
        // session name.
        //
        TRC_DBG((TB, _T("UI frame title loaded OK.")));
        if (_SH.fRegDefault)
        {
            TRC_DBG((TB, _T("Default session")));
            DC_TSPRINTF(_fullFrameTitleStr, _frameTitleStr);
        }
        else
        {
            TRC_DBG((TB, _T("Named session")));
            DC_TSPRINTF(_fullFrameTitleStr, _frameTitleStr, _SH.regSession);
        }
    }
    else
    {
        TRC_ERR((TB,_T("Failed to find UI frame title")));
        _fullFrameTitleStr[0] = (DCTCHAR) 0;
    }

    _hAppIcon = NULL;
#if defined(OS_WIN32) && !defined(OS_WINCE)
    _Ut.UT_ReadRegistryString(_SH.regSession,
                              SH_ICON_FILE,
                              _T(""),
                              _SH.szIconFile,
                              MAX_PATH);

    _SH.iconIndex = _Ut.UT_ReadRegistryInt(_SH.regSession,
                                   SH_ICON_INDEX,
                                   0);

    _hAppIcon = ::ExtractIcon(hInstance, _SH.szIconFile, _SH.iconIndex);

    if(NULL == _hAppIcon)
    {
        _hAppIcon = LoadIcon(hInstance, MAKEINTRESOURCE(UI_IDI_ICON));
    }
#else
    _hAppIcon = LoadIcon(hInstance, MAKEINTRESOURCE(UI_IDI_ICON));
#endif

    DC_END_FN();
    return TRUE;
}


/****************************************************************************/
/* Name:      SH_ParseCmdParam
/*
/* Purpose:   Parses the supplied cmdline
/*
/* Params:    IN - lpszCmdParam - cmd line to parse
/*
/* Returns:   Parsing status code
/*            
/*            SH_PARSECMD_OK - parsed successfully
/*            SH_PARSECMD_ERR_INVALID_CMD_LINE - generic parse error
/*            SH_PARSECMD_ERR_INVALID_CONNECTION_PARAM - invalid connect param
/*
/****************************************************************************/
DWORD CSH::SH_ParseCmdParam(LPTSTR lpszCmdParam)
{
    DWORD dwRet = SH_PARSECMD_ERR_INVALID_CMD_LINE;
    DC_BEGIN_FN("SHParseCmdParam");

    DC_TSTRCPY(_SH.regSession, SH_DEFAULT_REG_SESSION);
    if(!lpszCmdParam)
    {
        dwRet = SH_PARSECMD_ERR_INVALID_CMD_LINE;
        DC_QUIT;
    }

    while (*lpszCmdParam)
    {
        while (*lpszCmdParam == _T(' '))
            lpszCmdParam++;

        switch (*lpszCmdParam)
        {
            case _T('\0'):
                break;

            case _T('-'):
            case _T('/'):
                lpszCmdParam = SHGetSwitch(++lpszCmdParam);
                if(!lpszCmdParam) {
                    dwRet = SH_PARSECMD_ERR_INVALID_CMD_LINE;
                    DC_QUIT;
                }
                break;

            default:
                lpszCmdParam = SHGetSession(lpszCmdParam);
                break;
        }
    }

    SHValidateParsedCmdParam();

    //
    // Figure out if the connection param specified is a file
    // or a reg key
    //
    if (ParseFileOrRegConnectionParam()) {
        dwRet = SH_PARSECMD_OK;
    }
    else {
        dwRet = SH_PARSECMD_ERR_INVALID_CONNECTION_PARAM;
    }

    DC_END_FN();

DC_EXIT_POINT:
    return dwRet;
}

DCBOOL CSH::SH_ValidateParams(CTscSettings* pTscSet)
{
    HRESULT hr;
    BOOL fRet = FALSE;
    DC_BEGIN_FN("SH_ValidateParams");

    //
    // If the Address is empty, the params are invalid
    //
    if(pTscSet)
    {
        if (CRdpConnectionString::ValidateServerPart(
                                pTscSet->GetFlatConnectString())) {
            fRet = TRUE;
        }
    }

    DC_END_FN();
    return fRet;
}


DCVOID CSH::SetServer(PDCTCHAR szServer)
{
    DC_BEGIN_FN("SetServer");
    TRC_ASSERT(szServer, (TB,_T("szServer not set")));
    if(szServer)
    {
        DC_TSTRNCPY( _SH.szServer, szServer, sizeof(_SH.szServer)/sizeof(DCTCHAR));
    }

    DC_END_FN();
}

HICON CSH::GetAppIcon()
{
    DC_BEGIN_FN("GetAppIcon");
    return _hAppIcon;
    DC_END_FN();
}

//
// Read the control version string/cipher strength and store in _SH
//
DCBOOL CSH::SH_ReadControlVer(IMsRdpClient* pTsControl)
{
    HRESULT hr = E_FAIL;
    BSTR bsVer;
    LONG cipher;

    USES_CONVERSION;

    DC_BEGIN_FN("SH_ReadControlVer");

    TRC_ASSERT(pTsControl, (TB, _T("Null TS CTL\n")));
    if(!pTsControl)
    {
        return FALSE;
    }

    TRACE_HR(pTsControl->get_CipherStrength(&cipher));
    if(SUCCEEDED(hr))
    {
        _SH.cipherStrength = (DCINT)cipher;
        TRACE_HR(pTsControl->get_Version(&bsVer));
        if(SUCCEEDED(hr))
        {
            if(bsVer)
            {
                LPTSTR szVer = OLE2T(bsVer);
                _tcsncpy(_SH.szControlVer, szVer, SIZECHAR(_SH.szControlVer));
                SysFreeString(bsVer);
            }
            else
            {
                _tcscpy(_SH.szControlVer, _T(""));
            }
        }
        else
        {
            return FALSE;
            
        }
    }
    else
    {
        return FALSE;
    }
    

    DC_END_FN();
    return TRUE;
}

//
// Overide the _SH settings with params read in from
// the command line
// this should be called right after GetRegConfig is
// called
//
// hwnd is the window we are being called for (used to figure
// out which multimon screen we are on.)
//
DCVOID  CSH::SH_ApplyCmdLineSettings(CTscSettings* pTscSet, HWND hwnd)
{
    DC_BEGIN_FN("SH_ApplyCmdLineSettings");
    #ifdef OS_WINNT
    HMONITOR  hMonitor;
    MONITORINFO monInfo;
    #endif // OS_WINNT
    TRC_ASSERT(pTscSet,(TB,_T("pTscSet is NULL")));

    PDCTCHAR szCmdLineServer = GetCmdLineServer();
    if(szCmdLineServer[0] != 0)
    {
        pTscSet->SetConnectString(szCmdLineServer);

        //
        // If a command line server is specified
        // it means autoconnect
        //
        SetAutoConnect(TRUE);
    }

    if (_SH.fCommandStartFullScreen)
    {
        pTscSet->SetStartFullScreen(TRUE);
    }

    DCUINT desktopWidth = DEFAULT_DESKTOP_WIDTH;
    DCUINT desktopHeight = DEFAULT_DESKTOP_HEIGHT;
    
    if (SH_IsScreenResSpecifiedOnCmdLine())
    {
        //
        // User has specified start size on command line
        //
        desktopWidth = GetCmdLineDesktopWidth();
        desktopHeight= GetCmdLineDesktopHeight();
    
        if(GetCmdLineStartFullScreen())
        {
            //
            // StartFullScreen is specified
            //
            if(!desktopWidth || !desktopHeight)
            {
                //
                // set the desktop width/height
                // to the screen size
                //
                #ifdef OS_WINNT
                if (GetSystemMetrics(SM_CMONITORS)) {
                    hMonitor = MonitorFromWindow( hwnd,
                                                  MONITOR_DEFAULTTONULL);
                    if (hMonitor != NULL) {
                        monInfo.cbSize = sizeof(MONITORINFO);
                        if (GetMonitorInfo(hMonitor, &monInfo)) {
                            desktopWidth = monInfo.rcMonitor.right -
                                           monInfo.rcMonitor.left;
                            desktopHeight = monInfo.rcMonitor.bottom - 
                                            monInfo.rcMonitor.top;
                        }
                    }
                }
                #else
                desktopWidth = GetSystemMetrics(SM_CXSCREEN);
                desktopHeight = GetSystemMetrics(SM_CYSCREEN);
                #endif // OS_WINNT
            }
        }

        if (desktopWidth && desktopHeight)
        {
            pTscSet->SetDesktopWidth(desktopWidth);
            pTscSet->SetDesktopHeight(desktopHeight);

            if (!_SH.fCommandStartFullScreen)
            {
                //If command line w/h specified and fullscreen
                //not explicitliy stated then disable fullscreen
                pTscSet->SetStartFullScreen(FALSE);
            }
        }
    }

    if (_fConnectToConsole)
    {
        // Without it we leave it however it was specified in the .rdp file
        pTscSet->SetConnectToConsole(_fConnectToConsole);
    }

    DC_END_FN();
}

//
// Return true if the screen res was specified
// on the command line
//
DCBOOL CSH::SH_IsScreenResSpecifiedOnCmdLine()
{
    return (_SH.fCommandStartFullScreen ||
            (_SH.commandLineHeight &&
             _SH.commandLineWidth));
}

DCBOOL CSH::SH_CanonicalizeServerName(PDCTCHAR szServer)
{
    // Remove leading spaces
    int strLength = DC_TSTRBYTELEN(szServer);
    while (_T(' ') == szServer[0])
    {
        strLength -= sizeof(DCTCHAR);
        memmove(&szServer[0], &szServer[1], strLength);
    }

    // Remove trailing spaces -- allow for DBCS strings.
    // At this stage, the string cannot consist entirely
    // of spaces. It must have at least one character,
    // followed by zero or more spaces.
    int numChars = _tcslen(szServer);
    while ((numChars != 0) &&
        (_T(' ') == szServer[numChars - 1])
#ifndef UNICODE
        && (!IsDBCSLeadByte(szServer[numChars - 2]))
#endif
        )
    {
        numChars--;
        szServer[numChars] = _T('\0');
    }

    //check for "\\" before the server address and remove it and
    //store the server address without the "\\" into szServer

    if((szServer[0] == _T('\\')) && (szServer[1]== _T('\\')))
    {
        strLength = DC_TSTRBYTELEN(szServer) - 2*sizeof(DCTCHAR);
        memmove(&szServer[0], &szServer[2], strLength);
    }
    return TRUE;
}

//
// Initializes the combo (hwndSrvCombo) for autocompletion
// with the MRU server names in the pTscSet collection.
//
void CSH::InitServerAutoCmplCombo(CTscSettings* pTscSet, HWND hwndSrvCombo)
{
    DC_BEGIN_FN("InitServerComboEx");

    if(pTscSet && hwndSrvCombo)
    {
        SendMessage(hwndSrvCombo,
            CB_LIMITTEXT,
            SH_MAX_ADDRESS_LENGTH-1,
            0);

        //
        // This call can be used to re-intialize a combo
        // so delete any items first
        //
#ifndef OS_WINCE
        INT ret = 1;
        while(ret && ret != CB_ERR)
        {
            ret = SendMessage(hwndSrvCombo,
                        CBEM_DELETEITEM,
                        0,0);
        }
#else
        SendMessage(hwndSrvCombo, CB_RESETCONTENT, 0, 0);
#endif

        for (int i=0; i<=9;++i)
        {
            if( _tcsncmp(pTscSet->GetMRUServer(i),_T(""),
                         TSC_MAX_ADDRESS_LENGTH) )
            {
#ifndef OS_WINCE
                COMBOBOXEXITEM cbItem;
                cbItem.mask = CBEIF_TEXT;
                cbItem.pszText = (PDCTCHAR)pTscSet->GetMRUServer(i);
                cbItem.iItem = -1; //append
#endif
                if(-1 == SendMessage(hwndSrvCombo,
#ifdef OS_WINCE
                            CB_ADDSTRING,
                            0, (LPARAM)(LPCSTR)(PDCTCHAR)pTscSet->GetMRUServer(i)))
#else
                            CBEM_INSERTITEM,
                            0,(LPARAM)&cbItem))
#endif
                {
                    TRC_ERR((TB,(_T("Error appending to server dialog box"))));
                }
            }
        }

        //
        // Add browse for more option to server combo
        //
#ifndef OS_WINCE
        COMBOBOXEXITEM cbItem;
        cbItem.mask = CBEIF_TEXT;
        cbItem.pszText = CSH::_szBrowseForMore;
        cbItem.iItem = -1; //append
#endif
        if(-1 == SendMessage(hwndSrvCombo,
#ifdef OS_WINCE
                    CB_ADDSTRING,
                    0,(LPARAM)CSH::_szBrowseForMore))
#else
                    CBEM_INSERTITEM,
                    0,(LPARAM)&cbItem))
#endif
        {
            TRC_ERR((TB,(_T("Error appending to server dialog box"))));
        }


        //
        // Never select the browse for server's item
        //
        int numItems = SendMessage(hwndSrvCombo,
                           CB_GETCOUNT,
                           0,0);
        
        if(numItems != 1)
        {
            SendMessage( hwndSrvCombo, CB_SETCURSEL, (WPARAM)0,0);
        }
        
#ifndef OS_WINCE        
        SendMessage( hwndSrvCombo, CBEM_SETEXTENDEDSTYLE, (WPARAM)0, 
                     CBES_EX_NOEDITIMAGE );
        //
        // Enable autocomplete
        //
        HWND hwndEdit = (HWND)SendMessage( hwndSrvCombo,
                         CBEM_GETEDITCONTROL, 0, 0);
    
        CAutoCompl::EnableServerAutoComplete( pTscSet, hwndEdit);
#endif

#ifdef OS_WINCE
        //This is to avoid WinCE quirk(bug??)
        //When the "Browse for more" entry is selected in the combo
        //and the name of the selected server is programmatically set
        //in the edit control with SetWindowText in the CBN_SELCHANGE handler
        //the text is cleared internally because the corresponding entry isnt 
        //present in the list box. This is done only if the CBS_HASSTRINGS flag 
        //is set. But the CBS_HASSTRINGS is always added when the combo box is
        //created. I am removing the style here so the text isnt cleared by default.
        SetWindowLong(hwndSrvCombo, GWL_STYLE, 
            GetWindowLong(hwndSrvCombo, GWL_STYLE) & ~CBS_HASSTRINGS);
#endif

    }
    DC_END_FN();
}

//
// Return the filename that defines connection
// settings. This may be a temp file that has been
// automigrated from a reg session.
//
LPTSTR CSH::GetCmdLineFileName()
{
    return _szFileName;
}


//
// Return path to default.rdp file
//
BOOL CSH::SH_GetPathToDefaultFile(LPTSTR szPath, UINT nLen)
{
    DC_BEGIN_FN("SH_GetPathToDefaultFile");
    if(nLen >= MAX_PATH)
    {
        if(SH_GetRemoteDesktopFolderPath(szPath, nLen))
        {
            HRESULT hr = StringCchCat(szPath, nLen, DEFAULT_RDP_FILE);
            if (FAILED(hr)) {
                TRC_ERR((TB, _T("String concatenation failed: hr = 0x%x"), hr));
                return FALSE;
            }
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }

    DC_END_FN();
}

//
// Get the path to the remote desktop folder
// params:
//      szPath - receives path
//      nLen   - length of szPath
// Returns:
//      Success flag
// 
// Logic:
//  1) Try reg key lookup of the path (first EXPAND_SZ and then SZ)
//  2) Ask shell for location of MyDocuments and slap on suffix path
//  3) If all else fails try current directory as root + suffix path
//
//
BOOL CSH::SH_GetRemoteDesktopFolderPath(LPTSTR szPath, UINT nLen)
{
    DC_BEGIN_FN("SH_GetRemoteDesktopFolderPath");
    HRESULT hr;
    BOOL    fGotPathToMyDocs = FALSE;
    INT     cch;
    if(nLen >= MAX_PATH)
    {
        //
        // First see if there is a path specified in the registry
        //
        LPTSTR szRegPath = NULL;
		INT   len = (INT)nLen;
        _Ut.UT_ReadRegistryExpandSZ(SH_DEFAULT_REG_SESSION,
                                  REMOTEDESKTOPFOLDER_REGKEY,
                                  &szRegPath,
                                  &len);
        if(szRegPath)
        {
            int cchLen = 0;
            // User provided a reg key to override default
            // path so use that
            hr = StringCchCopy(szPath, nLen - 2, szRegPath);

            //Free returned buffer
            LocalFree( szRegPath );

            // Check if the string copy was successful.
            if (FAILED(hr)) {
                TRC_ERR((TB, _T("String copy failed: hr = 0x%x"), hr));
                return FALSE;
            }

            cchLen = _tcslen(szPath);
            if(szPath[cchLen-1] != _T('\\'))
            {
                hr = StringCchCat(szPath, nLen, _T("\\"));
                if (FAILED(hr)) {
                    TRC_ERR((TB, _T("String copy failed: hr = 0x%x"), hr));
                    return FALSE;
                }
            }
            TRC_NRM((TB,_T("Using path from registry %s"),
                     szPath));
            return TRUE;
        }

        //Next try non expando key
        _Ut.UT_ReadRegistryString(SH_DEFAULT_REG_SESSION,
                                  REMOTEDESKTOPFOLDER_REGKEY,
                                  _T(""),
                                  szPath,
                                  nLen-2);
        if(szPath[0] != 0)
        {
            int cchLen = 0;
            cchLen = _tcslen(szPath);
            if(szPath[cchLen-1] != _T('\\'))
            {
                hr = StringCchCat(szPath, nLen, _T("\\"));
                if (FAILED(hr)) {
                    TRC_ERR((TB, _T("String copy failed: hr = 0x%x"), hr));
                    return FALSE;
                }
            }
            TRC_NRM((TB,_T("Using path from registry %s"),
                     szPath));
            return TRUE;
        }

        //
        // Not in registry, fallback on shell
        //

#ifndef OS_WINCE
        //
        // It would be cool to use the nice and simple
        // SHGetFolderPath api but that doesn't work with
        // all versions of shell32.dll (i.e if you don't have the
        // IE desktop update you don't get SHGetFolderPath).
        //
        // blah.
        //
        //
        LPITEMIDLIST ppidl = NULL;

        hr = SHGetSpecialFolderLocation(NULL,
                                 CSIDL_PERSONAL,
                                 &ppidl);
        if(SUCCEEDED(hr) && ppidl)
        {
            hr = SHGetPathFromIDList(ppidl,
                                     szPath);
            TRC_ASSERT(SUCCEEDED(hr),
                       (TB,_T("SHGetPathFromIDList failed: %d"),hr));
            if(SUCCEEDED(hr))
            {
                fGotPathToMyDocs = TRUE;
            }

            IMalloc* pMalloc;
            hr = SHGetMalloc(&pMalloc);
            TRC_ASSERT(SUCCEEDED(hr),
                       (TB,_T("SHGetMalloc failed: %d"),hr));
            if(SUCCEEDED(hr))
            {
                pMalloc->Free(ppidl);
                pMalloc->Release();
            }
        }
        else
        {
            TRC_ERR((TB,_T("SHGetSpecialFolderLocation failed 0x%x"),
                     hr));
        }

        if(!fGotPathToMyDocs)
        {
            TRC_ERR((TB,_T("Get path to my docs failed."),
                     _T("Root folder in current directory.")));
            #ifndef OS_WINCE
            //Oh well as a last resort, root the folder
            //in the current directory. Necessary because some early
            //versions of win95 didn't have a MyDocuments folder
            if(!GetCurrentDirectory( nLen, szPath))
            {
                TRC_ERR((TB,_T("GetCurrentDirectory failed - 0x%x"),
                         GetLastError()));
                return FALSE;
            }
            #endif
        }
#else
        TRC_NRM((TB,_T("Using \\Windows directory 0x%x")));
        _stprintf(szPath,_T("\\windows"));
#endif

        //
        // Terminate the path
        //
        cch = _tcslen(szPath);
        if (cch >= 1 && szPath[cch-1] != _T('\\'))
        {
            hr = StringCchCat(szPath, nLen, _T("\\"));
            if (FAILED(hr)) {
                TRC_ERR((TB, _T("String copy failed: hr = 0x%x"), hr));
                return FALSE;
            }
        }
        return TRUE;
    }
    else
    {
        return FALSE;
    }

    DC_END_FN();
}

//
// A worker function to make life easier in SH_GetPluginDllList. This function
// takes a source string, cats it to a destination string, and then appends
// a comma.
//

HRESULT StringCchCatComma(LPTSTR pszDest, size_t cchDest, LPCTSTR pszSrc) {
    HRESULT hr;
    
    DC_BEGIN_FN("StringCchCatComma");

    hr = StringCchCat(pszDest, cchDest, pszSrc);
    if (FAILED(hr)) {
        DC_QUIT;
    }
    hr = StringCchCat(pszDest, cchDest, _T(","));
    if (FAILED(hr)) {
        DC_QUIT;
    }

DC_EXIT_POINT:
    
    DC_END_FN();

    return hr;
}

//
// Creates a plugindlls list by enumerating all plugin dlls
// in szSession reg entry
//
// Note, entries are APPENDED to szPlugins
//
BOOL CSH::SH_GetPluginDllList(LPTSTR szSession, LPTSTR szPlugins, size_t cchSzPlugins)
{
    USES_CONVERSION;

    DC_BEGIN_FN("GetPluginDllList");

    TCHAR       subKey[UT_MAX_SUBKEY];
    TCHAR       sectKey[UT_MAX_SUBKEY];
    TCHAR       enumKey[UT_MAX_SUBKEY];
    TCHAR       DLLName[UT_MAX_WORKINGDIR_LENGTH];
    BOOL        rc;
    DWORD       i;
    INT         enumKeySize;
    CUT         ut;
    HRESULT     hr;

    TRC_ASSERT(szSession && szPlugins,
               (TB,_T("Invalid param(s)")));

    hr = StringCchPrintf(subKey, SIZECHAR(subKey), _T("%s\\%s"), 
                         szSession, CHANNEL_SUBKEY_NAME);
    if (FAILED(hr)) {
        TRC_ERR((TB, _T("String printf failed: hr = 0x%x"), hr));
        return FALSE;
    }

    //
    // Enumerate the registered DLLs
    //
    for (i = 0; ; i++)
    {
        enumKeySize = UT_MAX_SUBKEY;
        rc = ut.UT_EnumRegistry(subKey, i, enumKey, &enumKeySize);

        // If a section name is returned, read the DLL name from it
        if (rc)
        {
            TRC_NRM((TB, _T("Section name %s found"), enumKey));
            
            hr = StringCchPrintf(sectKey, SIZECHAR(sectKey), _T("%s\\%s"), 
                                 subKey, enumKey);
            if (FAILED(hr)) {
                TRC_ERR((TB, _T("String printf failed: hr = 0x%x"), hr));
                return FALSE;
            }

            TRC_NRM((TB, _T("Section to read: %s"), sectKey));

            //
            // First try to read as an expandable
            // string (i.e REG_EXPAND_SZ)
            //
            LPTSTR szExpandedName = NULL;
            INT    expandedNameLen=0;
            if(ut.UT_ReadRegistryExpandSZ(sectKey,
                                          CHANNEL_NAME_KEY,
                                          &szExpandedName,
                                          &expandedNameLen))
            {
                TRC_NRM((TB, _T("Expanded DLL Name read %s"), szExpandedName));
                // If a DLL name is returned, append it to the list
                if (szExpandedName && szExpandedName[0] != 0)
                {
                    hr = StringCchCatComma(szPlugins, cchSzPlugins, szExpandedName);

                    //Must free returned buffer
                    LocalFree( szExpandedName );

                    // Check if the string concatenation failed.
                    if (FAILED(hr)) {
                        TRC_ERR((TB, _T("String concatenation failed: hr = 0x%x"), hr));
                        return FALSE;
                    }
                }
            }
            else
            {
                memset(DLLName, 0, sizeof(DLLName));
                ut.UT_ReadRegistryString(sectKey,
                                          CHANNEL_NAME_KEY,
                                          TEXT(""),
                                          DLLName,
                                          UT_MAX_WORKINGDIR_LENGTH);
                TRC_NRM((TB, _T("DLL Name read %s"), DLLName));

                // If a DLL name is returned, append it to the list
                if (DLLName[0] != 0)
                {
                    //FIXFIX finite size of szPlugins
                    hr = StringCchCatComma(szPlugins, cchSzPlugins, DLLName);
                    if (FAILED(hr)) {
                        TRC_ERR((TB, _T("String concatenation failed: hr = 0x%x"), hr));
                        return FALSE;
                    }
                }
            }
        }

        else
        {
            //
            // No DLL name returned - end of enumeration
            //
            break;
        }
    }

    TRC_NRM((TB, _T("Passing list of plugins to load: %s"), szPlugins));
    return TRUE;
}


//
// Handle the server combo box drop down
// for browse for more... functionality.
// this fn is broken out into sh to avoid code duplication
// because it is used in both the maindlg and propgeneral
//
BOOL CSH::HandleServerComboChange(HWND hwndCombo,
                                         HWND hwndDlg,
                                         HINSTANCE hInst,
                                         LPTSTR szPrevText)
{
    int numItems = SendMessage(hwndCombo,
                               CB_GETCOUNT,
                               0,0);
    int curSel   = SendMessage(hwndCombo,
                               CB_GETCURSEL,
                               0,0);
    //
    // If last item is selected
    //
    if(curSel == numItems-1)
    {
        INT_PTR nResult = IDCANCEL;
    
        SendMessage( hwndCombo, CB_SETCURSEL, 
                     (WPARAM)-1,0);
    
        CBrowseDlg browseDlg( hwndDlg, hInst);
        nResult = browseDlg.DoModal();
    
        if (IDOK == nResult)
        {
            SetWindowText( hwndCombo,
                            browseDlg.GetServer());
        }
        else
        {
            //
            // Revert to initial
            //
            SetWindowText( hwndCombo,
                           szPrevText);
        }
    }
    return TRUE;
}

//
// Fill in certain settings in pTsc with system
// defaults.
//
// E.g if the username is blank, fill that in
// with the current username
//
BOOL CSH::SH_AutoFillBlankSettings(CTscSettings* pTsc)
{
    DC_BEGIN_FN("SH_AutoFillBlankSettings");
    TRC_ASSERT(pTsc,(TB,_T("pTsc is null")));

    #ifndef OS_WINCE
    //
    // TODO: update with UPN user name when
    // server limit of 20 chars is fixed
    //
    if(!_tcscmp(pTsc->GetLogonUserName(), TEXT("")))
    {
        TCHAR szUserName[TSC_MAX_USERNAME_LENGTH];
        DWORD dwLen = SIZECHAR(szUserName);
        if(::GetUserName(szUserName, &dwLen))
        {
            pTsc->SetLogonUserName( szUserName);
        }
        else
        {
            TRC_ERR((TB,_T("GetUserName failed: %d"), GetLastError()));
            return FALSE;
        }
    }
    #endif

    DC_END_FN();
    return TRUE;
}

//
// Return TRUE if szFileName exists
//
BOOL CSH::SH_FileExists(LPTSTR szFileName)
{
    BOOL fExist = FALSE;
    if(szFileName)
    {
        HANDLE hFile = CreateFile(szFileName,
                                  GENERIC_READ,
                                  FILE_SHARE_READ,
                                  NULL,
                                  OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL);
        if(hFile != INVALID_HANDLE_VALUE)
        {
            fExist = TRUE;
        }
        
        CloseHandle(hFile);
        return fExist;
    }
    else
    {
        return FALSE;
    }
}

//
// Return TRUE if the settings reg key exists
// under HK{CU|LM}\Software\Microsoft\Terminal Server Client\{szKeyName}
//
BOOL
CSH::SH_TSSettingsRegKeyExists(LPTSTR szKeyName)
{
    BOOL fRet = FALSE;
    HKEY hRootKey;
    LONG rc;
    TCHAR szFullKeyName[MAX_PATH];

    DC_BEGIN_FN("SH_TSSettingsRegKeyExists");

    if (_tcslen(szKeyName) + SIZECHAR(TSC_SETTINGS_REG_ROOT) +1 >=
        SIZECHAR(szFullKeyName)) {

        TRC_ERR((TB,_T("szKeyName invalid length")));
        fRet = FALSE;
        DC_QUIT;
    }

    //
    // String lengths are pre-validated
    //
    _tcscpy(szFullKeyName,TSC_SETTINGS_REG_ROOT);
    _tcscat(szFullKeyName, szKeyName);


    //
    // First try HKLM
    //

    rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      szFullKeyName,
                      0,
                      KEY_READ,
                      &hRootKey);
    if (ERROR_SUCCESS == rc && hRootKey) {

        //
        // Key exists undler HKLM
        //

        RegCloseKey(hRootKey);
        fRet = TRUE;
    }
    else {

        //
        // Try HKCU
        //
        rc = RegOpenKeyEx(HKEY_CURRENT_USER,
                          szFullKeyName,
                          0,
                          KEY_READ,
                          &hRootKey);
        if (ERROR_SUCCESS == rc && hRootKey) {

            RegCloseKey(hRootKey);
            fRet = TRUE;
        }
    }

    DC_END_FN();
DC_EXIT_POINT:
    return fRet;
}

BOOL CSH::SH_DisplayErrorBox(HWND hwndParent, INT errStringID)
{
    DC_BEGIN_FN("SH_DisplayErrorBox");

    return SH_DisplayMsgBox(hwndParent, errStringID,
                            MB_ICONERROR | MB_OK);

    DC_END_FN();
}

BOOL CSH::SH_DisplayMsgBox(HWND hwndParent, INT errStringID, INT flags)
{
    DC_BEGIN_FN("SH_DisplayMsgBox");

    TCHAR szErr[MAX_PATH];
    if (LoadString(_hInstance,
                   errStringID,
                   szErr,
                   SIZECHAR(szErr)) != 0)
    {
        MessageBox(hwndParent, szErr, _szAppName, 
                   flags);
        return TRUE;
    }
    else
    {
        return FALSE;
    }

    DC_END_FN();
}

BOOL CSH::SH_DisplayErrorBox(HWND hwndParent, INT errStringID, LPTSTR szParam)
{
    DC_BEGIN_FN("SH_DisplayErrorBox");
    TRC_ASSERT(szParam,(TB,_T("szParam is null")));
    if(!szParam)
    {
        return FALSE;
    }

    TCHAR szErr[MAX_PATH];
    if (LoadString(_hInstance,
                   errStringID,
                   szErr,
                   SIZECHAR(szErr)) != 0)
    {
        TCHAR szFormatedErr[MAX_PATH*2];
        _stprintf(szFormatedErr, szErr, szParam);
        MessageBox(hwndParent, szFormatedErr, _szAppName, 
                   MB_ICONERROR | MB_OK);
        return TRUE;
    }
    else
    {
        return FALSE;
    }

    DC_END_FN();
}

BOOL CSH::SH_GetNameFromPath(LPTSTR szPath, LPTSTR szName, UINT nameLen)
{
    DC_BEGIN_FN("SH_GetNameFromPath");
    #ifndef OS_WINCE
    if(szPath && szName && nameLen)
    {
        short ret = GetFileTitle(szPath,
                                 szName,
                                 (WORD)nameLen);
        if(ret != 0)
        {
            TRC_ERR((TB,_T("SH_GetNameFromPath failed: %d"),GetLastError()));
            szName[0] = 0;
            return FALSE;
        }
        else
        {
            //Strip out the extension
            int len = _tcslen(szName);
            LPTSTR szEnd = &szName[len-1];
            while(szEnd >= szName)
            {
                if(*szEnd == L'.')
                {
                    *szEnd = 0;
                }
                szEnd--;
            }
            return TRUE;
        }
    }
    else
    {
        return FALSE;
    }
    #else
    // no GetFileTitle on CE so just cheat
    _tcsncpy( szName, szPath, nameLen - 1);
    szName[nameLen-1] = 0;
    return TRUE;
    #endif

    DC_END_FN();
}

#ifndef OS_WINCE
//
// Compute and return the disaplay name of the My Documents folder
//
BOOL CSH::SH_GetMyDocumentsDisplayName(LPTSTR szName, UINT nLen)
{
    IShellFolder* pshf = NULL;
    LPITEMIDLIST pidl = NULL;
    LPITEMIDLIST pidlDocFiles = NULL;
    HRESULT hr = E_FAIL;
    ULONG chEaten;
    STRRET strret;
    
    DC_BEGIN_FN("SH_GetMyDocumentsDisplayName");

    TRC_ASSERT((szName && nLen),(TB,_T("NULL param(s)")));
    if(!szName || !nLen)
    {
        return FALSE;
    }

    //On failure null string
    szName[0] = NULL;

    //
    // First try the powerful shell way
    // which will return the correctly localized
    // name. If this fails (due to shell issues)
    // then fall back on a technique that is guaranteed
    // to work but may in some cases give the physical
    // path instead.
    //

    hr = SHGetDesktopFolder( &pshf );
    TRC_ASSERT(SUCCEEDED(hr),
               (TB,_T("SHGetDesktopFolder failed")));
    if(FAILED(hr) || !pshf)
    {
        DC_QUIT;
    }

    //
    // GUID to MyDocuments folder taken from
    // MSDN "shell basics - managing the filesystem -"
    //      "my documents and my pictures folder"
    //
    hr = pshf->ParseDisplayName( NULL, NULL,
                                 L"::{450d8fba-ad25-11d0-98a8-0800361b1103}",
                                 &chEaten, &pidlDocFiles, NULL );
    if(SUCCEEDED(hr))
    {
        hr = pshf->GetDisplayNameOf( pidlDocFiles, SHGDN_INFOLDER, &strret );
        if(SUCCEEDED(hr))
        {
            LPTSTR sz;
            hr = XStrRetToStrW(&strret, pidl, &sz);
            if(SUCCEEDED(hr))
            {
                _tcsncpy(szName, sz, nLen);
                szName[nLen-1] = NULL;
                CoTaskMemFree(sz);
                pshf->Release();
                return TRUE;
            }
            else
            {
                TRC_ERR((TB,_T("XStrRetToStrW failed :%d"), hr));
                DC_QUIT;
            }
        }
        else
        {
            TRC_ERR((TB,_T("GetDisplayNameOf failed :%d"), hr));
            //Don't quit, fall back and try the other method
        }
    }
    else
    {
        TRC_ERR((TB,_T("ParseDisplayName failed :%d"), hr));
        //Don't quit, fall back and try the other method
    }


    hr = SHGetSpecialFolderLocation(NULL,
                             CSIDL_PERSONAL,
                             &pidl);
    if(SUCCEEDED(hr) && pidl)
    {
        hr = pshf->GetDisplayNameOf(pidl,
                                    SHGDN_INFOLDER,
                                    &strret);
        if(SUCCEEDED(hr))
        {
            LPTSTR sz;
            hr = XStrRetToStrW(&strret, pidl, &sz);
            if(SUCCEEDED(hr))
            {
                _tcsncpy(szName, sz, nLen);
                szName[nLen-1] = NULL;
                CoTaskMemFree(sz);
                pshf->Release();
                return TRUE;
            }
            else
            {
                TRC_ERR((TB,_T("XStrRetToStrW failed :%d"), hr));
                DC_QUIT;
            }
        }
        else
        {
            TRC_ERR((TB,_T("GetDisplayNameOf failed :%d"), hr));
            DC_QUIT;
        }
    }
    else
    {
        TRC_ERR((TB,_T("SHGetSpecialFolderLocation failed 0x%x"),
                 hr));
        DC_QUIT;
    }

DC_EXIT_POINT:
    if(pshf)
    {
        pshf->Release();
        pshf = NULL;
    }
    DC_END_FN();
    TRC_ERR((TB,_T("failed to get display name")));
    return FALSE;
}
#endif //OS_WINCE

//
// On demand loads HTML help and displays the client help
// if the HTMLHELP is not available, pop a message box to
// the user.
// SH_Cleanup cleans up HTML help (unloads lib)
// on exit
//
// Return HWND to help window or NULL on failure
//
//
HWND CSH::SH_DisplayClientHelp(HWND hwndOwner, INT helpCommand)
{
    BOOL fHtmlHelpAvailable = FALSE;
    DC_BEGIN_FN("SH_DisplayClientHelp");

#ifndef OS_WINCE
    if(!_hModHHCTRL)
    {
        _hModHHCTRL = (HMODULE)LoadLibrary(_T("hhctrl.ocx"));
        if(_hModHHCTRL)
        {
            //
            // Use ANSI version of HTML Help so it always works
            // on downlevel platforms without uniwrap
            //
            _pFnHtmlHelp = (PFNHtmlHelp)GetProcAddress(_hModHHCTRL,
                                                       "HtmlHelpA");
            if(_pFnHtmlHelp)
            {
                fHtmlHelpAvailable = TRUE;
            }
            else
            {
                TRC_ERR((TB,_T("GetProcAddress failed for HtmlHelpA: 0x%x"),
                         GetLastError()));
            }
        }
        else
        {
            TRC_ERR((TB,_T("LoadLibrary failed for hhctrl.ocx: 0x%x"),
                     GetLastError()));
        }
    }
    else if (_pFnHtmlHelp)
    {
        fHtmlHelpAvailable = TRUE;
    }

    if(fHtmlHelpAvailable)
    {
        return _pFnHtmlHelp( hwndOwner, MSTSC_HELP_FILE_ANSI,
                             helpCommand, 0L);
    }
    else
    {
        //
        // Display a message to the user that HTML help is
        // not availalbe on their system.
        //
        SH_DisplayErrorBox( hwndOwner, UI_IDS_NOHTMLHELP);
        return NULL;
    }

#else
    if ((GetFileAttributes(PEGHELP_EXE) != -1) &&
        (GetFileAttributes(TSC_HELP_FILE) != -1))
    {
        CreateProcess(PEGHELP_EXE, MSTSC_HELP_FILE, 0,0,0,0,0,0,0,0);
    }
    else
    {
        SH_DisplayErrorBox( hwndOwner, UI_IDS_NOHTMLHELP);
    }
#endif

    DC_END_FN();
#ifdef OS_WINCE
    return NULL;
#endif
}

BOOL CSH::SH_Cleanup()
{
    DC_BEGIN_FN("SH_Cleanup");

    if(_hModHHCTRL)
    {
        FreeLibrary(_hModHHCTRL);
        _pFnHtmlHelp = NULL;
        _hModHHCTRL = NULL;
    }

    if (_hUxTheme)
    {
        FreeLibrary(_hUxTheme);
        _hUxTheme = NULL;
        _pFnEnableThemeDialogTexture = NULL;
    }


    DC_END_FN();
    return TRUE;
}

//
// Enable or disable an array of dlg controls
//
VOID CSH::EnableControls(HWND hwndDlg, PUINT pCtls,
                    const UINT numCtls, BOOL fEnable)
{
    DC_BEGIN_FN("EnableControls");

    for(UINT i=0;i<numCtls;i++)
    {
        EnableWindow( GetDlgItem( hwndDlg, pCtls[i]),
                      fEnable);
    }

    DC_END_FN();
}

//
// Enable or disable an array of dlg controls
// with memory. E.g previously disabled controls
// are not re-enabled.
//
VOID CSH::EnableControls(HWND hwndDlg, PCTL_ENABLE pCtls,
                         const UINT numCtls, BOOL fEnable)
{
    DC_BEGIN_FN("EnableControls");

    if(!fEnable)
    {
        //
        // Disable controls and remember which
        // were previously disabled
        //
        for(UINT i=0;i<numCtls;i++)
        {
            pCtls[i].fPrevDisabled = 
                EnableWindow( GetDlgItem( hwndDlg, pCtls[i].ctlID),
                              FALSE);
        }
    }
    else
    {
        //Enable controls that were not initially disabled
        for(UINT i=0;i<numCtls;i++)
        {
            if(!pCtls[i].fPrevDisabled)
            {
                EnableWindow( GetDlgItem( hwndDlg, pCtls[i].ctlID),
                              TRUE);
            }
        }
    }

    DC_END_FN();
}

//
// Attempt to create a directory by first
// creating all the subdirs
//
// Params - szPath (path to dir to create)
// Returns - status
//
BOOL CSH::SH_CreateDirectory(LPTSTR szPath)
{
    BOOL rc = TRUE;
    int i = 0;
    DC_BEGIN_FN("SH_CreateDirectory");

    if(szPath)
    {
        if(szPath[i] == _T('\\') &&
           szPath[i+1] == _T('\\'))
        {
            //Handle UNC path

            //Walk until the end of the server name
            i+=2;
            while (szPath[i] && szPath[i++] != _T('\\'));
            if(!szPath[i])
            {
                TRC_ERR((TB,_T("Invalid path %s"), szPath));
                return FALSE;
            }

            //Walk past drive letter if specified
            //e.g \\myserver\a$\foo
            if (szPath[i] &&
                szPath[i+1] == _T('$') &&
                szPath[i+2] == _T('\\'))
            {
                i+=3;
            }
        }
        else
        {
            //Local path
#ifndef OS_WINCE
            while(szPath[i] && szPath[i++] != _T(':'));
#endif
            if(szPath[i] && szPath[i] == _T('\\'))
            {
                i++; //Skip the first '\'
            }
            else
            {
                TRC_ERR((TB,_T("Invalid (or non local) path %s"),
                         szPath));
                return FALSE;
            }
        }
        while (rc && szPath[i] != 0)
        {
            if (szPath[i] == _T('\\'))
            {
                szPath[i] = 0;

                if (!CreateDirectory(szPath, NULL))
                {
                    if (GetLastError() != ERROR_ALREADY_EXISTS)
                    {
                        rc = FALSE;
                    }
                }
                szPath[i] = _T('\\');
            }
            i++;
        }
    }

    if(!rc)
    {
        TRC_ERR((TB,_T("SH_CreateDirectory failed")));
    }

    DC_END_FN();
    return rc;
}

UINT CSH::SH_GetScreenBpp()
{
    HDC hdc;
    int screenBpp;
    DC_BEGIN_FN("UI_GetScreenBpp");

    hdc = GetDC(NULL);
    if(hdc)
    {
        screenBpp = GetDeviceCaps(hdc, BITSPIXEL);
        TRC_NRM((TB, _T("HDC %p has %u bpp"), hdc, screenBpp));
        ReleaseDC(NULL, hdc);
    }

    DC_END_FN();
    return screenBpp;
}

//
// Crypto API is present on WIN2k+
//
BOOL CSH::IsCryptoAPIPresent()
{
#ifndef OS_WINCE
    OSVERSIONINFO osVersionInfo;
    osVersionInfo.dwOSVersionInfoSize = sizeof(osVersionInfo);

    if (GetVersionEx( &osVersionInfo ))
    {
        if (osVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT &&
            osVersionInfo.dwMajorVersion >= 5)
        {
            return TRUE;
        }
    }

    return FALSE;
#else
//CryptProtectData and CryptUnprotectData are present in all CE configs.
//(At least everything with filesys or registry) So return TRUE.always.
    return TRUE;
#endif
}

//
// DataProtect
// Protect data for persistence using data protection API
// params:
//      pInData   - (in) input bytes to protect
//      pOutData  - (out) output data caller must free
// returns: bool status
//

typedef BOOL (WINAPI* PFNCryptProtectData)(
    IN              DATA_BLOB*      pDataIn,
    IN              LPCWSTR         szDataDescr,
    IN OPTIONAL     DATA_BLOB*      pOptionalEntropy,
    IN              PVOID           pvReserved,
    IN OPTIONAL     CRYPTPROTECT_PROMPTSTRUCT*  pPromptStruct,
    IN              DWORD           dwFlags,
    OUT             DATA_BLOB*      pDataOut
    );

BOOL CSH::DataProtect(PDATA_BLOB pInData, PDATA_BLOB pOutData)
{
#ifndef OS_WINCE
    HMODULE hCryptLib = NULL;
    PFNCryptProtectData fnCryptProtectData = NULL;
#endif
    BOOL bRet = TRUE;

    DC_BEGIN_FN("DataProtect");

    TRC_ASSERT( IsCryptoAPIPresent(),
                (TB,_T("Crytpapi not present shouldn't call DataProtect")));

    if (pInData && pInData->cbData && pInData->pbData &&
        pOutData)
    {
#ifndef OS_WINCE
        hCryptLib = (HMODULE) LoadLibrary( _T("crypt32.dll") );
        if (hCryptLib)
        {
            fnCryptProtectData = (PFNCryptProtectData)
                GetProcAddress( hCryptLib, "CryptProtectData");

        }
        else
        {
            TRC_ERR((TB,_T("LoadLib for crypt32.dll failed: 0x%x"),
                     GetLastError()));
            return FALSE;
        }

        if (fnCryptProtectData)
        {
            if (fnCryptProtectData( pInData,
#else
            if (CryptProtectData( pInData,
#endif
                                  TEXT("psw"), // DESCRIPTION STRING.
                                  NULL, // optional entropy
                                  NULL, // reserved
                                  NULL, // NO prompting
                                  CRYPTPROTECT_UI_FORBIDDEN, //don't pop UI
                                  pOutData ))
            {
                bRet = TRUE;
            }
            else
            {
                DWORD dwLastErr = GetLastError();
                TRC_ERR((TB,_T("CryptProtectData FAILED error:%d\n"),
                               dwLastErr));
                bRet = FALSE;
            }
#ifndef OS_WINCE
        }
        else
        {
            TRC_ERR((TB,_T("GetProcAddress for CryptProtectData failed: 0x%x"),
                     GetLastError()));
            bRet = FALSE;
        }
#endif
    }
    else
    {
        TRC_ERR((TB,_T("Invalid data")));
        return FALSE;
    }
#ifndef OS_WINCE

    if (hCryptLib)
    {
        FreeLibrary(hCryptLib);
    }
#endif

    DC_END_FN();
    return bRet;
}

//
// DataUnprotect
// UnProtect persisted out data using data protection API
// params:
//      pInData   - (in) input bytes to UN protect
//      cbLen     - (in) length of pInData in bytes
//      ppOutData - (out) output bytes
//      pcbOutLen - (out) length of output
// returns: bool status
//
//

typedef BOOL (WINAPI* PFNCryptUnprotectData)(
    IN              DATA_BLOB*      pDataIn,
    IN              LPCWSTR         szDataDescr,
    IN OPTIONAL     DATA_BLOB*      pOptionalEntropy,
    IN              PVOID           pvReserved,
    IN OPTIONAL     CRYPTPROTECT_PROMPTSTRUCT*  pPromptStruct,
    IN              DWORD           dwFlags,
    OUT             DATA_BLOB*      pDataOut
    );

BOOL CSH::DataUnprotect(PDATA_BLOB pInData, PDATA_BLOB pOutData)
{
#ifndef OS_WINCE
    HMODULE hCryptLib = NULL;
    PFNCryptUnprotectData fnCryptUnprotectData = NULL;
#endif
    BOOL bRet = TRUE;

    DC_BEGIN_FN("DataUnprotect");

    TRC_ASSERT( IsCryptoAPIPresent(),
                (TB,_T("Crytpapi not present shouldn't call DataUnprotect")));

    if (pInData && pInData->cbData && pInData->pbData &&
        pOutData)
    {
#ifndef OS_WINCE
        hCryptLib = (HMODULE) LoadLibrary( _T("crypt32.dll") );

        if (hCryptLib)
        {
            fnCryptUnprotectData = (PFNCryptUnprotectData)
                GetProcAddress( hCryptLib, "CryptUnprotectData");
        }
        else
        {
            TRC_ERR((TB,_T("LoadLib for crypt32.dll failed: 0x%x"),
                     GetLastError()));
            return FALSE;
        }

        if (fnCryptUnprotectData)
        {
            if (fnCryptUnprotectData( pInData,
#else
            if (CryptUnprotectData( pInData,
#endif
                                  NULL, // no description
                                  NULL, // optional entropy
                                  NULL, // reserved
                                  NULL, // NO prompting
                                  CRYPTPROTECT_UI_FORBIDDEN, //don't pop UI
                                  pOutData ))
            {
                bRet = TRUE;
            }
            else
            {
                DWORD dwLastErr = GetLastError();
                TRC_ERR((TB,_T("fnCryptUnprotectData FAILED error:%d\n"),
                               dwLastErr));
                bRet = FALSE;
            }
#ifndef OS_WINCE
        }
        else
        {
            TRC_ERR((TB,_T("GetProcAddress for CryptUnprotectData failed: 0x%x"),
                     GetLastError()));
            bRet = FALSE;
        }
#endif
    }
    else
    {
        TRC_ERR((TB,_T("Invalid data")));
        return FALSE;
    }

#ifndef OS_WINCE
    if (hCryptLib)
    {
        FreeLibrary(hCryptLib);
    }
#endif

    DC_END_FN();
    return bRet;
}

#ifndef OS_WINCE
BOOL CALLBACK MaxMonitorSizeEnumProc(HMONITOR hMonitor, HDC hdcMonitor,
                                  RECT* prc, LPARAM lpUserData)
{
    LPRECT prcLrg = (LPRECT)lpUserData;

    if ((prc->right - prc->left) >= (prcLrg->right - prcLrg->left) &&
        (prc->bottom - prc->top) >= (prcLrg->bottom - prcLrg->top))
    {
        *prcLrg = *prc;
    }

    return TRUE;
}

#endif

BOOL CSH::GetLargestMonitorRect(LPRECT prc)
{
    DC_BEGIN_FN("GetLargestMonitorRect");
    if (prc)
    {
        // default screen size
        prc->top  = 0;
        prc->left = 0;
        prc->bottom = GetSystemMetrics(SM_CYSCREEN);
        prc->right  = GetSystemMetrics(SM_CXSCREEN);

#ifndef OS_WINCE //No multimon on CE
        if (GetSystemMetrics(SM_CMONITORS))
        {
            //Enumerate and look for a larger monitor
            EnumDisplayMonitors(NULL, NULL, MaxMonitorSizeEnumProc,
                                (LPARAM) prc);
        }
#endif //OS_WINCE
        return TRUE;
    }
    else
    {
        return FALSE;
    }
    DC_END_FN();
}

BOOL CSH::MonitorRectFromHwnd(HWND hwnd, LPRECT prc)
{
#ifndef OS_WINCE
    HMONITOR  hMonitor;
    MONITORINFO monInfo;
#endif

    DC_BEGIN_FN("MonitorRectFromHwnd")

    // default screen size
    prc->top  = 0;
    prc->left = 0;
    prc->bottom = GetSystemMetrics(SM_CYSCREEN);
    prc->right  = GetSystemMetrics(SM_CXSCREEN);

#ifndef OS_WINCE
    // for multi monitor, need to find which monitor the client window
    // resides, then get the correct screen size of the corresponding
    // monitor

    if (GetSystemMetrics(SM_CMONITORS))
    {
        hMonitor = MonitorFromWindow( hwnd, MONITOR_DEFAULTTONULL);
        if (hMonitor != NULL)
        {
            monInfo.cbSize = sizeof(MONITORINFO);
            if (GetMonitorInfo(hMonitor, &monInfo))
            {
                *prc = monInfo.rcMonitor;
            }
        }
    }
#endif

    DC_END_FN();
    return TRUE;
}

BOOL CSH::MonitorRectFromNearestRect(LPRECT prcNear, LPRECT prcMonitor)
{
#ifndef OS_WINCE
    HMONITOR  hMonitor;
    MONITORINFO monInfo;
#endif

    DC_BEGIN_FN("MonitorRectFromHwnd")

    // default screen size
    prcMonitor->top  = 0;
    prcMonitor->left = 0;
    prcMonitor->bottom = GetSystemMetrics(SM_CYSCREEN);
    prcMonitor->right  = GetSystemMetrics(SM_CXSCREEN);

    // for multi monitor, need to find which monitor the client window
    // resides, then get the correct screen size of the corresponding
    // monitor
#ifndef OS_WINCE
    if (GetSystemMetrics(SM_CMONITORS))
    {
        hMonitor = MonitorFromRect(prcNear,
                                   MONITOR_DEFAULTTONEAREST);

        if (hMonitor != NULL)
        {
            monInfo.cbSize = sizeof(MONITORINFO);
            if (GetMonitorInfo(hMonitor, &monInfo))
            {
                *prcMonitor = monInfo.rcMonitor;
            }
        }
    }
#endif

    DC_END_FN();
    return TRUE;
}

LPTSTR CSH::FormatMessageVAList(LPCTSTR pcszFormat, va_list *argList)

{
    LPTSTR  pszOutput;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                      pcszFormat,
                      0, 0,
                      reinterpret_cast<LPTSTR>(&pszOutput), 0,
                      argList) == 0)
    {
        pszOutput = NULL;
    }

    return(pszOutput);
}


LPTSTR CSH::FormatMessageVArgs(LPCTSTR pcszFormat, ...)

{
    LPTSTR      pszOutput;
    va_list     argList;

    va_start(argList, pcszFormat);
    pszOutput = FormatMessageVAList(pcszFormat, &argList);
    va_end(argList);
    return(pszOutput);
}


//
// Create a hidden file
//
BOOL CSH::SH_CreateHiddenFile(LPCTSTR szPath)
{
    HANDLE hFile;
    BOOL fRet = FALSE;
    DC_BEGIN_FN("SH_CreateHiddenFile");

    hFile = CreateFile( szPath,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_ALWAYS, //Creates if !exist
                        FILE_ATTRIBUTE_HIDDEN,
                        NULL);
    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle(hFile);
        fRet = TRUE;
    }
    else
    {
        TRC_ERR((TB, _T("CreateFile failed: %s - err:%x"),
                 szPath, GetLastError()));
        fRet = FALSE; 
    }

    DC_END_FN();
    return fRet;
}

BOOL CSH::SH_IsRunningOn9x()
{
    BOOL fRunningOnWin9x = FALSE;
    DC_BEGIN_FN("SH_IsRunningOn9x");

    fRunningOnWin9x = FALSE;
    OSVERSIONINFO osVersionInfo;
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    //call A version to avoid wrapping
    if(GetVersionEx(&osVersionInfo))
    {
        fRunningOnWin9x = (osVersionInfo.dwPlatformId ==
                            VER_PLATFORM_WIN32_WINDOWS);
    }
    else
    {
        fRunningOnWin9x = FALSE;
        TRC_ERR((TB,_T("GetVersionEx failed: %d\n"), GetLastError()));
    }

    DC_END_FN();
    return fRunningOnWin9x;
}

//
// Dynamically load and call the EnableThemeDialogTexture API
// (since it is not available on all platforms)
//
HRESULT CSH::SH_ThemeDialogWindow(HWND hwnd, DWORD dwFlags)
{
    HRESULT hr = E_NOTIMPL;
    DC_BEGIN_FN("SH_ThemeDialogWindow");

    if (_fFailedToGetThemeDll)
    {
        //
        // If failed once then bail out to avoid repeatedly
        // trying to load theme dll that isn't there
        //
        DC_QUIT;
    }

    if (!_hUxTheme)
    {
        _hUxTheme = (HMODULE)LoadLibrary(_T("uxtheme.dll"));
        if(_hUxTheme)
        {
            _pFnEnableThemeDialogTexture = (PFNEnableThemeDialogTexture)
#ifndef OS_WINCE
                GetProcAddress( _hUxTheme,
                                "EnableThemeDialogTexture");
#else
                GetProcAddress( _hUxTheme,
                                _T("EnableThemeDialogTexture"));
#endif
            if (NULL == _pFnEnableThemeDialogTexture)
            {
                _fFailedToGetThemeDll = TRUE;
                TRC_ERR((TB,
                 _T("Failed to GetProcAddress for EnableThemeDialogTexture")));
            }
            else
            {
                TRC_NRM((TB,_T("Got EnableThemeDialogTexture entry point")));
            }
        }
        else
        {
            _fFailedToGetThemeDll = TRUE;
            TRC_ERR((TB,_T("LoadLibrary failed for uxtheme: 0x%x"),
                     GetLastError()));
        }
    }


    if (_pFnEnableThemeDialogTexture)
    {
        hr = _pFnEnableThemeDialogTexture(hwnd, dwFlags);

        if (FAILED(hr)) {
            TRC_ERR((TB,_T("_pFnEnableThemeDialogTexture ret 0x%x\n"), hr));
        }
    }

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\sh.h ===
//SH.h
//Header for SH (client Shell Utilities)
//

#ifndef _SH_H_
#define _SH_H_

#include "wuiids.h"
#include "autil.h"

#define DEFAULT_DESKTOP_WIDTH              800
#define DEFAULT_DESKTOP_HEIGHT             600

#define SH_MAX_DOMAIN_LENGTH               52
#define SH_MAX_USERNAME_LENGTH             512
#define SH_MAX_PASSWORD_LENGTH             256
#define SH_SALT_LENGTH                     20
#define SH_FILENAME_MAX_LENGTH             15
#define SH_MAX_WORKINGDIR_LENGTH           512
#define SH_MAX_ALTERNATESHELL_LENGTH       512
#define SH_MAX_ADDRESS_LENGTH              256
#define SH_REGSESSION_MAX_LENGTH           32
#define SH_MAX_SUBKEY                      265

#define SH_NUM_SERVER_MRU                  10
#define SH_DEFAULT_REG_SESSION             TEXT("Default")

#define SH_WINDOW_POSITION_STR_LEN         256

#define SH_FRAME_TITLE_RESOURCE_MAX_LENGTH 256
#define SH_DISCONNECT_RESOURCE_MAX_LENGTH  1024

#define SH_BUILDNUMBER_STRING_MAX_LENGTH   256
#define SH_VERSION_STRING_MAX_LENGTH       256
#define SH_DISPLAY_STRING_MAX_LENGTH       256
#define SH_INTEGER_STRING_MAX_LENGTH       10
#define SH_SHORT_STRING_MAX_LENGTH         32

#define UI_HELP_SERVERNAME_CONTEXT         103

#ifdef DC_DEBUG
#define SH_NUMBER_STRING_MAX_LENGTH        ( 18 * sizeof (TCHAR) )
#endif /* DC_DEBUG */

#define TS_CONTROL_DLLNAME                 TEXT("mstscax.dll")

extern DCUINT clientResSizeTable[UI_NUMBER_DESKTOP_SIZE_IDS][2];

extern PDCTCHAR clientResSize[UI_NUMBER_DESKTOP_SIZE_IDS];

#define REMOTEDESKTOPFOLDER_REGKEY          TEXT("RemoteDesktopFolder")

#ifdef OS_WINCE
#define PRINTER_APPLET_NAME _T("\\windows\\wbtprncpl.dll")
#endif

// Screen mode constants

#define UI_WINDOWED        1
#define UI_FULLSCREEN      2

#define SH_DEFAULT_BPP  8
#define SH_DEFAULT_NUMCOLS 256

#define SH_NUMBER_FIELDS_TO_READ       6
#define SH_WINDOW_POSITION_INI_FORMAT  _T("%u,%u,%d,%d,%d,%d")

#define TRANSPORT_TCP 1

#if defined(OS_WIN32) && !defined(OS_WINCE)
#define SH_ICON_FILE  _T("Icon File")
#define SH_ICON_INDEX _T("Icon Index")
#endif

#ifdef OS_WINCE
#define PEGHELP_EXE _T("\\Windows\\peghelp.exe")
#define TSC_HELP_FILE _T("\\Windows\\termservclient.htm")
#define HH_DISPLAY_TOPIC     0x0000
#endif

typedef struct tagSH_DATA
{
    DCTCHAR    regSession[MAX_PATH];
    DCBOOL     fRegDefault;
    DCUINT     connectedStringID;
    DCUINT     disconnectedStringID;

    #if defined(OS_WIN32) && !defined(OS_WINCE)
    DCTCHAR    szIconFile[MAX_PATH];
    DCINT      iconIndex;
    #endif

    DCBOOL     fAutoLogon;
    DCBOOL     fClearPersistBitmapCache;
    DCBOOL     autoConnectEnabled;
    DCBOOL     fStartFullScreen;
    DCTCHAR    szServer[SH_MAX_ADDRESS_LENGTH];
    // Server specified from the command line
    DCTCHAR    szCommandLineServer[SH_MAX_ADDRESS_LENGTH];
    DCUINT     desktopWidth;
    DCUINT     desktopHeight;
    TCHAR      szCLXCmdLine[256];

    DCINT      cipherStrength;
    DCTCHAR    szControlVer[SH_DISPLAY_STRING_MAX_LENGTH];
    // Command line settings
    DCBOOL     fCommandStartFullScreen;
    DCUINT     commandLineWidth;
    DCUINT     commandLineHeight;
} SH_DATA, *PSH_DATA;

typedef HWND (WINAPI* PFNHtmlHelp)(HWND hwndCaller,
                                  LPCSTR pszFile,
                                  UINT uCommand,
                                  DWORD_PTR dwData);

typedef HRESULT (*PFNEnableThemeDialogTexture)(HWND hwnd,
                                               BOOL fEnable);

typedef struct tagCTL_ENABLE
{
    UINT    ctlID;
    BOOL    fPrevDisabled;
} CTL_ENABLE, *PCTL_ENABLE;

#ifndef OS_WINCE
//
// Mstsc's private copy of StrRetToStrW because
// this is not availalbe on less than shlwapi.dll v5.00
//
HRESULT     XSHStrDupA(LPCSTR psz, WCHAR **ppwsz);
HRESULT     XStrRetToStrW(STRRET *psr, LPCITEMIDLIST pidl, WCHAR **ppsz);
#endif

//
// CMD Line parsing error codes
//
#define SH_PARSECMD_OK                            1
#define SH_PARSECMD_ERR_INVALID_CMD_LINE         (-1)
#define SH_PARSECMD_ERR_INVALID_CONNECTION_PARAM (-2)


class CSH
{
public:
    //
    // Public members
    //
    CSH();
    ~CSH();

    DCBOOL      SH_Init(HINSTANCE hInstance);
    DWORD       SH_ParseCmdParam(LPTSTR lpszCmdParam);
    DCBOOL      SH_ValidateParams(CTscSettings* pTscSet);
    DCBOOL      SH_ReadControlVer(IMsRdpClient* pTsControl);
    DCVOID      SH_ApplyCmdLineSettings(CTscSettings* pTscSet, HWND hwnd);
    DCBOOL      SH_IsScreenResSpecifiedOnCmdLine();
    
    DCBOOL      SH_CanonicalizeServerName(PDCTCHAR szServer);
    static void InitServerAutoCmplCombo(CTscSettings* pTscSet, HWND hwndSrvCombo);
    BOOL        SH_GetCmdFileForEdit()     {return _fFileForEdit;}
    BOOL        SH_GetCmdFileForConnect()  {return _fFileForConnect;}
    
    LPTSTR      SH_GetCmdLnFileName()      {return _szFileName;}

    BOOL        SH_GetPathToDefaultFile(LPTSTR szPath, UINT nLen);
    BOOL        SH_GetRemoteDesktopFolderPath(LPTSTR szPath, UINT nLen);
#ifndef OS_WINCE
    BOOL        SH_GetMyDocumentsDisplayName(LPTSTR szName, UINT nLen);
#endif
    BOOL        SH_GetCmdMigrate()         {return _fMigrateOnly;}
    BOOL        SH_GetCmdConnectToConsole(){return _fConnectToConsole;}
    VOID        SH_SetCmdConnectToConsole(BOOL bCon) {_fConnectToConsole=bCon;}

    static BOOL SH_GetPluginDllList(LPTSTR szSession, LPTSTR szPlugins, size_t cchSzPlugins);

    static BOOL HandleServerComboChange(HWND hwndCombo, HWND hwndDlg,
                                        HINSTANCE hInst,
                                        LPTSTR szPrevText);
    BOOL        SH_AutoFillBlankSettings(CTscSettings* pTsc);

    BOOL        SH_FileExists(LPTSTR szFileName);
    BOOL        SH_TSSettingsRegKeyExists(LPTSTR szKeyName);
    BOOL        SH_DisplayErrorBox(HWND hwndParent, INT errStringID);
    BOOL        SH_DisplayMsgBox(HWND hwndParent, INT errStringID, INT flags);
    BOOL        SH_DisplayErrorBox(HWND hwndParent, INT errStringID, LPTSTR szParam);
    static BOOL SH_GetNameFromPath(LPTSTR szPath, LPTSTR szName, UINT nameLen);

    HWND        SH_DisplayClientHelp(HWND hwndOwner, INT helpCommand);
    BOOL        SH_Cleanup();

    static BOOL SH_CreateDirectory(LPTSTR szPath);
    static BOOL SH_CreateHiddenFile(LPCTSTR szPath);
    static UINT SH_GetScreenBpp();

    static BOOL SH_IsRunningOn9x();

    //
    // Property accessers
    //
    LPTSTR      GetCmdLineFileName();
    DCINT       GetCipherStrength()        {return _SH.cipherStrength;}
    PDCTCHAR    GetControlVersionString()  {return _SH.szControlVer;}

    VOID        SetAutoConnect(DCBOOL bAutoCon) {_SH.autoConnectEnabled = bAutoCon;}
    DCBOOL      GetAutoConnect()           {return _SH.autoConnectEnabled;}

    DCVOID      SetServer(PDCTCHAR szServer);
    PDCTCHAR    GetServer()                {return _SH.szServer;}

    DCUINT      GetCmdLineDesktopWidth()   {return _SH.commandLineWidth;}
    DCUINT      GetCmdLineDesktopHeight()  {return _SH.commandLineHeight;}

    DCVOID      SetStartFullScreen(DCBOOL b) {_SH.fStartFullScreen = b;}
    DCBOOL      GetStartFullScreen()       {return _SH.fStartFullScreen;}

    DCBOOL      GetCmdLineStartFullScreen(){return _SH.fCommandStartFullScreen;}

    LPTSTR      GetCmdLineServer()         {return _SH.szCommandLineServer;}
    LPTSTR      GetClxCmdLine()            {return _SH.szCLXCmdLine;}

    DCBOOL      GetUsingDefaultRegSession() {return _SH.fRegDefault;}
    PDCTCHAR    GetRegSession()            {return _SH.regSession;}

    DCUINT      GetConnectedStringID()     {return _SH.connectedStringID;}
    HICON       GetAppIcon();

    DCBOOL      GetAutoLogon()             {return _SH.fAutoLogon;}
    DCVOID      SetAutoLogon(DCBOOL b)     {_SH.fAutoLogon = b;}

    static VOID EnableControls(HWND hwndDlg, PUINT pCtls,
                               const UINT numCtls, BOOL fEnable);

    static VOID EnableControls(HWND hwndDlg, PCTL_ENABLE pCtls,
                           const UINT numCtls, BOOL fEnable);

    BOOL        GetRegSessionSpecified()    {return _fRegSessionSpecified;}
    VOID        SetRegSessionSpecified(BOOL b) {_fRegSessionSpecified = b;}

    // Crypto helpter fns
    static BOOL IsCryptoAPIPresent();
    static BOOL DataProtect(PDATA_BLOB pInData, PDATA_BLOB pOutData);
    static BOOL DataUnprotect(PDATA_BLOB pInData, PDATA_BLOB pOutData);

    // Multimon helpers
    static BOOL GetLargestMonitorRect(LPRECT prc);
    static BOOL MonitorRectFromHwnd(HWND hwnd, LPRECT prc);
    static BOOL MonitorRectFromNearestRect(LPRECT prcNear, LPRECT prcMonitor);
    static LPTSTR FormatMessageVArgs(LPCTSTR pcszFormat, ...);
    static LPTSTR FormatMessageVAList(LPCTSTR pcszFormat, va_list *argList);
    HRESULT SH_ThemeDialogWindow(HWND hwnd, DWORD dwFlags);

private:
    //
    // Internal member functions
    //
    PDCTCHAR    SHGetSwitch(PDCTCHAR lpszCmdParam);
    LPTSTR      SHGetSession(LPTSTR lpszCmdParam);
    LPTSTR      SHGetFileName(LPTSTR lpszCmdParam);
    LPTSTR      SHGetServer(LPTSTR lpszCmdParam);
    UINT        CLX_GetSwitch_CLXCMDLINE(IN LPTSTR lpszCmdParam);
    BOOL        ParseFileOrRegConnectionParam();
    LPTSTR      SHGetCacheToClear(LPTSTR lpszCmdParam);
    DCVOID      SHUpdateMRUList(PDCTCHAR pBuffer);
    LPTSTR      SHGetCmdLineInt(LPTSTR lpszCmdParam, PDCUINT pInt);
    LPTSTR      SHGetCmdLineString(LPTSTR lpszCmdParam, LPTSTR lpszDest,
                                   DCINT cbDestLen);
    DCBOOL      SHValidateParsedCmdParam();
public:
    //
    // Public data members
    //
    DCTCHAR     _fullFrameTitleStr[SH_FRAME_TITLE_RESOURCE_MAX_LENGTH +
                                   SH_REGSESSION_MAX_LENGTH];

    DCTCHAR     _frameTitleStr[SH_FRAME_TITLE_RESOURCE_MAX_LENGTH];
private:
    //
    // Private data members
    //
    SH_DATA _SH;
    CUT     _Ut;
    HICON   _hAppIcon;

    TCHAR          _szFileName[MAX_PATH];

    static TCHAR   _szBrowseForMore[SH_DISPLAY_STRING_MAX_LENGTH];

    BOOL    _fFileForEdit;
    BOOL    _fFileForConnect;
    BOOL    _fRegSessionSpecified;
    TCHAR   _szAppName[MAX_PATH];
    BOOL    _fMigrateOnly;
    HINSTANCE _hInstance;
    BOOL    _fConnectToConsole;

    //
    // Handle to HHCTL.OCX for HTML Help
    //
    HMODULE _hModHHCTRL;
    PFNHtmlHelp _pFnHtmlHelp;

    HMODULE _hUxTheme;
    PFNEnableThemeDialogTexture _pFnEnableThemeDialogTexture;
    BOOL    _fFailedToGetThemeDll;
};

#endif // _SH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	ClassicShell.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\thruputdlg.h ===
//
// thruputdlg.h: thruput dialog class
// Network thruput debugging dialog
//

#ifndef _thruputdlg_h_
#define _thruputdlg_h_

#ifdef DC_DEBUG

#include "dlgbase.h"
#include "sh.h"


class CThruPutDlg : public CDlgBase
{
public:
    CThruPutDlg(HWND hwndOwner, HINSTANCE hInst, DCINT thruPut);
    ~CThruPutDlg();

    virtual DCINT   DoModal();
    virtual INT_PTR CALLBACK DialogBoxProc(HWND hwndDlg, UINT uMsg,WPARAM wParam, LPARAM lParam);
    static  INT_PTR CALLBACK StaticDialogBoxProc(HWND hwndDlg, UINT uMsg,WPARAM wParam, LPARAM lParam);

    static CThruPutDlg* _pThruPutDlgInstance;

    DCINT GetNetThruPut()      {return _thruPut;}

private:
    DCINT _thruPut;
};

#endif //DC_DEBUG
#endif //_thruputdlg_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#ifndef _stdafx_h_
#define _stdafx_h_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers


// Windows Header Files:
#include <windows.h>

// C RunTime Header Files
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>

#include "wincrypt.h"


#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

//
// FIX WIN64 ATL problem
//
#if defined (_M_IA64)
#pragma comment(lib, "atl21asm.lib")
#endif

#if defined (_M_AMD64)
#pragma comment(lib, "atlamd64.lib")
#endif

#ifndef OS_WINCE
#include <atlbase.h>

extern CComModule _Module;

#include <atlcom.h>
#include <atlhost.h>
#include <atlctl.h>

#else	//OS_WINCE

#define _ATL_NO_DEBUG_CRT
#define ATLASSERT ASSERT
#include <atlconv.h>

#endif	//OS_WINCE

#define STRSAFE_NO_DEPRECATE 1
#include <strsafe.h>

//File generated by MIDL compiler
#include  "mstsax.h"

/****************************************************************************/
/* Help file name.                                                          */
/****************************************************************************/
#ifdef OS_WIN32
    #define UI_HELP_FILE_NAME              _T("MSTSC.HLP")
#else
    #define UI_HELP_FILE_NAME              _T("MSTSC16.HLP")
#endif

/****************************************************************************/
/* Help file contexts.                                                      */
/****************************************************************************/
#define UI_HELP_DISCONNECTING_CONTEXT  100
#define UI_HELP_DISCONNECTED_CONTEXT   101
#define UI_HELP_SHUTDOWN_CONTEXT       102
#define UI_HELP_SERVERNAME_CONTEXT     103


#define CHECK_RET_HR(f)	\
    hr = f; \
	TRC_ASSERT(SUCCEEDED(hr), (TB, _T("ts control method failed: ") _T(#f) )); \
	if(FAILED(hr)) return FALSE;
    
#define CHECK_DCQUIT_HR(f)	\
    hr = f; \
	TRC_ASSERT(SUCCEEDED(hr), (TB, _T("ts control method failed: ") _T(#f) )); \
	if(FAILED(hr)) goto DC_EXIT_POINT;
    
#ifdef DEBUG
#define TRACE_HR(f)	\
    hr = f; \
	if(FAILED(hr)) TRC_ERR((TB, _T("ts control method failed: ") _T(#f) _T(" hr: 0x%x"),hr));
#else
#define TRACE_HR(f) \
    hr = f;
#endif    


    
#include <adcgbase.h>
//Necessary to disable warnings in ATL headers
#pragma warning(disable:4127) //conditional expression is constant
#pragma warning(disable:4100) //unreferenced formal parameter


#include "tscerrs.h" //error codes

#define TS_CONTROL_CLSID _T("{8c11efaf-92c3-11d1-bc1e-00c04fa31489}"

#define WM_SAVEPROPSHEET      WM_USER+30
#define WM_UPDATEFROMSETTINGS WM_USER+31
#define WM_TSC_CONNECTED      WM_USER+32
#define WM_TSC_DISCONNECTED   WM_USER+33
#define WM_TSC_ENABLECONTROLS WM_USER+34
#define WM_TSC_RETURNTOCONUI  WM_USER+35


#define SIZECHAR(x) sizeof(x)/sizeof(TCHAR)
#define RDP_FILE_EXTENSION          TEXT(".rdp")
#define RDP_FILE_EXTENSION_NODOT    TEXT("RDP")

#define BOOL_TO_VB(x)   (x ? VARIANT_TRUE : VARIANT_FALSE)

#include "tscsetting.h"
#include "constr.h"

#include "commdlg.h"
#include "shellapi.h" //for ExtractIcon

#ifndef OS_WINCE
#include "htmlhelp.h"
#define MSTSC_HELP_FILE      _T("mstsc.chm")
#define MSTSC_HELP_FILE_ANSI    "mstsc.chm"
#else
#define MSTSC_HELP_FILE      L"file:TermServClient.htm#Main_Contents"
#endif

#ifdef OS_WINCE
#undef SMART_SIZING
#endif

#ifndef OS_WINCE
#include "uxtheme.h"
#endif

//
// uwrap has to come after the headers for ANY wrapped
// functions
//
#ifdef UNIWRAP
#include "uwrap.h"
#endif
#endif // _stdafx_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\thruputdlg.cpp ===
//
// thruputdlg.cpp: thruput dialog box
//

#include "stdafx.h"

#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "thruputdlg"
#include <atrcapi.h>

#include "thruputdlg.h"
#include "sh.h"

#ifdef DC_DEBUG

CThruPutDlg* CThruPutDlg::_pThruPutDlgInstance = NULL;

CThruPutDlg::CThruPutDlg( HWND hwndOwner, HINSTANCE hInst, DCINT thruPut) :
           CDlgBase( hwndOwner, hInst, UI_IDD_NETWORKTHROUGHPUT)
{
    DC_BEGIN_FN("CThruPutDlg");
    TRC_ASSERT((NULL == CThruPutDlg::_pThruPutDlgInstance), 
               (TB,_T("Clobbering existing dlg instance pointer\n")));

    _thruPut = thruPut;

    CThruPutDlg::_pThruPutDlgInstance = this;
    DC_END_FN();
}

CThruPutDlg::~CThruPutDlg()
{
    CThruPutDlg::_pThruPutDlgInstance = NULL;
}

DCINT CThruPutDlg::DoModal()
{
    DCINT retVal = 0;
    DC_BEGIN_FN("DoModal");

    retVal = DialogBox(_hInstance, MAKEINTRESOURCE(_dlgResId),
                       _hwndOwner, StaticDialogBoxProc);
    TRC_ASSERT((retVal != 0 && retVal != -1), (TB, _T("DialogBoxParam failed\n")));

    DC_END_FN();
    return retVal;
}

INT_PTR CALLBACK CThruPutDlg::StaticDialogBoxProc (HWND hwndDlg, UINT uMsg,WPARAM wParam, LPARAM lParam)
{
    //
    // Delegate to appropriate instance (only works for single instance dialogs)
    //
    DC_BEGIN_FN("StaticDialogBoxProc");
    DCINT retVal = 0;

    TRC_ASSERT(_pThruPutDlgInstance, (TB, _T("ThruPut dialog has NULL static instance ptr\n")));
    if(_pThruPutDlgInstance)
    {
        retVal = _pThruPutDlgInstance->DialogBoxProc( hwndDlg, uMsg, wParam, lParam);
    }

    DC_END_FN();
    return retVal;
}

/****************************************************************************/
/* Name: DialogBoxProc                                                      */
/*                                                                          */
/* Purpose: Handles ThruPut Box dialog  (limits network thruput)            */
/*                                                                          */
/* Returns: TRUE if message dealt with                                      */
/*          FALSE otherwise                                                 */
/*                                                                          */
/* Params: See window documentation                                         */
/*                                                                          */
/****************************************************************************/
INT_PTR CALLBACK CThruPutDlg::DialogBoxProc (HWND hwndDlg, UINT uMsg,WPARAM wParam, LPARAM lParam)
{
    INT_PTR  rc = FALSE;
    DCTCHAR  numberString[SH_NUMBER_STRING_MAX_LENGTH];
    DCUINT32 number;


    DC_BEGIN_FN("UINetworkThroughputDialogProc");

    TRC_DBG((TB, _T("Network throughput dialog")));

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            /****************************************************************/
            /* Center the dialog.                                           */
            /****************************************************************/
            _hwndDlg = hwndDlg;
            if(hwndDlg)
            {
                CenterWindow(NULL);
                SetDialogAppIcon(hwndDlg);

                /************************************************************/
                /* Set edit text with current throughput setting.           */
                /************************************************************/
                TRC_ASSERT((HIWORD(_thruPut) == 0), (TB, _T("Losing information from _thruPut")));
                SetDlgItemText(hwndDlg,
                               UI_IDC_NETWORKTHROUGHPUT_EDIT,
                               DC_ITOT(LOWORD(_thruPut), numberString, 10));
            }


            rc = TRUE;
        }
        break;

        case WM_COMMAND:
        {
            switch (wParam)
            {
                case UI_IDB_NETWORKTHROUGHPUT_OK:
                {
                    rc = TRUE;

                    if(hwndDlg)
                    {
                        GetWindowText(GetDlgItem(hwndDlg, UI_IDC_NETWORKTHROUGHPUT_EDIT),
                                      numberString,
                                      SH_NUMBER_STRING_MAX_LENGTH);


                        number = (DCUINT32)DC_TTOI(numberString);

                        if (number <= 50000)
                        {
                            _thruPut = number;
                            EndDialog(hwndDlg, IDOK);
                        }
                    }
                }
                break;

                default:
                {
                    if(hwndDlg)
                    {
                        rc = CDlgBase::DialogBoxProc(hwndDlg,
                                                  uMsg,
                                                  wParam,
                                                  lParam);
                    }
                }
                break;
            }
        }
        break;

        default:
        {
            if(hwndDlg)
            {
                rc = CDlgBase::DialogBoxProc(hwndDlg,
                                          uMsg,
                                          wParam,
                                          lParam);
            }
        }
        break;
    }

    DC_END_FN();
    return(rc);
}

#endif //DC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\tscapp.h ===
//
// tscapp.h
//
// Definition of CTscApp
// Ts Client Shell app logic
//
// Copyright(C) Microsoft Corporation 2000
// Author: Nadim Abdo (nadima)
//
//

#ifndef _tscapp_h_
#define _tscapp_h_

#include "contwnd.h"

class CTscApp
{
public:
    CTscApp();
    ~CTscApp();

    //
    // Public methods
    //
    BOOL StartShell(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    LPTSTR lpszCmdLine);
    BOOL EndShell();
    HWND GetTscDialogHandle();

private:
    BOOL InitSettings(HINSTANCE hInstance);
    BOOL CreateRDdir();
    HINSTANCE       _hInst;
    CContainerWnd*  _pWnd;
    CSH*            _pShellUtil;
    CTscSettings*   _pTscSet;
    BOOL            _fAutoSaveSettings;

};

#endif //_tscapp_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\tscdefines.h ===
//
// tscdefines.h
//
// Terminal Services Client defines
//
// Copyright(C) Microsoft Corporation 2000
// Author: Nadim Abdo (nadima)
//

#ifndef _TSCDEFINES_H_
#define _TSCDEFINES_H_

#include "tsperf.h"

#define DEFAULT_DESKTOP_WIDTH               800
#define DEFAULT_DESKTOP_HEIGHT              600
#define MIN_DESKTOP_WIDTH                   200
#define MIN_DESKTOP_HEIGHT                  200
#define MAX_DESKTOP_WIDTH                   1600
#define MAX_DESKTOP_HEIGHT                  1200

#define TSC_MAX_DOMAIN_LENGTH               512
#define TSC_MAX_USERNAME_LENGTH             512
#define TSC_MAX_PASSWORD_LENGTH_BYTES       512
#define TSC_WIN2K_PASSWORD_LENGTH_BYTES     32
#define TSC_SALT_LENGTH                     20
#define TSC_FILENAME_MAX_LENGTH             15
#define TSC_MAX_WORKINGDIR_LENGTH           512
#define TSC_MAX_ALTERNATESHELL_LENGTH       512
#define TSC_MAX_ADDRESS_LENGTH              256
#define TSC_REGSESSION_MAX_LENGTH           32
#define TSC_MAX_SUBKEY                      265

#define TSC_NUM_SERVER_MRU                  10
#define TSC_WINDOW_POSITION_STR_LEN         256

#define TSC_FRAME_TITLE_RESOURCE_MAX_LENGTH 256
#define TSC_DISCONNECT_RESOURCE_MAX_LENGTH  256

#define TSC_BUILDNUMBER_STRING_MAX_LENGTH   256
#define TSC_VERSION_STRING_MAX_LENGTH       256
#define TSC_DISPLAY_STRING_MAX_LENGTH       256
#define TSC_INTEGER_STRING_MAX_LENGTH       10
#define TSC_SHORT_STRING_MAX_LENGTH         32
#define TSC_DEFAULT_BPP                     8

#define UI_HELP_SERVERNAME_CONTEXT          103

#ifdef DC_DEBUG
#define TSC_NUMBER_STRING_MAX_LENGTH        ( 18 * sizeof (DCTCHAR) )
#endif /* DC_DEBUG */

//Screen mode constants
#define UI_WINDOWED                         1
#define UI_FULLSCREEN                       2

#define TSC_NUMBER_FIELDS_TO_READ           6
#define TSC_WINDOW_POSITION_INI_FORMAT  _T("%u,%u,%d,%d,%d,%d")
#define TRANSPORT_TCP                       1

#define TSC_ICON_INDEX_DEFAULT              0
#define TSC_ICON_FILE  _T("Icon File")
#define TSC_ICON_INDEX _T("Icon Index")

#define TSC_DEFAULT_REG_SESSION _T("Default")

//
// Map the bitmap cache setting internally to a reserved
// bit in the disabled feature list (only used internally)
//
#define TS_PERF_DISABLE_BITMAPCACHING TS_PERF_RESERVED1

#define TSC_MAX_PASSLENGTH_TCHARS    (TSC_MAX_PASSWORD_LENGTH_BYTES / sizeof(TCHAR))


//
// Performance options dictate which features to
// enable or disable for a connection
//
#define TSCSETTING_PERFOPTIONS          _T("Performance Options")
#define TSCSETTING_PERFOPTIONS_DFLT     (TS_PERF_DISABLE_WALLPAPER      | \
                                         TS_PERF_DISABLE_FULLWINDOWDRAG | \
                                         TS_PERF_DISABLE_MENUANIMATIONS)
                                         


//
// Individual perf option settings
//
// Defaults must match configuration above in TSCSETTING_PERFOPTIONS_DFLT
//
#define PO_DISABLE_WALLPAPER                _T("Disable wallpaper")
#define PO_DISABLE_WALLPAPER_DFLT           1

#define PO_DISABLE_FULLWINDOWDRAG           _T("Disable full window drag")
#define PO_DISABLE_FULLWINDOWDRAG_DFLT      1

#define PO_DISABLE_MENU_WINDOW_ANIMS        _T("Disable menu anims")
#define PO_DISABLE_MENU_WINDOW_ANIMS_DFLT   1

#define PO_DISABLE_THEMES                   _T("Disable themes")
#define PO_DISABLE_THEMES_DFLT              0

#define PO_ENABLE_ENHANCED_GRAPHICS         _T("Enable enhanced graphics")
#define PO_ENABLE_ENHANCED_GRAPHICS_DFLT    0

#define PO_DISABLE_CURSOR_SETTINGS          _T("Disable Cursor Setting")
#define PO_DISABLE_CURSOR_SETTINGS_DFLT     0



#endif //_TSCDEFINES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\tscsetting.cpp ===
//
// tscsetting.cpp                                                        
//
// Terminal Services Client settings collection
//
// Copyright(C) Microsoft Corporation 2000
// Author: Nadim Abdo (nadima)
//

#include "stdafx.h"
#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "tscsetting.cpp"
#include <atrcapi.h>

#include "tscsetting.h"
#include "autreg.h"
#include "autil.h"
#include "wuiids.h"
#include "sh.h"


#ifdef OS_WINCE
//TEMP HACK for CE
BOOL UTREG_UI_DEDICATED_TERMINAL_DFLT = FALSE;
#endif
                   
LPCTSTR tscScreenResStringTable[UI_NUMBER_DESKTOP_SIZE_IDS] = {   _T("640x480"),
                                                                  _T("800x600"),
                                                                  _T("1024x768"),
                                                                  _T("1280x1024"),
                                                                  _T("1600x1200")
                                                               };
UINT tscScreenResTable[UI_NUMBER_DESKTOP_SIZE_IDS][2] =        {    {640,  480},
                                                                    {800,  600},
                                                                    {1024, 768},
                                                                    {1280, 1024},
                                                                    {1600, 1200}
                                                               };

const unsigned ProportionDefault[TS_BITMAPCACHE_MAX_CELL_CACHES] =
{
    UTREG_UH_BM_CACHE1_PROPORTION_DFLT,
    UTREG_UH_BM_CACHE2_PROPORTION_DFLT,
    UTREG_UH_BM_CACHE3_PROPORTION_DFLT,
    UTREG_UH_BM_CACHE4_PROPORTION_DFLT,
    UTREG_UH_BM_CACHE5_PROPORTION_DFLT,
};
#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
const unsigned PersistenceDefault[TS_BITMAPCACHE_MAX_CELL_CACHES] =
{
    UTREG_UH_BM_CACHE1_PERSISTENCE_DFLT,
    UTREG_UH_BM_CACHE2_PERSISTENCE_DFLT,
    UTREG_UH_BM_CACHE3_PERSISTENCE_DFLT,
    UTREG_UH_BM_CACHE4_PERSISTENCE_DFLT,
    UTREG_UH_BM_CACHE5_PERSISTENCE_DFLT,
};
#endif // ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))

const unsigned MaxEntriesDefault[TS_BITMAPCACHE_MAX_CELL_CACHES] =
{
    UTREG_UH_BM_CACHE1_MAXENTRIES_DFLT,
    UTREG_UH_BM_CACHE2_MAXENTRIES_DFLT,
    UTREG_UH_BM_CACHE3_MAXENTRIES_DFLT,
    UTREG_UH_BM_CACHE4_MAXENTRIES_DFLT,
    UTREG_UH_BM_CACHE5_MAXENTRIES_DFLT,
};

#define NUM_MRU_ENTRIES 10
LPCTSTR mruEntriesNames[NUM_MRU_ENTRIES] = {
    UTREG_UI_SERVER_MRU0, UTREG_UI_SERVER_MRU1, UTREG_UI_SERVER_MRU2,
    UTREG_UI_SERVER_MRU3, UTREG_UI_SERVER_MRU4, UTREG_UI_SERVER_MRU5,
    UTREG_UI_SERVER_MRU6, UTREG_UI_SERVER_MRU7, UTREG_UI_SERVER_MRU8,
    UTREG_UI_SERVER_MRU9
};

#define NUM_GLYPH_CACHE_SETTINGS 10
LPCTSTR tscGlyphCacheEntries[NUM_GLYPH_CACHE_SETTINGS] = {
    UTREG_UH_GL_CACHE1_CELLSIZE,
    UTREG_UH_GL_CACHE2_CELLSIZE,
    UTREG_UH_GL_CACHE3_CELLSIZE,
    UTREG_UH_GL_CACHE4_CELLSIZE,
    UTREG_UH_GL_CACHE5_CELLSIZE,
    UTREG_UH_GL_CACHE6_CELLSIZE,
    UTREG_UH_GL_CACHE7_CELLSIZE,
    UTREG_UH_GL_CACHE8_CELLSIZE,
    UTREG_UH_GL_CACHE9_CELLSIZE,
    UTREG_UH_GL_CACHE10_CELLSIZE,
};

UINT    tscGlyphCacheDefaults[NUM_GLYPH_CACHE_SETTINGS] = {
    UTREG_UH_GL_CACHE1_CELLSIZE_DFLT,
    UTREG_UH_GL_CACHE2_CELLSIZE_DFLT,
    UTREG_UH_GL_CACHE3_CELLSIZE_DFLT,
    UTREG_UH_GL_CACHE4_CELLSIZE_DFLT,
    UTREG_UH_GL_CACHE5_CELLSIZE_DFLT,
    UTREG_UH_GL_CACHE6_CELLSIZE_DFLT,
    UTREG_UH_GL_CACHE7_CELLSIZE_DFLT,
    UTREG_UH_GL_CACHE8_CELLSIZE_DFLT,
    UTREG_UH_GL_CACHE9_CELLSIZE_DFLT,
    UTREG_UH_GL_CACHE10_CELLSIZE_DFLT
};

CTscSettings::CTscSettings()
{
    memset(this, 0, sizeof(CTscSettings));
}

CTscSettings::~CTscSettings()
{
}

VOID CTscSettings::SetFileName(LPTSTR szFile)
{
    _tcsncpy(_szFileName, szFile, SIZECHAR(_szFileName));
}

//
// Load all the settings from the store.
// values not in the store are automatically intialized to their
// defaults by the store object.
//
// parameters:
//  pStore - persistant store object
// returns
//  hresult code
//
HRESULT CTscSettings::LoadFromStore(ISettingsStore* pStore)
{
    UINT i;
    CUT ut;
#ifndef OS_WINCE
    LONG delta;
#endif

    DC_BEGIN_FN("LoadFromStore");
    
    TRC_ASSERT(pStore, (TB,_T("pStore parameter is NULL to LoadFromStore")));
    if(!pStore)
    {
        return E_INVALIDARG;
    }

    TRC_ASSERT(pStore->IsOpenForRead(), (TB,_T("pStore is not OPEN for read")));
    if(!pStore->IsOpenForRead())
    {
        return E_FAIL;
    }

    //
    // Here we go...read in a gazillion properties
    // for some of these properties we do some special processing
    // to transmogrify (<-- word copyright adamo 2000) them.
    //

    ///////////////////////////////////////////////////////////////////
    // Fullscren property
    //
    UINT screenMode;
    #define SCREEN_MODE_UNSPECIFIED 0
    
    if(!pStore->ReadInt(UTREG_UI_SCREEN_MODE,
                        SCREEN_MODE_UNSPECIFIED,
                        &screenMode))
    {
        return E_FAIL;
    }

    if(SCREEN_MODE_UNSPECIFIED == screenMode)
    {
        //Screen mode was not specified.
        //The following logic is used to determine
        //if we're going full screen
        // 1) If no DesktopSize ID is specified then go fullscreen
        UINT val;
        #define DUMMY_DEFAULT ((UINT)-1)
        if(!pStore->ReadInt(UTREG_UI_DESKTOP_SIZEID,
                            DUMMY_DEFAULT,
                            &val))
        {
            return E_FAIL;
        }
        if(val == DUMMY_DEFAULT)
        {
            //DesktopSizeId was NOT specified
            //go fullscreen
            SetStartFullScreen(TRUE);
        }
        else
        {
            SetStartFullScreen(FALSE);
        }
    }
    else
    {
        //Go fullscreen according to setting
        SetStartFullScreen((UI_FULLSCREEN == screenMode));
    }

#ifndef OS_WINCE
    ///////////////////////////////////////////////////////////////////
    // Window position string
    //
    TCHAR  szBuffer[TSC_WINDOW_POSITION_STR_LEN];
    if(!pStore->ReadString(UTREG_UI_WIN_POS_STR,
                           UTREG_UI_WIN_POS_STR_DFLT,
                           szBuffer,
                           sizeof(szBuffer)/sizeof(TCHAR)))
    {
        return E_FAIL;
    }
    TRC_NRM((TB, _T("Store read - Window Position string = %s"), szBuffer));
    // parse the string into ten fields
    int nRead = _stscanf(szBuffer, TSC_WINDOW_POSITION_INI_FORMAT,
                       &_windowPlacement.flags,
                       &_windowPlacement.showCmd,
                       &_windowPlacement.rcNormalPosition.left,
                       &_windowPlacement.rcNormalPosition.top,
                       &_windowPlacement.rcNormalPosition.right,
                       &_windowPlacement.rcNormalPosition.bottom);

    if (nRead != TSC_NUMBER_FIELDS_TO_READ)
    {
        TRC_ABORT((TB, _T("Illegal Window Position %s configured"), szBuffer));
        TRC_DBG((TB, _T("Parsed %u variables (should be %d) from registry"),
                                         nRead, TSC_NUMBER_FIELDS_TO_READ));

        TCHAR szWPosDflt[] = UTREG_UI_WIN_POS_STR_DFLT;
        nRead = _stscanf(szWPosDflt,
                           TSC_WINDOW_POSITION_INI_FORMAT,
                           &_windowPlacement.flags,
                           &_windowPlacement.showCmd,
                           &_windowPlacement.rcNormalPosition.left,
                           &_windowPlacement.rcNormalPosition.top,
                           &_windowPlacement.rcNormalPosition.right,
                           &_windowPlacement.rcNormalPosition.bottom);

        if (nRead != TSC_NUMBER_FIELDS_TO_READ)
        {
            TRC_ABORT((TB,_T("Internal Error: Invalid default Window Position")));
        }
    }
    else
    {
        TRC_DBG((TB, _T("Parsed string to WINDOWPOSITION")));
    }
    _windowPlacement.length = sizeof(_windowPlacement);

    //
    //  Validate the windowPlacement struct
    //  replacing with reasonable defaults if a field is invalid
    //
    if(_windowPlacement.flags != 0                        &&
       _windowPlacement.flags != WPF_ASYNCWINDOWPLACEMENT &&
       _windowPlacement.flags != WPF_RESTORETOMAXIMIZED   &&
       _windowPlacement.flags != WPF_SETMINPOSITION)
    {
        TRC_DBG((TB,_T("Overriding _windowPlacement.flags from %d to 0"),
                 _windowPlacement.flags));
        _windowPlacement.flags = 0;
    }

    //
    // Validate the showCmd and if the windowplacement
    // represents a minimized window, restore it
    //
    if(_windowPlacement.showCmd != SW_MAXIMIZE      &&
       _windowPlacement.showCmd != SW_RESTORE       &&
       _windowPlacement.showCmd != SW_SHOW          &&
       _windowPlacement.showCmd != SW_SHOWMAXIMIZED &&
       _windowPlacement.showCmd != SW_SHOWNORMAL)
    {
        TRC_DBG((TB,_T("Overriding showCmd from %d to %d"),
                 _windowPlacement.showCmd, SW_RESTORE));
        _windowPlacement.showCmd =  SW_RESTORE;
    }

    if(_windowPlacement.rcNormalPosition.top < 0)
    {
        _windowPlacement.rcNormalPosition.top = 0;
    }

    //
    // Ensure a minimum width and height
    //
    delta = _windowPlacement.rcNormalPosition.right -
            _windowPlacement.rcNormalPosition.left;
    if( delta < 50)
    {
        _windowPlacement.rcNormalPosition.left  = 0;
        _windowPlacement.rcNormalPosition.right = DEFAULT_DESKTOP_WIDTH;
    }

    delta = _windowPlacement.rcNormalPosition.bottom -
            _windowPlacement.rcNormalPosition.top;
    if( delta < 50)
    {
        _windowPlacement.rcNormalPosition.top  = 0;
        _windowPlacement.rcNormalPosition.bottom = DEFAULT_DESKTOP_HEIGHT;
    }
#endif //OS_WINCE

    //
    // The windowplacement is further validated on connection to
    // ensure the window is actually visible on screen.
    //
       

#if !defined(OS_WINCE) || defined(OS_WINCE_NONFULLSCREEN)
    
    ///////////////////////////////////////////////////////////////////
    // Desktop size ID
    //
    if(!pStore->ReadInt(UTREG_UI_DESKTOP_SIZEID, UTREG_UI_DESKTOP_SIZEID_DFLT,
                        &_desktopSizeID))
    {
        return E_FAIL;
    }

    TRC_NRM((TB, _T("Store read - Desktop Size ID = %u"), _desktopSizeID));
    if (_desktopSizeID > (UI_NUMBER_DESKTOP_SIZE_IDS - 1))
    {
        TRC_ABORT((TB, _T("Illegal desktopSizeID %d configured"),
                                                           _desktopSizeID));
        _desktopSizeID = (UINT)UTREG_UI_DESKTOP_SIZEID_DFLT;
    }
    
    SetDesktopWidth(  tscScreenResTable[_desktopSizeID][0]);
    SetDesktopHeight( tscScreenResTable[_desktopSizeID][1]);


    ///////////////////////////////////////////////////////////////////
    // New style desktop width/height
    //
    UINT deskWidth = DEFAULT_DESKTOP_WIDTH;
    UINT deskHeight = DEFAULT_DESKTOP_HEIGHT;
    if(!pStore->ReadInt(UTREG_UI_DESKTOP_WIDTH,
                        UTREG_UI_DESKTOP_WIDTH_DFLT,
                        &deskWidth))
    {
        return E_FAIL;
    }

    if(!pStore->ReadInt(UTREG_UI_DESKTOP_HEIGHT,
                        UTREG_UI_DESKTOP_HEIGHT_DFLT,
                        &deskHeight))
    {
        return E_FAIL;
    }

    if(deskWidth  != UTREG_UI_DESKTOP_WIDTH_DFLT &&
       deskHeight != UTREG_UI_DESKTOP_HEIGHT_DFLT)
    {
        //Override the old sytle desktopsize ID setting
        //with the newwer desktopwidth/height
        if(deskWidth  >= MIN_DESKTOP_WIDTH  &&
           deskHeight >= MIN_DESKTOP_HEIGHT &&
           deskWidth  <= MAX_DESKTOP_WIDTH  &&
           deskHeight <= MAX_DESKTOP_HEIGHT)
        {
            SetDesktopWidth(deskWidth);
            SetDesktopHeight(deskHeight);
        }
    }

    if( GetStartFullScreen() )
    {
        //
        // Full screen overrides all resolution
        // settings in the RDP file
        //
        int xMaxSize = GetSystemMetrics(SM_CXSCREEN);
        int yMaxSize = GetSystemMetrics(SM_CYSCREEN);
        xMaxSize = xMaxSize > MAX_DESKTOP_WIDTH ? MAX_DESKTOP_WIDTH : xMaxSize;
        yMaxSize = yMaxSize > MAX_DESKTOP_HEIGHT?MAX_DESKTOP_HEIGHT : yMaxSize;
        SetDesktopWidth( xMaxSize );
        SetDesktopHeight( yMaxSize );
    }


#else  // !defined(OS_WINCE) || defined(OS_WINCE_NONFULLSCREEN)

    ///////////////////////////////////////////////////////////////////
    // WinCE desktop width/height
    //

    // WinCE needs to calculate the correct size from the beginning
    _desktopSizeID = 0;
    int xSize = GetSystemMetrics(SM_CXSCREEN);
    int ySize = GetSystemMetrics(SM_CYSCREEN);
    SetDesktopWidth(xSize);
    SetDesktopHeight(ySize);

#endif // !defined(OS_WINCE) || defined(OS_WINCE_NONFULLSCREEN)

    ///////////////////////////////////////////////////////////////////
    // Color depth
    //

    //
    // Find the actual display depth
    // don't worry about these functions failing - if they do,
    // we'll use the store setting
    //
    HDC hdc = GetDC(NULL);
    UINT screenBpp;
    TRC_ASSERT((NULL != hdc), (TB,_T("Failed to get DC")));
    if(hdc)
    {
        screenBpp = GetDeviceCaps(hdc, BITSPIXEL);
        TRC_NRM((TB, _T("HDC %p has %u bpp"), hdc, screenBpp));
        ReleaseDC(NULL, hdc);
    }
    else
    {
        screenBpp = TSC_DEFAULT_BPP;
    }

    UINT clientBpp;
    //
    // Set the default to any color depth up to 16 bpp and then limit
    // it to that depth
    //
    UINT clampedScreenBpp = screenBpp > 16 ? 16 : screenBpp;
    if(!pStore->ReadInt(UTREG_UI_SESSION_BPP, clampedScreenBpp, &clientBpp))
    {
        return E_FAIL;
    }
    TRC_NRM((TB, _T("Store read - color depth = %d"), clientBpp));
    
    if(clientBpp == 32)
    {
        //32 is not supported, it maps directly to 24
        clientBpp = 24;
    }

    if(clientBpp >= screenBpp && screenBpp >= 8)
    {
        clientBpp = screenBpp;
    }

    if(clientBpp == 8  ||
       clientBpp == 15 ||
       clientBpp == 16 ||
       clientBpp == 24)
    {
        SetColorDepth(clientBpp);
    }
    else
    {
        //Default for safety
        SetColorDepth(8);
    }

    ///////////////////////////////////////////////////////////////////
    // Auto connect flag
    //
    if(!pStore->ReadBool(UTREG_UI_AUTO_CONNECT, UTREG_UI_AUTO_CONNECT_DFLT,
                        &_fAutoConnectEnabled))
    {
        return E_FAIL;
    }

    ///////////////////////////////////////////////////////////////////
    // Server MRU list
    //
    for(i=0; i<NUM_MRU_ENTRIES; i++)
    {
        //MRU settings are global so they come from the registry
        ut.UT_ReadRegistryString( TSC_DEFAULT_REG_SESSION,
                                  (LPTSTR)mruEntriesNames[i],
                                  UTREG_UI_FULL_ADDRESS_DFLT,
                                  _szMRUServer[i],
                                  SIZECHAR(_szMRUServer[i]));
    }

    TCHAR szServer[TSC_MAX_ADDRESS_LENGTH];
    if(!pStore->ReadString( UTREG_UI_FULL_ADDRESS,
                            UTREG_UI_FULL_ADDRESS_DFLT,
                            szServer,
                            SIZECHAR(szServer)))
    {
        return E_FAIL;
    }
    SetConnectString(szServer);


    ///////////////////////////////////////////////////////////////////
    // Smooth scrolling option
    //
    if(!pStore->ReadBool(UTREG_UI_SMOOTH_SCROLL, UTREG_UI_SMOOTH_SCROLL_DFLT,
                        &_smoothScrolling))
    {
        return E_FAIL;
    }

    ///////////////////////////////////////////////////////////////////
    // Smart sizing option
    //
#ifdef SMART_SIZING
    if(!pStore->ReadBool(UTREG_UI_SMARTSIZING, UTREG_UI_SMARTSIZING_DFLT,
                        &_smartSizing))
    {
        return E_FAIL;
    }
#endif // SMART_SIZING

    ///////////////////////////////////////////////////////////////////
    // Connect to console option
    //
    if(!pStore->ReadBool(UTREG_UI_CONNECTTOCONSOLE, 
            UTREG_UI_CONNECTTOCONSOLE_DFLT, &_fConnectToConsole))
    {
        return E_FAIL;
    }

    ///////////////////////////////////////////////////////////////////
    // Accelerator check state
    //
    if(!pStore->ReadBool(UTREG_UI_ACCELERATOR_PASSTHROUGH_ENABLED,
                        UTREG_UI_ACCELERATOR_PASSTHROUGH_ENABLED_DFLT,
                        &_acceleratorPassthrough))
    {
        return E_FAIL;
    }

    ///////////////////////////////////////////////////////////////////
    // Shadow bitmap enabled
    //
    if(!pStore->ReadBool(UTREG_UI_SHADOW_BITMAP,
                        UTREG_UI_SHADOW_BITMAP_DFLT,
                        &_shadowBitmapEnabled))
    {
        return E_FAIL;
    }

    ///////////////////////////////////////////////////////////////////
    // Transport type
    // Currently limited to TCP
    //
    if(!pStore->ReadInt(UTREG_UI_TRANSPORT_TYPE,
                        TRANSPORT_TCP,
                        &_transportType))
    {
        return E_FAIL;
    }

    TRC_NRM((TB, _T("Store read - Transport type = %d"), _transportType));
    if (_transportType != TRANSPORT_TCP)
    {
        TRC_ABORT((TB, _T("Illegal Tansport Type %d configured"),
                        _transportType));
        _transportType = TRANSPORT_TCP;
    }

    ///////////////////////////////////////////////////////////////////
    // SAS sequence
    //
    if(!pStore->ReadInt(UTREG_UI_SAS_SEQUENCE,
                        UTREG_UI_SAS_SEQUENCE_DFLT,
                        &_sasSequence))
    {
        return E_FAIL;
    }

    TRC_NRM((TB, _T("Store read - SAS Sequence = %#x"), _sasSequence));
    if ((_sasSequence != RNS_UD_SAS_DEL) &&
        (_sasSequence != RNS_UD_SAS_NONE))
    {
        TRC_ABORT((TB, _T("Illegal SAS Sequence %#x configured"), _sasSequence));
        _sasSequence = UTREG_UI_SAS_SEQUENCE_DFLT;
    }

    ///////////////////////////////////////////////////////////////////
    // Encryption enabled
    //
    if(!pStore->ReadBool(UTREG_UI_ENCRYPTION_ENABLED,
                        UTREG_UI_ENCRYPTION_ENABLED_DFLT,
                        &_encryptionEnabled))
    {
        return E_FAIL;
    }
    TRC_NRM((TB, _T("Store read - Encryption Enabled = %d"), _encryptionEnabled));

    ///////////////////////////////////////////////////////////////////
    // Dedicated terminal
    //
    if(!pStore->ReadBool(UTREG_UI_DEDICATED_TERMINAL,
                        UTREG_UI_DEDICATED_TERMINAL_DFLT,
                        &_dedicatedTerminal))
    {
        return E_FAIL;
    }
    TRC_NRM((TB, _T("Store read - Dedicated terminal= %d"), _dedicatedTerminal));

    ///////////////////////////////////////////////////////////////////
    // MCS port
    //
    if(!pStore->ReadInt(UTREG_UI_MCS_PORT,
                        UTREG_UI_MCS_PORT_DFLT,
                        &_MCSPort))
    {
        return E_FAIL;
    }
    
    if (_MCSPort > 65535) {
        // At the moment, error message is not granular enough to indicate that
        // the port number is bogus. So, just set it to the default if we have
        // an out of range number.
        
        TRC_ERR((TB,_T("MCS port is not in valid range - resetting to default.")));
        _MCSPort = UTREG_UI_MCS_PORT_DFLT;
    }

    ///////////////////////////////////////////////////////////////////
    // Enable MOUSE
    //
    if(!pStore->ReadBool(UTREG_UI_ENABLE_MOUSE,
                        UTREG_UI_ENABLE_MOUSE_DFLT,
                        &_fEnableMouse))
    {
        return E_FAIL;
    }

    ///////////////////////////////////////////////////////////////////
    // Disable CTRL-ALT-DEL
    //
    if(!pStore->ReadBool(UTREG_UI_DISABLE_CTRLALTDEL,
                        UTREG_UI_DISABLE_CTRLALTDEL_DFLT,
                        &_fDisableCtrlAltDel))
    {
        return E_FAIL;
    }

    ///////////////////////////////////////////////////////////////////
    // Enable Windows key
    //
    if(!pStore->ReadBool(UTREG_UI_ENABLE_WINDOWSKEY,
                        UTREG_UI_ENABLE_WINDOWSKEY_DFLT,
                        &_fEnableWindowsKey))
    {
        return E_FAIL;
    }

    ///////////////////////////////////////////////////////////////////
    // Double click detect
    //
    if(!pStore->ReadBool(UTREG_UI_DOUBLECLICK_DETECT,
                        UTREG_UI_DOUBLECLICK_DETECT_DFLT,
                        &_fDoubleClickDetect))
    {
        return E_FAIL;
    }

    ///////////////////////////////////////////////////////////////////
    // Keyboard hooking mode
    //
    UINT keyHookMode;
    if(!pStore->ReadInt(UTREG_UI_KEYBOARD_HOOK,
                        UTREG_UI_KEYBOARD_HOOK_DFLT,
                        &keyHookMode))
    {
        return E_FAIL;
    }
    if (keyHookMode == UTREG_UI_KEYBOARD_HOOK_NEVER  ||
        keyHookMode == UTREG_UI_KEYBOARD_HOOK_ALWAYS ||
        keyHookMode == UTREG_UI_KEYBOARD_HOOK_FULLSCREEN)
    {
#ifdef OS_WINCE
        if (keyHookMode == UTREG_UI_KEYBOARD_HOOK_FULLSCREEN)
        {
            keyHookMode = UTREG_UI_KEYBOARD_HOOK_ALWAYS;
        }
#endif
        SetKeyboardHookMode(keyHookMode);
    }
    else
    {
        SetKeyboardHookMode(UTREG_UI_KEYBOARD_HOOK_NEVER);
    }

    ///////////////////////////////////////////////////////////////////
    // Sound redirection mode
    //
    UINT soundMode;
    if(!pStore->ReadInt(UTREG_UI_AUDIO_MODE,
                        UTREG_UI_AUDIO_MODE_DFLT,
                        &soundMode))
    {
        return E_FAIL;
    }
    if (soundMode == UTREG_UI_AUDIO_MODE_REDIRECT       ||
        soundMode == UTREG_UI_AUDIO_MODE_PLAY_ON_SERVER ||
        soundMode == UTREG_UI_AUDIO_MODE_NONE)
    {
        SetSoundRedirectionMode(soundMode);
    }
    else
    {
        SetSoundRedirectionMode(UTREG_UI_AUDIO_MODE_DFLT);
    }

    ///////////////////////////////////////////////////////////////////
    // AutoLogon settings
    // Decide which version to use based on finding (in order)
    //  AutoLogon50
    //  AutoLogon
    //  UserName50
    //
    
    //50 autologon
    if(!pStore->ReadBool(UTREG_UI_AUTOLOGON50,
                        UTREG_UI_AUTOLOGON50_DFLT,
                        &_fAutoLogon))
    {
        return E_FAIL;
    }
    memset(_szUserName, 0, sizeof(_szUserName));
    memset(_szDomain, 0, sizeof(_szDomain));
    memset(_szAlternateShell, 0, sizeof(_szAlternateShell));
    memset(_szWorkingDir, 0, sizeof(_szWorkingDir));

    ///////////////////////////////////////////////////////////////////
    // User name
    //
    if(!pStore->ReadString(UTREG_UI_USERNAME,
                           UTREG_UI_USERNAME_DFLT,
                           _szUserName,
                           SIZECHAR(_szUserName)))
    {
        return E_FAIL;
    }
        
    //
    // Domain
    //
    if(!pStore->ReadString(UTREG_UI_DOMAIN,
                           UTREG_UI_DOMAIN_DFLT,
                           _szDomain,
                           SIZECHAR(_szDomain)))
    {
        return E_FAIL;
    }

    if (!ReadPassword( pStore ))
    {
        //Not fatal..Allow rest of properties to be read
        TRC_ERR((TB,_T("Password read failed")));
    }

    //
    // Alternate shell (i.e StartProgram)
    //
    if(!pStore->ReadString(UTREG_UI_ALTERNATESHELL,
                           UTREG_UI_ALTERNATESHELL_DFLT,
                           _szAlternateShell,
                           SIZECHAR(_szAlternateShell)))
    {
        return E_FAIL;
    }

    //
    // WorkDir
    //
    if(!pStore->ReadString(UTREG_UI_WORKINGDIR,
                           UTREG_UI_WORKINGDIR_DFLT,
                           _szWorkingDir,
                           SIZECHAR(_szWorkingDir)))
    {
        return E_FAIL;
    }

    if(_tcscmp(_szAlternateShell,TEXT("")))
    {
        SetEnableStartProgram(TRUE);
    }
    else
    {
        SetEnableStartProgram(FALSE);
    }

    //
    // Maximize shell
    //
    if(!pStore->ReadBool(UTREG_UI_MAXIMIZESHELL50,
                        UTREG_UI_MAXIMIZESHELL50_DFLT,
                        &_fMaximizeShell))
    {
        return E_FAIL;
    }

    // ~~~~~~ ~~~~ ~~~~~ ~~~~ ~~~~~ ~~~~ ~~~~ ~~~ ~~~~ ~~~~ ~~~~~ ~~~~
    // FIXFIX Read HotKeys
    // (hotkeys are in a separate folder in the registry)
    // so they break the clean persistent store interface because a new
    // set of functions is needed to open a subkey
    //


    ///////////////////////////////////////////////////////////////////
    // Compression
    //
    if(!pStore->ReadBool(UTREG_UI_COMPRESS,UTREG_UI_COMPRESS_DFLT,
                         &_fCompress))
    {
        return E_FAIL;
    }
    TRC_NRM((TB, _T("Store read - Compression Enabled = %d"), _fCompress));

    ///////////////////////////////////////////////////////////////////
    // Bitmap memory cache size
    //
#ifndef OS_WINCE
    if(!pStore->ReadInt(UTREG_UH_TOTAL_BM_CACHE,
                        UTREG_UH_TOTAL_BM_CACHE_DFLT,
                        &_RegBitmapCacheSize))
    {
        return E_FAIL;
    }
#else
    _RegBitmapCacheSize = ut.UT_ReadRegistryInt(UTREG_SECTION,
                          UTREG_UH_TOTAL_BM_CACHE,
                          UTREG_UH_TOTAL_BM_CACHE_DFLT);
#endif

    ///////////////////////////////////////////////////////////////////
    // Update frequency
    //
    if(!pStore->ReadInt(UTREG_UH_DRAW_THRESHOLD,
                        UTREG_UH_DRAW_THRESHOLD_DFLT,
                        &_drawThreshold))
    {
        return E_FAIL;
    }

    ///////////////////////////////////////////////////////////////////
    // Disk/mem cache sizes
    //

    // 8bpp
    if(!pStore->ReadInt(TSC_BITMAPCACHE_8BPP_PROPNAME,
                        TSC_BITMAPCACHEVIRTUALSIZE_8BPP,
                        &_BitmapVirtualCache8BppSize))
    {
        return E_FAIL;
    }

    // 16bpp
    if(!pStore->ReadInt(TSC_BITMAPCACHE_16BPP_PROPNAME,
                        TSC_BITMAPCACHEVIRTUALSIZE_16BPP,
                        &_BitmapVirtualCache16BppSize))
    {
        return E_FAIL;
    }

    // 24bpp
    if(!pStore->ReadInt(TSC_BITMAPCACHE_24BPP_PROPNAME,
                        TSC_BITMAPCACHEVIRTUALSIZE_24BPP,
                        &_BitmapVirtualCache24BppSize))
    {
        return E_FAIL;
    }

    //
    // Bitmap disk cache size reg settings are usually
    // set in the registry. Override any file specified
    // or default values (read above) with reg settings.
    // (the previous values are passed in as 'defaults'
    // to get the desired overriding.
    //
    _BitmapVirtualCache8BppSize = (UINT) ut.UT_ReadRegistryInt(UTREG_SECTION,
                          TSC_BITMAPCACHE_8BPP_PROPNAME,
                          _BitmapVirtualCache8BppSize);

    _BitmapVirtualCache16BppSize = (UINT) ut.UT_ReadRegistryInt(UTREG_SECTION,
                          TSC_BITMAPCACHE_16BPP_PROPNAME,
                          _BitmapVirtualCache16BppSize);

    _BitmapVirtualCache24BppSize = (UINT) ut.UT_ReadRegistryInt(UTREG_SECTION,
                          TSC_BITMAPCACHE_24BPP_PROPNAME,
                          _BitmapVirtualCache24BppSize);

    //
    // Range validate bitmap cache size settings
    //
    if (_BitmapVirtualCache8BppSize > TSC_MAX_BITMAPCACHESIZE)
    {
        _BitmapVirtualCache8BppSize = TSC_MAX_BITMAPCACHESIZE;
    }

    if (_BitmapVirtualCache16BppSize > TSC_MAX_BITMAPCACHESIZE)
    {
        _BitmapVirtualCache16BppSize = TSC_MAX_BITMAPCACHESIZE;
    }

    if (_BitmapVirtualCache24BppSize > TSC_MAX_BITMAPCACHESIZE)
    {
        _BitmapVirtualCache24BppSize = TSC_MAX_BITMAPCACHESIZE;
    }

    ///////////////////////////////////////////////////////////////////
    // Whether to scale disk and mem bitmap caches by the protocol BPP
    //
    if(!pStore->ReadInt(UTREG_UH_SCALE_BM_CACHE,
                        UTREG_UH_SCALE_BM_CACHE_DFLT,
                        &_RegScaleBitmapCachesByBPP))
    {
        return E_FAIL;
    }

    ///////////////////////////////////////////////////////////////////
    // Number of bitmap caches
    //
    if(!pStore->ReadInt(UTREG_UH_BM_NUM_CELL_CACHES,
                        UTREG_UH_BM_NUM_CELL_CACHES_DFLT,
                        &_RegNumBitmapCaches))
    {
        return E_FAIL;
    }

    //
    // Bitmap cache settings galore....
    //
    //
    for (i = 0; i < TS_BITMAPCACHE_MAX_CELL_CACHES; i++)
    {
        TCHAR QueryStr[32];
        _stprintf(QueryStr, UTREG_UH_BM_CACHE_PROPORTION_TEMPLATE,
                _T('1') + i);
        //
        // Bitmap cache proportion
        //
        if(!pStore->ReadInt(QueryStr,
                            ProportionDefault[i],
                            &_RegBCProportion[i]))
        {
            return E_FAIL;
        }

    
#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
        _stprintf(QueryStr, UTREG_UH_BM_CACHE_PERSISTENCE_TEMPLATE,
                _T('1') + i);
        //
        // Bitmap send keys
        //
        if(!pStore->ReadInt(QueryStr,
                            PersistenceDefault[i] ? TRUE : FALSE,
                            &_bSendBitmapKeys[i]))
        {
            return E_FAIL;
        }
#endif // ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
    
        _stprintf(QueryStr, UTREG_UH_BM_CACHE_MAXENTRIES_TEMPLATE,
                _T('1') + i);

        //
        // Bitmap cache max entries
        //
        if(!pStore->ReadInt(QueryStr,
                            MaxEntriesDefault[i],
                            &_RegBCMaxEntries[i]))
        {
            return E_FAIL;
        }

        if (_RegBCMaxEntries[i] < MaxEntriesDefault[i])
        {
            _RegBCMaxEntries[i] = MaxEntriesDefault[i];
        }
    }

    ///////////////////////////////////////////////////////////////////
    // Glyph support level
    //
    if(!pStore->ReadInt(UTREG_UH_GL_SUPPORT,
                        UTREG_UH_GL_SUPPORT_DFLT,
                        &_GlyphSupportLevel))
    {
        return E_FAIL;
    }

    ///////////////////////////////////////////////////////////////////
    // Glyph cache cell sizes
    //
    for(i=0; i<NUM_GLYPH_CACHE_SETTINGS; i++)
    {
        if(!pStore->ReadInt(tscGlyphCacheEntries[i],
                            tscGlyphCacheDefaults[i],
                            &_GlyphCacheSize[i]))
        {
            return E_FAIL;
        }
    }

    ///////////////////////////////////////////////////////////////////
    // Frag cell size
    //
    if(!pStore->ReadInt(UTREG_UH_FG_CELLSIZE,
                        UTREG_UH_FG_CELLSIZE_DFLT,
                        &_fragCellSize))
    {
        return E_FAIL;
    }

    ///////////////////////////////////////////////////////////////////
    // Brush support level
    //
    if(!pStore->ReadInt(UTREG_UH_FG_CELLSIZE,
                        UTREG_UH_FG_CELLSIZE_DFLT,
                        &_brushSupportLevel))
    {
        return E_FAIL;
    }

    ///////////////////////////////////////////////////////////////////
    // Maximum input event count
    //
    if(!pStore->ReadInt(UTREG_IH_MAX_EVENT_COUNT,
                        UTREG_IH_MAX_EVENT_COUNT_DFLT,
                        &_maxInputEventCount))
    {
        return E_FAIL;
    }

    ///////////////////////////////////////////////////////////////////
    // Events at once
    //
    if(!pStore->ReadInt(UTREG_IH_NRM_EVENT_COUNT,
                        UTREG_IH_NRM_EVENT_COUNT_DFLT,
                        &_eventsAtOnce))
    {
        return E_FAIL;
    }

    ///////////////////////////////////////////////////////////////////
    // Minimum send interval
    //
    if(!pStore->ReadInt(UTREG_IH_MIN_SEND_INTERVAL,
                        UTREG_IH_MIN_SEND_INTERVAL_DFLT,
                        &_minSendInterval))
    {
        return E_FAIL;
    }

    ///////////////////////////////////////////////////////////////////
    // Keepalive interval in milliseconds
    //
    if(!pStore->ReadInt(UTREG_IH_KEEPALIVE_INTERVAL,
                        UTREG_IH_KEEPALIVE_INTERVAL_DFLT,
                        &_keepAliveIntervalMS))
    {
        return E_FAIL;
    }

    ///////////////////////////////////////////////////////////////////
    // Keybaord layout string
    //
    memset(_szKeybLayoutStr, 0, sizeof(_szKeybLayoutStr));
#ifndef OS_WINCE

    //
    // Precedence is (1) Registry (2) RDP file (per connection)
    //

    ut.UT_ReadRegistryString(UTREG_SECTION,
                              UTREG_UI_KEYBOARD_LAYOUT,
                              UTREG_UI_KEYBOARD_LAYOUT_DFLT,
                              _szKeybLayoutStr,
                              sizeof(_szKeybLayoutStr));

    TCHAR szKeybLayoutDflt[UTREG_UI_KEYBOARD_LAYOUT_LEN];
    StringCchCopy(szKeybLayoutDflt,
		SIZE_TCHARS(szKeybLayoutDflt),
		_szKeybLayoutStr
		);

    //
    // Override with any per-connection settings
    //

    if(!pStore->ReadString(UTREG_UI_KEYBOARD_LAYOUT,
                        szKeybLayoutDflt,
                        _szKeybLayoutStr,
                        sizeof(_szKeybLayoutStr)/sizeof(TCHAR)))
    {
        return E_FAIL;
    }
#else
    ut.UT_ReadRegistryString(UTREG_SECTION,
                              UTREG_UI_KEYBOARD_LAYOUT,
                              UTREG_UI_KEYBOARD_LAYOUT_DFLT,
                              _szKeybLayoutStr,
                              sizeof(_szKeybLayoutStr));
#endif

    ///////////////////////////////////////////////////////////////////
    // Shutdown timeout
    //
    if(!pStore->ReadInt(UTREG_UI_SHUTDOWN_TIMEOUT,
                        UTREG_UI_SHUTDOWN_TIMEOUT_DFLT,
                        &_shutdownTimeout))
    {
        return E_FAIL;
    }

    ///////////////////////////////////////////////////////////////////
    // Connection timeout
    //
    if(!pStore->ReadInt(UTREG_UI_OVERALL_CONN_TIMEOUT,
                        UTREG_UI_OVERALL_CONN_TIMEOUT_DFLT,
                        &_connectionTimeout))
    {
        return E_FAIL;
    }

    ///////////////////////////////////////////////////////////////////
    // Single connection timeout
    //
    if(!pStore->ReadInt(UTREG_UI_SINGLE_CONN_TIMEOUT,
                        UTREG_UI_SINGLE_CONN_TIMEOUT_DFLT,
                        &_singleConTimeout))
    {
        return E_FAIL;
    }


#ifdef OS_WINCE
    ///////////////////////////////////////////////////////////////////
    // Keyboard type
    //
    _keyboardType = ut.UT_ReadRegistryInt(
                                UTREG_SECTION,
                                UTREG_UI_KEYBOARD_TYPE,
                                UTREG_UI_KEYBOARD_TYPE_DFLT);

    ///////////////////////////////////////////////////////////////////
    // Keyboard sub-type
    //
    _keyboardSubType = ut.UT_ReadRegistryInt(
                                UTREG_SECTION,
                                UTREG_UI_KEYBOARD_SUBTYPE,
                                UTREG_UI_KEYBOARD_SUBTYPE_DFLT);

    ///////////////////////////////////////////////////////////////////
    // Keyboard function key
    //
    _keyboardFunctionKey = ut.UT_ReadRegistryInt(
                                UTREG_SECTION,
                                UTREG_UI_KEYBOARD_FUNCTIONKEY,
                                UTREG_UI_KEYBOARD_FUNCTIONKEY_DFLT);
#endif // OS_WINCE

    //
    // Debug options
    //
#ifdef DC_DEBUG

    ///////////////////////////////////////////////////////////////////
    // Hatch bitmap PDU
    //
    if(!pStore->ReadBool(UTREG_UI_HATCH_BITMAP_PDU_DATA,
                         UTREG_UI_HATCH_BITMAP_PDU_DATA_DFLT,
                         &_hatchBitmapPDUData))
    {
        return E_FAIL;
    }
    
    ///////////////////////////////////////////////////////////////////
    // Hatch SSB order data
    //
    if(!pStore->ReadBool(UTREG_UI_HATCH_SSB_ORDER_DATA,
                         UTREG_UI_HATCH_SSB_ORDER_DATA_DFLT,
                         &_hatchSSBOrderData))
    {
        return E_FAIL;
    }

    ///////////////////////////////////////////////////////////////////
    // Hatch index PDU data
    //
    if(!pStore->ReadBool(UTREG_UI_HATCH_INDEX_PDU_DATA,
                         UTREG_UI_HATCH_INDEX_PDU_DATA_DFLT,
                         &_hatchIndexPDUData))
    {
        return E_FAIL;
    }


    ///////////////////////////////////////////////////////////////////
    // Hatch memblt order data
    //
    if(!pStore->ReadBool(UTREG_UI_HATCH_MEMBLT_ORDER_DATA,
                         UTREG_UI_HATCH_MEMBLT_ORDER_DATA_DFLT,
                         &_hatchMemBltOrderData))
    {
        return E_FAIL;
    }

    ///////////////////////////////////////////////////////////////////
    // Label memblt orders
    //
    if(!pStore->ReadBool(UTREG_UI_LABEL_MEMBLT_ORDERS,
                         UTREG_UI_LABEL_MEMBLT_ORDERS_DFLT,
                         &_labelMemBltOrders))
    {
        return E_FAIL;
    }

    ///////////////////////////////////////////////////////////////////
    // Bitmap cache monitor
    //
    if(!pStore->ReadBool(UTREG_UI_BITMAP_CACHE_MONITOR,
                         UTREG_UI_BITMAP_CACHE_MONITOR_DFLT,
                         &_bitmapCacheMonitor))
    {
        return E_FAIL;
    }
#endif // DC_DEBUG

    ///////////////////////////////////////////////////////////////////
    // DNS browsing domain name
    //
    memset(_browseDNSDomainName,0,sizeof(_browseDNSDomainName));
    if(!pStore->ReadString(UTREG_UI_BROWSE_DOMAIN_NAME,
                           UTREG_UI_BROWSE_DOMAIN_NAME_DFLT,
                           _browseDNSDomainName,
                           sizeof(_browseDNSDomainName)/sizeof(TCHAR)))
    {
        return E_FAIL;
    }

    if(_tcscmp(_browseDNSDomainName,
               UTREG_UI_BROWSE_DOMAIN_NAME_DFLT))
    {
        _fbrowseDNSDomain = TRUE;
    }
    else
    {
        _fbrowseDNSDomain = FALSE;
    }


    //
    // Get the plugin list. For security reasons we only read
    // this from the registry - it would be dangerous to allow an RDP
    // file to specify DLLs that could potentially live off machine
    //
    DC_MEMSET(_szPluginList, 0, sizeof(_szPluginList));
    
    //
    // Get reg plugin list
    //
    CSH::SH_GetPluginDllList(TSC_DEFAULT_REG_SESSION, _szPluginList, 
                             SIZECHAR(_szPluginList));

    ///////////////////////////////////////////////////////////////////
    // Icon file
    //
    memset(_szIconFile, 0, sizeof(_szIconFile));
    if(!pStore->ReadString(TSC_ICON_FILE,
                          _T(""),
                          _szIconFile,
                           sizeof(_szIconFile)/sizeof(TCHAR)))
    {
        return E_FAIL;
    }

    ///////////////////////////////////////////////////////////////////
    // Icon index
    //
    if(!pStore->ReadInt(TSC_ICON_INDEX,
                        TSC_ICON_INDEX_DEFAULT,
                        &_iconIndex))
    {
        return E_FAIL;
    }

    if(!pStore->ReadBool(TSCSETTING_REDIRECTDRIVES,
                         TSCSETTING_REDIRECTDRIVES_DFLT,
                         &_fDriveRedirectionEnabled))
    {
        return E_FAIL;
    }

    if(!pStore->ReadBool(TSCSETTING_REDIRECTPRINTERS,
                         TSCSETTING_REDIRECTPRINTERS_DFLT,
                         &_fPrinterRedirectionEnabled))
    {
        return E_FAIL;
    }

    if(!pStore->ReadBool(TSCSETTING_REDIRECTCOMPORTS,
                         TSCSETTING_REDIRECTCOMPORTS_DFLT,
                         &_fPortRedirectionEnabled))
    {
        return E_FAIL;
    }

    if(!pStore->ReadBool(TSCSETTING_REDIRECTSCARDS,
                         TSCSETTING_REDIRECTSCARDS_DFLT,
                         &_fSCardRedirectionEnabled))
    {
        return E_FAIL;
    }

    if(!pStore->ReadBool(TSCSETTING_DISPLAYCONNECTIONBAR,
                         TSCSETTING_DISPLAYCONNECTIONBAR_DFLT,
                         &_fDisplayBBar))
    {
        return E_FAIL;
    }

    //
    // AutoReconnection
    //
    if (!pStore->ReadBool(TSCSETTING_ENABLEAUTORECONNECT,
                         TSCSETTING_ENABLEAUTORECONNECT_DFLT,
                         &_fEnableAutoReconnect))
    {
        return E_FAIL;
    }

    //
    // Autoreconnect max retries
    //
    if (!pStore->ReadInt(TSCSETTING_ARC_RETRIES,
                         TSCSETTING_ARC_RETRIES_DFLT,
                         &_nArcMaxRetries))
    {
        return E_FAIL;
    }



    //
    // Pin bbar is global
    //
    _fPinBBar = (BOOL) ut.UT_ReadRegistryInt(UTREG_SECTION,
                          TSCSETTING_PINCONNECTIONBAR,
                          TSCSETTING_PINCONNECTIONBAR_DFLT);

    if (!ReadPerfOptions(pStore))
    {
        TRC_ERR((TB,_T("ReadPerfOptions failed")));
        return E_FAIL;
    }

    //
    // FIXFIX..Missing props:
    //  Wince: iRegistryPaletteIsFixed/put_WinceFixedPalette
    //  HOTKEYS
    //  plugindlls
    //

    DC_END_FN();
    return S_OK;
}

//
// Write back settings to the store,
// Only do this for settings that could have been modified
// (by the UI/control).
// any other settings are transparently rewritten out by the
// the store.
// 
HRESULT CTscSettings::SaveToStore(ISettingsStore* pStore)
{
    CUT ut;
    DC_BEGIN_FN("SaveToStore");

    TRC_ASSERT(pStore,(TB,_T("pStore is null")));
    if(!pStore)
    {
        return E_INVALIDARG;
    }

    TRC_ASSERT(pStore->IsOpenForWrite(),
               (TB,_T("pStore is not open for write")));
    if(!pStore->IsOpenForWrite())
    {
        return E_FAIL;
    }

    //
    // Note all UI contrallable settings are _always_
    // written out to the RDP file
    //

    ///////////////////////////////////////////////////////////////////
    // FullScreen
    //
    UINT screenMode = GetStartFullScreen() ? UI_FULLSCREEN : UI_WINDOWED;
    if(!pStore->WriteInt(UTREG_UI_SCREEN_MODE,
                         UTREG_UI_SCREEN_MODE_DFLT,
                         screenMode,
                         TRUE))
    {
        return E_FAIL;
    }

    ///////////////////////////////////////////////////////////////////
    // Desktop width/height
    //
    UINT deskWidth = GetDesktopWidth();
    if(!pStore->WriteInt(UTREG_UI_DESKTOP_WIDTH,
                         UTREG_UI_DESKTOP_WIDTH_DFLT,
                         deskWidth,
                         TRUE))
    {
        return E_FAIL;
    }

    UINT deskHeight = GetDesktopHeight();
    if(!pStore->WriteInt(UTREG_UI_DESKTOP_HEIGHT,
                         UTREG_UI_DESKTOP_HEIGHT_DFLT,
                         deskHeight,
                         TRUE))
    {
        return E_FAIL;
    }

    ///////////////////////////////////////////////////////////////////
    // Color depth
    //
    UINT colorDepth = GetColorDepth();
    if(!pStore->WriteInt(UTREG_UI_SESSION_BPP,
                         -1, //invalid default to force always write
                         colorDepth,
                         TRUE))
    {
        return E_FAIL;
    }

    ///////////////////////////////////////////////////////////////////
    // Window placement string
    //
    TCHAR     szBuffer[TSC_WINDOW_POSITION_STR_LEN];
    DC_TSPRINTF(szBuffer,
                TSC_WINDOW_POSITION_INI_FORMAT,
                _windowPlacement.flags,
                _windowPlacement.showCmd,
                _windowPlacement.rcNormalPosition.left,
                _windowPlacement.rcNormalPosition.top,
                _windowPlacement.rcNormalPosition.right,
                _windowPlacement.rcNormalPosition.bottom);
    TRC_DBG((TB, _T("Top = %d"), _windowPlacement.rcNormalPosition.top));

    if(!pStore->WriteString(UTREG_UI_WIN_POS_STR,
                            UTREG_UI_WIN_POS_STR_DFLT,
                            szBuffer,
                            TRUE))
    {
        return E_FAIL;
    }

    if(!pStore->WriteString(UTREG_UI_FULL_ADDRESS,
                            UTREG_UI_FULL_ADDRESS_DFLT,
                            GetFlatConnectString(),
                            TRUE))
    {
        return E_FAIL;
    }

    ///////////////////////////////////////////////////////////////////
    // Compression
    //
    if(!pStore->WriteBool(UTREG_UI_COMPRESS,
                          UTREG_UI_COMPRESS_DFLT,
                          _fCompress,
                          TRUE))
    {
        return E_FAIL;
    }

    ///////////////////////////////////////////////////////////////////
    // SmartSizing
    //
#ifdef SMART_SIZING
    if(!pStore->WriteBool(UTREG_UI_SMARTSIZING,
                          UTREG_UI_SMARTSIZING_DFLT,
                          _smartSizing,
                          FALSE))
    {
        return E_FAIL;
    }
#endif // SMART_SIZING

    ///////////////////////////////////////////////////////////////////
    // Connect to console option
    //
    // Don't save it. Only way it can get set right now is from the
    // command line, and we wouldn't want that to screw with somebody's
    // .rdp file.
    //

    ///////////////////////////////////////////////////////////////////
    // Keyb Hook mode
    //
    if(!pStore->WriteInt(UTREG_UI_KEYBOARD_HOOK,
                         UTREG_UI_KEYBOARD_HOOK_DFLT,
                         GetKeyboardHookMode(),
                         TRUE))
    {
        return E_FAIL;
    }

    ///////////////////////////////////////////////////////////////////
    // Sound redir mode
    //
    if(!pStore->WriteInt(UTREG_UI_AUDIO_MODE,
                         UTREG_UI_AUDIO_MODE_DFLT,
                         GetSoundRedirectionMode(),
                         TRUE))
    {
        return E_FAIL;
    }



    ///////////////////////////////////////////////////////////////////
    // Drives and printers
    //
    if(!pStore->WriteBool(TSCSETTING_REDIRECTDRIVES,
                          TSCSETTING_REDIRECTDRIVES_DFLT,
                          _fDriveRedirectionEnabled,
                          TRUE))
    {
        return E_FAIL;
    }
    
    if(!pStore->WriteBool(TSCSETTING_REDIRECTPRINTERS,
                          TSCSETTING_REDIRECTPRINTERS_DFLT,
                          _fPrinterRedirectionEnabled,
                          TRUE))
    {
        return E_FAIL;
    }
    
    if(!pStore->WriteBool(TSCSETTING_REDIRECTCOMPORTS,
                          TSCSETTING_REDIRECTCOMPORTS_DFLT,
                          _fPortRedirectionEnabled,
                          TRUE))
    {
        return E_FAIL;
    }

    if(!pStore->WriteBool(TSCSETTING_REDIRECTSCARDS,
                          TSCSETTING_REDIRECTSCARDS_DFLT,
                          _fSCardRedirectionEnabled,
                          TRUE))
    {
        return E_FAIL;
    }

    if(!pStore->WriteBool(TSCSETTING_DISPLAYCONNECTIONBAR,
                         TSCSETTING_DISPLAYCONNECTIONBAR_DFLT,
                         _fDisplayBBar,
                          TRUE))
    {
        return E_FAIL;
    }

    ut.UT_WriteRegistryInt(UTREG_SECTION,
                           TSCSETTING_PINCONNECTIONBAR,
                           TSCSETTING_PINCONNECTIONBAR_DFLT,
                           _fPinBBar);

    //
    // AutoReconnection
    //
    if (!pStore->WriteBool(TSCSETTING_ENABLEAUTORECONNECT,
                          TSCSETTING_ENABLEAUTORECONNECT_DFLT,
                          _fEnableAutoReconnect,
                          TRUE))
    {
        return E_FAIL;
    }


    ///////////////////////////////////////////////////////////////////
    // User name
    //
    if(!pStore->WriteString(UTREG_UI_USERNAME,
                            UTREG_UI_USERNAME_DFLT,
                            _szUserName,
                            TRUE))
    {
        return E_FAIL;
    }
        
    //
    // Domain
    //
    if(!pStore->WriteString(UTREG_UI_DOMAIN,
                            UTREG_UI_DOMAIN_DFLT,
                            _szDomain,
                            TRUE))
    {
        return E_FAIL;
    }

    if(GetEnableStartProgram())
    {
        //
        // Alternate shell (i.e StartProgram)
        //
        if(!pStore->WriteString(UTREG_UI_ALTERNATESHELL,
                               UTREG_UI_ALTERNATESHELL_DFLT,
                               _szAlternateShell,
                                TRUE))
        {
            return E_FAIL;
        }

        //
        // WorkDir
        //
        if(!pStore->WriteString(UTREG_UI_WORKINGDIR,
                               UTREG_UI_WORKINGDIR_DFLT,
                               _szWorkingDir,
                                TRUE))
        {
            return E_FAIL;
        }
    }
    else
    {
        //The setting is disabled so write out the default
        //values which will delete any existing settings
        //in the file.
        if(!pStore->WriteString(UTREG_UI_ALTERNATESHELL,
                                UTREG_UI_ALTERNATESHELL_DFLT,
                                UTREG_UI_ALTERNATESHELL_DFLT,
                                TRUE))
        {
            return E_FAIL;
        }

        //
        // WorkDir
        //
        if(!pStore->WriteString(UTREG_UI_WORKINGDIR,
                                UTREG_UI_WORKINGDIR_DFLT,
                                UTREG_UI_WORKINGDIR_DFLT,
                                TRUE))
        {
            return E_FAIL;
        }
    }

    //
    // Delete old format on save
    //
    pStore->DeleteValueIfPresent(UTREG_UI_PASSWORD50);
    pStore->DeleteValueIfPresent(UTREG_UI_SALT50);

    if (GetPasswordProvided() && CSH::IsCryptoAPIPresent() &&
        GetSavePassword())
    {
        HRESULT hr;
        TCHAR szClearPass[TSC_MAX_PASSLENGTH_TCHARS];
        memset(szClearPass, 0, sizeof(szClearPass));

        hr = GetClearTextPass(szClearPass, sizeof(szClearPass));
        if (SUCCEEDED(hr))
        {
            DATA_BLOB din;
            DATA_BLOB dout;
            din.cbData = sizeof(szClearPass);
            din.pbData = (PBYTE)&szClearPass;
            dout.pbData = NULL;
            if (CSH::DataProtect( &din, &dout))
            {
                BOOL bRet = 
                    pStore->WriteBinary(UI_SETTING_PASSWORD51,
                                         dout.pbData,
                                         dout.cbData);

                LocalFree( dout.pbData );

                //
                // Wipe stack copy
                //
                SecureZeroMemory(szClearPass, sizeof(szClearPass));
                if(!bRet)
                {
                    return E_FAIL;
                }
            }
            else
            {
                return E_FAIL;
            }
        }
    }
    else
    {
        pStore->DeleteValueIfPresent(UI_SETTING_PASSWORD51);
    }

    if (!WritePerfOptions( pStore ))
    {
        TRC_ERR((TB,_T("WritePerfOptions failed")));
        return FALSE;
    }

    if(SaveRegSettings())
    {
        return S_OK;
    }
    else
    {
        TRC_ERR((TB,_T("SaveRegSettings failed")));
        return E_FAIL;
    }
    
    DC_END_FN();
    return S_OK;        
}

int  CTscSettings::GetSoundRedirectionMode()
{
    return _soundRedirectionMode;
}
void CTscSettings::SetSoundRedirectionMode(int soundMode)
{
    DC_BEGIN_FN("SetSoundRedirectionMode");
    TRC_ASSERT(soundMode == UTREG_UI_AUDIO_MODE_REDIRECT  ||
               soundMode == UTREG_UI_AUDIO_MODE_PLAY_ON_SERVER ||
               soundMode == UTREG_UI_AUDIO_MODE_NONE,
               (TB,_T("Invalid soundMode")));
    _soundRedirectionMode = soundMode;
    DC_END_FN();
}

int  CTscSettings::GetKeyboardHookMode()
{
    return _keyboardHookMode;
}

void CTscSettings::SetKeyboardHookMode(int hookmode)
{
    DC_BEGIN_FN("SetKeyboardHookMode");
    TRC_ASSERT(hookmode == UTREG_UI_KEYBOARD_HOOK_NEVER  ||
               hookmode == UTREG_UI_KEYBOARD_HOOK_ALWAYS ||
               hookmode == UTREG_UI_KEYBOARD_HOOK_FULLSCREEN,
               (TB,_T("Invalid hookmode")));
    _keyboardHookMode = hookmode;
    DC_END_FN();
}


VOID CTscSettings::SetLogonUserName(LPCTSTR szUserName)
{
    _tcsncpy(_szUserName, szUserName, SIZECHAR(_szUserName));
}

VOID CTscSettings::SetDomain(LPCTSTR szDomain)
{
    _tcsncpy(_szDomain, szDomain, SIZECHAR(_szDomain));
}

VOID CTscSettings::SetStartProgram(LPCTSTR szStartProg)
{
    _tcsncpy(_szAlternateShell, szStartProg, SIZECHAR(_szAlternateShell));
}

VOID CTscSettings::SetWorkDir(LPCTSTR szWorkDir)
{
    _tcsncpy(_szWorkingDir, szWorkDir, SIZECHAR(_szWorkingDir));
}


//
// Apply settings to the control
//
HRESULT CTscSettings::ApplyToControl(IMsRdpClient* pTsc)
{
    HRESULT hr = E_FAIL;
    INT portNumber = -1;
    TCHAR szCanonicalServerName[TSC_MAX_ADDRESS_LENGTH];
    TCHAR szConnectArgs[TSC_MAX_ADDRESS_LENGTH];
    IMsTscNonScriptable* pTscNonScript = NULL;
    IMsRdpClientSecuredSettings* pSecuredSet = NULL;
    IMsRdpClientAdvancedSettings2* pAdvSettings = NULL;
    IMsRdpClient2* pTsc2 = NULL;
    
    USES_CONVERSION;
    DC_BEGIN_FN("ApplyToControl");

    TRC_ASSERT(pTsc,(TB,_T("pTsc is NULL")));
    if(pTsc)
    {
        TRC_ASSERT(GetDesktopHeight() && 
                   GetDesktopWidth(),
           (TB, _T("Invalid desktop width/height\n")));

        if (!GetDesktopHeight() ||
            !GetDesktopWidth())
        {
            hr = E_FAIL;
            DC_QUIT;
        }
        
        CHECK_DCQUIT_HR(pTsc->get_SecuredSettings2(&pSecuredSet));
        CHECK_DCQUIT_HR(pTsc->put_UserName( T2OLE( (LPTSTR)GetLogonUserName())));
        CHECK_DCQUIT_HR(pTsc->put_Domain( T2OLE( (LPTSTR)GetDomain())));
        CHECK_DCQUIT_HR(pTsc->put_DesktopWidth(GetDesktopWidth()));
        CHECK_DCQUIT_HR(pTsc->put_DesktopHeight(GetDesktopHeight()));
        int colorDepth = GetColorDepth();
        if(colorDepth)
        {
            CHECK_DCQUIT_HR(pTsc->put_ColorDepth(colorDepth));
        }

        CHECK_DCQUIT_HR(pTsc->put_FullScreen( BOOL_TO_VB(GetStartFullScreen())) );

        if(GetEnableStartProgram())
        {
            CHECK_DCQUIT_HR( pSecuredSet->put_StartProgram(
                 T2OLE( (LPTSTR)GetStartProgram())));
            CHECK_DCQUIT_HR( pSecuredSet->put_WorkDir(
                T2OLE( (LPTSTR)GetWorkDir())) );
        }
        else
        {
            OLECHAR nullChar = 0;
            CHECK_DCQUIT_HR( pSecuredSet->put_StartProgram( &nullChar ));
            CHECK_DCQUIT_HR( pSecuredSet->put_WorkDir( &nullChar ));
        }

        CHECK_DCQUIT_HR(pTsc->QueryInterface(IID_IMsRdpClient2, (VOID**)&pTsc2));
        CHECK_DCQUIT_HR(pTsc2->get_AdvancedSettings3( &pAdvSettings));
        if (!pAdvSettings)
        {
            hr = E_FAIL;
            DC_QUIT;
        }


        CHECK_DCQUIT_HR(pAdvSettings->put_RedirectDrives(
            (VARIANT_BOOL)_fDriveRedirectionEnabled));
        CHECK_DCQUIT_HR(pAdvSettings->put_RedirectPrinters(
            (VARIANT_BOOL)_fPrinterRedirectionEnabled))
        CHECK_DCQUIT_HR(pAdvSettings->put_RedirectPorts(
            (VARIANT_BOOL)_fPortRedirectionEnabled));
        CHECK_DCQUIT_HR(pAdvSettings->put_RedirectSmartCards(
            (VARIANT_BOOL)_fSCardRedirectionEnabled));

        //
        // Enable mouse support
        //
        CHECK_DCQUIT_HR(pAdvSettings->put_EnableMouse(
            BOOL_TO_VB(_fEnableMouse)));

        // Bitmap disk cache sizes (per color depth)
        // 8bpp / TSAC legacy size
        //
        CHECK_DCQUIT_HR(pAdvSettings->put_BitmapVirtualCacheSize(
            _BitmapVirtualCache8BppSize));
        // 16 and 24 bpp sizes
        CHECK_DCQUIT_HR(pAdvSettings->put_BitmapVirtualCache16BppSize(
            _BitmapVirtualCache16BppSize));
        CHECK_DCQUIT_HR(pAdvSettings->put_BitmapVirtualCache24BppSize(
            _BitmapVirtualCache24BppSize));

        CHECK_DCQUIT_HR(pSecuredSet->put_KeyboardHookMode(
            GetKeyboardHookMode() ));
        CHECK_DCQUIT_HR(pSecuredSet->put_AudioRedirectionMode(
            GetSoundRedirectionMode()));

        hr = pTsc->QueryInterface(IID_IMsTscNonScriptable,
                                  (void**)&pTscNonScript);
        if(FAILED(hr) || !pTscNonScript)
        {
            CHECK_DCQUIT_HR(hr);
        }

        if(GetPasswordProvided())
        {
            TCHAR szClearPass[TSC_MAX_PASSLENGTH_TCHARS];
            memset(szClearPass, 0, sizeof(szClearPass));
            hr = GetClearTextPass(szClearPass, sizeof(szClearPass));
            if (SUCCEEDED(hr))
            {
                hr = pTscNonScript->put_ClearTextPassword(szClearPass);
            }
            else
            {
                hr = pTscNonScript->ResetPassword();
            }

            //
            // Wipe stack copy
            //
            SecureZeroMemory(szClearPass, sizeof(szClearPass));
            CHECK_DCQUIT_HR(hr);
        }
        else
        {
            CHECK_DCQUIT_HR(pTscNonScript->ResetPassword());
        }

        hr = _ConnectString.GetServerPortion(
                        szCanonicalServerName,
                        SIZE_TCHARS(szCanonicalServerName)
                        );
        CHECK_DCQUIT_HR(hr);

        //
        // Figure out if a port was specified as part of the
        // server name and if so strip it off the end and set
        // the port property
        //
        portNumber = CUT::GetPortNumberFromServerName(
            szCanonicalServerName
            );
        if(-1 != portNumber)
        {
            TRC_NRM((TB,_T("Port specified as part of srv name: %d"),
                     portNumber));
            
            //Strip out the port number portion
            //from the server.
            TCHAR szServer[TSC_MAX_ADDRESS_LENGTH];
            CUT::GetServerNameFromFullAddress(
                        szCanonicalServerName,
                        szServer,
                        TSC_MAX_ADDRESS_LENGTH
                        );

            CHECK_DCQUIT_HR( pAdvSettings->put_RDPPort( portNumber ) );
            CHECK_DCQUIT_HR( pTsc->put_Server(T2OLE( (LPTSTR)szServer )) );
        }
        else
        {
            //No server[:port] specified just set the port
            //from prop from the settings
            CHECK_DCQUIT_HR( pAdvSettings->put_RDPPort( GetMCSPort() ) );
            CHECK_DCQUIT_HR( pTsc->put_Server( T2OLE(szCanonicalServerName)) );
        }

        CHECK_DCQUIT_HR( pAdvSettings->put_Compress( GetCompress()) );
#ifdef SMART_SIZING
        CHECK_DCQUIT_HR( pAdvSettings->put_SmartSizing(
            BOOL_TO_VB(GetSmartSizing())));
#endif // SMART_SIZING
        CHECK_DCQUIT_HR( pAdvSettings->put_DisableCtrlAltDel(
            GetDisableCtrlAltDel()) );
        CHECK_DCQUIT_HR( pAdvSettings->put_BitmapPersistence(
            GetBitmapPersitenceFromPerfFlags() ));
        CHECK_DCQUIT_HR( pAdvSettings->put_PluginDlls(T2OLE(_szPluginList)) );
        CHECK_DCQUIT_HR( pAdvSettings->put_ConnectToServerConsole(
            BOOL_TO_VB(_fConnectToConsole)));
        CHECK_DCQUIT_HR( pAdvSettings->put_DisplayConnectionBar(
            BOOL_TO_VB(_fDisplayBBar)));
        CHECK_DCQUIT_HR( pAdvSettings->put_PinConnectionBar(
            BOOL_TO_VB(_fPinBBar)));
        CHECK_DCQUIT_HR( pAdvSettings->put_EnableAutoReconnect(
            BOOL_TO_VB(_fEnableAutoReconnect)));
        CHECK_DCQUIT_HR( pAdvSettings->put_MaxReconnectAttempts(
            _nArcMaxRetries));

        CHECK_DCQUIT_HR( pAdvSettings->put_KeyBoardLayoutStr(
            T2OLE(_szKeybLayoutStr)));

#ifdef OS_WINCE
        CHECK_DCQUIT_HR( pAdvSettings->put_KeyboardType(_keyboardType));
        CHECK_DCQUIT_HR( pAdvSettings->put_KeyboardSubType(_keyboardSubType));
        CHECK_DCQUIT_HR( pAdvSettings->put_KeyboardFunctionKey(_keyboardFunctionKey));

        CHECK_DCQUIT_HR( pAdvSettings->put_BitmapCacheSize(_RegBitmapCacheSize));
#endif

        //
        // Do some tweaking on the disabled feature list that we pass
        // to the control - remove the bitmap caching bit as that is a 
        // separate property
        //
        LONG perfFlags = 
            (LONG)(_dwPerfFlags & ~TS_PERF_DISABLE_BITMAPCACHING);
        CHECK_DCQUIT_HR( pAdvSettings->put_PerformanceFlags(perfFlags));

        //
        // Connection arguments come last (they override)
        // Parse and apply settings from any connect args
        //
        memset(szConnectArgs, 0 , sizeof(szConnectArgs));
        hr = _ConnectString.GetArgumentsPortion(
                        szConnectArgs,
                        SIZE_TCHARS(szConnectArgs)
                        );
        CHECK_DCQUIT_HR(hr);
        hr = ApplyConnectionArgumentSettings(
                        szConnectArgs,
                        pAdvSettings
                        );
        if (FAILED(hr)) {
            TRC_ERR((TB,
                _T("ApplyConnectionArgumentSettings failed: 0x%x"),hr));
        }
    }
    else
    {
        hr = E_INVALIDARG;
        DC_QUIT;
    }


    
DC_EXIT_POINT:
    if (pTscNonScript) {
        pTscNonScript->Release();
        pTscNonScript = NULL;
    }

    if (pAdvSettings) {
        pAdvSettings->Release();
        pAdvSettings = NULL;
    }

    if (pSecuredSet) {
        pSecuredSet->Release();
        pSecuredSet = NULL;
    }

    if (pTsc2) {
        pTsc2->Release();
        pTsc2 = NULL;
    }

    DC_END_FN();
    return hr;
}

#define CONARG_CONSOLE _T("/CONSOLE")
HRESULT
CTscSettings::ApplyConnectionArgumentSettings(
                LPCTSTR szConArg,
                IMsRdpClientAdvancedSettings2* pAdvSettings
                )
{
    HRESULT hr = S_OK;
    BOOL fConnectToConsole = FALSE;
    DC_BEGIN_FN("ApplyConnectionArgumentSettings");
    TCHAR szUpperArg[TSC_MAX_ADDRESS_LENGTH];

    if (szConArg[0] != 0) {
        TRC_NRM((TB,_T("Connect string Connection args - %s"), szConArg));

        hr = StringCchCopy(
                    szUpperArg,
                    SIZE_TCHARS(szUpperArg),
                    szConArg
                    );
        if (FAILED(hr)) {
            DC_QUIT;
        }

        //
        // U-case for the string find
        //
        LPTSTR sz = szUpperArg;
        while (*sz) {
            *sz = towupper(*sz);
            sz++;
        }

        //
        // Only one we care about now is "/console"
        //
        if (_tcsstr(szUpperArg, CONARG_CONSOLE)) {
            fConnectToConsole = TRUE;
        }
    }
    else {
        TRC_NRM((TB,_T("No Connection args")));
    }

    if (fConnectToConsole) {
        TRC_NRM((TB,_T("Connect args enabled connect to console")));
        hr = pAdvSettings->put_ConnectToServerConsole(VARIANT_TRUE);
    }

    DC_END_FN();
DC_EXIT_POINT:
    return hr;
}


//
// Pickup settings the control may have updated
//
HRESULT CTscSettings::GetUpdatesFromControl(IMsRdpClient* pTsc)
{
    DC_BEGIN_FN("GetUpdatesFromControl");
    USES_CONVERSION;
    HRESULT hr = E_FAIL;

    TRC_ASSERT(pTsc,(TB,_T("pTsc is null")));
    if(pTsc)
    {
        BSTR Domain;
        TRACE_HR(pTsc->get_Domain(&Domain));
        if(SUCCEEDED(hr))
        {
            LPTSTR szDomain = OLE2T(Domain);
            if(szDomain)
            {
                SetDomain(szDomain);
            }
            else
            {
                return E_FAIL;
            }

            SysFreeString(Domain);
        }
        else
        {
            return hr;
        }

        BSTR UserName;
        TRACE_HR(pTsc->get_UserName(&UserName));
        if(SUCCEEDED(hr))
        {
            LPTSTR szUserName = OLE2T(UserName);
            if(UserName)
            {
                SetLogonUserName(szUserName);
            }
            else
            {
                return E_FAIL;
            }
            SysFreeString(UserName);
        }
        else
        {
            return hr;
        }

        VARIANT_BOOL vb;
        IMsRdpClientAdvancedSettings* pAdv = NULL;
        TRACE_HR(pTsc->get_AdvancedSettings2(&pAdv));
        if (SUCCEEDED(hr))
        {
            TRACE_HR(pAdv->get_PinConnectionBar(&vb));
            if (SUCCEEDED(hr) && vb == VARIANT_TRUE)
            {
                _fPinBBar = TRUE;
            }
            else
            {
                _fPinBBar = FALSE;
            }

            pAdv->Release();
            pAdv = NULL;
        }
    }

    DC_END_FN();
    return S_OK;
}

BOOL CTscSettings::UpdateRegMRU(LPTSTR szNewServer)
{
    DCINT i, j;
    DCBOOL bServerPresent=FALSE;
    CUT ut;

    DC_BEGIN_FN("UpdateRegMRU");
    for (i=0; i<10;++i)
    {
        if (!_tcsnicmp(_szMRUServer[i],szNewServer,
                       SIZECHAR(_szMRUServer[i])))
        {
            bServerPresent = TRUE;
            for (j=i; j>0; --j)
            {
                _tcsncpy(_szMRUServer[j],_szMRUServer[j-1],
                         SIZECHAR(_szMRUServer[i]));
            }
            _tcsncpy(_szMRUServer[0], szNewServer,
                     SIZECHAR(_szMRUServer[i]));
        }
    }
    if (!bServerPresent)
    {
        for (i=9; i>0; --i)
        {
            _tcsncpy(_szMRUServer[i],_szMRUServer[i-1],
                     SIZECHAR(_szMRUServer[0]));
        }
        _tcsncpy(_szMRUServer[0], szNewServer,
                 SIZECHAR(_szMRUServer[0]));
    }

    ut.UT_WriteRegistryString(TSC_DEFAULT_REG_SESSION,
                               UTREG_UI_SERVER_MRU0,
                               UTREG_UI_SERVER_MRU_DFLT,
                               _szMRUServer[0]);
    ut.UT_WriteRegistryString(TSC_DEFAULT_REG_SESSION,
                               UTREG_UI_SERVER_MRU1,
                               UTREG_UI_SERVER_MRU_DFLT,
                               _szMRUServer[1]);
    ut.UT_WriteRegistryString(TSC_DEFAULT_REG_SESSION,
                               UTREG_UI_SERVER_MRU2,
                               UTREG_UI_SERVER_MRU_DFLT,
                               _szMRUServer[2]);
    ut.UT_WriteRegistryString(TSC_DEFAULT_REG_SESSION,
                               UTREG_UI_SERVER_MRU3,
                               UTREG_UI_SERVER_MRU_DFLT,
                               _szMRUServer[3]);
    ut.UT_WriteRegistryString(TSC_DEFAULT_REG_SESSION,
                               UTREG_UI_SERVER_MRU4,
                               UTREG_UI_SERVER_MRU_DFLT,
                               _szMRUServer[4]);
    ut.UT_WriteRegistryString(TSC_DEFAULT_REG_SESSION,
                               UTREG_UI_SERVER_MRU5,
                               UTREG_UI_SERVER_MRU_DFLT,
                               _szMRUServer[5]);
    ut.UT_WriteRegistryString(TSC_DEFAULT_REG_SESSION,
                               UTREG_UI_SERVER_MRU6,
                               UTREG_UI_SERVER_MRU_DFLT,
                               _szMRUServer[6]);
    ut.UT_WriteRegistryString(TSC_DEFAULT_REG_SESSION,
                               UTREG_UI_SERVER_MRU7,
                               UTREG_UI_SERVER_MRU_DFLT,
                               _szMRUServer[7]);
    ut.UT_WriteRegistryString(TSC_DEFAULT_REG_SESSION,
                               UTREG_UI_SERVER_MRU8,
                               UTREG_UI_SERVER_MRU_DFLT,
                               _szMRUServer[8]);
    ut.UT_WriteRegistryString(TSC_DEFAULT_REG_SESSION,
                               UTREG_UI_SERVER_MRU9,
                               UTREG_UI_SERVER_MRU_DFLT,
                               _szMRUServer[9]);

    TRC_NRM((TB, _T("Write to registry - Address = %s"), szNewServer));
    DC_END_FN();
    return TRUE;
}

//
// Save those settings that go in the registry
//
BOOL CTscSettings::SaveRegSettings()
{
    DC_BEGIN_FN("SaveRegSettings");

    //
    // Update the MRU list in the registry
    //
    UpdateRegMRU(GetFlatConnectString());

    DC_END_FN();
    return TRUE;
}

BOOL CTscSettings::ReadPassword(ISettingsStore* pSto)
{
    DC_BEGIN_FN("ReadPassword");

    PBYTE pbPass = NULL;
    BOOL bRet = TRUE;
    SetClearTextPass(_T(""));
    SetUIPasswordEdited(FALSE);
    SetSavePassword(FALSE);
    TCHAR szClearPass[TSC_MAX_PASSLENGTH_TCHARS];
    memset(szClearPass, 0, sizeof(szClearPass));

    if (CSH::IsCryptoAPIPresent() &&
        pSto->IsValuePresent(UI_SETTING_PASSWORD51))
    {
        DWORD dwEncPassLen = pSto->GetDataLength(UI_SETTING_PASSWORD51);
        if(dwEncPassLen && dwEncPassLen < 4096)
        {
            pbPass = (PBYTE)LocalAlloc( LPTR, dwEncPassLen);
            if (pbPass && pSto->ReadBinary( UI_SETTING_PASSWORD51,
                                              pbPass,
                                              dwEncPassLen ))
            {
                DATA_BLOB din, dout;
                din.cbData = dwEncPassLen;
                din.pbData = pbPass;
                dout.pbData = NULL;
                if (CSH::DataUnprotect(&din, &dout))
                {
                    memcpy(szClearPass, dout.pbData,
                           min( dout.cbData, sizeof(szClearPass)));

                    //
                    // Store the password securely
                    //
                    SetClearTextPass(szClearPass);

                    //
                    // Wipe stack copy
                    //
                    SecureZeroMemory(szClearPass, sizeof(szClearPass));
                    LocalFree( dout.pbData );

                    //
                    // If a password was provided default to save
                    // it
                    //
                    if (GetPasswordProvided())
                    {
                        SetSavePassword( TRUE );
                    }
                    
                }
                else
                {
                    bRet = FALSE;
                }
            }
        }
        else
        {
            TRC_ERR((TB,_T("Invalid pass length")));
            bRet = FALSE;
        }
    }

    if(pbPass)
    {
        LocalFree(pbPass);
    }

    DC_END_FN();

    return bRet;
}

//
// Store a clear text password. On platforms that support
// it internally encrypt the password.
//
HRESULT CTscSettings::SetClearTextPass(LPCTSTR szClearPass)
{
    HRESULT hr = E_FAIL;
    DC_BEGIN_FN("SetClearTextPass");

    if (CSH::IsCryptoAPIPresent())
    {
        DATA_BLOB din;
        din.cbData = _tcslen(szClearPass) * sizeof(TCHAR);
        din.pbData = (PBYTE)szClearPass;
        if (_blobEncryptedPassword.pbData)
        {
            LocalFree(_blobEncryptedPassword.pbData);
            _blobEncryptedPassword.pbData = NULL;
            _blobEncryptedPassword.cbData = 0;
        }
        if (din.cbData)
        {
            if (CSH::DataProtect( &din, &_blobEncryptedPassword))
            {
                hr = S_OK;
            }
            else
            {
                TRC_ERR((TB,_T("DataProtect failed")));
                hr = E_FAIL;
            }
        }
        else
        {
            TRC_NRM((TB,_T("0 length password, not encrypting")));
            hr = S_OK;
        }
    }
    else
    {
        hr = StringCchCopy(_szClearPass, SIZECHAR(_szClearPass), szClearPass);
        if (FAILED(hr)) {
            TRC_ERR((TB, _T("String copy failed: hr = 0x%x"), hr));
        }
    }

    DC_END_FN();
    return hr;
}

//
// Retrieve a clear text password
//
// On platforms that support it the password is internally encrypted
//
// Params
// [out] szBuffer - receives decrypted password
// [int] cbLen    - length of szBuffer
//
HRESULT CTscSettings::GetClearTextPass(LPTSTR szBuffer, INT cbLen)
{
    HRESULT hr = E_FAIL;
    DC_BEGIN_FN("GetClearTextPass");

    if (CSH::IsCryptoAPIPresent())
    {
        DATA_BLOB dout;
#ifdef OS_WINCE
        dout.cbData = 0;
        dout.pbData = NULL;
#endif
        if (_blobEncryptedPassword.cbData)
        {
            if (CSH::DataUnprotect(&_blobEncryptedPassword, &dout))
            {
                memcpy(szBuffer, dout.pbData, min( dout.cbData, (UINT)cbLen));

                //
                // Nuke the original copy
                //
                SecureZeroMemory(dout.pbData, dout.cbData);
                LocalFree( dout.pbData );
                hr = S_OK;
            }
            else
            {
                TRC_ERR((TB,_T("DataUnprotect failed")));
                hr = E_FAIL;
            }
        }
        else
        {
            TRC_NRM((TB,_T("0 length encrypted pass, not decrypting")));

            //
            // Just reset the output buffer
            //
            memset(szBuffer, 0, cbLen);
            hr = S_OK;
        }
    }
    else
    {
        memcpy(szBuffer, _szClearPass, cbLen);
        hr = S_OK;
    }

    DC_END_FN();
    return hr;
}


//
// Returns true if a password was provided
//
BOOL CTscSettings::GetPasswordProvided()
{
    HRESULT hr;
    BOOL fPassProvided = FALSE;
    TCHAR szClearPass[TSC_MAX_PASSWORD_LENGTH_BYTES / sizeof(TCHAR)];
    DC_BEGIN_FN("GetPasswordProvided");

    hr = GetClearTextPass(szClearPass, sizeof(szClearPass));
    if (SUCCEEDED(hr))
    {
        //
        // Blank password means no password
        //
        if (_tcscmp(szClearPass, _T("")))
        {
            fPassProvided =  TRUE;
        }
    }
    else
    {
        TRC_ERR((TB,_T("GetClearTextPass failed")));
    }

    SecureZeroMemory(szClearPass, sizeof(szClearPass));

    DC_END_FN();
    return fPassProvided;
}

const PERFOPTIONS_PERSISTINFO g_perfOptLut[] = {
    {PO_DISABLE_WALLPAPER, PO_DISABLE_WALLPAPER_DFLT,
        TS_PERF_DISABLE_WALLPAPER, TRUE},
    {PO_DISABLE_FULLWINDOWDRAG, PO_DISABLE_FULLWINDOWDRAG_DFLT,
        TS_PERF_DISABLE_FULLWINDOWDRAG, TRUE},
    {PO_DISABLE_MENU_WINDOW_ANIMS, PO_DISABLE_MENU_WINDOW_ANIMS_DFLT,
        TS_PERF_DISABLE_MENUANIMATIONS, TRUE},
    {PO_DISABLE_THEMES, PO_DISABLE_THEMES_DFLT,
        TS_PERF_DISABLE_THEMING, TRUE},
    {PO_ENABLE_ENHANCED_GRAPHICS, PO_ENABLE_ENHANCED_GRAPHICS_DFLT,
        TS_PERF_ENABLE_ENHANCED_GRAPHICS, FALSE},
    {PO_DISABLE_CURSOR_SETTINGS, PO_DISABLE_CURSOR_SETTINGS_DFLT,
        TS_PERF_DISABLE_CURSORSETTINGS, TRUE}
};

#define NUM_PERFLUT_ITEMS sizeof(g_perfOptLut)/sizeof(PERFOPTIONS_PERSISTINFO)

BOOL CTscSettings::ReadPerfOptions(ISettingsStore* pStore)
{
    BOOL fBitmapPersistence = FALSE;
    BOOL fSetting;
    INT i;

    DC_BEGIN_FN("ReadPerfOptions");

    _dwPerfFlags = 0;

    //
    // Read in the perf settings and insert into the perf flags
    //
    for (i=0; i<NUM_PERFLUT_ITEMS; i++)
    {
        if (pStore->ReadBool( g_perfOptLut[i].szValName,
                              g_perfOptLut[i].fDefaultVal,
                              &fSetting ))
        {
            if (fSetting)
            {
                _dwPerfFlags |= g_perfOptLut[i].fFlagVal;
            }
        }
        else
        {
            TRC_ERR((TB,_T("ReadBool failed on %s"), 
                     g_perfOptLut[i].szValName));
            return FALSE;
        }
    }

#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
    //
    //
    // Bitmap caching
    //
    if(!pStore->ReadBool(UTREG_UI_BITMAP_PERSISTENCE,
                         UTREG_UI_BITMAP_PERSISTENCE_DFLT,
                         &fBitmapPersistence))
    {
        return E_FAIL;
    }
#else
    fBitmapPersistence = UTREG_UI_BITMAP_PERSISTENCE_DFLT;
#endif

    //
    // Internally bitmap persistence (bitmap caching)
    // is passed around as part of the disabled feature list
    // so add it in
    //
    _dwPerfFlags |= (fBitmapPersistence ? 0 :
                               TS_PERF_DISABLE_BITMAPCACHING);

    //
    // Enable cursor setting if it was disabled previously.
    //
    _dwPerfFlags &= ~TS_PERF_DISABLE_CURSORSETTINGS;
    DC_END_FN();
    return TRUE;
}

BOOL CTscSettings::WritePerfOptions(ISettingsStore* pStore)
{
    BOOL fSetting;
    INT i;

    DC_BEGIN_FN("WritePerfOptions");


    //
    // Write out the individual perf settings
    //
    for (i=0; i<NUM_PERFLUT_ITEMS; i++)
    {
        fSetting = _dwPerfFlags & g_perfOptLut[i].fFlagVal ? TRUE : FALSE;

        if (!pStore->WriteBool( g_perfOptLut[i].szValName,
                               0, //ignored default
                               fSetting,
                               g_perfOptLut[i].fForceSave ))
        {
            TRC_ERR((TB,_T("WriteBool failed on %s"), 
                     g_perfOptLut[i].szValName));
            return FALSE;
        }
    }

    //
    // Fetch and write out the setting for bitmap caching
    //
    BOOL fBitmapPersistence = GetBitmapPersitenceFromPerfFlags();
    if(!pStore->WriteBool(UTREG_UI_BITMAP_PERSISTENCE,
                   UTREG_UI_BITMAP_PERSISTENCE_DFLT,
                   fBitmapPersistence,
                   TRUE))
    {

        return FALSE;
    }
    
    DC_END_FN();
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\tscapp.cpp ===
//
// tscapp.cpp
//
// Implementation of CTscApp
// Ts Client Shell app logic
//
// Copyright(C) Microsoft Corporation 2000
// Author: Nadim Abdo (nadima)
//
//

#include "stdafx.h"
#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "tscapp.cpp"
#include <atrcapi.h>

#include "tscapp.h"
#include "tscsetting.h"
#include "rdpfstore.h"
#include "rmigrate.h"
#include "sh.h"

CTscApp::CTscApp()
{
    DC_BEGIN_FN("CTscApp");
    _pWnd = NULL;
    _pShellUtil = NULL;
    _pTscSet = NULL;
    _fAutoSaveSettings = FALSE;
    DC_END_FN();
}

CTscApp::~CTscApp()
{
    DC_BEGIN_FN("~CTscApp");

    delete _pWnd;
    delete _pShellUtil;
    delete _pTscSet;

    DC_END_FN();
}

//
// StartShell called to startup the app
//
//
BOOL CTscApp::StartShell(HINSTANCE hInstance,
                         HINSTANCE hPrevInstance,
                         LPTSTR lpszCmdLine)
{
    DWORD dwErr;

    DC_BEGIN_FN("StartShell");

    _hInst = hInstance;
    TRC_ASSERT(!_pWnd,
               (TB,_T("Calling StartShell while container wnd is up")));

    //
    // Create the container window
    //
    _pShellUtil = new CSH();
    if(_pShellUtil)
    {
        if(!_pShellUtil->SH_Init( hInstance))
        {
            TRC_ERR((TB,_T("SH_Init failed")));
            return FALSE;
        }

        dwErr = _pShellUtil->SH_ParseCmdParam( lpszCmdLine);

        if (SH_PARSECMD_OK != dwErr) {
            TRC_ERR((TB,_T("SH_ParseCmdParam failed on: %s code: 0x%x"),lpszCmdLine, dwErr));

            //
            // Invalid connection file specified
            //
            if (SH_PARSECMD_ERR_INVALID_CONNECTION_PARAM == dwErr) {

                _pShellUtil->SH_DisplayErrorBox(NULL,
                                                UI_IDS_ERR_INVALID_CONNECTION_FILE,
                                                _pShellUtil->GetRegSession()
                                                );
            }

            //
            // Parse failure is fatal 
            //
            return FALSE;
        }

#ifndef OS_WINCE
        if(_pShellUtil->SH_GetCmdMigrate())
        {
            //Only do a migrate and then quit
            CTscRegMigrate mig;
            TCHAR szPath[MAX_PATH];
            if(_pShellUtil->SH_GetRemoteDesktopFolderPath(szPath,
                                             SIZECHAR(szPath)))
            {
                if(!mig.MigrateAll(szPath))
                {
                    TRC_ERR((TB,_T("MigrateAll failed to dir:%s"),szPath));
                }
                //Want to quit the app
                return FALSE;
            }
            else
            {
                TRC_ERR((TB,_T("SH_GetRemoteDesktopFolderPath failed")));
                return FALSE;
            }
        }
#endif

        if(!InitSettings(hInstance))
        {
            TRC_ERR((TB,_T("InitSettings returned FALSE")));
            return FALSE;
        }

        _pWnd = new CContainerWnd();
        if(_pWnd)
        {
            if (_pWnd->Init( hInstance, _pTscSet, _pShellUtil))
            {
                return TRUE;
            }
            else
            {
                TRC_ERR((TB,_T("Error: pWnd->Init returned FALSE. Exiting\n")));
                return FALSE;
            }
        }
        else
        {
            TRC_ERR((TB,_T("Could not new CContainerWnd")));
            return FALSE;
        }
    }
    else
    {
        TRC_ERR((TB,_T("Could not new CSH")));
        return FALSE;
    }

    DC_END_FN();
}

HWND CTscApp::GetTscDialogHandle()
{
    DC_BEGIN_FN("GetTscDialogHandle");
    HWND hwndDlg = NULL;
    if(_pWnd)
    {
        hwndDlg = _pWnd->GetConnectDialogHandle();
    }

    DC_END_FN();
    return hwndDlg;
}


//
// Setup the settings structures
// Based on command line options
//
// This involves figuring out where to load settings from
// and then doing it. E.g
//  Load from file
//  Load from registry
//  Load from internal defaults
//
BOOL CTscApp::InitSettings(HINSTANCE hInstance)
{
    CRdpFileStore rdpf;
    LPTSTR szFileName = NULL;
    TCHAR szDefaultFile[MAX_PATH];
    BOOL    fLoadedSettings = FALSE;

    DC_BEGIN_FN("InitSettings");

    _pTscSet = new CTscSettings();
    if(!_pTscSet)
    {
        TRC_ERR((TB,_T("Could not new CTscSettings")));
        return FALSE;
    }

    if(_pShellUtil->SH_GetCmdFileForEdit() ||
       _pShellUtil->SH_GetCmdFileForConnect())
    {
        szFileName = _pShellUtil->SH_GetCmdLnFileName();
        if(!_pShellUtil->SH_FileExists(szFileName))
        {
            TCHAR errFileNotFound[MAX_PATH];
            TCHAR szAppName[MAX_PATH];

            if(LoadString(hInstance,
                          UI_IDS_APP_NAME,
                          szAppName,
                          SIZECHAR(szAppName)))
            {
                if (LoadString(hInstance,
                               UI_IDS_ERR_FILEDOESNOTEXIST,
                               errFileNotFound,
                               SIZECHAR(errFileNotFound)) != 0)
                {
                    TCHAR errFormatedFileNotFound[MAX_PATH*3];
                    _stprintf(errFormatedFileNotFound, errFileNotFound,
                              szFileName);
                    MessageBox(NULL, errFormatedFileNotFound, szAppName, 
                               MB_ICONERROR | MB_OK);
                    return FALSE;
                }
            }
            return FALSE;
        }
    }
    else if(_pShellUtil->GetRegSessionSpecified())
    {
        // Automigrate the specified registry
        // session directly to an in-memory settings store
        _fAutoSaveSettings = FALSE;
        rdpf.SetToNullStore();

        CTscRegMigrate mig;
        TRC_NRM((TB,_T("Automigrating session %s"),
                 _pShellUtil->GetRegSession()));
        if(mig.MigrateSession( _pShellUtil->GetRegSession(),
                               &rdpf))
        {
            TRC_NRM((TB,_T("Success automigrating reg setting")));

            HRESULT hr = _pTscSet->LoadFromStore(&rdpf);
            if(FAILED(hr))
            {
                _pShellUtil->SH_DisplayErrorBox(NULL,
                                         UI_IDS_ERR_INITDEFAULT,
                                         szFileName);
                return FALSE;
            }

            _pShellUtil->SetAutoConnect( TRUE );
            fLoadedSettings = TRUE;
        }
        else
        {
            //Something bad happened
            //could not automigrate..indicate failure
            //and use NULL store
            fLoadedSettings = FALSE;
        }
    }
    else
    {
        //No files specified or registry sessions specified
        //Try to use the default.rdp file (create if necessary)
        if(!_pShellUtil->SH_GetPathToDefaultFile(
            szDefaultFile,
            SIZECHAR(szDefaultFile)))
        {
        
            TRC_ERR((TB,_T("SH_GetPathToDefaultFile failed")));
            //
            // Display error message to user
            //
            _pShellUtil->SH_DisplayErrorBox(NULL,
                UI_IDS_ERR_GETPATH_TO_DEFAULT_FILE);
            return FALSE;
        }

        szFileName = szDefaultFile;
        if(!_pShellUtil->SH_FileExists(szFileName))
        {
            //
            // File doesn't exist so create the Remote Desktops
            // directory to ensure the file can be created
            //
            if(!CreateRDdir())
            {
                TRC_ERR((TB,_T("Couldn't create RD dir. Not using %s"),
                         szFileName));
                szFileName = NULL;
            }

            //
            // Now create a hidden default file
            //
            if (szFileName)
            {
                if (!CSH::SH_CreateHiddenFile(szFileName))
                {
                    TRC_ERR((TB,_T("Unable to create and hide file %s"),
                             szFileName));
                    szFileName = NULL;
                }
            }
        }
        //
        // Auto Save on exit if we're using the default
        // connection file (Default.rdp)
        //
        _fAutoSaveSettings = szFileName ? TRUE : FALSE;
    }

    if(szFileName)
    {
        //
        //We're loading the settings from a file
        //this is the common case.
        //
        if(rdpf.OpenStore(szFileName))
        {
            HRESULT hr = _pTscSet->LoadFromStore(&rdpf);
            if(SUCCEEDED(hr))
            {
                fLoadedSettings = TRUE;
            }
            else
            {
                TRC_ERR((TB,_T("LoadFromStore failed")));
                _pShellUtil->SH_DisplayErrorBox(NULL,
                                         UI_IDS_ERR_LOAD,
                                         szFileName);
            // We can load NULL file even if you can't load the file
            }
            rdpf.CloseStore();
        }
        else
        {
            TRC_ERR((TB,_T("OpenStore (%s) failed"),szFileName));
            _pShellUtil->SH_DisplayErrorBox(NULL,UI_IDS_ERR_OPEN_FILE,
                                            szFileName);

            // We can load NULL file even if you can't open the file
        }
    }

    if(!fLoadedSettings)
    {
        TRC_ERR((TB,_T("Couldn't load settings, using NULL STORE")));
        //Some bad thing happened and we can't get a file to load
        //from (not even the default file). So load from an empty
        //store, this will initialize everything to defaults
        if(rdpf.SetToNullStore())
        {
            HRESULT hr = _pTscSet->LoadFromStore(&rdpf);
            if(FAILED(hr))
            {
                _pShellUtil->SH_DisplayErrorBox(NULL,
                                         UI_IDS_ERR_INITDEFAULT,
                                         szFileName);
                return FALSE;
            }
        }
        else
        {
            TRC_ERR((TB,_T("SetToNullStore Failed")));
            return FALSE;
        }
    }

    //Keep track of the filename
    if(szFileName)
    {
        _pTscSet->SetFileName(szFileName);
    }

    //
    // Override loaded settings with cmd line settings
    //
    _pShellUtil->SH_ApplyCmdLineSettings(_pTscSet, NULL);

    DC_END_FN();
    return TRUE;
}

BOOL CTscApp::EndShell()
{
    DC_BEGIN_FN("EndShell");
    BOOL fRet = FALSE;
    if(!_pTscSet || !_pShellUtil)
    {
        return FALSE;
    }

#ifndef OS_WINCE
    _pShellUtil->SH_Cleanup();
#endif

    //
    // Only autosave if
    // the last connection was successful
    //
    if(_fAutoSaveSettings && 
       _pWnd &&
       _pWnd->GetConnectionSuccessFlag())
    {
        //
        // AutoSave the tscsettings
        // (only if the current file is still Default.rdp)
        //
        TCHAR szDefaultFile[MAX_PATH];
        if(!_pShellUtil->SH_GetPathToDefaultFile(
            szDefaultFile,
            SIZECHAR(szDefaultFile)))
        {
            TRC_ERR((TB,_T("SH_GetPathToDefaultFile failed")));
            return FALSE;
        }
        if(!_tcscmp(szDefaultFile, _pTscSet->GetFileName()))
        {

            CRdpFileStore rdpf;
            if(rdpf.OpenStore(szDefaultFile))
            {
                HRESULT hr = E_FAIL;
                hr = _pTscSet->SaveToStore(&rdpf);
                if(SUCCEEDED(hr))
                {
                    if(rdpf.CommitStore())
                    {
                        //Save last filename
                        _pTscSet->SetFileName(szDefaultFile);
                        fRet = TRUE;
                    }
                    else
                    {
                        TRC_ERR((TB,_T("Unable to CommitStore settings")));
                    }
                }
                else
                {
                    TRC_ERR((TB,_T("Unable to save settings to store %d, %s"),
                              hr, szDefaultFile));
                }

                rdpf.CloseStore();
                if(!fRet)
                {
                    _pShellUtil->SH_DisplayErrorBox(NULL,
                                                    UI_IDS_ERR_SAVE,
                                                    szDefaultFile);

                }
                return fRet;
            }
            else
            {
                TRC_ERR((TB,_T("Unable to OpenStore for save %s"), szDefaultFile));
                _pShellUtil->SH_DisplayErrorBox(NULL,UI_IDS_ERR_OPEN_FILE,
                                                szDefaultFile);
                return FALSE;
            }


        }
        else
        {
            //Not a failure, but nothing to do
            TRC_NRM((TB,_T("Current file is no longer default, don't autosave")));
            return TRUE;
        }
    }
    else
    {
        return TRUE;
    }
    DC_END_FN();
}

//
// Creates the Remote Desktops dir (if needed)
// pops UI on failure
//
// Returns:
//      TRUE on success
//
//
BOOL CTscApp::CreateRDdir()
{
    DC_BEGIN_FN("CreateRDdir");

    //
    // Make sure the directory exists so that the file
    // can be created by the OpenStore
    //
    TCHAR szDir[MAX_PATH];
    if(_pShellUtil->SH_GetRemoteDesktopFolderPath(szDir,
                                            SIZECHAR(szDir)))
    {
        if(_pShellUtil->SH_CreateDirectory(szDir))
        {
            return TRUE;
        }
        else
        {
            TRC_ERR((TB,_T("SH_CreateDirectory failed %s:%d"),
                     szDir, GetLastError()));
            //
            // Display error message to user
            //
#ifndef OS_WINCE
            TCHAR szMyDocsFolderName[MAX_PATH];
            if(_pShellUtil->SH_GetMyDocumentsDisplayName(
                            szMyDocsFolderName,
                            SIZECHAR(szMyDocsFolderName)))
            {
                TCHAR errCantCreateRDFolder[MAX_PATH];
                TCHAR szAppName[MAX_PATH];

                if(LoadString(_hInst,
                              UI_IDS_APP_NAME,
                              szAppName,
                              SIZECHAR(szAppName)))
                {
                    if (LoadString(_hInst,
                                   UI_IDS_ERR_CREATE_REMDESKS_FOLDER,
                                   errCantCreateRDFolder,
                                   SIZECHAR(errCantCreateRDFolder)))
                    {
                        TCHAR errFmtCantCreateRDFolder[MAX_PATH*3];
                        _stprintf(errFmtCantCreateRDFolder,
                                  errCantCreateRDFolder,
                                  szMyDocsFolderName,
                                  szDir);
                        MessageBox(NULL, errFmtCantCreateRDFolder,
                                   szAppName,
                                   MB_ICONERROR | MB_OK);
                    }
                }
            }
#endif

            //
            // This is an error but we'll handle it anyway
            // by loading defaults from a null store
            //
            return FALSE;
        }
    }
    else
    {
        //Guess we can't load from a file after all
        return FALSE;
    }

    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\validatedlg.cpp ===
//
// validatedlg.cpp: validation dialog
//

#include "stdafx.h"

#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "validatedlg"
#include <atrcapi.h>

#include "validatedlg.h"
#include "sh.h"

CValidateDlg* CValidateDlg::_pValidateDlgInstance = NULL;

CValidateDlg::CValidateDlg( HWND hwndOwner, HINSTANCE hInst, HWND hwndMain,
                            CSH* pSh) :
              CDlgBase( hwndOwner, hInst, UI_IDD_VALIDATE),
              _hwndMain(hwndMain),
              _pSh(pSh)
{
    DC_BEGIN_FN("CValidateDlg");
    TRC_ASSERT((NULL == CValidateDlg::_pValidateDlgInstance), 
               (TB,_T("Clobbering existing dlg instance pointer\n")));

    TRC_ASSERT(_pSh,
               (TB,_T("_pSh set to NULL")));


    CValidateDlg::_pValidateDlgInstance = this;
    DC_END_FN();
}

CValidateDlg::~CValidateDlg()
{
    CValidateDlg::_pValidateDlgInstance = NULL;
}

DCINT CValidateDlg::DoModal()
{
    DCINT retVal = 0;
    DC_BEGIN_FN("DoModal");

    retVal = DialogBox(_hInstance, MAKEINTRESOURCE(_dlgResId),
                       _hwndOwner, StaticDialogBoxProc);
    TRC_ASSERT((retVal != 0 && retVal != -1), (TB, _T("DialogBoxParam failed\n")));

    DC_END_FN();
    return retVal;
}

INT_PTR CALLBACK CValidateDlg::StaticDialogBoxProc (HWND hwndDlg, UINT uMsg,WPARAM wParam, LPARAM lParam)
{
    //
    // Delegate to appropriate instance (only works for single instance dialogs)
    //
    DC_BEGIN_FN("StaticDialogBoxProc");
    DCINT retVal = 0;

    TRC_ASSERT(_pValidateDlgInstance, (TB, _T("Validate dialog has NULL static instance ptr\n")));
    if(_pValidateDlgInstance)
    {
        retVal = _pValidateDlgInstance->DialogBoxProc( hwndDlg, uMsg, wParam, lParam);
    }

    DC_END_FN();
    return retVal;
}

/****************************************************************************/
/* Name: DialogBoxProc                                                      */
/*                                                                          */
/* Purpose: Handles Validate Box dialog                                        */
/*                                                                          */
/* Returns: TRUE if message dealt with                                      */
/*          FALSE otherwise                                                 */
/*                                                                          */
/* Params: See window documentation                                         */
/*                                                                          */
/****************************************************************************/
INT_PTR CALLBACK CValidateDlg::DialogBoxProc (HWND hwndDlg, UINT uMsg,WPARAM wParam, LPARAM lParam)
{
    INT_PTR rc = FALSE;
    DC_BEGIN_FN("UIValidateDialogProc");

    /************************************************************************/
    /* Handle dialog messages                                               */
    /************************************************************************/
    switch(uMsg)
    {
        case WM_INITDIALOG:
        {
            _hwndDlg = hwndDlg;
            /****************************************************************/
            /* Center the dialog                                            */
            /****************************************************************/
            if(hwndDlg)
            {
                CenterWindow(_hwndOwner);
                SetDialogAppIcon(hwndDlg);
            }

            rc = TRUE;
        }
        break;

        case WM_COMMAND:
        {
            switch(DC_GET_WM_COMMAND_ID(wParam))
            {
                case IDOK:
                {
                    if(hwndDlg)
                    {
                        EndDialog(hwndDlg, IDOK);
                    }

                    rc = TRUE;
                }
                break;

                case UI_ID_HELP:
                {
                    //
                    // Display help
                    //
                    if(_hwndMain)
                    {
                        _pSh->SH_DisplayClientHelp(
                            _hwndMain,
                            HH_DISPLAY_TOPIC);
                    }
                    rc = TRUE;
                }
                break;

                default:
                {
                    if(hwndDlg)
                    {
                        rc = CDlgBase::DialogBoxProc(hwndDlg,
                                                  uMsg,
                                                  wParam,
                                                  lParam);
                    }
                }
                break;
            }
        }
        break;

        default:
        {
            if(hwndDlg)
            {
                rc = CDlgBase::DialogBoxProc(hwndDlg,
                                          uMsg,
                                          wParam,
                                          lParam);
            }
        }
        break;
    }

    DC_END_FN();

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\validatedlg.h ===
//
// validatedlg.h: validation dialog
//

#ifndef _validatedlg_h_
#define _validatedlg_h_

#include "dlgbase.h"

class CSH;
class CValidateDlg : public CDlgBase
{
public:
    CValidateDlg(HWND hwndOwner, HINSTANCE hInst, HWND hwndMain, CSH* pSh);
    ~CValidateDlg();

    virtual DCINT   DoModal();
    virtual INT_PTR CALLBACK DialogBoxProc(HWND hwndDlg, UINT uMsg,WPARAM wParam, LPARAM lParam);
    static  INT_PTR CALLBACK StaticDialogBoxProc(HWND hwndDlg, UINT uMsg,WPARAM wParam, LPARAM lParam);

    static CValidateDlg* _pValidateDlgInstance;
private:
    HWND _hwndMain;
    CSH* _pSh;
};

#endif // _validatedlg_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\clshell\tscsetting.h ===
//
// tscsetting.h
//
// Terminal Services Client settings collection
//
// Copyright(C) Microsoft Corporation 2000
// Author: Nadim Abdo (nadima)
//

#ifndef _TSCSETTING_H_
#define _TSCSETTING_H_

#include "tscdefines.h"
#include "setstore.h"
#include "autreg.h"
#include "constr.h"

typedef struct tag_PERFOPTIONS_PERSISTINFO
{
    LPCTSTR szValName;
    BOOL    fDefaultVal;
    UINT    fFlagVal;
    BOOL    fForceSave; //true if should always be saved
} PERFOPTIONS_PERSISTINFO, *PPERFOPTIONS_PERSISTINFO;


class CTscSettings
{
public:
    //
    // Public members
    //
    CTscSettings();
    ~CTscSettings();

    VOID    InitializeToDefaults();
    BOOL    ValidateSettings();
    HRESULT LoadFromStore(ISettingsStore* pStore);
    HRESULT SaveToStore(ISettingsStore* pStore);
    HRESULT ApplyToControl(IMsRdpClient* pTsc);
    HRESULT GetUpdatesFromControl(IMsRdpClient* pTsc);
    BOOL    SaveRegSettings();

    BOOL    UpdateRegMRU(LPTSTR szNewServer);

    VOID    SetFileName(LPTSTR szFile);
    LPTSTR  GetFileName()                       {return _szFileName;}

    //
    // Accessors for the settings
    //
    LPCTSTR GetFirstMRUServer()                 {return _szMRUServer[0];}
    LPCTSTR GetMRUServer(INT idx)               {return _szMRUServer[idx];}

    VOID    SetAutoConnect(BOOL bAutoConnect)   {_fAutoConnectEnabled = bAutoConnect;}
    BOOL    GetAutoConnect()                    {return _fAutoConnectEnabled;}

    //
    // Connection string accessors
    //
    VOID
    SetConnectString(CRdpConnectionString& conStr)
    {
        _ConnectString = conStr;
    }
    VOID
    SetConnectString(LPTSTR szConnectString)
    {
        _ConnectString.SetFullConnectionString(szConnectString);
    }
    CRdpConnectionString&
    GetConnectString()                          {return _ConnectString;}
    LPTSTR
    GetFlatConnectString()
    {
        return _ConnectString.GetFullConnectionString();
    }

    //Can't use GetUserName as that conflicts with the
    //the uniwrap macro which will try to redefine the name
    //to a wrapper call.
    VOID    SetLogonUserName(LPCTSTR szUserName);
    LPCTSTR GetLogonUserName()                  {return _szUserName;}

    VOID    SetDomain(LPCTSTR szDomain);
    LPCTSTR GetDomain()                         {return _szDomain;}

    VOID    SetEnableStartProgram(BOOL b)       {_fEnableStartProgram = b;}
    BOOL    GetEnableStartProgram()             {return _fEnableStartProgram;}

    VOID    SetStartProgram(LPCTSTR szStartProg);
    LPTSTR  GetStartProgram()                   {return _szAlternateShell;}

    VOID    SetWorkDir(LPCTSTR szWorkDir);
    LPTSTR  GetWorkDir()                        {return _szWorkingDir;}

    VOID    StoreWindowPlacement(WINDOWPLACEMENT wp) {_windowPlacement = wp;}
    WINDOWPLACEMENT* GetWindowPlacement()       {return &_windowPlacement;}

    VOID    SetDesktopSizeID(UINT _desktopSizeID);
    UINT    GetDesktopSizeID()                  {return _desktopSizeID;}

    VOID    SetDesktopWidth(UINT wd)            {_desktopWidth = wd;}
    UINT    GetDesktopWidth()                   {return _desktopWidth;}
               
    VOID    SetDesktopHeight(UINT ht)           {_desktopHeight = ht;}
    UINT    GetDesktopHeight()                  {return _desktopHeight;}

    VOID    SetStartFullScreen(BOOL b)          {_fStartFullScreen = b;}
    BOOL    GetStartFullScreen()                {return _fStartFullScreen;}

    VOID    SetCompress(BOOL b)                 {_fCompress = b;}
    BOOL    GetCompress()                       {return _fCompress;}

    BOOL    GetAutoLogon()                      {return _fAutoLogon;}
    VOID    SetAutoLogon(BOOL b)                {_fAutoLogon = b;}

    BOOL    GetUIPasswordEdited()          {return _fUIPasswordEdited;}
    VOID    SetUIPasswordEdited(BOOL b)    {_fUIPasswordEdited = b;}

    HRESULT SetClearTextPass(LPCTSTR szClearPass);
    HRESULT GetClearTextPass(LPTSTR szBuffer, INT cbLen);

    VOID    SetSavePassword(BOOL b)             {_fSavePassword = b;}
    BOOL    GetSavePassword()                   {return _fSavePassword;}

    BOOL    GetPasswordProvided();

    INT     GetColorDepth()                     {return _colorDepthBpp;}
    VOID    SetColorDepth(INT bpp)              {_colorDepthBpp = bpp;}

    INT     GetKeyboardHookMode();
    VOID    SetKeyboardHookMode(INT hookmode);

    INT     GetSoundRedirectionMode();
    VOID    SetSoundRedirectionMode(INT soundMode);

    BOOL    GetSmoothScrolling()                {return _smoothScrolling;}
    VOID    SetSmoothScrolling(BOOL b)          {_smoothScrolling = b;}

#ifdef SMART_SIZING
    BOOL    GetSmartSizing()                    {return _smartSizing;}
    VOID    SetSmartSizing(BOOL b)              {_smartSizing = b;}
#endif // SMART_SIZING

    BOOL    GetAcceleratorPassthrough()         {return _acceleratorPassthrough;}
    VOID    SetAcceleratorPassthrough(BOOL b)   {_acceleratorPassthrough = b;}

    BOOL    GetShadowBitmapEnabled()            {return _shadowBitmapEnabled;}
    VOID    SetShadowBitmapEnabled(BOOL b)      {_shadowBitmapEnabled=b;}

    UINT    GetTransportType()                  {return _transportType;}
    VOID    SetTransportType(UINT tt)           {_transportType=tt;}

    UINT    GetSasSequence()                    {return _sasSequence;}
    VOID    SetSasSequence(UINT ss)             {_sasSequence=ss;}

    BOOL    GetEncryptionEnabled()              {return _encryptionEnabled;}
    VOID    SetEncryptionEnabled(BOOL b)        {_encryptionEnabled=b;}

    BOOL    GetDedicatedTerminal()              {return _dedicatedTerminal;}
    VOID    SetDedicatedTerminal(BOOL b)        {_dedicatedTerminal=b;}

    UINT    GetMCSPort()                        {return _MCSPort;}
    VOID    SetMCSPort(UINT mcsport)            {_MCSPort=mcsport;}

    BOOL    GetEnableMouse()                    {return _fEnableMouse;}
    VOID    SetEnableMouse(BOOL b)              {_fEnableMouse=b;}

    BOOL    GetBitmapPersitenceFromPerfFlags()
    {
        BOOL fBitmapPersistence = 
           (_dwPerfFlags & TS_PERF_DISABLE_BITMAPCACHING) ? FALSE : TRUE;
        return fBitmapPersistence;
    }

    BOOL    GetDisableCtrlAltDel()              {return _fDisableCtrlAltDel;}
    VOID    SetDisableCtrlAltDel(BOOL b)        {_fDisableCtrlAltDel=b;}

    BOOL    GetEnableWindowsKey()               {return _fEnableWindowsKey;}
    VOID    SetEnableWindowsKey(BOOL b)         {_fEnableWindowsKey=b;}

    BOOL    GetDoubleClickDetect()              {return _fDoubleClickDetect;}
    VOID    SetDoubleClickDetect(BOOL b)        {_fDoubleClickDetect=b;}

    BOOL    GetMaximizeShell()                  {return _fMaximizeShell;}
    VOID    SetMaximizeShell(BOOL b)            {_fMaximizeShell = b;}

    BOOL    GetDriveRedirection()               {return _fDriveRedirectionEnabled;}
    VOID    SetDriveRedirection(BOOL b)         {_fDriveRedirectionEnabled = b;}

    BOOL    GetPrinterRedirection()             {return _fPrinterRedirectionEnabled;}
    VOID    SetPrinterRedirection(BOOL b)       {_fPrinterRedirectionEnabled = b;}

    BOOL    GetCOMPortRedirection()             {return _fPortRedirectionEnabled;}
    VOID    SetCOMPortRedirection(BOOL b)       {_fPortRedirectionEnabled = b;}

    BOOL    GetSCardRedirection()               {return _fSCardRedirectionEnabled;}
    VOID    SetSCardRedirection(BOOL b)         {_fSCardRedirectionEnabled = b;}

    BOOL    GetConnectToConsole()               {return _fConnectToConsole;}
    VOID    SetConnectToConsole(BOOL b)         {_fConnectToConsole=b;}

    BOOL    GetDisplayBBar()                    {return _fDisplayBBar;}
    VOID    SetDisplayBBar(BOOL b)              {_fDisplayBBar = b;}

    BOOL    GetPinBBar()                        {return _fPinBBar;}
    VOID    SetPinBBar(BOOL b)                  {_fPinBBar = b;}

#ifdef PROXY_SERVER 
    VOID    SetProxyServer(LPCTSTR szProxyServer);
    LPCTSTR GetProxyServer()                    {return _szProxyServer;}
#endif //PROXY_SERVER 

    DWORD   GetPerfFlags()                      {return _dwPerfFlags;}
    VOID    SetPerfFlags(DWORD dw)              {_dwPerfFlags = dw;}

    BOOL    GetEnableArc()                      {return _fEnableAutoReconnect;}
    VOID    SetEnableArc(BOOL b)                {_fEnableAutoReconnect = b;}


private:
    BOOL    GetPluginDllList();
    BOOL    ReadPassword(ISettingsStore* pSto);
    BOOL    ReadPerfOptions(ISettingsStore* pStore);
    BOOL    WritePerfOptions(ISettingsStore* pStore);
    HRESULT
    ApplyConnectionArgumentSettings(
                    IN LPCTSTR szConArg,
                    IN IMsRdpClientAdvancedSettings2* pAdvSettings
                    );

    //
    // keep track of last filename this
    // was opened/saved from.
    //
    TCHAR    _szFileName[MAX_PATH];
    //
    // Settings data members
    //
    BOOL     _fCompress;
    BOOL     _fAutoLogon;
    BOOL     _fAutoConnectEnabled;
    BOOL     _fStartFullScreen;
    BOOL     _fbrowseDNSDomain;
    TCHAR    _browseDNSDomainName[TSC_MAX_DOMAIN_LENGTH];
    WINDOWPLACEMENT _windowPlacement;
    
    CRdpConnectionString _ConnectString;
    TCHAR    _szUserName[TSC_MAX_USERNAME_LENGTH];
    TCHAR    _szDomain[TSC_MAX_DOMAIN_LENGTH];
    BOOL     _fEnableStartProgram;
    TCHAR    _szAlternateShell[TSC_MAX_ALTERNATESHELL_LENGTH];
    TCHAR    _szWorkingDir[TSC_MAX_WORKINGDIR_LENGTH];
    BYTE     _Password[TSC_MAX_PASSWORD_LENGTH_BYTES];
    BOOL     _fSavePassword;
    BOOL     _fPasswordProvided;
    BYTE     _Salt[TSC_SALT_LENGTH];

    UINT     _desktopSizeID;
    UINT     _desktopWidth;
    UINT     _desktopHeight;
    TCHAR    _szMRUServer[TSC_NUM_SERVER_MRU][TSC_MAX_ADDRESS_LENGTH];
    TCHAR    _szCLXCmdLine[MAX_PATH];
    
    //
    // User provided a password in the UI
    //
    BOOL     _fUIPasswordEdited;

    DATA_BLOB  _blobEncryptedPassword;
    TCHAR    _szClearPass[TSC_MAX_PASSLENGTH_TCHARS];
    DCTCHAR  _szIconFile[MAX_PATH];
    UINT     _iconIndex;
    INT      _colorDepthBpp;
    UINT     _keyboardHookMode;
    INT      _soundRedirectionMode;
    BOOL     _smoothScrolling;
#ifdef SMART_SIZING
    BOOL     _smartSizing;
#endif // SMART_SIZING
    BOOL     _acceleratorPassthrough;
    BOOL     _shadowBitmapEnabled;
    UINT     _transportType;
    UINT     _sasSequence;
    BOOL     _encryptionEnabled;
    BOOL     _dedicatedTerminal;
    UINT     _MCSPort;
    BOOL     _fEnableMouse;
    BOOL     _fDisableCtrlAltDel;
    BOOL     _fEnableWindowsKey;
    BOOL     _fDoubleClickDetect;
    BOOL     _fMaximizeShell;

    UINT     _RegBitmapCacheSize;
    UINT     _drawThreshold;
    UINT     _BitmapVirtualCache8BppSize;
    UINT     _BitmapVirtualCache16BppSize;
    UINT     _BitmapVirtualCache24BppSize;
    UINT     _RegScaleBitmapCachesByBPP;
    UINT     _RegNumBitmapCaches;

    UINT     _RegBCProportion[TS_BITMAPCACHE_MAX_CELL_CACHES];
    UINT     _RegBCMaxEntries[TS_BITMAPCACHE_MAX_CELL_CACHES];
    UINT     _bSendBitmapKeys[TS_BITMAPCACHE_MAX_CELL_CACHES];
    UINT     _GlyphSupportLevel;
    UINT     _GlyphCacheSize[10];
    UINT     _fragCellSize;
    UINT     _brushSupportLevel;
    
    UINT     _maxInputEventCount;
    UINT     _eventsAtOnce;
    UINT     _minSendInterval;
    UINT     _keepAliveIntervalMS;
    TCHAR    _szKeybLayoutStr[UTREG_UI_KEYBOARD_LAYOUT_LEN];

    UINT     _shutdownTimeout;
    UINT     _connectionTimeout;
    UINT     _singleConTimeout;

#ifdef OS_WINCE
    //
    // WinCE only keyboard settings
    //
    UINT     _keyboardType;
    UINT     _keyboardSubType;
    UINT     _keyboardFunctionKey;
#endif

#ifdef DC_DEBUG
    BOOL     _hatchBitmapPDUData;
    BOOL     _hatchSSBOrderData;
    BOOL     _hatchIndexPDUData;
    BOOL     _hatchMemBltOrderData;
    BOOL     _labelMemBltOrders;
    BOOL     _bitmapCacheMonitor;
#endif

    BOOL _fDriveRedirectionEnabled;
    BOOL _fPrinterRedirectionEnabled;
    BOOL _fPortRedirectionEnabled;
    BOOL _fSCardRedirectionEnabled;

    TCHAR    _szPluginList[MAX_PATH*10];
    BOOL     _fConnectToConsole;
    BOOL     _fDisplayBBar;
    BOOL     _fPinBBar;

#ifdef PROXY_SERVER	
    TCHAR    _szProxyServer[TSC_MAX_ADDRESS_LENGTH];
#endif //PROXY_SERVER 
    DWORD    _dwPerfFlags;

    BOOL     _fEnableAutoReconnect;
    UINT     _nArcMaxRetries;
};

#endif  //_TSCSETTING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\aco.cpp ===
/****************************************************************************/
// aco.cpp
//
// Core class.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <adcg.h>

#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "aco"
#define TSC_HR_FILEID TSC_HR_ACO_CPP

#include <atrcapi.h>
#include "aco.h"

// Order important

#include "wui.h"
#include "cd.h"

#include "cc.h"
#include "snd.h"
#include "ih.h"
#include "uh.h"
#include "sl.h"
#include "op.h"

#include "rcv.h"
#include "cm.h"

#include "sp.h"
#include "or.h"

#include "autil.h"

#ifdef OS_WINCE
#include <ceconfig.h>
#endif

extern "C"
VOID WINAPI CO_StaticInit(HINSTANCE hInstance)
{
    CIH::IH_StaticInit(hInstance);
}

extern "C"
VOID WINAPI CO_StaticTerm()
{
    CIH::IH_StaticTerm();
}

CCO::CCO(CObjs* objs)
{
    _pClientObjects = objs;
    _fCOInitComplete = FALSE;
}

CCO::~CCO()
{
}

//
// API functions
//

/****************************************************************************/
/* Name:      CO_Init                                                       */
/*                                                                          */
/* Purpose:   Core Initialization                                           */
/*                                                                          */
/* Params:    IN  hInstance     - the instance handle                       */
/*            IN  hwndMain      - the handle of the main window             */
/*            IN  hwndContainer - the handle of the container window        */
/****************************************************************************/
void DCAPI CCO::CO_Init(HINSTANCE hInstance, HWND hwndMain, HWND hwndContainer)
{
    DC_BEGIN_FN("CO_Init");

    TRC_ASSERT(_pClientObjects, (TB,_T("_pClientObjects is NULL")));
    _pClientObjects->AddObjReference(CO_OBJECT_FLAG);

    //Setup local object pointers
    _pUt  = _pClientObjects->_pUtObject;
    _pUi  = _pClientObjects->_pUiObject;
    _pSl  = _pClientObjects->_pSlObject;
    _pUh  = _pClientObjects->_pUHObject;
    _pRcv = _pClientObjects->_pRcvObject;
    _pCd  = _pClientObjects->_pCdObject;
    _pSnd = _pClientObjects->_pSndObject;
    _pCc  = _pClientObjects->_pCcObject;
    _pIh  = _pClientObjects->_pIhObject;
    _pOr  = _pClientObjects->_pOrObject;
    _pSp  = _pClientObjects->_pSPObject;
    _pOp  = _pClientObjects->_pOPObject;
    _pCm  = _pClientObjects->_pCMObject;
    _pClx = _pClientObjects->_pCLXObject;

    DC_MEMSET(&_CO, 0, sizeof(_CO));

    memset(m_disconnectHRs, 0, sizeof(m_disconnectHRs));
    m_disconnectHRIndex = 0;
    /************************************************************************/
    /* Set UT instance handle                                               */
    /************************************************************************/
    TRC_NRM((TB, _T("CO setting Instance handle in UT to %p"), hInstance));
    _pUi->UI_SetInstanceHandle(hInstance);
    _pUt->UT_SetInstanceHandle(hInstance);

    /************************************************************************/
    /* Set UT Main Window handle.                                           */
    /************************************************************************/
    TRC_NRM((TB, _T("CO setting Main Window handle in UT to %p"), hwndMain));
    _pUi->UI_SetUIMainWindow(hwndMain);

    /************************************************************************/
    /* Set UT Container Window handle.                                      */
    /************************************************************************/
    TRC_NRM((TB, _T("CO setting Container Window handle in UT to %p"),
                                                              hwndContainer));
    _pUi->UI_SetUIContainerWindow(hwndContainer);

    //
    // Initialize the component decoupler and register the UI (as we are
    // running on the UI thread here).  CD_Init must be called after
    // setting UT.hInstance.
    //
    _pCd->CD_Init();
    _pCd->CD_RegisterComponent(CD_UI_COMPONENT);

    COSubclassUIWindows();

    // Start the sender thread
    _pUt->UT_StartThread(CSND::SND_StaticMain, &_CO.sendThreadID, _pSnd);
    _fCOInitComplete = TRUE;

    DC_END_FN();
} /* CO_Init */


/****************************************************************************/
/* Name:      CO_Term                                                       */
/*                                                                          */
/* Purpose:   Core Termination                                              */
/****************************************************************************/
void DCAPI CCO::CO_Term()
{
    DC_BEGIN_FN("CO_Term");

    if(_fCOInitComplete)
    {
        // Deregister from the component decoupler
        _pCd->CD_UnregisterComponent(CD_UI_COMPONENT);

#ifdef OS_WIN32
        // We're on Win32 so terminate the Sender Thread.
        // We're called on the UI thread so PUMP messages while
        // waiting for the thread to get destroyed
        //
        
        //
        // Pump messages while waiting since this is the UI thread
        //
        _pUt->UT_DestroyThread(_CO.sendThreadID, TRUE);
#else
        // We're on Win16 so just call SND_Term directly.
        SND_Term();
#endif
    
        _pCd->CD_Term();
    
        _pClientObjects->ReleaseObjReference(CO_OBJECT_FLAG);
    }
    else
    {
        TRC_DBG((TB,_T("Skipping CO_Term because _fCOInitComplete is false")));
    }

    DC_END_FN();
} /* CO_Term */


/****************************************************************************/
/* Name:      CO_Connect                                                    */
/*                                                                          */
/* Purpose:   Connect to an RNS                                             */
/*                                                                          */
/* Params:    IN  pConnectStruct - connection information                   */
/****************************************************************************/
void DCAPI CCO::CO_Connect(PCONNECTSTRUCT pConnectStruct)
{
    DC_BEGIN_FN("CO_Connect");

    /************************************************************************/
    /* Check that the core is initialized.                                  */
    /************************************************************************/
    TRC_ASSERT((_pUi->UI_IsCoreInitialized()), (TB, _T("Core not initialized")));

    /************************************************************************/
    /* Call CC with a Connect event                                         */
    /************************************************************************/
    _pCd->CD_DecoupleNotification(CD_SND_COMPONENT,
            _pCc,
            CD_NOTIFICATION_FUNC(CCC,CC_Connect),
            pConnectStruct,
            sizeof(CONNECTSTRUCT));

    DC_END_FN();
} /* CO_Connect */


/****************************************************************************/
/* Name:      CO_Disconnect                                                 */
/*                                                                          */
/* Purpose:   Disconnect                                                    */
/*                                                                          */
/* Operation: call the Call Controller FSM                                  */
/****************************************************************************/
void DCAPI CCO::CO_Disconnect(void)
{
    DC_BEGIN_FN("CO_Disconnect");

    // Check that the core is initialized.
    TRC_ASSERT((_pUi->UI_IsCoreInitialized()), (TB, _T("Core not initialized")));

    // Call CC with a Disconnect event.
    _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, _pCc,
            CD_NOTIFICATION_FUNC(CCC,CC_Event),
            (ULONG_PTR) CC_EVT_API_DISCONNECT);

    DC_END_FN();
} /* CO_Disconnect */


/****************************************************************************/
/* Name:      CO_Shutdown                                                   */
/*                                                                          */
/* Purpose:   Shutdown the client                                           */
/*                                                                          */
/* Params:    IN  shutdownCode - what kind of shutdown is required.         */
/*                                                                          */
/* Operation: call the Call Controller FSM                                  */
/****************************************************************************/
void DCAPI CCO::CO_Shutdown(unsigned shutdownCode)
{
    DC_BEGIN_FN("CO_Shutdown");

    //Prevent race by ensuring CO init is complete
    if(_fCOInitComplete)
    {
        
        // Check that the core is initialized.
        
        if (!_pUi->UI_IsCoreInitialized())
        {
            //
            // Trace and then fake-up a call to UI_OnShutdown to pretend to the
            // UI that the shutdown completed successfully.
            //
            TRC_NRM((TB,_T("Core NOT initialized")));
            _pUi->UI_OnShutDown(UI_SHUTDOWN_SUCCESS);
            DC_QUIT;
        }
    
        switch (shutdownCode)
        {
            case CO_DISCONNECT_AND_EXIT:
            {
                TRC_DBG((TB, _T("Shutdown type: disconnect and exit")));
                // Call CC with a Shutdown event
                _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT,
                                              _pCc,
                                              CD_NOTIFICATION_FUNC(CCC,CC_Event),
                                              (ULONG_PTR) CC_EVT_API_DISCONNECTANDEXIT);
            }
            break;
    
            case CO_SHUTDOWN:
            {
                TRC_DBG((TB, _T("Shutdown type: shutdown")));
    
                // Call CC with a Shutdown event
                _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT,
                                              _pCc,
                                              CD_NOTIFICATION_FUNC(CCC,CC_Event),
                                              (ULONG_PTR) CC_EVT_API_SHUTDOWN);
            }
            break;
    
            default:
            {
                TRC_ABORT((TB, _T("Illegal shutdown code")));
            }
            break;
        }
    }

DC_EXIT_POINT:
    DC_END_FN();
} /* CO_Shutdown */


/****************************************************************************/
/* Name:      CO_OnSaveSessionInfoPDU                                       */
/*                                                                          */
/* Purpose:   Process Save Session PDU                                      */
/*                                                                          */
/* Params:    pInfoPDU - Ptr to PTS_SAVE_SESSION_INFO_PDU                   */
/****************************************************************************/
// SECURITY - the size of the packet has been checked only to be sure there is
//  enough data to read the PTS_SAVE_SESSION_INFO_PDU_DATA.InfoType field
HRESULT DCAPI CCO::CO_OnSaveSessionInfoPDU(
        PTS_SAVE_SESSION_INFO_PDU_DATA pInfoPDU,
        DCUINT dataLength)
{
    HRESULT hr = S_OK;
    UINT32 sessionId;
    TSUINT8  UserNameGot[TS_MAX_USERNAME_LENGTH];
    TSUINT8  DomainNameGot[TS_MAX_DOMAIN_LENGTH];
    TSUINT32 DomainLength, UserNameLength; 
    TSUINT16 VersionGot; 
    DCUINT  packetSize;

    DC_BEGIN_FN("CO_OnSaveSessionInfoPDU");

    switch (pInfoPDU->InfoType) {
        case TS_INFOTYPE_LOGON:
        {
            TRC_NRM((TB, _T("Logon PDU")));

            packetSize = FIELDOFFSET(TS_SAVE_SESSION_INFO_PDU_DATA, Info) + 
                sizeof(TS_LOGON_INFO);
            if (packetSize >= dataLength)
                sessionId = pInfoPDU->Info.LogonInfo.SessionId;
            else if (packetSize - FIELDSIZE(TS_LOGON_INFO, SessionId) >= 
                dataLength) {
                // NT4 servers did not send the session ID so default to zero
                // if there is no data.
                sessionId = 0;
            }
            else {
                TRC_ABORT((TB,_T("bad TS_SAVE_SESSION_INFO_PDU_DATA; size %u"),
                    dataLength ));
                hr = E_TSC_CORE_LENGTH;
                DC_QUIT;
            }

            TRC_ALT((TB, _T("Session ID is: %ld"), sessionId));

            if (pInfoPDU->Info.LogonInfo.cbDomain > TS_MAX_DOMAIN_LENGTH_OLD ||
                pInfoPDU->Info.LogonInfo.cbUserName > TS_MAX_USERNAME_LENGTH ) {
                TRC_ABORT(( TB, _T("Invalid TS_INFOTYPE_LOGON; cbDomain %u ")
                    _T("cbUserName %u"),
                    pInfoPDU->Info.LogonInfo.cbDomain, 
                    pInfoPDU->Info.LogonInfo.cbUserName));
                hr = E_TSC_CORE_LENGTH;
                DC_QUIT;
            }

            _pUi->UI_UpdateSessionInfo((PDCWCHAR)(pInfoPDU->Info.LogonInfo.Domain),
                                 (DCUINT)  (pInfoPDU->Info.LogonInfo.cbDomain),
                                 (PDCWCHAR)(pInfoPDU->Info.LogonInfo.UserName),
                                 (DCUINT)  (pInfoPDU->Info.LogonInfo.cbUserName),
                                 sessionId);
        }
        break;

        case TS_INFOTYPE_LOGON_LONG:
        {
            TRC_NRM((TB, _T("Logon PDU")));

            VersionGot = pInfoPDU->Info.LogonInfoVersionTwo.Version ; 
            DomainLength = pInfoPDU->Info.LogonInfoVersionTwo.cbDomain ;
            UserNameLength = pInfoPDU->Info.LogonInfoVersionTwo.cbUserName ; 

            if ((FIELDOFFSET( TS_SAVE_SESSION_INFO_PDU_DATA, Info) + 
                sizeof(TS_LOGON_INFO_VERSION_2) + DomainLength + UserNameLength
                > dataLength) ||
                (DomainLength > TS_MAX_DOMAIN_LENGTH) ||
                (UserNameLength > TS_MAX_USERNAME_LENGTH))
            {
                TRC_ABORT(( TB, _T("Invalid TS_INFOTYPE_LOGON_LONG; cbDomain ")
                    _T("%u cbUserName %u"), DomainLength, UserNameLength));
                hr = E_TSC_CORE_LENGTH;
                DC_QUIT;               
            }

            // Get the sessionId
            sessionId = pInfoPDU->Info.LogonInfoVersionTwo.SessionId;
            
            TRC_ALT((TB, _T("Session ID is: %ld"), sessionId));

            // Parse out the Domain and UserName from the pInfoPDU
            memset( DomainNameGot, 0, TS_MAX_DOMAIN_LENGTH);
            memset( UserNameGot, 0, TS_MAX_USERNAME_LENGTH);

            memcpy( DomainNameGot,
                    (PBYTE)(pInfoPDU + 1),
                    DomainLength) ; 

            memcpy(UserNameGot,
                   (PBYTE)(pInfoPDU + 1) + DomainLength, 
                   UserNameLength) ; 

            _pUi->UI_UpdateSessionInfo((PDCWCHAR)(DomainNameGot),
                                 (DCUINT)  (DomainLength),
                                 (PDCWCHAR)(UserNameGot),
                                 (DCUINT)  (UserNameLength),
                                 sessionId);
        }
        break;

        case TS_INFOTYPE_LOGON_PLAINNOTIFY:
        {
            //Notify of login event
            _pUi->UI_OnLoginComplete();
        }
        break;

        case TS_INFOTYPE_LOGON_EXTENDED_INFO:
        {
            TRC_NRM((TB,_T("Received TS_INFOTYPE_LOGON_EXTENDED_INFO")));
            TS_LOGON_INFO_EXTENDED UNALIGNED* pLogonInfoExPkt =
                (TS_LOGON_INFO_EXTENDED UNALIGNED*)&pInfoPDU->Info.LogonInfoEx;

            if (FIELDOFFSET(TS_SAVE_SESSION_INFO_PDU_DATA, Info) +
                pLogonInfoExPkt->Length > dataLength) {
                TRC_ABORT(( TB, _T("Invalid TS_INFOTYPE_LOGON_EXTENDED_INFO")
                    _T("[expected %u got %u]"),
                    sizeof(TS_SAVE_SESSION_INFO_PDU_DATA) - 
                    FIELDSIZE(TS_SAVE_SESSION_INFO_PDU_DATA, Info) +
                    pLogonInfoExPkt->Length, dataLength));
                hr = E_TSC_CORE_LENGTH;
                DC_QUIT;                    
            }

            PBYTE pBuf = (PBYTE)(pLogonInfoExPkt + 1);
            if (pLogonInfoExPkt &&
                pLogonInfoExPkt->Flags & LOGON_EX_AUTORECONNECTCOOKIE)
            {
                //
                // Autoreconnect cookie is present
                //
                ULONG cbAutoReconnectSize = *((ULONG UNALIGNED *)(pBuf));
                PBYTE pAutoReconnectCookie = (PBYTE)(pBuf) + sizeof(ULONG);
                pBuf += cbAutoReconnectSize + sizeof(ULONG);

                if (cbAutoReconnectSize > TS_MAX_AUTORECONNECT_LEN) {
                    TRC_ABORT(( TB, _T("TS_INFOTYPE_LOGON_EXTENDED_INFO")
                        _T("autoreconnect wrong size; [got %u]"), 
                        cbAutoReconnectSize));
                    hr = E_TSC_CORE_LENGTH;
                    DC_QUIT; 
                }
                
                CHECK_READ_N_BYTES( pAutoReconnectCookie, (PBYTE)pInfoPDU + dataLength,
                    cbAutoReconnectSize, hr, 
                    (TB,_T("TS_INFOTYPE_LOGON_EXTENDED_INFO")
                        _T("autoreconnect wrong size; [got %u]"), 
                        cbAutoReconnectSize));
                

                TRC_ALT((TB,_T("Received autoreconnect cookie - size: %d"),
                         cbAutoReconnectSize));
                //
                // Store the autoreconnect cookie. It will be used
                // if we get disconnected unexpectedly to allow a
                // fast reconnect to the server.
                //
                _pUi->UI_SetAutoReconnectCookie(pAutoReconnectCookie,
                                                cbAutoReconnectSize);
            }
        }
        break;

        default:
        {
            TRC_ERR((TB, _T("Unexpected Save Session Info PDU type: %u"),
                    (DCUINT)pInfoPDU->InfoType));
        }
        break;
    }
DC_EXIT_POINT:
    DC_END_FN();

    return hr;
} /* CO_OnSaveSessionInfoPDU */


/****************************************************************************/
/* Name:      CO_OnSetKeyboardIndicatorsPDU                                 */
/*                                                                          */
/* Purpose:   Process the TS_SET_KEYBOARD_INDICATORS_PDU                    */
/*                                                                          */
/* Params:    pKeyPDU - Ptr to TS_SET_KEYBOARD_INDICATORS_PDU               */
/****************************************************************************/
HRESULT DCAPI CCO::CO_OnSetKeyboardIndicatorsPDU(
        PTS_SET_KEYBOARD_INDICATORS_PDU pKeyPDU, DCUINT dataLen)
{
    DC_BEGIN_FN("CO_OnSetKeyboardIndicatorsPDU");

    DC_IGNORE_PARAMETER(dataLen);

    _pIh->IH_UpdateKeyboardIndicators(pKeyPDU->UnitId, pKeyPDU->LedFlags);

    DC_END_FN();
    return S_OK;
} /* CO_OnSetKeyboardIndicatorsPDU */


/****************************************************************************/
/* Name:      CO_SetConfigurationValue                                      */
/*                                                                          */
/* Purpose:   Sets a given configuration setting to a given value           */
/*                                                                          */
/* Params:    configItem - the configuration item to change                 */
/*            configValue - the new value of the configuration item         */
/*            (see acoapi.h for valid values)                               */
/****************************************************************************/
void DCAPI CCO::CO_SetConfigurationValue(
        unsigned configItem,
        unsigned configValue)
{
    DC_BEGIN_FN("CO_SetConfigurationValue");

    TRC_ASSERT((_pUi->UI_IsCoreInitialized()), (TB, _T("Core not initialized")));

    switch (configItem) {
        case CO_CFG_ACCELERATOR_PASSTHROUGH:
        {
            _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT,
                    _pIh,
                    CD_NOTIFICATION_FUNC(CIH,IH_SetAcceleratorPassthrough),
                    (ULONG_PTR) configValue);
        }
        break;

        case CO_CFG_ENCRYPTION:
        {
            _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT,
                                                _pSl,
                                                CD_NOTIFICATION_FUNC(CSL,SL_EnableEncryption),
                                                (ULONG_PTR) configValue);
        }
        break;

#ifdef DC_DEBUG
        case CO_CFG_DEBUG_SETTINGS:
        {
            _pCd->CD_DecoupleSimpleNotification(CD_RCV_COMPONENT,
                                                _pUh,
                                                CD_NOTIFICATION_FUNC(CUH,UH_ChangeDebugSettings),
                                                (ULONG_PTR) configValue);
        }
        break;
#endif /* DC_DEBUG */

        default:
        {
            TRC_ABORT((TB, _T("Invalid configItem: %u"), configItem));
        }
        break;
    }

    DC_END_FN();
} /* CO_SetConfigurationValue */


/****************************************************************************/
/* Name:      CO_SetHotkey                                                  */
/*                                                                          */
/* Purpose:   call the function with the given data                         */
/****************************************************************************/
void DCAPI CCO::CO_SetHotkey(PDCHOTKEY pHotkey)
{
    _pCd->CD_DecoupleNotification(CD_SND_COMPONENT,
            _pIh,
            CD_NOTIFICATION_FUNC(CIH,IH_SetHotkey),
            &pHotkey,
            sizeof(PDCHOTKEY));
}

#ifdef DC_DEBUG
/****************************************************************************/
/* Name:      CO_GetRandomFailureItem                                       */
/*                                                                          */
/* Purpose:   Simple wrapper to _pUt->UT_GetRandomFailureItem               */
/*                                                                          */
/* Returns:   % times item currently fails                                  */
/*                                                                          */
/* Params:    ItemID - IN - requested item                                  */
/****************************************************************************/
int DCAPI CCO::CO_GetRandomFailureItem(unsigned itemID)
{
    DC_BEGIN_FN("CO_GetRandomFailureItem");

    DC_END_FN();
    return _pUt->UT_GetRandomFailureItem(itemID);
} /* CO_GetRandomFailureItem */


/****************************************************************************/
/* Name:      CO_SetRandomFailureItem                                       */
/*                                                                          */
/* Purpose:   Simple wrapper for _pUi->UI_SetRandomFailureItem              */
/*                                                                          */
/* Params:    See _pUi->UI_SetRandomFailureItem                             */
/****************************************************************************/
void DCAPI CCO::CO_SetRandomFailureItem(unsigned itemID, int percent)
{
    DC_BEGIN_FN("CO_SetRandomFailureItem");

    _pUt->UT_SetRandomFailureItem(itemID, percent);

    DC_END_FN();
} /* CO_SetRandomFailureItem */

#endif /* DC_DEBUG */


/****************************************************************************/
/* Name:      COContainerWindowSubclassProc                                 */
/*                                                                          */
/* Purpose:   Subclass procedure for the UI Container Window                */
/****************************************************************************/
LRESULT CALLBACK CCO::COContainerWindowSubclassProc( HWND hwnd,
                                                UINT message,
                                                WPARAM wParam,
                                                LPARAM lParam )
{
    LRESULT  rc = 0;
    POINT    newPos;

    DC_BEGIN_FN("COContainerWindowSubclassProc");

    switch (message)
    {
        case WM_SETFOCUS:
        {
            //
            // Note, the code here used to use CallWindowProc.
            // this has been changed to use a direct call.
            // If there is ever a need for Unicode/ANSI conversions
            // then change the direct calls to the window proc
            // to use CallWindowProc
            //
            rc =_pUi->UIContainerWndProc( hwnd, message, wParam, lParam);

            if (rc) {
                SetFocus(_pIh->IH_GetInputHandlerWindow());
            }
        }
        break;

        case WM_MOVE:
        {
            /****************************************************************/
            /* Tell IH about the new window position.                       */
            /* Take care with sign extension here.                          */
            /****************************************************************/
            newPos.x = (DCINT)((DCINT16)LOWORD(lParam));
            newPos.y = (DCINT)((DCINT16)HIWORD(lParam));
            TRC_DBG((TB, _T("Move to %d,%d"), newPos.x, newPos.y));

            _pCd->CD_DecoupleNotification(CD_SND_COMPONENT,
                                          _pIh,
                                          CD_NOTIFICATION_FUNC(CIH,IH_SetVisiblePos),
                                          &newPos,
                                          sizeof(newPos));
            rc = _pUi->UIContainerWndProc( hwnd, message, wParam, lParam);
        }
        break;

        default:
        {
            rc =_pUi->UIContainerWndProc( hwnd, message, wParam, lParam);
        }
        break;
    }

    DC_END_FN();
    return rc;
} /* COContainerWindowSubclassProc */


/****************************************************************************/
/* Name:      COMainFrameWindowSubclassProc                                 */
/*                                                                          */
/* Purpose:   Subclass procedure for the UI Main Frame Window               */
/****************************************************************************/
LRESULT CALLBACK CCO::COMainWindowSubclassProc( HWND hwnd,
                                           UINT message,
                                           WPARAM wParam,
                                           LPARAM lParam )
{
    LRESULT  rc = 0;
    DCSIZE   newSize;

    DC_BEGIN_FN("COMainWindowSubclassProc");

    switch (message) {
        case WM_SIZE:
        {
            /****************************************************************/
            /* Tell IH about the new window size.                           */
            /* Take care with sign extension here.                          */
            /****************************************************************/
            newSize.width =  (DCINT)((DCINT16)LOWORD(lParam));
            newSize.height = (DCINT)((DCINT16)HIWORD(lParam));
            TRC_DBG((TB, _T("Size now %d,%d"), newSize.width, newSize.height));

            switch (wParam)
            {
                case SIZE_MINIMIZED:
                case SIZE_MAXIMIZED:
                case SIZE_RESTORED:
                {
                    WPARAM newWindowState = wParam;
                    //
                    // This is slightly hack-erific.
                    // because we're now an ActiveX nested child window
                    // we don't get a WM_MINIMIZED. But on minimize
                    // the size becomes 0,0 so fake it.
                    //
                    if(!newSize.width && !newSize.height)
                    {
                        newWindowState = SIZE_MINIMIZED;
                    }
                    /********************************************************/
                    /* OR interested in these to maybe send                 */
                    /* SuppressOutputPDU                                    */
                    /********************************************************/
                    _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT,
                            _pOr,
                            CD_NOTIFICATION_FUNC(COR,OR_SetSuppressOutput),
                            (UINT) newWindowState);
                }
                break;

                default:
                {
                    /********************************************************/
                    /* OR not interested in these - do nothing              */
                    /********************************************************/
                }
                break;
            }

            rc =_pUi->UIMainWndProc( hwnd, message, wParam, lParam);
        }
        break;

        case WM_PALETTECHANGED:
        {
            TRC_NRM((TB, _T("WM_PALETTECHANGED")));
            /****************************************************************/
            /* Note that we are calling this function (which should         */
            /* logically be called on the receive thread) on the UI thread. */
            /* See comment in function description.                         */
            /****************************************************************/
            _pOp->OP_PaletteChanged(hwnd, (HWND)wParam);
        }
        break;

        case WM_QUERYNEWPALETTE:
        {
            TRC_NRM((TB, _T("WM_QUERYNEWPALETTE")));
            /****************************************************************/
            /* Note that we are calling this function (which should         */
            /* logically be called on the receive thread) on the UI thread. */
            /* See comment in function description.                         */
            /****************************************************************/
            rc = _pOp->OP_QueryNewPalette(hwnd);
        }
        break;

#ifdef OS_WINNT
        case WM_ENTERSIZEMOVE:
        {
            /****************************************************************/
            /* Tell IH we're entering Size/Move mode                        */
            /****************************************************************/
            TRC_NRM((TB, _T("Enter Size/Move")));
            _CO.inSizeMove = TRUE;

            _pCd->CD_DecoupleSyncNotification(CD_SND_COMPONENT,
                                              _pIh,
                                              CD_NOTIFICATION_FUNC(CIH,IH_InputEvent),
                                              WM_ENTERSIZEMOVE);
        }
        break;

        case WM_CAPTURECHANGED:
        {
            if (_CO.inSizeMove)
            {
                /************************************************************/
                /* Tell IH we're leaving size/move mode (Windows doesn't    */
                /* always send WM_EXITSIZEMOVE, but it does seem to always  */
                /* send WM_CAPTURECHANGED).                                 */
                /************************************************************/
                TRC_NRM((TB, _T("Capture Changed when in Size/Move")));
                _CO.inSizeMove = FALSE;

                _pCd->CD_DecoupleSyncNotification(CD_SND_COMPONENT,
                        _pIh,
                         CD_NOTIFICATION_FUNC(CIH,IH_InputEvent),
                         WM_EXITSIZEMOVE);
            }
        }
        break;

        case WM_EXITSIZEMOVE:
        {
            // Tell IH we're leaving size/move mode.
            TRC_NRM((TB, _T("Exit Size/Move")));
            _CO.inSizeMove = FALSE;

            _pCd->CD_DecoupleSyncNotification(CD_SND_COMPONENT,
                    _pIh,
                    CD_NOTIFICATION_FUNC(CIH,IH_InputEvent),
                    WM_EXITSIZEMOVE);
        }
        break;

        case WM_EXITMENULOOP:
        {
            // Tell IH we're exiting the system menu handler.
            TRC_NRM((TB, _T("Exit menu loop")));

            _pCd->CD_DecoupleSyncNotification(CD_SND_COMPONENT,
                    _pIh,
                    CD_NOTIFICATION_FUNC(CIH,IH_InputEvent),
                    WM_EXITMENULOOP);
        }
        break;
#endif

#ifdef OS_WINCE
        // HPC devices do not get WM_SIZE (SIZE_RESTORED) on a maximize,
        // but we do get the WM_ACTIVATE message.
        case WM_ACTIVATE:
        {
            if (g_CEConfig != CE_CONFIG_WBT &&
                LOWORD(wParam) != WA_INACTIVE)
            {
                _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT,
                        _pOr,
                        CD_NOTIFICATION_FUNC(COR,OR_SetSuppressOutput),
                        SIZE_RESTORED);
            }
        }
        // FALL-THRU
#endif // OS_WINCE

        default:
        {
            rc =_pUi->UIMainWndProc( hwnd, message, wParam, lParam);
        }
        break;
    }

    DC_END_FN();
    return rc;
} /* COContainerWindowSubclassProc */


LRESULT CALLBACK CCO::COStaticContainerWindowSubclassProc( HWND hwnd,
                                        UINT message,
                                        WPARAM wParam,
                                        LPARAM lParam )
{
    // delegate to appropriate instance
    CCO* pCO = (CCO*)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    return pCO->COContainerWindowSubclassProc(hwnd, message, wParam, lParam);
}


LRESULT CALLBACK CCO::COStaticMainWindowSubclassProc( HWND hwnd,
                                           UINT message,
                                           WPARAM wParam,
                                           LPARAM lParam )
{
    // delegate to appropriate instance
    CCO* pCO = (CCO*)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    return pCO->COMainWindowSubclassProc(hwnd, message, wParam, lParam);
}


/****************************************************************************/
/* Name:      COSubclassUIWindows                                           */
/*                                                                          */
/* Purpose:   Subclasses the UI's Main Frame and Container Windows          */
/****************************************************************************/
void DCINTERNAL CCO::COSubclassUIWindows()
{
    DC_BEGIN_FN("COSubclassUIWindows");

    // Replace the instance pointer with that for the CO object
    // when subclassing. Have to do this because CO is not derived from UI
    SetWindowLongPtr( _pUi->UI_GetUIMainWindow(), GWLP_USERDATA, (LONG_PTR)this); 
    SetWindowLongPtr( _pUi->UI_GetUIContainerWindow(), GWLP_USERDATA, (LONG_PTR)this);

    _CO.pUIMainWndProc = SubclassWindow( _pUi->UI_GetUIMainWindow(),
                                        COStaticMainWindowSubclassProc );


    _CO.pUIContainerWndProc = SubclassWindow( _pUi->UI_GetUIContainerWindow(),
                                             COStaticContainerWindowSubclassProc );

    DC_END_FN();
} /* COSubclassUIWindows */


/****************************************************************************/
/* Name:      CO_OnInitialized                                              */
/*                                                                          */
/* Purpose:   Handle Initialized notification from SL                       */
/*                                                                          */
/* Operation: Initialize the Receiver Thread                                */
/****************************************************************************/
void DCCALLBACK CCO::CO_OnInitialized()
{
    DC_BEGIN_FN("CO_OnInitialized");

    // Call RCV_Init to initialize the Core.
    _pRcv->RCV_Init();

    DC_END_FN();
} /* CO_OnInitialized */


/****************************************************************************/
/* Name:      CO_OnTerminating                                              */
/*                                                                          */
/* Purpose:   Handle Terminating notification from SL                       */
/****************************************************************************/
void DCCALLBACK CCO::CO_OnTerminating()
{
    DC_BEGIN_FN("CO_OnTerminating");

    // Terminate Core components.
    _pRcv->RCV_Term();

    DC_END_FN();
} /* CO_OnTerminating */


/****************************************************************************/
/* Name:      CO_OnConnected                                                */
/*                                                                          */
/* Purpose:   Handle Connected notification from SL                         */
/*                                                                          */
/* Params:    IN      channelID                                             */
/*            IN      pUserData                                             */
/*            IN      userDataLength                                        */
/****************************************************************************/
void DCCALLBACK CCO::CO_OnConnected(
        unsigned channelID,
        PVOID pUserData,
        unsigned userDataLength,
        UINT32 serverVersion)
{
    DC_BEGIN_FN("CO_OnConnected");

    TRC_DBG((TB, _T("Channel %d"), channelID));

    DC_IGNORE_PARAMETER(serverVersion);

    // Currently there is no Core userdata sent from the Server.
    DC_IGNORE_PARAMETER(pUserData);
    DC_IGNORE_PARAMETER(userDataLength);
    DC_IGNORE_PARAMETER(channelID);

    // Pass to CC.
    TRC_NRM((TB, _T("Connect OK")));

    _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT,
            _pCc,
            CD_NOTIFICATION_FUNC(CCC,CC_Event),
            (ULONG_PTR) CC_EVT_API_ONCONNECTOK);

    DC_END_FN();
} /* CO_OnConnected */


/****************************************************************************/
/* Name:      CO_OnDisconnected                                             */
/*                                                                          */
/* Purpose:   Handle Disconnected notification from SL                      */
/*                                                                          */
/* Params:    IN      result - disconnection reason code                    */
/****************************************************************************/
void DCCALLBACK CCO::CO_OnDisconnected(unsigned result)
{
    DC_BEGIN_FN("CO_OnDisconnected");

    DC_IGNORE_PARAMETER(result);

    // Pass to CC.
    _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT,
            _pCc,
            CD_NOTIFICATION_FUNC(CCC,CC_OnDisconnected),
            (ULONG_PTR) result);

    DC_END_FN();
} /* CO_OnDisconnected */


#define CO_CHECKPACKETCAST( type, size, hr ) \
    if ( (size) < sizeof(type)) { \
        TRC_ABORT((TB, _T("Bad ") _T( #type ) _T(" len [expected %u got %u]"), \
            sizeof(type), (size) )); \
        hr = E_TSC_CORE_LENGTH; \
        DC_QUIT; \
    }

#define CO_CHECKPACKETCAST_SPECIFC( type, size, expected, hr ) \
    if ( (size) < (expected)) { \
        TRC_ABORT((TB, _T("Bad ") _T( #type ) _T(" len [expected %u got %u]"), \
            (expected), (size) )); \
        hr = E_TSC_CORE_LENGTH; \
        DC_QUIT; \
    }

// This macro is used to see that when a pointer to a TS_SHAREDATAHEADER 
// is passed on to a handler, the TS_SHAREDATAHEADER is an uncompressed packet
// If the packet was compressed, then the data after the TS_SHAREDATAHEADER is
// still compressed, and the method we pass this header onto will puke on the 
// data, assuming it does not uncompress the data, which no layers above this
// do
#define COPR_MUSTBEUNCOMP( type, pDataHdr, hr ) \
     if (pDataHdr->generalCompressedType & PACKET_COMPRESSED) { \
        TRC_ABORT((TB, _T( #type ) \
            _T(" was unexpectedly compressed"))); \
        hr = E_TSC_CORE_UNEXPECTEDCOMP; \
        DC_QUIT; \
    }

/****************************************************************************/
/* Name:      CO_OnPacketReceived                                           */
/*                                                                          */
/* Purpose:   Handle PacketReceived notification from SL                    */
/*                                                                          */
/* Params:    IN      pData    - packet received                            */
/*            IN      dataLen  - length of packet                           */
/*            IN      flags    - RNS_SEC_ flags                             */
/*            IN      channelID - MCS channel on which packet was sent      */
/*            IN      priority - priority of packet                         */
/****************************************************************************/
HRESULT DCCALLBACK CCO::CO_OnPacketReceived(
         PBYTE pData,
         unsigned dataLen,
         unsigned flags,
         unsigned channelID,
         unsigned priority)
{
    HRESULT     hr = S_OK;
    PTS_SHARECONTROLHEADER  pCtrlHdr;
    PTS_SHAREDATAHEADER     pDataHdr;
    PTS_FLOW_PDU            pFlowPDU;

    PDCUINT8                pCurrentPDU;
    DCUINT                  currentDataLen;
    DCUINT                  dataBufLen;
#ifdef DC_DEBUG
    DCUINT                  countPDU = 0;
#endif
    DCUINT                  dataRemaining = dataLen;

    DC_BEGIN_FN("CO_OnPacketReceived");

    DC_IGNORE_PARAMETER(flags);
    DC_IGNORE_PARAMETER(priority);
    DC_IGNORE_PARAMETER(channelID);

    TRC_ASSERT((pData != NULL), (TB, _T("NULL packet")));
    TRC_NRM((TB, _T("channelID %#x"), channelID));
    TRC_NRM((TB, _T("(fixed) Buffer: %p len %d"), pData, dataLen));
    TRC_DATA_DBG("Contents", pData, dataLen);

    // Find the first PDU in the packet.
    pCurrentPDU = pData;

    // And while there are more PDUs in the packet, route each PDU.
    while (pCurrentPDU != NULL) {
        // Intermediate variable to save in casts!
        pCtrlHdr = (PTS_SHARECONTROLHEADER)pCurrentPDU;

        // SECURITY: NOTE - it is not safe to read the pduSource
        //  field of the TS_SHARECONTROLHEADER since we are not
        //  requiring this data to be there.  This is to support
        //  the TS_PDUTYPE_DEACTIVATEALLPDU which appears smaller
        //  on win2k
        // Be sure there is enough data to read the totalLength
        if (dataRemaining < FIELDOFFSET(TS_SHARECONTROLHEADER, pduSource)) {
            TRC_ABORT(( TB, _T("dataRemaining %u partial sizeof(TS_")
                _T("SHARECONTROLHEADER) %u "), dataRemaining, 
                FIELDOFFSET(TS_SHARECONTROLHEADER, pduSource)));
            hr = E_TSC_CORE_LENGTH;
            DC_QUIT;
        }

        // All PDUs start with the length and PDU type, except FlowPDUs.
        if (pCtrlHdr->totalLength != TS_FLOW_MARKER) {

			currentDataLen = pCtrlHdr->totalLength;
			// Be sure there is enough data for the entire packet
			if (dataRemaining < currentDataLen) {
				TRC_ABORT(( TB, _T("dataRemaining %u currentDataLen %u"),
					dataRemaining, currentDataLen));
				hr = E_TSC_CORE_LENGTH;
				DC_QUIT;
			}        

			if (sizeof(PTS_SHAREDATAHEADER) <= dataRemaining) {
				TRC_NRM((TB, _T("current PDU x%p type %u, type2 %u, data len %u"),
						pCurrentPDU,
						(pCtrlHdr->pduType) & TS_MASK_PDUTYPE,
						((PTS_SHAREDATAHEADER)pCurrentPDU)->pduType2,
						currentDataLen));
			}
        
            switch ((pCtrlHdr->pduType) & TS_MASK_PDUTYPE) {
                case TS_PDUTYPE_DATAPDU:
                {
                    PDCUINT8 pDataBuf;
                    TRC_DBG((TB, _T("A Data PDU")));

                    CO_CHECKPACKETCAST(TS_SHAREDATAHEADER, currentDataLen, hr);

                    pDataHdr = (PTS_SHAREDATAHEADER)pCurrentPDU;
                    pDataBuf = pCurrentPDU + sizeof(TS_SHAREDATAHEADER);
                    dataBufLen = currentDataLen - sizeof(TS_SHAREDATAHEADER);

                    if (pDataHdr->generalCompressedType & PACKET_COMPRESSED) {
                        UCHAR *buf;
                        int   bufSize;

                        if (pDataHdr->generalCompressedType & PACKET_FLUSHED)
                            initrecvcontext (&_pUi->_UI.Context1,
                                             (RecvContext2_Generic*)_pUi->_UI.pRecvContext2,
                                             PACKET_COMPR_TYPE_64K);

                        if (decompress(pDataBuf,
                                pCtrlHdr->totalLength - sizeof(TS_SHAREDATAHEADER),
                                (pDataHdr->generalCompressedType & PACKET_AT_FRONT),
                                &buf,
                                &bufSize,
                                &_pUi->_UI.Context1,
                                (RecvContext2_Generic*)_pUi->_UI.pRecvContext2,
                                (pDataHdr->generalCompressedType &
                                  PACKET_COMPR_TYPE_MASK))) {
                            pDataBuf = buf;
                            dataBufLen = bufSize;
                        }
                        else {
                            TRC_ABORT((TB, _T("Decompression FAILURE!!!")));

                            hr = E_TSC_UI_DECOMPRESSION;
                            DC_QUIT;
                        }
                    }

                    switch (pDataHdr->pduType2) {
                        case TS_PDUTYPE2_UPDATE:
                            CO_CHECKPACKETCAST(TS_UPDATE_HDR_DATA, 
                                dataBufLen, hr);
                                                       
                            TRC_DBG((TB, _T("Update PDU")));
                            hr = _pUh->UH_OnUpdatePDU(
                                    (TS_UPDATE_HDR_DATA UNALIGNED FAR *)
                                    pDataBuf, dataBufLen);
                            DC_QUIT_ON_FAIL(hr);
                            break;

                        case TS_PDUTYPE2_POINTER:
                            // SECURITY: Only the TS_POINTER_PDU_DATA.messageType needs to be
                            //  read.  NT4 servers may not send a TS_POINTER_PDU_DATA.pointerData
                            CO_CHECKPACKETCAST_SPECIFC(TS_POINTER_PDU_DATA, 
                            dataBufLen, sizeof(TSUINT16), hr);

                            TRC_DBG((TB, _T("Mouse Pointer PDU")));
                            hr = _pCm->CM_SlowPathPDU(
                                    (TS_POINTER_PDU_DATA UNALIGNED FAR *)
                                    pDataBuf, dataBufLen);
                            DC_QUIT_ON_FAIL(hr);
                            break;

                        case TS_PDUTYPE2_FONTMAP:
                        case TS_PDUTYPE2_INPUT:
                        case TS_PDUTYPE2_UPDATECAPABILITY:
                        case TS_PDUTYPE2_DESKTOP_SCROLL:
                        case TS_PDUTYPE2_APPLICATION:
                        case TS_PDUTYPE2_CONTROL:
                        case TS_PDUTYPE2_MEDIATEDCONTROL:
                        case TS_PDUTYPE2_REMOTESHARE:
                        case TS_PDUTYPE2_SYNCHRONIZE:
                        case TS_PDUTYPE2_WINDOWLISTUPDATE:
                        case TS_PDUTYPE2_WINDOWACTIVATION:
                            TRC_DBG((TB, _T("Ignore pdutype2 %#x"),
                                    pDataHdr->pduType2));
                            break;

                        case TS_PDUTYPE2_SHUTDOWN_DENIED:
                            TRC_DBG((TB, _T("ShutdownDeniedPDU")));

                            _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT,
                                                                _pCc,
                                    CD_NOTIFICATION_FUNC(CCC,CC_Event),
                                    (ULONG_PTR)CC_EVT_API_ONSHUTDOWNDENIED);
                            
                            break;

                        case TS_PDUTYPE2_PLAY_SOUND:
                            CO_CHECKPACKETCAST(TS_PLAY_SOUND_PDU_DATA, 
                                dataBufLen, hr);
                            
                            TRC_DBG((TB, _T("PlaySoundPDU")));
                            hr = _pSp->SP_OnPlaySoundPDU((PTS_PLAY_SOUND_PDU_DATA)
                                pDataBuf, dataBufLen);
                            DC_QUIT_ON_FAIL(hr);
                            break;

                        case TS_PDUTYPE2_SAVE_SESSION_INFO:
                            //CO_CHECKPACKETCAST(TS_SAVE_SESSION_INFO_PDU_DATA, dataBufLen, hr);
                            // SECURITY: TS_SAVE_SESSION_INFO_PDU_DATA may be sent from NT4 with
                            //  only a TS_SAVE_SESSION_INFO_PDU_DATA.InfoType
                            CO_CHECKPACKETCAST_SPECIFC(TS_SAVE_SESSION_INFO_PDU_DATA, 
                                dataBufLen, sizeof(TSUINT32), hr);
                            
                            TRC_DBG((TB, _T("Save Session Info PDU")));
                            hr = CO_OnSaveSessionInfoPDU(
                                    (PTS_SAVE_SESSION_INFO_PDU_DATA)pDataBuf, 
                                    dataBufLen);
                            DC_QUIT_ON_FAIL(hr);
                            break;

                        case TS_PDUTYPE2_SET_KEYBOARD_INDICATORS:
                            CO_CHECKPACKETCAST(TS_SET_KEYBOARD_INDICATORS_PDU, 
                                currentDataLen, hr);
                            COPR_MUSTBEUNCOMP(TS_SET_KEYBOARD_INDICATORS_PDU, 
                                pDataHdr, hr);
                           
                            TRC_DBG((TB, _T("TS_PDUTYPE2_SET_KEYBOARD_INDICATORS PDU")));
                            hr = CO_OnSetKeyboardIndicatorsPDU
                                    ((PTS_SET_KEYBOARD_INDICATORS_PDU)pCurrentPDU,
                                    currentDataLen);
                            DC_QUIT_ON_FAIL(hr);
                            break;

                        case TS_PDUTYPE2_SET_KEYBOARD_IME_STATUS:
                        {
                            PTS_SET_KEYBOARD_IME_STATUS_PDU pImePDU;

                            CO_CHECKPACKETCAST(TS_SET_KEYBOARD_IME_STATUS_PDU, 
                                currentDataLen, hr);
                            COPR_MUSTBEUNCOMP(TS_SET_KEYBOARD_IME_STATUS_PDU, 
                                pDataHdr, hr);

                            TRC_DBG((TB, _T("TS_PDUTYPE2_SET_KEYBOARD_IME_STATUS PDU")));
                            pImePDU = (PTS_SET_KEYBOARD_IME_STATUS_PDU)pCurrentPDU;
                            _pIh->IH_SetKeyboardImeStatus(pImePDU->ImeOpen,
                                    pImePDU->ImeConvMode);
                            break;
                        }

                        case TS_PDUTYPE2_SET_ERROR_INFO_PDU:
                        {
                            PTS_SET_ERROR_INFO_PDU pErrInfoPDU;

                            CO_CHECKPACKETCAST(TS_SET_ERROR_INFO_PDU, 
                                currentDataLen, hr);
                            COPR_MUSTBEUNCOMP(TS_SET_ERROR_INFO_PDU, 
                                pDataHdr, hr);
                            
                            TRC_DBG((TB, _T("TS_SET_ERROR_INFO_PDU PDU")));
                            pErrInfoPDU = (PTS_SET_ERROR_INFO_PDU)pCurrentPDU;
                            _pUi->UI_SetServerErrorInfo(pErrInfoPDU->errorInfo);
                            break;
                        }

                        case TS_PDUTYPE2_ARC_STATUS_PDU:
                        {
                            PTS_AUTORECONNECT_STATUS_PDU pArcStatusPDU;

                            CO_CHECKPACKETCAST(TS_AUTORECONNECT_STATUS_PDU, 
                                currentDataLen, hr);
                            COPR_MUSTBEUNCOMP(TS_AUTORECONNECT_STATUS_PDU, 
                                pDataHdr, hr);
                            
                            TRC_DBG((TB, _T("TS_PDUTYPE2_ARC_STATUS_PDU")));
                            pArcStatusPDU = (PTS_AUTORECONNECT_STATUS_PDU)pCurrentPDU;
                            _pUi->UI_OnReceivedArcStatus(pArcStatusPDU->arcStatus);
                            break;
                        }


                        default:
                            TRC_ABORT((TB, _T("Invalid pduType2 %#x"),
                                           pDataHdr->pduType2));

                            break;
                    }
                }
                break;

                case TS_PDUTYPE_DEMANDACTIVEPDU: 
                    TRC_DBG((TB, _T("DemandActivePDU")));

                    CO_CHECKPACKETCAST(TS_DEMAND_ACTIVE_PDU, currentDataLen, hr);

                    _pCd->CD_DecoupleNotification(CD_SND_COMPONENT,
                                                  _pCc,
                                            CD_NOTIFICATION_FUNC(CCC,CC_OnDemandActivePDU),
                                            pCurrentPDU,
                                            currentDataLen);
                    break;

                case TS_PDUTYPE_DEACTIVATEALLPDU:
                    TRC_DBG((TB, _T("DeactivateAllPDU")));

                    _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, _pCc,
                                                        CD_NOTIFICATION_FUNC(CCC,CC_Event),
                            (ULONG_PTR)CC_EVT_API_ONDEACTIVATEALL);
                    break;

                case TS_PDUTYPE_DEACTIVATESELFPDU:
                case TS_PDUTYPE_DEACTIVATEOTHERPDU:
                case TS_PDUTYPE_CONFIRMACTIVEPDU:
                case TS_PDUTYPE_REQUESTACTIVEPDU:
                    TRC_ERR((TB, _T("PDU type %x unexpected!"), pCtrlHdr->pduType));
                    break;

                default:
                    TRC_ABORT((TB, _T("Unrecognized PDU type: %#x"),
                            pCtrlHdr->pduType));
                    break;
            }
        }
        else {
            TRC_NRM((TB, _T("FlowPDU")));
            pFlowPDU = (PTS_FLOW_PDU)pData;

            switch (pFlowPDU->pduType) {
                case TS_PDUTYPE_FLOWTESTPDU:
                    TRC_NRM((TB, _T("FlowTestPDU ignored")));
                    break;

                case TS_PDUTYPE_FLOWRESPONSEPDU:
                    TRC_NRM((TB, _T("FlowResponsePDU ignored")));
                    break;

                default:
                    TRC_ABORT((TB, _T("Unknown FlowPDU %#x"), pFlowPDU->pduType));
                    break;
            }

            DC_QUIT;
        }

        // Now look for the next PDU in the packet.
        pCurrentPDU += pCtrlHdr->totalLength;
        dataRemaining -= pCtrlHdr->totalLength;
        if ((DCUINT)(pCurrentPDU - pData) >= dataLen) {
            TRC_NRM((TB, _T("Last PDU in packet")));
            pCurrentPDU = NULL;
        }

#ifdef DC_DEBUG
        countPDU++;
#endif

    }

#ifdef DC_DEBUG
    if (countPDU > 1)
    {
        TRC_NRM((TB, _T("*** PDU count %u"), countPDU));
    }
#endif

DC_EXIT_POINT:     

    if (FAILED(hr) && IMMEDIATE_DISSCONNECT_ON_HR(hr)) {
        TRC_ABORT((TB, _T("Disconnect for security")));
        CO_DropLinkImmediate(SL_ERR_INVALIDPACKETFORMAT, hr);
    }

    DC_END_FN();    
    return hr;
} /* CO_OnPacketReceived */


/****************************************************************************/
// CO_OnFastPathOutputReceived
//
// Handles fast-path output from the server by dispatching subpackets
// to the right handler component.
/****************************************************************************/
#define DC_QUIT_ON_FAIL_TRC(hr, trc) if (FAILED(hr)) {TRC_ABORT( trc );DC_QUIT;}
HRESULT DCAPI CCO::CO_OnFastPathOutputReceived(BYTE FAR *pData, 
    unsigned DataLen)
{
    HRESULT hr = S_OK;
    unsigned RawPDUSize;
    unsigned HdrSize;
    unsigned PDUSize;
    BYTE FAR *pPDU;

    DC_BEGIN_FN("CO_OnFastPathOutputReceived");

    // Fast-path output is a series of PDUs packed on byte boundaries.
    while (DataLen) {
        // First byte is header containing the update type and compression-
        // used flag. If compression-used is true the following byte is the
        // compression flags, otherwise it's not present. Final part of
        // header is 2-byte little-endian size field.

        if (*pData & TS_OUTPUT_FASTPATH_COMPRESSION_USED) {

            HdrSize = 4;
            if (HdrSize > DataLen) {
                TRC_ABORT((TB, _T("Bad comp fast path PDU")));
                hr = E_TSC_CORE_LENGTH;
                DC_QUIT;
            }
            RawPDUSize = *((UINT16 UNALIGNED FAR *)(pData + 2));

            // Be sure there is enough size for the header
            if (HdrSize + RawPDUSize > DataLen) {
                TRC_ABORT((TB, _T("Bad comp fast path PDU; [need %u have %u]"),
                    HdrSize + RawPDUSize, DataLen));
                hr = E_TSC_CORE_LENGTH;
                DC_QUIT;
            }

            if (pData[1] & PACKET_COMPRESSED) {
                if (pData[1] & PACKET_FLUSHED)
                    initrecvcontext (&_pUi->_UI.Context1,
                                     (RecvContext2_Generic*)_pUi->_UI.pRecvContext2,
                                     PACKET_COMPR_TYPE_64K);

                if (!decompress(pData + 4, RawPDUSize,
                        pData[1] & PACKET_AT_FRONT, &pPDU, (PDCINT) &PDUSize,
                        &_pUi->_UI.Context1,
                        (RecvContext2_Generic*)_pUi->_UI.pRecvContext2,
                        pData[1] & PACKET_COMPR_TYPE_MASK)) {
                    TRC_ABORT((TB, _T("Decompression FAILURE!!!")));

                    hr = E_TSC_UI_DECOMPRESSION;
                    DC_QUIT;
                }
            }
            else {
                pPDU = pData + 4;
                PDUSize = RawPDUSize;
            }
        }
        else {
            // Compression flags not present.
            HdrSize = 3;
            if (HdrSize > DataLen) {
                TRC_ABORT((TB, _T("Bad uncomp fast path PDU; [need %u have %u]"),
                    HdrSize, DataLen));
                hr = E_TSC_CORE_LENGTH;
                DC_QUIT;
            }
            
            PDUSize = RawPDUSize = *((UINT16 UNALIGNED FAR *)(pData + 1));
            pPDU = pData + 3;

            // Be sure there is enough size for the header
            if (HdrSize + RawPDUSize > DataLen) {
                TRC_ABORT((TB, _T("Bad uncomp fast path PDU; [need %u have %u]"),
                    HdrSize + RawPDUSize, DataLen));
                hr = E_TSC_CORE_LENGTH;
                DC_QUIT;
            }
        }

        switch (*pData & TS_OUTPUT_FASTPATH_UPDATETYPE_MASK) {
            case TS_UPDATETYPE_ORDERS:
                // Number of orders is in little-endian format in
                // the first two bytes of the PDU area.
                TRC_NRM((TB, _T("Fast-path Order PDU")));
                hr = _pUh->UH_ProcessOrders(*((UINT16 UNALIGNED FAR *)pPDU),
                        pPDU + 2,  PDUSize);
                DC_QUIT_ON_FAIL_TRC( hr, (TB,_T("UH_ProcessOrders")));
                break;

            case TS_UPDATETYPE_BITMAP:
                // BitmapPDU format unchanged from normal path.
                CO_CHECKPACKETCAST(TS_UPDATE_BITMAP_PDU_DATA, PDUSize, hr);
                              
                TRC_NRM((TB, _T("Bitmap PDU")));
                hr = _pUh->UH_ProcessBitmapPDU(
                        (TS_UPDATE_BITMAP_PDU_DATA UNALIGNED FAR *)pPDU, 
                        PDUSize);
                DC_QUIT_ON_FAIL_TRC( hr, (TB,_T("UH_ProcessBitmapPDU")));
                break;

            case TS_UPDATETYPE_PALETTE:
                CO_CHECKPACKETCAST(TS_UPDATE_PALETTE_PDU_DATA, PDUSize, hr);
                
                // PalettePDU format unchanged from normal path.
                TRC_NRM((TB, _T("Palette PDU")));
                hr = _pUh->UH_ProcessPalettePDU(
                        (TS_UPDATE_PALETTE_PDU_DATA UNALIGNED FAR *)pPDU, 
                        PDUSize);
                DC_QUIT_ON_FAIL_TRC( hr, (TB,_T("UH_ProcessPalettePDU")));
                break;

            case TS_UPDATETYPE_SYNCHRONIZE:
                TRC_NRM((TB, _T("Sync PDU")));
                break;

            case TS_UPDATETYPE_MOUSEPTR_SYSTEM_NULL:
                TRC_NRM((TB,_T("Mouse null system pointer PDU")));
                _pCm->CM_NullSystemPointerPDU();
                break;

            case TS_UPDATETYPE_MOUSEPTR_SYSTEM_DEFAULT:
                TRC_NRM((TB,_T("Mouse default system pointer PDU")));
                _pCm->CM_DefaultSystemPointerPDU();
                break;

            case TS_UPDATETYPE_MOUSEPTR_MONO:
                CO_CHECKPACKETCAST(TS_MONOPOINTERATTRIBUTE, PDUSize, hr);
                
                TRC_NRM((TB,_T("Mouse mono pointer PDU")));
                hr = _pCm->CM_MonoPointerPDU(
                        (TS_MONOPOINTERATTRIBUTE UNALIGNED FAR *)pPDU,PDUSize);
                DC_QUIT_ON_FAIL_TRC( hr, (TB,_T("CM_MonoPointerPDU")));
                break;

            case TS_UPDATETYPE_MOUSEPTR_POSITION:
                CO_CHECKPACKETCAST(TS_POINT16, PDUSize, hr);
                
                TRC_NRM((TB,_T("Mouse position PDU")));
                _pCm->CM_PositionPDU((TS_POINT16 UNALIGNED FAR *)pPDU);
                break;

            case TS_UPDATETYPE_MOUSEPTR_COLOR:
                CO_CHECKPACKETCAST(TS_COLORPOINTERATTRIBUTE, PDUSize, hr);
                
                TRC_NRM((TB,_T("Mouse color pointer PDU")));
                hr = _pCm->CM_ColorPointerPDU(
                        (TS_COLORPOINTERATTRIBUTE UNALIGNED FAR *)pPDU, 
                        PDUSize);
                DC_QUIT_ON_FAIL_TRC( hr, (TB,_T("CM_ColorPointerPDU")));
                break;

            case TS_UPDATETYPE_MOUSEPTR_CACHED:
                CO_CHECKPACKETCAST(TSUINT16, PDUSize, hr);
                
                TRC_NRM((TB,_T("Mouse cached pointer PDU")));
                _pCm->CM_CachedPointerPDU(*((TSUINT16 UNALIGNED FAR *)pPDU));
                break;

            case TS_UPDATETYPE_MOUSEPTR_POINTER:
                CO_CHECKPACKETCAST(TS_POINTERATTRIBUTE, PDUSize, hr);
                
                TRC_NRM((TB,_T("Mouse pointer PDU")));
                hr = _pCm->CM_PointerPDU(
                    (TS_POINTERATTRIBUTE UNALIGNED FAR *)pPDU, PDUSize);
                DC_QUIT_ON_FAIL_TRC( hr, (TB,_T("CM_PointerPDU")));
                break;

            default:
                TRC_ERR((TB, _T("Unexpected Update PDU type: %u"),
                        *pData & TS_OUTPUT_FASTPATH_UPDATETYPE_MASK));
                break;
        }

        pData += HdrSize + RawPDUSize;
        DataLen -= HdrSize + RawPDUSize;
    }

    /************************************************************************/
    /* If there are a large number of PDUs arriving, messages flood the     */
    /* Receive Thread's message queue and it is possible for WM_PAINT       */
    /* messages to not get processed within a reasonable amount of time     */
    /* (as they have the lowest priority).  We therefore ensure that        */
    /* any outstanding WM_PAINTs are flushed if they have not been          */
    /* processed within UH_WORST_CASE_WM_PAINT_PERIOD.                      */
    /*                                                                      */
    /* Note that the normal processing of updates does not involve          */
    /* WM_PAINT messages - we draw directly to the Output Window.           */
    /* WM_PAINTs are only generated by resizing or obscuring/revealing      */
    /* an area of the client window.                                        */
    /************************************************************************/
    _pOp->OP_MaybeForcePaint();

DC_EXIT_POINT:

     if (FAILED(hr) && IMMEDIATE_DISSCONNECT_ON_HR(hr)) {
        TRC_ABORT((TB, _T("Disconnect for security")));
        CO_DropLinkImmediate(SL_ERR_INVALIDPACKETFORMAT, hr);
    }
    
    DC_END_FN();
    return hr;  
}


#define CHECK_ULONGLEN_STRING(p, pEnd, str, ulSize, descr) \
{\
    CHECK_READ_N_BYTES(p, pEnd, sizeof(ULONG), hr, (TB,_T("can not read ") _T( #descr ) _T("size"))) \
    (ulSize) = *((ULONG UNALIGNED *)(p)); \
    (str) = (PBYTE)(p) + sizeof(ULONG); \
    CHECK_READ_N_BYTES(str , pEnd, ulSize, hr, (TB,_T("can not read ") _T( #descr ))) \
    (p) += (ulSize) + sizeof(ULONG); \
}

/****************************************************************************/
// CO_OnServerRedirectionPacket
//
// Called from SL on receipt of a server redir packet for load balancing.
/****************************************************************************/
HRESULT DCAPI CCO::CO_OnServerRedirectionPacket(
        RDP_SERVER_REDIRECTION_PACKET UNALIGNED *pPkt,
        DCUINT dataLen)
{
    HRESULT hr = S_OK;
    WCHAR AlignedAddress[TS_MAX_SERVERADDRESS_LENGTH];
    unsigned length;
    PBYTE pEnd = ((BYTE *)pPkt) + pPkt->Length;
    BOOL fNeedRedirect = TRUE;
    
    
    DC_BEGIN_FN("CO_OnServerRedirectionPacket");

    TRC_DBG((TB, _T("RDP_SERVER_REDIRECTION_PACKET")));

    //
    // Notify the CLX test harness of the redirection packet
    //
    _pClx->CLX_RedirectNotify(pPkt, dataLen);

    if (dataLen < pPkt->Length) {
        TRC_ABORT(( TB, _T("packet length incorrect")));
        hr = E_TSC_CORE_LENGTH;
        DC_QUIT;
    }

    if (pPkt->Flags & RDP_SEC_REDIRECTION_PKT) {
        // Copy the address to an aligned buffer.
        length = min(pPkt->Length + sizeof(WCHAR) - sizeof(RDP_SERVER_REDIRECTION_PACKET),
                sizeof(AlignedAddress));
        
        if (length > 0 && length <= sizeof(AlignedAddress)) {
            memcpy(AlignedAddress, pPkt->ServerAddress, length);
        
            // Set the redir info in UI and disconnect.
            _pUi->UI_SetServerRedirectionInfo(pPkt->SessionID, AlignedAddress,
                    NULL, 0, fNeedRedirect);
        }                
    }
    else if (pPkt->Flags & RDP_SEC_REDIRECTION_PKT2) {
        RDP_SERVER_REDIRECTION_PACKET_V2 UNALIGNED *pPkt2 = 
                (RDP_SERVER_REDIRECTION_PACKET_V2 UNALIGNED*)pPkt;
        PBYTE LBInfo = NULL;
        PBYTE ServerName = NULL;
        PBYTE pBuf = NULL;
        unsigned LBInfoSize = 0;
        unsigned ServerNameSize = 0;
        
        pBuf = (PBYTE)(pPkt2 + 1);

        if (pPkt2->RedirFlags & TARGET_NET_ADDRESS) {
            CHECK_ULONGLEN_STRING(pBuf, pEnd, ServerName, 
                ServerNameSize, TARGET_NET_ADDRESS);
        }

        if (pPkt2->RedirFlags & LOAD_BALANCE_INFO) {
            CHECK_ULONGLEN_STRING(pBuf, pEnd, LBInfo, 
                LBInfoSize, LOAD_BALANCE_INFO);
        }

        if (ServerNameSize > 0 && ServerNameSize <= sizeof(AlignedAddress)) {
            memcpy(AlignedAddress, ServerName, ServerNameSize);
        
            // Set the redir info in UI and disconnect.
            _pUi->UI_SetServerRedirectionInfo(pPkt2->SessionID, AlignedAddress, 
                    NULL, 0, fNeedRedirect);
        }
        else {
            // Set the redir info in UI and disconnect.  That LBInfo is going to
            // be there indicates to XT_SendCR that we are in the middle of
            // a redirect and should use the redirect info instead of scripting
            // or hash-mode cookie.
            _pUi->UI_SetServerRedirectionInfo(pPkt2->SessionID, 
                    _pUi->_UI.strAddress, LBInfo, LBInfoSize, fNeedRedirect);
        }
    }
    else if (pPkt->Flags & RDP_SEC_REDIRECTION_PKT3) {
            RDP_SERVER_REDIRECTION_PACKET_V3 UNALIGNED *pPkt3 = 
                    (RDP_SERVER_REDIRECTION_PACKET_V3 UNALIGNED*)pPkt;
            PBYTE LBInfo = NULL;
            PBYTE ServerName = NULL;
            PBYTE pBuf = NULL;
            PBYTE pUserName = NULL;
            PBYTE pDomain  = NULL;
            PBYTE pClearPassword  = NULL;
            unsigned LBInfoSize = 0;
            unsigned ServerNameSize = 0;
            unsigned UserNameSize = 0;
            unsigned DomainSize = 0;
            unsigned PasswordSize = 0;
            
        
            pBuf = (PBYTE)(pPkt3 + 1);

            if (pPkt3->RedirFlags & TARGET_NET_ADDRESS) {
                CHECK_ULONGLEN_STRING(pBuf, pEnd, ServerName, 
                    ServerNameSize, TARGET_NET_ADDRESS);
            }

            if (pPkt3->RedirFlags & LOAD_BALANCE_INFO) {
                CHECK_ULONGLEN_STRING(pBuf, pEnd, LBInfo, 
                    LBInfoSize, LOAD_BALANCE_INFO);
            }

            if (pPkt3->RedirFlags & LB_USERNAME) {
                CHECK_ULONGLEN_STRING(pBuf, pEnd, pUserName, 
                    UserNameSize, LB_USERNAME);
            }

            if (pPkt3->RedirFlags & LB_DOMAIN) {
                CHECK_ULONGLEN_STRING(pBuf, pEnd, pDomain, 
                    DomainSize, LB_DOMAIN);
            }

            if (pPkt3->RedirFlags & LB_PASSWORD) {
                CHECK_ULONGLEN_STRING(pBuf, pEnd, pClearPassword, 
                    PasswordSize, LB_PASSWORD);
            }

            if (pPkt3->RedirFlags & LB_SMARTCARD_LOGON) {
                _pUi->UI_SetUseSmartcardLogon(TRUE);
            }

            if ((pPkt3->RedirFlags & LB_NOREDIRECT) != 0) {
                fNeedRedirect = FALSE;
            }

            if (UserNameSize > 0) {
                PBYTE pAlignedUserName = (PBYTE)LocalAlloc(LPTR,
                                                UserNameSize+sizeof(TCHAR));
                if (pAlignedUserName) {
                    memset(pAlignedUserName, 0, UserNameSize+sizeof(TCHAR));
                    memcpy(pAlignedUserName, pUserName, UserNameSize);
                    if (pPkt3->RedirFlags & LB_DONTSTOREUSERNAME) {
                        _pUi->UI_SetRedirectionUserName((LPTSTR)pAlignedUserName);
                    } else {
                        _pUi->UI_SetUserName((LPTSTR)pAlignedUserName);
                    }
                    LocalFree(pAlignedUserName);
                }
            }

            if (DomainSize > 0) {
                PBYTE pAlignedDomain = (PBYTE)LocalAlloc(LPTR,
                                                DomainSize+sizeof(TCHAR));
                if (pAlignedDomain) {
                    memset(pAlignedDomain, 0, DomainSize+sizeof(TCHAR));
                    memcpy(pAlignedDomain, pDomain, DomainSize);
                    _pUi->UI_SetDomain((LPTSTR)pAlignedDomain);
                    LocalFree(pAlignedDomain);
                }
            }

            if ((PasswordSize > 0) &&
                ((PasswordSize + sizeof(TCHAR)) <= UI_MAX_PASSWORD_LENGTH)) {
                PBYTE pAlignedClearPass = (PBYTE)LocalAlloc(LPTR,
                                                UI_MAX_PASSWORD_LENGTH);
                if (pAlignedClearPass) {
                    SecureZeroMemory(pAlignedClearPass, UI_MAX_PASSWORD_LENGTH);
                    memcpy(pAlignedClearPass, pClearPassword, PasswordSize);
                    BYTE Salt[UT_SALT_LENGTH];

                    //
                    // The password has to be stored in our internal 'obfuscated'
                    // format.
                    //
                    if(TSRNG_GenerateRandomBits(Salt, sizeof(Salt))) {
                        //Encrypt the password
                        if(EncryptDecryptLocalData50(pAlignedClearPass,
                                                 PasswordSize,
                                                 Salt, sizeof(Salt))) {
                            _pUi->UI_SetPassword( pAlignedClearPass );
                            _pUi->UI_SetSalt( Salt);
                        }
                        else {
                            TRC_ERR((TB,_T("Error encrytping password")));
                        }
                    }
                    else {
                        TRC_ERR((TB,_T("Error generating salt")));
                    }

                    //
                    // For security reasons clear the password field
                    //
                    SecureZeroMemory(pAlignedClearPass, PasswordSize+sizeof(TCHAR));
                    SecureZeroMemory(pClearPassword, PasswordSize);
                    LocalFree(pAlignedClearPass);

                    //
                    // Set the autologon flag
                    //
                    if (UserNameSize)
                    {
                        _pUi->_UI.fAutoLogon = TRUE;
                    }
                }
            }

            if (ServerNameSize > 0 && ServerNameSize <= sizeof(AlignedAddress)) {
                memcpy(AlignedAddress, ServerName, ServerNameSize);
        
                // Set the redir info in UI and disconnect.
                _pUi->UI_SetServerRedirectionInfo(pPkt3->SessionID, AlignedAddress, 
                    NULL, 0, fNeedRedirect);
            }
            else {
                // Set the redir info in UI and disconnect.  That LBInfo is going to
                // be there indicates to XT_SendCR that we are in the middle of
                // a redirect and should use the redirect info instead of scripting
                // or hash-mode cookie.
                _pUi->UI_SetServerRedirectionInfo(pPkt3->SessionID, 
                        _pUi->_UI.strAddress, LBInfo, LBInfoSize, fNeedRedirect);
            }
        }
        else {
            TRC_ERR((TB,_T("Unexpected redirection packet")));
        }
        if (fNeedRedirect) {
            CO_Disconnect();
        }
DC_EXIT_POINT:

    if (FAILED(hr) && IMMEDIATE_DISSCONNECT_ON_HR(hr)) {
        TRC_ABORT((TB, _T("Disconnect for security")));

        CO_DropLinkImmediate(SL_ERR_INVALIDPACKETFORMAT, hr);
    }

    DC_END_FN();
    return hr;
}


/****************************************************************************/
/* Name:      CO_OnBufferAvailable                                          */
/*                                                                          */
/* Purpose:   Handle BufferAvailable notification from SL.                  */
/****************************************************************************/
void DCCALLBACK CCO::CO_OnBufferAvailable()
{
    DC_BEGIN_FN("CO_OnBufferAvailable");

    // Tell the Sender Thread.
    _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT,
            _pSnd,
            CD_NOTIFICATION_FUNC(CSND,SND_BufferAvailable),
            (ULONG_PTR) 0);

    DC_END_FN();
} /* CO_OnBufferAvailable */

//
// CO_DropLinkImmediate
//
// Purpose: Immediately drops the link without doing a gracefull connection
//          shutdown (i.e. no DPUm is sent and we don't transition to the SND
//          thread at any point before dropping the link). Higher level components
//          will still get all the usual disconnect notifications so they can
//          be properly torn down.
//
//          This call was added to trigger an immediate disconnect in cases
//          where we detect invalid data that could be due to an attack, it
//          ensures we won't receive any more data after the call returns
//
// Params:  reason - SL disconnect reason code
//          hrDisconnect - hresult as to why the TSC_CORE wanted to disconnect
//
// Returns: HRESULT
// 
// Thread context: Call on RCV thread
//
HRESULT DCINTERNAL CCO::CO_DropLinkImmediate(UINT reason, HRESULT hrDisconnect ) 
{
    DC_BEGIN_FN("CO_DropLinkImmediate");
    
    HRESULT hr = E_FAIL;
    TRC_ASSERT((NULL != _pSl),
        (TB, _T("SL not connected can not drop immediate")));
    if (_pSl) {
        hr = _pSl->SL_DropLinkImmediate(reason);
    }

    COSetDisconnectHR(hrDisconnect);

    DC_END_FN();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\aco.h ===
/****************************************************************************/
// aco.h
//
// Core API header.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifndef _H_ACO
#define _H_ACO

extern "C" {
#include <adcgdata.h>
}

#include "autil.h"

class CUI;
class CSL;
class CUH;
class CRCV;
class CCD;
class CSND;
class CCC;
class CIH;
class COR;
class CSP;
class COP;
class CCM;


#include "objs.h"


/****************************************************************************/
/* Structure: CONNECTSTRUCT                                                 */
/*                                                                          */
/* Description: Structure of the data passed from the UI on connection      */
/****************************************************************************/
typedef struct tagCONNECTSTRUCT
{
    TCHAR RNSAddress[UT_MAX_ADDRESS_LENGTH];

#define CO_BITSPERPEL4   0
#define CO_BITSPERPEL8   1
#ifdef DC_HICOLOR
#define CO_BITSPERPEL15  2
#define CO_BITSPERPEL16  3
#define CO_BITSPERPEL24  4
#endif
    unsigned colorDepthID;

    UINT16 desktopWidth;
    UINT16 desktopHeight;

#define CO_TRANSPORT_TCP SL_TRANSPORT_TCP
    UINT16 transportType;
    UINT16 sasSequence;

    UINT32 keyboardLayout;
    UINT32 keyboardType;
    UINT32 keyboardSubType;
    UINT32 keyboardFunctionKey;
    TCHAR  imeFileName[TS_MAX_IMEFILENAME];

/****************************************************************************/
/* These flags are used to determine whether                                */
/* - the Shadow Bitmap is to be enabled                                     */
/* - we are running on a dedicated terminal.                                */
/* This will be used by UH to determine whether to enable SSB orders.       */
/****************************************************************************/
#define CO_CONN_FLAG_SHADOW_BITMAP_ENABLED 1
#define CO_CONN_FLAG_DEDICATED_TERMINAL    2
    UINT32 connectFlags;

    //-------------------------------------------------------------------------
    // These timer handles are used for managing connection timeout.
    //
    // hSingleConnectTimer: the single connection timer
    // hConnectionTimer: the overall connection timer
    // hLicensingTimer: the licensing phase timer
    //-------------------------------------------------------------------------
    HANDLE   hSingleConnectTimer;
    HANDLE   hConnectionTimer;
    HANDLE   hLicensingTimer;

    BOOL bInitiateConnect;
    
} CONNECTSTRUCT, FAR *PCONNECTSTRUCT;


/****************************************************************************/
/* Window message used to notify the UI that the desktop size has changed.  */
/* The new size is passed as                                                */
/*                                                                          */
/*     width  = LOWORD(lParam)                                              */
/*     height = HIWORD(lParam)                                              */
/****************************************************************************/
#define WM_DESKTOPSIZECHANGE    (DUC_CO_MESSAGE_BASE + 1)


/****************************************************************************/
/* Configuration items/values                                               */
/*                                                                          */
/* CO_CFG_ACCELERATOR_PASSTHROUGH:                                          */
/*    0: Disabled                                                           */
/*    1: Enabled                                                            */
/*                                                                          */
/* CO_CFG_SHADOW_BITMAP:                                                    */
/*    0: Disabled                                                           */
/*    1: Enabled                                                            */
/*                                                                          */
/* CO_CFG_ENCRYPTION:                                                       */
/*    0: Disabled                                                           */
/*    1: Enabled                                                            */
/*                                                                          */
/* CO_CFG_SCREEN_MODE_HOTKEY                                                */
/*    VKCode                                                                */
/*                                                                          */
/* CO_CFG_DEBUG_SETTINGS:                                                   */
/*    A combination of zero or more of the following flags                  */
/*      CO_CFG_FLAG_HATCH_BITMAP_PDU_DATA:   BitmapPDU data                 */
/*      CO_CFG_FLAG_HATCH_MEMBLT_ORDER_DATA: MemBlt order data              */
/*      CO_CFG_FLAG_LABEL_MEMBLT_ORDERS:     Label MemBlt orders            */
/*      CO_CFG_FLAG_BITMAP_CACHE_MONITOR:    Show Bitmap Cache Monitor      */
/****************************************************************************/
#define CO_CFG_ACCELERATOR_PASSTHROUGH  0
#define CO_CFG_SHADOW_BITMAP            1
#define CO_CFG_ENCRYPTION               2
#define CO_CFG_SCREEN_MODE_HOTKEY       3


#ifdef DC_DEBUG
#define CO_CFG_DEBUG_SETTINGS           100
#define    CO_CFG_FLAG_HATCH_BITMAP_PDU_DATA    1
#define    CO_CFG_FLAG_HATCH_MEMBLT_ORDER_DATA  2
#define    CO_CFG_FLAG_LABEL_MEMBLT_ORDERS      4
#define    CO_CFG_FLAG_BITMAP_CACHE_MONITOR     8
#define    CO_CFG_FLAG_HATCH_SSB_ORDER_DATA     16
#define    CO_CFG_FLAG_HATCH_INDEX_PDU_DATA     32
#endif /* DC_DEBUG */

#ifdef DC_DEBUG
#define CO_CFG_MALLOC_FAILURE         200
#define CO_CFG_MALLOC_HUGE_FAILURE    201
#endif /* DC_DEBUG */

#define CO_SHUTDOWN                 0x70
#define CO_DISCONNECT_AND_EXIT      0x71


/****************************************************************************/
/* Structure: CO_GLOBAL_DATA                                                */
/*                                                                          */
/* Description: Variables that need to be shared across the whole of the    */
/*              Core                                                        */
/****************************************************************************/
typedef struct tagCO_GLOBAL_DATA
{
    UT_THREAD_DATA sendThreadID;
    WNDPROC        pUIContainerWndProc;
    WNDPROC        pUIMainWndProc;
    BOOL           inSizeMove;
} CO_GLOBAL_DATA;


extern "C" {
    VOID WINAPI CO_StaticInit(HINSTANCE hInstance);
    VOID WINAPI CO_StaticTerm();
};

#define MAX_DISSCONNECT_HRS 10

class CCO
{
public:

    CCO(CObjs* objs);
    virtual ~CCO();

    /****************************************************************************/
    /* API functions                                                            */
    /****************************************************************************/
    
    void DCAPI CO_Init(HINSTANCE, HWND, HWND);
    void DCAPI CO_Term();
    void DCAPI CO_Connect(PCONNECTSTRUCT);

    void DCAPI CO_Disconnect();
    void DCAPI CO_Shutdown(unsigned);
    HRESULT DCAPI CO_OnSaveSessionInfoPDU(
        PTS_SAVE_SESSION_INFO_PDU_DATA, DCUINT);
    HRESULT DCAPI CO_OnSetKeyboardIndicatorsPDU(
        PTS_SET_KEYBOARD_INDICATORS_PDU, DCUINT);
    
    void DCAPI CO_SetConfigurationValue(unsigned, unsigned);
    
    void DCAPI CO_SetHotkey(PDCHOTKEY);
    
    HRESULT DCAPI CO_OnServerRedirectionPacket(
            RDP_SERVER_REDIRECTION_PACKET UNALIGNED *, DCUINT);

    #ifdef DC_DEBUG
    int DCAPI CO_GetRandomFailureItem(unsigned);
    void DCAPI CO_SetRandomFailureItem(unsigned, int);
    #endif
    
    //
    // callbacks
    //
    void DCCALLBACK CO_OnInitialized();

    void DCCALLBACK CO_OnTerminating();
    
    void DCCALLBACK CO_OnConnected(unsigned, PVOID, unsigned, UINT32);

   
    void DCCALLBACK CO_OnDisconnected(unsigned);
    
    HRESULT DCCALLBACK CO_OnPacketReceived(PBYTE, unsigned, unsigned, unsigned, unsigned);
    
    void DCCALLBACK CO_OnBufferAvailable();

    HRESULT DCAPI CO_OnFastPathOutputReceived(BYTE FAR *, unsigned);


    //
    // Static inline versions
    //
    static void DCCALLBACK CO_StaticOnInitialized(PVOID inst)
    {
        ((CCO*)inst)->CO_OnInitialized();
    }

    static void DCCALLBACK CO_StaticOnTerminating(PVOID inst)
    {
        ((CCO*)inst)->CO_OnTerminating();
    }
   
    static void DCCALLBACK CO_StaticOnConnected(
            PVOID inst,
            unsigned channelID,
            PVOID pUserData,
            unsigned userDataLength,
            UINT32 serverVersion)
    {
        ((CCO*)inst)->CO_OnConnected(channelID, pUserData, userDataLength, serverVersion);
    }
    
    static void DCCALLBACK CO_StaticOnDisconnected(PVOID inst, unsigned result)
    {
        ((CCO*)inst)->CO_OnDisconnected(result);
    }
    
    static HRESULT DCCALLBACK CO_StaticOnPacketReceived(
            PVOID inst,
            PBYTE pData,
            unsigned dataLen,
            unsigned flags,
            unsigned channelID,
            unsigned priority)
    {
        return ((CCO*)inst)->CO_OnPacketReceived(pData, dataLen, flags, channelID, priority);
    }
    
    static void DCCALLBACK CO_StaticOnBufferAvailable(PVOID inst)
    {
        ((CCO*)inst)->CO_OnBufferAvailable();
    }

    HRESULT DCINTERNAL CO_DropLinkImmediate(UINT reason, HRESULT hrDisconnect );

public:
    //
    // Public data members
    //
    CO_GLOBAL_DATA _CO;

private:

    LRESULT CALLBACK COContainerWindowSubclassProc( HWND hwnd,
                                                UINT message,
                                                WPARAM wParam,
                                                LPARAM lParam );
    
    LRESULT CALLBACK COMainWindowSubclassProc( HWND hwnd,
                                           UINT message,
                                           WPARAM wParam,
                                           LPARAM lParam );

    
    //
    // Static versions that delegate to appropriate instance
    //
    static LRESULT CALLBACK COStaticContainerWindowSubclassProc( HWND hwnd,
                                            UINT message,
                                            WPARAM wParam,
                                            LPARAM lParam );

    static LRESULT CALLBACK COStaticMainWindowSubclassProc( HWND hwnd,
                                       UINT message,
                                       WPARAM wParam,
                                       LPARAM lParam );


    void DCINTERNAL COSubclassUIWindows();
    
private:
    CUT* _pUt;
    CUI* _pUi;
    CSL* _pSl;
    CUH* _pUh;
    CRCV* _pRcv;

    CCD* _pCd;
    CSND* _pSnd;
    CCC* _pCc;
    CIH* _pIh;
    COR* _pOr;
    CSP* _pSp;
    COP* _pOp;
    CCM* _pCm;
    CCLX* _pClx;

private:
    CObjs* _pClientObjects;
    BOOL   _fCOInitComplete;

    HRESULT m_disconnectHRs[ MAX_DISSCONNECT_HRS ];
    short   m_disconnectHRIndex;

public:
    inline void DCINTERNAL COSetDisconnectHR( HRESULT hr ) {
        m_disconnectHRs[m_disconnectHRIndex] = hr;
        m_disconnectHRIndex = (m_disconnectHRIndex + 1) % MAX_DISSCONNECT_HRS;
    }
};



#endif // _H_ACO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\adcg.h ===
/**INC+**********************************************************************/
/* Header:    adcg.h                                                        */
/*                                                                          */
/* Purpose:   Precompiled header                                            */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/*                                                                          */
/** Changes:
 * $Log:   Y:/logs/client/adcg.h_v  $
 * 
 *    Rev 1.4   03 Jul 1997 11:58:58   AK
 * SFR0000: Initial development completed
 * 
**/
/**INC-**********************************************************************/

#include <adcgbase.h>

//
// uwrap has to come after the headers for ANY wrapped
// functions
//
#ifdef UNIWRAP
#include "uwrap.h"
#endif

#include <strsafe.h>

#ifdef __cplusplus

#define TRC_DBG(string)
#define TRC_NRM(string)
#define TRC_ALT(string)
#define TRC_ERR(string)
#define TRC_ASSERT(condition, string)
#define TRC_ABORT(string)
#define TRC_SYSTEM_ERROR(string)
#define TRC_FN(string)
#define TRC_ENTRY
#define TRC_EXIT
#define TRC_DATA_DBG

#ifdef USE_GDIPLUS
#include <gdiplus.h>
#endif USE_GDIPLUS   

#include "wui.h"
#include "autil.h"
#include "objs.h"

#include "aco.h"
#include "snd.h"
#include "cd.h"
#include "rcv.h"

#include "cc.h"
#include "ih.h"

#include "or.h"
#include "fs.h"
#include "sl.h"
#include "nl.h"
#include "nc.h"
#include "mcs.h"

#include "clicense.h"
#include "xt.h"
#include "td.h"
#include "cm.h"
#include "uh.h"
#include "gh.h"
#include "od.h"
#include "op.h"
#include "sp.h"
#include "clx.h"
#include "cchan.h"

#include "tscerrs.h"

#include "axresrc.h"

//
// Cicero Substitute Keyboard Layout Support
//
#ifndef OS_WINCE
#include <cicsthkl.h>
#endif

    
#undef TRC_DBG
#undef TRC_NRM
#undef TRC_ALT
#undef TRC_ERR
#undef TRC_ASSERT
#undef TRC_ABORT
#undef TRC_SYSTEM_ERROR
#undef TRC_FN
#undef TRC_ENTRY
#undef TRC_EXIT
#undef TRC_DATA_DBG

#endif

#ifdef OS_WINCE
//CE doesn't support StretchDiBits
#undef SMART_SIZING

#ifndef INVALID_SET_FILE_POINTER
#define INVALID_SET_FILE_POINTER ((DWORD)-1)
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\abdapi.h ===
/****************************************************************************/
/* abdapi.h                                                                 */
/*                                                                          */
/* Bitmap Decompression API header file                                     */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1999                             */
/****************************************************************************/
#ifndef _H_ABDAPI
#define _H_ABDAPI

/****************************************************************************/
/* RLE codes                                                                */
/****************************************************************************/
/*                                                                          */
/* The following codes fill a full single byte address space.  The approach */
/* is to use the high order bits to identify the code type and the low      */
/* order bits to encode the length of the associated run.  There are two    */
/* forms of order                                                           */
/* - regular orders which have a 5 bit length field (31 bytes of data)      */
/* - "lite" orders with a 4 bit length                                      */
/*                                                                          */
/* A value of 0 in the length field indicates an extended length, where     */
/* the following byte contains the length of the data.  There is also a     */
/* "mega mega" form which has a two byte length field. (See end of          */
/* codespace of the codes that define the megamega form).                   */
/*                                                                          */
/* A set of codes at the high end of the address space is used to encode    */
/* commonly occuring short sequences, in particular                         */
/* - certain single byte FGBG codings                                       */
/* - single bytes of BLACK and WHITE                                        */
/*                                                                          */
/*                                                                          */
/* SUMMARY                                                                  */
/* *******                                                                  */
/*                      7 6 5 4 3 2 1 0  76543210  76543210  76543210       */
/*                                                                          */
/* MEGA_BG_RUN          0 0 0 0 0 0 0 0  <length>                           */
/*                                                                          */
/* BG_RUN               0 0 0 <length->                                     */
/*                                                                          */
/* MEGA_FG_RUN          0 0 1 0 0 0 0 0  <length>                           */
/*                                                                          */
/* FG_RUN               0 0 1 <length->                                     */
/*                                                                          */
/* MEGA_FG_BG_IMAGE     0 1 0 0 0 0 0 0  <length>  <-data->  ...            */
/*                                                                          */
/* FG_BG_IMAGE          0 1 0 <length->  <-data->  ...                      */
/*                                                                          */
/* MEGA_COLOR_RUN       0 1 1 0 0 0 0 0  <length>  <-color>                 */
/*                                                                          */
/* COLOR_RUN            0 1 1 <length->  <color->                           */
/*                                                                          */
/* MEGA_COLOR_IMAGE     1 0 0 0 0 0 0 0  <length>  <-data->  ...            */
/*                                                                          */
/* COLOR_IMAGE          1 0 0 <length->  <-data->  ...                      */
/*                                                                          */
/* MEGA_PACKED_CLR_IMG  1 0 1 0 0 0 0 0  <length>  <-data->  ...            */
/*                                                                          */
/* PACKED COLOR IMAGE   1 0 1 <length->  <-data->  ...                      */
/*                                                                          */
/* SET_FG_MEGA_FG_RUN   1 1 0 0 0 0 0 0  <length>  <-color>                 */
/*                                                                          */
/* SET_FG_FG_RUN        1 1 0 0 <-len->  <color->                           */
/*                                                                          */
/* SET_FG_MEGA_FG_BG    1 1 0 1 0 0 0 0  <length>  <-color>  <-data->  ...  */
/*                                                                          */
/* SET_FG_FG_BG         1 1 0 1 <-len->  <color->  <-data->  ...            */
/*                                                                          */
/* MEGA_DITHERED_RUN    1 1 1 0 0 0 0 0  <length>  <-data->  <-data->       */
/*                                                                          */
/* DITHERED_RUN         1 1 1 0 <-len->  <-data->  <-data->                 */
/*                                                                          */
/* MEGA_MEGA_BG_RUN     1 1 1 1 0 0 0 0                                     */
/*                                                                          */
/* MEGA_MEGA_FG_RUN     1 1 1 1 0 0 0 1                                     */
/*                                                                          */
/* MEGA_MEGA_FGBG       1 1 1 1 0 0 1 0                                     */
/*                                                                          */
/* MEGA_MEGA_COLOR_RUN  1 1 1 1 0 0 1 1                                     */
/*                                                                          */
/* MEGA_MEGA_CLR_IMG    1 1 1 1 0 1 0 0                                     */
/*                                                                          */
/* MEGA_MEGA_PACKED_CLR 1 1 1 1 0 1 0 1                                     */
/*                                                                          */
/* MEGA_MEGA_SET_FG_RUN 1 1 1 1 0 1 1 0                                     */
/*                                                                          */
/* MEGA_MEGA_SET_FGBG   1 1 1 1 0 1 1 1                                     */
/*                                                                          */
/* MEGA_MEGA_DITHER     1 1 1 1 1 0 0 0                                     */
/*                                                                          */
/* Special FGBG code 1  1 1 1 1 1 0 0 1  FGBG code 0x03 = 11000000          */
/* (Note that 0x01 will generally handled by the single pel insertion code) */
/*                                                                          */
/* Special FBBG code 2  1 1 1 1 1 0 1 0  FGBG code 0x05 = 10100000          */
/*                                                                          */
/* Special FBBG code 3  1 1 1 1 1 0 1 1  FGBG code 0x07 = 11100000          */
/*                                                                          */
/* Special FBBG code 4  1 1 1 1 1 1 0 0  FGBG code 0x0F = 11110000          */
/*                                                                          */
/* BLACK                1 1 1 1 1 1 0 1                                     */
/*                                                                          */
/* WHITE                1 1 1 1 1 1 1 0                                     */
/*                                                                          */
/* START_LOSSY          1 1 1 1 1 1 1 1                                     */
/*                                                                          */
/*                                                                          */
/****************************************************************************/
/* GENERAL NOTES                                                            */
/****************************************************************************/
/*                                                                          */
/* - For MEGA runs the length encoded is the length of the run minus the    */
/*   maximum length of the non-mega form.                                   */
/*   In  the mega-mega form we encode the plain 16 bit length, to keep      */
/*   encoding/deconding simple.                                             */
/*                                                                          */
/* - The sequence BG_RUN,BG_RUN is not exactly what it appears.  We         */
/*   use the fact that this is not generated in normal encoding to          */
/*   encode <n background><1 foreground><n background>.  The same pel       */
/*   insertion convention applies to any combination of MEGA_BG run and     */
/*   BG_RUN                                                                 */
/*                                                                          */
/* - A packed image is encoded when we find that all the color fields in a  */
/*   run have 0 in the high order nibble. We do not currently use this code */
/*   for 8 bit compression, but it is supported by the V2 decoder.          */
/*                                                                          */
/* - The set fg color code (Used to exist in V1) has been retired in favor  */
/*   of separate commands for those codes that may embed a color.  Generally*/
/*   This saves one byte for every foreground color transition for 8bpp.    */
/*                                                                          */
/* - The color run code is new for V2.  It indicates a color run where the  */
/*   XOR is not performed.  This applies to, for example, the line of bits  */
/*   immediately below a text line.  (There is no special case for runs of  */
/*   the bg color - these are treated as any other color run.)              */
/*                                                                          */
/* - Observation shows a high occurrence of BG runs split by single FGBG    */
/*   codes.  In decreasing probability these are 3,5,7,9,f,11,1f,3f (1 is   */
/*   handled by the implicit BG run break). Save 1 byte by encoding as      */
/*   single codes                                                           */
/*                                                                          */
/* - There is a relatively high occurrence of single pel color codes ff and */
/*   00.  Save 1 byte by encoding as special characters                     */
/*                                                                          */
/* - The length in a FGBG run is slightly strange.  Because they generally  */
/*   occur in multiples of 8 bytes we get a big saving if we encode the     */
/*   length of a short run as length/8.  However, for those special         */
/*   cases where the length is not a multiple of 8 we encode a long run.    */
/*   Therefore the long form can only cover the range 1-256 bytes.          */
/*   beyond that we use the mega-mega form.                                 */
/*                                                                          */
/****************************************************************************/
/* DETAILS OF COMPRESSION CODES                                             */
/****************************************************************************/
/*                                                                          */
/* BG_RUN                                                                   */
/*                                                                          */
/* Represents a background run (black:0) of the specified length.           */
/*                                                                          */
/****************************************************************************/
/*                                                                          */
/* FG_BG_IMAGE/SET_FG_FG_BG_IMAGE                                           */
/*                                                                          */
/* Represents a binary image containing only the current foreground(1) and  */
/* background(0) colors.                                                    */
/*                                                                          */
/****************************************************************************/
/*                                                                          */
/* FG_RUN/SET_FG_FG_RUN                                                     */
/*                                                                          */
/* Represents a continuous foreground run of the specified length.          */
/* The foreground color is white by default, and is changed by the          */
/* SET_FG_FG_RUN version of this code.                                      */
/*                                                                          */
/****************************************************************************/
/*                                                                          */
/* DITHERED_RUN                                                             */
/*                                                                          */
/* Represents a run of alternating colors of the specified length.          */
/*                                                                          */
/****************************************************************************/
/*                                                                          */
/* COLOR_IMAGE                                                              */
/*                                                                          */
/* Represents a color image of the specified length.  No XOR is performed.  */
/* This data is uncompressed, so we hope that we won't see                  */
/* many of these codes!                                                     */
/*                                                                          */
/****************************************************************************/
/*                                                                          */
/* COLOR_RUN                                                                */
/*                                                                          */
/* Represents a color run of the specified length.  No XOR is performed.    */
/* Since the color is not XORed, it is unlikely to match the running        */
/* foreground color information.  Therefore this code always carries a      */
/* color byte and there is no SET_FG_COLOR_RUN form of the code.            */
/*                                                                          */
/****************************************************************************/
/*                                                                          */
/* PACKED_COLOR_IMAGE                                                       */
/*                                                                          */
/* Represents a color image of the specified length, with pairs of colors   */
/* packed into a single byte.  (This can only be done when the color info   */
/* is zero in the high order nibble.)                                       */
/*                                                                          */
/****************************************************************************/
/*                                                                          */
/* START_LOSSY                                                              */
/*                                                                          */
/* Informs the decoder that lossy mode has been established and any of the  */
/* following color runs will need pixel doubling performing.                */
/* RLE decoding will remain in this mode until the end of this block        */
/*                                                                          */
/****************************************************************************/

#define CODE_MASK                   0xE0
#define CODE_MASK_LITE              0xF0

#define CODE_BG_RUN                 0x00   /* 20 */
#define CODE_FG_RUN                 0x20   /* 20 */
#define CODE_FG_BG_IMAGE            0x40   /* 20 */
#define CODE_COLOR_RUN              0x60   /* 20 */
#define CODE_COLOR_IMAGE            0x80   /* 20 */
#ifndef DC_HICOLOR
#define CODE_PACKED_COLOR_IMAGE     0xA0   /* 20 */
#endif
#define CODE_SET_FG_FG_RUN          0xC0   /* 10 */
#define CODE_SET_FG_FG_BG           0xD0   /* 10 */
#define CODE_DITHERED_RUN           0xE0   /* 10 */
#define CODE_MEGA_MEGA_BG_RUN       0xF0
#define CODE_MEGA_MEGA_FG_RUN       0xF1
#define CODE_MEGA_MEGA_FGBG         0xF2
#define CODE_MEGA_MEGA_COLOR_RUN    0xF3
#define CODE_MEGA_MEGA_CLR_IMG      0xF4
#ifndef DC_HICOLOR
#define CODE_MEGA_MEGA_PACKED_CLR   0xF5
#endif
#define CODE_MEGA_MEGA_SET_FG_RUN   0xF6
#define CODE_MEGA_MEGA_SET_FGBG     0xF7
#define CODE_MEGA_MEGA_DITHER       0xF8
#define CODE_SPECIAL_FGBG_1         0xF9
#define CODE_SPECIAL_FGBG_2         0xFA

#ifndef DC_HICOLOR
#define CODE_SPECIAL_FGBG_3         0xFB
#define CODE_SPECIAL_FGBG_4         0xFC
#endif
#define CODE_WHITE                  0xFD
#define CODE_BLACK                  0xFE
#define CODE_START_LOSSY            0xFF

#define MAX_LENGTH_ORDER            31
#define MAX_LENGTH_LONG_ORDER       287

#define MAX_LENGTH_ORDER_LITE       15
#define MAX_LENGTH_LONG_ORDER_LITE  271

#define MAX_LENGTH_FGBG_ORDER       (31*8)
#define MAX_LENGTH_FGBG_ORDER_LITE  (15*8)
#define MAX_LENGTH_LONG_FGBG_ORDER  255

/****************************************************************************/
/* The special FGBG codes that correspond to codes F0-F7                    */
/****************************************************************************/
#define SPECIAL_FGBG_CODE_1         0x03
#define SPECIAL_FGBG_CODE_2         0x05
#define SPECIAL_FGBG_CODE_3         0x07
#define SPECIAL_FGBG_CODE_4         0x0F

/****************************************************************************/
/*                                                                          */
/* TYPES                                                                    */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* The Compressed Data header structure.                                    */
/****************************************************************************/
typedef struct _CD_HEADER
{
    DCUINT16    cbCompFirstRowSize;
    DCUINT16    cbCompMainBodySize;
    DCUINT16    cbScanWidth;
    DCUINT16    cbUncompressedSize;
} CD_HEADER;
typedef CD_HEADER *PCD_HEADER;

/****************************************************************************/
/*                                                                          */
/* FUNCTIONS                                                                */
/*                                                                          */
/****************************************************************************/
HRESULT DCAPI BD_DecompressBitmap( PDCUINT8  pCompressedData,
                                  PDCUINT8  pDstBitmap,
                                  DCUINT    srcDataSize,
                                  DCUINT    dstBufferSize,
                                  DCUINT    noBCHeader,
                                  DCUINT8   bitmapBitsPerPel,
                                  DCUINT16  bitmapWidth,
                                  DCUINT16  bitmapHeight );

#endif /* H_ABDAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\abdapi.cpp ===
/****************************************************************************/
/* abdapi.cpp                                                               */
/*                                                                          */
/* Bitmap Decompression API functions                                       */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1996-1999                             */
/****************************************************************************/

#include <adcg.h>
extern "C" {
#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "abdapi"
#include <atrcapi.h>
}
#define TSC_HR_FILEID TSC_HR_ABDAPI_CPP

#include <abdapi.h>

/****************************************************************************/
/*                                                                          */
/* See abdapi.h for descriptions of compression codes.                      */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* We shouldn't have OS_WINDOWS macros in an "a" file, but this file        */
/* generates lots of "conditional expression is constant" warnings due      */
/* to the optimised nature of the code (lots of macros).                    */
/*                                                                          */
/* The pragmatic (no pun intended) solution to this is to disable this      */
/* warning for the whole file in a way that won't affect other OSs.         */
/****************************************************************************/
#ifdef OS_WINDOWS
#pragma warning (push)
#pragma warning (disable: 4127)
#endif


/****************************************************************************/
/* Name:      BDMemcpy                                                      */
/*                                                                          */
/* Purpose:   Copies a given number of bytes from source to destination.    */
/*            Source and destination may overlap, but copy is always        */
/*            performed upwards (from start address onwards).               */
/*                                                                          */
/* Params:    pDst - pointer to destination                                 */
/*            pSrc - pointer to source data                                 */
/*            count - number of bytes to copy                               */
/****************************************************************************/
_inline DCVOID DCINTERNAL BDMemcpy(PDCUINT8 pDst, PDCUINT8 pSrc, DCUINT count)
{
#if defined(DC_DEBUG) || defined(DC_NO_UNALIGNED) || defined(_M_IA64)
    DCUINT      i;
#endif

    DC_BEGIN_FN("BDMemcpy");

    /************************************************************************/
    /* Bitmap decompression deliberately does overlapped memcpys, e.g.      */
    /* from the previous bitmap row to the current bitmap row for more than */
    /* one row.                                                             */
    /*                                                                      */
    /* When using the intrinsic memcpy (in the retail build) this works     */
    /* fine (in the current implementation of the MS compiler), as the copy */
    /* always goes upwards through memory.  However, if we use the MSVC     */
    /* run-time library (in the debug build) then memcpy appears to check   */
    /* for overlap and performs the copy so as to avoid clashing of src and */
    /* dst (i.e.  effectively performs a memmove).  Therefore this does not */
    /* do what we want, so manually copy the bytes in a debug build.        */
    /*                                                                      */
    /* This solution is a little unsatisfactory, as the operation of memset */
    /* is officially undefined, but the performance-critical nature of      */
    /* this bit of code means that we really do want to use a memcpy.       */
    /*                                                                      */
    /* For non-Intel platforms, cannot rely on the above - so always use    */
    /* manual version.                                                      */
    /*                                                                      */
    /************************************************************************/

#if defined(DC_DEBUG) || defined(DC_NO_UNALIGNED) || defined(_M_IA64)
    /************************************************************************/
    /* Debug build implementation.                                          */
    /************************************************************************/
    for (i = 0; i < count; i++)
    {
        *pDst++ = *pSrc++;
    }
#else
    /************************************************************************/
    /* Retail build implementation.                                         */
    /************************************************************************/
    DC_MEMCPY(pDst, pSrc, count);
#endif

    DC_END_FN();
    return;
}

/****************************************************************************/
/* Utility macros for decoding codes                                        */
/****************************************************************************/
#define BD_CHECK_READ_ONE_BYTE(pBuffer, pEnd, hr )     \
    CHECK_READ_ONE_BYTE(pBuffer, pEnd, hr, \
        (TB, _T("Decompress reads one byte end of buffer; [p=0x%x pEnd=0x%x]"), \
        (pBuffer), (pEnd) ))

#define BD_CHECK_READ_ONE_BYTE_2ENDED(pBuffer, pStart, pEnd, hr )     \
    CHECK_READ_ONE_BYTE_2ENDED(pBuffer, pStart, pEnd, hr, (TB, _T("Decompress reads one byte off end of buffer; [p=0x%x pStart=0x%x pEnd=0x%x]"), \
        (pBuffer), (pStart), (pEnd) ))

#define BD_CHECK_WRITE_ONE_BYTE(pBuffer, pEnd, hr )     \
    CHECK_WRITE_ONE_BYTE(pBuffer, pEnd, hr, (TB, _T("Decompress writes one byte off end of buffer; [p=0x%x pEnd=0x%x]"), \
        (pBuffer), (pEnd) ))

#define BD_CHECK_READ_N_BYTES(pBuffer, pEnd, N, hr )     \
    CHECK_READ_N_BYTES(pBuffer, pEnd, N, hr, (TB, _T("Decompress reads off end of buffer; [p=0x%x pEnd=0x%x N=%u]"), \
        (pBuffer), (pEnd), (ULONG)(N)))

#define BD_CHECK_READ_N_BYTES_2ENDED(pBuffer, pStart, pEnd, N, hr )     \
    CHECK_READ_N_BYTES_2ENDED(pBuffer, pStart, pEnd, N, hr, (TB, _T("Decompress reads off end of buffer; [p=0x%x pStart=0x%x pEnd=0x%x N=%u]"), \
        (pBuffer), (pStart), (pEnd), (ULONG)(N) ))

#define BD_CHECK_WRITE_N_BYTES(pBuffer, pEnd, N, hr )     \
    CHECK_WRITE_N_BYTES(pBuffer, pEnd, N, hr, (TB, _T("Decompress write off end of buffer; [p=0x%x pEnd=0x%x N=%u]"), \
        (pBuffer), (pEnd), (ULONG)(N)))
    
/****************************************************************************/
/* Macros to extract the length from order codes                            */
/****************************************************************************/
#define EXTRACT_LENGTH(pBuffer, pEnd, length, hr)                                      \
        BD_CHECK_READ_ONE_BYTE(pBuffer, pEnd, hr )         \
        length = *pBuffer++ & MAX_LENGTH_ORDER; \
        if (length == 0)                                                \
        {      \
            BD_CHECK_READ_ONE_BYTE(pBuffer, pEnd, hr )         \
            length = *pBuffer++ + MAX_LENGTH_ORDER + 1;                      \
        }

#define EXTRACT_LENGTH_LITE(pBuffer, pEnd, length, hr )                                 \
        BD_CHECK_READ_ONE_BYTE(pBuffer, pEnd, hr )         \
        length = *pBuffer++ & MAX_LENGTH_ORDER_LITE;                         \
        if (length == 0)                                                     \
        {                                                                    \
            BD_CHECK_READ_ONE_BYTE(pBuffer, pEnd, hr )         \
            length = *pBuffer++ + MAX_LENGTH_ORDER_LITE + 1;                 \
        }

#define EXTRACT_LENGTH_FGBG(pBuffer, pEnd, length, hr )                                 \
        BD_CHECK_READ_ONE_BYTE(pBuffer, pEnd, hr )         \
        length = *pBuffer++ & MAX_LENGTH_ORDER;                              \
        if (length == 0)                                                     \
        {                                                                    \
            BD_CHECK_READ_ONE_BYTE(pBuffer, pEnd, hr )         \
            length = *pBuffer++ + 1;                                         \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            length = length << 3;                                            \
        }

#define EXTRACT_LENGTH_FGBG_LITE(pBuffer, pEnd, length, hr)                            \
        BD_CHECK_READ_ONE_BYTE(pBuffer, pEnd, hr )         \
        length = *pBuffer++ & MAX_LENGTH_ORDER_LITE;                         \
        if (length == 0)                                                     \
        {                                                                    \
            BD_CHECK_READ_ONE_BYTE(pBuffer, pEnd, hr )         \
            length = *pBuffer++ + 1;                                         \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            length = length << 3;                                            \
        }

/****************************************************************************/
/* Macro to store an FGBG image                                             */
/* This macro expects that the function defines pDst, pEndDst, hr           */
/* If there is not enough data to write the full run, this will set error   */
/* and quit                                                                 */
/****************************************************************************/
#define STORE_FGBG(xorbyte, fgbgChar, fgChar, bits)                          \
{                                                                            \
    DCUINT   numbits = bits;                                                 \
    BD_CHECK_WRITE_N_BYTES( pDst, pEndDst, max(1, min(numbits, 8)), hr )           \
    if (fgbgChar & 0x01)                                                     \
    {                                                                        \
        *pDst++ = (DCUINT8)(xorbyte ^ fgChar);                               \
    }                                                                        \
    else                                                                     \
    {                                                                        \
        *pDst++ = xorbyte;                                                   \
    }                                                                        \
    if (--numbits > 0)                                                       \
    {                                                                        \
      if (fgbgChar & 0x02)                                                   \
      {                                                                      \
          *pDst++ = (DCUINT8)(xorbyte ^ fgChar);                             \
      }                                                                      \
      else                                                                   \
      {                                                                      \
          *pDst++ = xorbyte;                                                 \
      }                                                                      \
      if (--numbits > 0)                                                     \
      {                                                                      \
        if (fgbgChar & 0x04)                                                 \
        {                                                                    \
            *pDst++ = (DCUINT8)(xorbyte ^ fgChar);                           \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            *pDst++ = xorbyte;                                               \
        }                                                                    \
        if (--numbits > 0)                                                   \
        {                                                                    \
          if (fgbgChar & 0x08)                                               \
          {                                                                  \
              *pDst++ = (DCUINT8)(xorbyte ^ fgChar);                         \
          }                                                                  \
          else                                                               \
          {                                                                  \
              *pDst++ = xorbyte;                                             \
          }                                                                  \
          if (--numbits > 0)                                                 \
          {                                                                  \
            if (fgbgChar & 0x10)                                             \
            {                                                                \
                *pDst++ = (DCUINT8)(xorbyte ^ fgChar);                       \
            }                                                                \
            else                                                             \
            {                                                                \
                *pDst++ = xorbyte;                                           \
            }                                                                \
            if (--numbits > 0)                                               \
            {                                                                \
              if (fgbgChar & 0x20)                                           \
              {                                                              \
                  *pDst++ = (DCUINT8)(xorbyte ^ fgChar);                     \
              }                                                              \
              else                                                           \
              {                                                              \
                  *pDst++ = xorbyte;                                         \
              }                                                              \
              if (--numbits > 0)                                             \
              {                                                              \
                if (fgbgChar & 0x40)                                         \
                {                                                            \
                    *pDst++ = (DCUINT8)(xorbyte ^ fgChar);                   \
                }                                                            \
                else                                                         \
                {                                                            \
                    *pDst++ = xorbyte;                                       \
                }                                                            \
                if (--numbits > 0)                                           \
                {                                                            \
                  if (fgbgChar & 0x80)                                       \
                  {                                                          \
                      *pDst++ = (DCUINT8)(xorbyte ^ fgChar);                 \
                  }                                                          \
                  else                                                       \
                  {                                                          \
                      *pDst++ = xorbyte;                                     \
                  }                                                          \
                }                                                            \
              }                                                              \
            }                                                                \
          }                                                                  \
        }                                                                    \
      }                                                                      \
    }                                                                        \
}

#ifdef DC_HICOLOR
/****************************************************************************/
/* 8bpp decompression                                                       */
/****************************************************************************/
_inline HRESULT DCAPI BDDecompressBitmap8( PDCUINT8  pSrc,
                                          PDCUINT8  pDstBuffer,
                                          DCUINT    compressedDataSize,
                                          DCUINT    dstBufferSize,
                                          DCUINT8   bitmapBitsPerPel,
                                          DCUINT16  rowDelta)
{
    HRESULT hr = S_OK;
    DCUINT     codeLength;
    DCUINT8    codeByte;
    DCUINT8    codeByte2;
    DCUINT8    decode;
    DCUINT8    decodeLite;
    DCUINT8    decodeMega;
    DCUINT8    fgChar;
    PDCUINT8   pDst;
    PDCUINT8   pEndSrc;
    PDCUINT8   pEndDst;
    DCBOOL     backgroundNeedsPel;
    DCBOOL     firstLine;
    UNREFERENCED_PARAMETER( bitmapBitsPerPel);

    DC_BEGIN_FN("BDDecompressBitmap8");

    pEndSrc = pSrc + compressedDataSize;
    pDst    = pDstBuffer;
    pEndDst = pDst + dstBufferSize;

    fgChar = 0xFF;
    backgroundNeedsPel = FALSE;
    firstLine = TRUE;

    /************************************************************************/
    /*                                                                      */
    /* Main decompression loop                                              */
    /*                                                                      */
    /************************************************************************/
    while (pSrc < pEndSrc)
    {
        /********************************************************************/
        /* While we are processing the first line we should keep a look out */
        /* for the end of the line                                          */
        /********************************************************************/
        if (firstLine)
        {
            if ((DCUINT)(pDst - pDstBuffer) >= rowDelta)
            {
                firstLine = FALSE;
                backgroundNeedsPel = FALSE;
            }
        }

        /********************************************************************/
        /* Get the decode                                                   */
        /********************************************************************/
        BD_CHECK_READ_ONE_BYTE(pSrc, pEndSrc, hr );
        decode     = (DCUINT8)(*pSrc & CODE_MASK);
        decodeLite = (DCUINT8)(*pSrc & CODE_MASK_LITE);
        decodeMega = (DCUINT8)(*pSrc);

        /********************************************************************/
        /* BG RUN                                                           */
        /********************************************************************/
        if ((decode == CODE_BG_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_BG_RUN))
        {
            if (decode == CODE_BG_RUN)
            {
                EXTRACT_LENGTH(pSrc, pEndSrc, codeLength, hr);
            }
            else
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, pEndSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            TRC_DBG((TB, _T("Background run %u"),codeLength));

            if (!firstLine)
            {
                if (backgroundNeedsPel)
                {
                    BD_CHECK_WRITE_ONE_BYTE(pDst, pEndDst, hr);
                    BD_CHECK_READ_ONE_BYTE_2ENDED(pDst - rowDelta, pDstBuffer, pEndDst, hr);
                    *pDst++ = (DCUINT8)(*(pDst - rowDelta) ^ fgChar);
                    codeLength--;
                }

                BD_CHECK_READ_N_BYTES_2ENDED(pDst-rowDelta, pDstBuffer, pEndDst, codeLength, hr)
                BD_CHECK_WRITE_N_BYTES(pDst, pEndDst, codeLength, hr)

                BDMemcpy(pDst, pDst-rowDelta, codeLength);
                pDst += codeLength;
            }
            else
            {
                if (backgroundNeedsPel)
                {
                    BD_CHECK_WRITE_ONE_BYTE(pDst, pEndDst, hr)
                    *pDst++ = fgChar;
                    codeLength--;
                }

                BD_CHECK_WRITE_N_BYTES(pDst, pEndDst, codeLength, hr)
                DC_MEMSET(pDst, 0x00, codeLength);
                pDst += codeLength;
            }

            /****************************************************************/
            /* A follow on BG run will need a pel inserted                  */
            /****************************************************************/
            backgroundNeedsPel = TRUE;
            continue;
        }

        /********************************************************************/
        /* For any of the other runtypes a follow on BG run does not need   */
        /* a FG pel inserted                                                */
        /********************************************************************/
        backgroundNeedsPel = FALSE;

        /********************************************************************/
        /* FGBG IMAGE                                                       */
        /********************************************************************/
        if ((decode == CODE_FG_BG_IMAGE)      ||
            (decodeLite == CODE_SET_FG_FG_BG) ||
            (decodeMega == CODE_MEGA_MEGA_FGBG)    ||
            (decodeMega == CODE_MEGA_MEGA_SET_FGBG))
        {
            if ((decodeMega == CODE_MEGA_MEGA_FGBG) ||
                (decodeMega == CODE_MEGA_MEGA_SET_FGBG))
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, pEndSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                if (decode == CODE_FG_BG_IMAGE)
                {
                    EXTRACT_LENGTH_FGBG(pSrc, pEndSrc, codeLength, hr);
                }
                else
                {
                    EXTRACT_LENGTH_FGBG_LITE(pSrc, pEndSrc, codeLength, hr);
                }
            }

            if ((decodeLite == CODE_SET_FG_FG_BG) ||
                (decodeMega == CODE_MEGA_MEGA_SET_FGBG))
            {
                BD_CHECK_READ_ONE_BYTE(pSrc, pEndSrc, hr);
                fgChar = *pSrc++;
                TRC_DBG((TB, _T("Set FGBG image %u"),codeLength));
            }
            else
            {
                TRC_DBG((TB, _T("FGBG image     %u"),codeLength));
            }

            while (codeLength > 8)
            {
                BD_CHECK_READ_ONE_BYTE(pSrc, pEndSrc, hr);
                codeByte  = *pSrc++;
                if (firstLine)
                {
                    STORE_FGBG(0x00, codeByte, fgChar, 8);
                }
                else
                {
                    BD_CHECK_READ_ONE_BYTE_2ENDED( pDst -rowDelta, pDstBuffer, pEndDst, hr )
                    STORE_FGBG(*(pDst - rowDelta), codeByte, fgChar, 8);
                }
                codeLength -= 8;
            }
            if (codeLength > 0)
            {
                BD_CHECK_READ_ONE_BYTE(pSrc, pEndSrc, hr);
                codeByte  = *pSrc++;
                if (firstLine)
                {
                    STORE_FGBG(0x00, codeByte, fgChar, codeLength);
                }
                else
                {
                    BD_CHECK_READ_ONE_BYTE_2ENDED( pDst -rowDelta, pDstBuffer, pEndDst, hr )
                   STORE_FGBG(*(pDst - rowDelta),
                              codeByte,
                              fgChar,
                              codeLength);
                }
            }
            continue;
        }

        /********************************************************************/
        /* FG RUN                                                           */
        /********************************************************************/
        if ((decode == CODE_FG_RUN) ||
            (decodeLite == CODE_SET_FG_FG_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_FG_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_SET_FG_RUN))
        {
            if ((decodeMega == CODE_MEGA_MEGA_FG_RUN) ||
                (decodeMega == CODE_MEGA_MEGA_SET_FG_RUN))
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, pEndSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                if (decode == CODE_FG_RUN)
                {
                    EXTRACT_LENGTH(pSrc, pEndSrc, codeLength, hr);
                }
                else
                {
                    EXTRACT_LENGTH_LITE(pSrc, pEndSrc, codeLength, hr);
                }
            }

            /****************************************************************/
            /* Push the old fgChar down to the ALT position                 */
            /****************************************************************/
            if ((decodeLite == CODE_SET_FG_FG_RUN) ||
                (decodeMega  == CODE_MEGA_MEGA_SET_FG_RUN))
            {
                BD_CHECK_READ_ONE_BYTE(pSrc, pEndSrc, hr);
                TRC_DBG((TB, _T("Set FG run     %u"),codeLength));
                fgChar    = *pSrc++;
            }
            else
            {
                TRC_DBG((TB, _T("FG run         %u"),codeLength));
            }

            BD_CHECK_WRITE_N_BYTES(pDst, pEndDst, codeLength, hr)
            while (codeLength-- > 0)
            {
                if (!firstLine)
                {
                    BD_CHECK_READ_ONE_BYTE_2ENDED((pDst -rowDelta), pDstBuffer, pEndDst, hr)
                    *pDst++ = (DCUINT8)(*(pDst - rowDelta) ^ fgChar);
                }
                else
                {
                    *pDst++ = fgChar;
                }
            }
            continue;
        }

        /********************************************************************/
        /* DITHERED RUN                                                     */
        /********************************************************************/
        if ((decodeLite == CODE_DITHERED_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_DITHER))
        {
            if (decodeMega == CODE_MEGA_MEGA_DITHER)
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, pEndSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH_LITE(pSrc, pEndSrc, codeLength, hr);
            }
            TRC_DBG((TB, _T("Dithered run   %u"),codeLength));

            BD_CHECK_READ_N_BYTES(pSrc, pEndSrc, 2, hr);
            codeByte  = *pSrc++;
            codeByte2 = *pSrc++;

            BD_CHECK_WRITE_N_BYTES(pDst, pEndDst, codeLength * 2, hr)
            while (codeLength-- > 0)
            {
                *pDst++ = codeByte;
                *pDst++ = codeByte2;
            }
            continue;
        }

        /********************************************************************/
        /* COLOR IMAGE                                                      */
        /********************************************************************/
        if ((decode == CODE_COLOR_IMAGE) ||
            (decodeMega == CODE_MEGA_MEGA_CLR_IMG))
        {
            if (decodeMega == CODE_MEGA_MEGA_CLR_IMG)
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, pEndSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH(pSrc, pEndSrc, codeLength, hr);
            }
            TRC_DBG((TB, _T("Color image    %u"),codeLength));

            BD_CHECK_READ_N_BYTES(pSrc, pEndSrc, codeLength, hr)
            BD_CHECK_WRITE_N_BYTES(pDst, pEndDst, codeLength, hr)
            BDMemcpy(pDst, pSrc, codeLength);

            pDst += codeLength;
            pSrc += codeLength;

            continue;
        }

        /********************************************************************/
        /* COLOR RUN                                                        */
        /********************************************************************/
        if ((decode == CODE_COLOR_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_COLOR_RUN))
        {
            if (decodeMega == CODE_MEGA_MEGA_COLOR_RUN)
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, pEndSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH(pSrc, pEndSrc, codeLength, hr);
            }
            TRC_DBG((TB, _T("Color run      %u"),codeLength));

            BD_CHECK_READ_ONE_BYTE(pSrc, pEndSrc, hr)
            codeByte = *pSrc++;

            BD_CHECK_WRITE_N_BYTES(pDst, pEndDst, codeLength, hr)
            DC_MEMSET(pDst, codeByte, codeLength);
            pDst += codeLength;

            continue;
        }

        /********************************************************************/
        /* If we get here then the code must be a special one               */
        /********************************************************************/
        TRC_DBG((TB, _T("Special code   %#x"),decodeMega));
        switch (decodeMega)
        {
            case CODE_BLACK:
            {
                BD_CHECK_WRITE_ONE_BYTE(pDst, pEndDst, hr);
                *pDst++ = 0x00;
            }
            break;

            case CODE_WHITE:
            {
                BD_CHECK_WRITE_ONE_BYTE(pDst, pEndDst, hr);
                *pDst++ = 0xFF;
            }
            break;

            /****************************************************************/
            /* Ignore the unreachable code warnings that follow             */
            /* Simply because we use the STORE_FGBG macro with a constant   */
            /* value                                                        */
            /****************************************************************/
            case CODE_SPECIAL_FGBG_1:
            {
                if (firstLine)
                {
                    STORE_FGBG(0x00, SPECIAL_FGBG_CODE_1, fgChar, 8);
                }
                else
                {
                    BD_CHECK_READ_ONE_BYTE_2ENDED(pDst-rowDelta, pDstBuffer, pEndDst, hr);
                    STORE_FGBG(*(pDst - rowDelta),
                               SPECIAL_FGBG_CODE_1,
                               fgChar,
                               8);
                }

            }
            break;

            case CODE_SPECIAL_FGBG_2:
            {
                if (firstLine)
                {
                    STORE_FGBG(0x00,
                               SPECIAL_FGBG_CODE_2,
                               fgChar,
                               8);
                }
                else
                {
                    BD_CHECK_READ_ONE_BYTE_2ENDED(pDst-rowDelta, pDstBuffer, pEndDst, hr);
                    STORE_FGBG(*(pDst - rowDelta),
                               SPECIAL_FGBG_CODE_2,
                               fgChar,
                               8);
                }
            }
            break;

            default:
            {
                TRC_ERR((TB, _T("Invalid compression data %x"),decodeMega));
            }
            break;
        }
        pSrc++;
    }

    TRC_DBG((TB, _T("Decompressed to %d"), pDst-pDstBuffer));

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}

/****************************************************************************/
/* 15bpp decompression                                                      */
/****************************************************************************/
_inline HRESULT DCAPI BDDecompressBitmap15(PDCUINT8  pSrc,
                                          PDCUINT8  pDstBuffer,
                                          DCUINT    srcDataSize,
                                          DCUINT    dstBufferSize,
                                          DCUINT16  rowDelta)

/****************************************************************************/
/* Function name                                                            */
/****************************************************************************/
#define BC_FN_NAME              "BDDecompressBitmap15"

/****************************************************************************/
/* Data type of a pixel                                                     */
/****************************************************************************/
#define BC_PIXEL                DCUINT16

/****************************************************************************/
/* Length in bytes of a pixel                                               */
/****************************************************************************/
#define BC_PIXEL_LEN            2

/****************************************************************************/
/* Default fgPel                                                            */
/****************************************************************************/
#define BC_DEFAULT_FGPEL        0x0000FF7F

/****************************************************************************/
/* Macro to move to the next pixel in the buffer (modifies pPos)            */
/****************************************************************************/
#define BC_TO_NEXT_PIXEL(pPos)  pPos += 2

/****************************************************************************/
/* Macro to returns the value of the pixel at pPos (doesn't modify pPos)    */
/****************************************************************************/
#define BC_GET_PIXEL(pPos)      ((DCUINT16)  (((PDCUINT8)(pPos))[1]) |       \
                                 (DCUINT16) ((((PDCUINT8)(pPos))[0]) << 8) )

/****************************************************************************/
/* Macro to insert a pixel value pel at position pPos (doesn't modify pPos) */
/*                                                                          */
/* pel may well be an expression (e.g.  a BC_GET_PIXEL macro) so evaluate   */
/* it once into a local variable.                                           */
/****************************************************************************/
#define BC_SET_PIXEL(pPos, pel)                                              \
{                                                                            \
    BC_PIXEL val = pel;                                                      \
    (((PDCUINT8)(pPos))[1]) = (DCUINT8)( (val) & 0x00FF);                    \
    (((PDCUINT8)(pPos))[0]) = (DCUINT8)(((val)>>8) & 0x00FF);                \
}

/****************************************************************************/
/* Include the function body                                                */
/****************************************************************************/
#include <bdcom.c>

/****************************************************************************/
/* Undefine everything                                                      */
/****************************************************************************/
#undef BC_FN_NAME
#undef BC_PIXEL
#undef BC_PIXEL_LEN
#undef BC_TO_NEXT_PIXEL
#undef BC_GET_PIXEL
#undef BC_SET_PIXEL
#undef BC_DEFAULT_FGPEL

/****************************************************************************/
/* 16bpp decompression                                                      */
/****************************************************************************/
_inline HRESULT DCAPI BDDecompressBitmap16(PDCUINT8  pSrc,
                                          PDCUINT8  pDstBuffer,
                                          DCUINT    srcDataSize,
                                          DCUINT    dstBufferSize,
                                          DCUINT16  rowDelta)

/****************************************************************************/
/* Function name                                                            */
/****************************************************************************/
#define BC_FN_NAME              "BDDecompressBitmap16"

/****************************************************************************/
/* Data type of a pixel                                                     */
/****************************************************************************/
#define BC_PIXEL                DCUINT16

/****************************************************************************/
/* Length in bytes of a pixel                                               */
/****************************************************************************/
#define BC_PIXEL_LEN            2

/****************************************************************************/
/* Default fgPel                                                            */
/****************************************************************************/
#define BC_DEFAULT_FGPEL        0x0000FFFF

/****************************************************************************/
/* Macro to move to the next pixel in the buffer (modifies pPos)            */
/****************************************************************************/
#define BC_TO_NEXT_PIXEL(pPos)  pPos += 2

/****************************************************************************/
/* Macro to returns the value of the pixel at pPos (doesn't modify pPos)    */
/****************************************************************************/
#define BC_GET_PIXEL(pPos)      ((DCUINT16)  (((PDCUINT8)(pPos))[1]) |       \
                                 (DCUINT16) ((((PDCUINT8)(pPos))[0]) << 8) )

/****************************************************************************/
/* Macro to insert a pixel value pel at position pPos (doesn't modify pPos) */
/*                                                                          */
/* pel may well be an expression (e.g.  a BC_GET_PIXEL macro) so evaluate   */
/* it once into a local variable.                                           */
/****************************************************************************/
#define BC_SET_PIXEL(pPos, pel)                                              \
{                                                                            \
    BC_PIXEL val = pel;                                                      \
    (((PDCUINT8)(pPos))[1]) = (DCUINT8)( (val) & 0x00FF);                    \
    (((PDCUINT8)(pPos))[0]) = (DCUINT8)(((val)>>8) & 0x00FF);                \
}

/****************************************************************************/
/* Include the function body                                                */
/****************************************************************************/
#include <bdcom.c>

/****************************************************************************/
/* Undefine everything                                                      */
/****************************************************************************/
#undef BC_FN_NAME
#undef BC_PIXEL
#undef BC_PIXEL_LEN
#undef BC_TO_NEXT_PIXEL
#undef BC_GET_PIXEL
#undef BC_SET_PIXEL
#undef BC_DEFAULT_FGPEL

/****************************************************************************/
/* 24bpp decompression                                                      */
/****************************************************************************/
_inline HRESULT DCAPI BDDecompressBitmap24(PDCUINT8  pSrc,
                                          PDCUINT8  pDstBuffer,
                                          DCUINT    srcDataSize,
                                          DCUINT    dstBufferSize,
                                          DCUINT16  rowDelta)

/****************************************************************************/
/* Function name                                                            */
/****************************************************************************/
#define BC_FN_NAME              "BDDecompressBitmap24"

/****************************************************************************/
/* Data type of a pixel                                                     */
/****************************************************************************/
#define BC_PIXEL                DCUINT32

/****************************************************************************/
/* Length in bytes of a pixel                                               */
/****************************************************************************/
#define BC_PIXEL_LEN            3

/****************************************************************************/
/* Default fgPel                                                            */
/****************************************************************************/
#define BC_DEFAULT_FGPEL        0x00FFFFFF

/****************************************************************************/
/* Macro to move to the next pixel in the buffer (modifies pPos)            */
/****************************************************************************/
#define BC_TO_NEXT_PIXEL(pPos)  pPos += 3

/****************************************************************************/
/* Macro to returns the value of the pixel at pPos (doesn't modify pPos)    */
/****************************************************************************/
#define BC_GET_PIXEL(pPos) (                                                 \
                 (DCUINT32) ( (DCUINT16)(((PDCUINT8)(pPos))[2])       ) |    \
                 (DCUINT32) (((DCUINT16)(((PDCUINT8)(pPos))[1])) <<  8) |    \
                 (DCUINT32) (((DCUINT32)(((PDCUINT8)(pPos))[0])) << 16) )

/****************************************************************************/
/* Macro to insert a pixel value pel at position pPos (doesn't modify pPos) */
/*                                                                          */
/* pel may well be an expression (e.g.  a BC_GET_PIXEL macro) so evaluate   */
/* it once into a local variable.                                           */
/****************************************************************************/

#define BC_SET_PIXEL(pPos, pel)                                              \
{                                                                            \
    BC_PIXEL val = pel;                                                      \
    (((PDCUINT8)(pPos))[2]) = (DCUINT8)((val) & 0x000000FF);                 \
    (((PDCUINT8)(pPos))[1]) = (DCUINT8)(((val)>>8) & 0x000000FF);            \
    (((PDCUINT8)(pPos))[0]) = (DCUINT8)(((val)>>16) & 0x000000FF);           \
}

/****************************************************************************/
/* Include the function body                                                */
/****************************************************************************/
#include <bdcom.c>

/****************************************************************************/
/* Undefine everything                                                      */
/****************************************************************************/
#undef BC_FN_NAME
#undef BC_PIXEL
#undef BC_PIXEL_LEN
#undef BC_TO_NEXT_PIXEL
#undef BC_GET_PIXEL
#undef BC_SET_PIXEL
#undef BC_DEFAULT_FGPEL


/****************************************************************************/
/* 32bpp decompression                                                      */
/****************************************************************************/
_inline HRESULT DCAPI BDDecompressBitmap32(PDCUINT8  pSrc,
                                          PDCUINT8  pDstBuffer,
                                          DCUINT    srcDataSize,
                                          DCUINT    dstBufferSize,
                                          DCUINT16  rowDelta)

/****************************************************************************/
/* Function name                                                            */
/****************************************************************************/
#define BC_FN_NAME              "BDDecompressBitmap32"

/****************************************************************************/
/* Data type of a pixel                                                     */
/****************************************************************************/
#define BC_PIXEL                DCUINT32

/****************************************************************************/
/* Length in bytes of a pixel                                               */
/****************************************************************************/
#define BC_PIXEL_LEN            4

/****************************************************************************/
/* Default fgPel                                                            */
/****************************************************************************/
#define BC_DEFAULT_FGPEL        0xFFFFFFFF

/****************************************************************************/
/* Macro to move to the next pixel in the buffer (modifies pPos)            */
/****************************************************************************/
#define BC_TO_NEXT_PIXEL(pPos)  pPos += 4

/****************************************************************************/
/* Macro to returns the value of the pixel at pPos (doesn't modify pPos)    */
/****************************************************************************/
#define BC_GET_PIXEL(pPos) (                                                 \
                 (DCUINT32) ( (DCUINT16)(((PDCUINT8)(pPos))[3])       ) |    \
                 (DCUINT32) (((DCUINT16)(((PDCUINT8)(pPos))[2])) <<  8) |    \
                 (DCUINT32) (((DCUINT32)(((PDCUINT8)(pPos))[1])) << 16) |    \
                 (DCUINT32) (((DCUINT32)(((PDCUINT8)(pPos))[0])) << 24))

/****************************************************************************/
/* Macro to insert a pixel value pel at position pPos (doesn't modify pPos) */
/*                                                                          */
/* pel may well be an expression (e.g.  a BC_GET_PIXEL macro) so evaluate   */
/* it once into a local variable.                                           */
/****************************************************************************/
#define BC_SET_PIXEL(pPos, pel)                                              \
{                                                                            \
    BC_PIXEL val = pel;                                                      \
    (((PDCUINT8)(pPos))[3]) = (DCUINT8)((val) & 0x000000FF);                 \
    (((PDCUINT8)(pPos))[2]) = (DCUINT8)(((val)>>8) & 0x000000FF);            \
    (((PDCUINT8)(pPos))[1]) = (DCUINT8)(((val)>>16) & 0x000000FF);           \
    (((PDCUINT8)(pPos))[0]) = (DCUINT8)(((val)>>24) & 0x000000FF);           \
}

/****************************************************************************/
/* Include the function body                                                */
/****************************************************************************/
#include <bdcom.c>

/****************************************************************************/
/* Undefine everything                                                      */
/****************************************************************************/
#undef BC_FN_NAME
#undef BC_PIXEL
#undef BC_PIXEL_LEN
#undef BC_TO_NEXT_PIXEL
#undef BC_GET_PIXEL
#undef BC_SET_PIXEL
#undef BC_DEFAULT_FGPEL


/****************************************************************************/
/* Name:      BD_DecompressBitmap                                           */
/*                                                                          */
/* Purpose:   Decompresses compressed bitmap data                           */
/*                                                                          */
/* Params:    IN -  pCompressedData: pointer to compressed bitmap data      */
/*            OUT - pDstBitmap: pointer to buffer for decompressed data     */
/*            IN -  srcDataSize: the compressed data size                   */
/*            IN -  bitmapBitsPerPel: the bits per pel of the data          */
/****************************************************************************/
HRESULT DCAPI BD_DecompressBitmap( PDCUINT8  pCompressedData,
                                  PDCUINT8  pDstBuffer,
                                  DCUINT    srcDataSize,
                                  DCUINT    dstBufferSize,
                                  DCUINT    noBCHeader,
                                  DCUINT8   bitmapBitsPerPel,
                                  DCUINT16  bitmapWidth,
                                  DCUINT16  bitmapHeight)
{
    HRESULT hr = S_OK;
    PDCUINT8      pSrc;
    DCUINT16      rowDelta;
    DCUINT        compressedDataSize;
    PTS_CD_HEADER pCompDataHeader;
#ifdef DC_NO_UNALIGNED
    TS_CD_HEADER  compDataHeader;
#endif

#ifdef DC_DEBUG
    DCUINT32 decompLen;
#endif
    UNREFERENCED_PARAMETER( bitmapHeight);

    DC_BEGIN_FN("BD_DecompressBitmap");

    TRC_ASSERT( (pCompressedData != NULL),
                (TB, _T("Invalid pCompressedData(%p)"), pCompressedData) );
    TRC_ASSERT( (pDstBuffer != NULL),
                (TB, _T("Invalid pDstBuffer(%p)"), pDstBuffer) );
    TRC_ASSERT( (srcDataSize != 0),
                (TB, _T("Invalid srcDataSize(%u)"), srcDataSize) );
    TRC_ASSERT( (dstBufferSize != 0),
                (TB, _T("Invalid dstBufferSize(%u)"), dstBufferSize) );    
#ifdef DC_HICOLOR
#ifdef DC_DEBUG
    /************************************************************************/
    /* Check the decompression buffer is big enough                         */
    /************************************************************************/
    {
        decompLen = bitmapWidth * bitmapHeight *
                                                 ((bitmapBitsPerPel + 7) / 8);
        if (IsBadWritePtr(pDstBuffer, decompLen))
        {
            TRC_ABORT((TB, _T("Decompression buffer %p not big enough for") \
                           _T(" bitmap length %d"), pDstBuffer, decompLen ));
        }
    }
#endif
#else
    TRC_ASSERT( (bitmapBitsPerPel == 8),
                (TB, _T("Invalid bitmapBitsPerPel(%u)"), bitmapBitsPerPel) );
#endif

    /************************************************************************/
    /* Initialize variables before main loop.                               */
    /*                                                                      */
    /* No bitmap compression header included                                */
    /************************************************************************/
    if (noBCHeader)
    {
        compressedDataSize = srcDataSize;
        pSrc               = pCompressedData;
        rowDelta           = TS_BYTES_IN_SCANLINE(bitmapWidth,
                                                  bitmapBitsPerPel);
    }
    else
    {
        /************************************************************************/
        /* Work out the location in the source data of each component.          */
        /* Make sure this is naturally aligned (for RISC platforms)             */
        /************************************************************************/
        BD_CHECK_READ_N_BYTES(pCompressedData, (PBYTE)pCompressedData + srcDataSize, 
            sizeof(TS_CD_HEADER), hr);

#ifdef DC_NO_UNALIGNED
        DC_MEMCPY(&compDataHeader, pCompressedData, sizeof(TS_CD_HEADER));
        pCompDataHeader = &compDataHeader;
#else
        pCompDataHeader = (PTS_CD_HEADER)pCompressedData;
#endif

        /********************************************************************/
        /* Bitmap compression header included                               */
        /********************************************************************/
        compressedDataSize = pCompDataHeader->cbCompMainBodySize;
        BD_CHECK_READ_N_BYTES(pCompressedData, pCompressedData + srcDataSize, 
            compressedDataSize + sizeof(TS_CD_HEADER), hr);
        
        pSrc               = pCompressedData + sizeof(TS_CD_HEADER);
        rowDelta           = pCompDataHeader->cbScanWidth;
        if (rowDelta != TS_BYTES_IN_SCANLINE(bitmapWidth, bitmapBitsPerPel)) {
            TRC_ABORT((TB, _T("rowDelta in TS_CD_HEADER incorrect ")
                _T("[got %u expected %u]"), rowDelta,
                TS_BYTES_IN_SCANLINE(bitmapWidth, bitmapBitsPerPel)));
            hr = E_TSC_CORE_LENGTH;
            DC_QUIT;
        }
    }

    /************************************************************************/
    /* Call the appropriate decompress function, based on the color depth   */
    /************************************************************************/
    switch (bitmapBitsPerPel)
    {
        case 32:
        {
            hr = BDDecompressBitmap32 (pSrc,
                                  pDstBuffer,
                                  compressedDataSize,
                                  dstBufferSize,
                                  rowDelta);

        }
        break;

        case 24:
        {
            hr = BDDecompressBitmap24 (pSrc,
                                  pDstBuffer,
                                  compressedDataSize,
                                  dstBufferSize,
                                  rowDelta);
        }
        break;

        case 16:
        {
            hr = BDDecompressBitmap16 (pSrc,
                                  pDstBuffer,
                                  compressedDataSize,
                                  dstBufferSize,
                                  rowDelta);
        }
        break;

        case 15:
        {
            hr = BDDecompressBitmap15 (pSrc,
                                  pDstBuffer,
                                  compressedDataSize,
                                  dstBufferSize,
                                  rowDelta);
        }
        break;

        case 8:
        default:
        {
            hr = BDDecompressBitmap8  (pSrc,
                                  pDstBuffer,
                                  compressedDataSize,
                                  dstBufferSize,
                                  bitmapBitsPerPel,
                                  rowDelta);
        }
        break;
    }


DC_EXIT_POINT:
    return hr;
}

#else
/****************************************************************************/
/* Name:      BD_DecompressBitmap                                           */
/*                                                                          */
/* Purpose:   Decompresses compressed bitmap data                           */
/*                                                                          */
/* Params:    IN -  pCompressedData: pointer to compressed bitmap data      */
/*            OUT - pDstBitmap: pointer to buffer for decompressed data     */
/*            IN -  srcDataSize: the compressed data size                   */
/*            IN -  bitmapBitsPerPel: the bits per pel of the data          */
/****************************************************************************/
HRESULT DCAPI BD_DecompressBitmap( PDCUINT8  pCompressedData,
                                  PDCUINT8  pDstBuffer,
                                  DCUINT    srcDataSize,
                                  DCUINT    dstBufferSize,
                                  DCUINT    noBCHeader,
                                  DCUINT8   bitmapBitsPerPel,
                                  DCUINT16  bitmapWidth,
                                  DCUINT16  bitmapHeight )
{
    HRESULT hr = S_OK;
    UNREFERENCED_PARAMETER(bitmapHeight);
#ifdef DC_NO_UNALIGNED
    TS_CD_HEADER  compDataHeader;
#endif
    PTS_CD_HEADER pCompDataHeader;
    DCUINT     compressedDataSize;
    DCUINT     codeLength;
    DCUINT8    codeByte;
    DCUINT8    codeByte2;
    DCUINT8    decode;
    DCUINT8    decodeLite;
    DCUINT8    decodeMega;
    DCUINT8    fgChar;
    PDCUINT8   pSrc;
    PDCUINT8   pDst;
    PDCUINT8   pEndSrc;
    PDCUINT8    pEndDst;
    DCBOOL     backgroundNeedsPel;
    DCBOOL     firstLine;
    DCUINT     rowDelta;

    DC_BEGIN_FN("BD_DecompressBitmap");

    TRC_ASSERT( (pCompressedData != NULL),
                (TB, _T("Invalid pCompressedData(%p)"), pCompressedData) );
    TRC_ASSERT( (pDstBuffer != NULL),
                (TB, _T("Invalid pDstBuffer(%p)"), pDstBuffer) );
    TRC_ASSERT( (srcDataSize != 0),
                (TB, _T("Invalid srcDataSize(%u)"), srcDataSize) );
    TRC_ASSERT( (dstBufferSize != 0),
                (TB, _T("Invalid dstBufferSize(%u)"), dstBufferSize) );
    TRC_ASSERT( (bitmapBitsPerPel == 8),
                (TB, _T("Invalid bitmapBitsPerPel(%u)"), bitmapBitsPerPel) );

    /************************************************************************/
    /* Trace the important parameters.                                      */
    /************************************************************************/
    TRC_DBG((TB, _T("pData(%p) pDst(%p) cbSrc(%u) cbDst(%u)"),
       pCompressedData, pDstBuffer, srcDataSize, dstBufferSize));

    /************************************************************************/
    /* Initialize variables before main loop.                               */
    /************************************************************************/
    // no bitmap compression header included
    if (noBCHeader) {
        compressedDataSize = srcDataSize;
        pSrc = pCompressedData;
        rowDelta = TS_BYTES_IN_SCANLINE(bitmapWidth, bitmapBitsPerPel);

    }
    // bitmap compression header included
    else {
        /************************************************************************/
        /* Work out the location in the source data of each component.          */
        /* Make sure this is naturally aligned (for RISC platforms)             */
        /************************************************************************/
        BD_CHECK_READ_N_BYTES(pCompressedData, pCompressedData + srcDataSize, 
            sizeof(TS_CD_HEADER), hr);
#ifdef DC_NO_UNALIGNED
        DC_MEMCPY(&compDataHeader, pCompressedData, sizeof(TS_CD_HEADER));
        pCompDataHeader = &compDataHeader;
#else
        pCompDataHeader = (PTS_CD_HEADER)pCompressedData;
#endif
        
        compressedDataSize = pCompDataHeader->cbCompMainBodySize;
        BD_CHECK_READ_N_BYTES(pCompressedData, pCompressedData + srcDataSize, 
            compressedDataSize + sizeof(TS_CD_HEADER), hr);
        
        pSrc = pCompressedData + sizeof(TS_CD_HEADER);
        rowDelta = pCompDataHeader->cbScanWidth;
        if (rowDelta != TS_BYTES_IN_SCANLINE(bitmapWidth, bitmapBitsPerPel)) {
            TRC_ABORT((TB, _T("rowDelta in TS_CD_HEADER incorrect ")
                _T("[got %u expected %u]"), rowDelta,
                TS_BYTES_IN_SCANLINE(bitmapWidth, bitmapBitsPerPel)));
            hr = E_TSC_CORE_LENGTH;
            DC_QUIT;
        }
    }
  
    pEndSrc = pSrc + compressedDataSize;
    pDst = pDstBuffer;
    pEndDst = pDst + dstBufferSize;

    fgChar = 0xFF;
    backgroundNeedsPel = FALSE;
    firstLine = TRUE;

    /************************************************************************/
    /*                                                                      */
    /* Main decompression loop                                              */
    /*                                                                      */
    /************************************************************************/
    while(pSrc < pEndSrc)
    {
        /********************************************************************/
        /* While we are processing the first line we should keep a look out */
        /* for the end of the line                                          */
        /********************************************************************/
        if (firstLine)
        {
            if ((DCUINT)(pDst - pDstBuffer) >= rowDelta)
            {
                firstLine = FALSE;
                backgroundNeedsPel = FALSE;
            }
        }

        /********************************************************************/
        /* Get the decode                                                   */
        /********************************************************************/
        BD_CHECK_READ_ONE_BYTE(pSrc, pEndSrc, hr);
        decode     = (DCUINT8)(*pSrc & CODE_MASK);
        decodeLite = (DCUINT8)(*pSrc & CODE_MASK_LITE);
        decodeMega = (DCUINT8)(*pSrc);

        /********************************************************************/
        /* BG RUN                                                           */
        /********************************************************************/
        if ((decode == CODE_BG_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_BG_RUN))
        {
            if (decode == CODE_BG_RUN)
            {
                EXTRACT_LENGTH(pSrc, pEndSrc, codeLength, hr);
            }
            else
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, pEndSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            TRC_DBG((TB, _T("Background run %u"),codeLength));

            if (!firstLine)
            {
                if (backgroundNeedsPel)
                {
                    BD_CHECK_WRITE_ONE_BYTE(pDst, pEndDst, hr);
                    BD_CHECK_READ_ONE_BYTE_2ENDED(pDst - rowDelta, pDstBuffer, pEndDst, hr);
                    *pDst++ = (DCUINT8)(*(pDst - rowDelta) ^ fgChar);
                    codeLength--;
                }

                BD_CHECK_READ_N_BYTES_2ENDED(pDst - rowDelta, pDstBuffer, pEndDst, codeLength, hr);
                BD_CHECK_WRITE_N_BYTES(pDst, pEndDst, codeLength, hr);
                
                BDMemcpy(pDst, pDst-rowDelta, codeLength);
                pDst += codeLength;
            }
            else
            {
                if (backgroundNeedsPel)
                {
                    BD_CHECK_WRITE_ONE_BYTE(pDst, pEndDst, hr);
                    *pDst++ = fgChar;
                    codeLength--;
                }

                BD_CHECK_WRITE_N_BYTES(pDst, pEndDst, codeLength, hr);
                DC_MEMSET(pDst, 0x00, codeLength);
                pDst += codeLength;
            }

            /****************************************************************/
            /* A follow on BG run will need a pel inserted                  */
            /****************************************************************/
            backgroundNeedsPel = TRUE;
            continue;
        }

        /********************************************************************/
        /* For any of the other runtypes a follow on BG run does not need   */
        /* a FG pel inserted                                                */
        /********************************************************************/
        backgroundNeedsPel = FALSE;

        /********************************************************************/
        /* FGBG IMAGE                                                       */
        /********************************************************************/
        if ((decode == CODE_FG_BG_IMAGE)      ||
            (decodeLite == CODE_SET_FG_FG_BG) ||
            (decodeMega == CODE_MEGA_MEGA_FGBG)    ||
            (decodeMega == CODE_MEGA_MEGA_SET_FGBG))
        {
            if ((decodeMega == CODE_MEGA_MEGA_FGBG) ||
                (decodeMega == CODE_MEGA_MEGA_SET_FGBG))
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, pEndSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                if (decode == CODE_FG_BG_IMAGE)
                {
                    EXTRACT_LENGTH_FGBG(pSrc, pEndSrc, codeLength, hr);
                }
                else
                {
                    EXTRACT_LENGTH_FGBG_LITE(pSrc, pEndSrc, codeLength, hr);
                }
            }

            if ((decodeLite == CODE_SET_FG_FG_BG) ||
                (decodeMega == CODE_MEGA_MEGA_SET_FGBG))
            {
                BD_CHECK_READ_ONE_BYTE(pSrc, pEndSrc, hr);
                fgChar = *pSrc++;
                TRC_DBG((TB, _T("Set FGBG image %u"),codeLength));
            }
            else
            {
                TRC_DBG((TB, _T("FGBG image     %u"),codeLength));
            }

            while (codeLength > 8)
            {
                BD_CHECK_READ_ONE_BYTE(pSrc, pEndSrc, hr);
                codeByte  = *pSrc++;
                if (firstLine)
                {
                    STORE_FGBG(0x00, codeByte, fgChar, 8);
                }
                else
                {
                    BD_CHECK_READ_ONE_BYTE_2ENDED(pDst - rowDelta, pDstBuffer, pEndDst, hr)
                    STORE_FGBG(*(pDst - rowDelta), codeByte, fgChar, 8);
                }
                codeLength -= 8;
            }
            if (codeLength > 0)
            {
                BD_CHECK_READ_ONE_BYTE(pSrc, pEndSrc, hr);
                codeByte  = *pSrc++;
                if (firstLine)
                {
                    STORE_FGBG(0x00, codeByte, fgChar, codeLength);
                }
                else
                {
                    BD_CHECK_READ_ONE_BYTE_2ENDED(pDst - rowDelta, pDstBuffer, pEndDst, hr)
                   STORE_FGBG(*(pDst - rowDelta),
                              codeByte,
                              fgChar,
                              codeLength);
                }
            }
            continue;
        }

        /********************************************************************/
        /* FG RUN                                                           */
        /********************************************************************/
        if ((decode == CODE_FG_RUN) ||
            (decodeLite == CODE_SET_FG_FG_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_FG_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_SET_FG_RUN))
        {
            if ((decodeMega == CODE_MEGA_MEGA_FG_RUN) ||
                (decodeMega == CODE_MEGA_MEGA_SET_FG_RUN))
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, pEndSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                if (decode == CODE_FG_RUN)
                {
                    EXTRACT_LENGTH(pSrc, pEndSrc, codeLength, hr);
                }
                else
                {
                    EXTRACT_LENGTH_LITE(pSrc, pEndSrc, codeLength, hr);
                }
            }

            /****************************************************************/
            /* Push the old fgChar down to the ALT position                 */
            /****************************************************************/
            if ((decodeLite == CODE_SET_FG_FG_RUN) ||
                (decodeMega  == CODE_MEGA_MEGA_SET_FG_RUN))
            {
                BD_CHECK_READ_ONE_BYTE(pSrc, pEndSrc, hr);
                TRC_DBG((TB, _T("Set FG run     %u"),codeLength));
                fgChar    = *pSrc++;
            }
            else
            {
                TRC_DBG((TB, _T("FG run         %u"),codeLength));
            }

            BD_CHECK_WRITE_N_BYTES(pDst, pEndDst, codeLength, hr)
            while (codeLength-- > 0)
            {
                if (!firstLine)
                {
                    BD_CHECK_READ_ONE_BYTE_2ENDED(pDst - rowDelta, pDstBuffer, pEndDst, hr)
                    *pDst++ = (DCUINT8)(*(pDst - rowDelta) ^ fgChar);
                }
                else
                {
                    *pDst++ = fgChar;
                }
            }
            continue;
        }

        /********************************************************************/
        /* DITHERED RUN                                                     */
        /********************************************************************/
        if ((decodeLite == CODE_DITHERED_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_DITHER))
        {
            if (decodeMega == CODE_MEGA_MEGA_DITHER)
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, pEndSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH_LITE(pSrc, pEndSrc, codeLength, hr);
            }
            TRC_DBG((TB, _T("Dithered run   %u"),codeLength));

            BD_CHECK_READ_N_BYTES(pSrc, pEndSrc, 2, hr);
            codeByte  = *pSrc++;
            codeByte2 = *pSrc++;

            BD_CHECK_WRITE_N_BYTES(pDst, pEndDst, codeLength * 2, hr)
            while (codeLength-- > 0)
            {
                *pDst++ = codeByte;
                *pDst++ = codeByte2;
            }
            continue;
        }

        /********************************************************************/
        /* COLOR IMAGE                                                      */
        /********************************************************************/
        if ((decode == CODE_COLOR_IMAGE) ||
            (decodeMega == CODE_MEGA_MEGA_CLR_IMG))
        {
            if (decodeMega == CODE_MEGA_MEGA_CLR_IMG)
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, pEndSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH(pSrc, pEndSrc, codeLength, hr);
            }
            TRC_DBG((TB, _T("Color image    %u"),codeLength));

            BD_CHECK_READ_N_BYTES(pSrc, pEndSrc, codeLength, hr);
            BD_CHECK_WRITE_N_BYTES(pDst, pEndDst, codeLength, hr);
            BDMemcpy(pDst, pSrc, codeLength);

            pDst += codeLength;
            pSrc += codeLength;

            continue;
        }

        /********************************************************************/
        /* PACKED COLOR IMAGE                                               */
        /********************************************************************/
        if ((decode == CODE_PACKED_COLOR_IMAGE) ||
            (decodeMega == CODE_MEGA_MEGA_PACKED_CLR))
        {
            if (decodeMega == CODE_MEGA_MEGA_PACKED_CLR)
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, pEndSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH(pSrc, pEndSrc, codeLength, hr);
            }
            TRC_DBG((TB, _T("Packed color   %u"),codeLength));

            if (bitmapBitsPerPel == 4)
            {
                DCUINT   worklen = (codeLength)/2;
                DCUINT8  workchar;
                BD_CHECK_READ_N_BYTES(pSrc, pEndSrc, worklen, hr);
                BD_CHECK_WRITE_N_BYTES(pDst, pEndDst, worklen * 2, hr);
                while (worklen--)
                {
                    workchar   = *pSrc++;
                    *pDst++ = (DCUINT8)(workchar >> 4);
                    *pDst++ = (DCUINT8)(workchar & 0x0F);
                }
                if (codeLength & 0x0001)
                {
                    BD_CHECK_READ_ONE_BYTE(pSrc, pEndSrc, hr);
                    BD_CHECK_WRITE_ONE_BYTE(pDst, pEndDst, hr);
                    *pDst++ = (DCUINT8)(*pSrc++>>4);
                }
            }
            else
            {
                TRC_ERR((TB, _T("Don't support packed color for 8bpp")));
            }
            continue;
        }

        /********************************************************************/
        /* COLOR RUN                                                        */
        /********************************************************************/
        if ((decode == CODE_COLOR_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_COLOR_RUN))
        {
            if (decodeMega == CODE_MEGA_MEGA_COLOR_RUN)
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, pEndSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH(pSrc, pEndSrc, codeLength, hr);
            }
            TRC_DBG((TB, _T("Color run      %u"),codeLength));

            BD_CHECK_READ_ONE_BYTE(pSrc, pEndSrc, hr);
            codeByte = *pSrc++;

            BD_CHECK_WRITE_N_BYTES(pDst, pEndDst, codeLength, hr);
            DC_MEMSET(pDst, codeByte, codeLength);
            pDst += codeLength;

            continue;
        }

        /********************************************************************/
        /* If we get here then the code must be a special one               */
        /********************************************************************/
        TRC_DBG((TB, _T("Special code   %#x"),decodeMega));
        switch (decodeMega)
        {
            case CODE_BLACK:
            {
                BD_CHECK_WRITE_ONE_BYTE(pDst, pEndDst, hr);
                *pDst++ = 0x00;
            }
            break;

            case CODE_WHITE:
            {
                BD_CHECK_WRITE_ONE_BYTE(pDst, pEndDst, hr);
                *pDst++ = 0xFF;
            }
            break;

            /****************************************************************/
            /* Ignore the unreachable code warnings that follow             */
            /* Simply because we use the STORE_FGBG macro with a constant   */
            /* value                                                        */
            /****************************************************************/
            case CODE_SPECIAL_FGBG_1:
            {
                if (firstLine)
                {
                    STORE_FGBG(0x00, SPECIAL_FGBG_CODE_1, fgChar, 8);
                }
                else
                {
                    BD_CHECK_READ_ONE_BYTE_2ENDED(pDst - rowDelta, pDstBuffer, pEndDst, hr)
                    STORE_FGBG(*(pDst - rowDelta),
                               SPECIAL_FGBG_CODE_1,
                               fgChar,
                               8);
                }

            }
            break;

            case CODE_SPECIAL_FGBG_2:
            {
                if (firstLine)
                {
                    STORE_FGBG(0x00,
                               SPECIAL_FGBG_CODE_2,
                               fgChar,
                               8);
                }
                else
                {
                    BD_CHECK_READ_ONE_BYTE_2ENDED(pDst - rowDelta, pDstBuffer, pEndDst, hr)
                    STORE_FGBG(*(pDst - rowDelta),
                               SPECIAL_FGBG_CODE_2,
                               fgChar,
                               8);
                }
            }
            break;

            default:
            {
                TRC_ERR((TB, _T("Invalid compression data %x"),decodeMega));
            }
            break;
        }
        pSrc++;
    }

    TRC_DBG((TB, _T("Decompressed to %d"), pDst-pDstBuffer));

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}
#endif

#ifdef OS_WINDOWS
#pragma warning (default: 4127)
#endif /* OS_WINDOWS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\arcdlg.h ===
//
// arcdlg.h  Autoreconnect dialog box
//
// Copyright Microsoft Corportation 2001
// (nadima)
//

#ifndef _arcdlg_h_
#define _arcdlg_h_

#define DISPLAY_STRING_LEN 256

#define MAX_ARC_CONNECTION_ATTEMPTS 20

#include "progband.h"

//
// Minimal UI - just a flashing icon, introduced for XPSP1
// where we couldn't add resources
//
//#define ARC_MINIMAL_UI  0


typedef DWORD (*PFNGDI_SETLAYOUT)(HDC, DWORD);

//
// Base class for the ARC UI
//
class CAutoReconnectUI
{
public:
    CAutoReconnectUI(
        HWND hwndOwner,
        HINSTANCE hInst,
        CUI* pUi);
    virtual ~CAutoReconnectUI();

    virtual HWND
    StartModeless() = 0;

    //
    // Notifications
    //
    virtual VOID
    OnParentSizePosChange() = 0;
    virtual VOID
    OnNotifyAutoReconnecting(
        UINT  discReason,
        ULONG attemptCount,
        ULONG maxAttemptCount,
        BOOL* pfContinueArc
        ) = 0;

    virtual VOID
    OnNotifyConnected() = 0;

    virtual BOOL
    ShowTopMost() = 0;

    virtual HWND
    GetHwnd()           {return _hwnd;}

    virtual BOOL
    Destroy() = 0;

protected:
    //
    // Private member functions
    //
    VOID
    CenterWindow(
        HWND hwndCenterOn,
        INT xRatio,
        INT yRatio
        );

    VOID
    PaintBitmap(
        HDC hdcDestination,
        const RECT* prcDestination,
        HBITMAP hbmSource,
        const RECT *prcSource
        );

protected:
    CUI*          _pUi;
    HWND          _hwnd;
    HWND          _hwndOwner;
    HINSTANCE     _hInstance;
    //
    // GDI SetLayout call
    //
    PFNGDI_SETLAYOUT    _pfnSetLayout;
    HMODULE             _hGDI;
};

class CAutoReconnectDlg : public CAutoReconnectUI
{
public:
    CAutoReconnectDlg(HWND hwndOwner,
                      HINSTANCE hInst,
                      CUI* pUi);
    virtual ~CAutoReconnectDlg();

    virtual HWND
    StartModeless();

    virtual INT_PTR CALLBACK
    DialogBoxProc(
        HWND hwndDlg,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam
        );

    static INT_PTR CALLBACK
    StaticDialogBoxProc(
        HWND hwndDlg,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam
        );

#ifndef OS_WINCE
    static LRESULT CALLBACK
    CancelBtnSubclassProc(
        HWND hwnd,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam,
        UINT_PTR uiID,
        DWORD_PTR dwRefData
        );
#else
    static LRESULT CALLBACK
    CancelBtnSubclassProc(
        HWND hwnd,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam
        );
#endif

    //
    // Notifications
    //
    virtual VOID
    OnParentSizePosChange();
    virtual VOID
    OnNotifyAutoReconnecting(
        UINT  discReason,
        ULONG attemptCount,
        ULONG maxAttemptCount,
        BOOL* pfContinueArc
        );
    virtual VOID
    OnNotifyConnected();

    virtual BOOL
    ShowTopMost();

    virtual BOOL
    Destroy();


private:

    VOID
    UpdateConnectionAttempts(
        ULONG conAttempts,
        ULONG maxConAttempts
        );

    //
    // Message handlers
    //
    VOID
    OnEraseBkgnd(HWND hwnd, HDC hdc);

    VOID
    OnPrintClient(HWND hwnd, HDC hdcPrint, DWORD dwOptions);

    VOID
    OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT *pDIS);


private:
    TCHAR         _szConnectAttemptStringTmpl[DISPLAY_STRING_LEN];
    ULONG         _connectionAttempts;
    INT           _nArcTimerID;
    ULONG         _elapsedArcTime;

    //
    // Flag indicating dialog was properly initialized
    //
    BOOL          _fInitialized;

    //
    // TRUE while we are continuing to arc
    //
    BOOL           _fContinueReconAttempts;

    //
    // Bitmaps
    //
    HBITMAP        _hbmBackground;
    HBITMAP        _hbmFlag;
#ifndef OS_WINCE
    HBITMAP        _hbmDisconImg;
#endif

    //
    // Palette
    //
    HPALETTE       _hPalette;

    RECT           _rcBackground;
    RECT           _rcFlag;
    RECT           _rcDisconImg;

    //
    // Fonts
    //
    HFONT          _hfntTitle;

    //
    // Progress band
    //
    CProgressBand*  _pProgBand;

    //
    // Last disconnection reason
    //
    UINT            _lastDiscReason;

#ifdef OS_WINCE
    //
    // To subclass the "Cancel" button on CE
    //
    WNDPROC           _lOldCancelProc;  

    //
    // Brushes to paint the static ctls
    //
    HBRUSH            _hbrTopBand;
    HBRUSH            _hbrMidBand;
#endif
};


//
// Minimal UI - just a flashing icon
//
class CAutoReconnectPlainUI : public CAutoReconnectUI
{
public:
    CAutoReconnectPlainUI(HWND hwndOwner,
                      HINSTANCE hInst,
                      CUI* pUi);
    virtual ~CAutoReconnectPlainUI();

    virtual HWND
    StartModeless();

    virtual LRESULT CALLBACK
    WndProc(
        HWND hwnd,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam
        );

    static LRESULT CALLBACK
    StaticPlainArcWndProc(
        HWND hwnd,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam
        );

    //
    // Notifications
    //
    virtual VOID
    OnParentSizePosChange();
    virtual VOID
    OnNotifyAutoReconnecting(
        UINT  discReason,
        ULONG attemptCount,
        ULONG maxAttemptCount,
        BOOL* pfContinueArc
        );
    virtual VOID
    OnNotifyConnected();
    virtual BOOL
    ShowTopMost();
    virtual BOOL
    Destroy();


private:
    //
    // Private member functions
    //

    //
    // Message handlers
    //
    VOID
    OnEraseBkgnd(HWND hwnd, HDC hdc);

    VOID
    OnPrintClient(HWND hwnd, HDC hdcPrint, DWORD dwOptions);

    VOID
    OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT *pDIS);


private:
    VOID MoveToParentTopRight();
    VOID OnAnimFlashTimer();
    HBITMAP
    LoadImageFromMemory(
        HDC    hdc,
        LPBYTE pbBitmapBits,
        ULONG cbLen
        );
    
    HRESULT
    LoadImageBits(
        LPBYTE pbBitmapBits, ULONG cbLen,
        LPBITMAPINFO* ppBitmapInfo, PULONG pcbBitmapInfo,
        LPBYTE* ppBits, PULONG pcbBits
        );

    INT           _nFlashingTimer;

    //
    // Flag indicating UI was properly initialized
    //
    BOOL          _fInitialized;

    //
    // TRUE while we are continuing to arc
    //
    BOOL           _fContinueReconAttempts;

    //
    // Bitmaps
    //
    HBITMAP        _hbmDisconImg;

    //
    // Palette
    //
    HPALETTE       _hPalette;

    RECT           _rcDisconImg;

    //
    // Last disconnection reason
    //
    UINT            _lastDiscReason;

    //
    // Last hide state
    //
    BOOL            _fIsUiVisible;
};



#endif // _arcdlg_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\bbar.cpp ===
//
// bbar.cpp
//
// Implementation of CBBar
// Drop down connection status + utility bar
//
// Copyright(C) Microsoft Corporation 2000
// Author: Nadim Abdo (nadima)
//
//

#include "adcg.h"

#ifdef USE_BBAR

#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "bbar"
#include <atrcapi.h>

#include "bbar.h"
#include "commctrl.h"

#ifndef OS_WINCE
#define BBAR_CLASSNAME _TEXT("BBARCLASS")
#else
#define BBAR_CLASSNAME _T("BBARCLASS")
#endif

#define IDM_MINIMIZE 101
#define IDM_RESTORE  102
#define IDM_CLOSE    103
#define IDM_PIN      104


//
// BBar is 50% of parent's width
//
#define BBAR_PERCENT_WIDTH  50

#define BBAR_NUM_BUTTONS    3
#define BBAR_BUTTON_WIDTH   12
#define BBAR_BUTTON_HEIGHT  11
#define BBAR_BUTTON_SPACE   3

#define BBAR_MIN_HEIGHT     16

//
// Two pixels of vertical space are
// unavailable (due to lines at bottom)
//
#define BBAR_VERT_SPACE_NO_USE   3

#define COLOR_BLACK     RGB(0,0,0)
#define COLOR_DKGREY    RGB(128,128,128)

#ifndef OS_WINCE
#define BBAR_TIMERID_ANIM       0
#else
#define BBAR_TIMERID_ANIM       (WM_USER + 1001)
#endif

#define BBAR_TIMERID_AUTOHIDE   1

//
// Total animation period for animation (E.g lower)
// in milliseconds
//
#define BBAR_ANIM_TIME          300

#define BBAR_AUTOHIDE_TIME      1400
#define BBAR_FIRST_AUTOHIDE_TIME 5000

CBBar::CBBar(HWND hwndParent, HINSTANCE hInstance, CUI* pUi,
             BOOL fBBarEnabled)
{
    DC_BEGIN_FN("CBBar");

    _hwndBBar = NULL;
    _hwndParent = hwndParent;
    _hInstance = hInstance;
    _state = bbarNotInit;

    _pUi = pUi;

    _fBlockZOrderChanges = FALSE;
    _nBBarVertOffset = 0;

    _ptLastAutoHideMousePos.x = -0x0FF;
    _ptLastAutoHideMousePos.y = -0x0FF;
    _nBBarAutoHideTime = 0;
    _hwndPinBar = NULL;
    _hwndWinControlsBar = NULL;
    _fPinned = FALSE;
    _nPinUpImage = 0;
    _nPinDownImage = 0;

    _hbmpLeftImage = NULL;
    _hbmpRightImage = NULL;

    _fBBarEnabled = fBBarEnabled;
    _fLocked = FALSE;
    _fShowMinimize = TRUE;
    _fShowRestore = TRUE;

    SetDisplayedText(_T(""));
    
    DC_END_FN();
}

CBBar::~CBBar()
{
}

BOOL CBBar::StartupBBar(int desktopX, int desktopY, BOOL fStartRaised)
{
    BOOL bRet = FALSE;
    DC_BEGIN_FN("StartupBBar");

    if(bbarNotInit == _state)
    {
        // First drop interval is long
        _nBBarAutoHideTime = BBAR_FIRST_AUTOHIDE_TIME;

        bRet = Initialize( desktopX, desktopY, fStartRaised );
        if(!bRet)
        {
            return FALSE;
        }
    }
    else
    {
        // First drop interval is long
        _nBBarAutoHideTime = BBAR_AUTOHIDE_TIME;

        //re-init existing bbar
        BringWindowToTop( _hwndBBar );
        ShowWindow( _hwndBBar, SW_SHOWNOACTIVATE);

        //
        // Bring the window to the TOP of the Z order
        //
        SetWindowPos( _hwndBBar,
                      HWND_TOPMOST,
                      0, 0, 0, 0,
                      SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE );
        bRet = TRUE;
    }

    //
    // Note: The bbar is used as a security feature so we do the initial
    //       drop even if the bbar feature is not enabled. It's only subsequent
    //       drops (e.g. on the timer) that are disabled if bbar is OFF
    //
    if(_pUi->UI_IsFullScreen())
    {
        //First autohide interval is long
        //to make sure user gets to notice the bbar
        StartLowerBBar();
    }
    

    DC_END_FN();
    return bRet;
}

//
// Destroy the window and reset bbar state
// for another session
//
BOOL CBBar::KillAndCleanupBBar()
{
    BOOL fRet = TRUE;

    DC_BEGIN_FN("KillAndCleanupBBar");

    if(_state != bbarNotInit)
    {
        TRC_NRM((TB,_T("Cleaning up the bbar")));

        if(_hwndBBar)
        {
            if(::DestroyWindow( _hwndBBar ))
            {
                _state = bbarNotInit;
                _hwndBBar = NULL;
                _fBlockZOrderChanges = FALSE;

                if(!UnregisterClass( BBAR_CLASSNAME, _hInstance ))
                {
                    TRC_ERR((TB,_T("UnregisterClass bbar class failed 0x%x"),
                             GetLastError()));
                }
            }
            else
            {
                TRC_ERR((TB,_T("DestroyWindow bbar failed 0x%x"),
                         GetLastError()));
                fRet = FALSE;
            }

            if (_hbmpLeftImage)
            {
                DeleteObject(_hbmpLeftImage);
                _hbmpLeftImage = NULL;
            }

            if (_hbmpRightImage)
            {
                DeleteObject(_hbmpRightImage);
                _hbmpRightImage = NULL;
            }
        }
    }

    DC_END_FN();
    return fRet;
}

BOOL CBBar::StartLowerBBar()
{
    INT parentWidth = 0;
    RECT rc;
    DC_BEGIN_FN("StartLowerBBar");

    if(_state == bbarRaised)
    {
        //
        // Kick off a timer to lower the bar
        //
        TRC_ASSERT(0 == _nBBarVertOffset,
                   (TB,_T("_nBBarVertOffset (%d) should be 0"),
                   _nBBarVertOffset));

        TRC_ASSERT(_hwndBBar,
                   (TB,_T("_hwndBBar is NULL")));

        //
        // Set the last cursor pos at the time
        // the bbar is lowered to prevent it from being
        // autohidden if the mouse doesn't move
        //
        GetCursorPos(&_ptLastAutoHideMousePos);

        //
        // Main window size could have changed
        // so make sure the bbar is centered
        // before lowering it.
        // (keep constant bbar width)

        if(_pUi->_UI.hwndMain)
        {
            GetClientRect(_pUi->_UI.hwndMain, &rc);
            parentWidth = rc.right - rc.left;
            if(!parentWidth)
            {
                return FALSE;
            }

            _rcBBarLoweredAspect.left = parentWidth / 2 - _sizeLoweredBBar.cx / 2;
            _rcBBarLoweredAspect.right = parentWidth / 2 + _sizeLoweredBBar.cx / 2;
#ifdef DISABLE_SHADOW_IN_FULLSCREEN
            _pUi->UI_OnNotifyBBarRectChange(&_rcBBarLoweredAspect);
            _pUi->UI_OnNotifyBBarVisibleChange(1);
#endif
        }

#ifndef OS_WINCE
        if(!SetTimer( _hwndBBar, BBAR_TIMERID_ANIM,
                  BBAR_ANIM_TIME / _sizeLoweredBBar.cy,
                  NULL ))
        {
            TRC_ERR((TB,_T("SetTimer failed - 0x%x"),
                     GetLastError()));
            return FALSE;
        }
        _state = bbarLowering;
#else
        ImmediateLowerBBar();
#endif

        return TRUE;
    }
    else
    {
        TRC_NRM((TB,_T("StartLowerBBar called when bar in wrong state 0x%x"),
                   _state));
        return FALSE;
    }

    DC_END_FN();
}

BOOL CBBar::StartRaiseBBar()
{
    DC_BEGIN_FN("StartRaiseBBar");

    if(_state == bbarLowered && !_fPinned && !_fLocked)
    {
        //
        // Kick off a timer to lower the bar
        //
        TRC_ASSERT(_sizeLoweredBBar.cy == _nBBarVertOffset,
                   (TB,_T("_nBBarVertOffset (%d) should be %d"),
                   _nBBarVertOffset,
                   _sizeLoweredBBar.cy));

        TRC_ASSERT(_hwndBBar,
                   (TB,_T("_hwndBBar is NULL")));

#ifndef OS_WINCE
        if(!SetTimer( _hwndBBar, BBAR_TIMERID_ANIM,
                  BBAR_ANIM_TIME / _sizeLoweredBBar.cy,
                  NULL ))
        {
            TRC_ERR((TB,_T("SetTimer failed - 0x%x"),
                     GetLastError()));
            return FALSE;
        }
        _state = bbarRaising;
#else
        ImmediateRaiseBBar();
#endif

        return TRUE;
    }
    else
    {
        TRC_NRM((TB,_T("StartRaiseBBar called when bar in wrong state 0x%x"),
                   _state));
        return FALSE;
    }

    DC_END_FN();
    return TRUE;
}


BOOL CBBar::Initialize(int desktopX, int desktopY, BOOL fStartRaised)
{
#ifndef OS_WINCE
    RECT rc;
#endif
    HWND hwndBBar;
    int  parentWidth = desktopX;
    int  bbarHeight  = 0;
    int  bbarWidth   = 0;
    DC_BEGIN_FN("Initialize");

    TRC_ASSERT( bbarNotInit == _state,
                (TB,_T("bbar already initialized - state:0x%x"),
                _state));

    //
    // Compute BBAR position based on remote desktop size
    //
    
    
#ifndef OS_WINCE    
    bbarHeight = GetSystemMetrics( SM_CYMENUSIZE ) + 2;
#else
    bbarHeight = GetSystemMetrics( SM_CYMENU ) + 2;
#endif
    bbarHeight = max(bbarHeight, BBAR_MIN_HEIGHT);
    _rcBBarLoweredAspect.bottom = bbarHeight;
    _rcBBarLoweredAspect.left = (LONG)( (100 - BBAR_PERCENT_WIDTH) / 200.0 * 
                                        parentWidth );
    _rcBBarLoweredAspect.right = parentWidth - _rcBBarLoweredAspect.left;
    _rcBBarLoweredAspect.top = 0;

    bbarWidth = _rcBBarLoweredAspect.right - _rcBBarLoweredAspect.left;

    _sizeLoweredBBar.cx = bbarWidth;
    _sizeLoweredBBar.cy = bbarHeight;

    hwndBBar = CreateWnd( _hInstance, _hwndParent,
               &_rcBBarLoweredAspect );

    if(hwndBBar)
    {
        if( fStartRaised )
        {
            //
            // Move the bar up by it's height to raise it
            //
            if(SetWindowPos(hwndBBar,
                            NULL,
                            _rcBBarLoweredAspect.left, //x
                            -_sizeLoweredBBar.cy, //y
                            0,0,
                            SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE ))
            {
                TRC_NRM((TB,_T("BBAR SetWindowPos failed - 0x%x"),
                         GetLastError()));
            }
        }

        BringWindowToTop( hwndBBar );
        ShowWindow( hwndBBar, SW_SHOWNOACTIVATE);

        //
        // Create the polygon region for the bounds of the BBar window
        // This cuts the corners off the edges.
        //
        POINT pts[4];
        int xOffset = parentWidth / 2 - _rcBBarLoweredAspect.left;
        pts[3].x =  -bbarWidth/2 + xOffset;
        pts[3].y =  0;

        pts[2].x =  bbarWidth/2  + xOffset;
        pts[2].y =  0;

        pts[1].x =  bbarWidth/2 - bbarHeight + xOffset;
        pts[1].y =  bbarHeight;

        pts[0].x =  -bbarWidth/2 + bbarHeight + xOffset;
        pts[0].y =  bbarHeight;

#ifndef OS_WINCE
        //
        // Polygon does not self intersect so winding mode is not
        // relevant
        //
        HRGN hRgn = CreatePolygonRgn( pts,
                                      4,
                                      ALTERNATE );
#else
        HRGN hRgn = GetBBarRgn(pts);
#endif
        if(hRgn)
        {
            if(!SetWindowRgn( hwndBBar, hRgn, TRUE))
            {
                TRC_ERR((TB,_T("SetWindowRgn failed - 0x%x"),
                         GetLastError()));
                //
                // In the success case the system will free
                // the region handle when it is done with it.
                // Here however, the call failed...
                //
                DeleteObject( hRgn );
            }
        }
        else
        {
            //
            // Not fatal, continue
            //
            TRC_ERR((TB,_T("CreatePolygonRgn failed - 0x%x"),
                     GetLastError()));
        }

        //
        // Bring the window to the TOP of the Z order
        //
        if(!SetWindowPos( hwndBBar,
                      HWND_TOPMOST,
                      0, 0, 0, 0,
                      SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE ))
        {
            TRC_ERR((TB,_T("SetWindowPos failed - 0x%x"),
                     GetLastError()));
            return FALSE;
        }

        //
        // Compute the rectangle for displayed text
        //
        // First figure out how much space to trim in the
        // x direction
        //
        int xDelta = _sizeLoweredBBar.cy * 2 +             //diagonal corners
                     BBAR_NUM_BUTTONS *
                     (BBAR_BUTTON_WIDTH + BBAR_BUTTON_SPACE); //button space
                    
        GetClientRect( hwndBBar, &_rcBBarDisplayTextArea);
        if(!InflateRect( &_rcBBarDisplayTextArea,
                        -xDelta,
                        0 ))
        {
            TRC_ABORT((TB,_T("InflateRect failed 0x%x"),
                       GetLastError()));
            return FALSE;
        }
        // Shave off from the bottom
        _rcBBarDisplayTextArea.bottom -= 1;

        if (!CreateToolbars())
        {
            TRC_ERR((TB,_T("CreateToolbars failed")));
            return FALSE;
        }

        //
        // Trigger a repaint of the background
        //
        InvalidateRect( hwndBBar, NULL, TRUE);
    }
    else
    {
        TRC_ERR((TB,_T("CreateWnd for BBar failed")));
        return FALSE;
    }

    if( fStartRaised )
    {
        SetState( bbarRaised );
        _nBBarVertOffset = 0;
    }
    else
    {
        SetState( bbarLowered );
        _nBBarVertOffset = _sizeLoweredBBar.cy;
    }
    

    DC_END_FN();
    return TRUE;
}

//
//	DIBs use RGBQUAD format:
//		0xbb 0xgg 0xrr 0x00
//
//	Reasonably efficient code to convert a COLORREF into an
//	RGBQUAD.
//
#define RGB_TO_RGBQUAD(r,g,b)   (RGB(b,g,r))
#define CLR_TO_RGBQUAD(clr)     (RGB(GetBValue(clr), GetGValue(clr), GetRValue(clr)))

//
// Internal helper that loads a bitmap and remaps it's colors
// to the system colors. Use this instead of LoadImage with the
// LR_LOADMAP3DCOLORS flag because that fn doesn't work well on NT4.
//
HBITMAP _LoadSysColorBitmap(HINSTANCE hInst, HRSRC hRsrc, BOOL bMono)
{
    struct COLORMAP
    {
        // use DWORD instead of RGBQUAD so we can compare two RGBQUADs easily
        DWORD rgbqFrom;
        int iSysColorTo;
    };
    static const COLORMAP sysColorMap[] =
    {
        // mapping from color in DIB to system color
        { RGB_TO_RGBQUAD(0x00, 0x00, 0x00),  COLOR_BTNTEXT },       // black
        { RGB_TO_RGBQUAD(0x80, 0x80, 0x80),  COLOR_BTNSHADOW },     // dark grey
        { RGB_TO_RGBQUAD(0xC0, 0xC0, 0xC0),  COLOR_BTNFACE },       // bright grey
        { RGB_TO_RGBQUAD(0xFF, 0xFF, 0xFF),  COLOR_BTNHIGHLIGHT }   // white
    };
    const int nMaps = 4;
    
    HGLOBAL hglb;
    if ((hglb = LoadResource(hInst, hRsrc)) == NULL)
        return NULL;
    
    LPBITMAPINFOHEADER lpBitmap = (LPBITMAPINFOHEADER)LockResource(hglb);
    if (lpBitmap == NULL)
        return NULL;
    
    // make copy of BITMAPINFOHEADER so we can modify the color table
    const int nColorTableSize = 16;
    UINT nSize = lpBitmap->biSize + nColorTableSize * sizeof(RGBQUAD);
    LPBITMAPINFOHEADER lpBitmapInfo = (LPBITMAPINFOHEADER)
                                            LocalAlloc(LPTR, nSize);
    if (lpBitmapInfo == NULL)
        return NULL;
    memcpy(lpBitmapInfo, lpBitmap, nSize);
    
    // color table is in RGBQUAD DIB format
    DWORD* pColorTable =
        (DWORD*)(((LPBYTE)lpBitmapInfo) + (UINT)lpBitmapInfo->biSize);

    for (int iColor = 0; iColor < nColorTableSize; iColor++)
    {
        // look for matching RGBQUAD color in original
        for (int i = 0; i < nMaps; i++)
        {
            if (pColorTable[iColor] == sysColorMap[i].rgbqFrom)
            {
                if (bMono)
                {
                    // all colors except text become white
                    if (sysColorMap[i].iSysColorTo != COLOR_BTNTEXT)
                        pColorTable[iColor] = RGB_TO_RGBQUAD(255, 255, 255);
                }
                else
                    pColorTable[iColor] =
                        CLR_TO_RGBQUAD(
                            GetSysColor(sysColorMap[i].iSysColorTo));
                break;
            }
        }
    }

    int nWidth = (int)lpBitmapInfo->biWidth;
    int nHeight = (int)lpBitmapInfo->biHeight;
    HDC hDCScreen = GetDC(NULL);
    HBITMAP hbm = CreateCompatibleBitmap(hDCScreen, nWidth, nHeight);

    if (hbm != NULL)
    {
        HDC hDCGlyphs = CreateCompatibleDC(hDCScreen);
        HBITMAP hbmOld = (HBITMAP)SelectObject(hDCGlyphs, hbm);
        
        LPBYTE lpBits;
        lpBits = (LPBYTE)(lpBitmap + 1);
        lpBits += (1 << (lpBitmapInfo->biBitCount)) * sizeof(RGBQUAD);
        
        StretchDIBits(hDCGlyphs, 0, 0, nWidth,
                      nHeight, 0, 0, nWidth, nHeight,
                      lpBits, (LPBITMAPINFO)lpBitmapInfo,
                      DIB_RGB_COLORS, SRCCOPY);
        SelectObject(hDCGlyphs, hbmOld);
        
        DeleteDC(hDCGlyphs);
    }
    ReleaseDC(NULL, hDCScreen);
    
    // free copy of bitmap info struct and resource itself
    LocalFree(lpBitmapInfo);
#ifndef OS_WINCE
    FreeResource(hglb);
#endif
    
    return hbm;
}


BOOL CBBar::CreateToolbars()
{
    DC_BEGIN_FN("CreateToolbars");

    //
    // Create toolbars
    //
    INT ret = 0;
    UINT imgIdx = 0;
    INITCOMMONCONTROLSEX icex;
    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC  = ICC_BAR_CLASSES;
    if(!InitCommonControlsEx( &icex ))
    {
        TRC_ERR((TB,_T("InitCommonControlsEx failed 0x%x"),
                   GetLastError()));
        return FALSE;
    }

    //
    // Right bar (close window,disconnect etc)
    //
    {
        TBBUTTON tbButtons [] = {
            {0, IDM_MINIMIZE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
#ifndef OS_WINCE
            {0, IDM_RESTORE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
#endif
            {0, IDM_CLOSE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0}
        };
        TBBUTTON tbRealButtons[3];

        HWND hwndRightToolbar = CreateToolbarEx( GetHwnd(),
                                            WS_CHILD | WS_VISIBLE |
                                            TBSTYLE_FLAT |
                                            CCS_NODIVIDER | CCS_NORESIZE,
                                            IDB_BBAR_TOOLBAR_RIGHT,
                                            0,
                                            _hInstance,
                                            0,
                                            NULL,
                                            0,
                                            12,
                                            12,
                                            16,
                                            16,
                                            sizeof(TBBUTTON) );
        if(!hwndRightToolbar)
        {
            TRC_ERR((TB,_T("CreateToolbarEx failed 0x%x"),
                       GetLastError()));
            return FALSE;
        }

        //
        // Add images
        //
        if (!AddReplaceImage(hwndRightToolbar,
                             IDB_BBAR_TOOLBAR_RIGHT,
#ifndef OS_WINCE
                             3, //image makes up 3 buttons
#else
                             2, //2 buttons on CE
#endif
                             &_hbmpRightImage,
                             &imgIdx))
        {
            TRC_ERR((TB,_T("AddReplaceImage for rt toolbar failed")));
            return FALSE;
        }

        //
        // Associate images with buttons
        //
        tbButtons[0].iBitmap = imgIdx;
        tbButtons[1].iBitmap = imgIdx + 1;
#ifndef OS_WINCE
        tbButtons[2].iBitmap = imgIdx + 2;
#endif

        //
        // Not all buttons are to be added, figure out which here
        // and setup the real buttons array
        //
        ULONG nNumButtons = 0;
        if (_fShowMinimize) {
            tbRealButtons[nNumButtons++] = tbButtons[0];
        }
        if (_fShowRestore) {
            tbRealButtons[nNumButtons++] = tbButtons[1];
        }
        // Always show the close button
#ifndef OS_WINCE
        tbRealButtons[nNumButtons++] = tbButtons[2];
#endif

        //
        // Add the buttons
        //
        ret = SendMessage( hwndRightToolbar,
                     TB_ADDBUTTONS,
                     nNumButtons,
                     (LPARAM)(LPTBBUTTON) &tbRealButtons );

        if(-1 == ret)
        {
            TRC_ERR((TB,_T("TB_ADDBUTTONS failed")));
            return FALSE;
        }

        //
        // Move the toolbar
        //

        if(!MoveWindow( hwndRightToolbar,
                    _sizeLoweredBBar.cx - _sizeLoweredBBar.cy -
                    ((BBAR_BUTTON_SPACE + BBAR_BUTTON_WIDTH)*(nNumButtons+1)),
                    0,
                    ((BBAR_BUTTON_SPACE + BBAR_BUTTON_WIDTH)*(nNumButtons+1)),
                    BBAR_BUTTON_HEIGHT*2,
                    TRUE))
        {
            TRC_ERR((TB,_T("MoveWindow failed")));
            return FALSE;
        }

        if(!ShowWindow ( hwndRightToolbar,
                         SW_SHOWNORMAL) )
        {
            TRC_ERR((TB,_T("ShowWindow failed")));
            return FALSE;
        }
        _hwndWinControlsBar = hwndRightToolbar;
    }

    //
    // Left bar (pin)
    //
    {
        TBBUTTON tbButtons [] = {
            {0, IDM_PIN,
                TBSTATE_ENABLED | (_fPinned ? TBSTATE_PRESSED : 0),
                TBSTYLE_BUTTON, 0L, 0}
        };

        HWND hwndLeftToolbar = CreateToolbarEx( GetHwnd(),
                                            WS_CHILD | WS_VISIBLE |
                                            TBSTYLE_FLAT |
                                            CCS_NODIVIDER | CCS_NORESIZE,
                                            IDB_BBAR_TOOLBAR_LEFT,
                                            0,
                                            _hInstance,
                                            0,
                                            NULL,
                                            0,
                                            12,
                                            12,
                                            16,
                                            16,
                                            sizeof(TBBUTTON) );
        if(!hwndLeftToolbar)
        {
            TRC_ERR((TB,_T("CreateToolbarEx failed 0x%x"),
                       GetLastError()));
            return FALSE;
        }

        //
        // Add images
        //
        if (!AddReplaceImage(hwndLeftToolbar,
                             IDB_BBAR_TOOLBAR_LEFT,
                             2, //image makes up 2 buttons
                             &_hbmpLeftImage,
                             &imgIdx))
        {
            TRC_ERR((TB,_T("AddReplaceImage for lt toolbar failed")));
            return FALSE;
        }

		_nPinUpImage = imgIdx;
        _nPinDownImage = imgIdx + 1;

        //
        // Associate images with buttons
        //
        tbButtons[0].iBitmap = _fPinned ? _nPinDownImage : _nPinUpImage;


        //
        // Add the button
        //
        ret = SendMessage( hwndLeftToolbar,
                     TB_ADDBUTTONS,
                     1,
                     (LPARAM)(LPTBBUTTON) &tbButtons );

        if(-1 == ret)
        {
            TRC_ERR((TB,_T("TB_ADDBUTTONS failed")));
            return FALSE;
        }

        //
        // Move the toolbar
        //

        if(!MoveWindow( hwndLeftToolbar,
                    _sizeLoweredBBar.cy + BBAR_BUTTON_SPACE,
                    0,
                    (BBAR_BUTTON_SPACE + BBAR_BUTTON_WIDTH) * 2,
                    BBAR_BUTTON_HEIGHT*2,
                    TRUE))
        {
            TRC_ERR((TB,_T("MoveWindow failed")));
            return FALSE;
        }

        if(!ShowWindow ( hwndLeftToolbar,
                         SW_SHOWNORMAL) )
        {
            TRC_ERR((TB,_T("ShowWindow failed")));
            return FALSE;
        }

        _hwndPinBar = hwndLeftToolbar;
    }

    DC_END_FN();
    return TRUE;
}

//
// ReloadImages for the toolbar including
// refreshing the colors
//
BOOL CBBar::ReloadImages()
{
    BOOL rc = FALSE;
#ifndef OS_WINCE
    INT ret;
#endif
    DC_BEGIN_FN("ReloadImages");

    if (!_hwndWinControlsBar || !_hwndPinBar)
    {
        TRC_ERR((TB,_T("Toolbars not initialized")));
        DC_QUIT;
    }

    //
    // Replace images
    //
    if (!AddReplaceImage(_hwndWinControlsBar,
                         IDB_BBAR_TOOLBAR_RIGHT,
                         3, //image makes up 3 buttons
                         &_hbmpRightImage,
                         NULL))
    {
        TRC_ERR((TB,_T("AddReplaceImage for rt toolbar failed")));
        return FALSE;
    }


    if (!AddReplaceImage(_hwndPinBar,
                         IDB_BBAR_TOOLBAR_LEFT,
                         2, //image makes up 3 buttons
                         &_hbmpLeftImage,
                         NULL))
    {
        TRC_ERR((TB,_T("AddReplaceImage for lt toolbar failed")));
        return FALSE;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}

//
// Adds or replaces an image to a toolbar
// Params:
// hwndToolbar - toolbar to act on
// rsrcId      - resource ID of the bitmap
// nCells      - number of image cells
// phbmpOldImage - [IN/OUT] handle to previous image, on return is
//                          set to current image
// pImgIndex     - [OUT] index to the first image added
//
BOOL CBBar::AddReplaceImage(HWND hwndToolbar,
                            UINT rsrcId,
                            UINT nCells,
                            HBITMAP* phbmpOldImage,
                            PUINT pImgIndex)
{
    BOOL rc = FALSE;
    INT ret = 0;
    HBITMAP hbmpNew = NULL;
    HRSRC hBmpRsrc = NULL;

    DC_BEGIN_FN("AddReplaceImage");

    //
    // Replace images
    //
    hBmpRsrc = FindResource(_hInstance,
                            MAKEINTRESOURCE(rsrcId),
                            RT_BITMAP);
    if (hBmpRsrc)
    {
        hbmpNew = _LoadSysColorBitmap(_hInstance, hBmpRsrc, FALSE);
        if (hbmpNew)
        {
            if (NULL == *phbmpOldImage)
            {
                TBADDBITMAP tbAddBitmap;
                tbAddBitmap.hInst = NULL;
                tbAddBitmap.nID = (UINT_PTR)hbmpNew;

                ret = SendMessage( hwndToolbar,
                                   TB_ADDBITMAP,
                                   nCells,
                                   (LPARAM)(LPTBADDBITMAP)&tbAddBitmap );
            }
            else
            {
                TBREPLACEBITMAP tbRplBitmap;
                tbRplBitmap.hInstOld = NULL;
                tbRplBitmap.nIDOld = (UINT_PTR)*phbmpOldImage;
                tbRplBitmap.hInstNew = NULL;
                tbRplBitmap.nIDNew = (UINT_PTR)hbmpNew;
                tbRplBitmap.nButtons = nCells;
                ret = SendMessage(hwndToolbar,
                                  TB_REPLACEBITMAP,
                                  0,
                                  (LPARAM)(LPTBADDBITMAP)&tbRplBitmap);
            }
            if (-1 != ret)
            {
                //Delete the old bitmap
                if (*phbmpOldImage)
                {
                    DeleteObject(*phbmpOldImage);
                }
                *phbmpOldImage = hbmpNew;
                if (pImgIndex)
                {
                    *pImgIndex = ret;
                }
            }
            else
            {
                TRC_ERR((TB,_T("TB_ADDBITMAP failed")));
                DC_QUIT;
            }
        }
        else
        {
            TRC_ERR((TB,_T("LoadSysColorBitmap failed rsrcid:%d"), rsrcId));
            DC_QUIT;
        }
    }
    else
    {
        TRC_ERR((TB,_T("Unable to find rsrc: %d"), rsrcId));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


//
// Create the window
// params:
//  hInstance   - app instance
//  _hwndBBarParent  - parent window
//  szClassName - window class name (will create)
//  dwStyle     - window style
// returns:
//  window handle
//
HWND CBBar::CreateWnd(HINSTANCE hInstance,HWND _hwndBBarParent,
                      LPRECT lpInitialRect)
{
    BOOL rc = FALSE;
#ifndef OS_WINCE
    WNDCLASSEX wndclass;
#else
    WNDCLASS wndclass;
#endif
    WNDCLASS tmpwc;

    DC_BEGIN_FN("CreateWnd");

    TRC_ASSERT(hInstance, (TB, _T("hInstance is null")));
    TRC_ASSERT(lpInitialRect, (TB, _T("lpInitialRect is null")));
    if(!hInstance || !lpInitialRect)
    {
        return NULL;
    }

    TRC_ASSERT(!_hwndBBar, (TB,_T("Double create window. Could be leaking!!!")));
    _hInstance = hInstance;
    
#ifndef OS_WINCE    
    wndclass.cbSize         = sizeof (wndclass);
#endif
    wndclass.style          = CS_DBLCLKS;
    wndclass.lpfnWndProc    = CBBar::StaticBBarWndProc;
    wndclass.cbClsExtra     = 0;
    wndclass.cbWndExtra     = 0;
    wndclass.hInstance      = hInstance;
    wndclass.hIcon          = NULL;
    wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground  = (HBRUSH) GetSysColorBrush(COLOR_INFOBK);
    wndclass.lpszMenuName   = NULL;
    wndclass.lpszClassName  = BBAR_CLASSNAME;
#ifndef OS_WINCE
    wndclass.hIconSm        = NULL;
#endif

    SetLastError(0);
    if(!GetClassInfo( hInstance, BBAR_CLASSNAME, &tmpwc))
    {
#ifndef OS_WINCE
        if ((0 == RegisterClassEx(&wndclass)) &&
#else
        if ((0 == RegisterClass(&wndclass)) &&
#endif
            (ERROR_CLASS_ALREADY_EXISTS != GetLastError()))
        {
            TRC_ERR((TB,_T("RegisterClassEx failed: %d"),GetLastError()));
            return NULL;
        }
    }
    _hwndBBar = CreateWindowEx(0,
                           BBAR_CLASSNAME,
                           NULL,
                           WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS,
                           lpInitialRect->left,
                           lpInitialRect->top,
                           lpInitialRect->right - lpInitialRect->left,
                           lpInitialRect->bottom - lpInitialRect->top,
                           _hwndBBarParent,
                           NULL,
                           hInstance,
                           this);

    if(_hwndBBar)
    {
        // put a reference to the current object into the hwnd
        // so we can access the object from the WndProc
        SetLastError(0);
        if(!SetWindowLongPtr(_hwndBBar, GWLP_USERDATA, (LONG_PTR)this))
        {
            if(GetLastError())
            {
                TRC_ERR((TB,_T("SetWindowLongPtr failed 0x%x"),
                         GetLastError()));
                return NULL;
            }
        }
    }
    else
    {
        TRC_ERR((TB,_T("CreateWindow failed 0x%x"), GetLastError()));
        return NULL;
    }
                         
    
    DC_END_FN();
    return _hwndBBar;
}


LRESULT CALLBACK CBBar::StaticBBarWndProc(HWND hwnd,
                                          UINT uMsg,
                                          WPARAM wParam,
                                          LPARAM lParam)
{
    DC_BEGIN_FN("StatiCBBarProc");
	// pull out the pointer to the container object associated with this hwnd
	CBBar *pwnd = (CBBar *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if(pwnd)
    {
        return pwnd->BBarWndProc( hwnd, uMsg, wParam, lParam);
    }
    else
    {
        return DefWindowProc (hwnd, uMsg, wParam, lParam);
    }
    DC_END_FN();
}

LRESULT CALLBACK CBBar::BBarWndProc(HWND hwnd,
                                    UINT uMsg,
                                    WPARAM wParam,
                                    LPARAM lParam)
{
    DC_BEGIN_FN("BBarWndProc");

    switch (uMsg)
    {
        case WM_ERASEBKGND:
        {
            return OnEraseBkgnd(hwnd, uMsg, wParam, lParam);
        }
        break;

        case WM_LBUTTONDBLCLK:
        {
            OnCmdRestore();
            return 0L;
        }
        break;

        case WM_PAINT:
        {
            return OnPaint(hwnd, uMsg, wParam, lParam);
        }
        break;

        case WM_SYSCOLORCHANGE:
        {
            InvalidateRect( hwnd, NULL, TRUE);
            return 0L;
        }
        break;

        case WM_TIMER:
        {
            if( BBAR_TIMERID_ANIM == wParam)
            {
#ifndef OS_WINCE
                if(_state == bbarLowering ||
                   _state == bbarRaising)
                {
                    BOOL fReachedEndOfAnimation = FALSE;
                    int delta = (bbarLowering == _state ) ? 1 : -1;
                    _nBBarVertOffset+= delta;

                    if(SetWindowPos(_hwndBBar,
                                    NULL,
                                    _rcBBarLoweredAspect.left, //x
                                    _nBBarVertOffset - _sizeLoweredBBar.cy, //y
                                    0,0,
                                    SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE ))
                    {
                        TRC_ALT((TB,_T("SetWindowPos failed - 0x%x"),
                                 GetLastError()));
                    }

                    if(_state == bbarLowering)
                    {
                        if(_nBBarVertOffset >= _sizeLoweredBBar.cy)
                        {
                            _nBBarVertOffset = _sizeLoweredBBar.cy;
                            _state = bbarLowered;
                            fReachedEndOfAnimation = TRUE;
                            OnBBarLowered();
                        }
                    }
                    else if(_state == bbarRaising)
                    {
                        if(_nBBarVertOffset <= 0)
                        {
                            _nBBarVertOffset = 0;
                            _state = bbarRaised;
                            fReachedEndOfAnimation = TRUE;
                            OnBBarRaised();
                        }
                    }

                    if(fReachedEndOfAnimation)
                    {
                        if(!KillTimer( _hwndBBar, BBAR_TIMERID_ANIM ))
                        {
                            TRC_ERR((TB,_T("KillTimer failed - 0x%x"),
                                     GetLastError()));
                        }
                    }
                }
#endif
            }
            else if (BBAR_TIMERID_AUTOHIDE == wParam)
            {
                //
                // If the mouse is within the hotzone
                // then don't autohide. Otherwise kill the autohide
                // timer and kick off a bbar raise
                //
                if(_state == bbarLowered)
                {
                    POINT pt;
                    RECT  rc;
                    GetCursorPos(&pt);

                    //
                    // Don't hide if mouse hasn't moved
                    //
                    if(_ptLastAutoHideMousePos.x != pt.x &&
                       _ptLastAutoHideMousePos.y != pt.y)
                    {
                        _ptLastAutoHideMousePos.x = pt.x;
                        _ptLastAutoHideMousePos.y = pt.y;
                        //
                        // Get window rect in screen coordinates
                        //
                        GetWindowRect( _hwndBBar, &rc);
                        //
                        // Don't hide if the cursor is within
                        // the bbar rect
                        //
                        if(!PtInRect(&rc, pt))
                        {
                            // Stop the autohide timer because we're going
                            // to hide
                            if(!KillTimer( _hwndBBar, BBAR_TIMERID_AUTOHIDE ))
                            {
                                TRC_ERR((TB,_T("KillTimer failed - 0x%x"),
                                         GetLastError()));
                            }
                            StartRaiseBBar();
                        }
                    }
                    else
                    {
                        //
                        // Don't autohide the bbar because the mouse
                        // has not moved, this prevents the raise/lower
                        // loop problem because the hotzone (see IH) region and
                        // auto-hide prevention regions are different
                        // (by design).
                        //
                        TRC_NRM((TB,
                                 _T("Autohide timer fired but mouse not moved")));
                    }
                }
            }

            return 0L;
        }
        break;

#ifndef OS_WINCE
        case WM_WINDOWPOSCHANGING:
        {
            if(_fBlockZOrderChanges)
            {
                LPWINDOWPOS lpwp = (LPWINDOWPOS) lParam;
                lpwp->flags |= SWP_NOZORDER;
            }
            return 0L;
        }
        break;
#endif

        case WM_COMMAND:
        {
            switch(LOWORD(wParam))
            {
                case IDM_MINIMIZE:
                {
                    OnCmdMinimize();
                }
                break;

                case IDM_RESTORE:
                {
                    OnCmdRestore();
                }
                break;

                case IDM_CLOSE:
                {
                    OnCmdClose();
                }
                break;

                case IDM_PIN:
                {
                    OnCmdPin();
                }
                break;
            }
            return 0L;
        }
        break;

        default:
        {
            return DefWindowProc( hwnd, uMsg, wParam, lParam);
        }
        break;
    }

    DC_END_FN();
}

VOID CBBar::SetState(BBarState newState)
{
    DC_BEGIN_FN("SetState");

    TRC_NRM((TB,_T("BBar old state: 0x%x - new state: 0x%x"),
             _state, newState));

    _state = newState;

    DC_END_FN();
}

LRESULT CBBar::OnEraseBkgnd(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    RECT rc;
    HDC  hDC = NULL;
    HBRUSH hBrToolTipBgCol = NULL;
#ifndef OS_WINCE
    HGDIOBJ hPrevBr = NULL;
    COLORREF prevCol;
#endif
    HPEN    hPenNew = NULL, hPenOld = NULL, hPenOri = NULL;
    DC_BEGIN_FN("OnEraseBkgnd");

    hDC = (HDC)wParam;
    GetClientRect( hwnd, &rc );
    
    //
    // Repaint the background as follows
    // 1) fill the window with the TOOLTIP bg color
    // 2) draw the edges in solid black
    // 3) add a grey line to the bottom horizontal edge because it looks
    //    really cool
    //

    hBrToolTipBgCol = (HBRUSH) GetSysColorBrush(COLOR_INFOBK);
    FillRect(hDC, &rc, hBrToolTipBgCol);


#ifdef OS_WINCE
    //On CE, the toolbar sends an extra WM_ERASEBKGND message to the parent with its DC in wParam.
    //The origin of that DC, is the where the toolbar is located. So we want to use supplied DC for FillRect
    //but not for drawing lines
    hDC = GetDC(hwnd);
#endif
    hPenNew = CreatePen( PS_SOLID, 0 , COLOR_BLACK);
    if (NULL != hPenNew) {
        hPenOri = SelectPen(hDC, hPenNew);
    }
    
    //
    // Left diagonal corner (assumes 45degree line)
    //
    MoveToEx( hDC, 0, 0, NULL);
    LineTo( hDC,
            _sizeLoweredBBar.cy,
            _sizeLoweredBBar.cy );

    //
    // Right diagonal corner (assumes 45degree line)
    // (bias by one pixel to end up inside the clipping region)
    //
    MoveToEx( hDC, _sizeLoweredBBar.cx - 1, 0, NULL);
    LineTo( hDC,
            _sizeLoweredBBar.cx - _sizeLoweredBBar.cy -1,
            _sizeLoweredBBar.cy );

    //
    // Bottom black line
    // bias by 1 pixel up to lie inside clip region
    //
    MoveToEx( hDC, _sizeLoweredBBar.cy,
              _sizeLoweredBBar.cy - 1, NULL);
    LineTo( hDC,
            _sizeLoweredBBar.cx - _sizeLoweredBBar.cy,
            _sizeLoweredBBar.cy - 1);

    if (NULL != hPenOri) {
        SelectPen(hDC, hPenOri);
    }
    if (NULL != hPenNew) {
        DeleteObject(hPenNew); 
        hPenNew = NULL;
    }
    //
    // Thin grey line above bottom gray line
    //
    hPenNew = CreatePen( PS_SOLID, 0 , COLOR_DKGREY);
    if (NULL != hPenNew) {
        hPenOri = SelectPen(hDC, hPenNew);
    }

    MoveToEx( hDC, _sizeLoweredBBar.cy - 1,
              _sizeLoweredBBar.cy - 2, NULL);
    LineTo( hDC,
            _sizeLoweredBBar.cx - _sizeLoweredBBar.cy + 1,
            _sizeLoweredBBar.cy - 2);

    //
    // Restore DC
    //
#ifndef OS_WINCE
    if (NULL != hPenOri) {
        SelectPen( hDC, hPenOri);
    }
#else
    SelectPen( hDC, GetStockObject(BLACK_PEN));
#endif

    if (NULL != hPenNew) {
        DeleteObject( hPenNew);
        hPenNew = NULL;
    }

#ifdef OS_WINCE
    ReleaseDC(hwnd, hDC);
#endif

    DC_END_FN();
    return TRUE;
}

VOID  CBBar::SetDisplayedText(LPTSTR szText)
{
    HRESULT hr;
    DC_BEGIN_FN("SetDisplayedText");

    if(szText) {
        hr = StringCchCopy(_szDisplayedText,
                           SIZE_TCHARS(_szDisplayedText),
                           szText);

        if (FAILED(hr)) {
            TRC_ERR((TB,_T("StringCopy for dispayed text failed: 0x%x"),hr));
        }
    }
    else {
        _szDisplayedText[0] = NULL;
    }

    if(_hwndBBar && _state != bbarNotInit) {
        //Trigger a repaint
        InvalidateRect( _hwndBBar, NULL, TRUE);
    }

    DC_END_FN();
}

LRESULT CBBar::OnPaint(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT ps;
    DC_BEGIN_FN("OnPaint");

    if(_state != bbarNotInit)
    {
        COLORREF oldCol;
        INT      oldMode;
        HFONT    hOldFont;
        COLORREF oldTextCol;

        //
        // Draw the displayed text
        //
        BeginPaint( hwnd, &ps);

        oldCol = SetBkColor( ps.hdc, GetSysColor(COLOR_INFOBK)); 
        oldMode = SetBkMode( ps.hdc, OPAQUE);
        oldTextCol = SetTextColor( ps.hdc, GetSysColor(COLOR_INFOTEXT));
        hOldFont = (HFONT)SelectObject( ps.hdc,
#ifndef OS_WINCE
                                 GetStockObject( DEFAULT_GUI_FONT));
#else
                                 GetStockObject( SYSTEM_FONT));
#endif
        
        DrawText(ps.hdc,
                 _szDisplayedText,
                 _tcslen(_szDisplayedText),
                 &_rcBBarDisplayTextArea,
                 DT_CENTER | DT_VCENTER | DT_SINGLELINE);

        SetBkColor( ps.hdc, oldCol);
        SetBkMode( ps.hdc, oldMode);
        SetTextColor( ps.hdc, oldTextCol);
        SelectObject( ps.hdc, hOldFont);

        EndPaint( hwnd, &ps);
    }

    DC_END_FN();
    return 0;
}

//
// Internal event handler for bbar lowered
//
VOID CBBar::OnBBarLowered()
{
    DC_BEGIN_FN("OnBBarLowered");

    //
    // Kick off the autohide timer
    //
    TRC_ASSERT(_state == bbarLowered,
               (TB,_T("_state should be lowered...0x%x"),
                _state));

    TRC_ASSERT(_nBBarAutoHideTime,
               (TB,_T("_nBBarAutoHideTime is 0")));
    if(bbarLowered == _state)
    {
        if (!_fPinned || !_fLocked)
        {
            if(!SetTimer( _hwndBBar, BBAR_TIMERID_AUTOHIDE,
                      _nBBarAutoHideTime, NULL ))
            {
                TRC_ERR((TB,_T("SetTimer failed - 0x%x"),
                         GetLastError()));
                //
                // Bail out
                //
                return;
            }

            // After bbar has lowered once reset
            // the autohide interval time to the shorter
            // interval.
            _nBBarAutoHideTime = BBAR_AUTOHIDE_TIME;
        }
    }
    

    DC_END_FN();
}

//
// Internal event handler for bbar raised
//
VOID CBBar::OnBBarRaised()
{
    DC_BEGIN_FN("OnBBarRaised");
#ifdef DISABLE_SHADOW_IN_FULLSCREEN
    _pUi->UI_OnNotifyBBarVisibleChange(0);
#endif
    DC_END_FN();
}


VOID CBBar::OnBBarHotzoneFired()
{
    DC_BEGIN_FN("OnBBarHotzoneFired");

    //
    // Only allow the bbar to drop on the timer if it's enabled
    //
    if (_fBBarEnabled &&
        _state == bbarRaised &&
       _pUi->UI_IsFullScreen())
    {
        StartLowerBBar();
    }

    DC_END_FN();
}

VOID CBBar::OnCmdMinimize()
{
    DC_BEGIN_FN("OnCmdLock");

    TRC_NRM((TB,_T("BBAR Command Minimize")));

    TRC_ASSERT( bbarNotInit != _state,
                (TB,_T("bbar not initalized - state:0x%x"),
                _state));

    if(bbarNotInit != _state &&
       _pUi->UI_IsFullScreen())
    {
        _pUi->UI_RequestMinimize();
    }

    DC_END_FN();
}

VOID CBBar::OnCmdRestore()
{
    DC_BEGIN_FN("OnCmdLock");

    TRC_NRM((TB,_T("BBAR Command Restore")));

    TRC_ASSERT( bbarNotInit != _state,
            (TB,_T("bbar not initalized - state:0x%x"),
            _state));

    if(bbarNotInit != _state)
    {
        _pUi->UI_ToggleFullScreenMode();
    }


    DC_END_FN();
}

VOID CBBar::OnCmdClose()
{
    DC_BEGIN_FN("OnCmdClose");

    TRC_NRM((TB,_T("BBAR Command Close")));

    TRC_ASSERT( bbarNotInit != _state,
                (TB,_T("bbar not initalized - state:0x%x"),
                _state));

    if (bbarNotInit != _state)
    {
        //
        // Dispatch a close request to the core
        //
        if (!_pUi->UI_UserRequestedClose())
        {
            // Request for clean close down (including firing of events
            // asking container if they really want to close) has failed
            // so trigger an immediate disconnection without user prompts
            TRC_ALT((TB,_T("UI_UserRequestedClose failed, disconnect now!")));
            _pUi->UI_UserInitiatedDisconnect(NL_DISCONNECT_LOCAL);
        }
    }

    DC_END_FN();
}

VOID CBBar::OnCmdPin()
{
    DC_BEGIN_FN("OnCmdPin");

    TRC_NRM((TB,_T("BBAR Command Pin")));

    TRC_ASSERT( bbarNotInit != _state,
                (TB,_T("bbar not initalized - state:0x%x"),
                _state));

    TRC_ASSERT(_hwndPinBar, (TB,_T("Left bar not created")));

    if (bbarNotInit != _state)
    {
        //
        // The pin button acts like a toggle
        //
        _fPinned = !_fPinned;

        SendMessage(_hwndPinBar, TB_PRESSBUTTON,
                    IDM_PIN, MAKELONG(_fPinned,0));

        SendMessage(_hwndPinBar, TB_CHANGEBITMAP,
                    IDM_PIN,
                    MAKELPARAM( _fPinned ?_nPinDownImage : _nPinUpImage, 0));

        if(!_fPinned && bbarLowered == _state )
        {
            // We just unpinned trigger an OnLowered event
            // to startup the autohide timers
            OnBBarLowered();
        }
    }

    DC_END_FN();
}

//
// Notification from core that we entered fullscreen mode
//
VOID CBBar::OnNotifyEnterFullScreen()
{
    DC_BEGIN_FN("OnNotifyEnterFullScreen");

    //
    // Lower bbar to give a visual cue
    //
    if(_state != bbarNotInit)
    {
        StartLowerBBar();
    }

    DC_END_FN();
}

//
// Notification from core that we left fullscreen mode
//
VOID CBBar::OnNotifyLeaveFullScreen()
{
    DC_BEGIN_FN("OnNotifyLeaveFullScreen");

    //
    // Disable the bbar in windowed mode
    //
    if(_state != bbarNotInit)
    {
        //Kill timers
        KillTimer( _hwndBBar, BBAR_TIMERID_AUTOHIDE);
        KillTimer( _hwndBBar, BBAR_TIMERID_ANIM);

        //Immediate raise of the bbar
        if(_state != bbarRaised)
        {
            ImmediateRaiseBBar();
        }
    }

    DC_END_FN();
}


//
// Raise the bbar without much fanfare (i.e animations)
// this is used to quickly 'hide' the bbar
//
BOOL CBBar::ImmediateRaiseBBar()
{
    DC_BEGIN_FN("ImmediateRaiseBBar");

    if(_state != bbarNotInit &&
       _state != bbarRaised)
    {
        _nBBarVertOffset = 0;
        _state = bbarRaised;

        if(SetWindowPos(_hwndBBar,
                        NULL,
                        _rcBBarLoweredAspect.left, //x
                        _nBBarVertOffset - _sizeLoweredBBar.cy, //y
                        0,0,
                        SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE ))
        {
            TRC_ALT((TB,_T("SetWindowPos failed - 0x%x"),
                     GetLastError()));
        }


        OnBBarRaised();
    }

    DC_END_FN();
    return TRUE;
}

#ifdef OS_WINCE
//
// Lower the bbar without much fanfare (i.e animations)
// this is used to quickly 'show' the bbar
//
BOOL CBBar::ImmediateLowerBBar()
{
    DC_BEGIN_FN("ImmediateLowerBBar");

    if(_state != bbarNotInit &&
       _state != bbarLowered)
    {
        _nBBarVertOffset = _sizeLoweredBBar.cy;
        _state = bbarLowered;

        if(!SetWindowPos(_hwndBBar,
                        NULL,
                        _rcBBarLoweredAspect.left, //x
                        _nBBarVertOffset - _sizeLoweredBBar.cy, //y
                        0,0,
                        SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE ))
        {
            TRC_ALT((TB,_T("SetWindowPos failed - 0x%x"),
                     GetLastError()));
        }


        OnBBarLowered();
    }

    DC_END_FN();
    return TRUE;
}
#endif

VOID CBBar::OnSysColorChange()
{
    DC_BEGIN_FN("OnSysColorChange");

    if (_state != bbarNotInit)
    {
        //
        // Force a reload of the images
        // so they get updated for the new system colors
        // 
        ReloadImages();
    }

    DC_END_FN();
}

#ifdef OS_WINCE

//Assumes four points in the array
HRGN CBBar::GetBBarRgn(POINT *pts)
{
    DC_BEGIN_FN("CBBar::GetBBarRgn");

    HRGN hRgn=NULL, hRgn1=NULL;
    int nRect, nTotalRects, nStart;
    RGNDATA *pRgnData = NULL;
    RECT *pRect = NULL;
    BOOL bSuccess = FALSE;

    TRC_ASSERT((pts[2].x - pts[1].x == pts[0].x - pts[3].x), (TB,_T("Invalid points!")));

    nTotalRects = (pts[2].x - pts[1].x + 1) /2; 

    pRgnData = (RGNDATA *)LocalAlloc(0, sizeof(RGNDATAHEADER) + (sizeof(RECT)*nTotalRects));
    if (!pRgnData)
        return NULL;

    pRgnData->rdh.dwSize = sizeof(RGNDATAHEADER);
    pRgnData->rdh.iType = RDH_RECTANGLES;
    pRgnData->rdh.nCount = nTotalRects;
    pRgnData->rdh.nRgnSize = (sizeof(RECT)*nTotalRects);

    pRect = (RECT *)pRgnData->Buffer;

    hRgn = CreateRectRgn(pts[0].x + 1, pts[3].y, pts[1].x, pts[1].y);
    if (!hRgn)
        DC_QUIT;
    
    SetRect(&(pRgnData->rdh.rcBound), 0, 0, pts[0].x, pts[0].y);

    //The left triangle
    nStart = pts[3].x + 1;
    for (nRect = 0;  nRect < nTotalRects; nRect++)
    {
        SetRect(&pRect[nRect], nStart, pts[3].y, nStart + 1, nStart);
        TRC_DBG((TB,_T("pRect[%d]={%d,%d,%d,%d}"), nRect, pRect[nRect].left, pRect[nRect].top, pRect[nRect].right, pRect[nRect].bottom));
        nStart += 2;
    }

    hRgn1 = ExtCreateRegion(NULL, sizeof(RGNDATAHEADER) + (sizeof(RECT)*nTotalRects), pRgnData);
    if (!hRgn1)
        DC_QUIT;

    if (ERROR == CombineRgn(hRgn, hRgn, hRgn1, RGN_OR))
        DC_QUIT;

    DeleteObject(hRgn1);

    //The left triangle offset by one pixel to avoid a striped triangle
    nStart = pts[3].x + 2;
    for (nRect = 0;  nRect < nTotalRects; nRect++)
    {
        SetRect(&pRect[nRect], nStart, pts[3].y, nStart + 1, nStart);
        TRC_DBG((TB,_T("pRect[%d]={%d,%d,%d,%d}"), nRect, pRect[nRect].left, pRect[nRect].top, pRect[nRect].right, pRect[nRect].bottom));
        nStart += 2;
    }
    
    hRgn1 = ExtCreateRegion(NULL, sizeof(RGNDATAHEADER) + (sizeof(RECT)*nTotalRects), pRgnData);
    if (!hRgn1)
        DC_QUIT;

    if (ERROR == CombineRgn(hRgn, hRgn, hRgn1, RGN_OR))
        DC_QUIT;

    DeleteObject(hRgn1);

    //The right triangle
    nStart = pts[1].x - 1; 
    for (nRect = 0;  nRect < nTotalRects; nRect++)
    {
        SetRect(&pRect[nRect], nStart, pts[3].y, nStart + 1, pts[2].x - nStart);
        TRC_DBG((TB,_T("pRect[%d]={%d,%d,%d,%d}"), nRect, pRect[nRect].left, pRect[nRect].top, pRect[nRect].right, pRect[nRect].bottom));
        nStart += 2;
    }
    
    hRgn1 = ExtCreateRegion(NULL, sizeof(RGNDATAHEADER) + (sizeof(RECT)*nTotalRects), pRgnData);
    if (!hRgn1)
        DC_QUIT;

    if (ERROR == CombineRgn(hRgn, hRgn, hRgn1, RGN_OR))
        DC_QUIT;

    DeleteObject(hRgn1);

    //The right triangle offset by one pixel to avoid a striped triangle
    nStart = pts[1].x; 
    for (nRect = 0;  nRect < nTotalRects; nRect++)
    {
        SetRect(&pRect[nRect], nStart, pts[3].y, nStart + 1, pts[2].x - nStart);
        TRC_DBG((TB,_T("pRect[%d]={%d,%d,%d,%d}"), nRect, pRect[nRect].left, pRect[nRect].top, pRect[nRect].right, pRect[nRect].bottom));
        nStart += 2;
    }
    
    hRgn1 = ExtCreateRegion(NULL, sizeof(RGNDATAHEADER) + (sizeof(RECT)*nTotalRects), pRgnData);
    if (!hRgn1)
        DC_QUIT;

    if (ERROR == CombineRgn(hRgn, hRgn, hRgn1, RGN_OR))
        DC_QUIT;

    DeleteObject(hRgn1);
    hRgn1 = NULL;

    bSuccess = TRUE;

DC_EXIT_POINT:

    LocalFree(pRgnData);

    if (hRgn1)
        DeleteObject(hRgn1);

    if (!bSuccess && hRgn)
    {
        DeleteObject(hRgn);
        hRgn = NULL;
    }

    DC_END_FN();

    return hRgn;
}
#endif //OS_WINCE

#endif // USE_BBAR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\capienc.h ===
#ifndef _H_CAPIENC
#define _H_CAPIENC


#include <wincrypt.h>
//#include <sha.h>

#define A_SHA_DIGEST_LEN 20


typedef BOOL (CRYPTENCRYPT)(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, 
                            DWORD dwFlags, BYTE* pbData, DWORD* pdwDataLen, DWORD dwBufLen);
typedef BOOL (CRYPTRELEASECONTEXT) (HCRYPTPROV hProv, DWORD dwFlags);
typedef BOOL (CRYPTGENRANDOM) (HCRYPTPROV hProv, DWORD dwLen, BYTE* pbBuffer);
typedef BOOL (CRYPTDECRYPT)(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, 
                            BYTE* pbData, DWORD* pdwDataLen);
typedef BOOL (CRYPTACQUIRECONTEXT) (HCRYPTPROV* phProv, LPCTSTR pszContainer, LPCTSTR pszProvider, 
                            DWORD dwProvType, DWORD dwFlags);
typedef BOOL (CRYPTIMPORTKEY)(HCRYPTPROV hProv, BYTE* pbData, DWORD dwDataLen, HCRYPTKEY hPubKey, 
                            DWORD dwFlags, HCRYPTKEY* phKey);
typedef BOOL (CRYPTDESTROYKEY) (HCRYPTKEY hKey);
typedef BOOL (CRYPTSETKEYPARAM) (HCRYPTKEY hKey, DWORD dwParam, BYTE* pbData, DWORD dwFlags);
typedef BOOL (CRYPTCREATEHASH)(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTKEY hKey, 
                            DWORD dwFlags, HCRYPTHASH* phHash);
typedef BOOL (CRYPTHASHDATA)(HCRYPTHASH hHash, BYTE* pbData, DWORD dwDataLen, DWORD dwFlags);
typedef BOOL (CRYPTSETHASHPARAM)(HCRYPTHASH hHash, DWORD dwParam, BYTE* pbData, DWORD dwFlags);
typedef BOOL (CRYPTGETHASHPARAM)(HCRYPTHASH hHash, DWORD dwParam, BYTE* pbData, DWORD* pdwDataLen, DWORD dwFlags);
typedef BOOL (CRYPTDESTROYHASH)(HCRYPTHASH hHash);

                  
typedef struct _CAPI_FUNCTION_TABLE {
    CRYPTACQUIRECONTEXT *pfnCryptAcquireContext;
    CRYPTRELEASECONTEXT *pfnCryptReleaseContext;
    CRYPTGENRANDOM *pfnCryptGenRandom;
    CRYPTENCRYPT *pfnCryptEncrypt;
    CRYPTDECRYPT *pfnCryptDecrypt;
    CRYPTIMPORTKEY *pfnCryptImportKey;
    CRYPTDESTROYKEY *pfnCryptDestroyKey;
    CRYPTSETKEYPARAM *pfnCryptSetKeyParam;
    CRYPTCREATEHASH *pfnCryptCreateHash;
    CRYPTHASHDATA *pfnCryptHashData;
    CRYPTSETHASHPARAM *pfnCryptSetHashParam;
    CRYPTGETHASHPARAM *pfnCryptGetHashParam;
    CRYPTDESTROYHASH *pfnCryptDestroyHash;
} CAPI_FUNCTION_TABLE, *PCAPI_FUNCTION_TABLE;
         
typedef struct _CAPIData {
    HMODULE hAdvapi32;
    CAPI_FUNCTION_TABLE CapiFunctionTable;
    HCRYPTPROV  hProv;
    HCRYPTKEY   hEncKey;
    BYTE        bEncKey[MAX_FIPS_SESSION_KEY_SIZE];
	HCRYPTKEY   hDecKey;
    BYTE        bDecKey[MAX_FIPS_SESSION_KEY_SIZE];
    BYTE        bEncIv[FIPS_BLOCK_LEN];
    BYTE        bDecIv[FIPS_BLOCK_LEN];
	HCRYPTHASH  hSignKey;
    BYTE        bSignKey[MAX_SIGNKEY_SIZE];
}CAPIData, *PCAPIData;


BOOL TSCAPI_Init(PCAPIData pCapiData);
BOOL TSCAPI_Enable(PCAPIData pCapiData);
BOOL TSCAPI_Term(PCAPIData pCapiData);
DCUINT TSCAPI_AdjustDataLen(DCUINT dataLen);
BOOL TSCAPI_GenerateRandomNumber(PCAPIData pCapiData, LPBYTE pbRandomBits, DWORD cbLen);
BOOL TSCAPI_MakeSessionKeys(PCAPIData pCapiData, RANDOM_KEYS_PAIR *pKeyPair, CryptMethod *pEnumMethod);
BOOL TSCAPI_EncryptData(
        PCAPIData pCapiData,
        LPBYTE pbData,
        DWORD *pdwDataLen,
        DWORD dwBufLen,
        LPBYTE pbSignature,
        DWORD  dwEncryptionCount);

BOOL TSCAPI_DecryptData(
            PCAPIData pCapiData,
            LPBYTE pbData,
            DWORD  dwDataLen,
            DWORD  dwPadLen,
            LPBYTE pbSignature,
            DWORD  dwDecryptionCount);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\bdcom.c ===
/****************************************************************************/
/*                                                                          */
/* abdcom.c                                                                 */
/*                                                                          */
/* Copyright (c) Data Connection Limited 1998                               */
/*                                                                          */
/*                                                                          */
/* Bitmap decompression routine and macros for 16 and 24bpp protocol        */
/*                                                                          */
/****************************************************************************/

#ifdef BC_TRACE
#define BCTRACE TRC_DBG
#else
#define BCTRACE(string)
#endif


/****************************************************************************/
/* We use the same helper macros as the 8bpp code except for STORE_FGBG.    */
/****************************************************************************/
/****************************************************************************/
/* Macro to store an FGBG image at destbuf                                  */
/*                                                                          */
/*  xorPel is either the value 0 or an expression containing the local      */
/*  variable destbuf.                                                       */
/*                                                                          */
/*  THIS MEANS THAT xorPel HAS A DIFFERENT VALUE EVERY TIME destbuf IS      */
/*  CHANGED.                                                                */
/*                                                                          */
/*  fgPel is a BC_PIXEL and the FG color to XOR with xorbyte                */
/*  fgbgChar is a bitmask telling which color to put where                  */
/*                                                                          */
/* This macro expects that the function defines pDst, pEndDst, hr           */
/* If there is not enough data to write the full run, this will set error   */
/* and quit                                                                 */
/****************************************************************************/
#undef  STORE_FGBG
#define STORE_FGBG(xorPelIn, fgbgChar, fgPel, bits)                          \
      {                                                                      \
        DCUINT   numbits = bits;                                             \
        BC_PIXEL xorPel;                                                     \
        BD_CHECK_WRITE_N_BYTES( destbuf, pEndDst, max(1, min(numbits, 8)) * BC_PIXEL_LEN, hr )           \
                                                                             \
        xorPel = BC_GET_PIXEL(xorPelIn);                                     \
        if (fgbgChar & 0x01)                                                 \
        {                                                                    \
            BC_SET_PIXEL(destbuf, xorPel ^ fgPel);                           \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            BC_SET_PIXEL(destbuf, xorPel);                                   \
        }                                                                    \
        BC_TO_NEXT_PIXEL(destbuf);                                           \
                                                                             \
        if (--numbits > 0)                                                   \
        {                                                                    \
          xorPel = BC_GET_PIXEL(xorPelIn);                                   \
          if (fgbgChar & 0x02)                                               \
          {                                                                  \
              BC_SET_PIXEL(destbuf, xorPel ^ fgPel);                         \
          }                                                                  \
          else                                                               \
          {                                                                  \
              BC_SET_PIXEL(destbuf, xorPel)                                  \
          }                                                                  \
          BC_TO_NEXT_PIXEL(destbuf);                                         \
                                                                             \
          if (--numbits > 0)                                                 \
          {                                                                  \
            xorPel = BC_GET_PIXEL(xorPelIn);                                 \
            if (fgbgChar & 0x04)                                             \
            {                                                                \
                BC_SET_PIXEL(destbuf, xorPel ^ fgPel);                       \
            }                                                                \
            else                                                             \
            {                                                                \
                BC_SET_PIXEL(destbuf, xorPel)                                \
            }                                                                \
            BC_TO_NEXT_PIXEL(destbuf);                                       \
                                                                             \
            if (--numbits > 0)                                               \
            {                                                                \
              xorPel = BC_GET_PIXEL(xorPelIn);                               \
              if (fgbgChar & 0x08)                                           \
              {                                                              \
                  BC_SET_PIXEL(destbuf, xorPel ^ fgPel);                     \
              }                                                              \
              else                                                           \
              {                                                              \
                  BC_SET_PIXEL(destbuf, xorPel);                             \
              }                                                              \
              BC_TO_NEXT_PIXEL(destbuf);                                     \
                                                                             \
              if (--numbits > 0)                                             \
              {                                                              \
                xorPel = BC_GET_PIXEL(xorPelIn);                             \
                if (fgbgChar & 0x10)                                         \
                {                                                            \
                    BC_SET_PIXEL(destbuf, xorPel ^ fgPel);                   \
                }                                                            \
                else                                                         \
                {                                                            \
                    BC_SET_PIXEL(destbuf, xorPel);                           \
                }                                                            \
                BC_TO_NEXT_PIXEL(destbuf);                                   \
                                                                             \
                if (--numbits > 0)                                           \
                {                                                            \
                  xorPel = BC_GET_PIXEL(xorPelIn);                           \
                  if (fgbgChar & 0x20)                                       \
                  {                                                          \
                      BC_SET_PIXEL(destbuf, xorPel ^ fgPel);                 \
                  }                                                          \
                  else                                                       \
                  {                                                          \
                      BC_SET_PIXEL(destbuf, xorPel);                         \
                  }                                                          \
                  BC_TO_NEXT_PIXEL(destbuf);                                 \
                                                                             \
                  if (--numbits > 0)                                         \
                  {                                                          \
                    xorPel = BC_GET_PIXEL(xorPelIn);                         \
                    if (fgbgChar & 0x40)                                     \
                    {                                                        \
                        BC_SET_PIXEL(destbuf, xorPel ^ fgPel);               \
                    }                                                        \
                    else                                                     \
                    {                                                        \
                        BC_SET_PIXEL(destbuf, xorPel);                       \
                    }                                                        \
                    BC_TO_NEXT_PIXEL(destbuf);                               \
                                                                             \
                    if (--numbits > 0)                                       \
                    {                                                        \
                      xorPel = BC_GET_PIXEL(xorPelIn);                       \
                      if (fgbgChar & 0x80)                                   \
                      {                                                      \
                          BC_SET_PIXEL(destbuf, xorPel ^ fgPel);             \
                      }                                                      \
                      else                                                   \
                      {                                                      \
                          BC_SET_PIXEL(destbuf, xorPel);                     \
                      }                                                      \
                      BC_TO_NEXT_PIXEL(destbuf);                             \
                    }                                                        \
                  }                                                          \
                }                                                            \
              }                                                              \
            }                                                                \
          }                                                                  \
        }                                                                    \
      }


#define STORE_LINE1_FGBG(fgbgChar, fgPel, bits)                              \
      {                                                                      \
        DCUINT   numbits = bits;                                             \
        BD_CHECK_WRITE_N_BYTES( destbuf, pEndDst, max(1, min(numbits, 8)) * BC_PIXEL_LEN, hr )           \
                                                                             \
        if (fgbgChar & 0x01)                                                 \
        {                                                                    \
            BC_SET_PIXEL(destbuf,  fgPel);                                   \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            BC_SET_PIXEL(destbuf, 0);                                        \
        }                                                                    \
        BC_TO_NEXT_PIXEL(destbuf);                                           \
                                                                             \
        if (--numbits > 0)                                                   \
        {                                                                    \
          if (fgbgChar & 0x02)                                               \
          {                                                                  \
              BC_SET_PIXEL(destbuf, fgPel);                                  \
          }                                                                  \
          else                                                               \
          {                                                                  \
              BC_SET_PIXEL(destbuf, 0)                                       \
          }                                                                  \
          BC_TO_NEXT_PIXEL(destbuf);                                         \
                                                                             \
          if (--numbits > 0)                                                 \
          {                                                                  \
            if (fgbgChar & 0x04)                                             \
            {                                                                \
                BC_SET_PIXEL(destbuf,  fgPel);                               \
            }                                                                \
            else                                                             \
            {                                                                \
                BC_SET_PIXEL(destbuf, 0)                                     \
            }                                                                \
            BC_TO_NEXT_PIXEL(destbuf);                                       \
                                                                             \
            if (--numbits > 0)                                               \
            {                                                                \
              if (fgbgChar & 0x08)                                           \
              {                                                              \
                  BC_SET_PIXEL(destbuf,  fgPel);                             \
              }                                                              \
              else                                                           \
              {                                                              \
                  BC_SET_PIXEL(destbuf, 0);                                  \
              }                                                              \
              BC_TO_NEXT_PIXEL(destbuf);                                     \
                                                                             \
              if (--numbits > 0)                                             \
              {                                                              \
                if (fgbgChar & 0x10)                                         \
                {                                                            \
                    BC_SET_PIXEL(destbuf,  fgPel);                           \
                }                                                            \
                else                                                         \
                {                                                            \
                    BC_SET_PIXEL(destbuf, 0);                                \
                }                                                            \
                BC_TO_NEXT_PIXEL(destbuf);                                   \
                                                                             \
                if (--numbits > 0)                                           \
                {                                                            \
                  if (fgbgChar & 0x20)                                       \
                  {                                                          \
                      BC_SET_PIXEL(destbuf,  fgPel);                         \
                  }                                                          \
                  else                                                       \
                  {                                                          \
                      BC_SET_PIXEL(destbuf, 0);                              \
                  }                                                          \
                  BC_TO_NEXT_PIXEL(destbuf);                                 \
                                                                             \
                  if (--numbits > 0)                                         \
                  {                                                          \
                    if (fgbgChar & 0x40)                                     \
                    {                                                        \
                        BC_SET_PIXEL(destbuf,  fgPel);                       \
                    }                                                        \
                    else                                                     \
                    {                                                        \
                        BC_SET_PIXEL(destbuf, 0);                            \
                    }                                                        \
                    BC_TO_NEXT_PIXEL(destbuf);                               \
                                                                             \
                    if (--numbits > 0)                                       \
                    {                                                        \
                      if (fgbgChar & 0x80)                                   \
                      {                                                      \
                          BC_SET_PIXEL(destbuf,  fgPel);                     \
                      }                                                      \
                      else                                                   \
                      {                                                      \
                          BC_SET_PIXEL(destbuf, 0);                          \
                      }                                                      \
                      BC_TO_NEXT_PIXEL(destbuf);                             \
                    }                                                        \
                  }                                                          \
                }                                                            \
              }                                                              \
            }                                                                \
          }                                                                  \
        }                                                                    \
      }

/****************************************************************************/
/* Decompression function begins here                                       */
/****************************************************************************/
/****************************************************************************/
/*                                                                          */
/*  PDCUINT8 pSrc                                                           */
/*  PDCUINT8 pDstBuffer                                                     */
/*  DCUINT   srcDataSize          total bytes in image                      */
/*  DCUINT   rowDelta             scanline length in bytes                  */
/*                                                                          */
/****************************************************************************/
{
    HRESULT hr = S_OK;
    DCUINT    codeLength;
    DCINT     pixelLength;
    DCUINT8   bitMask;
    DCUINT8   decode;
    DCUINT8   decodeLite;
    DCUINT8   decodeMega;
    BC_PIXEL  fgPel              = BC_DEFAULT_FGPEL;
    BC_PIXEL  pixelA;
    BC_PIXEL  pixelB;
    PDCUINT8  destbuf            = pDstBuffer;
    PDCUINT8  endSrc             = pSrc + srcDataSize;
    PDCUINT8  pEndDst           = pDstBuffer + dstBufferSize;
    DCBOOL    backgroundNeedsPel = FALSE;
    DCBOOL    firstLine          = TRUE;

    DC_BEGIN_FN(BC_FN_NAME);

    /************************************************************************/
    /* Loop processing the input                                            */
    /************************************************************************/
    while (pSrc < endSrc)
    {
        /********************************************************************/
        /* While we are processing the first line we should keep a look out */
        /* for the end of the line                                          */
        /********************************************************************/
        if (firstLine)
        {
            if ((DCUINT)(destbuf - pDstBuffer) >= rowDelta)
            {
                firstLine = FALSE;
                backgroundNeedsPel = FALSE;
            }
        }

        /********************************************************************/
        /* Get the decode                                                   */
        /********************************************************************/
        BD_CHECK_READ_ONE_BYTE(pSrc, endSrc, hr);
        decode     = (DCUINT8)(*pSrc & CODE_MASK);
        decodeLite = (DCUINT8)(*pSrc & CODE_MASK_LITE);
        decodeMega = (DCUINT8)(*pSrc);

        /********************************************************************/
        /* BG RUN                                                           */
        /********************************************************************/
        if ((decode == CODE_BG_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_BG_RUN))
        {
            if (decode == CODE_BG_RUN)
            {
                EXTRACT_LENGTH(pSrc, endSrc, codeLength, hr);
            }
            else
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, endSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            BCTRACE((TB, _T("Background run %u"),codeLength));

            if (!firstLine)
            {
                if (backgroundNeedsPel)
                {
                    BD_CHECK_WRITE_N_BYTES(destbuf, pEndDst, BC_PIXEL_LEN, hr);
                    BD_CHECK_READ_N_BYTES_2ENDED(destbuf - rowDelta, pDstBuffer, pEndDst, BC_PIXEL_LEN, hr)
                    
                    BC_SET_PIXEL(destbuf,
                                 BC_GET_PIXEL(destbuf - rowDelta) ^ fgPel);
                    BC_TO_NEXT_PIXEL(destbuf);
                    codeLength--;
                }

                BD_CHECK_WRITE_N_BYTES(destbuf, pEndDst, BC_PIXEL_LEN * codeLength, hr);

                while (codeLength-- > 0)
                {
                    BD_CHECK_READ_N_BYTES_2ENDED(destbuf - rowDelta, pDstBuffer, pEndDst, BC_PIXEL_LEN, hr)
                    BC_SET_PIXEL(destbuf, BC_GET_PIXEL(destbuf - rowDelta));
                    BC_TO_NEXT_PIXEL(destbuf);
                }
            }
            else
            {
                if (backgroundNeedsPel)
                {
                    BD_CHECK_WRITE_N_BYTES(destbuf, pEndDst, BC_PIXEL_LEN, hr);
                    BC_SET_PIXEL(destbuf, fgPel);
                    BC_TO_NEXT_PIXEL(destbuf);
                    codeLength--;
                }
                BD_CHECK_WRITE_N_BYTES(destbuf, pEndDst, BC_PIXEL_LEN * codeLength, hr);
                while (codeLength-- > 0)
                {
                    /********************************************************/
                    /* On the first line BG colour means 0                  */
                    /********************************************************/
                    BC_SET_PIXEL(destbuf, (BC_PIXEL)0);
                    BC_TO_NEXT_PIXEL(destbuf);
                }
            }
            /****************************************************************/
            /* A follow on BG run will need a pel inserted                  */
            /****************************************************************/
            backgroundNeedsPel = TRUE;
            continue;
        }

        /********************************************************************/
        /* For any of the other runtypes a follow on BG run does not need   */
        /* a FG pel inserted                                                */
        /********************************************************************/
        backgroundNeedsPel = FALSE;

        /********************************************************************/
        /* FGBG IMAGE                                                       */
        /********************************************************************/
        if ((decode == CODE_FG_BG_IMAGE)      ||
            (decodeLite == CODE_SET_FG_FG_BG) ||
            (decodeMega == CODE_MEGA_MEGA_FGBG)    ||
            (decodeMega == CODE_MEGA_MEGA_SET_FGBG))
        {
            if ((decodeMega == CODE_MEGA_MEGA_FGBG) ||
                (decodeMega == CODE_MEGA_MEGA_SET_FGBG))
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, endSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                if (decode == CODE_FG_BG_IMAGE)
                {
                    EXTRACT_LENGTH_FGBG(pSrc, endSrc, codeLength, hr);
                }
                else
                {
                    EXTRACT_LENGTH_FGBG_LITE(pSrc, endSrc, codeLength, hr);
                }
            }

            if ((decodeLite == CODE_SET_FG_FG_BG) ||
                (decodeMega == CODE_MEGA_MEGA_SET_FGBG))
            {
                BD_CHECK_READ_N_BYTES(pSrc, endSrc, BC_PIXEL_LEN, hr);
                fgPel = BC_GET_PIXEL(pSrc);
                BC_TO_NEXT_PIXEL(pSrc);
                BCTRACE((TB, _T("Set FGBG image %u, fgPel %06lx"),
                                                codeLength, (DCUINT32)fgPel));
            }
            else
            {
                BCTRACE((TB, _T("FGBG image     %u"),codeLength));
            }

            while (codeLength > 8)
            {
                /************************************************************/
                /* A FGBG image is a set of bitmasks describing the         */
                /* positions of the FG and BG colors.                       */
                /************************************************************/
                BD_CHECK_READ_ONE_BYTE(pSrc, endSrc, hr);
                bitMask  = *pSrc++;
                if (!firstLine)
                {
                    BD_CHECK_READ_N_BYTES_2ENDED(destbuf - rowDelta, pDstBuffer, pEndDst, BC_PIXEL_LEN, hr)
                    STORE_FGBG((destbuf - rowDelta),
                               bitMask,
                               fgPel,
                               8);
                }
                else
                {
                    STORE_LINE1_FGBG(bitMask, fgPel, 8);
                }
                codeLength -= 8;
            }
            if (codeLength > 0)
            {
                BD_CHECK_READ_ONE_BYTE(pSrc, endSrc, hr);
                bitMask  = *pSrc++;
                if (!firstLine)
                {
                    BD_CHECK_READ_N_BYTES_2ENDED(destbuf - rowDelta, pDstBuffer, pEndDst, BC_PIXEL_LEN, hr)
                    STORE_FGBG((destbuf - rowDelta),
                               bitMask,
                               fgPel,
                               codeLength);
                }
                else
                {
                    STORE_LINE1_FGBG(bitMask, fgPel, codeLength);
                }
            }
            continue;
        }

        /********************************************************************/
        /* FG RUN                                                           */
        /********************************************************************/
        if ((decode == CODE_FG_RUN) ||
            (decodeLite == CODE_SET_FG_FG_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_FG_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_SET_FG_RUN))
        {

            if ((decodeMega == CODE_MEGA_MEGA_FG_RUN) ||
                (decodeMega == CODE_MEGA_MEGA_SET_FG_RUN))
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, endSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                if (decode == CODE_FG_RUN)
                {
                    EXTRACT_LENGTH(pSrc, endSrc, codeLength, hr);
                }
                else
                {
                    EXTRACT_LENGTH_LITE(pSrc, endSrc, codeLength, hr);
                }
            }

            /****************************************************************/
            /* Push the old fgPel down to the ALT position                  */
            /****************************************************************/
            if ((decodeLite == CODE_SET_FG_FG_RUN) ||
                (decodeMega  == CODE_MEGA_MEGA_SET_FG_RUN))
            {
                BD_CHECK_READ_N_BYTES(pSrc, endSrc, BC_PIXEL_LEN, hr);
                BCTRACE((TB, _T("Set FG run     %u"),codeLength));
                fgPel = BC_GET_PIXEL(pSrc);
                BC_TO_NEXT_PIXEL(pSrc);
            }
            else
            {
                BCTRACE((TB, _T("FG run         %u"),codeLength));
            }

            BD_CHECK_WRITE_N_BYTES(destbuf, pEndDst, BC_PIXEL_LEN * codeLength, hr)
            while (codeLength-- > 0)
            {
                if (!firstLine)
                {
                    BD_CHECK_READ_N_BYTES_2ENDED(destbuf - rowDelta, pDstBuffer, pEndDst, BC_PIXEL_LEN, hr)
                    BC_SET_PIXEL(destbuf,
                                 BC_GET_PIXEL(destbuf - rowDelta) ^ fgPel);
                    BC_TO_NEXT_PIXEL(destbuf);
                }
                else
                {
                    BC_SET_PIXEL(destbuf, fgPel);
                    BC_TO_NEXT_PIXEL(destbuf);
                }
            }
            continue;
        }

        /********************************************************************/
        /* DITHERED RUN                                                     */
        /********************************************************************/
        if ((decodeLite == CODE_DITHERED_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_DITHER))
        {
            if (decodeMega == CODE_MEGA_MEGA_DITHER)
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, endSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH_LITE(pSrc, endSrc, codeLength, hr);
            }
            BCTRACE((TB, _T("Dithered run   %u"),codeLength));

            BD_CHECK_READ_N_BYTES(pSrc, endSrc, BC_PIXEL_LEN * 2, hr);
            pixelA = BC_GET_PIXEL(pSrc);
            BC_TO_NEXT_PIXEL(pSrc);
            pixelB = BC_GET_PIXEL(pSrc);
            BC_TO_NEXT_PIXEL(pSrc);

            BD_CHECK_WRITE_N_BYTES(destbuf, pEndDst, 2 * codeLength * BC_PIXEL_LEN, hr)
            while (codeLength-- > 0)
            {
                BC_SET_PIXEL(destbuf, pixelA);
                BC_TO_NEXT_PIXEL(destbuf);

                BC_SET_PIXEL(destbuf, pixelB);
                BC_TO_NEXT_PIXEL(destbuf);
            }
            continue;
        }

        /********************************************************************/
        /* COLOR IMAGE                                                      */
        /********************************************************************/
        if ((decode == CODE_COLOR_IMAGE) ||
            (decodeMega == CODE_MEGA_MEGA_CLR_IMG))
        {
            if (decodeMega == CODE_MEGA_MEGA_CLR_IMG)
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, endSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH(pSrc, endSrc, codeLength, hr);
            }
            BCTRACE((TB, _T("Color image    %u"),codeLength));

            /****************************************************************/
            /* Just copy the pixel values across                            */
            /****************************************************************/
            pixelLength = (codeLength * BC_PIXEL_LEN);
            BD_CHECK_READ_N_BYTES(pSrc, endSrc, pixelLength, hr);
            BD_CHECK_WRITE_N_BYTES(destbuf, pEndDst, pixelLength, hr);
            while (pixelLength-- > 0)
            {
                *destbuf++ = *pSrc++;
            }

            continue;
        }

        /********************************************************************/
        /* COLOR RUN                                                        */
        /********************************************************************/
        if ((decode == CODE_COLOR_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_COLOR_RUN))
        {
            if (decodeMega == CODE_MEGA_MEGA_COLOR_RUN)
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, endSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH(pSrc, endSrc, codeLength, hr);
            }
            BCTRACE((TB, _T("Color run      %u"),codeLength));

            BD_CHECK_READ_N_BYTES(pSrc, endSrc, BC_PIXEL_LEN, hr);
            pixelA = BC_GET_PIXEL(pSrc);
            BC_TO_NEXT_PIXEL(pSrc);

            BD_CHECK_WRITE_N_BYTES(destbuf, pEndDst, codeLength * BC_PIXEL_LEN, hr)
            while (codeLength-- > 0)
            {
                BC_SET_PIXEL(destbuf, pixelA);
                BC_TO_NEXT_PIXEL(destbuf);
            }
            continue;
        }


        /********************************************************************/
        /* If we get here then the code must be a special one               */
        /********************************************************************/
        BCTRACE((TB, _T("Special code   %x"),decodeMega));
        switch (decodeMega)
        {
            case CODE_BLACK:
                BD_CHECK_WRITE_N_BYTES(destbuf, pEndDst, BC_PIXEL_LEN, hr)
                BC_SET_PIXEL(destbuf, (BC_PIXEL)0);
                BC_TO_NEXT_PIXEL(destbuf);
                break;

            case CODE_WHITE:
                BD_CHECK_WRITE_N_BYTES(destbuf, pEndDst, BC_PIXEL_LEN, hr)
                BC_SET_PIXEL(destbuf, BC_DEFAULT_FGPEL);
                BC_TO_NEXT_PIXEL(destbuf);
                break;

            /****************************************************************/
            /* Ignore the unreachable code warnings that follow             */
            /* Simply because we use the STORE_FGBG macro with a constant   */
            /* value                                                        */
            /****************************************************************/
            case CODE_SPECIAL_FGBG_1:
                if (!firstLine)
                {
                    BD_CHECK_READ_N_BYTES_2ENDED(destbuf - rowDelta, pDstBuffer, pEndDst, BC_PIXEL_LEN, hr)
                    STORE_FGBG((destbuf - rowDelta),
                               SPECIAL_FGBG_CODE_1,
                               fgPel,
                               8);
                }
                else
                {
                    STORE_LINE1_FGBG(SPECIAL_FGBG_CODE_1, fgPel, 8);
                }
                break;

            case CODE_SPECIAL_FGBG_2:
                if (!firstLine)
                {
                    BD_CHECK_READ_N_BYTES_2ENDED(destbuf - rowDelta, pDstBuffer, pEndDst, BC_PIXEL_LEN, hr)
                    STORE_FGBG((destbuf - rowDelta),
                               SPECIAL_FGBG_CODE_2,
                               fgPel,
                               8);
                }
                else
                {
                    STORE_LINE1_FGBG(SPECIAL_FGBG_CODE_2, fgPel, 8);
                }
                break;


            default:
                {
                    TRC_ERR((TB, _T("Invalid compression data %x"),decodeMega));
                }
                break;
        }
        pSrc++;

    }

    BCTRACE((TB, _T("Decompressed to %u bytes"), destbuf - pDstBuffer));
#if 0
#ifdef DC_DEBUG
    if ((destbuf - pDstBuffer) != decompLen)
    {
        TRC_ABORT((TB, _T("calculated decomp len %d != actual len %d"),
                   decompLen, (destbuf - pDstBuffer) ));
    }
#endif
#endif

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\ccapi.cpp ===
/**MOD+**********************************************************************/
/* Module:    ccapi.cpp                                                     */
/*                                                                          */
/* Purpose:   Call Controller APIs                                          */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1999                             */
/*                                                                          */
/****************************************************************************/

#include <adcg.h>

extern "C" {
#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "accapi"
#include <atrcapi.h>
}

#include "cc.h"
#include "aco.h"

#ifdef OS_WINCE
#include "ceconfig.h"
#endif

/****************************************************************************/
/* If you add a capability set, update the following also (in accdata.h):   */
/* -  CC_COMBINED_CAPS_NUMBER_CAPABILITIES                                  */
/* -  the definition of the CC_COMBINED_CAPABILITIES struct.                */
/*    This is used to initialize the per instance capabilities              */
/****************************************************************************/
CC_COMBINED_CAPABILITIES ccInitCombinedCapabilities = {
    CC_COMBINED_CAPS_NUMBER_CAPABILITIES,      /* Number of capabilities    */
    0,                                         /* padding                   */

    /************************************************************************/
    /* General caps                                                         */
    /************************************************************************/
    {
        TS_CAPSETTYPE_GENERAL,         /* capabilitySetType                 */
        sizeof(TS_GENERAL_CAPABILITYSET), /* lengthCapability               */
        TS_OSMAJORTYPE_WINDOWS,        /* OSMajorType                       */
        TS_OSMINORTYPE_WINDOWS_NT,     /* OSMinorType                       */
        TS_CAPS_PROTOCOLVERSION,       /* protocolVersion                   */
        0,                             /* pad1                              */
        0,                             /* generalCompressionTypes (none)    */
        TS_EXTRA_NO_BITMAP_COMPRESSION_HDR |
        TS_FASTPATH_OUTPUT_SUPPORTED       |
        TS_LONG_CREDENTIALS_SUPPORTED      |
        TS_AUTORECONNECT_COOKIE_SUPPORTED,  // extraFlags
        FALSE,                         /* updateCapabilityFlag              */
        FALSE,                         /* remoteUnshareFlag                 */
        0,                             /* generalCompressionLevel (none)    */
        0,                             /* refreshRectSupport                */
        0                              /* suppressOutputSupport             */
    },

    /************************************************************************/
    /* Bitmap caps                                                          */
    /************************************************************************/
    {
        TS_CAPSETTYPE_BITMAP,                    /* capabilitySetType       */
        sizeof(TS_BITMAP_CAPABILITYSET),         /* lengthCapability        */
        0,          /* Set in CC */              /* preferredBitsPerPixel   */
        TRUE,                                    /* receive1BitPerPixel     */
        TRUE,                                    /* receive4BitsPerPixel    */
        TRUE,                                    /* receive8BitsPerPixel    */
        0,          /* Set in CC */              /* desktopWidth            */
        0,          /* Set in CC */              /* desktopHeight           */
        0,                                       /* pad2                    */
        TS_CAPSFLAG_SUPPORTED,                   /* desktopResizeFlag       */
        1,                                       /* bitmapCompressionFlag   */
        0,                                       /* highColorFlags          */
        0,                                       /* pad1                    */
        TRUE,                                    /* multipleRectangleSupport*/
        0                                        /* pad2                    */
    },

    /************************************************************************/
    /* Order Caps                                                           */
    /************************************************************************/
    {
        TS_CAPSETTYPE_ORDER,                        /* capabilitySetType    */
        sizeof(TS_ORDER_CAPABILITYSET),             /* lengthCapability     */
        {'\0','\0','\0','\0','\0','\0','\0','\0',
         '\0','\0','\0','\0','\0','\0','\0','\0'},  /* terminalDescriptor   */
        0,                                          /* pad1                 */
        UH_SAVE_BITMAP_X_GRANULARITY,           /* desktopSaveXGranularity  */
        UH_SAVE_BITMAP_Y_GRANULARITY,           /* desktopSaveYGranularity  */
        0,                                          /* pad2                 */
        1,                                          /* maximumOrderLevel    */
        0,                                          /* numberFonts          */

#ifdef OS_WINCE
        TS_ORDERFLAGS_SOLIDPATTERNBRUSHONLY     |
#endif
#ifdef NO_ORDER_SUPPORT
        TS_ORDERFLAGS_CANNOTRECEIVEORDERS       |
#endif

        TS_ORDERFLAGS_ZEROBOUNDSDELTASSUPPORT   |
        TS_ORDERFLAGS_NEGOTIATEORDERSUPPORT,        /* orderFlags           */

        {
            /****************************************************************/
            /* Order Support flags.                                         */
            /*                                                              */
            /* The array index corresponds to the TS_NEG_xxx_INDEX value    */
            /* indicated (from at128.h) The values marked with an x in the  */
            /* first column are overwritten at run time by UH before CC     */
            /* sends the combined capabilities.                             */
            /****************************************************************/

            1, /*   0 TS_NEG_DSTBLT_INDEX          destinationBltSupport    */
            1, /*   1 TS_NEG_PATBLT_INDEX          patternBltSupport        */
            0, /* x 2 TS_NEG_SCRBLT_INDEX          screenBltSupport         */
            1, /* x 3 TS_NEG_MEMBLT_INDEX          memoryBltSupport         */
            1, /* x 4 TS_NEG_MEM3BLT_INDEX         memoryThreeWayBltSupport */
            0, /*   5 TS_NEG_ATEXTOUT_INDEX        textASupport             */
            0, /*   6 TS_NEG_AEXTTEXTOUT_INDEX     extendedTextASupport     */
#ifdef DRAW_NINEGRID
            1, /*   7 TS_NEG_DRAWNINEGRID_INDEX                             */
#else
            0,
#endif
            1, /* x 8 TS_NEG_LINETO_INDEX          lineSupport              */
#ifdef DRAW_NINEGRID
            1, /*   9 TS_NEG_MULTI_DRAWNINEGRID_INDEX                       */
#else
            0,
#endif
            0, /*  10 TS_NEG_OPAQUERECT_INDEX      opaqueRectangleSupport   */
            0, /*  11 TS_NEG_SAVEBITMAP_INDEX      desktopSaveSupport       */
            0, /*  12 TS_NEG_WTEXTOUT_INDEX        textWSupport             */
            0, /*  13 TS_NEG_MEMBLT_R2_INDEX       Reserved entry           */
            0, /*  14 TS_NEG_MEM3BLT_R2_INDEX      Reserved entry           */
            1, /* x15 TS_NEG_MULTIDSTBLT_INDEX     multi DstBlt support     */
            1, /* x16 TS_NEG_MULTIPATBLT_INDEX     multi PatBlt support     */
            1, /* x17 TS_NEG_MULTISCRBLT_INDEX     multi ScrBlt support     */
            1, /* x18 TS_NEG_MULTIOPAQUERECT_INDEX multi OpaqueRect support */
            1, /* x19 TS_NEG_FAST_INDEX_INDEX      fast index order support */
#ifdef OS_WINCE
            0, /*  20 Polygon not supported for WinCE                       */
            0, /*  21 Polygon not supported for WinCE                       */
#else
            1, /* x20 TS_NEG_POLYGON_SC_INDEX      polygon sc support       */
            1, /* x21 TS_NEG_POLYGON_CB_INDEX      polygon cb support       */
#endif
            1, /* x22 TS_NEG_POLYLINE_INDEX        polyLineSupport          */
            0, /* x23                              not used                 */
            1, /* x24 TS_NEG_FAST_GLYPH_INDEX      fast glyph order support */
#ifdef OS_WINCE
            0, /*  25 Ellipse not supported for WinCE                       */
            0, /*  26 Ellipse not supported for WinCE                       */
#else 
            1, /* x25 TS_NEG_ELLIPSE_SC_INDEX      ellipse sc support       */
            1, /* x26 TS_NEG_ELLIPSE_CB_INDEX      ellipse cb support       */
#endif
            0, /*  27                              MS reserved entry 6      */
            0, /*  28 TS_NEG_WEXTTEXTOUT_INDEX     extendedTextWSupport     */
            0, /*  29 TS_NEG_WLONGTEXTOUT_INDEX    longTextWSupport         */
            0, /*  30 TS_NEG_WLONGEXTTEXTOUT_INDEX longExtendedTextWSupport */
            0, /*  31                              DCL reserved entry 3     */
        },
            /****************************************************************/
            /* Don't use font signatures for Windows CE                     */
            /****************************************************************/
#ifdef OS_WINCE
          ( ((TS_TEXT_AND_MASK)|(TS_TEXT_OR_MASK)) &
            (~TS_TEXTFLAGS_CHECKFONTSIGNATURES) ),    /* textFlags          */
#else
          (TS_TEXT_AND_MASK)|(TS_TEXT_OR_MASK),       /* textFlags          */
#endif
        0,                                          /* pad2                 */
        0,                                          /* pad4                 */
        UH_SAVE_BITMAP_SIZE,                        /* desktopSaveSize      */
        0,                                          /* pad2                 */
        0,                                          /* pad2                 */
        0,                                          /* textANSICodePage     */
        0                                           /* pad2                 */
    },

    /************************************************************************/
    // BitmapCache Caps
    // Note that this same space is used for rev1 and rev2, we declare as
    // rev1 because it is the larger of the two. We will cast to rev2 if
    // we get a server advertisement that it supports rev2 (via
    // TS_BITMAPCACHE_CAPABILITYSET_HOSTSUPPORT).
    /************************************************************************/
    {
        TS_CAPSETTYPE_BITMAPCACHE,                /* capabilitySetType      */
        sizeof(TS_BITMAPCACHE_CAPABILITYSET),     /* lengthCapability       */
        0, 0, 0, 0, 0, 0,                         /* 6 pad DWORDs           */
        0, 0,                                     /* Cache1                 */
        0, 0,                                     /* Cache2                 */
        0, 0,                                     /* Cache3                 */
    },

    /************************************************************************/
    /* ColorTableCache Caps                                                 */
    /************************************************************************/
    {
        TS_CAPSETTYPE_COLORCACHE,                    /* capabilitySetType   */
        sizeof(TS_COLORTABLECACHE_CAPABILITYSET),    /* lengthCapability    */
        UH_COLOR_TABLE_CACHE_ENTRIES,                /* colortableCacheSize */
        0                                            /* notpartOfTSharePad  */
    },

    /************************************************************************/
    /* WindowActivation Caps                                                */
    /************************************************************************/
    {
        TS_CAPSETTYPE_ACTIVATION,                   /* capabilitySetType    */
        sizeof(TS_WINDOWACTIVATION_CAPABILITYSET),  /* lengthCapability     */
        FALSE,                                      /* helpKeyFlag          */
        FALSE,                                      /* helpKeyIndexFlag     */
        FALSE,                                      /* helpExtendedKeyFlag  */
        FALSE                                       /* windowManagerKeyFlag */
    },

    /************************************************************************/
    /* Control Caps                                                         */
    /************************************************************************/
    {
        TS_CAPSETTYPE_CONTROL,                    /* capabilitySetType      */
        sizeof(TS_CONTROL_CAPABILITYSET),         /* lengthCapability       */
        0,                                        /* controlFlags           */
        FALSE,                                    /* remoteDetachFlag       */
        TS_CONTROLPRIORITY_NEVER,                 /* controlInterest        */
        TS_CONTROLPRIORITY_NEVER                  /* detachInterest         */
    },

    /************************************************************************/
    /* Pointer Caps                                                         */
    /************************************************************************/
    {
        TS_CAPSETTYPE_POINTER,                    /* capabilitySetType      */
        sizeof(TS_POINTER_CAPABILITYSET),         /* lengthCapability       */
        TRUE,                                     /* colorPointerFlag       */
        CM_COLOR_CACHE_SIZE,                      /* colorPointerCacheSize  */
        CM_CURSOR_CACHE_SIZE                      /* pointerCacheSize       */
    },

    /************************************************************************/
    /* Share Caps                                                           */
    /************************************************************************/
    {
        TS_CAPSETTYPE_SHARE,                      /* capabilitySetType      */
        sizeof(TS_SHARE_CAPABILITYSET),           /* lengthCapability       */
        0,                                        /* nodeId                 */
        0                                         /* padding                */
    },

    /************************************************************************/
    /* Input Caps                                                           */
    /************************************************************************/
    {
        TS_CAPSETTYPE_INPUT,
        sizeof(TS_INPUT_CAPABILITYSET),           /* lengthCapability       */
        TS_INPUT_FLAG_SCANCODES |                 /* inputFlags             */
        TS_INPUT_FLAG_VKPACKET  |
#if !defined(OS_WINCE)
            TS_INPUT_FLAG_MOUSEX,
#endif
        TS_INPUT_FLAG_FASTPATH_INPUT2,
        RNS_UD_KBD_DEFAULT                        /* keyboard layout        */
    },

    /************************************************************************/
    /* Sound                                                                */
    /************************************************************************/
    {
        TS_CAPSETTYPE_SOUND,
        sizeof(TS_SOUND_CAPABILITYSET),           /* lengthCapability       */
        TS_SOUND_FLAG_BEEPS,                      /* soundFlags             */
        0,                                        /* padding                */
    },

    /************************************************************************/
    /* Font                                                                 */
    /************************************************************************/
    {
        TS_CAPSETTYPE_FONT,
        sizeof(TS_FONT_CAPABILITYSET),            /* lengthCapability       */
        TS_FONTSUPPORT_FONTLIST,                  /* fontSupportFlags       */
        0,                                        /* padding                */
    },

    /************************************************************************/
    /* GlyphCache Caps                                                      */
    /************************************************************************/
    {
        TS_CAPSETTYPE_GLYPHCACHE,                 /* capabilitySetType      */
        sizeof(TS_GLYPHCACHE_CAPABILITYSET),      /* lengthCapability       */
        0,                                        /* GlyphCache             */
        0,                                        /* FragCache              */
        0,                                        /* GlyphSupportLevel      */
    },

    /************************************************************************/
    /* Brush Caps                                                           */
    /************************************************************************/
    {
        TS_CAPSETTYPE_BRUSH,                      /* capabilitySetType      */
        sizeof(TS_BRUSH_CAPABILITYSET),           /* lengthCapability       */
        0,                                        /* brushSupportLevel      */
    },
    
    /************************************************************************/
    /* Offscreen Caps                                                       */
    /************************************************************************/
    {
        TS_CAPSETTYPE_OFFSCREENCACHE,             /* capabilitySetType      */
        sizeof(TS_OFFSCREEN_CAPABILITYSET),       /* lengthCapability       */
        0,                                        /* offscreenSupportLevel  */
        0,                                        /* offscreenCacheSize     */
        0,                                        /* offscreenCacheEntries  */
    },

    /************************************************************************/
    /* Virtual Channel Caps                                                 */
    /************************************************************************/
    {
        TS_CAPSETTYPE_VIRTUALCHANNEL,             /* capabilitySetType      */
        sizeof(TS_VIRTUALCHANNEL_CAPABILITYSET),  /* lengthCapability       */
        //
        // What this particular cap means is that the client understands
        // virtual channels compressed from the server at 64K.
        //
        // The client recevies what compression cap the server supports
        // from the client and compresses appropriately
        //
        TS_VCCAPS_COMPRESSION_64K,                /* vc support flags       */

#ifdef DRAW_NINEGRID
    },

    /************************************************************************/
    // DrawNineGrid Caps                                                       
    /************************************************************************/
    {
        TS_CAPSETTYPE_DRAWNINEGRIDCACHE,          // capabilitySetType      
        sizeof(TS_DRAW_NINEGRID_CAPABILITYSET),   // lengthCapability       
        0,                                        // drawNineGridSupportLevel  
        0,                                        // drawNineGridCacheSize     
        0,                                        // drawNineGridCacheEntries  
#endif

#ifdef DRAW_GDIPLUS
    },

    {
        TS_CAPSETTYPE_DRAWGDIPLUS,
        sizeof(TS_DRAW_GDIPLUS_CAPABILITYSET),
        0,                                          //drawGdiplusSupportLevel
        0,                                          //GdipVersion;
        0,                                          //drawGdiplusCacheLevel
        0,                                          //GdipGraphicsCacheEntries;
        0,                                          //GdipObjectBrushCacheEntries;
        0,                                          //GdipObjectPenCacheEntries;
        0,                                          //GdipObjectImageCacheEntries;
        0,                                          //GdipObjectImageAttributesCacheEntries;
        0,                                          //GdipGraphicsCacheChunkSize;
        0,                                          //GdipObjectBrushCacheChunkSize;
        0,                                          //GdipObjectPenCacheChunkSize;
        0,                                          //GdipObjectImageAttributesCacheChunkSize;
        0,                                          //GdipObjectImageCacheChunkSize;
        0,                                          //GdipObjectImageCacheTotalSize;
        0,                                          //GdipObjectImageCacheMaxSize;
#endif
    }

};


CCC::CCC(CObjs* objs)
{
    _pClientObjects = objs;

    DC_MEMCPY(&_ccCombinedCapabilities, &ccInitCombinedCapabilities, 
              sizeof(_ccCombinedCapabilities));
}

CCC::~CCC()
{
}

/**PROC+*********************************************************************/
/* Name:      CC_Init                                                       */
/*                                                                          */
/* Purpose:   Initializes the Call Controller                               */
/*                                                                          */
/* Returns:   Nothing                                                       */
/*                                                                          */
/* Params:    None                                                          */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI CCC::CC_Init(DCVOID)
{
    DC_BEGIN_FN("CC_Init");

    //Setup local object pointers
    _pUt  = _pClientObjects->_pUtObject;
    _pUi  = _pClientObjects->_pUiObject;
    _pSl  = _pClientObjects->_pSlObject;
    _pUh  = _pClientObjects->_pUHObject;
    _pCd  = _pClientObjects->_pCdObject;
    _pIh  = _pClientObjects->_pIhObject;
    _pOr  = _pClientObjects->_pOrObject;
    _pFs  = _pClientObjects->_pFsObject;
    _pCm  = _pClientObjects->_pCMObject;
    _pCChan = _pClientObjects->_pChanObject;

    DC_MEMSET(&_CC, 0, sizeof(_CC));
    _CC.fsmState = CC_DISCONNECTED;



    DC_END_FN();

    return;

} /* CC_Init */


/**PROC+*********************************************************************/
/* Name:      CC_Term                                                       */
/*                                                                          */
/* Purpose:   Terminates the Call Controller                                */
/*                                                                          */
/* Returns:   Nothing                                                       */
/*                                                                          */
/* Params:    None                                                          */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI CCC::CC_Term(DCVOID)
{
    DC_BEGIN_FN("CC_Term");

    /************************************************************************/
    /* No Action                                                            */
    /************************************************************************/

    DC_END_FN();

    return;

} /* CC_Term */


/**PROC+*********************************************************************/
/* Name:      CC_Event                                                      */
/*                                                                          */
/* Purpose:   Handles calls from the Component Decoupler by passing on the  */
/*            event to the CCFSMProc whilst leaving the data parameter null */
/*                                                                          */
/* Returns:   Nothing                                                       */
/*                                                                          */
/* Params:    IN - event - event to be passed on                            */
/*                                                                          */
/* Operation: Takes a PDCVOID passed via the Component Decoupler            */
/*            CD_DecoupleMessage function                                   */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI CCC::CC_Event(ULONG_PTR apiEvent)
{
    DCUINT internalEvent;

    DC_BEGIN_FN("CC_Event");
    TRC_DBG((TB, _T("CC_Event handling Event %u"), apiEvent));
    
    switch ((DCUINT)apiEvent)
    {
        case CC_EVT_API_ONCONNECTOK:
        {
           internalEvent = CC_EVT_ONCONNECTOK;
        }
        break;

        case CC_EVT_API_ONBUFFERAVAILABLE:
        {
            internalEvent = CC_EVT_ONBUFFERAVAILABLE;
        }
        break;

        case CC_EVT_API_ONDEACTIVATEALL:
        {
            internalEvent = CC_EVT_ONDEACTIVATEALL;
        }
        break;

        case CC_EVT_API_DISCONNECT:
        {
            internalEvent = CC_EVT_DISCONNECT;
        }
        break;

        case CC_EVT_API_SHUTDOWN:
        {
            internalEvent = CC_EVT_SHUTDOWN;
        }
        break;

        case CC_EVT_API_ONSHUTDOWNDENIED:
        {
            internalEvent = CC_EVT_ONSHUTDOWNDENIED;
        }
        break;

        case CC_EVT_API_DISCONNECTANDEXIT:
        {
            internalEvent = CC_EVT_DISCONNECT_AND_EXIT;
        }
        break;

        default:
        {
            TRC_ABORT((TB,_T("Unexpected event passed to CC_Event")));
            DC_QUIT;
        }
        break;
    }

    CCFSMProc(internalEvent, 0, 0);

DC_EXIT_POINT:
    DC_END_FN();

    return;

} /* CC_Event */


/**PROC+*********************************************************************/
/* Name:      CC_Connect                                                    */
/*                                                                          */
/* Purpose:   Handles calls from the component Decoupler by passing on the  */
/*            RNSAddress with a CC_EVENT_CONNECTOK event to CCFSMProc       */
/*                                                                          */
/* Returns:   Nothing                                                       */
/*                                                                          */
/* Params:    IN - RNSAddress - pointer to RNSAddress string to be called   */
/*            IN - unusedParam - not used                                   */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI CCC::CC_Connect(PDCVOID pData, DCUINT dataLen)
{
    PCONNECTSTRUCT  pConnectStruct = (PCONNECTSTRUCT)pData;

    DC_BEGIN_FN("CC_Connect");
    TRC_ASSERT((dataLen == sizeof(CONNECTSTRUCT) ), (TB,_T("Bad connect data")));

    CCFSMProc(CC_EVT_STARTCONNECT, (ULONG_PTR)pConnectStruct, dataLen);

    DC_END_FN();

    return;

} /* CC_Connect */


/**PROC+*********************************************************************/
/* Name:      CC_ConnectFail                                                */
/*                                                                          */
/* Purpose:   Handles calls from the Component Decoupler by passing on the  */
/*            failId and with a CC_EVENT_CONNECTFAIL event to CCFSMProc     */
/*                                                                          */
/* Returns:   Nothing                                                       */
/*                                                                          */
/* Params:    IN - failID - Reason of failure to connect                    */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI CCC::CC_OnDisconnected(ULONG_PTR failId)
{
    DC_BEGIN_FN("CC_OnDisconnected");

    TRC_DBG((TB, _T("CC_ConnectFail handling failure %hd"), failId));
    CCFSMProc(CC_EVT_ONDISCONNECTED, (DCUINT32)failId, sizeof(DCUINT32));

#ifdef OS_WINCE
        if (gbFlushHKLM)
        {
#ifdef DC_DEBUG
            DWORD dwTick = GetTickCount();
#endif
            RegFlushKey(HKEY_LOCAL_MACHINE);
            gbFlushHKLM = FALSE;
#ifdef DC_DEBUG
            TRC_NRM((TB, _T("RegFlushKey took %d milliseconds"), (GetTickCount() - dwTick)));
#endif
        }
#endif

    DC_END_FN();

    return;

} /* CC_ConnectFail */

/**PROC+*********************************************************************/
/* Name:      CC_OnDemandActivePDU                                          */
/*                                                                          */
/* Purpose:   Handles calls from the Component Decoupler by storing         */
/*            the serverMCSId locally and calling                           */
/*            CCFSMProc with a CC_EVENT_DEMAND_ACTIVE event                 */
/*                                                                          */
/* Returns:   Nothing                                                       */
/*                                                                          */
/* Params:    IN - pPDU - pointer to a demand active PDU                    */
/*            IN - dataLen - length of data pointed to by pPDU              */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI CCC::CC_OnDemandActivePDU(PDCVOID pData, DCUINT dataLen)
{
    DC_BEGIN_FN("CC_OnDemandActivePDU");

    CCFSMProc(CC_EVT_ONDEMANDACTIVE, (ULONG_PTR) pData, dataLen);

    DC_END_FN();

    return;

} /* CC_DemandActiveRequest */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\cc.h ===
/****************************************************************************/
// cc.h
//
// Call controller class defs.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifndef _H_CC
#define _H_CC

extern "C" {
//#include <acmapi.h>
//#include <afsapi.h>
//#include <auhapi.h>

#include <adcgdata.h>
#include <adcgfsm.h>
}

#include "cd.h"
#include "uh.h"

#include "cm.h"
#include "fs.h"


class CUI;
class CSL;
class CUH;
class CCD;
class CIH;
class COR;
class CFS;
class CCM;
class CChan;


/****************************************************************************/
/* FSM events (different numbers as the internal events)                    */
/****************************************************************************/
#define CC_EVT_API_ONCONNECTOK            101
#define CC_EVT_API_ONBUFFERAVAILABLE      104
#define CC_EVT_API_ONDEACTIVATEALL        105
#define CC_EVT_API_DISCONNECT             106
#define CC_EVT_API_ONSHUTDOWNDENIED       107
#define CC_EVT_API_DISCONNECTANDEXIT      108
#define CC_EVT_API_SHUTDOWN               109


/****************************************************************************/
/* Structure: CC_COMBINED_CAPABILITIES                                      */
/*                                                                          */
/* Description: Capabilities sent from client to server.                    */
/****************************************************************************/
typedef struct tagCC_COMBINED_CAPABILITIES
{
    UINT16                             numberCapabilities;
#ifdef DRAW_GDIPLUS
#ifdef DRAW_NINEGRID
#define CC_COMBINED_CAPS_NUMBER_CAPABILITIES 18
#else // DRAW_NINEGRID
#define CC_COMBINED_CAPS_NUMBER_CAPABILITIES 17
#endif // DRAW_NINEGRID
#else  // DRAW_GDIPLUS
#ifdef DRAW_NINEGRID
#define CC_COMBINED_CAPS_NUMBER_CAPABILITIES 17
#else 
#define CC_COMBINED_CAPS_NUMBER_CAPABILITIES 16
#endif // DRAW_NINEGRID
#endif // DRAW_GDIPLUS

    UINT16                             pad2octets;
    TS_GENERAL_CAPABILITYSET           generalCapabilitySet;
    TS_BITMAP_CAPABILITYSET            bitmapCapabilitySet;
    TS_ORDER_CAPABILITYSET             orderCapabilitySet;
    TS_BITMAPCACHE_CAPABILITYSET       bitmapCacheCaps;
    TS_COLORTABLECACHE_CAPABILITYSET   colorTableCacheCapabilitySet;
    TS_WINDOWACTIVATION_CAPABILITYSET  windowActivationCapabilitySet;
    TS_CONTROL_CAPABILITYSET           controlCapabilitySet;
    TS_POINTER_CAPABILITYSET           pointerCapabilitySet;
    TS_SHARE_CAPABILITYSET             shareCapabilitySet;
    TS_INPUT_CAPABILITYSET             inputCapabilitySet;
    TS_SOUND_CAPABILITYSET             soundCapabilitySet;
    TS_FONT_CAPABILITYSET              fontCapabilitySet;
    TS_GLYPHCACHE_CAPABILITYSET        glyphCacheCapabilitySet;
    TS_BRUSH_CAPABILITYSET             brushCapabilitySet;
    TS_OFFSCREEN_CAPABILITYSET         offscreenCapabilitySet;
    TS_VIRTUALCHANNEL_CAPABILITYSET    virtualchannelCapabilitySet;

#ifdef DRAW_NINEGRID
    TS_DRAW_NINEGRID_CAPABILITYSET     drawNineGridCapabilitySet;
#endif

#ifdef DRAW_GDIPLUS
    TS_DRAW_GDIPLUS_CAPABILITYSET       drawGdiplusCapabilitySet;
#endif

} CC_COMBINED_CAPABILITIES, DCPTR PCC_COMBINED_CAPABILITIES;


/****************************************************************************/
/* FSM definitions                                                          */
/****************************************************************************/
#define CC_FSM_INPUTS       11
#define CC_FSM_STATES       11

/****************************************************************************/
/* FSM states                                                               */
/****************************************************************************/
#define CC_DISCONNECTED                0
#define CC_CONNECTPENDING              1
#define CC_WAITINGFORDEMANDACTIVE      2
#define CC_SENDINGCONFIRMACTIVE1       3
#define CC_SENDINGSYNC1                4
#define CC_SENDINGCOOPCONTROL          5
#define CC_SENDINGGRANTCONTROL         CC_SENDINGCOOPCONTROL + 1
#define CC_CONNECTED                   CC_SENDINGCOOPCONTROL + 2
#define CC_SENDING_SHUTDOWNPDU         CC_SENDINGCOOPCONTROL + 3
#define CC_SENT_SHUTDOWNPDU            CC_SENDINGCOOPCONTROL + 4
#define CC_PENDING_SHUTDOWN            CC_SENDINGCOOPCONTROL + 5


#ifdef DC_DEBUG
static TCHAR FAR *stateString[CC_FSM_STATES] =
{
    _T("CC_DISCONNECTED"),
    _T("CC_CONNECTPENDING"),
    _T("CC_WAITINGFORDEMANDACTIVE"),
    _T("CC_SENDINGCONFIRMACTIVE1"),
    _T("CC_SENDINGSYNC1"),
    _T("CC_SENDINGCOOPCONTROL"),
    _T("CC_SENDINGGRANTCONTROL"),
    _T("CC_CONNECTED"),
    _T("CC_SENDING_SHUTDOWPDU"),
    _T("CC_SENT_SHUTDOWNPDU"),
    _T("CC_PENDING_SHUTDOWN")
};
#endif /* DEBUG */


/****************************************************************************/
/* FSM events                                                               */
/****************************************************************************/
#define CC_EVT_STARTCONNECT           0
#define CC_EVT_ONCONNECTOK            1
#define CC_EVT_ONDEMANDACTIVE         2
#define CC_EVT_SENTOK                 3
#define CC_EVT_ONBUFFERAVAILABLE      4
#define CC_EVT_ONDEACTIVATEALL        5
#define CC_EVT_DISCONNECT             6
#define CC_EVT_ONDISCONNECTED         7
#define CC_EVT_SHUTDOWN               8
#define CC_EVT_ONSHUTDOWNDENIED       9
#define CC_EVT_DISCONNECT_AND_EXIT   10

#ifdef DC_DEBUG

static TCHAR FAR *eventString[CC_FSM_INPUTS] =
{
    _T("CC_EVT_STARTCONNECT"),
    _T("CC_EVT_ONCONNECTOK"),
    _T("CC_EVT_ONDEMANDACTIVE"),
    _T("CC_EVT_SENTOK"),
    _T("CC_EVT_ONBUFFERAVAILABLE"),
    _T("CC_EVT_ONDEACTIVATEALL"),
    _T("CC_EVT_DISCONNECT"),
    _T("CC_EVT_ONDISCONNECTED"),
    _T("CC_EVT_SHUTDOWN"),
    _T("CC_EVT_ONSHUTDOWNDENIED"),
    _T("CC_EVT_DISCONNECT_AND_EXIT")
};
#endif /* DEBUG */


typedef struct tagCC_GLOBAL_DATA
{
    TS_SHARECONTROLHEADER shareControlHeader;
    TS_SHAREDATAHEADER    shareDataHeader;
    unsigned fsmState;
    unsigned packetLen;
    PBYTE pBuffer;
    //
    // Flag indicating we've already set the safe checksum settings
    // for this link.
    //
    BOOL    fSafeChecksumSettingsSet;
} CC_GLOBAL_DATA;

class CCC
{
public:
    CCC(CObjs* objs);
    ~CCC();

    //
    // API functions
    //

    void DCAPI CC_Init();
    void DCAPI CC_Term();
    
    void DCAPI CC_Event(ULONG_PTR);
    void DCAPI CC_Connect(PVOID, unsigned);

    EXPOSE_CD_NOTIFICATION_FN(CCC, CC_Connect);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CCC, CC_Event);

    void DCAPI CC_OnDisconnected(ULONG_PTR);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CCC, CC_OnDisconnected)

    void DCAPI CC_OnDemandActivePDU(PVOID, unsigned);
    EXPOSE_CD_NOTIFICATION_FN(CCC, CC_OnDemandActivePDU)


    //
    // Data members
    //

public:

    /****************************************************************************/
    /* CC_BUFSIZE is big enough for the largest packet sent by CC - which is a  */
    /* ConfirmActivePDU with Combined Caps and the largest legal                */
    /* SourceDescriptor.                                                        */
    /****************************************************************************/
    #define CC_BUFSIZE \
             (TS_CA_NON_DATA_SIZE + TS_MAX_SOURCEDESCRIPTOR +  \
             sizeof(CC_COMBINED_CAPABILITIES))
    
    /****************************************************************************/
    /* Call Controller global data                                              */
    /****************************************************************************/
    
    /****************************************************************************/
    /* Structure: CC_GLOBAL_DATA                                                */
    /*                                                                          */
    /* Description: Data global in the Call Controller                          */
    /****************************************************************************/
    CC_GLOBAL_DATA _CC;

    CC_COMBINED_CAPABILITIES _ccCombinedCapabilities;


    //
    // FSM
    //

    //
    // Internal methods
    //
private:

    /****************************************************************************/
    /* Name for use as terminal descriptor                                      */
    /****************************************************************************/
    #define CC_DUCATI_NAME "MSTSC"
    
    /****************************************************************************/
    /* SL types                                                                 */
    /****************************************************************************/
    #define CC_SEND_FLAGS_CONFIRM   (RNS_SEC_RESET_SEQNO |                       \
                                     RNS_SEC_IGNORE_SEQNO |                      \
                                     RNS_SEC_ENCRYPT)
    
    #define CC_SEND_FLAGS_DATA      (RNS_SEC_ENCRYPT)
    
    #define CC_SEND_FLAGS_OTHER     (RNS_SEC_ENCRYPT | RNS_SEC_IGNORE_SEQNO)
    
    /****************************************************************************/
    /* Call Controller internal function prototypes                             */
    /****************************************************************************/
    
    void DCINTERNAL CCFSMProc(unsigned, ULONG_PTR, DCUINT dataLen);
    void DCINTERNAL CCBuildConfirmActivePDU();
    void DCINTERNAL CCBuildSyncPDU();
    void DCINTERNAL CCBuildCoopControlPDU();
    void DCINTERNAL CCSendPDU(unsigned, unsigned, unsigned, unsigned);
    void DCINTERNAL CCBuildShutdownReqPDU();
    void DCINTERNAL CCBuildRequestControlPDU();
    void DCINTERNAL CCBuildShareHeaders();
    HRESULT DCINTERNAL CCShareStart(PTS_DEMAND_ACTIVE_PDU, DCUINT dataLen,
                                    PBOOL pfChecksumEncryptedData);
    void DCINTERNAL CCShareEnd();
    void DCINTERNAL CCEnableShareSendCmpnts();
    void DCINTERNAL CCDisableShareSendCmpnts();
    void DCINTERNAL CCEnableShareRecvCmpnts();
    void DCINTERNAL CCDisableShareRecvCmpnts();
    void DCINTERNAL CCDisconnectShareRecvCmpnts();
    
    #define CC_TYPE_CONFIRMACTIVE  1
    #define CC_TYPE_SYNCHRONIZE    2
    #define CC_TYPE_COOPCONTROL    3
    #define CC_TYPE_REQUESTCONTROL 4
    #define CC_TYPE_SHUTDOWNREQ    5

private:
    CUT* _pUt;
    CUI* _pUi;
    CSL* _pSl;
    CUH* _pUh;
    CCD* _pCd;
    CIH* _pIh;
    COR* _pOr;
    CFS* _pFs;
    CCM* _pCm;
    CChan* _pCChan;

private:
    CObjs* _pClientObjects;

};



#endif // _H_CC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\arcdlg.cpp ===
//
// arcdlg.cpp: Autoreconnect dialog box
//             modeless dialog box for autoreconnection status
//
// Copyright Microsoft Corportation 2001
// (nadima)
//

#include "adcg.h"

#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "arcdlg.cpp"
#include <atrcapi.h>

#include "arcdlg.h"
#include "axresrc.h"

#define TRANSPARENT_MASK_COLOR RGB(105, 139, 228)

#ifdef OS_WINCE
#define RGB_TOPBAND RGB(0, 52, 156)
#define RGB_MIDBAND RGB(49,101,206)
#endif

//
// Runtime debug flags instrumentation for 611316
//
#define ARCDLG_DEBUG_DESTROYCALLED      0x0001
#define ARCDLG_DEBUG_WMDESTROYCALLED    0x0002
#define ARCDLG_DEBUG_WMDESTROYSUCCEED   0x0004
#define ARCDLG_DEBUG_SETNULLINSTPTR     0x0008
DWORD g_dwArcDlgDebug = 0;
#define ARC_DBG_SETINFO(x)   g_dwArcDlgDebug |= x;

LPTSTR
FormatMessageVArgs(LPCTSTR pcszFormat, ...)

{
    LPTSTR      pszOutput;
    va_list     argList;

    va_start(argList, pcszFormat);
    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                      pcszFormat,
                      0, 0,
                      reinterpret_cast<LPTSTR>(&pszOutput), 0,
                      &argList) == 0)
    {
        pszOutput = NULL;
    }

    va_end(argList);
    return(pszOutput);
}


///////////////////////////////////////////////////////////////////////////////
//
// ARC UI base class
//
CAutoReconnectUI::CAutoReconnectUI(
                    HWND hwndOwner,
                    HINSTANCE hInst,
                    CUI* pUi) :
                    _hwndOwner(hwndOwner),
                    _hInstance(hInst),
                    _hwnd(NULL),
                    _pUi(pUi)
{
    DC_BEGIN_FN("CAutoReconnectUI");

#ifndef OS_WINCE
    _hGDI = LoadLibrary(_T("gdi32.dll"));
    if (_hGDI) {
        _pfnSetLayout = (PFNGDI_SETLAYOUT)GetProcAddress(_hGDI, "SetLayout");
        if (!_pfnSetLayout) {
            TRC_ERR((TB,_T("GetProcAddress 'SetLayout' failed: 0x%x"),
                     GetLastError()));
        }
    }
#else
    _hGDI = NULL;
    _pfnSetLayout = NULL;
#endif

    DC_END_FN();
}

CAutoReconnectUI::~CAutoReconnectUI()
{
    DC_BEGIN_FN("CAutoReconnectUI");

#ifndef OS_WINCE
    if (_hGDI) {
        _pfnSetLayout = NULL;
        FreeLibrary(_hGDI);
        _hGDI = NULL;
    }
#endif
    
    DC_END_FN();
}

//
//  PaintBitmap
//
//  Params:  hdcDestination  =   HDC to paint into.
//              prcDestination  =   RECT in HDC to paint into.
//              hbmSource       =   HBITMAP to paint.
//              prcSource       =   RECT from HBITMAP to paint from.
//
//  Returns:    <none>
//
//  Purpose:    Wraps blitting a bitmap.
//
//  Modified from version in shell code
//
VOID
CAutoReconnectUI::PaintBitmap(
    HDC hdcDestination,
    const RECT* prcDestination,
    HBITMAP hbmSource,
    const RECT *prcSource
    )
{
    HDC     hdcBitmap;

    DC_BEGIN_FN("PaintBitmap");

    hdcBitmap = CreateCompatibleDC(NULL);
    if (hdcBitmap != NULL)
    {
        BOOL        fEqualWidthAndHeight;
        INT         iWidthSource, iHeightSource;
        INT         iWidthDestination, iHeightDestination;
        INT         iStretchBltMode;
#ifndef OS_WINCE
        DWORD       dwLayout;
#endif
        HBITMAP     hbmSelected;
        RECT        rcSource;
        BITMAP      bitmap;

        if (prcSource == NULL)
        {
            if (GetObject(hbmSource, sizeof(bitmap), &bitmap) == 0)
            {
                bitmap.bmWidth = prcDestination->right - prcDestination->left;
                bitmap.bmHeight = prcDestination->bottom - prcDestination->top;
            }
            SetRect(&rcSource, 0, 0, bitmap.bmWidth, bitmap.bmHeight);
            prcSource = &rcSource;
        }
        hbmSelected = static_cast<HBITMAP>(SelectObject(hdcBitmap, hbmSource));
        iWidthSource = prcSource->right - prcSource->left;
        iHeightSource = prcSource->bottom - prcSource->top;
        iWidthDestination = prcDestination->right - prcDestination->left;
        iHeightDestination = prcDestination->bottom - prcDestination->top;
        fEqualWidthAndHeight = (iWidthSource == iWidthDestination) &&
                               (iHeightSource == iHeightDestination);
        if (!fEqualWidthAndHeight) {
#ifndef OS_WINCE
            iStretchBltMode = SetStretchBltMode(hdcDestination, HALFTONE);
#endif
        }
        else {
            iStretchBltMode = 0;
        }

#ifndef OS_WINCE
        if (_pfnSetLayout) {
            dwLayout = _pfnSetLayout(hdcDestination,
                                     LAYOUT_BITMAPORIENTATIONPRESERVED);
        }
#endif
        if (!StretchBlt(hdcDestination,
                    prcDestination->left,
                    prcDestination->top,
                    iWidthDestination,
                    iHeightDestination,
                    hdcBitmap,
                    prcSource->left,
                    prcSource->top,
                    iWidthSource,
                    iHeightSource,
                    SRCCOPY)) {
            TRC_ERR((TB,_T("Blt failed")));
        }

#ifndef OS_WINCE
        if (_pfnSetLayout) {
            _pfnSetLayout(hdcDestination, dwLayout);
        }

        if (!fEqualWidthAndHeight) {
            (int)SetStretchBltMode(hdcDestination, iStretchBltMode);
        }
#endif
        (HGDIOBJ)SelectObject(hdcBitmap, hbmSelected);
        DeleteDC(hdcBitmap);
    }

    DC_END_FN();
}


VOID
CAutoReconnectUI::CenterWindow(
    HWND hwndCenterOn,
    INT xRatio,
    INT yRatio
    )
{
    RECT  childRect;
    RECT  parentRect;
    DCINT xPos;
    DCINT yPos;

    LONG  desktopX = GetSystemMetrics(SM_CXSCREEN);
    LONG  desktopY = GetSystemMetrics(SM_CYSCREEN);

    BOOL center = TRUE;

    DC_BEGIN_FN("CenterWindowOnParent");

    TRC_ASSERT(_hwnd, (TB, _T("_hwnd is NULL...was it set in WM_INITDIALOG?\n")));
    if (!_hwnd)
    {
        TRC_ALT((TB, _T("Window doesn't exist")));
        DC_QUIT;
    }
    if (!xRatio)
    {
        xRatio = 2;
    }
    if (!yRatio)
    {
        yRatio = 2;
    }

    GetClientRect(hwndCenterOn, &parentRect);
    GetWindowRect(_hwnd, &childRect);

    //
    // Calculate the top left - centered in the parent window.
    //
    xPos = ( (parentRect.right + parentRect.left) -
             (childRect.right - childRect.left)) / xRatio;
    yPos = ( (parentRect.bottom + parentRect.top) -
             (childRect.bottom - childRect.top)) / yRatio;

    //
    // Constrain to the desktop
    //
    if (xPos < 0)
    {
        xPos = 0;
    }
    else if (xPos > (desktopX - (childRect.right - childRect.left)))
    {
        xPos = desktopX - (childRect.right - childRect.left);
    }
    if (yPos < 0)
    {
        yPos = 0;
    }
    else if (yPos > (desktopY - (childRect.bottom - childRect.top)))
    {
        yPos = desktopY - (childRect.bottom - childRect.top);
    }

    TRC_DBG((TB, _T("Set dialog position to %u %u"), xPos, yPos));
    SetWindowPos(_hwnd,
                 NULL,
                 xPos, yPos,
                 0, 0,
                 SWP_NOSIZE | SWP_NOACTIVATE);

DC_EXIT_POINT:
    DC_END_FN();

    return;
} // CenterWindowOnParent


#ifndef ARC_MINIMAL_UI

///////////////////////////////////////////////////////////////////////////////
//
// ARC UI - Rich UI - dialog with status text and progress band
//

CAutoReconnectDlg::CAutoReconnectDlg(HWND hwndOwner,
                                     HINSTANCE hInst,
                                     CUI* pUi) :
                    CAutoReconnectUI(hwndOwner, hInst, pUi),
                    _fInitialized(FALSE),
                    _hfntTitle(NULL),
                    _pProgBand(NULL),
                    _hPalette(NULL)
{
#ifndef OS_WINCE
    BOOL fUse8BitDepth = FALSE;
#else
    BOOL fUse8BitDepth = TRUE;
#endif
    LOGFONT     logFont;
#ifndef OS_WINCE
    HDC hdcScreen;
    char        szPixelSize[10];
#else
    WCHAR        szPixelSize[10];
#endif
    BITMAP bitmap;
    INT logPixelsY = 100;

    DC_BEGIN_FN("CAutoReconnectDlg");

    _nArcTimerID = 0;
    _elapsedArcTime = 0;
    _fContinueReconAttempts = TRUE; 

#ifndef OS_WINCE
    //
    // Get color depth
    //
    hdcScreen = GetDC(NULL);
    if (hdcScreen) {
        fUse8BitDepth = (GetDeviceCaps(hdcScreen, BITSPIXEL) <= 8);
        logPixelsY = GetDeviceCaps(hdcScreen, LOGPIXELSY);
        ReleaseDC(NULL, hdcScreen);
        hdcScreen = NULL;
    }
#endif

    //
    // Load bitmaps
    //
    _hbmBackground = (HBITMAP)LoadImage(
                                _hInstance,
                                MAKEINTRESOURCE(fUse8BitDepth ?
                                    IDB_ARC_BACKGROUND8 :IDB_ARC_BACKGROUND24),
                                IMAGE_BITMAP,
                                0,
                                0,
#ifndef OS_WINCE
                                LR_CREATEDIBSECTION);
#else
                                0);
#endif
    if ((_hbmBackground != NULL) &&
        (GetObject(_hbmBackground,
                   sizeof(bitmap), &bitmap) >= sizeof(bitmap))) {
        SetRect(&_rcBackground, 0, 0, bitmap.bmWidth, bitmap.bmHeight);
    }

    _hbmFlag = (HBITMAP)LoadImage(
                                _hInstance,
                                MAKEINTRESOURCE(fUse8BitDepth ?
                                    IDB_ARC_WINFLAG8 :IDB_ARC_WINFLAG24),
                                IMAGE_BITMAP,
                                0,
                                0,
#ifndef OS_WINCE
                                LR_CREATEDIBSECTION);
#else
                                0);
#endif
    if ((_hbmFlag != NULL) &&
        (GetObject(_hbmFlag,
                   sizeof(bitmap), &bitmap) >= sizeof(bitmap))) {
        SetRect(&_rcFlag, 0, 0, bitmap.bmWidth, bitmap.bmHeight);
    }

#ifndef OS_WINCE
    _hbmDisconImg = (HBITMAP)LoadImage(
                                _hInstance,
                                MAKEINTRESOURCE(fUse8BitDepth ?
                                    IDB_ARC_DISCON8 :IDB_ARC_DISCON24),
                                IMAGE_BITMAP,
                                0,
                                0,
                                LR_CREATEDIBSECTION);
    if ((_hbmDisconImg != NULL) &&
        (GetObject(_hbmDisconImg,
                   sizeof(bitmap), &bitmap) >= sizeof(bitmap))) {
        SetRect(&_rcDisconImg, 0, 0, bitmap.bmWidth, bitmap.bmHeight);
    }

    _hPalette = CUT::UT_GetPaletteForBitmap(NULL, _hbmBackground);
#endif


    //
    //  Create fonts. Load the font name and size from resources.
    //

    ZeroMemory(&logFont, sizeof(logFont));
#ifndef OS_WINCE
    if (LoadStringA(_hInstance,
                    IDS_ARC_TITLE_FACESIZE,
                    szPixelSize,
                    sizeof(szPixelSize)) != 0)
#else
    if (LoadString(_hInstance,
                    IDS_ARC_TITLE_FACESIZE,
                    szPixelSize,
                    sizeof(szPixelSize)/sizeof(WCHAR)) != 0)
#endif
    {
#ifndef OS_WINCE
        logFont.lfHeight = -MulDiv(atoi(szPixelSize),
                                   logPixelsY, 72);
#else
        logFont.lfHeight = -(_wtoi(szPixelSize)/logPixelsY*72);
#endif
        if (LoadString(_hInstance,
                       IDS_ARC_TITLE_FACENAME,
                       logFont.lfFaceName,
                       LF_FACESIZE) != 0)
        {
            logFont.lfWeight = FW_BOLD;
            logFont.lfQuality = DEFAULT_QUALITY;
            _hfntTitle = CreateFontIndirect(&logFont);
        }
    }

    _szConnectAttemptStringTmpl[0] = NULL;
    if (!LoadString(_hInstance,
                   IDS_ARC_CONATTEMPTS,
                   _szConnectAttemptStringTmpl,
                   sizeof(_szConnectAttemptStringTmpl)/sizeof(TCHAR)) != 0)
    {
        TRC_ERR((TB,_T("Failed to load IDS_ARC_CONATTEMPTS")));
    }

    _lastDiscReason = NL_DISCONNECT_LOCAL;

#ifdef OS_WINCE
    _hbrTopBand = CreateSolidBrush(RGB_TOPBAND);
    _hbrMidBand = CreateSolidBrush(RGB_MIDBAND);
#endif
    

    _fInitialized = (_hbmBackground &&
                     _hbmFlag       &&
                     _hfntTitle     &&
                     _pUi           &&
                     _szConnectAttemptStringTmpl[0]); 
    if (!_fInitialized) {
        TRC_ERR((TB,_T("Failed to properly init arc dlg")));
    }

    DC_END_FN();
}

CAutoReconnectDlg::~CAutoReconnectDlg()
{
    if (_hbmBackground) {
        DeleteObject(_hbmBackground);
        _hbmBackground = NULL;
    }

    if (_hbmFlag) {
        DeleteObject(_hbmFlag);
        _hbmFlag = NULL;
    }

#ifndef OS_WINCE
    if (_hbmDisconImg) {
        DeleteObject(_hbmDisconImg);
        _hbmDisconImg = NULL;
    }
#endif

    if (_hfntTitle) {
        DeleteObject(_hfntTitle);
        _hfntTitle = NULL;
    }

    if (_hPalette) {
        DeleteObject(_hPalette);
        _hPalette = NULL;
    }

    if (_pProgBand) {
        delete _pProgBand;
        _pProgBand = NULL;
    }

#ifdef OS_WINCE
    if (_hbrTopBand) {
        DeleteObject(_hbrTopBand);
        _hbrTopBand = NULL;
    }

    if (_hbrMidBand) {
        DeleteObject(_hbrMidBand);
        _hbrMidBand = NULL;
    }
#endif
}

HWND CAutoReconnectDlg::StartModeless()
{
    LONG_PTR dwStyle;
    DC_BEGIN_FN("StartModeless");

    if (!_fInitialized) {
        TRC_ERR((TB,_T("failing startmodeless fInitialized is FALSE")));
        return NULL;
    }

    _hwnd = CreateDialogParam(_hInstance,
                                 MAKEINTRESOURCE(IDD_ARCDLG),
                                 _hwndOwner,
                                 StaticDialogBoxProc,
                                 (LPARAM)this);

    if (_hwnd) {
        //
        // Make the dialog a child of the parent
        //
        dwStyle = GetWindowLongPtr(_hwnd, GWL_STYLE);
        dwStyle &= ~WS_POPUP;
        dwStyle |= WS_CHILD;
        SetParent(_hwnd, _hwndOwner);
        SetWindowLongPtr(_hwnd, GWL_STYLE, dwStyle);
    }
    else {
        TRC_ERR((TB,_T("CreateDialog failed: 0x%x"), GetLastError()));
    }

    DC_END_FN();
    return _hwnd;
}

BOOL CAutoReconnectDlg::ShowTopMost()
{
    BOOL rc = FALSE;
    DC_BEGIN_FN("ShowTopMost");

    if (!_hwnd) {
        DC_QUIT;
    }

    ShowWindow(_hwnd, SW_SHOWNORMAL);

    //
    // Bring the window to the TOP of the Z order
    //
    SetWindowPos( _hwnd,
                  HWND_TOPMOST,
                  0, 0, 0, 0,
                  SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE );

    rc = TRUE;

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}

VOID
CAutoReconnectDlg::OnParentSizePosChange()
{
    DC_BEGIN_FN("OnParentSizePosChange");

    //
    // Reposition the dialog to 1/2 down the middle
    // of the owner window
    //
    if (_hwnd && _hwndOwner) {
        CenterWindow(_hwndOwner, 2, 2);
    }

    DC_END_FN();
}

//
// Handler for WM_ERASEBKGND (See platform sdk docs)
//
VOID
CAutoReconnectDlg::OnEraseBkgnd(
    HWND hwnd,
    HDC hdc
    )
{
    RECT    rc;
    HPALETTE hPaletteOld = NULL;
    DC_BEGIN_FN("OnEraseBkgnd");

    TRC_ASSERT(_hbmBackground, (TB,_T("_hbmBackground is NULL")));

    if (GetClientRect(hwnd, &rc)) {

        hPaletteOld = SelectPalette(hdc, _hPalette, FALSE);
        RealizePalette(hdc);

        PaintBitmap(hdc, &rc, _hbmBackground, &_rcBackground);

        SelectPalette(hdc, hPaletteOld, FALSE);
        RealizePalette(hdc);

    }

    DC_END_FN();
}


//
// Handler for WM_PRINTCLIENT
//
VOID
CAutoReconnectDlg::OnPrintClient(
    HWND hwnd,
    HDC hdcPrint,
    DWORD dwOptions)
{
    DC_BEGIN_FN("OnPrintClient");

#ifndef OS_WINCE
    if ((dwOptions & (PRF_ERASEBKGND | PRF_CLIENT)) != 0)
    {
        OnEraseBkgnd(hwnd, hdcPrint);
    }
#endif
    DC_END_FN();
}

#ifndef OS_WINCE
void xDrawTransparentBitmap(HDC hdc, HBITMAP hBitmap, short xStart,
                           short yStart, COLORREF cTransparentColor)
{
   BITMAP     bm;
   COLORREF   cColor;
   HBITMAP    bmAndBack, bmAndObject, bmAndMem, bmSave;
   HBITMAP    bmBackOld, bmObjectOld, bmMemOld, bmSaveOld;
   HDC        hdcMem, hdcBack, hdcObject, hdcTemp, hdcSave;
   POINT      ptSize;

   hdcTemp = CreateCompatibleDC(hdc);
   SelectObject(hdcTemp, hBitmap);   // Select the bitmap

   GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);
   ptSize.x = bm.bmWidth;            // Get width of bitmap
   ptSize.y = bm.bmHeight;           // Get height of bitmap
   DPtoLP(hdcTemp, &ptSize, 1);      // Convert from device

                                     // to logical points

   // Create some DCs to hold temporary data.
   hdcBack   = CreateCompatibleDC(hdc);
   hdcObject = CreateCompatibleDC(hdc);
   hdcMem    = CreateCompatibleDC(hdc);
   hdcSave   = CreateCompatibleDC(hdc);

   // Create a bitmap for each DC. DCs are required for a number of
   // GDI functions.

   // Monochrome DC
   bmAndBack   = CreateBitmap(ptSize.x, ptSize.y, 1, 1, NULL);

   // Monochrome DC
   bmAndObject = CreateBitmap(ptSize.x, ptSize.y, 1, 1, NULL);

   bmAndMem    = CreateCompatibleBitmap(hdc, ptSize.x, ptSize.y);
   bmSave      = CreateCompatibleBitmap(hdc, ptSize.x, ptSize.y);

   // Each DC must select a bitmap object to store pixel data.
   bmBackOld   = (HBITMAP)SelectObject(hdcBack, bmAndBack);
   bmObjectOld = (HBITMAP)SelectObject(hdcObject, bmAndObject);
   bmMemOld    = (HBITMAP)SelectObject(hdcMem, bmAndMem);
   bmSaveOld   = (HBITMAP)SelectObject(hdcSave, bmSave);

   // Set proper mapping mode.
   SetMapMode(hdcTemp, GetMapMode(hdc));

   // Save the bitmap sent here, because it will be overwritten.
   BitBlt(hdcSave, 0, 0, ptSize.x, ptSize.y, hdcTemp, 0, 0, SRCCOPY);

   // Set the background color of the source DC to the color.
   // contained in the parts of the bitmap that should be transparent
   cColor = SetBkColor(hdcTemp, cTransparentColor);

   // Create the object mask for the bitmap by performing a BitBlt
   // from the source bitmap to a monochrome bitmap.
   BitBlt(hdcObject, 0, 0, ptSize.x, ptSize.y, hdcTemp, 0, 0,
          SRCCOPY);

   // Set the background color of the source DC back to the original
   // color.
   SetBkColor(hdcTemp, cColor);

   // Create the inverse of the object mask.
   BitBlt(hdcBack, 0, 0, ptSize.x, ptSize.y, hdcObject, 0, 0,
          NOTSRCCOPY);

   // Copy the background of the main DC to the destination.
   BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y, hdc, xStart, yStart,
          SRCCOPY);

   // Mask out the places where the bitmap will be placed.
   BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y, hdcObject, 0, 0, SRCAND);

   // Mask out the transparent colored pixels on the bitmap.
   BitBlt(hdcTemp, 0, 0, ptSize.x, ptSize.y, hdcBack, 0, 0, SRCAND);

   // XOR the bitmap with the background on the destination DC.
   BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y, hdcTemp, 0, 0, SRCPAINT);

   // Copy the destination to the screen.
   BitBlt(hdc, xStart, yStart, ptSize.x, ptSize.y, hdcMem, 0, 0,
          SRCCOPY);

   // Place the original bitmap back into the bitmap sent here.
   BitBlt(hdcTemp, 0, 0, ptSize.x, ptSize.y, hdcSave, 0, 0, SRCCOPY);

   // Delete the memory bitmaps.
   DeleteObject(SelectObject(hdcBack, bmBackOld));
   DeleteObject(SelectObject(hdcObject, bmObjectOld));
   DeleteObject(SelectObject(hdcMem, bmMemOld));
   DeleteObject(SelectObject(hdcSave, bmSaveOld));

   // Delete the memory DCs.
   DeleteDC(hdcMem);
   DeleteDC(hdcBack);
   DeleteDC(hdcObject);
   DeleteDC(hdcSave);
   DeleteDC(hdcTemp);
} 

//
// Handler for WM_DRAWITEM  (see platform sdk)
// Handles owner draw items
//
//
VOID
CAutoReconnectDlg::OnDrawItem(
    HWND hwnd,
    const DRAWITEMSTRUCT *pDIS
    )
{
    DC_BEGIN_FN("OnDrawItem");

    HPALETTE    hPaletteOld = NULL;
    HFONT       hfntSelected;
    int         iBkMode;
    COLORREF    colorText;
    RECT        rc;
    SIZE        size;
    TCHAR       szText[256];

    
    hPaletteOld = SelectPalette(pDIS->hDC, _hPalette, FALSE);
    (UINT)RealizePalette(pDIS->hDC);
    switch (pDIS->CtlID)
    {
        case IDC_TITLE_ARCING:
        {
            //  Draw the title of the dialog "AutoReconecting".
            hfntSelected = static_cast<HFONT>(SelectObject(pDIS->hDC,
                                                           _hfntTitle));
            colorText = SetTextColor(pDIS->hDC, 0x00FFFFFF);
            iBkMode = SetBkMode(pDIS->hDC, TRANSPARENT);
            (int)GetWindowText(GetDlgItem(hwnd, pDIS->CtlID),
                               szText,
                               sizeof(szText)/sizeof(szText[0]));
            GetTextExtentPoint(pDIS->hDC, szText, lstrlen(szText), &size);
            CopyRect(&rc, &pDIS->rcItem);
            InflateRect(&rc, 0, -((rc.bottom - rc.top - size.cy) / 2));
            DrawText(pDIS->hDC, szText, -1, &rc, 0);
            SetBkMode(pDIS->hDC, iBkMode);
            SetTextColor(pDIS->hDC, colorText);
            SelectObject(pDIS->hDC, hfntSelected);
        }
        break;

        case IDC_TITLE_FLAG:
        {
            BITMAP      bitmap;
    
            GetClientRect(pDIS->hwndItem, &rc);
            if (GetObject(_hbmFlag, sizeof(bitmap), &bitmap) != 0)
            {
                rc.left += ((rc.right - rc.left) - bitmap.bmWidth) / 2;
                rc.right = rc.left + bitmap.bmWidth;
                rc.top += ((rc.bottom - rc.top) - bitmap.bmHeight) / 2;
                rc.bottom = rc.top + bitmap.bmHeight;
            }
            PaintBitmap(pDIS->hDC, &rc, _hbmFlag, &_rcFlag);
        }
        break;
        case IDC_ARC_STATIC_DISCBMP:
        {
            xDrawTransparentBitmap(pDIS->hDC, _hbmDisconImg,
                                   0, 0,
                                   TRANSPARENT_MASK_COLOR);
        }
        break;
    }
    (HGDIOBJ)SelectPalette(pDIS->hDC, hPaletteOld, FALSE);
    (UINT)RealizePalette(pDIS->hDC);


    DC_END_FN();
}
#endif

//
// StaticDialogBoxProc
// Params: see platform sdk for wndproc
//
// Delegates work to appropriate instance
//
//
INT_PTR CALLBACK
CAutoReconnectDlg::StaticDialogBoxProc(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    //
    // Delegate to appropriate instance
    // (only works for single instance dialogs)
    //
    DC_BEGIN_FN("StaticDialogBoxProc");
    DCINT retVal = 0;
    CAutoReconnectDlg* pDlg;

    if(WM_INITDIALOG != uMsg) {
        //
        // Need to retreive the instance pointer from the window class
        //
        pDlg = (CAutoReconnectDlg*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    }
    else {
        //
        // WM_INITDIALOG need to grab and set instance pointer
        //

        //
        // lParam contains this pointer (passed in DialogBoxParam)
        //
        pDlg = (CAutoReconnectDlg*) lParam;
        TRC_ASSERT(pDlg,(TB,_T("Got null instance pointer (lParam) in WM_INITDIALOG")));
        if(!pDlg) {
            DC_QUIT;
        }
        //
        // Store the dialog pointer in the windowclass
        //
        SetLastError(0);
        if(!SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pDlg)) {
            if(GetLastError()) {
                TRC_ERR((TB,_T("SetWindowLongPtr failed 0x%x"),
                         GetLastError()));
                DC_QUIT;
            }
        }
    }

    if (pDlg) {
        retVal = pDlg->DialogBoxProc(hwndDlg, uMsg, wParam, lParam);
    }

DC_EXIT_POINT:
    DC_END_FN();
    return retVal;
}


//
// Name: DialogBoxProc
//
// Purpose: Handles AutoReconnect dialog box proc
//
// Returns: TRUE if message dealt with
//          FALSE otherwise
//
// Params: See windows documentation
//
//
INT_PTR CALLBACK CAutoReconnectDlg::DialogBoxProc (HWND hwndDlg,
                                          UINT uMsg,
                                          WPARAM wParam,
                                          LPARAM lParam)
{
    INT_PTR rc = FALSE;
    DC_BEGIN_FN("DialogBoxProc");

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            //
            // Center
            //
            _hwnd = hwndDlg;
            CenterWindow(_hwndOwner, 2, 2);
            UpdateConnectionAttempts(0, 0);

            //
            // The band is positioned a fixed ratio of the way
            // down the height of this dialog to match up with the
            // background image
            //
            RECT cliRect;
            LONG nBandPos = 0;
            GetClientRect(hwndDlg, &cliRect);
            nBandPos = (INT)((cliRect.bottom - cliRect.top) * 42.0/193.0);

            _pProgBand = new CProgressBand(hwndDlg,
                                           _hInstance,
                                           nBandPos,
                                           IDB_ARC_BAND24,
                                           IDB_ARC_BAND8,
                                           NULL);
            if (_pProgBand) {
                if (!_pProgBand->Initialize()) {
                    TRC_ERR((TB,_T("Progress band failed to init")));
                    delete _pProgBand;
                    _pProgBand = NULL;
                }
            }

            //
            // Subclass the cancel button to do the correct key handling
            // this is important because the message loop is driven by
            // the container application so we can't just rely on it
            // calling IsDialogMessage(). In other words we need to manually
            // handle the appropriate keymapping code.
            //
#ifndef OS_WINCE
            if (!SetWindowSubclass(GetDlgItem(hwndDlg, IDCANCEL),
                                   CancelBtnSubclassProc, IDCANCEL,
                                   reinterpret_cast<DWORD_PTR>(this))) {

                TRC_ERR((TB,_T("SetWindowSubclass failed: 0x%x"),
                         GetLastError()));

            }
#else
            _lOldCancelProc = (WNDPROC )SetWindowLong(GetDlgItem(hwndDlg, IDCANCEL), 
                            GWL_WNDPROC, (LONG )CancelBtnSubclassProc);
            SetWindowLong(GetDlgItem(hwndDlg, IDCANCEL), GWL_USERDATA, reinterpret_cast<DWORD_PTR>(this));
#endif
            //
            // Set the focus on the cancel button
            // and make it the default button
            //
            SendMessage(hwndDlg, DM_SETDEFID, IDCANCEL, 0);

            //SetFocus(GetDlgItem(hwndDlg, IDCANCEL));
            SetFocus(hwndDlg);

            if (_pProgBand) {
                _pProgBand->StartSpinning();
            }

            rc = 1;
        }
        break;

        case WM_COMMAND:
        {
            switch(DC_GET_WM_COMMAND_ID(wParam))
            {
                case IDCANCEL:
                {
                    TRC_NRM((TB,_T("AutoReconnect cancel was pressed")));

                    if (_pProgBand) {
                        _pProgBand->StopSpinning();
                    }

                    _pUi->UI_UserInitiatedDisconnect(_lastDiscReason);

                    //
                    // Disable the cancel button and set the cancel flag.
                    // This will take effect on the next autoreconnection
                    // notification.
                    //
                    EnableWindow(GetDlgItem(hwndDlg, IDCANCEL), FALSE);
                    _fContinueReconAttempts = FALSE;
                }
                break;
            }
        }
        break; //WM_COMMAND

        case WM_DESTROY:
        {
            ARC_DBG_SETINFO(ARCDLG_DEBUG_WMDESTROYCALLED);
#ifndef OS_WINCE
            RemoveWindowSubclass(GetDlgItem(hwndDlg, IDCANCEL),
                                 CancelBtnSubclassProc, IDCANCEL);
#else
            SetWindowLong(GetDlgItem(hwndDlg, IDCANCEL),
                          GWL_WNDPROC, (LONG )_lOldCancelProc);
#endif
            //
            // Clear the instance data to prevent further processing
            // after the dialog is deleted
            //
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR)NULL);
        }
        break;

#ifndef OS_WINCE
        case WM_DRAWITEM:
        {
            OnDrawItem(hwndDlg, (DRAWITEMSTRUCT*)(lParam));
        }
        break;
#endif

        case WM_TIMER:
        {
            if (_pProgBand) {
                _pProgBand->OnTimer((INT)wParam);
            }
        }
        break;

        case WM_ERASEBKGND:
        {
            OnEraseBkgnd(hwndDlg, (HDC)wParam);

            if (_pProgBand) {
                _pProgBand->OnEraseParentBackground((HDC)wParam);
            }
            rc = 1;
        }
        break;

        case WM_CTLCOLORDLG:
        {
            SetBkMode((HDC)wParam, TRANSPARENT);
            rc = (INT_PTR)GetStockObject(NULL_BRUSH);
        }
        break;

        case WM_CTLCOLORSTATIC:
        {
            SetTextColor((HDC)wParam, RGB(255,255,255));
            SetBkMode((HDC)wParam, TRANSPARENT);
#ifndef OS_WINCE
            rc = (INT_PTR)GetStockObject(NULL_BRUSH);
#else
            LONG lId = GetWindowLong((HWND)lParam, GWL_ID);
            rc = (INT_PTR)((lId == IDC_TITLE_ARCING) ? _hbrTopBand : _hbrMidBand);
#endif
        }
        break;

#ifndef OS_WINCE
        case WM_PRINTCLIENT:
        {
            OnPrintClient(hwndDlg, (HDC)wParam, (DWORD)lParam);
            rc = 1;
        }
        break;
#endif

        default:
        {
            rc = 0;
        }
        break;
    }

    DC_END_FN();

    return(rc);

} /* DialogBoxProc */

VOID CAutoReconnectDlg::UpdateConnectionAttempts(
    ULONG conAttempts,
    ULONG maxConAttempts)
{
    LPTSTR szFormattedString = NULL;
    HWND hwndStatic;

    DC_BEGIN_FN("UpdateConnectionAttempts");

    hwndStatic = GetDlgItem(GetHwnd(), IDC_ARC_STATIC_INFO);

    szFormattedString = FormatMessageVArgs(
        _szConnectAttemptStringTmpl,
        conAttempts,
        maxConAttempts
        );

    if (szFormattedString) {
        SetDlgItemText(GetHwnd(),
                       IDC_ARC_STATIC_INFO,
                       szFormattedString);
        LocalFree(szFormattedString);

        //
        // Invalidate the static control to trigger a repaint
        //
        if (hwndStatic) {
            RECT rc;
            if (GetWindowRect(hwndStatic, &rc)) {
                MapWindowPoints(HWND_DESKTOP, GetHwnd(),
                                (LPPOINT)&rc,sizeof(RECT)/sizeof(POINT));
                InvalidateRect(GetHwnd(), &rc, TRUE);
                UpdateWindow(GetHwnd());
            }
        }
    }

    DC_END_FN();
}

//
// Called to notify us that we got disconnected
// this means the last connection attempt failed
//
// Params:
//      discReason   - disconnect major reason code
//      attemptCount - attempt count so far
//      pfContinueArc - [OUT] set to FALSE to stop ARC
//
VOID
CAutoReconnectDlg::OnNotifyAutoReconnecting(
        UINT  discReason,
        ULONG attemptCount,
        ULONG maxAttemptCount,
        BOOL* pfContinueArc
        )
{
    DC_BEGIN_FN("OnNotifyDisconnected");

    _lastDiscReason = discReason;

    if (_fContinueReconAttempts) {
        _connectionAttempts = attemptCount;
        UpdateConnectionAttempts(attemptCount, maxAttemptCount);
    }
    else {
        TRC_NRM((TB,_T("Stopping arc - _fContinueReconAttempts is FALSE")));
    }

    *pfContinueArc = _fContinueReconAttempts;

    DC_END_FN();
}

//
// Called to notify us that we have connected
//
VOID CAutoReconnectDlg::OnNotifyConnected()
{
    DC_BEGIN_FN("OnNotifyConnected");

    _fContinueReconAttempts = FALSE;

    DC_END_FN();
}

//
// Destory
// Called to kill and cleanup the dialog
// 
//
BOOL
CAutoReconnectDlg::Destroy()
{
    DC_BEGIN_FN("Destroy");

    ARC_DBG_SETINFO(ARCDLG_DEBUG_DESTROYCALLED);

    if (!DestroyWindow(_hwnd)) {
        TRC_ERR((TB,_T("DestroyWindow failed: 0x%x"),
                GetLastError()));
    }
    else {
        ARC_DBG_SETINFO(ARCDLG_DEBUG_WMDESTROYSUCCEED);
    }

    //
    // Clear the instance data to prevent further processing
    // after the dialog is deleted
    //
    ARC_DBG_SETINFO(ARCDLG_DEBUG_SETNULLINSTPTR);

    SetWindowLongPtr(_hwnd, GWLP_USERDATA, (LONG_PTR)NULL);

    DC_END_FN();
    return TRUE;
}

#ifndef OS_WINCE
LRESULT CALLBACK
CAutoReconnectDlg::CancelBtnSubclassProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    UINT_PTR uiID,
    DWORD_PTR dwRefData
    )
#else
LRESULT CALLBACK
CAutoReconnectDlg::CancelBtnSubclassProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
#endif
{
    LRESULT rc = 0;
    CAutoReconnectDlg* pThis = NULL;

    DC_BEGIN_FN("CancelBtnSubclassProc");

#ifndef OS_WINCE
    pThis = reinterpret_cast<CAutoReconnectDlg*>(dwRefData);
#else
    pThis = reinterpret_cast<CAutoReconnectDlg*>(GetWindowLong(hwnd, GWL_USERDATA));
#endif
    TRC_ASSERT(pThis, (TB,_T("pThis == NULL")));

    switch (uMsg)
    {
        case WM_KEYUP:
        {
            //
            // Hitting 'Esc' or 'Return' on the Cancel button
            // are the same as pressing it
            //
            if (VK_ESCAPE == wParam ||
                VK_RETURN == wParam) {
                SendMessage(hwnd, BM_CLICK, NULL, NULL);
            }
        }
        //
        // Intentional fallthru
        //

        default:
        {
#ifndef OS_WINCE
            rc = DefSubclassProc(hwnd, uMsg, wParam, lParam);
#else
            rc = CallWindowProc(pThis->_lOldCancelProc, hwnd, uMsg, wParam, lParam);
#endif
        }
        break;
    }

    DC_END_FN();
    return rc;
}

#else  // ARC_MINIMAL_UI

#include "res_inc.c"

CAutoReconnectPlainUI::CAutoReconnectPlainUI(HWND hwndOwner,
                                     HINSTANCE hInst,
                                     CUI* pUi) :
                    CAutoReconnectUI(hwndOwner, hInst, pUi),
                    _fInitialized(FALSE),
                    _hPalette(NULL),
                    _fIsUiVisible(FALSE)
{
#ifndef OS_WINCE
    BOOL fUse8BitDepth = FALSE;
#else
    BOOL fUse8BitDepth = TRUE;
#endif
    LOGFONT     logFont;
#ifndef OS_WINCE
    HDC hdcScreen;
#else
#endif
    BITMAP bitmap;
    INT logPixelsY = 100;

    DC_BEGIN_FN("CAutoReconnectPlainUI");

    _nFlashingTimer = 0;
    _fContinueReconAttempts = TRUE; 

#ifndef OS_WINCE
    //
    // Get color depth
    //
    hdcScreen = GetDC(NULL);
    if (hdcScreen) {
        fUse8BitDepth = (GetDeviceCaps(hdcScreen, BITSPIXEL) <= 8);
        logPixelsY = GetDeviceCaps(hdcScreen, LOGPIXELSY);

        //
        // Load bitmaps
        //
        LPBYTE pBitmapBits = fUse8BitDepth ? (LPBYTE)g_DisconImage8Bits :
                                             (LPBYTE)g_DisconImageBits;
        ULONG  cbBitmapLen = fUse8BitDepth ? g_cbDisconImage8Bits :
                                             g_cbDisconImageBits;
                                             
        _hbmDisconImg = (HBITMAP)LoadImageFromMemory(
                                            hdcScreen,
                                            (LPBYTE)pBitmapBits,
                                            cbBitmapLen
                                            );
        if ((_hbmDisconImg != NULL) &&
            (GetObject(_hbmDisconImg,
                       sizeof(bitmap), &bitmap) >= sizeof(bitmap))) {
            SetRect(&_rcDisconImg, 0, 0, bitmap.bmWidth, bitmap.bmHeight);

            _hPalette = CUT::UT_GetPaletteForBitmap(NULL, _hbmDisconImg);
        }
        ReleaseDC(NULL, hdcScreen);
        hdcScreen = NULL;
    }

#endif

    _fInitialized = (_hbmDisconImg && _pUi); 
    if (!_fInitialized) {
        TRC_ERR((TB,_T("Failed to properly init arc dlg")));
    }

    DC_END_FN();
}

CAutoReconnectPlainUI::~CAutoReconnectPlainUI()
{
#ifndef OS_WINCE
    if (_hbmDisconImg) {
        DeleteObject(_hbmDisconImg);
        _hbmDisconImg = NULL;
    }
#endif

    if (_hPalette) {
        DeleteObject(_hPalette);
        _hPalette = NULL;
    }
}

#define ARC_PLAIN_WNDCLASS _T("ARCICON")
HWND CAutoReconnectPlainUI::StartModeless()
{
    LONG_PTR    dwStyle;
    WNDCLASS    tmpWndClass;
    WNDCLASS    plainArcWndClass;
    ATOM        registerClassRc;

    DC_BEGIN_FN("StartModeless");

    if (!_fInitialized) {
        TRC_ERR((TB,_T("failing startmodeless fInitialized is FALSE")));
        return NULL;
    }

    //
    // Create a window to host the UI   
    //
    //
    // Register the class for the Main Window
    //
    if (!GetClassInfo(_hInstance, ARC_PLAIN_WNDCLASS, &tmpWndClass))
    {
        TRC_NRM((TB, _T("Register Main Window class")));
        plainArcWndClass.style         = CS_DBLCLKS;
        plainArcWndClass.lpfnWndProc   = StaticPlainArcWndProc;
        plainArcWndClass.cbClsExtra    = 0;
        plainArcWndClass.cbWndExtra    = sizeof(void*); //store 'this' pointer
        plainArcWndClass.hInstance     = _hInstance;
        plainArcWndClass.hIcon         = NULL;
        plainArcWndClass.hCursor       = LoadCursor(NULL, IDC_ARROW);
        plainArcWndClass.hbrBackground = (HBRUSH) GetStockObject(HOLLOW_BRUSH);
        plainArcWndClass.lpszMenuName  = NULL;
        plainArcWndClass.lpszClassName = ARC_PLAIN_WNDCLASS;

        registerClassRc = RegisterClass (&plainArcWndClass);

        if (registerClassRc == 0)
        {
            TRC_ERR((TB,_T("RegisterClass failed: 0x%x"), GetLastError()));
            DC_QUIT;
        }
    }

    _hwnd = CreateWindow(ARC_PLAIN_WNDCLASS,
                NULL,
                WS_CHILD | WS_CLIPSIBLINGS,
                0,
                0,
                _rcDisconImg.right - _rcDisconImg.left,
                _rcDisconImg.bottom - _rcDisconImg.top,
                _hwndOwner,
                NULL,
                _hInstance,
                this
                );

    if (_hwnd) {
        //
        // Move window to the parent's top-right and then show the window
        //
        MoveToParentTopRight();
        ShowTopMost();
        _fIsUiVisible = TRUE;
    }
    else {
        TRC_ERR((TB,_T("CreateWindow failed: 0x%x"), GetLastError()));
    }

DC_EXIT_POINT:
    DC_END_FN();
    return _hwnd;
}

BOOL CAutoReconnectPlainUI::ShowTopMost()
{
    BOOL rc = FALSE;
    DC_BEGIN_FN("ShowTopMost");

    if (!_hwnd) {
        DC_QUIT;
    }

    ShowWindow(_hwnd, SW_SHOWNORMAL);

    //
    // Bring the window to the TOP of the Z order
    //
    SetWindowPos( _hwnd,
                  HWND_TOPMOST,
                  0, 0, 0, 0,
                  SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE );

    rc = TRUE;

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}

//
// Position offset from the edge
//
#define ICON_POSITION_OFFSET 20

VOID
CAutoReconnectPlainUI::MoveToParentTopRight()
{
    RECT rcParent;
    INT  xPos, yPos;
    DC_BEGIN_FN("OnParentSizePosChange");

    //
    // Reposition the dialog to the top right
    // of the owner window
    //
    if (_hwnd && _hwndOwner) {
        //
        // Position the window in the top-right of the parent
        //
        GetClientRect(_hwndOwner, &rcParent);
        xPos = rcParent.right - ICON_POSITION_OFFSET -
               (_rcDisconImg.right - _rcDisconImg.left);
        yPos = rcParent.top + ICON_POSITION_OFFSET;
        
        SetWindowPos(_hwnd,
                     NULL,
                     xPos, yPos,
                     0, 0,
                     SWP_NOSIZE | SWP_NOACTIVATE);
    }

    DC_END_FN();
}

VOID
CAutoReconnectPlainUI::OnParentSizePosChange()
{
    MoveToParentTopRight();
}

//
// Handler for WM_ERASEBKGND (See platform sdk docs)
//
VOID
CAutoReconnectPlainUI::OnEraseBkgnd(
    HWND hwnd,
    HDC hdc
    )
{
    RECT    rc;
    HPALETTE hPaletteOld = NULL;
    DC_BEGIN_FN("OnEraseBkgnd");

    TRC_ASSERT(_hbmDisconImg, (TB,_T("_hbmBackground is NULL")));

    if (GetClientRect(hwnd, &rc)) {

        hPaletteOld = SelectPalette(hdc, _hPalette, FALSE);
        RealizePalette(hdc);

        PaintBitmap(hdc, &rc, _hbmDisconImg, &_rcDisconImg);

        SelectPalette(hdc, hPaletteOld, FALSE);
        RealizePalette(hdc);

    }

    DC_END_FN();
}


//
// Handler for WM_PRINTCLIENT
//
VOID
CAutoReconnectPlainUI::OnPrintClient(
    HWND hwnd,
    HDC hdcPrint,
    DWORD dwOptions)
{
    DC_BEGIN_FN("OnPrintClient");

#ifndef OS_WINCE
    if ((dwOptions & (PRF_ERASEBKGND | PRF_CLIENT)) != 0)
    {
        OnEraseBkgnd(hwnd, hdcPrint);
    }
#endif
    DC_END_FN();
}

//
// StaticPlainArcWndProc
// Params: see platform sdk for wndproc
//
// Delegates work to appropriate instance
//
//
LRESULT CALLBACK
CAutoReconnectPlainUI::StaticPlainArcWndProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    INT                     retVal = 0;
    CAutoReconnectPlainUI*  pUI;

    DC_BEGIN_FN("StaticPlainArcWndProc");

    pUI = (CAutoReconnectPlainUI*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if(WM_CREATE == uMsg)
    {
        //pull out the this pointer and stuff it in the window class
        LPCREATESTRUCT lpcs = (LPCREATESTRUCT) lParam;
        pUI = (CAutoReconnectPlainUI*)lpcs->lpCreateParams;

        SetWindowLongPtr( hwnd, GWLP_USERDATA, (LONG_PTR)pUI);
    }
    
    //
    // Delegate the message to the appropriate instance
    //

    if(pUI) {
        return pUI->WndProc(hwnd, uMsg, wParam, lParam);
    }
    else {
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

DC_EXIT_POINT:
    DC_END_FN();
    return retVal;
}

#define ARC_PLAIN_UI_TIMERID 1
#define ARC_ANIM_TIME        400
//
// Name: WndProc
//
// Purpose: Handles AutoReconnect dialog box proc
//
// Returns: TRUE if message dealt with
//          FALSE otherwise
//
// Params: See windows documentation
//
//
LRESULT CALLBACK CAutoReconnectPlainUI::WndProc(HWND hwnd,
                                            UINT uMsg,
                                            WPARAM wParam,
                                            LPARAM lParam)
{
    INT_PTR rc = FALSE;
    DC_BEGIN_FN("DialogBoxProc");

    switch (uMsg)
    {
        case WM_CREATE:
        {
            _nFlashingTimer = SetTimer(hwnd, ARC_PLAIN_UI_TIMERID,
                                       ARC_ANIM_TIME,
                                       NULL
                                       );
            if (_nFlashingTimer) {
                SetFocus(hwnd);
            }
            else {
                TRC_ERR((TB,_T("SetTimer failed - 0x%x"),
                         GetLastError()));
                rc = -1;
            }
        }
        break;


        case WM_DESTROY:
        {
            if (_nFlashingTimer) {
                KillTimer(hwnd, _nFlashingTimer);
                _nFlashingTimer = 0;
            }
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)NULL);
        }
        break;


        case WM_TIMER:
        {
            //
            // DO animation stuff
            //
            OnAnimFlashTimer();
        }
        break;

        case WM_ERASEBKGND:
        {
            OnEraseBkgnd(hwnd, (HDC)wParam);
            rc = 1;
        }
        break;

        case WM_KEYUP:
        {
            if (VK_ESCAPE == wParam) {
                TRC_NRM((TB,_T("ARC ESC pressed, disconnect")));
                _pUi->UI_UserInitiatedDisconnect(_lastDiscReason);
                _fContinueReconAttempts = FALSE;
            }
        }
        break;

        case WM_SETFOCUS:
        {
            TRC_NRM((TB,_T("Setfocus to arc")));
        }
        break;

        case WM_KILLFOCUS:
        {
            TRC_NRM((TB,_T("killfocus to arc: 0x%x 0x%x"), wParam, lParam));
        }
        break;


#ifndef OS_WINCE
        case WM_PRINTCLIENT:
        {
            OnPrintClient(hwnd, (HDC)wParam, (DWORD)lParam);
            rc = 1;
        }
        break;
#endif

        default:
        {
            return DefWindowProc( hwnd, uMsg, wParam, lParam);
        }
        break;
    }

    DC_END_FN();

    return(rc);

} /* DialogBoxProc */


VOID
CAutoReconnectPlainUI::OnAnimFlashTimer()
{
    //
    // Toggle UI hide state
    //
    _fIsUiVisible = !_fIsUiVisible;
    ShowWindow(_hwnd, _fIsUiVisible ? SW_SHOWNORMAL : SW_HIDE);
}

//
// Called to notify us that we got disconnected
// this means the last connection attempt failed
//
// Params:
//      discReason   - disconnect major reason code
//      attemptCount - attempt count so far
//      pfContinueArc - [OUT] set to FALSE to stop ARC
//
VOID
CAutoReconnectPlainUI::OnNotifyAutoReconnecting(
        UINT  discReason,
        ULONG attemptCount,
        ULONG maxAttemptCount,
        BOOL* pfContinueArc
        )
{
    DC_BEGIN_FN("OnNotifyDisconnected");

    _lastDiscReason = discReason;

    if (!_fContinueReconAttempts) {
        TRC_NRM((TB,_T("Stopping arc - _fContinueReconAttempts is FALSE")));
    }

    *pfContinueArc = _fContinueReconAttempts;

    DC_END_FN();
}

//
// Called to notify us that we have connected
//
VOID CAutoReconnectPlainUI::OnNotifyConnected()
{
    DC_BEGIN_FN("OnNotifyConnected");

    _fContinueReconAttempts = FALSE;

    DC_END_FN();
}

//
// Destory
// Called to kill and cleanup the dialog
// 
//
BOOL
CAutoReconnectPlainUI::Destroy()
{
    DC_BEGIN_FN("Destroy");

    if (!DestroyWindow(_hwnd)) {
        TRC_ERR((TB,_T("DestroyWindow failed: 0x%x"),
                GetLastError()));
    }

    DC_END_FN();
    return TRUE;
}

//
// Load a bitmap from memory
//
// Params:
//   pbBitmapBits - pointer to bitmap bits (e.g. can pass in file mapping
//                  to a BMP file).
//
//   cbLen        - length of pbBitmapBits
//
// Returns:
//   HBITMAP      - handle to the bitmap
//
HBITMAP
CAutoReconnectPlainUI::LoadImageFromMemory(
                            HDC hdc,
                            LPBYTE pbBitmapBits,
                            ULONG cbLen
                            )
{
    HRESULT hr;
    HBITMAP hbmp = NULL;
    LPBITMAPINFO pbmi = NULL;
    ULONG   cbBmiLen = 0;
    PBYTE   pBitmapBits = NULL;
    ULONG   cbBitmapBits = 0;

    hr = LoadImageBits(
            pbBitmapBits,
            cbLen,
            &pbmi,
            &cbBmiLen,
            &pBitmapBits,
            &cbBitmapBits
            );
    if (SUCCEEDED(hr)) {

        hbmp = CreateDIBitmap(hdc,
                              &pbmi->bmiHeader,
                              CBM_INIT,
                              pBitmapBits,
                              pbmi,
                              DIB_RGB_COLORS
                              );

        delete pBitmapBits;
        delete pbmi;
    }

    return hbmp;
}


#define BMP_24_BITSPERPIXEL 24
#define BMP_16_BITSPERPIXEL 16
#define BMP_32_BITSPERPIXEL 32

//
// Worker function for image load, caller frees outparam bits
//
HRESULT
CAutoReconnectPlainUI::LoadImageBits(
                            LPBYTE pbBitmapBits, ULONG cbLen,
                            LPBITMAPINFO* ppBitmapInfo, PULONG pcbBitmapInfo,
                            LPBYTE* ppBits, PULONG pcbBits
                            )
{
    HRESULT          hr = ResultFromScode(S_OK);
    BITMAPFILEHEADER bmfh;
    BITMAPCOREHEADER *pbch;
    BITMAPINFOHEADER bih;
    LPBYTE           pbStart;
    ULONG            cbi = 0;
    ULONG            cbData;
    LPBITMAPINFO     pbi = NULL;
    LPBYTE           pbData = NULL;
    DWORD            dwSizeOfHeader;

    //
    // Record the starting position
    //

    pbStart = pbBitmapBits;

    //
    // First validate the buffer for size
    //

    if (cbLen < sizeof(BITMAPFILEHEADER))
    {
         return(ResultFromScode(E_FAIL));
    }

    //
    // Now get the bitmap file header
    //
    memcpy(&bmfh, pbBitmapBits, sizeof(BITMAPFILEHEADER));

    //
    // Validate the header
    //

    if (!(bmfh.bfType == 0x4d42) && (bmfh.bfOffBits <= cbLen))
    {
         return E_FAIL;
    }

    //
    // Get the next 4 bytes which will represent the size of the
    // next structure and allow us to determine the type
    //

    if (SUCCEEDED(hr))
    {
         pbBitmapBits += sizeof(BITMAPFILEHEADER);
         memcpy(&dwSizeOfHeader, pbBitmapBits, sizeof(DWORD));

         if (dwSizeOfHeader == sizeof(BITMAPCOREHEADER))
         {
              pbch = (BITMAPCOREHEADER *)pbBitmapBits;
              memset(&bih, 0, sizeof(BITMAPINFOHEADER));

              bih.biSize = sizeof(BITMAPINFOHEADER);
              bih.biWidth = pbch->bcWidth;
              bih.biHeight = pbch->bcHeight;
              bih.biPlanes = pbch->bcPlanes;
              bih.biBitCount = pbch->bcBitCount;

              pbBitmapBits += sizeof(BITMAPCOREHEADER);
         }
         else if (dwSizeOfHeader == sizeof(BITMAPINFOHEADER))
         {
              memcpy(&bih, pbBitmapBits, sizeof(BITMAPINFOHEADER));

              pbBitmapBits += sizeof(BITMAPINFOHEADER);
         }
         else
         {
              hr = ResultFromScode(E_FAIL);
         }
    }

    //
    // Check if biClrUsed is set since we do not handle that
    // case at this time
    //

    if (SUCCEEDED(hr))
    {
         if (bih.biClrUsed != 0)
         {
              hr = ResultFromScode(E_FAIL);
         }
    }

    //
    // Now we need to calculate the size of the BITMAPINFO we need
    // to allocate including any palette information
    //

    if (SUCCEEDED(hr))
    {
         //
         // First the size of the header
         //

         cbi = sizeof(BITMAPINFOHEADER);

         //
         // Now the palette
         //

         if (bih.biBitCount == BMP_24_BITSPERPIXEL)
         {
              //
              // Just add on the 1 RGBQUAD for the structure but
              // there is no palette
              //

              cbi += sizeof(RGBQUAD);
         }
         else if ((bih.biBitCount == BMP_16_BITSPERPIXEL) ||
                  (bih.biBitCount == BMP_32_BITSPERPIXEL))
         {
              //
              // Add on the 3 DWORD masks which are used to
              // get the colors out of the data
              //

              cbi += (3 * sizeof(DWORD));
         }
         else
         {
              //
              // Anything else we just use the bit count to calculate
              // the number of entries
              //

              cbi += ((1 << bih.biBitCount) * sizeof(RGBQUAD));
         }

         //
         // Now allocate the BITMAPINFO
         //

         pbi = (LPBITMAPINFO) new BYTE [cbi];
         if (pbi == NULL)
         {
              hr = ResultFromScode(E_OUTOFMEMORY);
         }
    }

    //
    // Fill in the BITMAPINFO data structure and get the bits
    //

    if (SUCCEEDED(hr))
    {
         //
         // First copy the header data
         //

         memcpy(&(pbi->bmiHeader), &bih, sizeof(BITMAPINFOHEADER));

         //
         // Now the palette data
         //

         if (bih.biBitCount == BMP_24_BITSPERPIXEL)
         {
              //
              // No palette data to copy
              //
         }
         else if ((bih.biBitCount == BMP_16_BITSPERPIXEL) ||
                  (bih.biBitCount == BMP_32_BITSPERPIXEL))
         {
              //
              // Copy the 3 DWORD masks
              //

              memcpy(&(pbi->bmiColors), pbBitmapBits, 3*sizeof(DWORD));
         }
         else
         {
              //
              // If we were a BITMAPCOREHEADER type then we have our
              // palette data in the form of RGBTRIPLEs so we must
              // explicitly copy each.  Otherwise we can just memcpy
              // the RGBQUADs
              //

              if (dwSizeOfHeader == sizeof(BITMAPCOREHEADER))
              {
                   ULONG     cPalEntry = (1 << bih.biBitCount);
                   ULONG     cCount;
                   RGBTRIPLE *argbt = (RGBTRIPLE *)pbBitmapBits;

                   for (cCount = 0; cCount < cPalEntry; cCount++)
                   {
                        pbi->bmiColors[cCount].rgbRed =
                                           argbt[cCount].rgbtRed;
                        pbi->bmiColors[cCount].rgbGreen =
                                           argbt[cCount].rgbtGreen;
                        pbi->bmiColors[cCount].rgbBlue =
                                           argbt[cCount].rgbtBlue;

                        pbi->bmiColors[cCount].rgbReserved = 0;
                   }
              }
              else
              {
                   ULONG cbPalette = (1 << bih.biBitCount) * sizeof(RGBQUAD);

                   memcpy(&(pbi->bmiColors), pbBitmapBits, cbPalette);
              }
         }

         //
         // Now find out where the bits are
         //

         pbBitmapBits = pbStart + bmfh.bfOffBits;

         //
         // Get the size to copy
         //

         cbData = cbLen - bmfh.bfOffBits;

         //
         // Allocate the buffer to hold the bits
         //

         pbData = new BYTE [cbData];
         if (pbData == NULL)
         {
              hr = ResultFromScode(E_OUTOFMEMORY);
         }

         if (SUCCEEDED(hr))
         {
              memcpy(pbData, pbBitmapBits, cbData);
         }
    }

    //
    // If everything succeeded record the data
    //

    if (SUCCEEDED(hr))
    {
         //
         // Record the info
         //

         *pcbBitmapInfo = cbi;
         *ppBitmapInfo = pbi;

         //
         // Record the data
         //

         *ppBits = pbData;
         *pcbBits = cbData;
    }
    else
    {
         //
         // Cleanup
         //

         delete pbi;
         delete pbData;
    }

    return(hr);
}
#endif // ARC_MINIMAL_UI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\capienc.cpp ===
/****************************************************************************/
/* capienc.cpp                                                              */
/*                                                                          */
/* FIPS encrpt/decrypt                                                      */
/*                                                                          */
/* Copyright (C) 2002-2004 Microsoft Corporation                            */
/****************************************************************************/



#include <adcg.h>

extern "C" {
#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "capienc"
#include <atrcapi.h>
}

#include "capienc.h"
#include "sl.h"

#define TERMSRV_NAME    L"terminal_server_client"

const BYTE DESParityTable[] = {0x00,0x01,0x01,0x02,0x01,0x02,0x02,0x03,
                      0x01,0x02,0x02,0x03,0x02,0x03,0x03,0x04};
// IV for all block ciphers
BYTE rgbIV[] = {0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF};


//
// Name:        PrintData
//
// Purpose:     Print out the data in debugger
//
// Returns:     No
//
// Params:      IN      pKeyData: point to the data to be printed
//              IN      cbSize: the size of the key

void PrintData(BYTE *pKeyData, DWORD cbSize)
{
    DWORD dwIndex;
    TCHAR Buffer[128];
    
    for( dwIndex = 0; dwIndex<cbSize; dwIndex++ ) {

        StringCchPrintf(Buffer, 128, TEXT("0x%x "), pKeyData[dwIndex]);
        OutputDebugString(Buffer);
        if( dwIndex > 0 && (dwIndex+1) % 8 == 0 )
            OutputDebugString((TEXT("\n")));
    }
}



//
// Name:        Is_WinXP_or_Later
//
// Purpose:     Tell if the OS is WinXP or later
//
// Returns:     TRUE if it's WinXP or later
//
// Params:      No

BOOL Is_WinXP_or_Later () 
{
    OSVERSIONINFO osvi;
    BOOL bIsWinXPorLater = FALSE;

    ZeroMemory(&osvi, sizeof(OSVERSIONINFO));

    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&osvi)) {
        bIsWinXPorLater = ((osvi.dwMajorVersion >= 5) && (osvi.dwMinorVersion >= 1));
    }
    return bIsWinXPorLater;
}


//
// Name:        Mydesparityonkey
//
// Purpose:     Set the parity on the DES key to be odd
//
// Returns:     No
//
// Params:      IN/OUT  pbKey: point to the key
//              IN      cbKey: the size of the key

void Mydesparityonkey(
        BYTE *pbKey,
        DWORD cbKey
        )
{
    DWORD i;

    for (i=0;i<cbKey;i++)
    {
        if (!((DESParityTable[pbKey[i]>>4] + DESParityTable[pbKey[i]&0x0F]) % 2))
            pbKey[i] = pbKey[i] ^ 0x01;
    }
}



//
// Name:        Expandkey
//
// Purpose:     Expand a 21-byte 3DES key to a 24-byte 3DES key (including parity bit)
//              by inserting a parity bit after every 7 bits in the 21-byte DES
//
// Returns:     No
//
// Params:      IN/OUT  pbKey: point to the key
//              

#define PARITY_UNIT 7
void Expandkey(
        BYTE *pbKey
        )
{
    BYTE pbTemp[DES3_KEYLEN];
    DWORD i, dwCount;
    UINT16 shortTemp;
    BYTE *pbIn, *pbOut;

    memcpy(pbTemp, pbKey, sizeof(pbTemp));
    dwCount = (DES3_KEYLEN * 8) / PARITY_UNIT;

    pbOut = pbKey;
    for (i=0; i<dwCount; i++) {
        pbIn = ((pbTemp + (PARITY_UNIT * i) / 8));
        //shortTemp = *(pbIn + 1);
        shortTemp = *pbIn + (((UINT16)*(pbIn + 1)) << 8);
        shortTemp = shortTemp >> ((PARITY_UNIT * i) % 8);
        //shortTemp = (*(unsigned short *)((pbTemp + (PARITY_UNIT * i) / 8))) >> ((PARITY_UNIT * i) % 8);
        *pbOut = (BYTE)(shortTemp & 0x7F);
        pbOut++;
    }
}



// Name:        HashData
//
// Purpose:     Hash the data using SHA.
//
// Returns:     TRUE if succeeded
//
// Params:      IN      pCapiFunctionTable: CAPI function table
//              IN      hProv: Handle of the cript provider
//              IN      pbData: point to the data to be hashed
//              IN      dwDataLen: the size of the data to be hashed
//              OUT     phHash: point to the hash

BOOL HashData(PCAPI_FUNCTION_TABLE pCapiFunctionTable, HCRYPTPROV hProv, PBYTE pbData, DWORD dwDataLen, HCRYPTHASH* phHash)
{
    BOOL rc = FALSE;

    DC_BEGIN_FN("HashData");

    //
    // Create a hash object.
    //
    if(!pCapiFunctionTable->pfnCryptCreateHash(hProv, CALG_SHA1, 0, 0, phHash)) {
        TRC_ERR((TB, _T("Error %x during CryptCreateHash!\n"), GetLastError()));
        goto done;
    }

    //
    // Hash in the data.
    //
    if(!pCapiFunctionTable->pfnCryptHashData(*phHash, pbData, dwDataLen, 0)) {
        TRC_ERR((TB, _T("Error %x during CryptHashData!\n"), GetLastError()));
        goto done;
    }
    rc = TRUE;
done:  
    DC_END_FN();
    return rc;
}



// Name:        HashDataEx
//
// Purpose:     Hash 2 set of data using SHA.
//
// Returns:     TRUE if succeeded
//
// Params:      IN      pCapiFunctionTable: CAPI function table
//              IN      hProv: Handle of the cript provider
//              IN      pbData: point to the data to be hashed
//              IN      dwDataLen: the size of the data to be hashed
//              IN      pbData2: point to the data to be hashed
//              IN      dwDataLen2: the size of the data to be hashed
//              OUT     phHash: point to the hash

BOOL HashDataEx(PCAPI_FUNCTION_TABLE pCapiFunctionTable, HCRYPTPROV hProv, PBYTE pbData, DWORD dwDataLen, 
              PBYTE pbData2, DWORD dwDataLen2, HCRYPTHASH* phHash)
{
    BOOL rc = FALSE;

    DC_BEGIN_FN("HashDataEx");

    //
    // Create a hash object.
    //
    if(!pCapiFunctionTable->pfnCryptCreateHash(hProv, CALG_SHA1, 0, 0, phHash)) {
        printf("Error %x during CryptCreateHash!\n", GetLastError());
        goto done;
    }

    //
    // Hash in the data.
    //
    if(!pCapiFunctionTable->pfnCryptHashData(*phHash, pbData, dwDataLen, 0)) {
        printf("Error %x during CryptHashData!\n", GetLastError());
        goto done;
    }
    if(!pCapiFunctionTable->pfnCryptHashData(*phHash, pbData2, dwDataLen2, 0)) {
        printf("Error %x during CryptHashData!\n", GetLastError());
        goto done;
    }
    rc = TRUE;
done:
    DC_END_FN();

    return rc;
}


// Name:        HmacHashData
//
// Purpose:     Hash the data using HmacSHA.
//
// Returns:     TRUE if succeeded
//
// Params:      IN      pCapiFunctionTable: CAPI function table
//              IN      hProv: Handle of the cript provider
//              IN      pbData: point to the data to be hashed
//              IN      dwDataLen: the size of the data to be hashed
//              IN      hKey: handle to the key
//              OUT     phHash: point to the hash

BOOL HmacHashData(PCAPI_FUNCTION_TABLE pCapiFunctionTable, HCRYPTPROV hProv, PBYTE pbData, DWORD dwDataLen,
                  HCRYPTKEY hKey, HCRYPTHASH* phHash)
{
    BOOL rc = FALSE;
    BYTE  bmacinfo[sizeof(HMAC_INFO)];
    HMAC_INFO* pmac;
    memset(bmacinfo, 0, sizeof(bmacinfo));
    
    pmac = (HMAC_INFO*)bmacinfo;
    pmac->HashAlgid = CALG_SHA1;

    DC_BEGIN_FN("HmacHashData");

    //
    // Create a hash object.
    //
    if(!pCapiFunctionTable->pfnCryptCreateHash(hProv, CALG_HMAC, hKey, 0, phHash)) {
        TRC_ERR((TB, _T("Error %x during CryptCreateHash!\n"), GetLastError()));
        goto done;
    }

    rc = pCapiFunctionTable->pfnCryptSetHashParam(*phHash, HP_HMAC_INFO, bmacinfo, 0);

    //
    // Hash in the data.
    //
    if(!pCapiFunctionTable->pfnCryptHashData(*phHash, pbData, dwDataLen, 0)) {
        TRC_ERR((TB, _T("Error %x during CryptHashData!\n"), GetLastError()));
        goto done;
    }
    rc = TRUE;
done:
    DC_END_FN();

    return rc;
}



// Name:        HmacHashDataEx
//
// Purpose:     Hash 2 set of data using HmacSHA.
//
// Returns:     TRUE if succeeded
//
// Params:      IN      pCapiFunctionTable: CAPI function table
//              IN      hProv: Handle of the cript provider
//              IN      pbData: point to the data to be hashed
//              IN      dwDataLen: the size of the data to be hashed
//              IN      pbData2: point to the data to be hashed
//              IN      dwDataLen2: the size of the data to be hashed
//              IN      hKey: handle to the key
//              OUT     phHash: point to the hash

BOOL HmacHashDataEx(PCAPI_FUNCTION_TABLE pCapiFunctionTable, HCRYPTPROV hProv, PBYTE pbData, DWORD dwDataLen,
                  PBYTE pbData2, DWORD dwDataLen2, HCRYPTKEY hKey, HCRYPTHASH* phHash)
{
    BOOL rc = FALSE;
    BYTE  bmacinfo[sizeof(HMAC_INFO)];
    HMAC_INFO* pmac;
    memset(bmacinfo, 0, sizeof(bmacinfo));
    
    pmac = (HMAC_INFO*)bmacinfo;
    pmac->HashAlgid = CALG_SHA1;

    DC_BEGIN_FN("HmacHashDataEx");

    //
    // Create a hash object.
    //
    if(!pCapiFunctionTable->pfnCryptCreateHash(hProv, CALG_HMAC, hKey, 0, phHash)) {
        TRC_ERR((TB, _T("Error %x during CryptCreateHash!\n"), GetLastError()));
        goto done;
    }

    rc = pCapiFunctionTable->pfnCryptSetHashParam(*phHash, HP_HMAC_INFO, bmacinfo, 0);

    //
    // Hash in the data.
    //
    if(!pCapiFunctionTable->pfnCryptHashData(*phHash, pbData, dwDataLen, 0)) {
        TRC_ERR((TB, _T("Error %x during CryptHashData!\n"), GetLastError()));
        goto done;
    }

    if(!pCapiFunctionTable->pfnCryptHashData(*phHash, pbData2, dwDataLen2, 0)) {
        TRC_ERR((TB, _T("Error %x during CryptHashData!\n"), GetLastError()));
        goto done;
    }
    rc = TRUE;
done:
    DC_END_FN();

    return rc;
}




// Name:        DumpHashes
//
// Purpose:     Get the hash bits from hash handle
//
// Returns:     TRUE if succeeded
//
// Params:      IN      pCapiFunctionTable: CAPI function table
//              IN      phHash: point to hash handle
//              OUT     pbBytes: point data buffer to get hash
//              IN      dwTotal: len of the data buffer

BOOL DumpHashes(PCAPI_FUNCTION_TABLE pCapiFunctionTable, HCRYPTHASH* phHash, PBYTE pbBytes, DWORD dwTotal)
{    
    BOOL rc = FALSE;

    DC_BEGIN_FN("DumpHashes");

    if (!pCapiFunctionTable->pfnCryptGetHashParam(*phHash, HP_HASHVAL, pbBytes, &dwTotal , 0)) {
        TRC_ERR((TB, _T("Error %x during CryptGetHashParam!\n"), GetLastError()));
        goto done;
    }

    //
    //destroy the hash, we don't need it anymore
    //
    if(*phHash)  {
        pCapiFunctionTable->pfnCryptDestroyHash(*phHash);
        *phHash = 0;
    }
    
    rc = TRUE;
done: 
    DC_END_FN();
    return rc;
}


// Name:        TSCAPI_Init
//
// Purpose:     Initialize the CAPI function table.
//
// Returns:     TRUE  - succeeded                                  
//              FALSE - failed
//
// Params:      IN      pCapiData: CAPI data

BOOL TSCAPI_Init(PCAPIData pCapiData)
{
    BOOL rc = FALSE;

    // FIPS is only available on WinXP and later
    if (!Is_WinXP_or_Later()) {
        goto done;
    }

    pCapiData->hAdvapi32 = LoadLibrary(L"advapi32.dll");

    if (pCapiData->hAdvapi32 == NULL) {
        goto done;
    }

    if ((pCapiData->CapiFunctionTable.pfnCryptAcquireContext = (CRYPTACQUIRECONTEXT *)GetProcAddress(
            pCapiData->hAdvapi32, "CryptAcquireContextW")) == NULL) {
        goto done;
    }
    if ((pCapiData->CapiFunctionTable.pfnCryptReleaseContext = (CRYPTRELEASECONTEXT *)GetProcAddress(
            pCapiData->hAdvapi32, "CryptReleaseContext")) == NULL) {
        goto done;
    }
    if ((pCapiData->CapiFunctionTable.pfnCryptGenRandom = (CRYPTGENRANDOM *)GetProcAddress(
            pCapiData->hAdvapi32, "CryptGenRandom")) == NULL) {
        goto done;
    }
    if ((pCapiData->CapiFunctionTable.pfnCryptEncrypt = (CRYPTENCRYPT *)GetProcAddress(
            pCapiData->hAdvapi32, "CryptEncrypt")) == NULL) {
        goto done;
    }
    if ((pCapiData->CapiFunctionTable.pfnCryptDecrypt = (CRYPTDECRYPT *)GetProcAddress(
            pCapiData->hAdvapi32, "CryptDecrypt")) == NULL) {
        goto done;
    }
    if ((pCapiData->CapiFunctionTable.pfnCryptImportKey = (CRYPTIMPORTKEY *)GetProcAddress(
            pCapiData->hAdvapi32, "CryptImportKey")) == NULL) {
        goto done;
    }
    if ((pCapiData->CapiFunctionTable.pfnCryptSetKeyParam = (CRYPTSETKEYPARAM *)GetProcAddress(
            pCapiData->hAdvapi32, "CryptSetKeyParam")) == NULL) {
        goto done;
    }
    if ((pCapiData->CapiFunctionTable.pfnCryptDestroyKey = (CRYPTDESTROYKEY *)GetProcAddress(
            pCapiData->hAdvapi32, "CryptDestroyKey")) == NULL) {
        goto done;
    }
    if ((pCapiData->CapiFunctionTable.pfnCryptCreateHash = (CRYPTCREATEHASH *)GetProcAddress(
            pCapiData->hAdvapi32, "CryptCreateHash")) == NULL) {
        goto done;
    }
    if ((pCapiData->CapiFunctionTable.pfnCryptHashData = (CRYPTHASHDATA *)GetProcAddress(
            pCapiData->hAdvapi32, "CryptHashData")) == NULL) {
        goto done;
    }
    if ((pCapiData->CapiFunctionTable.pfnCryptSetHashParam = (CRYPTSETHASHPARAM *)GetProcAddress(
            pCapiData->hAdvapi32, "CryptSetHashParam")) == NULL) {
        goto done;
    }
    if ((pCapiData->CapiFunctionTable.pfnCryptGetHashParam = (CRYPTGETHASHPARAM *)GetProcAddress(
            pCapiData->hAdvapi32, "CryptGetHashParam")) == NULL) {
        goto done;
    }
    if ((pCapiData->CapiFunctionTable.pfnCryptDestroyHash = (CRYPTDESTROYHASH *)GetProcAddress(
            pCapiData->hAdvapi32, "CryptDestroyHash")) == NULL) {
        goto done;
    }
 
   
    rc = TRUE;
done:
    return rc;
}


// Name:        TSCAPI_Enable
//
// Purpose:     Some CAPI initialization
//
// Returns:     TRUE  - succeeded                                  
//              FALSE - failed
//
// Params:      IN      pCapiData: CAPI data

BOOL TSCAPI_Enable(PCAPIData pCapiData)
{
    BOOL rc = FALSE;
    DWORD Error;
    DWORD dwExtraFlags = 0;
    HRESULT hr;

    DC_BEGIN_FN("TSCAPI_Enable");

    // Get handle to the default provider.
    if(!pCapiData->CapiFunctionTable.pfnCryptAcquireContext(&(pCapiData->hProv), 
                                   TERMSRV_NAME, MS_ENHANCED_PROV, PROV_RSA_FULL, dwExtraFlags)) {
        
        // Could not acquire a crypt context, get the reason of failure
        Error = GetLastError();
        hr = HRESULT_FROM_WIN32(Error);

        if (hr == NTE_BAD_KEYSET) {
            //
            //create a new keyset
            //
            if(!pCapiData->CapiFunctionTable.pfnCryptAcquireContext(&(pCapiData->hProv), TERMSRV_NAME, 
                                         MS_ENHANCED_PROV, PROV_RSA_FULL, dwExtraFlags | CRYPT_NEWKEYSET)) {
                Error = GetLastError();
                TRC_ERR((TB, _T("Error %x during CryptAcquireContext!\n"), GetLastError()));
                goto done;
            }
        }
        else {
            goto done;
        }
    }  
    rc = TRUE; 
done: 
    DC_END_FN();
    return rc;
}



// Name:        TSCAPI_Term
//
// Purpose:     Terminate the CAPI .
//
// Returns:     TRUE if succeeded                                
//             
//
// Params:      IN      pCapiData: CAPI data

BOOL TSCAPI_Term(PCAPIData pCapiData)
{
    BOOL rc = TRUE;

    DC_BEGIN_FN("TSCAPI_Enable");

    if (pCapiData->hEncKey) {
        rc = pCapiData->CapiFunctionTable.pfnCryptDestroyKey(pCapiData->hEncKey);
        pCapiData->hEncKey = NULL;
    }

    if (pCapiData->hDecKey) {
        rc = pCapiData->CapiFunctionTable.pfnCryptDestroyKey(pCapiData->hDecKey);
        pCapiData->hDecKey = NULL;
    }
    
    if (pCapiData->hProv) {
        rc = pCapiData->CapiFunctionTable.pfnCryptReleaseContext(pCapiData->hProv, 0);
        pCapiData->hProv = NULL;
    }

    DC_END_FN();

    return rc;
}


// Name:        TSCAPI_GenerateRandomNumber
//
// Purpose:     Generates random number using CAPI in user mode
//
// Returns:     TRUE if succeeded                                
//             
//
// Params:      IN      pCapiData: CAPI data
//              OUT     pbRandomBits: pointer to a buffer where a random key is returned.
//              IN      cbLen: length of the random key required.

BOOL TSCAPI_GenerateRandomNumber(
            PCAPIData pCapiData,
            LPBYTE pbRandomBits,
            DWORD cbLen)
{
    BOOL rc = FALSE;

    DC_BEGIN_FN("TSCAPI_GenerateRandomNumber");

    if (pCapiData->CapiFunctionTable.pfnCryptGenRandom(pCapiData->hProv, cbLen, pbRandomBits)) {
        rc = TRUE;
    }
done:
    DC_END_FN();

    return rc;
}




// Name:        ImportKey
//
// Purpose:     Import the key in bits to crypt provider
//
// Returns:     TRUE if succeeded                                
//             
//
// Params:      IN      pCapiData: CAPI data
//              IN      hProv: handle to the crypt provider
//              IN      Algid: Algorithm identifier
//              IN      pbKey: point to the buffer contain the key bits
//              IN      dwKeyLen: length of the key.
//              IN      dwFlags: dwFlags used in CryptImportKey
//              OUT     phKey: point to the key handle

BOOL ImportKey(PCAPI_FUNCTION_TABLE pCapiFunctionTable, HCRYPTPROV hProv, ALG_ID Algid, PBYTE pbKey, DWORD dwKeyLen, DWORD dwFlags, HCRYPTKEY* phKey)
{
    BOOL rc = FALSE;
    PBYTE pbData = NULL;
    DWORD cbLen = 0;
    DWORD Error;
    //
    //create blob header first
    //
    BLOBHEADER blobHead;
    blobHead.bType = PLAINTEXTKEYBLOB;
    blobHead.bVersion = 2;
    blobHead.reserved = 0;
    blobHead.aiKeyAlg = Algid;

    DC_BEGIN_FN("ImportKey");

    //
    //calculate the length
    //
    cbLen = sizeof(blobHead) + sizeof(dwKeyLen) + dwKeyLen;

    pbData = (PBYTE)LocalAlloc(LPTR, cbLen);
    
    if(NULL == pbData) {
        TRC_ERR((TB, _T("Out of memory\n")));
        goto done;
    }

    //
    //copy data. First data must be header, then the size of the key, then the key
    //
    memcpy( pbData, &blobHead, sizeof(blobHead));
    memcpy( pbData + sizeof(blobHead), &dwKeyLen, sizeof(dwKeyLen));
    memcpy( pbData + sizeof(blobHead) + sizeof(dwKeyLen), pbKey, dwKeyLen);

    if( !pCapiFunctionTable->pfnCryptImportKey( hProv, pbData, cbLen, 0, dwFlags, phKey)) {
        Error = GetLastError();
        TRC_ERR((TB, _T("Failed to import plaint text key Error = 0x%x\n"), Error));
        *phKey = 0;
        goto done;
    }

    rc = TRUE;
done:
    DC_END_FN();

    if(pbData) {
        LocalFree(pbData);
    }
    return rc;
}




// Name:        TSCAPI_DeriveKey
//
// Purpose:     Derive the key from the hash.
//
// Returns:     TRUE if succeeded
//
// Params:      IN      pCapiFunctionTable: CAPI function table
//              IN      hProv: crypt provider handle
//              OUT     phKey: point to key handle
//              IN      rgbSHABase: base data used to derive the key
//              IN      cbSHABase: size of the base data
//              OUT     pbKey: point to the derived DESkey
//              OUT     pdwKeyLen: point to the key length

BOOL TSCAPI_DeriveKey(
            PCAPI_FUNCTION_TABLE pCapiFunctionTable,
            HCRYPTPROV hProv,
            HCRYPTKEY *phKey,
            BYTE *rgbSHABase,
            DWORD cbSHABase,
            BYTE *pbKey,
            DWORD *pdwKeyLen)
{
    BOOL rc = FALSE;
    BOOL fRet = FALSE;
    BYTE rgb3DESKey[MAX_FIPS_SESSION_KEY_SIZE];
    
    DC_BEGIN_FN("TSCAPI_DeriveKey");

    //
    //Generate the key as follows
    //1. Hash the secret.  Call the result H1 (rgbSHABase in our case)
    //2. Use 1st 21 bytes of [H1|H1] as the 3DES key
    //3. Expand the 21-byte 3DES key to a 24-byte 3DES key (including parity bit), which
    //      will be used by CryptAPI
    //4. Set the parity on the 3DES key to be odd

    //
    //Step 2 - [H1|H1]
    //
    
    memcpy(rgb3DESKey, rgbSHABase, cbSHABase);
    memcpy(rgb3DESKey + cbSHABase, rgbSHABase, DES3_KEYLEN - cbSHABase);

    //
    //Step 3 - Expand the key
    //

    Expandkey(rgb3DESKey);

    //
    //Step 4 - Set parity
    //

    Mydesparityonkey(rgb3DESKey, sizeof(rgb3DESKey));

    //
    //import the key as PLAINTEXT into the csp
    //
    rc = ImportKey(pCapiFunctionTable, hProv, CALG_3DES, rgb3DESKey, sizeof(rgb3DESKey), 0, phKey);
    if (!rc) {
        goto done;
    }

    //give the key to the caller
    //
    memcpy(pbKey, rgb3DESKey, sizeof(rgb3DESKey));
    *pdwKeyLen = sizeof(rgb3DESKey);

    rc = TRUE;
done:
    DC_END_FN();

    return rc;
}



// Name:        TSCAPI_MakeSessionKeys
//
// Purpose:     Make the key from client/server random numbers
//
// Returns:     TRUE if succeeded
//
// Params:      IN      pCapiData: CAPI Data
//              IN      pKeyPair: Randow numbers used to generate key
//              IN      pEnumMethod: To generate Encrypt or Decrypt key, If NULL, both keys

BOOL TSCAPI_MakeSessionKeys(
            PCAPIData pCapiData,
            RANDOM_KEYS_PAIR *pKeyPair,
            CryptMethod *pEnumMethod)
{
    BOOL rc = FALSE;
    HCRYPTHASH  hHash;
    DWORD dwKeyLen;
    BYTE rgbSHABase1[A_SHA_DIGEST_LEN];
    BYTE rgbSHABase2[A_SHA_DIGEST_LEN];

    DC_BEGIN_FN("TSCAPI_MakeSessionKeys");

    memset(rgbSHABase1, 0, sizeof(rgbSHABase1));
    memset(rgbSHABase2, 0, sizeof(rgbSHABase2));

    //
    // Client Encrypt/Server Decrypt key
    //
    if ((pEnumMethod == NULL) ||
        (*pEnumMethod == Encrypt)) {
        if (!pCapiData->CapiFunctionTable.pfnCryptCreateHash(pCapiData->hProv, CALG_SHA1, 0, 0, &hHash)) {
            TRC_ERR((TB, _T("CryptCreateHash failed with %u"), GetLastError()));
            goto done;
        }
        if (!pCapiData->CapiFunctionTable.pfnCryptHashData(hHash, pKeyPair->clientRandom + RANDOM_KEY_LENGTH/2, RANDOM_KEY_LENGTH/2, 0)) {
            TRC_ERR((TB, _T("CryptHashData failed with %u"), GetLastError()));
            goto done;
        }
        if (!pCapiData->CapiFunctionTable.pfnCryptHashData(hHash, pKeyPair->serverRandom + RANDOM_KEY_LENGTH/2, RANDOM_KEY_LENGTH/2, 0)) {
            TRC_ERR((TB, _T("CryptHashData failed with %u"), GetLastError()));
            goto done;
        }

        if (!DumpHashes(&(pCapiData->CapiFunctionTable), &hHash, rgbSHABase1, sizeof(rgbSHABase1))) {
            goto done;
        }
        dwKeyLen = sizeof(pCapiData->bEncKey);
        if (!TSCAPI_DeriveKey(&(pCapiData->CapiFunctionTable), pCapiData->hProv, &(pCapiData->hEncKey), rgbSHABase1,
                          sizeof(rgbSHABase1), pCapiData->bEncKey, &dwKeyLen)) {
            goto done;
        }

        //
        //set the IV
        //
        if(!pCapiData->CapiFunctionTable.pfnCryptSetKeyParam(pCapiData->hEncKey, KP_IV,  rgbIV, 0 )) {
             TRC_ERR((TB, _T("Error %x during CryptSetKeyParam!\n"), GetLastError()));
            goto done;
        }
    }

    //
    // Server Encrypt/Client Decrypt key
    //
    if ((pEnumMethod == NULL) ||
        (*pEnumMethod == Decrypt)) {
        if (!pCapiData->CapiFunctionTable.pfnCryptCreateHash(pCapiData->hProv, CALG_SHA1, 0, 0, &hHash)) {
            TRC_ERR((TB, _T("CryptCreateHash failed with %u"), GetLastError()));
            goto done;
        }
        if (!pCapiData->CapiFunctionTable.pfnCryptHashData(hHash, pKeyPair->clientRandom, RANDOM_KEY_LENGTH/2, 0)) {
            TRC_ERR((TB, _T("CryptHashData failed with %u"), GetLastError()));
            goto done;
        }
        if (!pCapiData->CapiFunctionTable.pfnCryptHashData(hHash, pKeyPair->serverRandom, RANDOM_KEY_LENGTH/2, 0)) {
            TRC_ERR((TB, _T("CryptHashData failed with %u"), GetLastError()));
            goto done;
        }

        if (!DumpHashes(&(pCapiData->CapiFunctionTable), &hHash, rgbSHABase2, sizeof(rgbSHABase2))) {
            goto done;
        }
        dwKeyLen = sizeof(pCapiData->bDecKey);
        if (!TSCAPI_DeriveKey(&(pCapiData->CapiFunctionTable), pCapiData->hProv, &(pCapiData->hDecKey), rgbSHABase2,
                          sizeof(rgbSHABase2), pCapiData->bDecKey, &dwKeyLen)) {
            goto done;
        }

        //
        //set the IV
        //
        if(!pCapiData->CapiFunctionTable.pfnCryptSetKeyParam(pCapiData->hDecKey, KP_IV,  rgbIV, 0 )) {
            TRC_ERR((TB, _T("Error %x during CryptSetKeyParam!\n"), GetLastError()));
            goto done;
        }
    }

    //
    // Get the signing key
    // The signing key is SHA(rgbSHABase2|rgbSHABase1)
    //
    if (pEnumMethod == NULL) {
        if (!HashDataEx(&(pCapiData->CapiFunctionTable), pCapiData->hProv, rgbSHABase2, sizeof(rgbSHABase2),
               rgbSHABase1, sizeof(rgbSHABase1), &hHash)) {
            goto done;
        }
        if (!DumpHashes(&(pCapiData->CapiFunctionTable), &hHash, pCapiData->bSignKey, sizeof(pCapiData->bSignKey))) {
            goto done;
        }
        rc = ImportKey(&(pCapiData->CapiFunctionTable), pCapiData->hProv, CALG_RC2, pCapiData->bSignKey, sizeof(pCapiData->bSignKey), CRYPT_IPSEC_HMAC_KEY, &(pCapiData->hSignKey));
        if (!rc) {
            goto done;
        }
    }
       
    rc = TRUE;
done:
    DC_END_FN();

    return rc;
}




// Name:        TSCAPI_AdjustDataLen
//
// Purpose:     In Block encryption mode, adjust the data len to multiple of blocks
//
// Returns:     Adjusted data length
//
// Params:      IN      dataLen: Data length needed to be encrypted

DCUINT TSCAPI_AdjustDataLen(DCUINT dataLen)
{ 
    return (dataLen - dataLen % FIPS_BLOCK_LEN + FIPS_BLOCK_LEN);
}



// Name:        TSCAPI_EncryptData
//
// Purpose:     Encrypt the data and compute the signature
//
// Returns:     No
//
// Params:      IN      pCapiData: CAPI Data
//              IN/OUT  pbData: pointer to the data buffer being encrypted, encrypted data is
//                          returned in the same buffer.
//              IN/OUT  pdwDataLen: data length to be encrypted, and returns encrypted data length
//              IN      dwPadLen: padding length in the data buffer
//              OUT     pbSignature: pointer to a signature buffer where the data signature is returned.
//              IN      dwEncryptionCount: running counter of all encryptions

BOOL TSCAPI_EncryptData(
        PCAPIData pCapiData,
        LPBYTE pbData,
        DWORD *pdwDataLen,
        DWORD dwBufLen,
        LPBYTE pbSignature,
        DWORD  dwEncryptionCount)
{
    BOOL rc = FALSE;
    DWORD Error;
    HCRYPTHASH  hHash;
    BYTE rgbSHA[A_SHA_DIGEST_LEN];
    BYTE pbHmac[A_SHA_DIGEST_LEN];
    DWORD dwTemp = dwBufLen;

    DC_BEGIN_FN("TSCAPI_EncryptData");

    // Compute signature
    if (!HmacHashDataEx(&(pCapiData->CapiFunctionTable), pCapiData->hProv, pbData, *pdwDataLen, (BYTE *)&dwEncryptionCount, 
                         sizeof(dwEncryptionCount), pCapiData->hSignKey, &hHash)) {
        goto done;
    }

    if (!DumpHashes(&(pCapiData->CapiFunctionTable), &hHash, pbHmac, sizeof(pbHmac))) {
        goto done;
    }
    // Take the 1st 8 bytes of Hmac as signature
    memcpy(pbSignature, pbHmac, MAX_SIGN_SIZE);

    rc = pCapiData->CapiFunctionTable.pfnCryptEncrypt(pCapiData->hEncKey,
                      NULL,                 //Hash
                      FALSE,                 //Final
                      0,
                      pbData,
                      &dwTemp,
                      dwBufLen);

    if (!rc) {
        TRC_ERR((TB, _T("Error %x during CryptEncrypt!\n"), GetLastError()));
        goto done;
    }

    rc = TRUE;
done:
    DC_END_FN();

    return rc;
}



// Name:        TSCAPI_DecryptData
//
// Purpose:     Decrypt the data and compare the signature
//
// Returns:     TRUE if successfully decrypted the data
//
// Params:      IN      PCAPIData: CAPI Data
//              IN/OUT  pbData: pointer to the data buffer being decrypted, decrypted data is
//                          returned in the same buffer.
//              IN      dwDataLen: data length to be decrypted
//              IN      dwPadLen: padding length in the data buffer
//              IN      pbSignature: pointer to a signature buffer
//              IN      dwDecryptionCount: running counter of all encryptions

BOOL TSCAPI_DecryptData(
            PCAPIData pCapiData,
            LPBYTE pbData,
            DWORD  dwDataLen,
            DWORD  dwPadLen,
            LPBYTE pbSignature,
            DWORD  dwDecryptionCount)
{
    BOOL rc = FALSE;
    DWORD dwLen = dwDataLen;
    DWORD Error;
    HCRYPTHASH  hHash;
    BYTE abSignature[A_SHA_DIGEST_LEN];
    BYTE rgbSHA[A_SHA_DIGEST_LEN];

    DC_BEGIN_FN("TSCAPI_DecryptData");

    // data length check
    if (dwDataLen <= dwPadLen) {
        TRC_ERR((TB, _T("Bad data length, padLen %d is larger than DataLen %d"),
                 dwPadLen, dwDataLen));
        goto done;
    }

    rc = pCapiData->CapiFunctionTable.pfnCryptDecrypt(pCapiData->hDecKey,
                      NULL,                 //Hash
                      FALSE,                 //Final
                      0,
                      pbData,
                      &dwLen);
    if (!rc) {
        TRC_ERR((TB, _T("Error %x during CryptDecrypt!\n"), GetLastError()));
        goto done;
    }

    // Compute signature
    if (!HmacHashDataEx(&(pCapiData->CapiFunctionTable), pCapiData->hProv, pbData, dwDataLen - dwPadLen, (BYTE *)&dwDecryptionCount, 
                       sizeof(dwDecryptionCount), pCapiData->hSignKey, &hHash)) {
        goto done;
    }

    if (!DumpHashes(&(pCapiData->CapiFunctionTable), &hHash, abSignature, sizeof(abSignature))) {
        goto done;
    }
    //
    // check to see the sigature match.
    //

    if(!memcmp(
            (LPBYTE)abSignature,
            pbSignature,
            MAX_SIGN_SIZE)) {
        rc = TRUE;;
    }
done:
    DC_END_FN();

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\bbar.h ===
//
// bbar.h: BBar drop down connection status bar
// Copyright Microsoft Corporation 1999-2000
//
//

#ifndef _BBAR_H_
#define	_BBAR_H_

#ifdef USE_BBAR
class CUI;

class CBBar
{
public:    
    typedef enum {
        bbarNotInit     = 0x0,
        bbarInitialized = 0x1,
        bbarLowering    = 0x2,
        bbarRaising     = 0x3,
        bbarLowered     = 0x4,
        bbarRaised      = 0x5
    } BBarState;

    CBBar(HWND hwndParent, HINSTANCE hInstance, CUI* pUi,
          BOOL fBBarEnabled);
    virtual ~CBBar();

    BOOL StartupBBar(int desktopX, int desktopY, BOOL fStartRaised);
    BOOL KillAndCleanupBBar();

    //
    // Kickoff the lower or raise animations
    //
    BOOL StartLowerBBar();
    BOOL StartRaiseBBar();

    VOID SetLocked(BOOL fLocked) {_fLocked = fLocked;}
    BOOL GetLockedState() {return _fLocked;}

    VOID SetEnabled(BOOL fEnabled) {_fBBarEnabled = fEnabled;}
    BOOL GetEnabled() {return _fBBarEnabled;}

    
    HWND        GetHwnd()       {return _hwndBBar;}
    HINSTANCE   GetInstance()   {return _hInstance;}
    BBarState   GetState()      {return _state;}
#ifdef DISABLE_SHADOW_IN_FULLSCREEN
    VOID        GetBBarLoweredAspect(RECT *rect)
    {
        rect->left = _rcBBarLoweredAspect.left;
        rect->top = _rcBBarLoweredAspect.top;
        rect->right = _rcBBarLoweredAspect.right;
        rect->bottom = _rcBBarLoweredAspect.bottom;
    }
#endif // DISABLE_SHADOW_IN_FULLSCREEN
    
    VOID        SetDisplayedText(LPTSTR szText);
    LPTSTR      GetDisplayedText() {return _szDisplayedText;}

    //
    // Notification from UI that the hotzone hover timer
    //
    VOID        OnBBarHotzoneFired();

    //
    // Fullscreen notifications
    //
    VOID        OnNotifyEnterFullScreen();
    VOID        OnNotifyLeaveFullScreen();

    // Syscolor change notification
    VOID        OnSysColorChange();

    BOOL        IsRaised()  {return _state == bbarRaised;}
    BOOL        IsLowered() {return _state == bbarLowered;}

    VOID        SetPinned(BOOL b)   {_fPinned = b;}
    BOOL        IsPinned()  {return _fPinned;}

    //
    // Button state props
    //
    VOID SetShowMinimize(BOOL fShowMinimize) {_fShowMinimize = fShowMinimize;}
    BOOL GetShowMinimize() {return _fShowMinimize;}

    VOID SetShowRestore(BOOL fShowRestore) {_fShowRestore = fShowRestore;}
    BOOL GetShowRestore() {return _fShowRestore;}



private:
    //Private methods
    HWND CreateWnd(HINSTANCE hInstance,HWND hwndParent,
                   LPRECT lpInitialRect);

    LRESULT CALLBACK BBarWndProc(HWND hwnd,
                                UINT uMsg,
                                WPARAM wParam,
                                LPARAM lParam);
    BOOL DestroyWindow() {return ::DestroyWindow(_hwndBBar);}
    static LRESULT CALLBACK StaticBBarWndProc(HWND hwnd,
                                              UINT uMsg,
                                              WPARAM wParam,
                                              LPARAM lParam);
    VOID    SetState(BBarState newState);
    BOOL    Initialize(int desktopX, int desktopY, BOOL fStartRaised);
    BOOL    ImmediateRaiseBBar();
#ifdef OS_WINCE
    BOOL    ImmediateLowerBBar();
#endif
    BOOL    AddReplaceImage(HWND hwndToolbar, UINT rsrcId,
                            UINT nCells, HBITMAP* phbmpOldImage,
                            PUINT pImgIndex);
    BOOL    CreateToolbars();
    BOOL    ReloadImages();


    //
    // Window event handlers
    //
    LRESULT OnPaint(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT OnEraseBkgnd(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    //
    // Internal event handlers
    //
    VOID    OnBBarLowered();
    VOID    OnBBarRaised();

    VOID    OnCmdMinimize();
    VOID    OnCmdRestore();
    VOID    OnCmdClose();
    VOID    OnCmdPin();

#ifdef OS_WINCE
    HRGN    GetBBarRgn(POINT *pts);
#endif

protected:
    //Protected members
    HWND        _hwndBBar;
    HWND        _hwndParent;
private:
    //Private members
    HINSTANCE   _hInstance;

    BOOL        _fBBarEnabled;

    HWND        _hwndPinBar;
    HWND        _hwndWinControlsBar;

    BBarState   _state;
    RECT        _rcBBarLoweredAspect;
    SIZE        _sizeLoweredBBar;
    TCHAR       _szDisplayedText[260];
    RECT        _rcBBarDisplayTextArea;
    BOOL        _fBlockZOrderChanges;

    //
    // Vertical offset used for animation
    // 0 is fully raised
    // _sizeLoweredBBar.cy is fully lowered
    INT         _nBBarVertOffset;
    
    INT         _nBBarAutoHideTime;

    //
    // Position of the mouse at the last autohide
    //
    POINT       _ptLastAutoHideMousePos;

    CUI*        _pUi;

    BOOL        _fPinned;
    INT         _nPinUpImage;
    INT         _nPinDownImage;

    HBITMAP     _hbmpLeftImage;
    HBITMAP     _hbmpRightImage;

    //
    // Locked in similar to the pin except that it does not
    // affect the pin state. It can be used to force the bbar
    // to remain in a lowered state without having to change
    // the pin state
    //
    BOOL        _fLocked;

    //
    // Button display states
    //
    BOOL        _fShowMinimize;
    BOOL        _fShowRestore;
};

#endif // USE_BBAR

#endif // _BBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\cdapi.cpp ===
/****************************************************************************/
// cdapi.cpp
//
// Component Decoupler API functions
// Copyright (C) 1997-1999 Microsoft Corporation
/****************************************************************************/

#include <adcg.h>
extern "C" {
#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "cdapi"
#include <atrcapi.h>
}

#include "autil.h"
#include "cd.h"
#include "wui.h"


CCD::CCD(CObjs* objs)
{
    _pClientObjects = objs;
    _fCDInitComplete = FALSE;

    /************************************************************************/
    /* Initialize the global data.                                          */
    /************************************************************************/
    DC_MEMSET(&_CD, 0, sizeof(_CD));
}

CCD::~CCD()
{
}


/****************************************************************************/
/* Name:      CD_Init                                                       */
/*                                                                          */
/* Purpose:   Component Decoupler initialization function                   */
/****************************************************************************/
DCVOID DCAPI CCD::CD_Init(DCVOID)
{
    WNDCLASS wc;
    WNDCLASS tmpWndClass;

    DC_BEGIN_FN("CD_Init");

    TRC_ASSERT(_pClientObjects, (TB,_T("_pClientObjects is NULL")));
    _pClientObjects->AddObjReference(CD_OBJECT_FLAG);

    //Setup local object pointers
    _pUt  = _pClientObjects->_pUtObject;
    _pUi  = _pClientObjects->_pUiObject;

    //
    // Only register the class if not already registered (previous instance)
    //
    if(!GetClassInfo( _pUi->UI_GetInstanceHandle(), CD_WINDOW_CLASS, &tmpWndClass))
    {
        /************************************************************************/
        /* Register the CD window class.                                        */
        /************************************************************************/
        wc.style         = 0;
        wc.lpfnWndProc   = CDStaticWndProc;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = sizeof(void*);
        wc.hInstance     = _pUi->UI_GetInstanceHandle();
        wc.hIcon         = NULL;
        wc.hCursor       = NULL;
        wc.hbrBackground = NULL;
        wc.lpszMenuName  = NULL;
        wc.lpszClassName = CD_WINDOW_CLASS;
    
        if (!RegisterClass(&wc))
        {
            // $$$v-reddya. Hack to avoid bug #923.
            TRC_ERR((TB, _T("Failed to register window class")));
            //_pUi->UI_FatalError(DC_ERR_OUTOFMEMORY);
        }
    }

    _fCDInitComplete = TRUE;

    DC_END_FN();
}


/****************************************************************************/
/* Name:      CD_Term                                                       */
/*                                                                          */
/* Purpose:   Component Decoupler termination function                      */
/****************************************************************************/
DCVOID DCAPI CCD::CD_Term(DCVOID)
{
    DC_BEGIN_FN("CD_Term");

    if(_fCDInitComplete)
    {
        if (!UnregisterClass(CD_WINDOW_CLASS, _pUi->UI_GetInstanceHandle())) {
            //Failure to unregister could happen if another instance is still running
            //that's ok...unregistration will happen when the last instance exits.
            TRC_ERR((TB, _T("Failed to unregister window class")));
        }
        _pClientObjects->ReleaseObjReference(CD_OBJECT_FLAG);
    }

    DC_END_FN();
}


/****************************************************************************/
/* Name:      CD_RegisterComponent                                          */
/*                                                                          */
/* Purpose:   Register a new component                                      */
/*                                                                          */
/* Params:    IN  component: component id                                   */
/****************************************************************************/
HRESULT DCAPI CCD::CD_RegisterComponent(DCUINT component)
{
    HRESULT hr = E_FAIL;

    DC_BEGIN_FN("CD_RegisterComponent");
    TRC_ASSERT((component <= CD_MAX_COMPONENT),
               (TB, _T("Invalid component %u"), component));

    TRC_ASSERT((_CD.hwnd[component] == NULL),
               (TB, _T("Component %u already registered"), component));

    /************************************************************************/
    /* Create window for this component.                                    */
    /************************************************************************/
    _CD.hwnd[component] = CreateWindow(
         CD_WINDOW_CLASS,              /* See RegisterClass() call          */
         NULL,                         /* Text for window title bar         */
         0,                            /* Window style                      */
         0,                            /* Default horizontal position       */
         0,                            /* Default vertical position         */
         0,                            /* Width                             */
         0,                            /* Height                            */
         NULL,                         /* hwndParent - none                 */
         NULL,                         /* hMenu - none                      */
         _pUi->UI_GetInstanceHandle(),
         this                          /* Window creation data              */
       );

    if (_CD.hwnd[component] != NULL) {
        hr = S_OK;
    }
    else {
        hr = HRESULT_FROM_WIN32(GetLastError());
        TRC_ERR((TB,_T("Failed to create window: 0x%x"),hr));
    }
    TRC_NRM((TB, _T("Component(%u) hwnd(%p)"), component, _CD.hwnd[component]));

    DC_END_FN();
    return hr;
} /* CD_RegisterComponent */


/****************************************************************************/
/* Name:      CD_UnregisterComponent                                        */
/*                                                                          */
/* Purpose:   Unregister component from CD                                  */
/*                                                                          */
/* Params:    IN  component: component ID                                   */
/****************************************************************************/
HRESULT DCAPI CCD::CD_UnregisterComponent(DCUINT component)
{
    HRESULT hr = E_FAIL;
    DC_BEGIN_FN("CD_UnregisterComponent");

    TRC_ASSERT((component <= CD_MAX_COMPONENT),
               (TB, _T("Invalid component %u"), component));

    /************************************************************************/
    /* Destroy this component's window, if it exists.                       */
    /************************************************************************/
    if (_CD.hwnd[component] != NULL)
    {
        DestroyWindow(_CD.hwnd[component]);
        _CD.hwnd[component] = NULL;
    }

    hr = S_OK;

    DC_END_FN();
    return hr;
} /* CD_UnregisterComponent */


// Note that we have several copies of very similar code below. This is
// to trade a bit of code size (easy to predict and cache) against
// 50%-predictable branches created by parameterizing sync/async, which are
// very CPU expensive on modern processors. Since notifications are often
// used in performance paths (send/receive data), this optimization is
// worthwhile.


/****************************************************************************/
/* Name:      CD_DecoupleNotification                                       */
/*                                                                          */
/* Purpose:   Call given function with specified data                       */
/*                                                                          */
/* Params:    IN  component:        target thread                           */
/*            IN  pInst             target object instance pointer          */
/*            IN  pNotificationFn:  target function                         */
/*            IN  pData:            pointer to data to pass: cannot be NULL */
/*            IN  dataLength:       data length in bytes: cannot be zero    */
/*                                                                          */
/* Operation: Copy supplied data into data buffer and post message to       */
/*            corresponding component window.                               */
/****************************************************************************/
BOOL DCAPI CCD::CD_DecoupleNotification(
        unsigned            component,
        PDCVOID             pInst,
        PCD_NOTIFICATION_FN pNotificationFn,
        PDCVOID             pData,
        unsigned            dataLength)
{
    PCDTRANSFERBUFFER pTransferBuffer;

    DC_BEGIN_FN("CD_DecoupleNotificationEx");

    TRC_ASSERT(((dataLength <= CD_MAX_NOTIFICATION_DATA_SIZE) &&
            (dataLength > 0 )),
            (TB, _T("dataLength(%u) invalid"), dataLength));
    TRC_ASSERT((component <= CD_MAX_COMPONENT),
            (TB, _T("Invalid component %u"), component));
    TRC_ASSERT((pNotificationFn != NULL),(TB, _T("Null pNotificationFn")));
    TRC_ASSERT((pData != NULL),(TB, _T("Null pData")));
    TRC_ASSERT((pInst != NULL),(TB, _T("Null pInst")));

    // Check that the target component is still registered.
    if (_CD.hwnd[component] != NULL) {
        pTransferBuffer = CDAllocTransferBuffer(dataLength);
        if(pTransferBuffer) {
            pTransferBuffer->hdr.pNotificationFn = pNotificationFn;
            pTransferBuffer->hdr.pInst           = pInst;
            DC_MEMCPY(pTransferBuffer->data, pData, dataLength);
    
            TRC_NRM((TB, _T("Notify component %u (%p) of %u bytes of data"),
                    component, _CD.hwnd[component], dataLength));
            TRC_DATA_DBG("notification data", pData, dataLength);
    
            // For now, we only use async data notifications. If we
            // need sync data notifications, copy this code to a new
            // func and use the ifdef'd SendMessage.
            if (!PostMessage(_CD.hwnd[component], CD_NOTIFICATION_MSG,
                    (WPARAM)dataLength, (LPARAM)pTransferBuffer)) {
                _pUi->UI_FatalError(DC_ERR_POSTMESSAGEFAILED);
            }
            else {
                return TRUE;
            }
                
#ifdef DC_DEBUG
            // Trace is before increment so that the point at which we're most
            // likely to get pre-empted (TRC_GetBuffer) is before all references
            // to the variable we're interested in.
            TRC_NRM((TB, _T("Messages now pending: %ld"), _CD.pendingMessageCount + 1));
            _pUt->UT_InterlockedIncrement(&_CD.pendingMessageCount);
#endif
        }
        else {
            TRC_ERR((TB,_T(" CDAllocTransferBuffer returned NULL")));
        }
    }
    else {
        TRC_ERR((TB, _T("Null hwnd for component(%u)"), component));
    }

    DC_END_FN();
    return FALSE;
} /* CD_DecoupleNotification */


/****************************************************************************/
/* Name:      CD_DecoupleSyncDataNotification                               */
/*                                                                          */
/* Purpose:   Call given function with specified data                       */
/*                                                                          */
/* Params:    IN  component:        target thread                           */
/*            IN  pInst             target object instance pointer          */
/*            IN  pNotificationFn:  target function                         */
/*            IN  pData:            pointer to data to pass: cannot be NULL */
/*            IN  dataLength:       data length in bytes: cannot be zero    */
/*                                                                          */
/* Operation: Copy supplied data into data buffer and post message to       */
/*            corresponding component window.                               */
/****************************************************************************/
BOOL DCAPI CCD::CD_DecoupleSyncDataNotification(
        unsigned            component,
        PDCVOID             pInst,
        PCD_NOTIFICATION_FN pNotificationFn,
        PDCVOID             pData,
        unsigned            dataLength)
{
    PCDTRANSFERBUFFER pTransferBuffer;

    DC_BEGIN_FN("CD_DecoupleSyncDataNotification");

    TRC_ASSERT(((dataLength <= CD_MAX_NOTIFICATION_DATA_SIZE) &&
            (dataLength > 0 )),
            (TB, _T("dataLength(%u) invalid"), dataLength));
    TRC_ASSERT((component <= CD_MAX_COMPONENT),
            (TB, _T("Invalid component %u"), component));
    TRC_ASSERT((pNotificationFn != NULL),(TB, _T("Null pNotificationFn")));
    TRC_ASSERT((pData != NULL),(TB, _T("Null pData")));
    TRC_ASSERT((pInst != NULL),(TB, _T("Null pInst")));

    // Check that the target component is still registered.
    if (_CD.hwnd[component] != NULL) {
        pTransferBuffer = CDAllocTransferBuffer(dataLength);
        //
        // If CDAllocTransferBuffer fails, it calls UI_FatalError
        // don't need to do that from here again.
        //
        if(pTransferBuffer) {
            pTransferBuffer->hdr.pNotificationFn = pNotificationFn;
            pTransferBuffer->hdr.pInst           = pInst;
            DC_MEMCPY(pTransferBuffer->data, pData, dataLength);
    
            TRC_NRM((TB, _T("Notify component %u (%p) of %u bytes of data"),
                    component, _CD.hwnd[component], dataLength));
            TRC_DATA_DBG("notification data", pData, dataLength);
    
            if (0 != SendMessage(_CD.hwnd[component], CD_NOTIFICATION_MSG,
                    (WPARAM)dataLength, (LPARAM)pTransferBuffer))
            {
                _pUi->UI_FatalError(DC_ERR_SENDMESSAGEFAILED);
            }
            else
            {
                return TRUE;
            }
                

#ifdef DC_DEBUG
            // Trace is before increment so that the point at which we're most
            // likely to get pre-empted (TRC_GetBuffer) is before all references
            // to the variable we're interested in.
            TRC_NRM((TB, _T("Messages now pending: %ld"), _CD.pendingMessageCount + 1));
            _pUt->UT_InterlockedIncrement(&_CD.pendingMessageCount);
#endif
        }
        else {
            TRC_ERR((TB,_T("CDAllocTransferBuffer returned NULL")));
        }
    }
    else {
        TRC_ERR((TB, _T("Null hwnd for component(%u)"), component));
    }

    DC_END_FN();
    return FALSE;
}


/****************************************************************************/
/* Name:      CD_DecoupleSimpleNotification                                 */
/*                                                                          */
/* Purpose:   Call given function with specified message (DCUINT)           */
/*                                                                          */
/* Params:    IN  component        - target thread                          */
/*            IN  pInst             target object instance pointer          */
/*            IN  pNotificationFn  - address of notification function       */
/*            IN  data             - message data                           */
/****************************************************************************/
BOOL DCAPI CCD::CD_DecoupleSimpleNotification(
        unsigned                   component,
        PDCVOID                    pInst,
        PCD_SIMPLE_NOTIFICATION_FN pNotificationFn,
        ULONG_PTR                  msg)
{
    PCDTRANSFERBUFFER pTransferBuffer;

    DC_BEGIN_FN("CD_DecoupleSimpleNotification");

    TRC_ASSERT((component <= CD_MAX_COMPONENT),
            (TB, _T("Invalid component %u"), component));
    TRC_ASSERT((pNotificationFn != NULL),
            (TB, _T("Null pNotificationFn")));
    TRC_NRM((TB, _T("Notify component %u (%p) of %x"), component,
            _CD.hwnd[component], msg));
    TRC_ASSERT((pInst != NULL),(TB, _T("Null pInst")));

    // Check that the target component is still registered.
    if (_CD.hwnd[component] != NULL) {

        //
        // We need to pass instance pointer, function pointer and message
        // so we need a transfer buffer (with no data) message is posted
        // in WPARAM
        //
        pTransferBuffer = CDAllocTransferBuffer(0);
        if(pTransferBuffer) {
            pTransferBuffer->hdr.pSimpleNotificationFn = pNotificationFn;
            pTransferBuffer->hdr.pInst           = pInst;
        
#ifdef DC_DEBUG
            {
                // Check on the number of pending messages - if this deviates too
                // far from 0 then something has probably gone wrong.
                DCINT32 msgCount = _CD.pendingMessageCount;
    
                _pUt->UT_InterlockedIncrement(&_CD.pendingMessageCount);
    
                if ( msgCount > 50 ) {
                    TRC_ERR((TB, _T("Now %u pending messages - too high"), msgCount));
                }
                else {
                    TRC_NRM((TB, _T("Now %u pending messages"), msgCount));
                }
            }
#endif

            if (PostMessage(_CD.hwnd[component], CD_SIMPLE_NOTIFICATION_MSG,
                    (WPARAM)msg, (LPARAM)pTransferBuffer))
            {
                return TRUE;
            }
            else
            {
                _pUi->UI_FatalError(DC_ERR_POSTMESSAGEFAILED);
            }
        }
        else {
            TRC_ERR((TB,_T(" CDAllocTransferBuffer returned NULL")));
        }
    }
    else
    {
        TRC_ERR((TB, _T("Null hwnd for component(%u)"), component));
    }

    DC_END_FN();
    return FALSE;
}


/****************************************************************************/
/* Name:      CD_DecoupleSyncNotification                                   */
/*                                                                          */
/* Purpose:   Synchronously call given function with specified message      */
/*                                                                          */
/* Params:    IN  component        - target thread                          */
/*            IN  pInst             target object instance pointer          */
/*            IN  pNotificationFn  - address of notification function       */
/*            IN  data             - message data                           */
/****************************************************************************/
BOOL DCAPI CCD::CD_DecoupleSyncNotification(
        unsigned                   component,
        PDCVOID                    pInst,
        PCD_SIMPLE_NOTIFICATION_FN pNotificationFn,
        ULONG_PTR                  msg)
{
    PCDTRANSFERBUFFER pTransferBuffer;

    DC_BEGIN_FN("CD_DecoupleSyncNotification");

    TRC_ASSERT((component <= CD_MAX_COMPONENT),
            (TB, _T("Invalid component %u"), component));
    TRC_ASSERT((pNotificationFn != NULL),
            (TB, _T("Null pNotificationFn")) );
    TRC_NRM((TB, _T("Notify component %u (%p) of %x"), component,
            _CD.hwnd[component], msg));
    TRC_ASSERT((pInst != NULL),(TB, _T("Null pInst")));

    // Check that the target component is still registered.
    if (_CD.hwnd[component] != NULL)
    {

        //
        // We need to pass instance pointer, function pointer and message
        // so we need a transfer buffer (with no data) message is posted
        // in WPARAM
        //
        pTransferBuffer = CDAllocTransferBuffer(0);
        if(pTransferBuffer) {
            pTransferBuffer->hdr.pSimpleNotificationFn = pNotificationFn;
            pTransferBuffer->hdr.pInst           = pInst;
#ifdef DC_DEBUG
            {
                // Check on the number of pending messages - if this deviates too
                // far from 0 then something has probably gone wrong.
                DCINT32 msgCount = _CD.pendingMessageCount;
    
                _pUt->UT_InterlockedIncrement(&_CD.pendingMessageCount);
    
                if ( msgCount > 50 ) {
                    TRC_ERR((TB, _T("Now %u pending messages - too high"), msgCount));
                }
                else {
                    TRC_NRM((TB, _T("Now %u pending messages"), msgCount));
                }
            }
#endif
            if (0 != SendMessage(_CD.hwnd[component], CD_SIMPLE_NOTIFICATION_MSG,
                    (WPARAM)msg, (LPARAM)pTransferBuffer))
            {
                _pUi->UI_FatalError(DC_ERR_SENDMESSAGEFAILED);
            }
            else
            {
                return TRUE;
            }
        }
        else {
            TRC_ERR((TB,_T(" CDAllocTransferBuffer returned NULL")));
        }
    }
    else
    {
        TRC_ERR((TB, _T("Null hwnd for component(%u)"), component));
    }

    DC_END_FN();
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\clicense.cpp ===
/**MOD+**********************************************************************/
/* Header:    CLicense.cpp                                                  */
/*                                                                          */
/* Purpose:   Client License Manager implementation                         */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1999                             */
/*                                                                          */
/****************************************************************************/

#include <adcg.h>

extern "C" {
#include <clicense.h>
#define TRC_GROUP TRC_GROUP_SECURITY
#define TRC_FILE  "clicense"
#include <atrcapi.h>

#ifdef ENFORCE_LICENSE

#include "license.h"
#include "cryptkey.h"
#include "hccontxt.h"
#endif  //ENFORCE_LICENSE
}

#include "clicense.h"
#include "autil.h"
#include "wui.h"
#include "sl.h"

/****************************************************************************/
/* License Handle Data                                                      */
/****************************************************************************/
typedef struct tagCLICENSE_DATA
{
    int ANumber;

} CLICENSE_DATA, * PCLICENSE_DATA;

/****************************************************************************/
/* Define our memory alloc function                                         */
/****************************************************************************/

#define MemoryAlloc(x) LocalAlloc(LMEM_FIXED, x)
#define MemoryFree(x) LocalFree(x)

CLic::CLic(CObjs* objs)
{
    _pClientObjects = objs;
}


CLic::~CLic()
{
}


/**PROC+*********************************************************************/
/* Name:      CLicenseInit                                                  */
/*                                                                          */
/* Purpose:   Initialize ClientLicense Manager                              */
/*                                                                          */
/* Returns:   Handle to be passed to subsequent License Manager functions   */
/*                                                                          */
/* Params:    None                                                          */
/*                                                                          */
/* Operation: LicenseInit is called during Client initialization.  Its      */
/*            purpose is to allow one-time initialization.  It returns a    */
/*            handle which is subsequently passed to all License Manager    */
/*            functions.  A typical use for this handle is as a pointer to  */
/*            memory containing per-instance data.                          */
/*                                                                          */
/**PROC-*********************************************************************/
int CALL_TYPE CLic::CLicenseInit(
    HANDLE FAR * phContext
    )
{
    int 
        nResult = LICENSE_OK;
    LICENSE_STATUS
        Status;

    DC_BEGIN_FN( "CLicenseInit" );

    _pUt  = _pClientObjects->_pUtObject;
    _pSl  = _pClientObjects->_pSlObject;
    _pMcs = _pClientObjects->_pMCSObject;
    _pUi  = _pClientObjects->_pUiObject;

    //Set only if server capability specifies it
    _fEncryptLicensePackets = FALSE;

    TRC_NRM( ( TB, _T("ClicenseInit Called\n") ) );

    if( _pSl->_SL.encrypting )
    {
        //
        // Security exchange has already taken place, so we do not
        // have to do the server authentication again.
        //

        Status = LicenseInitializeContext(
                            phContext, 
                            LICENSE_CONTEXT_NO_SERVER_AUTHENTICATION );

        if( LICENSE_STATUS_OK != Status ) 
        {
            TRC_ERR( ( TB, _T("Error Initializing License Context: %d\n"), Status ) );
            nResult = LICENSE_ERROR;
        }
    
        //
        // Keep track of the proprietory certificate or the public key that the
        // server has sent to us.
        //

        if( _pSl->_SL.pServerCert )
        {
            Status = LicenseSetCertificate( *phContext, _pSl->_SL.pServerCert );

            if( LICENSE_STATUS_OK != Status )
            {
                TRC_ERR( ( TB, _T("Error setting server certificate: %d\n"), Status ) );
                nResult = LICENSE_ERROR;
            }
        }
        else if( _pSl->_SL.pbServerPubKey )
        {
            Status = LicenseSetPublicKey( *phContext, _pSl->_SL.cbServerPubKey, _pSl->_SL.pbServerPubKey );

            if( LICENSE_STATUS_OK != Status )
            {
                TRC_ERR( ( TB, _T("Error setting server public key: %d\n"), Status ) );
                nResult = LICENSE_ERROR;
            }
        }
        else
        {
            TRC_ERR( ( TB, _T("Error: no server certificate or public key after security exchange\n") ) );
            nResult = LICENSE_ERROR;
        }
    }
    else
    {
        Status = LicenseInitializeContext( phContext, 0 );                            

        if( LICENSE_STATUS_OK != Status ) 
        {
            TRC_ERR( ( TB, _T("Error Initializing License Context: %d\n"), Status ) );
            nResult = LICENSE_ERROR;
        }
    
    }

    DC_END_FN();
    return( nResult );
}


/**PROC+*********************************************************************/
/* Name:      CLicenseData                                                  */
/*                                                                          */
/* Purpose:   Handle license data received from the Server                  */
/*                                                                          */
/* Returns:   LICENSE_OK       - License negotiation is complete            */
/*            LICENSE_CONTINUE - License negotiation will continue          */
/*                                                                          */
/* Params:    pHandle   - handle returned by LicenseInit                    */
/*            pData     - data received from Server                         */
/*            dataLen   - length of data received                           */
/*                                                                          */
/* Operation: This function is passed all license packets received from the */
/*            Server.  It should parse the packet and respond (by calling   */
/*            suitable SL functions - see aslapi.h) as required.            */
/*                                                                          */
/*            If license negotiation is complete, this function must return */
/*            LICENSE_OK                                                    */
/*            If license negotiation is not yet complete, return            */
/*            LICENSE_CONTINUE                                              */
/*                                                                          */
/*            Incoming packets from the Client will continue to be          */
/*            interpreted as license packets until this function returns    */
/*            LICENSE_OK.                                                   */
/*                                                                          */
/**PROC-*********************************************************************/
int CALL_TYPE CLic::CLicenseData(
    HANDLE hContext,
    LPVOID pData,
    DWORD dwDataLen,
    UINT32 *puiExtendedErrorInfo)
{
    SL_BUFHND bufHandle;
    DWORD dwBufLen;
    DWORD dwHeaderLen, dwTotalLen, newDataLen;
    BYTE FAR * pbBuffer;
    LICENSE_STATUS lsReturn = LICENSE_STATUS_OK;
    PRNS_SECURITY_HEADER2 pSecHeader2;

    DC_BEGIN_FN("CLicenseData");

    TRC_NRM((TB, _T("CLicenseData Called\n")));
    TRC_NRM((TB, _T("CLicenseData called, length = %ld"), dwDataLen));

    lsReturn = LicenseAcceptContext( hContext,
                                     puiExtendedErrorInfo,
                                     (BYTE FAR *)pData,
                                     dwDataLen,
                                     NULL,
                                     &dwBufLen);

    if( lsReturn == LICENSE_STATUS_OK)
    {
        TRC_NRM((TB, _T("License verification succeeded\n")));
        DC_END_FN();
        return LICENSE_OK;
    }

    if(lsReturn != LICENSE_STATUS_CONTINUE)
    {
        TRC_ERR((TB, _T("Error %d during license verification.\n"), lsReturn));
        DC_END_FN();
        return LICENSE_ERROR;
    }

    /************************************************************************/
    /* Adjust requested length to account for SL header and                 */
    /* get the buffer from NL                                               */
    /************************************************************************/

    if (_pSl->_SL.encrypting)
    {
        if (_pSl->_SL.encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
            // If FIPS is used, 
            // it must have room for an extra block
            dwHeaderLen = sizeof(RNS_SECURITY_HEADER2);
            newDataLen = TSCAPI_AdjustDataLen(dwBufLen);
            dwTotalLen = newDataLen + dwHeaderLen;
        }
        else {
            dwHeaderLen = sizeof(RNS_SECURITY_HEADER1);
            dwTotalLen = dwBufLen + dwHeaderLen;
        }
        TRC_DBG((TB, _T("Ask NL for %d (was %d) bytes"), dwTotalLen, dwBufLen));
    }
    else
    {
        dwHeaderLen = sizeof(RNS_SECURITY_HEADER);
        dwTotalLen = dwBufLen + dwHeaderLen;
        TRC_DBG((TB, _T("Not encrypting, ask NL for %d bytes"), dwTotalLen));
    }

    if( !_pMcs->NL_GetBuffer((DCUINT)(dwTotalLen),
                      (PPDCUINT8)&pbBuffer,
                      &bufHandle) )
    {
        /********************************************************************/
        /* Buffer not available so can't send, try later.                   */
        /********************************************************************/

        TRC_ALT((TB, _T("Failed to get buffer for licensing data\n")));
        DC_END_FN();
        return LICENSE_ERROR;
    }

    // Since FIPS need extra block, fill in the padding size
    if (_pSl->_SL.encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
        pSecHeader2 = (PRNS_SECURITY_HEADER2)pbBuffer;
        pSecHeader2->padlen = (TSUINT8)(newDataLen - dwBufLen);
    }

    /********************************************************************/
    /* Adjust buffer pointer to account for SL header                   */
    /********************************************************************/

    pbBuffer += dwHeaderLen;

    lsReturn = LicenseAcceptContext(hContext,
                                    0,
                                    (BYTE FAR *)pData,
                                    dwDataLen,
                                    pbBuffer,
                                    &dwBufLen);

    if( lsReturn != LICENSE_STATUS_CONTINUE )
    {
        TRC_ERR((TB, _T("Error %d during license verification.\n"), lsReturn));
        DC_END_FN();
        return LICENSE_ERROR;
    }

    if(dwBufLen >0)
    {
        //
        // Now send the data
        //

        _pSl->SL_SendPacket( pbBuffer,
                       (DCUINT)(dwBufLen),
                       RNS_SEC_LICENSE_PKT |
                       (_fEncryptLicensePackets ? RNS_SEC_ENCRYPT : 0 ),
                       bufHandle,
                       _pUi->UI_GetClientMCSID(),
                       _pUi->UI_GetChannelID(),
                       TS_LOWPRIORITY );

        TRC_NRM((TB, _T("Sending license verification data, length = %ld"),
                dwBufLen));
        TRC_NRM((TB, _T("Send License Verification data.\n")));
        DC_END_FN();
        DC_END_FN();
        return LICENSE_CONTINUE;
    }

    DC_END_FN();
    return(LICENSE_OK);
}

/**PROC+*********************************************************************/
/* Name:      CLicenseTerm                                                  */
/*                                                                          */
/* Purpose:   Terminate Client License Manager                              */
/*                                                                          */
/* Returns:   None                                                          */
/*                                                                          */
/* Params:    pHandle - handle returned from LicenseInit                    */
/*                                                                          */
/* Operation: This function is provided to do one-time termination of the   */
/*            License Manager.  For example, if pHandle points to per-      */
/*            instance memory, this would be a good place to free it.       */
/*                                                                          */
/*            Note that CLicenseTerm is called if CLicenseInit fails, hence */
/*            it can be called with a NULL pHandle.                         */
/*                                                                          */
/**PROC-*********************************************************************/

int CALL_TYPE CLic::CLicenseTerm(
    HANDLE hContext )
{
    LICENSE_STATUS lsReturn = LICENSE_STATUS_OK;
    DC_BEGIN_FN("CLicenseTerm");
    TRC_NRM((TB, _T("CLicenseTerm called.\n")));
 
    if( LICENSE_STATUS_OK != ( lsReturn = LicenseDeleteContext(hContext) ) )
    {
        TRC_ERR((TB, _T("Error %d while deleting license context.\n"), lsReturn));
        DC_END_FN();
        return LICENSE_ERROR;
    }

    DC_END_FN();
    return LICENSE_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\clicense.h ===
/**INC+**********************************************************************/
/* Header:    CLicense.h                                                    */
/*                                                                          */
/* Purpose:   Client License Manager functions                              */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log$
**/
/**INC-**********************************************************************/
#ifndef _CLICENSE_H
#define _CLICENSE_H
/****************************************************************************/
/* Define the calling convention                                            */
/****************************************************************************/
#ifndef OS_WINCE
#define CALL_TYPE _stdcall
#else
#define CALL_TYPE
#endif

class CSL;
class CUT;
class CMCS;
class CUI;

#include "objs.h"


class CLic
{
public:
    CLic(CObjs* objs);
    ~CLic();

    /**PROC+*********************************************************************/
    /* Name:      CLicenseInit                                                  */
    /*                                                                          */
    /* Purpose:   Initialize ClientLicense Manager                              */
    /*                                                                          */
    /* Returns:   Handle to be passed to subsequent License Manager functions   */
    /*                                                                          */
    /* Params:    None                                                          */
    /*                                                                          */
    /* Operation: LicenseInit is called during Client initialization.  Its      */
    /*            purpose is to allow one-time initialization.  It returns a    */
    /*            handle which is subsequently passed to all License Manager    */
    /*            functions.  A typical use for this handle is as a pointer to  */
    /*            memory containing per-instance data.                          */
    /*                                                                          */
    /**PROC-*********************************************************************/
    
    int CALL_TYPE CLicenseInit(
    						   HANDLE FAR * phContext
    						   );
    
    
    /**PROC+*********************************************************************/
    /* Name:      CLicenseData                                                  */
    /*                                                                          */
    /* Purpose:   Handle license data received from the Server                  */
    /*                                                                          */
    /* Returns:   LICENSE_OK       - License negotiation is complete            */
    /*            LICENSE_CONTINUE - License negotiation will continue          */
    /*                                                                          */
    /* Params:    pHandle   - handle returned by LicenseInit                    */
    /*            pData     - data received from Server                         */
    /*            dataLen   - length of data received                           */
    /*            puiExtendedErrorInfo - receives extended error info code      */
    /*                                                                          */
    /* Operation: This function is passed all license packets received from the */
    /*            Server.  It should parse the packet and respond (by calling   */
    /*            suitable SL functions - see aslapi.h) as required.            */
    /*                                                                          */
    /*            If license negotiation is complete, this function must return */
    /*            LICENSE_OK                                                    */
    /*            If license negotiation is not yet complete, return            */
    /*            LICENSE_CONTINUE                                              */
    /*                                                                          */
    /*            Incoming packets from the Client will continue to be          */
    /*            interpreted as license packets until this function returns    */
    /*            LICENSE_OK.                                                   */
    /*                                                                          */
    /**PROC-*********************************************************************/
    int CALL_TYPE CLicenseData(
                               HANDLE hContext,
                               LPVOID pData, 
                               DWORD dataLen,
                               UINT32 *puiExtendedErrorInfo
                               );
    
    #define LICENSE_OK          0
    #define LICENSE_CONTINUE    2
    #define LICENSE_ERROR		4
    
    /**PROC+*********************************************************************/
    /* Name:      CLicenseTerm                                                  */
    /*                                                                          */
    /* Purpose:   Terminate Client License Manager                              */
    /*                                                                          */
    /* Returns:   None                                                          */
    /*                                                                          */
    /* Params:    pHandle - handle returned from LicenseInit                    */
    /*                                                                          */
    /* Operation: This function is provided to do one-time termination of the   */
    /*            License Manager.  For example, if pHandle points to per-      */
    /*            instance memory, this would be a good place to free it.       */
    /*                                                                          */
    /**PROC-*********************************************************************/
    int CALL_TYPE CLicenseTerm(
    						   HANDLE hContext
    						   );

    VOID    SetEncryptLicensingPackets(BOOL b)   {_fEncryptLicensePackets = b;}
    BOOL    GetEncryptLicensingPackets()      {return _fEncryptLicensePackets;}

private:
    CSL* _pSl;
    CUT* _pUt;
    CMCS* _pMcs;
    CUI* _pUi;

private:
    CObjs* _pClientObjects;
    //
    // Flag set to specify server capability
    // indicating client should encrypt licensing
    // packets to the server.
    //
    BOOL   _fEncryptLicensePackets;
};

#endif /* _CLICENSE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\ccfsm.cpp ===
/****************************************************************************/
// ccfsm.cpp
//
// Call controller finite state machine code.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <adcg.h>

extern "C" {
#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "accfsm"
#include <atrcapi.h>
#include <aver.h>
#include <winsock.h>
}

#include "cd.h"
#include "cc.h"
#include "aco.h"
#include "fs.h"
#include "ih.h"
#include "sl.h"
#include "wui.h"
#include "autil.h"
#include "or.h"
#include "uh.h"

#define REG_WINDOWS_KEY            TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion")
/****************************************************************************/
// CCEnableShareRecvCmpnts
//
// Called after sending ConfirmActivePDU to server to activate receive-thread
// components.
/****************************************************************************/
inline void DCINTERNAL CCC::CCEnableShareRecvCmpnts(void)
{
    DC_BEGIN_FN("CCEnableShareRecvCmpnts");

    // The following components expect to be called in the receiver thread
    // context - but we are in the sender thread context.  Thus we need to
    // decouple the calls to these functions.
    // Note that we have to wait for completion of UH_Enable since it will
    // prepare the bitmap cache capabilities for the ConfirmActivePDU.
    TRC_NRM((TB, _T("Decoupling calls to CM/UH_Enable")));
    _pCd->CD_DecoupleSyncNotification(CD_RCV_COMPONENT, _pCm,
            CD_NOTIFICATION_FUNC(CCM,CM_Enable), 0);
    _pCd->CD_DecoupleSyncNotification(CD_RCV_COMPONENT, _pUh,
            CD_NOTIFICATION_FUNC(CUH,UH_Enable), 0);

    DC_END_FN();
} /* CCEnableShareRecvCmpnts */


/****************************************************************************/
// CCDisableShareRecvCmpnts
//
// Disables the recv-side share components. Called on receipt of a
// DisableAllPDU from the server. Note that although this is the end of a
// share, it may not be the end of the session, since if the server is
// reconnecting a DemandActivePDU will be sent soon after this.
/****************************************************************************/
inline void DCINTERNAL CCC::CCDisableShareRecvCmpnts(void)
{
    DC_BEGIN_FN("CCDisableShareRecvCmpnts");

    /************************************************************************/
    /* The following components expect to be called in the receiver thread  */
    /* context - but we are in the sender thread context.  Thus we need     */
    /* to decouple the calls to these functions.                            */
    /************************************************************************/
    TRC_NRM((TB, _T("Decoupling calls to CM/UH_Disable")));
    _pCd->CD_DecoupleSyncNotification(CD_RCV_COMPONENT, _pCm,
            CD_NOTIFICATION_FUNC(CCM,CM_Disable), 0);
    _pCd->CD_DecoupleSyncNotification(CD_RCV_COMPONENT, _pUh,
            CD_NOTIFICATION_FUNC(CUH,UH_Disable), 0);
    DC_END_FN();
} /* CCDisableShareRecvCmpnts */


/****************************************************************************/
// CCDisconnectShareRecvCmpnts
//
// Disconnects the recv-side share components. Called on session end,
// indicates cleanup should occur.
/****************************************************************************/
inline void DCINTERNAL CCC::CCDisconnectShareRecvCmpnts(void)
{
    DC_BEGIN_FN("CCDisableShareRecvCmpnts");

    /************************************************************************/
    /* The following components expect to be called in the receiver thread  */
    /* context - but we are in the sender thread context.  Thus we need     */
    /* to decouple the calls to these functions.                            */
    /************************************************************************/
    TRC_NRM((TB, _T("Decoupling calls to CM/UH_Disable")));
    _pCd->CD_DecoupleSyncNotification(CD_RCV_COMPONENT, _pCm,
            CD_NOTIFICATION_FUNC(CCM,CM_Disable), 0);
    _pCd->CD_DecoupleSyncNotification(CD_RCV_COMPONENT, _pUh,
            CD_NOTIFICATION_FUNC(CUH,UH_Disconnect), 0);

    DC_END_FN();
} /* CCDisconnectShareRecvCmpnts */


/****************************************************************************/
// CCEnableShareSendCmpnts
//
// Enables the send-side share components. Called after sending
// ConfirmActivePDU (containing client capabilities) to the server.
/****************************************************************************/
inline void DCINTERNAL CCC::CCEnableShareSendCmpnts(void)
{
    DC_BEGIN_FN("CCEnableShareSendCmpnts");

    // The following components expect to be called in the sender thread
    // context - which is the context we're currently in. So we can just
    // call the functions directly.
    TRC_NRM((TB, _T("Calling IH/FS/FC/OR_Enable")));
    _pIh->IH_Enable();

    // Enable fonts.  This becomes an empty function now because we only
    // send a zero font PDU from UH.
    _pFs->FS_Enable();

    // UH_Enable() is called when the DemandActivePDU is received, but the
    // persistent bitmap cache keys need to be sent after the sync and control
    // PDUs at this time. Call within the send thread context because that is
    // where this code expects to be called.
    // The PersistentKey PDUs have to be sent out before Font PDUs in the protocol.
    // So font list is sent out from UH code after persistent keys.
    _pUh->UH_SendPersistentKeysAndFontList();

    _pOr->OR_Enable();

    DC_END_FN();
} /* CCEnableShareSendCmpnts */


/****************************************************************************/
/* Name:      CCDisableShareSendCmpnts                                      */
/*                                                                          */
/* Purpose:   Disables the send-side share components.                      */
/****************************************************************************/
inline void DCINTERNAL CCC::CCDisableShareSendCmpnts(void)
{
    DC_BEGIN_FN("CCDisableShareSendCmpnts");

    // The following components expect to be called in the sender thread
    // context - which is what we are in - so we can just call these
    // functions directly.
    TRC_NRM((TB, _T("Calling OR/IH/FC/FS_Disable")));
    _pOr->OR_Disable();
    _pIh->IH_Disable();

    _pFs->FS_Disable();

    DC_END_FN();
} /* CCDisableShareSendCmpnts */


/****************************************************************************/
/* CC FSM                                                                   */
/*                                                                          */
/* EVENTS                          STATES                                   */
/* 0 CC_EVT_STARTCONNECT           0  CC_DISCONNECTED                       */
/* 1 CC_EVT_ONCONNECTOK            1  CC_CONNECTPENDING                     */
/* 2 CC_EVT_ONDEMANDACTIVE         2  CC_WAITINGFORDMNDACT                  */
/* 3 CC_EVT_SENTOK                 3  CC_SENDINGCONFIRMACTIVEPDU1           */
/* 4 CC_EVT_ONBUFFERAVAILABLE      4  CC_SENDINGSYNCPDU1                    */
/* 5 CC_EVT_ONDEACTIVATEALL        5  CC_SENDINGCOOPCONTROL                 */
/* 6 CC_EVT_DISCONNECT             6  CC_SENDINGGRANTCONTROL                */
/* 7 CC_EVT_ONDISCONNECTED         7  CC_CONNECTED                          */
/* 8 CC_EVT_SHUTDOWN               8  CC_SENDING_SHUTDOWNPDU                */
/* 9 CC_EVT_ONSHUTDOWNDENIED       9  CC_SENT_SHUTDOWNPDU                   */
/*10 CC_EVT_DISCONNECT_AND_EXIT    10 CC_PENDING_SHUTDOWN                   */
/*                                                                          */
/* Stt | 0    1    2    3    4    5    6    7    8    9   10                */
/* =========================================================                */
/* Evt |                                                                    */
/* 0   | 1A   /    /    /    /    /    /    /    /    /   /                 */
/*     |                                                                    */
/* 1   | -    2-   /    /    /    /    /    /    /    /   -                 */
/*     |                                                                    */
/* 2   | -    /    3B   /    /    /    /    /    /    /   -                 */
/*     |                                                                    */
/* 3   | /    /    /    4D   5G   6J   7K   /    9-   /   /                 */
/*     |                                                                    */
/* 4   | -    -    -    -C   -F   -I   -J   -    -Z   -   -                 */
/*     |                                                                    */
/* 5   | -    /    /    /    /    /    /    2M  10P  10P  -                 */
/*     |                                                                    */
/* 6   | -    -P   -P   -P   -P   -P   -P   -P   -P   -P  -                 */
/*     |                                                                    */
/* 7   | /    0Y   0Y   0Y   0Y   0Y   0Y   0Y   0T   0T  0T                */
/*     |                                                                    */
/* 8   | -V  10P  10P  10P  10P  10P  10P   8Z   -    -   -                 */
/*     |                                                                    */
/* 9   | -    /    /    /    /    /    /    /    /    7W  -                 */
/*     |                                                                    */
/* 10  | -V  10P  10P  10P  10P  10P  10P  10P  10P  10P  -                 */
/*                                                                          */
/* '/' = illegal event/state combination                                    */
/* '-' = no action                                                          */
/****************************************************************************/
const FSM_ENTRY ccFSM[CC_FSM_INPUTS][CC_FSM_STATES] =
{
/* CC_EVT_STARTCONNECT */
   {{CC_CONNECTPENDING,         ACT_A},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO}},

/* CC_EVT_CONNECTOK */
   {{CC_DISCONNECTED,           ACT_NO},
    {CC_WAITINGFORDEMANDACTIVE, ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {CC_PENDING_SHUTDOWN,       ACT_NO}},

/* CC_EVENT_DEMAND_ACTIVE */
   {{CC_DISCONNECTED,           ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {CC_SENDINGCONFIRMACTIVE1,  ACT_B},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {CC_PENDING_SHUTDOWN,       ACT_NO}},

/* CC_EVENT_SEND_OK */
    {{STATE_INVALID,            ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {CC_SENDINGSYNC1,           ACT_F},
    {CC_SENDINGCOOPCONTROL,     ACT_I},
    {CC_SENDINGGRANTCONTROL,    ACT_J},
    {CC_CONNECTED,              ACT_K},
    {STATE_INVALID,             ACT_NO},
    {CC_SENT_SHUTDOWNPDU,       ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO}},

/* CC_EVENT_BUFFER_AVAILABLE */
    {{CC_DISCONNECTED,          ACT_NO},
    {CC_CONNECTPENDING,         ACT_NO},
    {CC_WAITINGFORDEMANDACTIVE, ACT_NO},
    {CC_SENDINGCONFIRMACTIVE1,  ACT_C},
    {CC_SENDINGSYNC1,           ACT_F},
    {CC_SENDINGCOOPCONTROL,     ACT_I},
    {CC_SENDINGGRANTCONTROL,    ACT_J},
    {CC_CONNECTED,              ACT_NO},
    {CC_SENDING_SHUTDOWNPDU,    ACT_Z},
    {CC_SENT_SHUTDOWNPDU,       ACT_NO},
    {CC_PENDING_SHUTDOWN,       ACT_NO}},

/* CC_EVENT_DEACTIVATEALL */
    {{CC_DISCONNECTED,          ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {CC_WAITINGFORDEMANDACTIVE, ACT_M},
    {CC_PENDING_SHUTDOWN,       ACT_P},
    {CC_PENDING_SHUTDOWN,       ACT_P},
    {CC_PENDING_SHUTDOWN,       ACT_NO}},

/* CC_EVENT_DISCONNECT */
    {{CC_DISCONNECTED,          ACT_NO},
    {CC_CONNECTPENDING,         ACT_P},
    {CC_WAITINGFORDEMANDACTIVE, ACT_P},
    {CC_SENDINGCONFIRMACTIVE1,  ACT_P},
    {CC_SENDINGSYNC1,           ACT_P},
    {CC_SENDINGCOOPCONTROL,     ACT_P},
    {CC_SENDINGGRANTCONTROL,    ACT_P},
    {CC_CONNECTED,              ACT_P},
    {CC_SENDING_SHUTDOWNPDU,    ACT_P},
    {CC_SENT_SHUTDOWNPDU,       ACT_P},
    {CC_PENDING_SHUTDOWN,       ACT_NO}},

/* CC_EVENT_ONDISCONNECTED */
    {{STATE_INVALID,            ACT_NO},
    {CC_DISCONNECTED,           ACT_Y},
    {CC_DISCONNECTED,           ACT_Y},
    {CC_DISCONNECTED,           ACT_Y},
    {CC_DISCONNECTED,           ACT_Y},
    {CC_DISCONNECTED,           ACT_Y},
    {CC_DISCONNECTED,           ACT_Y},
    {CC_DISCONNECTED,           ACT_Y},
    {CC_DISCONNECTED,           ACT_T},
    {CC_DISCONNECTED,           ACT_T},
    {CC_DISCONNECTED,           ACT_T}},

/* CC_EVENT_SHUTDOWN */
    {{CC_DISCONNECTED,           ACT_V},
    {CC_PENDING_SHUTDOWN,        ACT_P},
    {CC_PENDING_SHUTDOWN,        ACT_P},
    {CC_PENDING_SHUTDOWN,        ACT_P},
    {CC_PENDING_SHUTDOWN,        ACT_P},
    {CC_PENDING_SHUTDOWN,        ACT_P},
    {CC_PENDING_SHUTDOWN,        ACT_P},
    {CC_SENDING_SHUTDOWNPDU,     ACT_Z},
    {CC_SENDING_SHUTDOWNPDU,     ACT_NO},
    {CC_SENT_SHUTDOWNPDU,        ACT_NO},
    {CC_PENDING_SHUTDOWN,        ACT_NO}},

/* CC_EVENT_ON_SHUTDOWN_DENIED */
   {{CC_DISCONNECTED,           ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {STATE_INVALID,             ACT_NO},
    {CC_CONNECTED,              ACT_W},
    {CC_PENDING_SHUTDOWN,       ACT_NO}},

/* CC_EVENT_DISCONNECT_AND_EXIT */
    {{CC_DISCONNECTED,           ACT_V},
    {CC_PENDING_SHUTDOWN,        ACT_P},
    {CC_PENDING_SHUTDOWN,        ACT_P},
    {CC_PENDING_SHUTDOWN,        ACT_P},
    {CC_PENDING_SHUTDOWN,        ACT_P},
    {CC_PENDING_SHUTDOWN,        ACT_P},
    {CC_PENDING_SHUTDOWN,        ACT_P},
    {CC_PENDING_SHUTDOWN,        ACT_P},
    {CC_PENDING_SHUTDOWN,        ACT_P},
    {CC_PENDING_SHUTDOWN,        ACT_P},
    {CC_PENDING_SHUTDOWN,        ACT_NO}}
};

/****************************************************************************/
// CCFSMProc
//
// Runs the CC finite state machine based on event inputs.
/****************************************************************************/
void DCINTERNAL CCC::CCFSMProc(unsigned event, ULONG_PTR data, DCUINT dataLen)
{
    BOOL     sendRc  = TRUE;
    unsigned action  = 0;
    PCONNECTSTRUCT pConnect;
    DCSIZE         desktopSize;
    HRESULT        hr;

    DC_BEGIN_FN("CCFSMProc");

    TRC_ASSERT(((0==data && 0==dataLen) ||
                (0!=data && 0!=dataLen)),
               (TB, _T("data and dataLen should both be set or NULL")));

    // Run the FSM.
    EXECUTE_FSM(ccFSM, event, _CC.fsmState, action, eventString, stateString);

    switch (action) {
        case ACT_A:
        {
            BYTE UserData[sizeof(RNS_UD_CS_CORE) + sizeof(TS_UD_CS_CLUSTER)];
            RNS_UD_CS_CORE *pCoreData;
            TS_UD_CS_CLUSTER *pClusterData;
            TCHAR CompName[sizeof(pCoreData->clientName) / sizeof(UINT16)];

            TRC_NRM((TB, _T("ACT_A: begin connection process")));

            //
            // Flag that safe checksum settings have not been set yet
            // allowing them to be set on the first capabilities negotiation
            // we don't allow them to be reconfigured as it's a per-link 
            // setting rather than something that needs to be reconfigured
            // when shadowing.
            //
            _CC.fSafeChecksumSettingsSet = FALSE;


            // We create here two different GCC user data sub-blocks (core
            // and cluster). Memset the entire space and create sub-pointers
            // for the individual parts.
            memset(UserData, 0, sizeof(UserData));
            pCoreData = (RNS_UD_CS_CORE *)UserData;
            pClusterData = (TS_UD_CS_CLUSTER *)
                    (UserData + sizeof(RNS_UD_CS_CORE));

            // Incomplete Connect - need to break out address.
            pConnect = (PCONNECTSTRUCT)data;
            TRC_ASSERT((pConnect != NULL), (TB, _T("No connection data")));

            // Start creating the core data.
            pCoreData->header.type = RNS_UD_CS_CORE_ID;
            pCoreData->header.length = sizeof(RNS_UD_CS_CORE);
            pCoreData->version = RNS_UD_VERSION;

            pCoreData->desktopWidth  = pConnect->desktopWidth;
            pCoreData->desktopHeight = pConnect->desktopHeight;

            //Indicate early support for error info PDU
            //We can't do this during caps negotiation because
            //that happens after licensing which could make use
            //of this PDU.
            // 
            pCoreData->earlyCapabilityFlags = RNS_UD_CS_SUPPORT_ERRINFO_PDU;

            // Add desktop size to combined caps structure.
            _ccCombinedCapabilities.bitmapCapabilitySet.desktopWidth =
                    pConnect->desktopWidth;
            _ccCombinedCapabilities.bitmapCapabilitySet.desktopHeight =
                    pConnect->desktopHeight;

            // Pass the desktop size to UT.
            desktopSize.width = pConnect->desktopWidth;
            desktopSize.height = pConnect->desktopHeight;
            _pUi->UI_SetDesktopSize(&desktopSize);

            // Call UH_SetConnectOptions with the connect flags. This call
            // must happen after the desktop size has been sent to UT.
            // Make sure that we haven't set any flags in the high word, as
            // these will get dropped if DCUINT is 16 bits.
            TRC_ASSERT((0 == HIWORD(pConnect->connectFlags)),
                    (TB, _T("Set flags in high word")));
            _pCd->CD_DecoupleSimpleNotification(CD_RCV_COMPONENT,
                    _pUh,
                    CD_NOTIFICATION_FUNC(CUH,UH_SetConnectOptions),
                    (ULONG_PTR)pConnect->connectFlags);

#ifdef DC_HICOLOR
            pCoreData->colorDepth = RNS_UD_COLOR_8BPP;

            // Set up the full hicolor support. We advertise support for
            // all the depths we can manage; if we don't then get the depth
            // the UI actually asked for, well, it can end the connection
            // if it so chooses.
            // Note that Win16 can only support 15bpp if running in a
            // suitable screen mode.
            pCoreData->supportedColorDepths = RNS_UD_15BPP_SUPPORT |
                    RNS_UD_16BPP_SUPPORT |
                    RNS_UD_24BPP_SUPPORT;
#endif

            switch (pConnect->colorDepthID) {
                // The Server supports both 4bpp & 8bpp Clients.  However,
                // a beta2 Server supported only 8bpp, and rejected Clients
                // specifying 4bpp.
                //
                // Therefore, always set colorDepth (the beta2 field) to
                // 8bpp, and set postBeta2ColorDepth (the new field) to the
                // real value.

#ifndef DC_HICOLOR
                // Always set preferredBitsPerPixel to 8, as that is the
                // protocol color depth that we expect, irrespective of the
                // display color depth.
#endif

                case CO_BITSPERPEL4:
#ifndef DC_HICOLOR
                    pCoreData->colorDepth = RNS_UD_COLOR_8BPP;
#endif
                    pCoreData->postBeta2ColorDepth = RNS_UD_COLOR_4BPP;
#ifdef  DC_HICOLOR
                    pCoreData->highColorDepth  = 4;
#endif
                    _ccCombinedCapabilities.bitmapCapabilitySet
                                                   .preferredBitsPerPixel = 8;
                    _pUi->UI_SetColorDepth(4);
                    break;

                case CO_BITSPERPEL8:
#ifndef DC_HICOLOR
                    pCoreData->colorDepth = RNS_UD_COLOR_8BPP;
#endif
                    pCoreData->postBeta2ColorDepth = RNS_UD_COLOR_8BPP;
#ifdef DC_HICOLOR
                    pCoreData->highColorDepth       = 8;
#endif
                    _ccCombinedCapabilities.bitmapCapabilitySet
                                                   .preferredBitsPerPixel = 8;
                    _pUi->UI_SetColorDepth(8);
                    break;

#ifdef DC_HICOLOR
                case CO_BITSPERPEL24:
                    pCoreData->postBeta2ColorDepth = RNS_UD_COLOR_8BPP;
                    pCoreData->highColorDepth = 24;
                    _ccCombinedCapabilities.bitmapCapabilitySet.
                            preferredBitsPerPixel = 24;
                    _pUi->UI_SetColorDepth(24);
                    break;

                case CO_BITSPERPEL15:
                    pCoreData->postBeta2ColorDepth  = RNS_UD_COLOR_8BPP;
                    pCoreData->highColorDepth       = 15;
                    _ccCombinedCapabilities.bitmapCapabilitySet.
                            preferredBitsPerPixel = 15;
                    _pUi->UI_SetColorDepth(15);
                    break;

                case CO_BITSPERPEL16:
                    pCoreData->postBeta2ColorDepth  = RNS_UD_COLOR_8BPP;
                    pCoreData->highColorDepth       = 16;
                    _ccCombinedCapabilities.bitmapCapabilitySet.
                            preferredBitsPerPixel = 16;
                    _pUi->UI_SetColorDepth(16);
                    break;
#endif

                default:
                    TRC_ABORT((TB, _T("Unsupported color depth %d"),
                                   pConnect->colorDepthID));
                    break;
            }

            // SAS sequence.
            pCoreData->SASSequence = pConnect->sasSequence;

            // The keyboard information is passed to the Server in both the
            // userdata and the T.128 capabilites.
            pCoreData->keyboardLayout = pConnect->keyboardLayout;

            TRC_NRM((TB, _T("Set Caps kbdtype %#lx"), pCoreData->keyboardLayout));
            _ccCombinedCapabilities.inputCapabilitySet.keyboardLayout =
                    pCoreData->keyboardLayout;

            // The keyboard sub type information is passed to the Server in
            // both the userdata and the T.128 capabilites.
            pCoreData->keyboardType        = pConnect->keyboardType;
            pCoreData->keyboardSubType     = pConnect->keyboardSubType;
            pCoreData->keyboardFunctionKey = pConnect->keyboardFunctionKey;

            TRC_NRM((TB, _T("Set Caps kbd type %#lx sub type %#lx func key %#lx"),
                    pCoreData->keyboardType,
                    pCoreData->keyboardSubType,
                    pCoreData->keyboardFunctionKey));
            _ccCombinedCapabilities.inputCapabilitySet.keyboardType =
                    pCoreData->keyboardType;
            _ccCombinedCapabilities.inputCapabilitySet.keyboardSubType =
                    pCoreData->keyboardSubType;
            _ccCombinedCapabilities.inputCapabilitySet.keyboardFunctionKey =
                    pCoreData->keyboardFunctionKey;

            // The IME file name information is passed to the Server in
            // both the userdata and the T.128 capabilites.
#ifdef UNICODE
            hr = StringCchCopy(pCoreData->imeFileName,
                               SIZE_TCHARS(pCoreData->imeFileName),
                               pConnect->imeFileName);
            if (SUCCEEDED(hr)) {
                hr = StringCchCopy(
                        _ccCombinedCapabilities.inputCapabilitySet.imeFileName,
                        SIZE_TCHARS(_ccCombinedCapabilities.inputCapabilitySet.imeFileName),
                        pCoreData->imeFileName);
            }

            //
            // Failure is not fatal just zero out the IME filenames
            //
            if (FAILED(hr)) {
                ZeroMemory(pCoreData->imeFileName, sizeof(pCoreData->imeFileName));
                ZeroMemory(
                    _ccCombinedCapabilities.inputCapabilitySet.imeFileName,
                    sizeof(_ccCombinedCapabilities.inputCapabilitySet.imeFileName));
            }
#else
            // Manually translate the character array into the Unicode buffer.
            // ASCII only.
            {
                int i = 0;
                while (pConnect->imeFileName[i] && i < TS_MAX_IMEFILENAME) {
                    pCoreData->imeFileName[i] =
                            _ccCombinedCapabilities.inputCapabilitySet.
                            imeFileName[i] =
                            (UINT16)pConnect->imeFileName[i];
                    i++;
                }
                pCoreData->imeFileName[i] = 0;
                _ccCombinedCapabilities.inputCapabilitySet.imeFileName[i] = 0;
            }
#endif

            // Client build #.
            pCoreData->clientBuild = DCVER_BUILD_NUMBER;

            // Client computer name. gethostname() returns a full domain-
            // type name which we need to parse to take only the machine
            // name up to the first dot.
            pCoreData->clientName[0] = 0;

            //new core field added for beta3 Whistler
            pCoreData->clientDigProductId[0] = 0;
            {
                //get the digital product id from the registry
                HKEY hKey = NULL;
                if( RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_WINDOWS_KEY, 0, KEY_READ, &hKey) == ERROR_SUCCESS )
                {
                    //failure not fatal; we can use the computername in the worst case.                                     
                    DWORD dwType = REG_SZ;
                    DWORD dwSize = sizeof( pCoreData->clientDigProductId );
                    RegQueryValueEx( hKey, 
                                        _T("ProductId"), NULL, &dwType,
                                        (LPBYTE)pCoreData->clientDigProductId, 
                                        &dwSize
                                        );
                    if (hKey)
                        RegCloseKey( hKey );
                    hKey = NULL;
               }                        
                        

            if (_pUt->UT_GetComputerName(CompName,
                    sizeof(CompName) / sizeof(TCHAR))) {
#ifdef UNICODE
                TRC_NRM((TB, _T("Sending unicode client computername")));
                hr = StringCchCopy(pCoreData->clientName,
                                   SIZE_TCHARS(pCoreData->clientName),
                                   CompName);
                if (FAILED(hr)) {
                    TRC_ERR((TB,_T("Compname string copy failed: 0x%x"), hr));
                }
#else // UNICODE
#ifdef OS_WIN32
                {
                    ULONG ulRetVal;

                    TRC_NRM((TB, _T("Translating and sending unicode client ")
                            "computername"));

                    ulRetVal = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                            CompName, -1, pCoreData->clientName,
                            sizeof(pCoreData->clientName) /
                            sizeof(pCoreData->clientName[0]));
                    pCoreData->clientName[ulRetVal] = 0;
                }
#else // !OS_WIN32
                // Manually translate the character array into the
                // Unicode buffer.
                // This will only work for code page 1252, so
                // non-latin Win3.11 clients that use non-Latin
                // computer names will come as a random jumble of high
                // ANSI characters. Fix this next time.
                int i = 0;
                while (CompName[i]) {
                    pCoreData->clientName[i] = (DCUINT16)CompName[i];
                    i++;
                }
                pCoreData->clientName[i] = 0;
#endif // OS_WIN32
#endif // UNICODE
                }
            }

            // New core data fields added post Win2000 beta 3
            pCoreData->clientProductId = 1;
            pCoreData->serialNumber = 0;

            // Now set up the clustering data. We indicate that the client
            // supports redirection (TS_SERVER_REDIRECT_PDU). If we are in the
            // midst of a redirection, we set up the session ID fields.
            pClusterData->header.type = TS_UD_CS_CLUSTER_ID;
            pClusterData->header.length = sizeof(TS_UD_CS_CLUSTER);
            pClusterData->Flags = TS_CLUSTER_REDIRECTION_SUPPORTED;

            pClusterData->Flags &= ~TS_CLUSTER_REDIRECTION_VERSION;
            pClusterData->Flags |= TS_CLUSTER_REDIRECTION_VERSION4 << 2;

            if(_pUi->UI_GetConnectToServerConsole()) {
                pClusterData->Flags |=
                        TS_CLUSTER_REDIRECTED_SESSIONID_FIELD_VALID;
                //Console is session ID 0
                pClusterData->RedirectedSessionID = 0;
            }
            else if (_pUi->UI_GetDoRedirection()) {
                // redirection for purposes other than connecting to console
                // e.g load balancing
                pClusterData->Flags |=
                        TS_CLUSTER_REDIRECTED_SESSIONID_FIELD_VALID;
                pClusterData->RedirectedSessionID =
                        _pUi->UI_GetRedirectionSessionID();
                _pUi->UI_ClearDoRedirection();
            }

            if (_pUi->UI_GetUseSmartcardLogon()) {
                pClusterData->Flags |= TS_CLUSTER_REDIRECTED_SMARTCARD;
            }

            _pSl->SL_Connect(pConnect->bInitiateConnect, pConnect->RNSAddress, 
                    pConnect->transportType, SL_PROTOCOL_T128, UserData,
                    sizeof(RNS_UD_CS_CORE) + sizeof(TS_UD_CS_CLUSTER));
        }
        break;


        case ACT_B:
        {
            TRC_NRM((TB, _T("ACT_B: DemandActive - send ConfirmActive")));

            /****************************************************************/
            /* The server is requesting that we start a share.  The last    */
            /* thing we do in this action is reply to the server with a     */
            /* confirm active and once the server receives it               */
            /* we are in a share as far as the server is concerned so now   */
            /* is the time to store connection information.  Call           */
            /* CCShareStart to do this.                                     */
            /****************************************************************/
            TRC_ASSERT((data != 0), (TB, _T("No data!")));
            BOOL fUseSafeChecksum = FALSE;
            if (SUCCEEDED(CCShareStart((PTS_DEMAND_ACTIVE_PDU)data, dataLen,
                                       &fUseSafeChecksum)))
            {
                /****************************************************************/
                // We also need to enable the share recv-side components at
                // this time. This neds to be done on the receiver thread. Note
                // that we don't enable the send-side components until we've sent
                // all the sync/control PDUs to the server - this keeps things
                // cleaner.
                /****************************************************************/
                CCEnableShareRecvCmpnts();

                /****************************************************************/
                /* Build and send Confirm active on low prioity                 */
                /****************************************************************/
                CCBuildShareHeaders();

                TRC_NRM((TB,_T("Sending ConfirmActivePDU")));

                if (!_CC.fSafeChecksumSettingsSet) {
                    _pSl->SL_SetEncSafeChecksumSC(fUseSafeChecksum);
                }

                CCSendPDU(CC_TYPE_CONFIRMACTIVE,
                          CC_SEND_FLAGS_CONFIRM,
                          TS_CA_NON_DATA_SIZE + TS_MAX_SOURCEDESCRIPTOR +
                                       sizeof(CC_COMBINED_CAPABILITIES),
                          TS_LOWPRIORITY);

                if (!_CC.fSafeChecksumSettingsSet) {
                    //
                    // Notify SL, separate calls for send and recv thread to prevent
                    // races
                    //
                    _pCd->CD_DecoupleSimpleNotification(
                            CD_SND_COMPONENT,
                            _pSl,
                            CD_NOTIFICATION_FUNC(CSL,SL_SetEncSafeChecksumCS),
                            fUseSafeChecksum
                            );
                }

                //
                // Flag that checksum settings are set and don't allow
                // them to be reset until the next connection
                //
                _CC.fSafeChecksumSettingsSet = TRUE;

                /****************************************************************/
                /* Inform the UI that we received DemandActivePDU.              */
                /****************************************************************/
                _pCd->CD_DecoupleSyncNotification(
                        CD_UI_COMPONENT,
                        _pUi,
                        CD_NOTIFICATION_FUNC(CUI,UI_OnDemandActivePDU),
                        0
                        );
            }
        }
        break;

        case ACT_C:
        {
            TRC_ALT((TB, _T("ACT_C: retry send of lowPri ConfirmActive")));

            /****************************************************************/
            /* Build and send Confirm active on low prioity                 */
            /****************************************************************/
            CCBuildShareHeaders();

            CCSendPDU(CC_TYPE_CONFIRMACTIVE,
                      CC_SEND_FLAGS_CONFIRM,
                      TS_CA_NON_DATA_SIZE + TS_MAX_SOURCEDESCRIPTOR +
                                   sizeof(CC_COMBINED_CAPABILITIES),
                      TS_LOWPRIORITY);
        }
        break;

        case ACT_F:
        {
            TRC_NRM((TB, _T("ACT_F: Send synchronize PDU (1)")));
            CCSendPDU(CC_TYPE_SYNCHRONIZE,
                      CC_SEND_FLAGS_OTHER,
                      TS_SYNC_PDU_SIZE,
                      TS_LOWPRIORITY);
        }
        break;

        case ACT_I:
        {
            TRC_NRM((TB, _T("ACT_I:  Send co-operate control PDU")));
            CCSendPDU(CC_TYPE_COOPCONTROL,
                      CC_SEND_FLAGS_DATA,
                      TS_CONTROL_PDU_SIZE,
                      TS_MEDPRIORITY);
        }
        break;

        case ACT_J:
        {
            TRC_NRM((TB, _T("ACT_J: Send request control PDU")));
            CCSendPDU(CC_TYPE_REQUESTCONTROL,
                      CC_SEND_FLAGS_DATA,
                      TS_CONTROL_PDU_SIZE,
                      TS_MEDPRIORITY);
        }
        break;

        case ACT_K:
        {
            TRC_NRM((TB, _T("ACT_K: Share has been created - connection OK")));

            /****************************************************************/
            /* Enable the share send components.                            */
            /****************************************************************/
            CCEnableShareSendCmpnts();

            /****************************************************************/
            /* Inform the UI that the connection is now complete.           */
            /****************************************************************/
            _pCd->CD_DecoupleSimpleNotification(CD_UI_COMPONENT,
                                                _pUi,
                                                CD_NOTIFICATION_FUNC(CUI,UI_OnConnected),
                                                (ULONG_PTR) 0);
        }
        break;

        case ACT_M:
        {
            TRC_NRM((TB, _T("ACT_M: clearing up after share termination")));

            /****************************************************************/
            // The share has been terminated by the server so disable all
            // the share components. Note that if the session is reconnected
            // on the server we are not actually disconnecting since we could
            // receive a DemandActivePDU and start the share again.
            /****************************************************************/
            CCDisableShareSendCmpnts();
            CCDisableShareRecvCmpnts();
            CCShareEnd();

            /****************************************************************/
            /* Inform the UI that we received DeactivateAllPDU.  Do it      */
            /* synchronously so it's processed before any disconnection.    */
            /****************************************************************/
            _pCd->CD_DecoupleSyncNotification(CD_UI_COMPONENT,
                                              _pUi,
                                              CD_NOTIFICATION_FUNC(CUI,UI_OnDeactivateAllPDU),
                                              0);

        }
        break;

        case ACT_P:
        {
            /****************************************************************/
            /* Disconnect                                                   */
            /****************************************************************/
            TRC_NRM((TB, _T("ACT_P: disconnect")));
            _pSl->SL_Disconnect();
        }
        break;

        case ACT_T:
        {
            TRC_NRM((TB, _T("ACT_T: disable components and inform UI")));

            /****************************************************************/
            /* We need to disable all the share components.                 */
            /****************************************************************/
            CCDisableShareSendCmpnts();
            CCDisconnectShareRecvCmpnts();
            CCShareEnd();

            /****************************************************************/
            /* Reset the client MCS ID and the channel ID.                  */
            /****************************************************************/
            _pUi->UI_SetClientMCSID(0);
            _pUi->UI_SetChannelID(0);

            /****************************************************************/
            /* Inform UI that shutdown is OK                                */
            /****************************************************************/
            TRC_DBG((TB, _T("ACT_T: calling UI_OnShutDown(SUCCESS)")));
            _pCd->CD_DecoupleSimpleNotification(CD_UI_COMPONENT,
                                                _pUi,
                                                CD_NOTIFICATION_FUNC(CUI,UI_OnShutDown),
                                                (ULONG_PTR) UI_SHUTDOWN_SUCCESS);
        }
        break;

        case ACT_V:
        {
            TRC_NRM((TB, _T("ACT_V: calling UI_OnShutDown(success)")));

            /****************************************************************/
            /* Inform UI that shutdown is OK                                */
            /****************************************************************/
            _pCd->CD_DecoupleSimpleNotification(CD_UI_COMPONENT,
                                                _pUi,
                                                CD_NOTIFICATION_FUNC(CUI,UI_OnShutDown),
                                                (ULONG_PTR) UI_SHUTDOWN_SUCCESS);
        }
        break;

        case ACT_W:
        {
            TRC_NRM((TB, _T("ACT_W: calling UI_OnShutDown(failure)")));

            /****************************************************************/
            /* Inform UI that shutdown has been denied                      */
            /****************************************************************/
            _pCd->CD_DecoupleSimpleNotification(CD_UI_COMPONENT,
                                                _pUi,
                                                CD_NOTIFICATION_FUNC(CUI,UI_OnShutDown),
                                                (ULONG_PTR) UI_SHUTDOWN_FAILURE);
        }
        break;

        case ACT_Y:
        {
            TRC_NRM((TB, _T("ACT_Y: disconnection")));

            /****************************************************************/
            /* We need to disable all the share components.                 */
            /****************************************************************/
            CCDisableShareSendCmpnts();
            CCDisconnectShareRecvCmpnts();
            CCShareEnd();

            /****************************************************************/
            /* Connection has been lost, so we can safely reset the         */
            /* client MCS ID and the channel ID.                            */
            /****************************************************************/
            _pUi->UI_SetClientMCSID(0);
            _pUi->UI_SetChannelID(0);

            /****************************************************************/
            /* Pass the UI the disconnect reason code.  This reason code    */
            /* should not occupy more than 16 bits.                         */
            /****************************************************************/
            TRC_ASSERT((HIWORD(data) == 0),
                       (TB, _T("Disconnect reason code bigger then 16 bits %#x"),
                            HIWORD(data)));

            _pCd->CD_DecoupleSimpleNotification(CD_UI_COMPONENT,
                                                _pUi,
                                                CD_NOTIFICATION_FUNC(CUI,UI_OnDisconnected),
                                                data);
        }
        break;

        case ACT_Z:
        {
            TRC_DBG((TB, _T("ACT_Z: sending ShutDownPDU")));

            /****************************************************************/
            /* Send Shutdown PDU                                            */
            /****************************************************************/
            CCSendPDU(CC_TYPE_SHUTDOWNREQ,
                      CC_SEND_FLAGS_DATA,
                      TS_SHUTDOWN_REQ_PDU_SIZE,
                      TS_HIGHPRIORITY);
        }
        break;

        case ACT_NO:
        {
            TRC_NRM((TB, _T("ACT_NO: Doing nothing")));
        }
        break;

        default:
        {
            TRC_ABORT((TB, _T("Invalid action %u"), action));
        }
        break;
    }

    DC_END_FN();
} /* CC_FSMProc */


/****************************************************************************/
/* Name: CCBuildConfirmActive                                               */
/*                                                                          */
/* Purpose: Fills _CC.pBuffer and _CC.packetLen with a ConfirmActivePDU     */
/*            and its length                                                */
/****************************************************************************/
void DCINTERNAL CCC::CCBuildConfirmActivePDU()
{
    PTS_CONFIRM_ACTIVE_PDU pConfirmActivePDU;
    PBYTE pCombinedCapabilities;

    DC_BEGIN_FN("CCBuildConfirmActivePDU");

    pConfirmActivePDU = (PTS_CONFIRM_ACTIVE_PDU)_CC.pBuffer;
    pConfirmActivePDU->shareControlHeader = _CC.shareControlHeader;

    pConfirmActivePDU->shareControlHeader.pduType =
                          TS_PDUTYPE_CONFIRMACTIVEPDU | TS_PROTOCOL_VERSION;
    pConfirmActivePDU->shareID = _pUi->UI_GetShareID();
    pConfirmActivePDU->originatorID = _pUi->UI_GetServerMCSID();

    /************************************************************************/
    /* Note: source descriptor is a NULL-terminated string.                 */
    /************************************************************************/
    pConfirmActivePDU->lengthSourceDescriptor = (DCUINT16)
                                               DC_ASTRBYTELEN(CC_DUCATI_NAME);
    pConfirmActivePDU->lengthCombinedCapabilities =
                                             sizeof(CC_COMBINED_CAPABILITIES);

    TS_CTRLPKT_LEN(pConfirmActivePDU) =
                    (DCUINT16)(pConfirmActivePDU->lengthSourceDescriptor +
                               pConfirmActivePDU->lengthCombinedCapabilities +
                               TS_CA_NON_DATA_SIZE);
    _CC.packetLen = TS_CTRLPKT_LEN(pConfirmActivePDU);
    TRC_ASSERT((CC_BUFSIZE >= _CC.packetLen),
                                  (TB,_T("CC Buffer not large enough")));

    StringCbCopyA((PCHAR)pConfirmActivePDU->data,
                  sizeof(pConfirmActivePDU->data),
                  CC_DUCATI_NAME);

    /************************************************************************/
    /* Copy the Combined Caps.                                              */
    /************************************************************************/
    pCombinedCapabilities = pConfirmActivePDU->data +
                                               DC_ASTRBYTELEN(CC_DUCATI_NAME);

    DC_MEMCPY(pCombinedCapabilities,
              &_ccCombinedCapabilities,
              sizeof( CC_COMBINED_CAPABILITIES));

    DC_END_FN();
} /* CCBuildConfirmActive */


/****************************************************************************/
/* Name: CCBuildSyncPDU                                                     */
/*                                                                          */
/* Purpose: Fills _CC.pBuffer and _CC.packetLen with a SynchronizePDU       */
/*            and its length                                                */
/****************************************************************************/
void DCINTERNAL CCC::CCBuildSyncPDU()
{
    PTS_SYNCHRONIZE_PDU pSyncPDU;

    DC_BEGIN_FN("CCBuildSyncPDU");

    pSyncPDU = (PTS_SYNCHRONIZE_PDU) _CC.pBuffer;
    pSyncPDU->shareDataHeader = _CC.shareDataHeader;

    _CC.packetLen = TS_SYNC_PDU_SIZE;
    TRC_ASSERT((CC_BUFSIZE >= _CC.packetLen),
                                         (TB,_T("CC Buffer not large enough")));

    TS_DATAPKT_LEN(pSyncPDU) = TS_SYNC_PDU_SIZE;
    pSyncPDU->shareDataHeader.shareControlHeader.pduType
                                = TS_PDUTYPE_DATAPDU | TS_PROTOCOL_VERSION;
    TS_UNCOMP_LEN(pSyncPDU)  = TS_SYNC_UNCOMP_LEN;
    pSyncPDU->shareDataHeader.pduType2 = TS_PDUTYPE2_SYNCHRONIZE;

    pSyncPDU->messageType = TS_SYNCMSGTYPE_SYNC;
    pSyncPDU->targetUser = _pUi->UI_GetServerMCSID();

    DC_END_FN();
} /* CCBuildSync */


/****************************************************************************/
/* Name:      CCBuildShutdownReqPDU                                         */
/*                                                                          */
/* Purpose:   Fills _CC.pBuffer and _CC.packetLen with a ShutdownReqPDU     */
/*            and its length                                                */
/****************************************************************************/
void DCINTERNAL CCC::CCBuildShutdownReqPDU()
{
    PTS_SHUTDOWN_REQ_PDU pShutdownPDU;

    DC_BEGIN_FN("CCBuildShutdownReqPDU");

    pShutdownPDU = (PTS_SHUTDOWN_REQ_PDU) _CC.pBuffer;
    pShutdownPDU->shareDataHeader = _CC.shareDataHeader;

    _CC.packetLen = TS_SHUTDOWN_REQ_PDU_SIZE;
    TRC_ASSERT((CC_BUFSIZE >= _CC.packetLen),
                                         (TB,_T("CC Buffer not large enough")));

    TS_DATAPKT_LEN(pShutdownPDU) = TS_SHUTDOWN_REQ_PDU_SIZE;
    pShutdownPDU->shareDataHeader.shareControlHeader.pduType
                                = TS_PDUTYPE_DATAPDU | TS_PROTOCOL_VERSION;
    TS_UNCOMP_LEN(pShutdownPDU)  = TS_SHUTDOWN_REQ_UNCOMP_LEN;
    pShutdownPDU->shareDataHeader.pduType2 = TS_PDUTYPE2_SHUTDOWN_REQUEST;

    DC_END_FN();
} /* CCBuildShutdownReqPDU */


/****************************************************************************/
/* Name: CCBuildCoopControlPDU                                              */
/*                                                                          */
/* Purpose: Fills _CC.pBuffer and _CC.packetLen with a CoopControlPDU         */
/*            and its length                                                */
/****************************************************************************/
void DCINTERNAL CCC::CCBuildCoopControlPDU()
{
    PTS_CONTROL_PDU pControlPDU;

    DC_BEGIN_FN("CCBuildCoopControlPDU");

    pControlPDU = (TS_CONTROL_PDU*) _CC.pBuffer;
    pControlPDU->shareDataHeader = _CC.shareDataHeader;

    _CC.packetLen = TS_CONTROL_PDU_SIZE;
    TRC_ASSERT((CC_BUFSIZE >= _CC.packetLen),\
                                   (TB,_T("CC Buffer not large enough")));

    TS_DATAPKT_LEN(pControlPDU) = TS_CONTROL_PDU_SIZE;
    pControlPDU->shareDataHeader.shareControlHeader.pduType
                                = TS_PDUTYPE_DATAPDU | TS_PROTOCOL_VERSION;
    TS_UNCOMP_LEN(pControlPDU)  = TS_CONTROL_UNCOMP_LEN;
    pControlPDU->shareDataHeader.pduType2 = TS_PDUTYPE2_CONTROL;

    pControlPDU->action = TS_CTRLACTION_COOPERATE;
    pControlPDU->grantId = 0;
    pControlPDU->controlId = 0;

    DC_END_FN();
} /* CCBuildCoopControl */


/****************************************************************************/
/* Name:    CCSendPDU                                                       */
/*                                                                          */
/* Purpose: Fills and sends a specified PDU on agiven priority              */
/****************************************************************************/
void DCINTERNAL CCC::CCSendPDU(
        unsigned pduTypeToSend,
        unsigned flags,
        unsigned size,
        unsigned priority)
{
    SL_BUFHND bufHandle;

    DC_BEGIN_FN("CCSendPDU");

    if (!_pSl->SL_GetBuffer(size, &_CC.pBuffer, &bufHandle)) {
        // Buffer not available so can't send, try later.
        TRC_ALT((TB, _T("Fail to get buffer for type %u"), pduTypeToSend));
        DC_QUIT;
    }

    switch (pduTypeToSend) {
        case CC_TYPE_CONFIRMACTIVE:
        {
            TRC_DBG((TB, _T("CCSendPDU handling Confirm Active PDU")));
            CCBuildConfirmActivePDU();
        }
        break;

        case CC_TYPE_SYNCHRONIZE:
        {
            CCBuildSyncPDU();
        }
        break;

        case CC_TYPE_COOPCONTROL:
        {
            CCBuildCoopControlPDU();
        }
        break;

        case CC_TYPE_REQUESTCONTROL:
        {
            CCBuildRequestControlPDU();
        }
        break;

        case CC_TYPE_SHUTDOWNREQ:
        {
            CCBuildShutdownReqPDU();
        }
        break;

        default:
        {
            TRC_ABORT((TB,_T("Bad PDU type")));
        }
        break;
    }

    _pSl->SL_SendPacket(_CC.pBuffer,
                  _CC.packetLen,
                  flags,
                  bufHandle,
                  _pUi->UI_GetClientMCSID(),
                  _pUi->UI_GetChannelID(),
                  priority);

    _CC.pBuffer = NULL;

    CCFSMProc(CC_EVT_SENTOK, 0, 0);

DC_EXIT_POINT:
    DC_END_FN();
} /* CCSendPDU */


/****************************************************************************/
/* Name: CCBuildRequestControlPDU                                           */
/*                                                                          */
/* Purpose: Fills _CC.pBuffer and _CC.packetLen with a RequestControlPDU      */
/*            and its length                                                */
/****************************************************************************/
void DCINTERNAL CCC::CCBuildRequestControlPDU()
{
    TS_CONTROL_PDU * pControlPDU;

    DC_BEGIN_FN("CCBuildRequestControlPDU");

    pControlPDU = (PTS_CONTROL_PDU) _CC.pBuffer;
    pControlPDU->shareDataHeader = _CC.shareDataHeader;

    _CC.packetLen = TS_CONTROL_PDU_SIZE;
    TRC_ASSERT((CC_BUFSIZE >= _CC.packetLen),\
                                          (TB,_T("CC Buffer not large enough")));

    pControlPDU->shareDataHeader.shareControlHeader.pduType
                                   = TS_PDUTYPE_DATAPDU | TS_PROTOCOL_VERSION;
    TS_DATAPKT_LEN(pControlPDU)           = TS_CONTROL_PDU_SIZE;
    TS_UNCOMP_LEN(pControlPDU)            = TS_CONTROL_UNCOMP_LEN;
    pControlPDU->shareDataHeader.pduType2 = TS_PDUTYPE2_CONTROL;

    pControlPDU->action    = TS_CTRLACTION_REQUEST_CONTROL;
    pControlPDU->grantId   = 0;
    pControlPDU->controlId = 0;

    DC_END_FN();
} /* CCBuildRequestControl */


/****************************************************************************/
/* Name:      CCBuildShareHeaders                                           */
/*                                                                          */
/* Purpose:   Fills in Core ShareControl and ShareData headers              */
/****************************************************************************/
void DCINTERNAL CCC::CCBuildShareHeaders()
{
    DC_BEGIN_FN("CCBuildShareHeaders");

    _CC.shareControlHeader.totalLength = 0;          /* sender sets this     */
    _CC.shareControlHeader.pduType     = 0;          /* sender sets this     */
    _CC.shareControlHeader.pduSource   = _pUi->UI_GetClientMCSID();

    _CC.shareDataHeader.shareControlHeader = _CC.shareControlHeader;
    _CC.shareDataHeader.shareID            = _pUi->UI_GetShareID();
    _CC.shareDataHeader.pad1               = 0;
    _CC.shareDataHeader.streamID           = TS_STREAM_LOW;
    _CC.shareDataHeader.uncompressedLength = 0;      /* sender sets this     */
    _CC.shareDataHeader.pduType2           = 0;      /* sender sets this     */
    _CC.shareDataHeader.generalCompressedType  = 0;
    _CC.shareDataHeader.generalCompressedLength= 0;

    DC_END_FN();
} /* CCBuildShareHeaders */


/****************************************************************************/
/* Name:      CCShareStart                                                  */
/*                                                                          */
/* Purpose:   Called when a share is established.                           */
/****************************************************************************/
HRESULT DCINTERNAL CCC::CCShareStart(PTS_DEMAND_ACTIVE_PDU pPDU, DCUINT dataLen,
                                     PBOOL pfSecureChecksum)
{
    HRESULT hrc = S_OK;
    UINT32 sessionId;
    PTS_INPUT_CAPABILITYSET pInputCaps;
    PTS_ORDER_CAPABILITYSET pOrderCaps;
    DCSIZE desktopSize;
    PTS_BITMAP_CAPABILITYSET pBitmapCaps;
    PTS_VIRTUALCHANNEL_CAPABILITYSET pVCCaps = NULL;
    PTS_DRAW_GDIPLUS_CAPABILITYSET pDrawGdipCaps = NULL;

    DC_BEGIN_FN("CCShareStart");

    TRC_ASSERT((pPDU != NULL), (TB, _T("Null demand active PDU")));

    /************************************************************************/
    /* SECURITY: We verified that this PDU has at least enough data for the */
    /* TS_DEMAND_ACTIVE_PDU struct in aco.cpp!CO_OnPacketReceived.          */
    /************************************************************************/

    /************************************************************************/
    /* Keep a copy of the server's share ID.                                */
    /************************************************************************/
    TRC_NRM((TB, _T("Save shareID %#x"), pPDU->shareID));
    _pUi->UI_SetShareID(pPDU->shareID);

    /************************************************************************/
    /* Let UT know about the server's MCS user ID.                          */
    /************************************************************************/
    _pUi->UI_SetServerMCSID(pPDU->shareControlHeader.pduSource);

    /************************************************************************/
    /* Verify that the capabilities offset is within the PDU, and the cap   */
    /* length fits within the PDU.  Throughout this function, UT_GetCapsSet */
    /* is called with pointers to the caps and the caps length.             */
    /*                                                                      */
    /* Also, note that the last 4 bytes of this PDU can be the sessionId,   */
    /* but if someone's going to send the cap length as garbage, there's no */
    /* reason to force the cap length to end 4 bytes before the packet end. */
    /************************************************************************/
    if (!IsContainedMemory(pPDU, dataLen, pPDU->data + pPDU->lengthSourceDescriptor, pPDU->lengthCombinedCapabilities))
    {
        TRC_ABORT((TB, _T("Capabilities (%u) is larger than packet size"), pPDU->lengthCombinedCapabilities));
        _pSl->SLSetReasonAndDisconnect(SL_ERR_INVALIDPACKETFORMAT);
        hrc = E_ABORT;
        DC_QUIT;
    }

    PTS_GENERAL_CAPABILITYSET pGeneralCaps;
    pGeneralCaps = (PTS_GENERAL_CAPABILITYSET) _pUt->UT_GetCapsSet(
            pPDU->lengthCombinedCapabilities,
            (PTS_COMBINED_CAPABILITIES)(pPDU->data +
            pPDU->lengthSourceDescriptor),
            TS_CAPSETTYPE_GENERAL);
    TRC_ASSERT((pGeneralCaps != NULL),(TB,_T("General capabilities not found")));
    
    //
    // A word about the safe checksum fix:
    // The feature is a fix to salt the checksum with a running counter
    // The problem is that checksumming plaintext leaves us vulnerable
    // to frequency analysis of the checksums (since input packets for the same
    // scancode will return the same checksum).
    //
    // To negotiate caps for this encryption setting
    // a handshake must occur where one side requests the feature and the other side
    // ackownledges it before you can start encrypting in the new way. The packets
    // also have a bit set in the security header identifying which type of checksum
    // is in effect.
    //
    // If the server advertises support for receiving C->S newly checksummed data
    // then acknowlege it here, this completes the handshake any further data
    // transfers to the server will now checksum the encrypted bytes.
    //
    // Also the server can now start sending us data in the checksummed encrypted format
    //
    
    if (pGeneralCaps &&
        pGeneralCaps->extraFlags & TS_ENC_SECURE_CHECKSUM) {
        _ccCombinedCapabilities.generalCapabilitySet.extraFlags |=
            TS_ENC_SECURE_CHECKSUM;
        *pfSecureChecksum = TRUE;
    }
    else {
        _ccCombinedCapabilities.generalCapabilitySet.extraFlags &=
            ~TS_ENC_SECURE_CHECKSUM;
        *pfSecureChecksum = FALSE;
    }

    /************************************************************************/
    /* If the call supports shadowing of sessions bigger than our current   */
    /* desktop size, then we'd better take note of the returned size        */
    /************************************************************************/
    pBitmapCaps = (PTS_BITMAP_CAPABILITYSET) _pUt->UT_GetCapsSet(
            pPDU->lengthCombinedCapabilities,
            (PTS_COMBINED_CAPABILITIES)(pPDU->data +
            pPDU->lengthSourceDescriptor),
            TS_CAPSETTYPE_BITMAP);
    TRC_ASSERT((pBitmapCaps != NULL),(TB,_T("Bitmap capabilities not found")));
    if (pBitmapCaps && pBitmapCaps->desktopResizeFlag == TS_CAPSFLAG_SUPPORTED)
    {
        TRC_ALT((TB, _T("New desktop size %u x %u"),
                 pBitmapCaps->desktopWidth,
                 pBitmapCaps->desktopHeight));

        /********************************************************************/
        /* Pass the desktop size to UT - it will be picked up in UH_Enable  */
        /********************************************************************/
        desktopSize.width  = pBitmapCaps->desktopWidth;
        desktopSize.height = pBitmapCaps->desktopHeight;
        _pUi->UI_OnDesktopSizeChange(&desktopSize);

        /********************************************************************/
        /* And notify the client                                            */
        /********************************************************************/
        PostMessage(_pUi->UI_GetUIMainWindow(), WM_DESKTOPSIZECHANGE, 0,
                    MAKELPARAM(desktopSize.width, desktopSize.height) );
    }

#ifdef DC_HICOLOR
    /************************************************************************/
    /* Set up the returned color depth                                      */
    /************************************************************************/
    if( pBitmapCaps )
    {
        TRC_ALT((TB, _T("Server returned %u bpp"), pBitmapCaps->preferredBitsPerPixel));
        _pUi->UI_SetColorDepth(pBitmapCaps->preferredBitsPerPixel);
    }
#endif

    /************************************************************************/
    /* Pass the input capabilities to IH.                                   */
    /************************************************************************/
    pInputCaps = (PTS_INPUT_CAPABILITYSET)_pUt->UT_GetCapsSet(
            pPDU->lengthCombinedCapabilities,
           (PTS_COMBINED_CAPABILITIES)(pPDU->data +
           pPDU->lengthSourceDescriptor),
           TS_CAPSETTYPE_INPUT);
    TRC_ASSERT((pInputCaps != NULL),(TB,_T("Input capabilities not found")));
    if (pInputCaps != NULL)
        _pIh->IH_ProcessInputCaps(pInputCaps);

    /************************************************************************/
    /* The orders caps go to UH.                                            */
    /************************************************************************/
    pOrderCaps = (PTS_ORDER_CAPABILITYSET)_pUt->UT_GetCapsSet(
            pPDU->lengthCombinedCapabilities,
           (PTS_COMBINED_CAPABILITIES)(pPDU->data +
           pPDU->lengthSourceDescriptor),
           TS_CAPSETTYPE_ORDER);
    TRC_ASSERT((pOrderCaps != NULL),(TB,_T("Order capabilities not found")));
    if (pOrderCaps != NULL)
        _pUh->UH_ProcessServerCaps(pOrderCaps);

    /************************************************************************/
    // Send the bitmap cache HOSTSUPPORT caps to UH, whether or not present.
    /************************************************************************/
    _pUh->UH_ProcessBCHostSupportCaps(
            (PTS_BITMAPCACHE_CAPABILITYSET_HOSTSUPPORT)_pUt->UT_GetCapsSet(
            pPDU->lengthCombinedCapabilities,
            (PTS_COMBINED_CAPABILITIES)(pPDU->data +
            pPDU->lengthSourceDescriptor),
            TS_CAPSETTYPE_BITMAPCACHE_HOSTSUPPORT));

    //
    // Get virtual channel caps
    //
    pVCCaps = (PTS_VIRTUALCHANNEL_CAPABILITYSET)_pUt->UT_GetCapsSet(
                pPDU->lengthCombinedCapabilities,
                (PTS_COMBINED_CAPABILITIES)(pPDU->data +
                pPDU->lengthSourceDescriptor),
                TS_CAPSETTYPE_VIRTUALCHANNEL);
    if(pVCCaps)
    {
        //Inform VC layer of the capabilities
        _pCChan->SetCapabilities(pVCCaps->vccaps1);
    }
    else
    {
        //No VCCaps, could be an older server. Set default caps
        _pCChan->SetCapabilities(TS_VCCAPS_DEFAULT);
    }

    //
    // Get draw gdiplus caps
    //
    pDrawGdipCaps = (PTS_DRAW_GDIPLUS_CAPABILITYSET)_pUt->UT_GetCapsSet(
                pPDU->lengthCombinedCapabilities,
                (PTS_COMBINED_CAPABILITIES)(pPDU->data +
                pPDU->lengthSourceDescriptor),
                TS_CAPSETTYPE_DRAWGDIPLUS);
    if (pDrawGdipCaps) {
        _pUh->UH_SetServerGdipSupportLevel(pDrawGdipCaps->drawGdiplusSupportLevel);
    }
    else {
        _pUh->UH_SetServerGdipSupportLevel(TS_DRAW_GDIPLUS_DEFAULT);
    }

    /************************************************************************/
    /* Set SessionId                                                        */
    /************************************************************************/
    if (pPDU->shareControlHeader.totalLength >
            (sizeof(TS_DEMAND_ACTIVE_PDU) - 1 + pPDU->lengthSourceDescriptor +
            pPDU->lengthCombinedCapabilities))
    {
        memcpy(&sessionId,
                pPDU->data + pPDU->lengthSourceDescriptor +
                pPDU->lengthCombinedCapabilities,
                sizeof(sessionId));
        TRC_ALT((TB, _T("Session ID: %ld"), sessionId));
    }
    else {
        sessionId = 0;
        TRC_ALT((TB, _T("Session ID is zero"), sessionId));
    }

    _pUi->UI_SetSessionId(sessionId);

DC_EXIT_POINT:
    DC_END_FN();
    return(hrc);
} /* CCShareStart */


/****************************************************************************/
/* Name:      CCShareEnd                                                    */
/*                                                                          */
/* Purpose:   Called when a share ends.                                     */
/****************************************************************************/
void DCINTERNAL CCC::CCShareEnd()
{
    DC_BEGIN_FN("CCShareEnd");

    // Reset ServerMCSID and ChannelID.
    TRC_NRM((TB, _T("Resetting ServerMCSID and ChannelID")));
    _pUi->UI_SetServerMCSID(0);

    // Finally reset the share ID.
    TRC_NRM((TB, _T("Resetting ShareID")));
    _pUi->UI_SetShareID(0);

    DC_END_FN();
} /* CCShareEnd */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\cchan.h ===
/**INC+**********************************************************************/
/* Header:    cchan.h                                                       */
/*                                                                          */
/* Purpose:   Virtual Channel 'internal' API file                           */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log$
**/
/**INC-**********************************************************************/
/****************************************************************************/
/* Include 'external' API file                                              */
/****************************************************************************/

#ifndef _H_CHAN_
#define _H_CHAN_


extern "C" {
#include <cchannel.h>
}

#include "objs.h"
#include "cd.h"
#include "drapi.h"

//
// Enable code that verifies each compression
// by decompressing
//
// #define DEBUG_CCHAN_COMPRESSION 1

class CChan;

/****************************************************************************/
/****************************************************************************/
/* TYPEDEFS                                                                 */
/****************************************************************************/
/****************************************************************************/
/**STRUCT+*******************************************************************/
/* Structure: CHANNEL_INIT_HANDLE                                           */
/*                                                                          */
/* Description: Channel data held per user                                  */
/****************************************************************************/

//NOTE: This structure needs to be exposed to 'internal' plugins e.g rdpdr
//      so the definition is is vchandle.h
//      Internal plugins need to know the structure because they access
//      the lpInternalAddinParam field

#include "vchandle.h"

#define VC_MIN_COMPRESS_INPUT_BUF   50
#define VC_MAX_COMPRESS_INPUT_BUF   CHANNEL_CHUNK_LENGTH
// Size of sample for MPPC compression statistics.
#define VC_MPPC_SAMPLE_SIZE 65535
// Compression scaling factor
#define VC_UNCOMP_BYTES 1024
// Limit to prevent off behaviour
#define VC_COMP_LIMIT   25

#define VC_USER_OUTBUF  (CHANNEL_CHUNK_LENGTH+sizeof(CHANNEL_PDU_HEADER))

#define VC_MAX_COMPRESSED_BUFFER  (CHANNEL_CHUNK_LENGTH*2)

/**STRUCT-*******************************************************************/

/**STRUCT+*******************************************************************/
/* Structure: CHANNEL_DATA                                                  */
/*                                                                          */
/* Description: Information about all channels                              */
/****************************************************************************/
typedef struct tagCHANNEL_DATA
{
    PCHANNEL_OPEN_EVENT_FN  pOpenEventFn;
    PCHANNEL_OPEN_EVENT_EX_FN  pOpenEventExFn;

    DCUINT16                MCSChannelID;
    DCUINT16                pad;
    PCHANNEL_INIT_HANDLE    pInitHandle;
    DCUINT                  status;
#define CHANNEL_STATUS_CLOSED  0
#define CHANNEL_STATUS_OPEN    1
    DCUINT                  priority;
    DCUINT                  SLFlags;
    DCUINT                  VCFlags;
} CHANNEL_DATA, DCPTR PCHANNEL_DATA;
/**STRUCT-*******************************************************************/

/**STRUCT+*******************************************************************/
/* Structure: CHANNEL_WRITE_DECOUPLE                                        */
/*                                                                          */
/* Description:structure passed to IntChannelWrite                          */
/****************************************************************************/
typedef struct tagCHANNEL_WRITE_DECOUPLE
{
    DCUINT32 signature;
#define CHANNEL_DECOUPLE_SIGNATURE 0x43684465  /* "ChDe" */
    LPVOID   pData;
    HPDCVOID pNextData;
    ULONG    dataLength;
    ULONG    dataLeft;
    ULONG    dataSent;
    DWORD    openHandle;
    LPVOID   pUserData;
    DCUINT32 flags;
    unsigned chanOptions;
    struct tagCHANNEL_WRITE_DECOUPLE * pPrev;
    struct tagCHANNEL_WRITE_DECOUPLE * pNext;
} CHANNEL_WRITE_DECOUPLE,
  DCPTR PCHANNEL_WRITE_DECOUPLE,
  DCPTR DCPTR PPCHANNEL_WRITE_DECOUPLE;
/**STRUCT-*******************************************************************/

typedef struct tagDEVICE_PARAMS
{
    WPARAM wParam;
    LPARAM lParam;
    IRDPDR_INTERFACE_OBJ *deviceObj;
} DEVICE_PARAMS, *PDEVICE_PARAMS;
                        
class CCD;
class CSL;
class CUT;
class CUI;


extern "C" {
#ifdef OS_WIN32
BOOL DCAPI
#else //OS_WIN32
BOOL __loadds DCAPI
#endif //OS_WIN32
MSTSCAX_VirtualChannelEntryEx(PCHANNEL_ENTRY_POINTS_EX pEntryPointsEx,
                              PVOID                    pAxCtlInstance);

} // extern "C"

class CChan
{
public:
    CChan(CObjs* objs);
    ~CChan();


public:
    DCVOID DCCALLBACK ChannelOnInitialized(DCVOID);
    
    DCVOID DCCALLBACK ChannelOnTerminating(DCVOID);
    
    DCVOID DCCALLBACK ChannelOnConnected(DCUINT   channelID,
                                         DCUINT32 serverVersion,
                                         PDCVOID  pUserData,
                                         DCUINT   userDataLength);
    
    DCVOID DCCALLBACK ChannelOnDisconnected(DCUINT reason);
    
    DCVOID DCCALLBACK ChannelOnSuspended(DCUINT reason);
    
    DCVOID DCCALLBACK ChannelOnPacketReceived(PDCUINT8   pData,
                                              DCUINT     dataLen,
                                              DCUINT     flags,
                                              DCUINT     userID,
                                              DCUINT     priority);
    
    DCVOID DCCALLBACK ChannelOnBufferAvailable(DCVOID);
    
    DCVOID DCCALLBACK ChannelOnConnecting(PPCHANNEL_DEF ppChannel,
                                          PDCUINT32     pChannelCount);
    
    DCVOID DCCALLBACK ChannelOnInitializing(DCVOID);


    //
    // Per instance versions of external channel API
    //
    UINT VCAPITYPE  IntVirtualChannelInit(
                               PVOID                    pParam,
                               PVOID *                  ppInitHandle,
                               PCHANNEL_DEF             pChannel,
                               INT                      channelCount,
                               DWORD                    versionRequested,
                               PCHANNEL_INIT_EVENT_FN   pChannelInitEventProc,
                               PCHANNEL_INIT_EVENT_EX_FN pChannelInitEventProcEx);

    UINT VCAPITYPE DCEXPORT IntVirtualChannelOpen(
                                 PVOID                  pInitHandle,
                                 PDWORD                 pOpenHandle,
                                 PCHAR                  pChannelName,
                                 PCHANNEL_OPEN_EVENT_FN pChannelOpenEventProc,
                                 PCHANNEL_OPEN_EVENT_EX_FN pChannelOpenEventProcEx);

    UINT VCAPITYPE DCEXPORT IntVirtualChannelClose(DWORD openHandle);

    UINT VCAPITYPE DCEXPORT IntVirtualChannelWrite(DWORD  openHandle,
                                            LPVOID pData,
                                            ULONG  dataLength,
                                            LPVOID pUserData);
    VOID  SetCapabilities(LONG caps);

    void OnDeviceChange(ULONG_PTR);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CChan, OnDeviceChange);

public:
    //
    // Member data
    //


    /****************************************************************************/
    /* Pointer to first Init Handle                                             */
    /****************************************************************************/
    PCHANNEL_INIT_HANDLE        _pInitHandle;
    
    /****************************************************************************/
    /* Pointer to first and last queued write operations - can be accessed only */
    /* on SND thread.                                                           */
    /****************************************************************************/
    PCHANNEL_WRITE_DECOUPLE     _pFirstWrite;
    PCHANNEL_WRITE_DECOUPLE     _pLastWrite;
    
    /****************************************************************************/
    /* State informtation                                                       */
    /****************************************************************************/
    #define CONNECTION_NONE     0
    #define CONNECTION_V1       1
    #define CONNECTION_VC       2
    #define CONNECTION_SUSPENDED    3
    DCUINT                      _connected;
    
    /****************************************************************************/
    /* State information used by IntChannelLoad                                 */
    /****************************************************************************/
    DCBOOL                      _inChannelEntry;
    DCBOOL                      _ChannelInitCalled;
    PCHANNEL_INIT_HANDLE        _newInitHandle;
    
    /****************************************************************************/
    /* Channel data                                                             */
    /****************************************************************************/
    CHANNEL_DEF                 _channel[CHANNEL_MAX_COUNT];
    CHANNEL_DATA                _channelData[CHANNEL_MAX_COUNT];
    DCUINT                      _channelCount;
    
    
    /****************************************************************************/
    /* Channel entry points                                                     */
    /****************************************************************************/
    CHANNEL_ENTRY_POINTS _channelEntryPoints;
    CHANNEL_ENTRY_POINTS_EX _channelEntryPointsEx;

    static CChan* pStaticClientInstance;


private:
    /****************************************************************************/
    /****************************************************************************/
    /* Internal functions (defined later)                                       */
    /****************************************************************************/
    /****************************************************************************/
    DCVOID DCINTERNAL IntChannelCallCallbacks(DCUINT event,
                                              PDCVOID pData,
                                              DCUINT dataLength);
    DCVOID DCINTERNAL IntChannelFreeLibrary(DCUINT value);
    DCVOID DCINTERNAL IntChannelSend(ULONG_PTR value);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CChan, IntChannelSend);
    
    DCVOID DCINTERNAL IntChannelCancelSend(ULONG_PTR value);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CChan, IntChannelCancelSend);

    DCVOID DCINTERNAL IntChannelWrite(PDCVOID pData, DCUINT dataLength);
    EXPOSE_CD_NOTIFICATION_FN(CChan, IntChannelWrite);
    
    DCVOID DCINTERNAL IntChannelLoad(PDCTCHAR DLLName);
    DCBOOL DCINTERNAL IntChannelInitAddin(PVIRTUALCHANNELENTRY pChanEntry,
                                          PVIRTUALCHANNELENTRYEX pChanEntryEx,
                                          HMODULE hMod,
                                          PDCTCHAR DLLName,
                                          PVOID    pPassParamToEx);

    inline UCHAR IntChannelCompressData(UCHAR* pSrcData, ULONG cbSrcLen,
                                 UCHAR* pOutBuf,  ULONG* pcbOutLen);

private:
    CObjs*  _pClientObjs;
    CCD*    _pCd;
    CSL*    _pSl;
    CUT*    _pUt;
    CUI*    _pUi;
    BOOL    _fLockInitalized;
    CRITICAL_SECTION _VirtualChannelInitLock;
    BOOL    _fCapsVCCompressionSupported;

    //
    // VC flag that specifies we are compressing
    // channels for this session. Individual channels can choose
    // to be compressed or not, be compression will only take place
    // if this flag is set.
    //
    // Same thing for decompressing channel data, we only decompress if
    // this flag is set and the virtual channel header specifies the
    // channel is compressed.
    //
    BOOL    _fCompressChannels;

    //Compression stats
#ifdef DC_DEBUG
    unsigned _cbBytesRecvd;
    unsigned _cbCompressedBytesRecvd;
    unsigned _cbDecompressedBytesRecvd;

    unsigned _cbTotalBytesUserAskSend; //total bytes user asked to send
    unsigned _cbTotalBytesSent;        //total bytes actually sent on net
    unsigned _cbComprInput;            //total compression input bytes
    unsigned _cbComprOutput;           //total compression output bytes
#endif

    SendContext* _pMPPCContext;
    LONG         _CompressFlushes;
    BOOL         _fCompressionFlushed;
    //When decompressing, we can't just hand of a pointer to the decompressed
    //data as the user may corrupt the decompression context, so we need to make
    //a copy into a user outbuf.
    PUCHAR       _pUserOutBuf;
    //Reset the compression context
    BOOL         _fNeedToResetContext;

#ifdef DEBUG_CCHAN_COMPRESSION
    RecvContext2_8K* _pDbgRcvDecompr8K;
    RecvContext1     _DbgRcvContext1;
    BOOL             _fDbgVCTriedAllocRecvContext;
    BOOL             _fDbgAllocFailedForVCRecvContext;
#endif

    INT              _iDbgCompressFailedCount;
    INT              _iChanSuspendCount;
    INT              _iChanResumeCount;
    INT              _iChanCapsRecvdCount;
};

#endif // _H_CHAN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\cchannel.cpp ===
/**MOD+**********************************************************************/
/* Module:    cchannel.c                                                    */
/*                                                                          */
/* Purpose:   Virtual Channel Client functions                              */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/* $Log$                                                                    */
/*                                                                          */
/**MOD-**********************************************************************/

/****************************************************************************/
/****************************************************************************/
/* HEADERS                                                                  */
/****************************************************************************/
/****************************************************************************/
#include <adcg.h>

extern "C" {
#define TRC_GROUP TRC_GROUP_NETWORK
#define TRC_FILE  "cchannel"
#include <atrcapi.h>
}


#include "autil.h"
#include "wui.h"
#include "sl.h"
#include "nc.h"
#include "cd.h"

#include "cchan.h"

CChan* CChan::pStaticClientInstance = NULL;

/****************************************************************************/
/****************************************************************************/
/* Constants                                                                */
/****************************************************************************/
/****************************************************************************/

#define CHANNEL_MSG_SEND        1
#define CHANNEL_MSG_SUSPEND     2

#ifndef UNREFERENCED_PARAMETER
#define UNREFERENCED_PARAMETER(P)           (P)
#endif

#define WEBCTRL_DLL_NAME    TEXT("mstscax.dll")


#ifdef DEBUG_CCHAN_COMPRESSION
_inline ULONG DbgUserPrint(TCHAR* Format, ...)
{
    va_list arglist;
    TCHAR Buffer[512];
    ULONG retval;

    //
    // Format the output into a buffer and then print it.
    //

    va_start(arglist, Format);
    retval = _vsntprintf(Buffer, sizeof(Buffer), Format, arglist);

    if (retval != -1) {
        OutputDebugString(Buffer);
    }
    return retval;
}
#endif


CChan::CChan(CObjs* objs)
{
    DC_BEGIN_FN("CChan");
    _pClientObjs = objs;

    _pInitHandle = NULL;
    _pFirstWrite = NULL;
    _pLastWrite  = NULL;
    _connected   = CONNECTION_NONE;

    _inChannelEntry    = FALSE;
    _ChannelInitCalled = FALSE;
    _channelCount      = 0;
    _fCapsVCCompressionSupported = FALSE;
    _fCompressChannels = FALSE;

    if(!CChan::pStaticClientInstance)
    {
        //
        // Legacy addins can only talk to the initial instance of the client
        //
        CChan::pStaticClientInstance = this;
    }

    _pMPPCContext = NULL;

    _CompressFlushes       = 0;
    _fCompressionFlushed   = 0;
    _pUserOutBuf           = NULL;

    _fNeedToResetContext   = TRUE;
    _fLockInitalized = FALSE;

#ifdef DEBUG_CCHAN_COMPRESSION
    _pDbgRcvDecompr8K = NULL;
    _fDbgVCTriedAllocRecvContext = FALSE;
    _fDbgAllocFailedForVCRecvContext = TRUE;
#endif

    _iDbgCompressFailedCount = 0;
    _iChanSuspendCount = 0;
    _iChanResumeCount = 0;
    _iChanCapsRecvdCount = 0;

    DC_END_FN();
}

CChan::~CChan()
{
    if(_fLockInitalized)
    {
        DeleteCriticalSection(&_VirtualChannelInitLock);
    }
    
    if(this == CChan::pStaticClientInstance)
    {
        CChan::pStaticClientInstance = NULL;
    }
}
VOID CChan::SetCapabilities(LONG caps)
{
    DC_BEGIN_FN("SetCapabilities");
    
    //
    // Determine if we can send compressed VC data to the server
    // NOTE: for a few whistler builds the server supported 64K
    //       compressed channels from the client, but this capability
    //       has been removed to enhance server scalability.
    //
    // The capability in the other direction, e.g can the server send
    // us compressed data is something the client exposes to the server
    //

    _iChanCapsRecvdCount++;

    _fCapsVCCompressionSupported = (caps & TS_VCCAPS_COMPRESSION_8K) ?
                                    TRUE : FALSE;

    TRC_NRM((TB,_T("VC Caps, compression supported: %d"),
             _fCapsVCCompressionSupported));

    _fCompressChannels = (_fCapsVCCompressionSupported & _pUi->UI_GetCompress());
    TRC_NRM((TB,_T("Compress virtual channels: %d"),
             _fCompressChannels));

    DC_END_FN();
}

void CChan::OnDeviceChange(ULONG_PTR params)
{
    PDEVICE_PARAMS deviceParams = (PDEVICE_PARAMS)params;

    if (deviceParams->deviceObj != NULL) {
        deviceParams->deviceObj->OnDeviceChange(deviceParams->wParam, deviceParams->lParam);
    }
}

/****************************************************************************/
/****************************************************************************/
/* API Functions                                                            */
/****************************************************************************/
/****************************************************************************/

/****************************************************************************/
/* VirtualChannelInit - see cchannel.h                                      */
/****OC-*********************************************************************/
UINT VCAPITYPE DCEXPORT VirtualChannelInitEx(
                               PVOID                    lpUserParam,
                               PVOID                    pInitHandle,
                               PCHANNEL_DEF             pChannel,
                               INT                      channelCount,
                               DWORD                    versionRequested,
                               PCHANNEL_INIT_EVENT_EX_FN   pChannelInitEventProcEx)
{
    DC_BEGIN_FN("VirtualChannelInitEx");
    UINT rc = CHANNEL_RC_OK;

    /************************************************************************/
    /* Check parameters                                                     */
    /************************************************************************/
    if (NULL == pInitHandle)
    {
        rc = CHANNEL_RC_BAD_INIT_HANDLE;
        DC_QUIT;
    }

    if (((PCHANNEL_INIT_HANDLE)pInitHandle)->pInst == NULL)
    {
        TRC_ERR((TB, _T("Null Init Handle")));
        rc = CHANNEL_RC_BAD_INIT_HANDLE;
        DC_QUIT;
    }

    rc = ((PCHANNEL_INIT_HANDLE)pInitHandle)->pInst->IntVirtualChannelInit(
        lpUserParam,
        NULL, pChannel,
        channelCount,
        versionRequested,
        NULL,
        pChannelInitEventProcEx);

DC_EXIT_POINT:
    return (rc);
    DC_END_FN();
}


UINT VCAPITYPE DCEXPORT VirtualChannelInit(
                               PVOID *                  ppInitHandle,
                               PCHANNEL_DEF             pChannel,
                               INT                      channelCount,
                               DWORD                    versionRequested,
                               PCHANNEL_INIT_EVENT_FN   pChannelInitEventProc)
{
    DC_BEGIN_FN("VirtualChannelInit");
    UINT rc = CHANNEL_RC_OK;

    /************************************************************************/
    /* Check parameters                                                     */
    /************************************************************************/
    TRC_ASSERT( CChan::pStaticClientInstance,
                (TB, _T("CChan::pStaticClientInstance is NULL in VirtualChannelInit\n")));
    if (NULL == CChan::pStaticClientInstance)
    {
        rc = CHANNEL_RC_INVALID_INSTANCE;
        DC_QUIT;
    }

    rc = (CChan::pStaticClientInstance)->IntVirtualChannelInit(
        NULL,
        ppInitHandle, pChannel,
        channelCount,
        versionRequested,
        pChannelInitEventProc,
        NULL);

DC_EXIT_POINT:
    return (rc);
    DC_END_FN();
}

UINT VCAPITYPE DCEXPORT CChan::IntVirtualChannelInit(
                               PVOID                    pParam,
                               PVOID *                  ppInitHandle,
                               PCHANNEL_DEF             pChannel,
                               INT                      channelCount,
                               DWORD                    versionRequested,
                               PCHANNEL_INIT_EVENT_FN   pChannelInitEventProc,
                               PCHANNEL_INIT_EVENT_EX_FN pChannelInitEventProcEx)
{
    UINT rc = CHANNEL_RC_OK;
    INT  i, j, k;
    PCHANNEL_INIT_HANDLE pRealInitHandle;

    DC_BEGIN_FN("IntVirtualChannelInit");
    UNREFERENCED_PARAMETER( versionRequested );

    EnterCriticalSection(&_VirtualChannelInitLock);

    /************************************************************************/
    /* Check parameters                                                     */
    /************************************************************************/
    if( versionRequested > VIRTUAL_CHANNEL_VERSION_WIN2000)
    {
        rc = CHANNEL_RC_UNSUPPORTED_VERSION;
        DC_QUIT;
    }
    //
    // ppInitHandle is not used by the EX version of the API
    //
    if (pChannelInitEventProc && ppInitHandle == NULL)
    {
        rc = CHANNEL_RC_BAD_INIT_HANDLE;
        DC_QUIT;
    }
    if(pChannelInitEventProc && IsBadWritePtr(ppInitHandle, sizeof(PVOID)))
    {
        rc = CHANNEL_RC_BAD_INIT_HANDLE;
        DC_QUIT;
    }

    if (pChannel == NULL)
    {
        rc = CHANNEL_RC_BAD_CHANNEL;
        DC_QUIT;
    }

    if(channelCount <= 0)
    {
        rc = CHANNEL_RC_BAD_CHANNEL;
        DC_QUIT;
    }

    if ((IsBadReadPtr(pChannel, channelCount * sizeof(CHANNEL_DEF))) ||
        (IsBadWritePtr(pChannel, channelCount * sizeof(CHANNEL_DEF))))
    {
        rc = CHANNEL_RC_BAD_CHANNEL;
        DC_QUIT;
    }

    if ((_channelCount + channelCount) > CHANNEL_MAX_COUNT)
    {
        rc = CHANNEL_RC_TOO_MANY_CHANNELS;
        DC_QUIT;
    }

    for (i = 0; i < channelCount; i++)
    {
        for (j = 0; j <= CHANNEL_NAME_LEN; j++)
        {
            if (pChannel[i].name[j] == '\0')
            {
                break;
            }
        }
        if (!j || j > CHANNEL_NAME_LEN)
        {
            /****************************************************************/
            /* There was no terminating null in this channel name string    */
            /* or the channel name was zero length                          */
            /****************************************************************/
            rc = CHANNEL_RC_BAD_CHANNEL;
            DC_QUIT;
        }
    }

    if (pChannelInitEventProc == NULL && pChannelInitEventProcEx == NULL)
    {
        rc = CHANNEL_RC_BAD_PROC;
        DC_QUIT;
    }

    /************************************************************************/
    /* Check state                                                          */
    /************************************************************************/
    if (_connected != CONNECTION_NONE)
    {
        rc = CHANNEL_RC_ALREADY_CONNECTED;
        DC_QUIT;
    }

    if (!_inChannelEntry)
    {
        TRC_ERR((TB,_T("VirtualChannelInit called outside VirtualChannelEntry")));
        rc = CHANNEL_RC_NOT_IN_VIRTUALCHANNELENTRY;
        DC_QUIT;
    }

    /************************************************************************/
    /* Save the fact that VirtualChannelInit has been called, so that       */
    /* IntChannelLoad knows it's done.                                      */
    /************************************************************************/
    _ChannelInitCalled = TRUE;

    /************************************************************************/
    /* Initialize a handle (allocated by VirtualChannelEntry)               */
    /************************************************************************/
    pRealInitHandle = _newInitHandle;
    pRealInitHandle->pInitEventFn = pChannelInitEventProc;
    pRealInitHandle->pInitEventExFn = pChannelInitEventProcEx;
    pRealInitHandle->channelCount = channelCount;
    pRealInitHandle->dwFlags = 0;
    
    if(pChannelInitEventProcEx)
    {
        pRealInitHandle->lpParam = pParam;
        pRealInitHandle->fUsingExApi = TRUE;
    }
    else
    {
        pRealInitHandle->fUsingExApi = FALSE;
    }

    /************************************************************************/
    /* Process all Channel data                                             */
    /************************************************************************/
    for (i = 0, j = _channelCount; i < channelCount; i++)
    {
        /********************************************************************/
        /* Assume it's going to be OK                                       */
        /********************************************************************/
        pChannel[i].options |= CHANNEL_OPTION_INITIALIZED;

        /********************************************************************/
        /* Check for duplicate names                                        */
        /********************************************************************/
        for (k = 0; k < j; k++)
        {
            #ifdef UNICODE
            TRC_DBG((TB, _T("Test %S (#%d) for (case insensitive) dup with %S ((#%d)"),
                    pChannel[i].name, i, _channel[k].name, k));
            #else
            TRC_DBG((TB, _T("Test %s (#%d) for (case insensitive) dup with %s ((#%d)"),
                    pChannel[i].name, i, _channel[k].name, k));
            #endif            
            
            if (0 == DC_ASTRNICMP(pChannel[i].name, _channel[k].name,
                                  CHANNEL_NAME_LEN))
            {
                /************************************************************/
                /* Tell the caller this channel is not initialized          */
                /************************************************************/
                #ifdef UNICODE
                TRC_ERR((TB, _T("Dup channel name %S (#%d/#%d)"),
                        pChannel[i].name, i, k));
                #else
                TRC_ERR((TB, _T("Dup channel name %s (#%d/#%d)"),
                        pChannel[i].name, i, k));
                #endif
                pChannel[i].options &= (~(CHANNEL_OPTION_INITIALIZED));
                pRealInitHandle->channelCount--;
                break;
            }
        }

        if (pChannel[i].options & CHANNEL_OPTION_INITIALIZED)
        {
            /****************************************************************/
            /* Channel is OK - save its data                                */
            /****************************************************************/
            DC_MEMCPY(_channel[j].name, pChannel[i].name, CHANNEL_NAME_LEN);
            //name length is CHANNEL_NAME_LEN+1, ensure null termination
            _channel[j].name[CHANNEL_NAME_LEN] = 0;
            /****************************************************************/
            /* Channels are lower case                                      */
            /****************************************************************/
            DC_ACSLWR(_channel[j].name);
            _channel[j].options = pChannel[i].options;
            #ifdef UNICODE
            TRC_NRM((TB, _T("Channel #%d, %S"), i, _channel[j].name));
            #else
            TRC_NRM((TB, _T("Channel #%d, %s"), i, _channel[j].name));
            #endif
            _channelData[j].pOpenEventFn = NULL;
            _channelData[j].pOpenEventExFn = NULL;
            _channelData[j].MCSChannelID = 0;
            _channelData[j].pInitHandle = pRealInitHandle;
            _channelData[j].status = CHANNEL_STATUS_CLOSED;
            _channelData[j].priority =
             (_channel[j].options & CHANNEL_OPTION_PRI_HIGH) ? TS_HIGHPRIORITY:
             (_channel[j].options & CHANNEL_OPTION_PRI_MED)  ? TS_MEDPRIORITY:
                                                               TS_LOWPRIORITY;
            TRC_NRM((TB, _T("  Priority %d"), _channelData[j].priority));
            //Ignore all flags, channels always encrypt
            _channelData[j].SLFlags = RNS_SEC_ENCRYPT;

            _channelData[j].VCFlags =
                (_channel[j].options & CHANNEL_OPTION_SHOW_PROTOCOL) ?
                CHANNEL_FLAG_SHOW_PROTOCOL : 0;

            #ifdef UNICODE
            TRC_NRM((TB, _T("Channel %S has %s shadow persistent option"), _channel[j].name,
                (_channel[j].options & CHANNEL_OPTION_REMOTE_CONTROL_PERSISTENT)? _T(""): _T("NO")));
            #else
            TRC_NRM((TB, _T("Channel %S has %s shadow persistent option"), _channel[j].name,
                (_channel[j].options & CHANNEL_OPTION_REMOTE_CONTROL_PERSISTENT) ? _T(""): _T("NO")));
            #endif

            if (_channel[j].options & CHANNEL_OPTION_REMOTE_CONTROL_PERSISTENT) {
                _channelData[j].VCFlags |= CHANNEL_FLAG_SHADOW_PERSISTENT;
                // if one channel is shadow persistent then the whole plugin is too.
                pRealInitHandle->dwFlags |= CHANNEL_FLAG_SHADOW_PERSISTENT;
            }
            TRC_NRM((TB, _T("VC Flags: %#x"), _channelData[j].VCFlags));
            j++;
        }
    }

    _channelCount += pRealInitHandle->channelCount;

    /************************************************************************/
    /* Set return code                                                      */
    /************************************************************************/
    if(!pRealInitHandle->fUsingExApi)
    {
        *ppInitHandle = pRealInitHandle;
        TRC_NRM((TB, _T("Return handle %p"), *ppInitHandle));
    }
    
    rc = CHANNEL_RC_OK;

DC_EXIT_POINT:

    LeaveCriticalSection(&_VirtualChannelInitLock);

    DC_END_FN();
    return(rc);
} /* VirtualChannelInit */


/****************************************************************************/
/* VirtualChannelOpen - see cchannel.h                                      */
/****************************************************************************/
UINT VCAPITYPE DCEXPORT VirtualChannelOpen(
                                 PVOID                  pInitHandle,
                                 PDWORD                 pOpenHandle,
                                 PCHAR                  pChannelName,
                                 PCHANNEL_OPEN_EVENT_FN pChannelOpenEventProc)
{
    DC_BEGIN_FN("VirtualChannelOpen");
    UINT rc = CHANNEL_RC_OK;

    if (pInitHandle == NULL)
    {
        TRC_ERR((TB, _T("Null Init Handle")));
        rc = CHANNEL_RC_BAD_INIT_HANDLE;
        DC_QUIT;
    }

    if (((PCHANNEL_INIT_HANDLE)pInitHandle)->pInst == NULL)
    {
        TRC_ERR((TB, _T("Null Init Handle")));
        rc = CHANNEL_RC_BAD_INIT_HANDLE;
        DC_QUIT;
    }


    rc = ((PCHANNEL_INIT_HANDLE)pInitHandle)->pInst->IntVirtualChannelOpen(pInitHandle,
                                                                             pOpenHandle,
                                                                             pChannelName,
                                                                             pChannelOpenEventProc,
                                                                             NULL);

DC_EXIT_POINT:
    return (rc);

    DC_END_FN();
}

UINT VCAPITYPE DCEXPORT VirtualChannelOpenEx(
                                 PVOID                  pInitHandle,
                                 PDWORD                 pOpenHandle,
                                 PCHAR                  pChannelName,
                                 PCHANNEL_OPEN_EVENT_EX_FN pChannelOpenEventProcEx)
{
    DC_BEGIN_FN("VirtualChannelOpenEx");
    UINT rc = CHANNEL_RC_OK;

    if (pInitHandle == NULL)
    {
        TRC_ERR((TB, _T("Null Init Handle")));
        rc = CHANNEL_RC_BAD_INIT_HANDLE;
        DC_QUIT;
    }

    if (((PCHANNEL_INIT_HANDLE)pInitHandle)->pInst == NULL)
    {
        TRC_ERR((TB, _T("Null Init Handle")));
        rc = CHANNEL_RC_BAD_INIT_HANDLE;
        DC_QUIT;
    }


    rc = ((PCHANNEL_INIT_HANDLE)pInitHandle)->pInst->IntVirtualChannelOpen(pInitHandle,
                                                                             pOpenHandle,
                                                                             pChannelName,
                                                                             NULL,
                                                                             pChannelOpenEventProcEx);

DC_EXIT_POINT:
    return (rc);

    DC_END_FN();
}



UINT VCAPITYPE CChan::IntVirtualChannelOpen(
                                 PVOID                  pInitHandle,
                                 PDWORD                 pOpenHandle,
                                 PCHAR                  pChannelName,
                                 PCHANNEL_OPEN_EVENT_FN pChannelOpenEventProc,
                                 PCHANNEL_OPEN_EVENT_EX_FN pChannelOpenEventProcEx)
{
    PCHANNEL_INIT_HANDLE pRealInitHandle;
    UINT channelID;
    UINT rc = CHANNEL_RC_OK;

    DC_BEGIN_FN("IntVirtualChannelOpen");

    pRealInitHandle = (PCHANNEL_INIT_HANDLE)pInitHandle;

    /************************************************************************/
    /* Check parameters                                                     */
    /************************************************************************/
    if (pInitHandle == NULL)
    {
        TRC_ERR((TB, _T("Null Init Handle")));
        rc = CHANNEL_RC_BAD_INIT_HANDLE;
        DC_QUIT;
    }

    if (pRealInitHandle->signature != CHANNEL_INIT_SIGNATURE)
    {
        TRC_ERR((TB, _T("Invalid init handle signature %#lx"),
                pRealInitHandle->signature));
        rc = CHANNEL_RC_BAD_INIT_HANDLE;
        DC_QUIT;
    }

    if (pOpenHandle == NULL)
    {
        TRC_ERR((TB, _T("NULL Open Handle")));
        rc = CHANNEL_RC_BAD_CHANNEL_HANDLE;
        DC_QUIT;
    }

    if(pRealInitHandle->fUsingExApi)
    {
        if (pChannelOpenEventProcEx == NULL)
        {
            rc = CHANNEL_RC_BAD_PROC;
            DC_QUIT;
        }
    }
    else
    {
        if (pChannelOpenEventProc == NULL)
        {
            rc = CHANNEL_RC_BAD_PROC;
            DC_QUIT;
        }
    }

    /************************************************************************/
    /* Check connection state                                               */
    /************************************************************************/
    if ((_connected != CONNECTION_VC) &&
        (_connected != CONNECTION_SUSPENDED))
    {
        TRC_ERR((TB, _T("Not yet connected")));
        rc = CHANNEL_RC_NOT_CONNECTED;
        DC_QUIT;
    }

    /************************************************************************/
    /* Find the requested channel                                           */
    /* channel names are lowercase but do a case insensitve cmp             */
    /* Just incase an older plugin passed in an upper case name (doc was    */
    /* not clear channel names had to be lower case                         */
    /************************************************************************/
    for (channelID = 0; channelID < _channelCount; channelID++)
    {
        if (0 == DC_ASTRNICMP(pChannelName, _channel[channelID].name,
                              CHANNEL_NAME_LEN))
        {
            break;
        }
    }

    if (channelID == _channelCount)
    {
        #ifdef UNICODE
        TRC_ERR((TB, _T("Unregistered channel %S"), pChannelName));
        #else
        TRC_ERR((TB, _T("Unregistered channel %s"), pChannelName));
        #endif
        rc = CHANNEL_RC_UNKNOWN_CHANNEL_NAME;
        DC_QUIT;
    }

    /************************************************************************/
    /* Check this channel is registered by this user                        */
    /************************************************************************/
    if (_channelData[channelID].pInitHandle != pInitHandle)
    {
#ifdef UNICODE
        TRC_ERR((TB, _T("Channel %S not registered to this user"), pChannelName));
#else
        TRC_ERR((TB, _T("Channel %s not registered to this user"), pChannelName));
#endif
        
        rc = CHANNEL_RC_UNKNOWN_CHANNEL_NAME;
        DC_QUIT;
    }

    /************************************************************************/
    /* Check that this channel is not already open                          */
    /************************************************************************/
    if (_channelData[channelID].status == CHANNEL_STATUS_OPEN)
    {
#ifdef UNICODE
        TRC_ERR((TB, _T("Channel %S already open"), pChannelName));
#else
        TRC_ERR((TB, _T("Channel %s already open"), pChannelName));
#endif

        rc = CHANNEL_RC_ALREADY_OPEN;
        DC_QUIT;
    }

    /************************************************************************/
    /* Well, everything seems to be in order.  Mark the channel as open and */
    /* return its index as the handle.                                      */
    /************************************************************************/
    _channelData[channelID].status = CHANNEL_STATUS_OPEN;
    _channelData[channelID].pOpenEventFn = pChannelOpenEventProc;
    _channelData[channelID].pOpenEventExFn = pChannelOpenEventProcEx;
    *pOpenHandle = channelID;
    rc = CHANNEL_RC_OK;

DC_EXIT_POINT:
    DC_END_FN();
    return(rc);
} /* VirtualChannelOpen */


/****************************************************************************/
/* VirtualChannelClose - see cchannel.h                                     */
/****************************************************************************/

UINT VCAPITYPE DCEXPORT VirtualChannelClose(DWORD openHandle)
{
    UINT rc = CHANNEL_RC_OK;
    DC_BEGIN_FN("VirtualChannelClose");

    TRC_ASSERT( CChan::pStaticClientInstance,
                (TB, _T("CChan::pStaticClientInstance is NULL in VirtualChannelInit\n")));
    if (NULL == CChan::pStaticClientInstance)
    {
        rc = CHANNEL_RC_INVALID_INSTANCE;
        DC_QUIT;
    }
    else
    {
        rc = (CChan::pStaticClientInstance)->IntVirtualChannelClose(openHandle);
    }

    
    DC_END_FN();
DC_EXIT_POINT:
    return rc;
}

UINT VCAPITYPE DCEXPORT VirtualChannelCloseEx(LPVOID pInitHandle,
                                              DWORD openHandle)
{
    DC_BEGIN_FN("VirtualChannelCloseEx");
    UINT rc = CHANNEL_RC_OK; 
    /************************************************************************/
    /* Check parameters                                                     */
    /************************************************************************/
    if (NULL == pInitHandle)
    {
        return CHANNEL_RC_NULL_DATA;
        DC_QUIT;
    }

    if (((PCHANNEL_INIT_HANDLE)pInitHandle)->pInst == NULL)
    {
        TRC_ERR((TB, _T("Null Init Handle")));
        return CHANNEL_RC_BAD_INIT_HANDLE;
        DC_QUIT;
    }

    rc = ((PCHANNEL_INIT_HANDLE)pInitHandle)->pInst->IntVirtualChannelClose(
                                                              openHandle);
DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}

UINT VCAPITYPE DCEXPORT CChan::IntVirtualChannelClose(DWORD openHandle)
{
    UINT rc = CHANNEL_RC_OK;
    DWORD chanIndex;

    DC_BEGIN_FN("VirtualChannelClose");

    chanIndex = openHandle;


    /************************************************************************/
    /* Check parameters                                                     */
    /************************************************************************/
    if (chanIndex >= _channelCount)
    {
        TRC_ERR((TB, _T("Invalid handle %ul ...(channel index portion '%ul' invalid)"),
                  openHandle, chanIndex));
        rc = CHANNEL_RC_BAD_CHANNEL_HANDLE;
        DC_QUIT;
    }

    /************************************************************************/
    /* Check we're connected                                                */
    /************************************************************************/
    if ((_connected != CONNECTION_VC) &&
        (_connected != CONNECTION_SUSPENDED))
    {
        TRC_ALT((TB, _T("Not connected")));
        rc = CHANNEL_RC_NOT_CONNECTED;
        DC_QUIT;
    }

    /************************************************************************/
    /* Check channel status                                                 */
    /************************************************************************/
    if (_channelData[chanIndex].status != CHANNEL_STATUS_OPEN)
    {
        TRC_ERR((TB, _T("Channel %ul not open"), chanIndex));
        rc = CHANNEL_RC_NOT_OPEN;
        DC_QUIT;
    }

    /************************************************************************/
    /* Close the channel                                                    */
    /************************************************************************/
    TRC_NRM((TB, _T("Close channel %ul"), chanIndex));
    _channelData[chanIndex].status = CHANNEL_STATUS_CLOSED;
    _channelData[chanIndex].pOpenEventFn = NULL;
    _channelData[chanIndex].pOpenEventExFn = NULL;

    /************************************************************************/
    /* Er, that's it                                                        */
    /************************************************************************/
    rc = CHANNEL_RC_OK;

DC_EXIT_POINT:
    DC_END_FN();
    return(rc);
} /* VirtualChannelClose */


/****************************************************************************/
/* VirtualChannelWrite - see cchannel.h                                     */
/****************************************************************************/
UINT VCAPITYPE DCEXPORT VirtualChannelWrite(DWORD  openHandle,
                                            LPVOID pData,
                                            ULONG  dataLength,
                                            LPVOID pUserData)
{
    DC_BEGIN_FN("VirtualChannelWrite");
    UINT rc = CHANNEL_RC_OK;

    TRC_ASSERT( CChan::pStaticClientInstance,
                (TB, _T("CChan::pStaticClientInstance is NULL in VirtualChannelInit\n")));
    if (NULL == CChan::pStaticClientInstance)
    {
        rc = CHANNEL_RC_INVALID_INSTANCE;
        DC_QUIT;
    }
    else
    {
        rc = (CChan::pStaticClientInstance)->IntVirtualChannelWrite(openHandle,
                                             pData,
                                             dataLength,
                                             pUserData);
    }
    
    DC_END_FN();
DC_EXIT_POINT:
    return rc;
}

UINT VCAPITYPE DCEXPORT VirtualChannelWriteEx(LPVOID pInitHandle,
                                            DWORD  openHandle,
                                            LPVOID pData,
                                            ULONG  dataLength,
                                            LPVOID pUserData)
{
    DC_BEGIN_FN("VirtualChannelWriteEx");
    /************************************************************************/
    /* Check parameters                                                     */
    /************************************************************************/
    UINT rc = CHANNEL_RC_OK;
    if (NULL == pInitHandle)
    {
        rc = CHANNEL_RC_NULL_DATA;
        DC_QUIT;
    }

    if (((PCHANNEL_INIT_HANDLE)pInitHandle)->pInst == NULL)
    {
        TRC_ERR((TB, _T("Null Init Handle")));
        rc = CHANNEL_RC_BAD_INIT_HANDLE;
        DC_QUIT;
    }

    rc = ((PCHANNEL_INIT_HANDLE)pInitHandle)->pInst->IntVirtualChannelWrite(
                                             openHandle,
                                             pData,
                                             dataLength,
                                             pUserData);
DC_EXIT_POINT:    
    DC_END_FN();
    return rc;
}

UINT VCAPITYPE DCEXPORT CChan::IntVirtualChannelWrite(DWORD  openHandle,
                                            LPVOID pData,
                                            ULONG  dataLength,
                                            LPVOID pUserData)
{
    UINT rc = CHANNEL_RC_OK;
    PCHANNEL_WRITE_DECOUPLE pDecouple;
    UINT                chanIndex;

    DC_BEGIN_FN("VirtualChannelWrite");

    chanIndex = openHandle;
    TRC_DBG((TB, _T("Got channel index: %ul from handle: %d"), chanIndex, openHandle));

    /************************************************************************/
    /* Check that we're connected                                           */
    /************************************************************************/
    if ((_connected != CONNECTION_VC) &&
        (_connected != CONNECTION_SUSPENDED))
    {
        TRC_ERR((TB, _T("Not connected")));
        rc = CHANNEL_RC_NOT_CONNECTED;
        DC_QUIT;
    }

    /************************************************************************/
    /* Check that this channel is open                                      */
    /************************************************************************/
    if(chanIndex > _channelCount)
    {
        TRC_ERR((TB, _T("Invalid channel index %ul from handle %ul"), chanIndex, 
                      openHandle));
        rc = CHANNEL_RC_BAD_CHANNEL_HANDLE;
        DC_QUIT;
    }

    /************************************************************************/
    /* Check that this channel is open                                      */
    /************************************************************************/
    if (_channelData[chanIndex].status != CHANNEL_STATUS_OPEN)
    {
        TRC_ERR((TB, _T("Channel %ul not open"), chanIndex));
        rc = CHANNEL_RC_BAD_CHANNEL_HANDLE;
        DC_QUIT;
    }

    /************************************************************************/
    /* Check parameters                                                     */
    /************************************************************************/
    if (!pData)
    {
        TRC_ERR((TB, _T("No data passed")));
        rc = CHANNEL_RC_NULL_DATA;
        DC_QUIT;
    }

    if (dataLength == 0)
    {
        TRC_ERR((TB, _T("Zero data length")));
        rc = CHANNEL_RC_ZERO_LENGTH;
        DC_QUIT;
    }

    /************************************************************************/
    /* Queue the write operation                                            */
    /************************************************************************/
    pDecouple = (PCHANNEL_WRITE_DECOUPLE) UT_Malloc(_pUt, sizeof(CHANNEL_WRITE_DECOUPLE));
    if (pDecouple == NULL)
    {
        TRC_ERR((TB, _T("Failed to allocate decouple structure")));
        rc = CHANNEL_RC_NO_MEMORY;
        DC_QUIT;
    }

    TRC_NRM((TB, _T("Decouple structure allocated at %p"), pDecouple));
    pDecouple->signature = CHANNEL_DECOUPLE_SIGNATURE;

    pDecouple->pData = pData;
    pDecouple->pNextData = pData;
    pDecouple->dataLength = dataLength;
    pDecouple->dataLeft = dataLength;
    pDecouple->dataSent = 0;
    pDecouple->openHandle = openHandle;
    pDecouple->pUserData = pUserData;
    pDecouple->pNext = NULL;
    pDecouple->pPrev = NULL;
    pDecouple->chanOptions = _channel[chanIndex].options;
    pDecouple->flags = _channelData[chanIndex].VCFlags | CHANNEL_FLAG_FIRST;

    /************************************************************************/
    /* Pass the request to the SND thread                                   */
    /************************************************************************/
    TRC_NRM((TB, _T("Decouple, pass %p -> %p"), &pDecouple, pDecouple));
    _pCd->CD_DecoupleNotification(CD_SND_COMPONENT,
                                  this,
                                  CD_NOTIFICATION_FUNC(CChan,IntChannelWrite),
                                  &pDecouple,
                                  sizeof(pDecouple));

    /************************************************************************/
    /* All done!                                                            */
    /************************************************************************/
    rc = CHANNEL_RC_OK;

DC_EXIT_POINT:
    DC_END_FN();
    return(rc);
} /* VirtualChannelWrite */


/****************************************************************************/
/****************************************************************************/
/* Callback Functions                                                       */
/****************************************************************************/
/****************************************************************************/
/**PROC+*********************************************************************/
/* Name:      ChannelOnInitialized                                          */
/*                                                                          */
/* Purpose:   Called when MSTSC completes initialization                    */
/*                                                                          */
/* Returns:   none                                                          */
/*                                                                          */
/* Params:    none                                                          */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCCALLBACK CChan::ChannelOnInitialized(DCVOID)
{
    DC_BEGIN_FN("ChannelOnInitialized");

    /************************************************************************/
    /* Call Initialized callbacks                                           */
    /************************************************************************/
    TRC_NRM((TB, _T("Call callbacks ...")));
    IntChannelCallCallbacks(CHANNEL_EVENT_INITIALIZED, NULL, 0);

    DC_END_FN();
    return;
} /* ChannelOnInitialized */


/**PROC+*********************************************************************/
/* Name:      ChannelOnTerminating                                          */
/*                                                                          */
/* Purpose:   Call when MSTSC is terminating                                */
/*                                                                          */
/* Returns:   none                                                          */
/*                                                                          */
/* Params:    none                                                          */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCCALLBACK CChan::ChannelOnTerminating(DCVOID)
{
    PCHANNEL_INIT_HANDLE pInitHandle;
    PCHANNEL_INIT_HANDLE pFreeHandle;

    DC_BEGIN_FN("ChannelOnTerminating");

    /************************************************************************/
    /* Loop through all handles                                             */
    /************************************************************************/
    pInitHandle = _pInitHandle;
    while (pInitHandle != NULL)
    {
        TRC_NRM((TB, _T("Terminate handle %p"), pInitHandle));
        /********************************************************************/
        /* Call the terminated callback                                     */
        /********************************************************************/
        if(pInitHandle->fUsingExApi)
        {
            pInitHandle->pInitEventExFn(
                                  pInitHandle->lpParam,
                                  pInitHandle,
                                  CHANNEL_EVENT_TERMINATED,
                                  NULL, 0);

        }
        else
        {
            pInitHandle->pInitEventFn(pInitHandle,
                                      CHANNEL_EVENT_TERMINATED,
                                      NULL, 0);
        }

        /********************************************************************/
        /* Free the library                                                 */
        /********************************************************************/
        FreeLibrary(pInitHandle->hMod);

        /********************************************************************/
        /* Free the handle                                                  */
        /********************************************************************/
        pFreeHandle = pInitHandle;
        pInitHandle = pInitHandle->pNext;
        pFreeHandle->signature = 0;
        UT_Free(_pUt, pFreeHandle);
    }

    if(_pMPPCContext)
    {
        UT_Free(_pUt, _pMPPCContext);
        _pMPPCContext = NULL;
    }

    if(_pUserOutBuf)
    {
        UT_Free(_pUt, _pUserOutBuf);
        _pUserOutBuf = NULL;
    }

    /************************************************************************/
    /* Clear key data                                                       */
    /************************************************************************/
    _pInitHandle = NULL;
    _channelCount = 0;
    _connected = CONNECTION_NONE;

    DC_END_FN();
DC_EXIT_POINT:
    return;
} /* ChannelOnTerminating */


/**PROC+*********************************************************************/
/* Name:      ChannelOnConnected                                            */
/*                                                                          */
/* Purpose:   Called when a connection is established                       */
/*                                                                          */
/* Returns:   None                                                          */
/*                                                                          */
/* Params:    channelID - T128 MCS channel ID                               */
/*            serverVersion - software version of Server                    */
/*            pUserData - Server-Client Net user data                       */
/*            userDataLength - length of user data                          */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCCALLBACK CChan::ChannelOnConnected(DCUINT   channelID,
                                     DCUINT32 serverVersion,
                                     PDCVOID  pUserData,
                                     DCUINT   userDataLength)
{
    PRNS_UD_SC_NET  pNetUserData;
    PDCUINT16       pMCSChannel;
    UINT i;
    UINT expectedLength;
    UINT event;
    DCTCHAR serverName[UT_MAX_ADDRESS_LENGTH];

    DC_BEGIN_FN("ChannelOnConnected");
    UNREFERENCED_PARAMETER( channelID );
#ifndef DC_DEBUG
    UNREFERENCED_PARAMETER( userDataLength );
#endif

    /************************************************************************/
    /* Check Server software version                                        */
    /************************************************************************/
    if (_RNS_MINOR_VERSION(serverVersion) < 2)
    {
        TRC_ALT((TB, _T("Old Server - no channel support")));
        event = CHANNEL_EVENT_V1_CONNECTED;
        _connected = CONNECTION_V1;
    }

    else
    {
        TRC_NRM((TB, _T("New Server version - channels supported")));
        /********************************************************************/
        /* Set up local pointers                                            */
        /********************************************************************/
        pNetUserData = (PRNS_UD_SC_NET)pUserData;
        pMCSChannel = (PDCUINT16)(pNetUserData + 1);

        /********************************************************************/
        /* Check parameters                                                 */
        /********************************************************************/
        TRC_ASSERT((pNetUserData->channelCount == _channelCount),
                (TB, _T("Channel count changed by Server: was %hd, is %d"),
                _channelCount, pNetUserData->channelCount));
        expectedLength = sizeof(RNS_UD_SC_NET) +
                         (pNetUserData->channelCount * sizeof(DCUINT16));
        if (userDataLength < expectedLength) {
            TRC_ABORT((TB,_T("SC NET user data too short - is %d, expect %d"),
                    userDataLength, expectedLength));

            _pSl->SL_DropLinkImmediate(SL_ERR_INVALIDPACKETFORMAT);
            DC_QUIT;
        }

        /********************************************************************/
        /* Save channel data                                                */
        /********************************************************************/
        for (i = 0; i < _channelCount; i++)
        {
            _channelData[i].MCSChannelID = pMCSChannel[i];
        }

        /********************************************************************/
        /* Update our state                                                 */
        /********************************************************************/
        _connected = CONNECTION_VC;
        event = CHANNEL_EVENT_CONNECTED;

    }
    /************************************************************************/
    /* Call Connected callbacks                                             */
    /************************************************************************/
    _pUi->UI_GetServerName(serverName, SIZE_TCHARS(serverName));

    IntChannelCallCallbacks(event, serverName, UT_MAX_ADDRESS_LENGTH);

DC_EXIT_POINT:

    DC_END_FN();
    return;
} /* ChannelOnConnected */


/**PROC+*********************************************************************/
/* Name:      ChannelOnDisconnected                                         */
/*                                                                          */
/* Purpose:   Called when a session is disconnected                         */
/*                                                                          */
/* Returns:   none                                                          */
/*                                                                          */
/* Params:    reason - disconnect reason code                               */
/*                                                                          */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCCALLBACK CChan::ChannelOnDisconnected(DCUINT reason)
{
    UINT i;

    DC_BEGIN_FN("ChannelOnDisconnected");
    UNREFERENCED_PARAMETER( reason );

    /************************************************************************/
    /* Don't do anything if we haven't told the callbacks we're connected.  */
    /************************************************************************/
    if (_connected == CONNECTION_NONE)
    {
        TRC_ALT((TB, _T("Disconnected callback when not connected")));
        DC_QUIT;
    }

    /************************************************************************/
    /* Change state                                                         */
    /************************************************************************/
    _connected = CONNECTION_NONE;

    /************************************************************************/
    /* Call Disconnected callbacks                                          */
    /************************************************************************/
    TRC_NRM((TB, _T("Call disconnected callbacks")));
    IntChannelCallCallbacks(CHANNEL_EVENT_DISCONNECTED, NULL, 0);


    /************************************************************************/
    /* Disconnection implies that all channels are closed                   */
    /************************************************************************/
    for (i = 0; i < _channelCount; i++)
    {
        TRC_NRM((TB, _T("'Close' channel %d"), i));
        _channelData[i].status = CHANNEL_STATUS_CLOSED;
    }

    /************************************************************************/
    /* Switch to SND thread to cancel all outstanding sends                 */
    /************************************************************************/
    _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT,
                                        this,
                                        CD_NOTIFICATION_FUNC(CChan,IntChannelCancelSend),
                                        CHANNEL_MSG_SEND);


DC_EXIT_POINT:
    DC_END_FN();
    return;
} /* ChannelOnDisconnected */


/**PROC+*********************************************************************/
/* Name:      ChannelOnSuspended                                            */
/*                                                                          */
/* Purpose:   Called when a session is suspended (shadow client)            */
/*                                                                          */
/* Returns:   none                                                          */
/*                                                                          */
/* Params:    reason - disconnect reason code                               */
/*                                                                          */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCCALLBACK CChan::ChannelOnSuspended(DCUINT reason)
{
    UINT i;

    DC_BEGIN_FN("ChannelOnDisconnected");
    UNREFERENCED_PARAMETER( reason );

    /************************************************************************/
    /* Don't do anything if we haven't told the callbacks we're connected.  */
    /************************************************************************/
    if (_connected == CONNECTION_NONE)
    {
        TRC_ALT((TB, _T("Disconnected callback when not connected")));
        DC_QUIT;
    }

    _iChanSuspendCount++;

    /************************************************************************/
    /* Change state                                                         */
    /************************************************************************/
    _connected = CONNECTION_SUSPENDED;

    /************************************************************************/
    /* Call Disconnected callbacks                                          */
    /************************************************************************/
    TRC_NRM((TB, _T("Call disconnected callbacks")));
    IntChannelCallCallbacks(CHANNEL_EVENT_REMOTE_CONTROL_START, NULL, 0);


    /************************************************************************/
    /* Disconnection implies that all channels are closed                   */
    /************************************************************************/
    for (i = 0; i < _channelCount; i++)
    {
        TRC_NRM((TB, _T("'Close' channel %d"), i));
        // If a plug-in specified at least one of its channels shadow persistent,
        // then it will be notified with the shadow start event instead of the
        // disconnected event. In this case the plug-in is supposed to shutdown 
        // only its non-shadow-persistent channels. So close only channels that
        // are not shadow persistent.
        if (!(_channelData[i].VCFlags & CHANNEL_FLAG_SHADOW_PERSISTENT))
            _channelData[i].status = CHANNEL_STATUS_CLOSED;
    }

    /************************************************************************/
    /* Switch to SND thread to cancel all outstanding sends                 */
    /************************************************************************/
    _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT,
                                        this,
                                        CD_NOTIFICATION_FUNC(CChan,IntChannelCancelSend),
                                        CHANNEL_MSG_SUSPEND);


DC_EXIT_POINT:
    DC_END_FN();
    return;
} /* ChannelOnSuspended */


/**PROC+*********************************************************************/
/* Name:      ChannelOnPacketReceived                                       */
/*                                                                          */
/* Purpose:   Called when data is received from the Server                  */
/*                                                                          */
/* Returns:   none                                                          */
/*                                                                          */
/* Params:    pData - data received                                         */
/*            dataLen - length of data received                             */
/*            flags - security flags (meaningless to this function)         */
/*            channelID - ID of channel on which data received              */
/*            priority - priority on which data was sent                    */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCCALLBACK CChan::ChannelOnPacketReceived(PDCUINT8   pData,
                                          DCUINT     dataLen,
                                          DCUINT     flags,
                                          DCUINT     channelID,
                                          DCUINT     priority)
{
    UINT i;
    PCHANNEL_PDU_HEADER pHdr;
    UINT32 len;
    DCTCHAR serverName[UT_MAX_ADDRESS_LENGTH];
    UINT32 Hdrflags;
    UINT32 Hdrlength;

    DC_BEGIN_FN("ChannelOnPacketReceived");

    UNREFERENCED_PARAMETER( priority );
    UNREFERENCED_PARAMETER( flags );

    /************************************************************************/
    /* First of all, handle suspend/resume messages                         */
    /************************************************************************/

    if (dataLen < sizeof(CHANNEL_PDU_HEADER)) {
        TRC_ERR((TB,_T("Not enough data: 0x%x need at least: 0x%x"),
                 dataLen, sizeof(CHANNEL_PDU_HEADER)));
        DC_QUIT;
    }

    pHdr = (PCHANNEL_PDU_HEADER)pData;
    memcpy(&Hdrflags,(UNALIGNED UINT32 *)&(pHdr->flags),sizeof(Hdrflags));
    memcpy(&Hdrlength,(UNALIGNED UINT32 *)&(pHdr->length),sizeof(Hdrlength));

    if (Hdrflags & CHANNEL_FLAG_SUSPEND)
    {
        TRC_ALT((TB, _T("VC suspended")));

        /********************************************************************/
        /* Treat as a disconnection                                         */
        /********************************************************************/
        ChannelOnSuspended(0);
        DC_QUIT;
    }

    if (Hdrflags & CHANNEL_FLAG_RESUME)
    {
        TRC_ALT((TB, _T("VC resumed")));

        /********************************************************************/
        /* Update our state                                                 */
        /********************************************************************/
        _connected = CONNECTION_VC;

        _iChanResumeCount++;

        /********************************************************************/
        /* Call Connected callbacks                                         */
        /********************************************************************/
        _pUi->UI_GetServerName(serverName, SIZE_TCHARS(serverName));
        IntChannelCallCallbacks(CHANNEL_EVENT_REMOTE_CONTROL_STOP,
                                serverName,
                                UT_MAX_ADDRESS_LENGTH);
        DC_QUIT;
    }

    /************************************************************************/
    /* Check we're still connected                                          */
    /************************************************************************/
    if ((_connected != CONNECTION_VC) &&
        (_connected != CONNECTION_SUSPENDED))
    {
        TRC_ASSERT((_connected != CONNECTION_V1),
                    (TB,_T("Channel data received from V1 Server!")));
        TRC_NRM((TB, _T("Discard packet received when we're not connected")));
        DC_QUIT;
    }

    /************************************************************************/
    /* Find the channel data for this channel                               */
    /************************************************************************/
    for (i = 0; i < _channelCount; i++)
    {
        if (_channelData[i].MCSChannelID == channelID)
        {
            //
            // Note it's important to do the decompression even if the channel
            // is closed otherwise the context could get out of sync
            //

            /****************************************************************/
            /* call the callback                                            */
            /****************************************************************/
            TRC_NRM((TB, _T("MCS channel %x = channel %d"), channelID, i));
            pData = (PDCUINT8)(pHdr + 1);
            len = dataLen - sizeof(CHANNEL_PDU_HEADER);
                
            UCHAR vcCompressFlags = (Hdrflags >> VC_FLAG_COMPRESS_SHIFT) &
                                     VC_FLAG_COMPRESS_MASK;
            //Data that is returned to user
            PDCUINT8 pVCUserData = pData;
            UINT32   cbVCUserDataLen = len;
            if(vcCompressFlags & PACKET_COMPRESSED)
            {
                UCHAR *buf;
                int   bufSize;

                //Decompress channel data
                if(vcCompressFlags & PACKET_FLUSHED)
                {
                    initrecvcontext (&_pUi->_UI.Context1,
                                     (RecvContext2_Generic*)_pUi->_UI.pRecvContext2,
                                     PACKET_COMPR_TYPE_64K);
                }
                #ifdef DC_DEBUG
                //Update compression stats (debug only)
                _cbCompressedBytesRecvd += len;
                #endif

                if (decompress(pData,
                               len,
                               (vcCompressFlags & PACKET_AT_FRONT),
                               &buf,
                               &bufSize,
                               &_pUi->_UI.Context1,
                               (RecvContext2_Generic*)_pUi->_UI.pRecvContext2,
                               vcCompressFlags & PACKET_COMPR_TYPE_MASK))
                {
                    if(!_pUserOutBuf)
                    {
                        _pUserOutBuf = (PUCHAR)UT_Malloc(_pUt, VC_USER_OUTBUF);
                    }

                    TRC_ASSERT(_pUserOutBuf, (TB,_T("_pUserOutBuf is NULL")));
                    TRC_ASSERT((bufSize < VC_USER_OUTBUF),
                               (TB,_T("Decompressed buffer to big!!!")));
                    if(_pUserOutBuf && (bufSize < VC_USER_OUTBUF))
                    {
                        //
                        // Make a copy of the buffer as we can't hand off
                        // a pointer to the decompression context to the
                        // user because a badly behaved plugin can corrupt
                        // the decompression context causing all sorts of 
                        // horrible and hard to debug problems.
                        //
                        memcpy(_pUserOutBuf, buf, bufSize);
                        pVCUserData = _pUserOutBuf;
                        cbVCUserDataLen = bufSize;
                    }
                    else
                    {
                        DC_QUIT;
                    }
                }
                else {
                    TRC_ABORT((TB, _T("Decompression FAILURE!!!")));
                    _pSl->SL_DropLinkImmediate(SL_ERR_INVALIDPACKETFORMAT);
                    DC_QUIT;
                }
            }

            #ifdef DC_DEBUG
            //Update compression stats (debug only)
            _cbBytesRecvd += len;
            _cbDecompressedBytesRecvd += cbVCUserDataLen;
            #endif

            //
            // Turn off header flags to hide internal
            // protocol info from user
            //
            Hdrflags &= ~VC_FLAG_PRIVATE_PROTOCOL_MASK;

            //
            // Drop the packet at the last moment if the channel is closed
            //
            if (_channelData[i].status != CHANNEL_STATUS_OPEN)
            {
                TRC_ALT((TB, _T("Data received on un-opened channel %x"),
                        channelID));
                DC_QUIT;
            }

            

            if(_channelData[i].pInitHandle->fUsingExApi)
            {
                _channelData[i].pOpenEventExFn(
                                        _channelData[i].pInitHandle->lpParam,
                                         i,
                                         CHANNEL_EVENT_DATA_RECEIVED,
                                         pVCUserData,
                                         cbVCUserDataLen,
                                         Hdrlength,
                                         Hdrflags);
            }
            else
            {
                _channelData[i].pOpenEventFn(i,
                                         CHANNEL_EVENT_DATA_RECEIVED,
                                         pVCUserData,
                                         cbVCUserDataLen,
                                         Hdrlength,
                                         Hdrflags);
            }
            DC_QUIT;
        }
    }

    /************************************************************************/
    /* If we get here, we didn't find this channel                          */
    /************************************************************************/
    TRC_ALT((TB, _T("Data received on unknown channel %x"), channelID));

DC_EXIT_POINT:
    DC_END_FN();
    return;
} /* ChannelOnPacketReceived */


/**PROC+*********************************************************************/
/* Name:      ChannelOnBufferAvailable                                      */
/*                                                                          */
/* Purpose:   Called when a buffer is available, after a write has failed   */
/*            because no buffer was available                               */
/*                                                                          */
/* Returns:   none                                                          */
/*                                                                          */
/* Params:    none                                                          */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCCALLBACK CChan::ChannelOnBufferAvailable(DCVOID)
{
    DC_BEGIN_FN("ChannelOnBufferAvailable");

    /************************************************************************/
    /* Kick the send process into restarting                                */
    /************************************************************************/
    TRC_NRM((TB, _T("Write pending %p"), _pFirstWrite));
    _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT,
                                        this,
                                        CD_NOTIFICATION_FUNC(CChan,IntChannelSend),
                                        CHANNEL_MSG_SEND);

    DC_END_FN();
    return;
} /* ChannelOnBufferAvailable */


/**PROC+*********************************************************************/
/* Name:      ChannelOnConnecting                                           */
/*                                                                          */
/* Purpose:   Called when a connection is being established - returns       */
/*            virtual channel user data to be sent to the Server            */
/*                                                                          */
/* Returns:   None                                                          */
/*                                                                          */
/* Params:    ppChannel (returned) - virtual channel user data              */
/*            pChannelCount (returned) - number of channels returned        */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCCALLBACK CChan::ChannelOnConnecting(PPCHANNEL_DEF ppChannel,
                                      PDCUINT32     pChannelCount)
{
    DC_BEGIN_FN("ChannelOnConnecting");

    //Reset the context on each new connection
    _fNeedToResetContext = TRUE;

    *ppChannel = _channel;
    *pChannelCount = _channelCount;

    DC_END_FN();
    return;
} /* ChannelOnConnecting */


/**PROC+*********************************************************************/
/* Name:      ChannelOnInitializing                                         */
/*                                                                          */
/* Purpose:   Called when MSTSC Network Layer is initializing - loads all   */
/*            configured application DLLs                                   */
/*                                                                          */
/* Returns:   none                                                          */
/*                                                                          */
/* Params:    none                                                          */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCCALLBACK CChan::ChannelOnInitializing(DCVOID)
{
    HINSTANCE     hInst;
    PDCTCHAR      szAddinDllList = NULL;
    DWORD         status = ERROR_SUCCESS;
    PRDPDR_DATA   pdrInitData = NULL;

    DC_BEGIN_FN("ChannelOnInitializing");

    //
    // Initialize private member pointers
    //
    _pCd = _pClientObjs->_pCdObject;
    _pSl = _pClientObjs->_pSlObject;
    _pUt = _pClientObjs->_pUtObject;
    _pUi = _pClientObjs->_pUiObject;

    /************************************************************************/
    /* Create the exported function table                                   */
    /************************************************************************/
    _channelEntryPoints.cbSize = sizeof(CHANNEL_ENTRY_POINTS);
    _channelEntryPoints.protocolVersion = VIRTUAL_CHANNEL_VERSION_WIN2000;
    hInst = _pUi->UI_GetInstanceHandle();
    _channelEntryPoints.pVirtualChannelInit =
                        (PVIRTUALCHANNELINIT)(MakeProcInstance
                                        ((FARPROC)VirtualChannelInit, hInst));
    _channelEntryPoints.pVirtualChannelOpen =
                        (PVIRTUALCHANNELOPEN)(MakeProcInstance
                                        ((FARPROC)VirtualChannelOpen, hInst));
    _channelEntryPoints.pVirtualChannelClose =
                        (PVIRTUALCHANNELCLOSE)(MakeProcInstance
                                       ((FARPROC)VirtualChannelClose, hInst));
    _channelEntryPoints.pVirtualChannelWrite =
                        (PVIRTUALCHANNELWRITE)(MakeProcInstance
                                       ((FARPROC)VirtualChannelWrite, hInst));

    _channelEntryPointsEx.cbSize = sizeof(CHANNEL_ENTRY_POINTS);
    _channelEntryPointsEx.protocolVersion = VIRTUAL_CHANNEL_VERSION_WIN2000;
    
    _channelEntryPointsEx.pVirtualChannelInitEx =
                        (PVIRTUALCHANNELINITEX)(MakeProcInstance
                                        ((FARPROC)VirtualChannelInitEx, hInst));
    _channelEntryPointsEx.pVirtualChannelOpenEx =
                        (PVIRTUALCHANNELOPENEX)(MakeProcInstance
                                        ((FARPROC)VirtualChannelOpenEx, hInst));
    _channelEntryPointsEx.pVirtualChannelCloseEx =
                        (PVIRTUALCHANNELCLOSEEX)(MakeProcInstance
                                       ((FARPROC)VirtualChannelCloseEx, hInst));
    _channelEntryPointsEx.pVirtualChannelWriteEx =
                        (PVIRTUALCHANNELWRITEEX)(MakeProcInstance
                                       ((FARPROC)VirtualChannelWriteEx, hInst));


    //
    // Initialize the single instance VC critical
    // section lock. This is used to ensure only one
    // VC plugin at a time can be in the Initialize fn.
    //
    //
    __try
    {
        InitializeCriticalSection(&_VirtualChannelInitLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = GetExceptionCode();
    }

    if(ERROR_SUCCESS == status)
    {
        _fLockInitalized = TRUE;
    }
    else
    {
        //
        // Without the lock we can't ensure we won't get re-entered
        // because the API's did not make it clear that we did
        // not support re-entrancy in the VirtualChannelInit fn
        // so this is fatal just bail out and don't load plugins.
        //
        _fLockInitalized = FALSE;
        TRC_ERR((TB,_T("InitializeCriticalSection failed 0x%x.")
                 _T("NOT LOADING PLUGINS"),status));
        DC_QUIT;
    }


    //
    // RDPDR is statically linked in
    //
    
    // Initialize and pass in initialization info to rdpdr
    // rdpdr keeps a pointer to this struct accross connections
    // (because there is no clean way to pass it back in again)
    // On each connection, the core reinitalizes the struct settings.
    _pUi->UI_InitRdpDrSettings();

    pdrInitData = _pUi->UI_GetRdpDrInitData();

    if(!_pUi->_UI.fDisableInternalRdpDr)
    {
        if(!IntChannelInitAddin( NULL, RDPDR_VirtualChannelEntryEx, NULL,WEBCTRL_DLL_NAME,
                                 pdrInitData))
        {
            TRC_ERR((TB, _T("Failed to load internal addin 'RDPDR'")));
        }
    }
    else
    {
        TRC_NRM((TB, _T("NOT LOADING Internal RDPDR, fDisableInternalRdpDr is set")));    
    }

    //
    // Ts ActiveX control's exposed interfaces to the virtual channel API
    // are also statically linked in
    //
    if(!IntChannelInitAddin( NULL, MSTSCAX_VirtualChannelEntryEx, NULL, WEBCTRL_DLL_NAME,
                             (PVOID)_pUi->_UI.pUnkAxControlInstance))
    {
        TRC_NRM((TB, _T("Internal addin (scriptable vchans) did not load: possibly none requested")));
    }


    //Get a comma separated list of dll's to load (passed down from control)
    szAddinDllList = _pUi->UI_GetVChanAddinList();
    if(!szAddinDllList)
    {
        TRC_DBG((TB, _T("Not loading any external plugins")));
        DC_QUIT;
    }
    else
    {
        PDCTCHAR szTok = NULL;
        DCUINT len = DC_TSTRLEN(szAddinDllList);
        PDCTCHAR szCopyAddinList = (PDCTCHAR) UT_Malloc( _pUt,sizeof(DCTCHAR) *
                                               (len+1));
        TRC_ASSERT(szCopyAddinList, (TB, _T("Could not allocate mem for addin list")));
        if(!szCopyAddinList)
        {
            DC_QUIT;
        }

        StringCchCopy(szCopyAddinList, len+1, szAddinDllList);

        szTok = DC_TSTRTOK( szCopyAddinList, _T(","));
        while(szTok)
        {
            //
            // Load the DLL
            //
            if (_tcsicmp(szTok, _T("rdpdr.dll")))
            {
                IntChannelLoad( szTok);
            }
            else
            {
                //
                // Don't load the crusty rdpdr.dll since
                // we have a newer better one built-in
                //
                TRC_ERR((TB,_T("Skiping load of rdpdr.dll")));
            }
            
            szTok = DC_TSTRTOK( NULL, _T(","));
        }

        UT_Free( _pUt, szCopyAddinList); 
    }

#ifdef DC_DEBUG
    //Debug compression counters
    _cbBytesRecvd             = 0;
    _cbCompressedBytesRecvd   = 0;
    _cbDecompressedBytesRecvd = 0;

    _cbTotalBytesUserAskSend  = 0;
    _cbTotalBytesSent         = 0;
    _cbComprInput             = 0;
    _cbComprOutput            = 0;
#endif

DC_EXIT_POINT:
    DC_END_FN();
    return;
} /* ChannelOnInitializing */


/****************************************************************************/
/****************************************************************************/
/* Internal Functions                                                       */
/****************************************************************************/
/****************************************************************************/
/**PROC+*********************************************************************/
/* Name:      IntChannelCallCallbacks                                       */
/*                                                                          */
/* Purpose:   Call all ChannelInitEvent callbacks with a specified event    */
/*                                                                          */
/* Returns:   none                                                          */
/*                                                                          */
/* Params:    event - event to pass to callbacks                            */
/*            pData - additional data                                       */
/*            dataLength - length of additional data                        */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCINTERNAL CChan::IntChannelCallCallbacks(DCUINT event,
                                          PDCVOID pData,
                                          DCUINT dataLength)
{
    PCHANNEL_INIT_HANDLE pInitHandle;
    DCUINT altEvent, sentEvent;

    if (event == CHANNEL_EVENT_REMOTE_CONTROL_START) {
        altEvent = CHANNEL_EVENT_DISCONNECTED;
    } else if (event == CHANNEL_EVENT_REMOTE_CONTROL_STOP) {
        altEvent = CHANNEL_EVENT_CONNECTED;
    } else {
        altEvent = event;
    }

    DC_BEGIN_FN("IntChannelCallCallbacks");

    pInitHandle = _pInitHandle;
    while (pInitHandle != NULL)
    {
        if (pInitHandle->dwFlags & CHANNEL_FLAG_SHADOW_PERSISTENT) {

            // The plug-in supports the new events, don't change it.
            sentEvent = event;

        } else {

            // No support or the new event is not wanted.
            sentEvent = altEvent;
        } 

        if(pInitHandle->fUsingExApi)
        {
            TRC_NRM((TB, _T("Call callback (Ex) at %p, handle %p, event %d"),
                    pInitHandle->pInitEventExFn, pInitHandle, sentEvent));
            pInitHandle->pInitEventExFn(pInitHandle->lpParam, 
                                        pInitHandle, sentEvent, pData, dataLength);
        }
        else
        {
            TRC_NRM((TB, _T("Call callback at %p, handle %p, event %d"),
                    pInitHandle->pInitEventFn, pInitHandle, sentEvent));
            pInitHandle->pInitEventFn(pInitHandle, sentEvent, pData, dataLength);
        }
        pInitHandle = pInitHandle->pNext;
    }

    DC_END_FN();
    return;
} /* IntChannelCallCallbacks */


/**PROC+*********************************************************************/
/* Name:      IntChannelFreeLibrary                                         */
/*                                                                          */
/* Purpose:   Decoupled function to unload a DLL                            */
/*                                                                          */
/* Returns:   none                                                          */
/*                                                                          */
/* Params:    value - hMod of DLL to free                                   */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCINTERNAL CChan::IntChannelFreeLibrary(DCUINT value)
{
    BOOL bRc;
    DC_BEGIN_FN("IntChannelFreeLibrary");

    if(value)
    {
        //
        // Statically linked extenstions (e.g RDPDR) have a null hModule
        //
#ifdef OS_WIN32
    
        
        bRc = FreeLibrary(
        #ifndef OS_WINCE
            (HMODULE)ULongToPtr(value)
        #else
            (HMODULE)value
        #endif
            );
        if (bRc)
        {
            TRC_NRM((TB, _T("Free library %#x OK"), value));
        }
        else
        {
            TRC_ERR((TB, _T("Failed to free library %#x"), value));
        }
#else //OS_WIN32
        FreeLibrary((HMODULE)value);
#endif // OS_WIN32
    }

    DC_END_FN();
    return;
} /* IntChannelFreeLibrary */


//
// IntChannelCompressData
// Compressed the buffer directly into the outbuf.
// Caller MUST decide if input buf is in size range for compression
// and should handle copying over the buffer directly in that case.
//
// Params:
//  pSrcData - input buffer
//  cbSrcLen - length of input buffer
//  pOutBuf  - output buffer
//  pcbOutLen- compressed output size
// Returns:
//  Compression result (see compress() fn)
//
UCHAR CChan::IntChannelCompressData(UCHAR* pSrcData, ULONG cbSrcLen,
                                    UCHAR* pOutBuf,  ULONG* pcbOutLen)
{
    UCHAR compressResult = 0;
    ULONG CompressedSize = cbSrcLen;

    DC_BEGIN_FN("IntChannelCompressData");

    TRC_ASSERT(((cbSrcLen > VC_MIN_COMPRESS_INPUT_BUF) &&
                (cbSrcLen < VC_MAX_COMPRESSED_BUFFER)),
               (TB,_T("Compression src len out of range: %d"),
                cbSrcLen));
    TRC_ASSERT(_pMPPCContext,(TB,_T("_pMPPCContext is null")));

    //Attempt to compress directly into the outbuf
    compressResult =  compress(pSrcData,
                               pOutBuf,
                               &CompressedSize,
                               _pMPPCContext);
    if(compressResult & PACKET_COMPRESSED)
    {
        //Successful compression.
        TRC_ASSERT((CompressedSize >= CompressedSize),
                (TB,_T("Compression created larger size than uncompr")));
        compressResult |= _fCompressionFlushed;
        _fCompressionFlushed = 0;

        #ifdef DC_DEBUG
        //Compr counters
        _cbComprInput  += cbSrcLen;
        _cbComprOutput += CompressedSize;
        #endif
    }
    else if(compressResult & PACKET_FLUSHED)
    {
        //Overran compression history, copy over the
        //uncompressed buffer.
        _fCompressionFlushed = PACKET_FLUSHED;
        memcpy(pOutBuf, pSrcData, cbSrcLen);
        _CompressFlushes++;
    }
    else
    {
        TRC_ALT((TB, _T("Compression FAILURE")));
    }

    DC_END_FN();
    *pcbOutLen = CompressedSize;
    return compressResult;
}



/**PROC+*********************************************************************/
/* Name:      IntChannelSend                                                */
/*                                                                          */
/* Purpose:   Internal function to send data to the Server                  */
/*                                                                          */
/* Returns:   None                                                          */
/*                                                                          */
/* Params:    value - message passed from caller                            */
/*                                                                          */
/* Operation: Called on SND thread                                          */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCINTERNAL CChan::IntChannelSend(ULONG_PTR value)
{
    PCHANNEL_WRITE_DECOUPLE pDecouple;
    DCBOOL                  bRc;
    PDCUINT8                pBuffer;
    SL_BUFHND               bufHnd;
    PCHANNEL_PDU_HEADER     pHdr;
    ULONG                   thisLength;
    DWORD                   chanIndex = 0xFDFDFDFD; 
    ULONG cbOutLen = 0;
    UCHAR compressResult = 0;
    BOOL  fNeedToDirectCopy = TRUE;


    DC_BEGIN_FN("IntChannelSend");
    //
    // CD passes param as PVOID
    //
    #ifndef DC_DEBUG
    UNREFERENCED_PARAMETER(value);
    #endif

    /************************************************************************/
    /* Assert parameters                                                    */
    /************************************************************************/
    TRC_ASSERT((value == CHANNEL_MSG_SEND),
                (TB, _T("Unexpected value %d"), value));

    /************************************************************************/
    /* Exit immediately if there's nothing to do.                           */
    /************************************************************************/
    if (_pFirstWrite == NULL)
    {
        TRC_NRM((TB, _T("Nothing to do")));
        DC_QUIT;
    }

    TRC_ASSERT((_pFirstWrite->signature == CHANNEL_DECOUPLE_SIGNATURE),
                (TB,_T("Invalid first signature %#lx"), _pFirstWrite->signature));
    TRC_ASSERT((_pLastWrite->signature == CHANNEL_DECOUPLE_SIGNATURE),
                (TB,_T("Invalid last signature %#lx"), _pLastWrite->signature));

    /************************************************************************/
    /* Get the next queued request                                          */
    /************************************************************************/
    pDecouple = _pFirstWrite;

    /************************************************************************/
    /* Calculate the length to send                                         */
    /************************************************************************/
    thisLength = CHANNEL_CHUNK_LENGTH;

    /************************************************************************/
    /* Truncate the data sent if we're about to send more than is left      */
    /************************************************************************/
    if (thisLength >= pDecouple->dataLeft)
    {
        thisLength = pDecouple->dataLeft;
        pDecouple->flags |= CHANNEL_FLAG_LAST;
    }

    TRC_NRM((TB,
            _T("pDecouple %p, src %p, this %lu, left %lu, flags %#lx"),
            pDecouple, pDecouple->pNextData, thisLength,
            pDecouple->dataLeft, pDecouple->flags));

    /************************************************************************/
    /* Get a buffer                                                         */
    /************************************************************************/
    bRc = _pSl->SL_GetBuffer(thisLength + sizeof(CHANNEL_PDU_HEADER),
                             &pBuffer, &bufHnd);
    if (!bRc)
    {
        /********************************************************************/
        /* Failed to get a buffer.  This is not entirely unexpected and is  */
        /* most likely simply due to back-pressure.  The write will be      */
        /* retried when a buffer becomes available (signalled by a call to  */
        /* ChannelOnBufferAvailable).                                       */
        /********************************************************************/
        TRC_NRM((TB, _T("Failed to get %d-byte buffer"), thisLength +
                 sizeof(CHANNEL_PDU_HEADER)));
        DC_QUIT;
    }

    /************************************************************************/
    /* Fill in the Channel PDU                                              */
    /************************************************************************/
    pHdr = (PCHANNEL_PDU_HEADER)pBuffer;
    memcpy((UNALIGNED UINT32 *)&(pHdr->length),
            &(pDecouple->dataLength),sizeof(pDecouple->dataLength));
    memcpy((UNALIGNED UINT32 *)&(pHdr->flags),
           &(pDecouple->flags),sizeof(pDecouple->flags));

    cbOutLen = thisLength;
    compressResult = 0;
    fNeedToDirectCopy = TRUE;
    if(_fCompressChannels &&
       (pDecouple->chanOptions & CHANNEL_OPTION_COMPRESS_RDP))
    {
        if((thisLength > VC_MIN_COMPRESS_INPUT_BUF) &&
           (thisLength < VC_MAX_COMPRESSED_BUFFER))
        {
            //Compress the packet
            if(!_pMPPCContext)
            {
                //Deferred init of the send context
                _pMPPCContext = (SendContext*) UT_Malloc(_pUt,
                                                VC_MAX_COMPRESSED_BUFFER+
                                                sizeof(SendContext));
                if(!_pMPPCContext)
                {
#ifdef OS_WINCE	//Applies to OS_WINNT too
                    _pSl->SL_FreeBuffer(bufHnd);
#endif
                    TRC_ERR((TB,_T("Failed to alloc MPPC send context")));
                    DC_QUIT;
                }
                _fNeedToResetContext = TRUE;
            }

#ifdef DEBUG_CCHAN_COMPRESSION
            if (!_pDbgRcvDecompr8K)
            {
                _fDbgVCTriedAllocRecvContext = TRUE;
                _pDbgRcvDecompr8K = (RecvContext2_8K*)
                    LocalAlloc(LPTR, sizeof(RecvContext2_8K));
                if (_pDbgRcvDecompr8K)
                {
                    _pDbgRcvDecompr8K->cbSize = sizeof(RecvContext2_8K);
                    initrecvcontext(&_DbgRcvContext1,
                                    (RecvContext2_Generic*)_pDbgRcvDecompr8K,
                                    PACKET_COMPR_TYPE_8K);
                }
                else
                {
                    _fDbgAllocFailedForVCRecvContext = TRUE;
                    TRC_ERR((TB,_T("Fail to alloc debug decompression context")));
                    DC_QUIT;
                }
            }
#endif

            if(_fNeedToResetContext)
            {
                //
                //Reset the context at the start of every connection.
                //

                // Server only supports 8K compression from client
                // i.e. it will only decompress with 8K of history
                //
                initsendcontext(_pMPPCContext, PACKET_COMPR_TYPE_8K);
                _fNeedToResetContext = FALSE;
            }
            TRC_ASSERT((_pMPPCContext),
                       (TB,_T("_pMPPCContext is null")));

            compressResult = IntChannelCompressData( (UCHAR*)pDecouple->pNextData,
                                                     thisLength,
                                                     (UCHAR*)(pHdr+1),
                                                     &cbOutLen );
            if(0 != compressResult)
            {
#ifdef DEBUG_CCHAN_COMPRESSION
                //
                // debug: decompresss the packet
                //
                PUCHAR pDecompOutBuf = NULL;
                INT cbDecompLen;
                if (compressResult & PACKET_COMPRESSED)
                {
                    if (compressResult & PACKET_FLUSHED)
                    {
                        initrecvcontext(&_DbgRcvContext1,
                                        (RecvContext2_Generic*)_pDbgRcvDecompr8K,
                                        PACKET_COMPR_TYPE_8K);
                    }

                    if (decompress((PUCHAR)(pHdr+1),
                                   cbOutLen,
                                   (compressResult & PACKET_AT_FRONT), //0 start
                                   &pDecompOutBuf,
                                   &cbDecompLen,
                                   &_DbgRcvContext1,
                                   (RecvContext2_Generic*)_pDbgRcvDecompr8K,
                                   PACKET_COMPR_TYPE_8K))
                    {
                        if (cbDecompLen != thisLength)
                        {
                            DbgUserPrint(_T("Decompress check failed. Inlen!=outlen\n"));
                            DbgUserPrint(_T("Mail tsstress - orig len %d, decompressed len %d\n"),
                                         thisLength,cbDecompLen);
                            DbgUserPrint(_T("pHdr 0x%x, inlen %d\n"),
                                         pHdr, thisLength);
                            DbgUserPrint(_T("compression result %d\n"),compressResult);
                            DbgUserPrint(_T("pDecompOutBuf 0x%x, cbDecompLen %d\n"),
                                     pDecompOutBuf, cbDecompLen);
                            DebugBreak();

                        }
                        if (memcmp(pDecompOutBuf, (PUCHAR)(pDecouple->pNextData), cbDecompLen))
                        {
                            DbgUserPrint(_T("Decompressed buffer does not match original!"));
                            DbgUserPrint(_T("Mail tsstress!"));
                            DbgUserPrint(_T("pHdr 0x%x, inlen %d\n"),
                                         pHdr, thisLength);
                            DbgUserPrint(_T("compression result %d\n"),compressResult);
                            DbgUserPrint(_T("pDecompOutBuf 0x%x, cbDecompLen %d\n"),
                                     pDecompOutBuf, cbDecompLen);

                            DebugBreak();
                        }
                    }
                    else
                    {
                        DbgUserPrint(_T("Decompression check failed!"));
                        DbgUserPrint(_T("Mail tsstress!"));
                        DbgUserPrint(_T("pHdr 0x%x, inlen %d\n"),pHdr, thisLength);
                        DbgUserPrint(_T("compression result %d\n"),compressResult);
                        DbgUserPrint(_T("pDecompOutBuf 0x%x, cbDecompLen %d\n"),
                                 pDecompOutBuf, cbDecompLen);
                        DebugBreak();
                    }
                }
#endif
                //Update the VC packet header flags with the compression info
                UINT32 newFlags = (pDecouple->flags | 
                                   ((compressResult & VC_FLAG_COMPRESS_MASK) <<
                                    VC_FLAG_COMPRESS_SHIFT));
                memcpy((UNALIGNED UINT32 *)&(pHdr->flags),
                        &newFlags,sizeof(newFlags));
                                    
                //Succesfully compressed no need to direct copy
                fNeedToDirectCopy = FALSE;
                cbOutLen += sizeof(CHANNEL_PDU_HEADER);
            }
            else
            {
                _iDbgCompressFailedCount++;
#ifdef DEBUG_CCHAN_COMPRESSION
                DebugBreak();
#endif
                TRC_ERR((TB, _T("IntChannelCompressData failed")));
                _pSl->SL_FreeBuffer(bufHnd);
                DC_QUIT;
            }
        }
    }
    //Copy buffer directly if compression not enabled
    //or the buffer does not fit size range for compression
    if(fNeedToDirectCopy)
    {
        DC_MEMCPY(pHdr+1, pDecouple->pNextData, thisLength);
        cbOutLen = thisLength + sizeof(CHANNEL_PDU_HEADER);
    }

    #ifdef DC_DEBUG
    //Compr counters
    _cbTotalBytesUserAskSend += thisLength;
    _cbTotalBytesSent        += cbOutLen;
    #endif

    TRC_DATA_DBG("Send channel data", pBuffer, cbOutLen);


    /************************************************************************/
    /* Get the channel index                                                */
    /************************************************************************/
    chanIndex = pDecouple->openHandle;


    /************************************************************************/
    /* Send the Channel PDU                                                 */
    /************************************************************************/
    _pSl->SL_SendPacket(pBuffer,
                  cbOutLen,
                  _channelData[chanIndex].SLFlags,
                  bufHnd,
                  _pUi->UI_GetClientMCSID(),
                  _channelData[chanIndex].MCSChannelID,
                  _channelData[chanIndex].priority);

    /************************************************************************/
    /* Set up for next iteration                                            */
    /************************************************************************/
    pDecouple->pNextData = ((HPDCUINT8)(pDecouple->pNextData)) + thisLength;
    pDecouple->dataLeft -= thisLength;
    pDecouple->dataSent += thisLength;
    pDecouple->flags = _channelData[chanIndex].VCFlags;
    TRC_NRM((TB, _T("Done write %p, src %p, sent %lu, left %lu, flags %#lx"),
            pDecouple, pDecouple->pNextData, pDecouple->dataSent,
            pDecouple->dataLeft, pDecouple->flags));

    /************************************************************************/
    /* See if we've finished this operation                                 */
    /************************************************************************/
    if (pDecouple->dataLeft <= 0)
    {
        /********************************************************************/
        /* Remove the operation from the queue                              */
        /********************************************************************/
        _pFirstWrite = pDecouple->pNext;
        if (_pFirstWrite == NULL)
        {
            TRC_NRM((TB, _T("Finished last write")));
            _pLastWrite = NULL;
        }
        else
        {
            TRC_NRM((TB, _T("New first in queue: %p"), _pFirstWrite));
            _pFirstWrite->pPrev = NULL;
        }

        /********************************************************************/
        /* Operation complete - call the callback                           */
        /********************************************************************/
        TRC_NRM((TB, _T("Write %p complete"), pDecouple));

        if(_channelData[chanIndex].pInitHandle->fUsingExApi)
        {
            TRC_ASSERT((NULL != _channelData[chanIndex].pOpenEventExFn),
                    (TB, _T("Callback %p, handle %ld"),
                    _channelData[chanIndex].pOpenEventExFn,
                    pDecouple->openHandle));

            /************************************************************************/
            /* Is the channel still open?  This was checked in                      */
            /* IntVirtualChannelWrite, but that was before the post to this thread. */
            /* If the VC was closed, it's possible we no longer have callback       */
            /* pointers.                                                            */
            /************************************************************************/
            if (NULL != _channelData[chanIndex].pOpenEventExFn)
            {
                _channelData[chanIndex].pOpenEventExFn(
                       _channelData[chanIndex].pInitHandle->lpParam,
                                                      pDecouple->openHandle,
                                                      CHANNEL_EVENT_WRITE_COMPLETE,
                                                      pDecouple->pUserData,
                                                      0, 0, 0);
            }
        }
        else
        {
            TRC_ASSERT((NULL != _channelData[chanIndex].pOpenEventFn),
                    (TB, _T("Callback %p, handle %ld"),
                    _channelData[chanIndex].pOpenEventFn,
                    pDecouple->openHandle));

            if (NULL != _channelData[chanIndex].pOpenEventFn)
            {
                _channelData[chanIndex].pOpenEventFn( pDecouple->openHandle,
                                                      CHANNEL_EVENT_WRITE_COMPLETE,
                                                      pDecouple->pUserData,
                                                      0, 0, 0);
            }
        }

        /********************************************************************/
        /* Free the request                                                 */
        /********************************************************************/
        UT_Free( _pUt,pDecouple);
    }

    /************************************************************************/
    /* Kick the process again if there's anything left to do                */
    /************************************************************************/
    if (_pFirstWrite != NULL)
    {
        TRC_NRM((TB, _T("More work to do %p"), _pFirstWrite));
        _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT,
                                            this,
                                            CD_NOTIFICATION_FUNC(CChan,IntChannelSend),
                                            CHANNEL_MSG_SEND);
    }

    /************************************************************************/
    /* Note that if we failed to get a buffer above, we won't kick the      */
    /* process into continuing.  This is done later, on receipt of an       */
    /* OnBufferAvailable callback from SL.                                  */
    /************************************************************************/

DC_EXIT_POINT:
    DC_END_FN();
    return;
} /* IntChannelSend  */


/**PROC+*********************************************************************/
/* Name:      IntChannelWrite                                               */
/*                                                                          */
/* Purpose:   Start writing data to the Server                              */
/*                                                                          */
/* Returns:   none                                                          */
/*                                                                          */
/* Params:    pData - CHANNEL_WRITE_DECOUPLE structure                      */
/*            dataLength - length of pData                                  */
/*                                                                          */
/* Operation: Called on SND thread                                          */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCINTERNAL CChan::IntChannelWrite(PDCVOID pData, DCUINT dataLength)
{
    PCHANNEL_WRITE_DECOUPLE pDecouple;
    DC_BEGIN_FN("IntChannelWrite");
#ifndef DC_DEBUG
    UNREFERENCED_PARAMETER(dataLength);
#endif

    /************************************************************************/
    /* Check parameters                                                     */
    /************************************************************************/
    TRC_ASSERT((dataLength == sizeof(PCHANNEL_WRITE_DECOUPLE)),
                (TB, _T("Wrong size data: is/expect %d/%d"),
                dataLength, sizeof(PCHANNEL_WRITE_DECOUPLE)));

    TRC_ASSERT((((_pFirstWrite == NULL) && (_pLastWrite == NULL)) ||
                ((_pFirstWrite != NULL) && (_pLastWrite != NULL))),
                (TB,_T("Invalid queue, pFirst %p, pLast %p"),
                _pFirstWrite, _pLastWrite));

    pDecouple = *((PPCHANNEL_WRITE_DECOUPLE)pData);
    TRC_NRM((TB, _T("Receive %p -> %p"), pData, pDecouple));
    TRC_ASSERT((pDecouple->signature == CHANNEL_DECOUPLE_SIGNATURE),
                (TB,_T("Invalid decouple signature %#lx"), pDecouple->signature));

    /************************************************************************/
    /* Add this request to the queue                                        */
    /************************************************************************/
    if (_pFirstWrite == NULL)
    {
        /********************************************************************/
        /* Empty queue                                                      */
        /********************************************************************/
        TRC_NRM((TB, _T("Empty queue")));
        _pFirstWrite = pDecouple;
        _pLastWrite = pDecouple;
    }
    else
    {
        /********************************************************************/
        /* Non-empty queue                                                  */
        /********************************************************************/
        TRC_NRM((TB, _T("Non-empty queue: first %p, last %p"),
                _pFirstWrite, _pLastWrite));
        pDecouple->pPrev = _pLastWrite;
        _pLastWrite->pNext = pDecouple;
        _pLastWrite = pDecouple;
    }
    TRC_ASSERT((_pFirstWrite->signature == CHANNEL_DECOUPLE_SIGNATURE),
                (TB,_T("Invalid first signature %#lx"), _pFirstWrite->signature));
    TRC_ASSERT((_pLastWrite->signature == CHANNEL_DECOUPLE_SIGNATURE),
                (TB,_T("Invalid last signature %#lx"), _pLastWrite->signature));

    /************************************************************************/
    /* Try to send the data                                                 */
    /************************************************************************/
    IntChannelSend(CHANNEL_MSG_SEND);

    DC_END_FN();
    return;
} /* IntChannelWrite */


/**PROC+*********************************************************************/
/* Name:      IntChannelLoad                                                */
/*                                                                          */
/* Purpose:   Load an Addin                                                 */
/*                                                                          */
/* Returns:   none                                                          */
/*                                                                          */
/* Params:    DLLName - name of Addin DLL to load                           */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCINTERNAL CChan::IntChannelLoad(PDCTCHAR DLLName)
{
    DCBOOL rc = FALSE;
    PVIRTUALCHANNELENTRY pChannelEntry;
    PVIRTUALCHANNELENTRYEX pChannelEntryEx;
    HMODULE hMod;
    PCHANNEL_INIT_HANDLE pAddin;

    DC_BEGIN_FN("IntChannelLoad");

    /************************************************************************/
    /* Load the DLL                                                         */
    /************************************************************************/
    hMod = LoadLibrary(DLLName);
    if (!hMod)
    {
        TRC_ERR((TB, _T("Failed to load %s"), DLLName));
        DC_QUIT;
    }
    TRC_NRM((TB, _T("Loaded %s (%p)"), DLLName, hMod));

    /************************************************************************/
    /* Search the already-loaded Addins in case this is a duplicate         */
    /************************************************************************/
    for (pAddin = _pInitHandle; pAddin != NULL; pAddin = pAddin->pNext)
    {
        TRC_DBG((TB, _T("Compare %s, %p, %p"), DLLName, pAddin->hMod, hMod));
        if (pAddin->hMod == hMod)
        {
            TRC_ERR((TB, _T("Reloading %s (%p)"), DLLName, hMod));
            DC_QUIT;
        }
    }

    /************************************************************************/
    /* DLL loaded OK - find its VirtualChannelEntry function                */
    /************************************************************************/

    //
    // First try to find the Ex entry point
    //
    pChannelEntryEx = (PVIRTUALCHANNELENTRYEX)GetProcAddress(hMod,
                                                 CE_WIDETEXT("VirtualChannelEntryEx"));
    if(pChannelEntryEx)
    {
        TRC_NRM((TB,_T("Found EX entry point, Init using ex api: %s"), DLLName));
        IntChannelInitAddin( NULL, pChannelEntryEx, hMod, DLLName, NULL);
    }
    else
    {
        //
        // Only try to load legacy DLL's from the first instance
        //
        if( CChan::pStaticClientInstance == this)
        {
            TRC_NRM((TB,_T("Did not find EX entry point, looking for old api: %s"), DLLName));
            pChannelEntry = (PVIRTUALCHANNELENTRY)GetProcAddress(hMod,
                                                        CE_WIDETEXT("VirtualChannelEntry"));
            if (pChannelEntry == NULL)
            {
                TRC_ERR((TB, _T("Failed to find VirtualChannelEntry in %s"),
                        DLLName));
                DC_QUIT;
            }
    
            IntChannelInitAddin( pChannelEntry, NULL, hMod, DLLName, NULL);
        }
    }

DC_EXIT_POINT:
    DC_END_FN();
    return;
} /* IntChannelLoad */

/**PROC+*********************************************************************/
/* Name:      IntChannelInitAddin                                           */
/*                                                                          */
/* Purpose:   Initialize addin given it's entry point                       */
/*                                                                          */
/* Returns:   Success flag                                                  */
/*                                                                          */
/* Params:    pChannelEntry - Addin entry point                             */
/*                                                                          */
/**PROC-*********************************************************************/
DCBOOL DCINTERNAL CChan::IntChannelInitAddin(PVIRTUALCHANNELENTRY pChannelEntry,
                                             PVIRTUALCHANNELENTRYEX pChannelEntryEx,
                                             HMODULE hMod,
                                             PDCTCHAR DLLName,
                                             PVOID    pPassParamToEx)
{
    DCBOOL rc = FALSE;
    PCHANNEL_ENTRY_POINTS pTempEntryPoints = NULL;
    PCHANNEL_ENTRY_POINTS_EX pTempEntryPointsEx = NULL;
    UINT i=0;
    
    DC_BEGIN_FN("IntChannelInitAddin");

    _newInitHandle = NULL;

    if (pChannelEntry == NULL && pChannelEntryEx == NULL)
    {
        TRC_ERR((TB, _T("Invalid VirtualChannelEntry")));
        DC_QUIT;
    }

    if (DLLName == NULL)
    {
        TRC_ERR((TB, _T("Invalid DLLName")));
        DC_QUIT;
    }

    TRC_NRM((TB, _T("VirtualChannelEntry at %p"), pChannelEntry));
    TRC_NRM((TB, _T("VirtualChannelEntryEx at %p"), pChannelEntryEx));

    /************************************************************************/
    /* Allocate and initialize a handle                                     */
    /************************************************************************/
    _newInitHandle = (PCHANNEL_INIT_HANDLE)UT_Malloc( _pUt,sizeof(CHANNEL_INIT_HANDLE));
    if (_newInitHandle == NULL)
    {
        TRC_ERR((TB, _T("Failed to allocate handle")));
        DC_QUIT;
    }

    _newInitHandle->signature = CHANNEL_INIT_SIGNATURE;
    _newInitHandle->hMod = hMod;
    _newInitHandle->pInst = this;

    //
    //ChannelCount for this addin is marked as 0 now
    //it will be updated by the plugin's calls to VirtualChannelInit
    //if VirtualChannelEntry returns false, this count will be used
    //to rollback any created channels.
    //
    _newInitHandle->channelCount = 0;
    //
    // Internal addin's can get params passed back down
    // today this is used so the control can pass it's internal
    // an interface pointer to the virtual channel scripting addin
    //
    _newInitHandle->lpInternalAddinParam = pPassParamToEx;

    /************************************************************************/
    /* Allocate and fill a temporary structure in which to pass the entry   */
    /* points.  This keeps our global entry points structure safe from      */
    /* badly-behaved addins that could overwrite it and stop other addins   */
    /* from working correctly.  Note that addins must copy this structure   */
    /* -- it is only valid during this call to VirtualChannelEntry.         */
    /************************************************************************/
    if(pChannelEntryEx)
    {
        pTempEntryPointsEx  = (PCHANNEL_ENTRY_POINTS_EX)UT_Malloc(
             _pUt,sizeof(CHANNEL_ENTRY_POINTS_EX));
        if (pTempEntryPointsEx == NULL)
        {
            TRC_ERR((TB, _T("Failed to allocate temporary entry points (Ex) structure")));
            DC_QUIT;
        }
    
        DC_MEMCPY(pTempEntryPointsEx,
                  &_channelEntryPointsEx,
                  sizeof(CHANNEL_ENTRY_POINTS_EX));
    }
    else
    {
        pTempEntryPoints = (PCHANNEL_ENTRY_POINTS)UT_Malloc( _pUt,sizeof(CHANNEL_ENTRY_POINTS));
        if (pTempEntryPoints == NULL)
        {
            TRC_ERR((TB, _T("Failed to allocate temporary entry points structure")));
            DC_QUIT;
        }
    
        DC_MEMCPY(pTempEntryPoints,
                  &_channelEntryPoints,
                  sizeof(CHANNEL_ENTRY_POINTS));
    }

    /************************************************************************/
    /* Call VirtualChannelEntry                                             */
    /************************************************************************/
    _ChannelInitCalled = FALSE;
    
    _inChannelEntry = TRUE;
    if(pChannelEntryEx)
    {
        //
        // Pass the adddin a pointer to the new init handle
        //
        rc = pChannelEntryEx(pTempEntryPointsEx, _newInitHandle);
    }
    else
    {
        rc = pChannelEntry(pTempEntryPoints);
    }
    _inChannelEntry = FALSE;

    if (!rc)
    {
        TRC_NRM((TB, _T("ChannelEntry aborted")));
        DC_QUIT;
    }

    /************************************************************************/
    /* Make sure that the Addin called VirtualChannelInit from              */
    /* VirtualChannelEntry                                                  */
    /************************************************************************/
    if (!_ChannelInitCalled)
    {
        TRC_ERR((TB, _T("Addin %s didn't call VirtualChannelInit"), DLLName));
        rc = FALSE;
        DC_QUIT;
    }

    /************************************************************************/
    /* Everything OK - insert this handle into chain of Init Handles        */
    /************************************************************************/
    _newInitHandle->pPrev = NULL;
    _newInitHandle->pNext = _pInitHandle;
    if (_pInitHandle != NULL)
    {
        _pInitHandle->pPrev = _newInitHandle;
    }
    _pInitHandle = _newInitHandle;

    rc = TRUE;

DC_EXIT_POINT:
    if (!rc)
    {
        TRC_NRM((TB, _T("Something failed - tidy up")));
        if (hMod)
        {
            TRC_NRM((TB, _T("Free the library")));
            FreeLibrary(hMod);
        }
        if (_newInitHandle)
        {
            //
            // Remove any channel entries that were created
            // for this plugin. These should be consecutive channels at the tail
            // of the channels array.
            //
            if(_newInitHandle->channelCount)
            {
                UINT startRemoveIdx = _channelCount - _newInitHandle->channelCount;
                TRC_ASSERT((startRemoveIdx < _channelCount),
                           (TB,_T("startRemoveIdx for channel cleanup is invalid")));
                if(startRemoveIdx < _channelCount)
                {
                    //
                    // Rollback creation of virtual channels
                    //
                    for( i=startRemoveIdx; i<_channelCount; i++)
                    {
                        TRC_ASSERT((_channelData[i].pInitHandle == _newInitHandle),
                         (TB,_T("_channelData[i].pInitHandle != _newInitHandle on rollback")));
                        if(_channelData[i].pInitHandle == _newInitHandle)
                        {
                            _channel[i].options = ~CHANNEL_OPTION_INITIALIZED;
                            DC_MEMSET(_channel[i].name, 0, CHANNEL_NAME_LEN+1);
                            _channelData[i].pOpenEventExFn = NULL;
                            _channelData[i].pOpenEventFn = NULL;
                            _channelData[i].status = CHANNEL_STATUS_CLOSED;
                        }
                        else
                        {
                            break;
                        }
                    }
                    _channelCount -= _newInitHandle->channelCount;
                }
            }

            TRC_NRM((TB, _T("Free unused handle")));
            UT_Free( _pUt,_newInitHandle);
        }
    }

    if (pTempEntryPoints)
    {
        UT_Free( _pUt,pTempEntryPoints);
    }

    if (pTempEntryPointsEx)
    {
        UT_Free( _pUt, pTempEntryPointsEx);
    }

    DC_END_FN();
    return rc;
} /* IntChannelInitAddin */

/**PROC+*********************************************************************/
/* Name:      IntChannelCancelSend                                          */
/*                                                                          */
/* Purpose:   Cancel outstanding send requests                              */
/*                                                                          */
/* Returns:   none                                                          */
/*                                                                          */
/* Params:    value - message passed from caller                            */
/*                                                                          */
/* Operation: Called on SND thread                                          */
/*                                                                          */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCINTERNAL CChan::IntChannelCancelSend(ULONG_PTR value)
{
    PCHANNEL_WRITE_DECOUPLE pDecouple;
    PCHANNEL_WRITE_DECOUPLE pFree;
    DWORD                   chanIndex = 0xFDFDFDFD;

    DC_BEGIN_FN("IntChannelCancelSend");

    //UNREFERENCED_PARAMETER( value );

    pDecouple = _pFirstWrite;
    while (pDecouple != NULL)
    {
        TRC_ASSERT((pDecouple->signature == CHANNEL_DECOUPLE_SIGNATURE),
                 (TB,_T("Invalid decouple signature %#lx"), pDecouple->signature));

        chanIndex = pDecouple->openHandle;

        if ((value == CHANNEL_MSG_SUSPEND) &&
            (_channelData[chanIndex].VCFlags & CHANNEL_FLAG_SHADOW_PERSISTENT)) {

            // skip this one as it should not be closed
            pDecouple = pDecouple->pNext;
            continue;
        }

        /********************************************************************/
        /* Call the callback                                                */
        /********************************************************************/
        TRC_NRM((TB, _T("Write %p cancelled"), pDecouple));

        if(_channelData[chanIndex].pInitHandle->fUsingExApi)
        {
            _channelData[chanIndex].pOpenEventExFn(
                                               _channelData[chanIndex].pInitHandle->lpParam,
                                                  pDecouple->openHandle,
                                                  CHANNEL_EVENT_WRITE_CANCELLED,
                                                  pDecouple->pUserData,
                                                  0, 0, 0);
        }
        else
        {
            _channelData[chanIndex].pOpenEventFn( pDecouple->openHandle,
                                                  CHANNEL_EVENT_WRITE_CANCELLED,
                                                  pDecouple->pUserData,
                                                  0, 0, 0);
        }

        /********************************************************************/
        /* Free the decouple structure                                      */
        /********************************************************************/
        pFree = pDecouple;
        pDecouple = pDecouple->pNext;

        if (pDecouple) {
            pDecouple->pPrev = pFree->pPrev;
        } else {
            _pLastWrite = pFree->pPrev;
        }

        if (pFree->pPrev) {
            pFree->pPrev->pNext = pDecouple;
        } else {
            _pFirstWrite = pDecouple;
        }

        pFree->signature = 0;
        UT_Free( _pUt,pFree);
    }

    if (value != CHANNEL_MSG_SUSPEND) {
        _pFirstWrite = NULL;
        _pLastWrite = NULL;
    }

    DC_END_FN();
    return;
} /* IntChannelCancelSend */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\cd.h ===
/****************************************************************************/
// cd.h
//
// Component Decoupler Class
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#ifndef _H_CD
#define _H_CD


extern "C" {
    #include <adcgdata.h>
}

#include "objs.h"

/****************************************************************************/
/* Component IDs                                                            */
/****************************************************************************/
#define   CD_UI_COMPONENT   0
#define   CD_SND_COMPONENT  1
#define   CD_RCV_COMPONENT  2

#define   CD_MAX_COMPONENT  2
#define   CD_NUM_COMPONENTS 3


/****************************************************************************/
/* CD_NOTIFICATION_FN:                                                      */
/*                                                                          */
/* Callback for notifications.                                              */
/****************************************************************************/
typedef DCVOID DCAPI CD_NOTIFICATION_FN( PDCVOID pInst,
                                         PDCVOID pData,
                                         DCUINT  dataLength );
typedef CD_NOTIFICATION_FN DCPTR PCD_NOTIFICATION_FN;


/****************************************************************************/
/* CD_SIMPLE_NOTIFICATION_FN:                                               */
/*                                                                          */
/* Callback for simple notifications (can only pass a single ULONG_PTR).    */
/****************************************************************************/
typedef DCVOID DCAPI CD_SIMPLE_NOTIFICATION_FN(PDCVOID pInst, ULONG_PTR value);
typedef CD_SIMPLE_NOTIFICATION_FN DCPTR PCD_SIMPLE_NOTIFICATION_FN;


/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/
#define CD_WINDOW_CLASS _T("ComponentDecouplerClass")

#define CD_NOTIFICATION_MSG         (DUC_CD_MESSAGE_BASE)
#define CD_SIMPLE_NOTIFICATION_MSG  (DUC_CD_MESSAGE_BASE+1)

#define CD_MAX_NOTIFICATION_DATA_SIZE (0xFFFF - sizeof(CDTRANSFERBUFFERHDR))

/****************************************************************************/
/* Transfer buffers used by CD_DecoupleNotification.  The largest size      */
/* required is used to pass connection userdata between Network Layer       */
/* components.                                                              */
/* The number of buffers reflects the usage during connection startup       */
/****************************************************************************/
#define CD_CACHED_TRANSFER_BUFFER_SIZE  0x100
#define CD_NUM_CACHED_TRANSFER_BUFFERS  32 //changed from 6

/****************************************************************************/
/*                                                                          */
/* STRUCTURES                                                               */
/*                                                                          */
/****************************************************************************/
/**STRUCT+*******************************************************************/
/* Structure: CDTRANSFERBUFFER                                              */
/*                                                                          */
/* Description: structure for buffer passed with decoupled notifications    */
/****************************************************************************/
typedef struct tagCDTRANSFERBUFFERHDR
{
    PCD_NOTIFICATION_FN  pNotificationFn;
    PCD_SIMPLE_NOTIFICATION_FN pSimpleNotificationFn;
    PDCVOID              pInst;
} CDTRANSFERBUFFERHDR;

typedef struct tagCDTRANSFERBUFFER
{
    CDTRANSFERBUFFERHDR  hdr;
    DCUINT8              data[1];
} CDTRANSFERBUFFER;
typedef CDTRANSFERBUFFER DCPTR PCDTRANSFERBUFFER;

typedef DCUINT8 CDCACHEDTRANSFERBUFFER[CD_CACHED_TRANSFER_BUFFER_SIZE];


/**STRUCT+*******************************************************************/
/* Structure: CD_COMPONENT_DATA                                             */
/*                                                                          */
/* Description: Component Decoupler component data                          */
/*                                                                          */
/* Note that the transferBufferInUse flags are declared as a separate       */
/* array so that when we search for a free buffer we look at contiguous     */
/* bytes rather than bytes separated by the size of a Transfer Buffer       */
/* i.e. it makes the most of processor memory caching.                      */
/****************************************************************************/
typedef struct tagCD_COMPONENT_DATA
{
#ifdef DC_DEBUG
    DCINT32                pendingMessageCount;   /* must be 4-byte aligned */
    DCINT32                pad; /*transferBuffer must start on a processor word boundary*/
#endif
    CDCACHEDTRANSFERBUFFER transferBuffer[CD_NUM_CACHED_TRANSFER_BUFFERS];
    DCBOOL32               transferBufferInUse[
                                              CD_NUM_CACHED_TRANSFER_BUFFERS];
    HWND                   hwnd[CD_NUM_COMPONENTS];
} CD_COMPONENT_DATA;
/**STRUCT-*******************************************************************/



//
// MACROS to create static versions of notification functions that
// are CD callable
//
// This is needed because the CD does not support getting C++ pointer-to-member's
// changing that would require having a copy of all the CD for each possible
// class type that makes CD calls.
//

#define EXPOSE_CD_SIMPLE_NOTIFICATION_FN(class_name, fn_name)                   \
    public:                                                                     \
    static DCVOID DCAPI MACROGENERATED_Static_##fn_name(                        \
                                            PDCVOID inst, ULONG_PTR param_name) \
    {                                                                           \
        ((class_name*)inst)->##fn_name(param_name);                             \
    }                                                                           \


#define EXPOSE_CD_NOTIFICATION_FN(class_name, fn_name)                                             \
    public:                                                                                        \
    static DCVOID DCAPI MACROGENERATED_Static_##fn_name(                                           \
                                            PDCVOID inst, PDCVOID param1_name, DCUINT param2_name) \
    {                                                                                              \
        ((class_name*)inst)->##fn_name(param1_name, param2_name);                                  \
    }
    
#define CD_NOTIFICATION_FUNC(class_name, fn_name)                                                  \
            class_name::MACROGENERATED_Static_##fn_name


class CUT;
class CUI;

class CCD
{
public:
    CCD(CObjs* objs);
    ~CCD();

    DCVOID DCAPI CD_TestNotify(DCUINT uni);
    DCVOID DCAPI CD_otify(DCUINT uni,int fo);

public:
    //
    // API
    //

    /****************************************************************************/
    /* FUNCTIONS                                                                */
    /****************************************************************************/
    DCVOID DCAPI CD_Init(DCVOID);
    DCVOID DCAPI CD_Term(DCVOID);
    
    HRESULT DCAPI CD_RegisterComponent(DCUINT component);
    HRESULT DCAPI CD_UnregisterComponent(DCUINT component);
    
    //
    // Notifications..pass a buffer and a length
    //

    BOOL DCAPI CD_DecoupleNotification(unsigned,PDCVOID, PCD_NOTIFICATION_FN, PDCVOID,
            unsigned);
    
    BOOL DCAPI CD_DecoupleSyncDataNotification(unsigned,PDCVOID, PCD_NOTIFICATION_FN,
            PDCVOID, unsigned);
    //
    // Simple notifications (accept one parameter)
    //
    BOOL DCAPI CD_DecoupleSimpleNotification(unsigned,PDCVOID, PCD_SIMPLE_NOTIFICATION_FN,
            ULONG_PTR);
    
    BOOL DCAPI CD_DecoupleSyncNotification(unsigned,PDCVOID, PCD_SIMPLE_NOTIFICATION_FN,
            ULONG_PTR);


public:
    //
    // Public data members
    //

    CD_COMPONENT_DATA _CD;


private:
    //
    // Internal functions
    //
    
    /****************************************************************************/
    /*                                                                          */
    /* FUNCTIONS                                                                */
    /*                                                                          */
    /****************************************************************************/
    
    PCDTRANSFERBUFFER DCINTERNAL CDAllocTransferBuffer(DCUINT dataLength);
    DCVOID DCINTERNAL CDFreeTransferBuffer(PCDTRANSFERBUFFER pTransferBuffer);
    
    
    static LRESULT CALLBACK CDStaticWndProc( HWND   hwnd,
                                UINT   message,
                                WPARAM wParam,
                                LPARAM lParam );

    LRESULT CALLBACK CDWndProc( HWND   hwnd,
                                UINT   message,
                                WPARAM wParam,
                                LPARAM lParam );

private:
    CUT* _pUt;
    CUI* _pUi;
    
private:
    CObjs* _pClientObjects;
    BOOL   _fCDInitComplete;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\cdint.cpp ===
/**MOD+**********************************************************************/
/* Module:    cdint.cpp                                                     */
/*                                                                          */
/* Purpose:   Component Decoupler internal functions                        */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1999                             */
/*                                                                          */
/****************************************************************************/

#include <adcg.h>
extern "C" {
#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "acdint"
#include <atrcapi.h>
}

#include "cd.h"
#include "autil.h"
#include "wui.h"


/**PROC+*********************************************************************/
/* Name:      CDAllocTransferBuffer                                         */
/*                                                                          */
/* Purpose:   Allocates a transfer buffer of a given size to pass between   */
/*            components / threads.                                         */
/*            The function is thread safe.                                  */
/*                                                                          */
/* Returns:   Pointer to allocated buffer.                                  */
/*                                                                          */
/* Params:    IN    dataLength - the size of buffer to be allocated.        */
/*                                                                          */
/* Operation: Several cached transfer buffers are maintained to avoid       */
/*            continual dynamic allocation/free operations.  If the         */
/*            allocation request cannot be satisfied by the available       */
/*            cached buffers a dynamic memory allocation is made.           */
/*                                                                          */
/**PROC-*********************************************************************/
PCDTRANSFERBUFFER DCINTERNAL CCD::CDAllocTransferBuffer(DCUINT dataLength)
{
    DCUINT             i;
    DCUINT             transferBufferLength;
    PCDTRANSFERBUFFER  rc;

    DC_BEGIN_FN("CDAllocTransferBuffer");

    /************************************************************************/
    /* Calculate the Transfer Buffer size (including header).               */
    /************************************************************************/
    transferBufferLength = sizeof(CDTRANSFERBUFFERHDR) + dataLength;
    if (transferBufferLength <= CD_CACHED_TRANSFER_BUFFER_SIZE)
    {
        TRC_DBG((TB, _T("Look in cache")));

        /********************************************************************/
        /* Search for a free cached Transfer Buffer.                        */
        /*                                                                  */
        /* We need to do this in a thread-safe way, so we use an            */
        /* interlocked exchange on the "in use" flag.                       */
        /********************************************************************/
        for (i = 0; i < CD_NUM_CACHED_TRANSFER_BUFFERS; i++)
        {
            TRC_DBG((TB, _T("Look in cache %d"), i));
            if (!_pUt->UT_InterlockedExchange(&(_CD.transferBufferInUse[i]), TRUE))
            {
                TRC_NRM((TB, _T("Using cached buffer(%u)"), i));
                rc = (PCDTRANSFERBUFFER)&(_CD.transferBuffer[i]);
                DC_QUIT;
            }
        }
    }

    /************************************************************************/
    /* We can't use a cached Transfer Buffer, so we have to allocate one.   */
    /************************************************************************/
    TRC_ALT((TB, _T("Dynamic buffer allocation: length(%d)"),
                                                       transferBufferLength));
    rc = (PCDTRANSFERBUFFER)UT_Malloc(_pUt, transferBufferLength);
    if (rc == NULL)
    {
        _pUi->UI_FatalError(DC_ERR_OUTOFMEMORY);
    }

DC_EXIT_POINT:
    DC_END_FN();
    return(rc);
}


/**PROC+*********************************************************************/
/* Name:      CDFreeTransferBuffer                                          */
/*                                                                          */
/* Purpose:   Frees a Transfer Buffer allocated via a previous call to      */
/*            CDAllocTransferBuffer.                                        */
/*                                                                          */
/* Returns:   Nothing.                                                      */
/*                                                                          */
/* Params:    IN   pTransferBuffer - pointer to buffer to free              */
/*                                                                          */
/* Operation: Either frees the given cached Transfer Buffer, or frees the   */
/*            dynamically allocated memory.                                 */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCINTERNAL CCD::CDFreeTransferBuffer(PCDTRANSFERBUFFER pTransferBuffer)
{
    DCUINT  iTransferBuffer;

    DC_BEGIN_FN("CDFreeTransferBuffer");

    TRC_ASSERT((pTransferBuffer != NULL), (TB, _T("NULL pTransferBuffer")));

    /************************************************************************/
    /* Determine whether the supplied buffer is one of our cached buffers.  */
    /************************************************************************/
    if ((pTransferBuffer >= (PCDTRANSFERBUFFER)&(_CD.transferBuffer[0])) &&
        (pTransferBuffer <= (PCDTRANSFERBUFFER)
                      &(_CD.transferBuffer[CD_NUM_CACHED_TRANSFER_BUFFERS-1])))
    {
        iTransferBuffer = (DCUINT)
          (((ULONG_PTR)pTransferBuffer) -
                              ((ULONG_PTR)(PDCVOID)&(_CD.transferBuffer[0]))) /
                                                 sizeof(_CD.transferBuffer[0]);

        TRC_ASSERT((pTransferBuffer == (PCDTRANSFERBUFFER)
                                       &(_CD.transferBuffer[iTransferBuffer])),
                   (TB, _T("Invalid Transfer Buffer pointer(%p) expected(%p)"),
                        pTransferBuffer,
                        &(_CD.transferBuffer[iTransferBuffer])));

        TRC_ASSERT((_CD.transferBufferInUse[iTransferBuffer]),
                   (TB, _T("Transfer buffer(%u) not in use"), iTransferBuffer));

        _CD.transferBufferInUse[iTransferBuffer] = FALSE;
    }
    else
    {
        /********************************************************************/
        /* This memory must be a dynamic allocation.                        */
        /********************************************************************/
        UT_Free(_pUt, pTransferBuffer);
    }

    DC_END_FN();
    return;
}

/**PROC+*********************************************************************/
/* Name:      CDStaticWndProc                                               */
/*                                                                          */
/* Purpose:   Window Procedure for CD windows (Static version)              */
/*                                                                          */
/* Returns:   Windows return code                                           */
/*                                                                          */
/* Params:    IN      hwnd    - window handle                               */
/*            IN      message - message                                     */
/*            IN      wParam  - parameter                                   */
/*            IN      lParam  - parameter                                   */
/*                                                                          */
/**PROC-*********************************************************************/
LRESULT CALLBACK CCD::CDStaticWndProc(HWND   hwnd,
                           UINT   message,
                           WPARAM wParam,
                           LPARAM lParam)
{
    CCD* pCD = (CCD*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if(WM_CREATE == message)
    {
        //pull out the this pointer and stuff it in the window class
        LPCREATESTRUCT lpcs = (LPCREATESTRUCT) lParam;
        pCD = (CCD*)lpcs->lpCreateParams;

        SetWindowLongPtr( hwnd, GWLP_USERDATA, (LONG_PTR)pCD);
    }
    
    //
    // Delegate the message to the appropriate instance
    //

    if(pCD)
    {
        return pCD->CDWndProc(hwnd, message, wParam, lParam);
    }
    else
    {
        return DefWindowProc(hwnd, message, wParam, lParam);
    }
    
}



/**PROC+*********************************************************************/
/* Name:      CDWndProc                                                     */
/*                                                                          */
/* Purpose:   Window Procedure for CD windows                               */
/*                                                                          */
/* Returns:   Windows return code                                           */
/*                                                                          */
/* Params:    IN      hwnd    - window handle                               */
/*            IN      message - message                                     */
/*            IN      wParam  - parameter                                   */
/*            IN      lParam  - parameter                                   */
/*                                                                          */
/**PROC-*********************************************************************/
LRESULT CALLBACK CCD::CDWndProc(HWND   hwnd,
                           UINT   message,
                           WPARAM wParam,
                           LPARAM lParam)
{
    PCDTRANSFERBUFFER    pTransferBuffer;
    LRESULT              rc = 0;

    DC_BEGIN_FN("CDWndProc");

    switch (message)
    {
        case CD_SIMPLE_NOTIFICATION_MSG:
        {
            PCD_SIMPLE_NOTIFICATION_FN pNotificationFn;
            PDCVOID                    pInst;
            ULONG_PTR                  msg;

#ifdef DC_DEBUG
            /****************************************************************/
            /* Trace is before decrement so that the point at which we're   */
            /* most likely to get pre-empted (TRC_GetBuffer) is before all  */
            /* references to the variable we're interested in.              */
            /****************************************************************/
            TRC_NRM((TB, _T("Messages now pending: %ld"),
                         _CD.pendingMessageCount - 1));
            _pUt->UT_InterlockedDecrement(&_CD.pendingMessageCount);
#endif

            /****************************************************************/
            /* Simple notification:                                         */
            /*     lParam contains transfer buffer                          */
            /*     The transfer buffer contains no data payload, just the   */
            /*      function pointer and object instance pointer.           */
            /*     wParam contains message                                  */
            /****************************************************************/


            pTransferBuffer = (PCDTRANSFERBUFFER)lParam;
            pNotificationFn = pTransferBuffer->hdr.pSimpleNotificationFn;
            pInst           = pTransferBuffer->hdr.pInst;


            msg = (ULONG_PTR) wParam;
            TRC_ASSERT((pNotificationFn != NULL),
                       (TB, _T("NULL pNotificationFn")));
            TRC_ASSERT((pInst != NULL), (TB, _T("NULL pInst")));

            TRC_ASSERT((pTransferBuffer != NULL), (TB, _T("NULL pInst")));

            TRC_NRM((TB, _T("Simple notification: pfn(%p) msg(%u)"),
                                                       pNotificationFn, msg));

            /****************************************************************/
            /* Call the function.                                           */
            /****************************************************************/

            (*pNotificationFn)(pInst, msg);

            /****************************************************************/
            /* Release the memory allocated for this transfer buffer.       */
            /****************************************************************/
            CDFreeTransferBuffer(pTransferBuffer);
        }
        break;

        case CD_NOTIFICATION_MSG:
        {
            PCD_NOTIFICATION_FN pNotificationFn;
            PDCVOID             pData;
            DCUINT              dataLength;
            PDCVOID             pInst;

#ifdef DC_DEBUG
            /****************************************************************/
            /* Trace is before decrement so that the point at which we're   */
            /* most likely to get pre-empted (TRC_GetBuffer) is before all  */
            /* references to the variable we're interested in.              */
            /****************************************************************/
            TRC_NRM((TB, _T("Messages now pending: %ld"),
                         _CD.pendingMessageCount - 1));
            _pUt->UT_InterlockedDecrement(&_CD.pendingMessageCount);
#endif
            /****************************************************************/
            /* Notification:                                                */
            /*     lParam contains pointer to CD transfer buffer            */
            /*     wParam contains dataLength                               */
            /****************************************************************/
            pTransferBuffer = (PCDTRANSFERBUFFER)lParam;
            pNotificationFn = pTransferBuffer->hdr.pNotificationFn;
            dataLength = (DCUINT) wParam;
            pData = &(pTransferBuffer->data[0]);
            pInst =     pTransferBuffer->hdr.pInst;

            TRC_ASSERT((pNotificationFn != NULL),
                       (TB, _T("NULL pNotificationFn")));
            TRC_ASSERT((pInst != NULL), (TB, _T("NULL pInst")));

            TRC_NRM((TB, _T("Notification: pfn(%p) pData(%p) dataLength(%u)"),
                                         pNotificationFn, pData, dataLength));

            (*pNotificationFn)(pInst, pData, dataLength);

            /****************************************************************/
            /* Release the memory allocated for this transfer buffer.       */
            /****************************************************************/
            CDFreeTransferBuffer(pTransferBuffer);
        }
        break;

        default:
        {
            /****************************************************************/
            /* Ignore other messages - pass to the default window handler.  */
            /****************************************************************/
            TRC_DBG((TB, _T("Non-notification message %x"), message));
            rc = DefWindowProc(hwnd, message, wParam, lParam);
        }
        break;
    }

    DC_END_FN();
    return(rc);

} /* CDWndProc */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\clx.h ===
/**INC+**********************************************************************/
/*                                                                          */
/* ClxApi.h                                                                 */
/*                                                                          */
/* Client extension header file                                             */
/*                                                                          */
/* Copyright(c) Microsoft 1997-1999                                         */
/*                                                                          */
/* Notes:                                                                   */
/*                                                                          */
/*  CLINFO_VERSION                                                          */
/*      1               Initial version                                     */
/*      2               hwndMain added to CLINFO struct                     */
/*                                                                          */
/****************************************************************************/

#ifndef _H_CLX_
#define _H_CLX_

extern "C" {
    #include <extypes.h>
}

#include "objs.h"


#define CLINFO_VERSION              2

#define CLX_DISCONNECT_LOCAL        1
#define CLX_DISCONNECT_BY_USER      2
#define CLX_DISCONNECT_BY_SERVER    3
#define CLX_DISCONNECT_NL_ERROR     4
#define CLX_DISCONNECT_SL_ERROR     5
#define CLX_DISCONNECT_UNKNOWN      6



typedef struct _tag_CLINFO
{
    DWORD   cbSize;                 // Size of CLINFO structure (bytes)
    DWORD   dwVersion;              // CLINFO_VERSION

    //CLX expects ANSI strings here
    LPSTR  pszServer;              // Test server name / address
    LPSTR  pszCmdLine;             // /clxcmdline= switch data

    HWND    hwndMain;               // Main window handle

} CLINFO, *PCLINFO;

#define VLADIMIS_NEW_CHANGE
typedef enum
{
    CLX_EVENT_CONNECT,              // Connect event
    CLX_EVENT_DISCONNECT,           // Disconnect event
    CLX_EVENT_LOGON,                // Logon event
    CLX_EVENT_SHADOWBITMAP,         // Shadow bitmap created
    CLX_EVENT_SHADOWBITMAPDC,       // -- " --
    CLX_EVENT_PALETTE,              // new color palette

} CLXEVENT;

#ifndef PVOID
typedef void * PVOID;
typedef unsigned long ULONG;
typedef char *PCHAR, *PCH, *LPSTR;
#endif

#ifndef DWORD
typedef unsigned long DWORD;
typedef char *LPSTR;
#endif

#ifndef IN
#define IN
#endif


#define CLX_INITIALIZE      CE_WIDETEXT("ClxInitialize")
#define CLX_CONNECT         CE_WIDETEXT("ClxConnect")
#define CLX_EVENT           CE_WIDETEXT("ClxEvent")
#define CLX_DISCONNECT      CE_WIDETEXT("ClxDisconnect")
#define CLX_TERMINATE       CE_WIDETEXT("ClxTerminate")

#define CLX_TEXTOUT         CE_WIDETEXT("ClxTextOut")
#define CLX_TEXTPOSOUT      CE_WIDETEXT("ClxTextAndPosOut")
#define CLX_OFFSCROUT       CE_WIDETEXT("ClxOffscrOut")
#define CLX_GLYPHOUT        CE_WIDETEXT("ClxGlyphOut")
#define CLX_BITMAP          CE_WIDETEXT("ClxBitmap")
#define CLX_DIALOG          CE_WIDETEXT("ClxDialog")
#define CLX_PKTDRAWN        CE_WIDETEXT("ClxPktDrawn")
#define CLX_REDIRECTNOTIFY  CE_WIDETEXT("ClxRedirectNotify")
#define CLX_CONNECT_EX      CE_WIDETEXT("ClxConnectEx")


#define CLXSERVER       _T("CLXSERVER")
#define CLXDLL          _T("CLXDLL")
#define CLXCMDLINE      _T("CLXCMDLINE")


#ifdef ASSERT
#undef ASSERT
#endif // ASSERT
#ifdef ASSERTMSG
#undef ASSERTMSG
#endif // ASSERTMSG

#if DBG && WIN32

/////////////////////////////////////////////////////////////
extern "C" {

NTSYSAPI
VOID
NTAPI
RtlAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

ULONG
_cdecl
DbgPrint(
    PCH Format,
    ...
    );
} //extern c

#ifdef OS_WINCE
#define KdPrint(_x_) \
    NKDbgPrintfW _x_
#else // !OS_WINCE
#define KdPrint(_x_) \
    DbgPrint _x_
#endif // OS_WINCE

#define ASSERT(exp) \
    if (!(exp)) \
        RtlAssert(#exp, __FILE__, __LINE__, NULL)

#define ASSERTMSG(msg, exp) \
    if (!(exp)) \
        RtlAssert(#exp, __FILE__, __LINE__, msg)

#else

#define KdPrint(_x_)
#define ASSERT(exp)
#define ASSERTMSG(msg, exp)




#endif // DBG


typedef BOOL (WINAPI * PCLX_INITIALIZE)(PCLINFO, PVOID);
typedef BOOL (WINAPI * PCLX_CONNECT)(PVOID, LPTSTR);
typedef VOID (WINAPI * PCLX_EVENT)(PVOID, CLXEVENT, LPARAM); 
typedef VOID (WINAPI * PCLX_DISCONNECT)(PVOID);
typedef VOID (WINAPI * PCLX_TERMINATE)(PVOID); 
typedef VOID (WINAPI * PCLX_TEXTOUT)(PVOID, PVOID, int);
typedef VOID (WINAPI * PCLX_TEXTPOSOUT)(PVOID, PVOID, int, PRECT, HANDLE);
typedef VOID (WINAPI * PCLX_OFFSCROUT)(PVOID, HANDLE, int, int);
typedef VOID (WINAPI * PCLX_GLYPHOUT)(PVOID, UINT, UINT, PVOID);
typedef VOID (WINAPI * PCLX_BITMAP)(PVOID, UINT, UINT, PVOID, UINT, PVOID);
typedef VOID (WINAPI * PCLX_DIALOG)(PVOID, HWND);
typedef VOID (WINAPI * PCLX_PKTDRAWN)(PVOID);
typedef VOID (WINAPI * PCLX_REDIRECTNOTIFY)(
                    RDP_SERVER_REDIRECTION_PACKET UNALIGNED *pRedirPacket,
                    UINT dataLen
                    );
typedef BOOL (WINAPI * PCLX_CONNECT_EX)(
                    LPTSTR szConnectAddress,
                    BOOL   fAutoReconnecting,
                    BOOL   fIsConnectedToCluster,
                    BSTR   RedirectedLBInfo
                    );


typedef struct _tag_CLEXTENSION
{
    LPTSTR          pszClxServer;
    LPTSTR          pszClxDll;
    LPTSTR          pszClxCmdLine;
    
    HINSTANCE       hInstance;
    
    PCLX_INITIALIZE pClxInitialize;
    PCLX_CONNECT    pClxConnect;
    PCLX_EVENT      pClxEvent;
    PCLX_DISCONNECT pClxDisconnect;
    PCLX_TERMINATE  pClxTerminate;

    PCLX_TEXTOUT    pClxTextOut;
    PCLX_TEXTPOSOUT pClxTextPosOut;
    PCLX_OFFSCROUT  pClxOffscrOut;
    PCLX_GLYPHOUT   pClxGlyphOut;
    PCLX_BITMAP     pClxBitmap;
    PCLX_DIALOG     pClxDialog;
    PCLX_PKTDRAWN   pClxPktDrawn;

    PCLX_REDIRECTNOTIFY pClxRedirectNotify;
    PCLX_CONNECT_EX     pClxConnectEx;
    
    PVOID           pvClxContext;
    
} CLEXTENSION, *PCLEXTENSION;

class CCLX
{
public:
    CCLX(CObjs* objs);
    ~CCLX();


public:
    //
    // API
    //

    PVOID CLX_Alloc(IN DWORD dwSize);
    VOID CLX_Free(IN PVOID lpMemory);
    VOID            CLX_OnConnected(VOID);
    VOID            CLX_OnDisconnected(UINT  uResult);
    
    

    //
    // Internal functions
    //

    LPTSTR          CLX_SkipWhite(LPTSTR lpszCmdParam);
    LPTSTR          CLX_SkipNonWhite(LPTSTR lpszCmdParam);
    PCLEXTENSION    CLX_GetClx(VOID);
    BOOL            CLX_LoadProcs(VOID);
    
    UINT            CLX_GetSwitch_CLXSERVER(LPTSTR lpszCmdParam);
    UINT            CLX_GetSwitch_CLXCMDLINE(LPTSTR lpszCmdParam);
    
    BOOL            CLX_Init(HWND hwndMain, LPTSTR szCmdLine);
    VOID            CLX_Term(VOID);
    
 
    BOOL            CLX_ClxConnect(VOID);
    VOID            CLX_ClxEvent(CLXEVENT ClxEvent, LPARAM lParam);
    VOID            CLX_ClxDisconnect(VOID);
    VOID            CLX_ClxTerminate(VOID);
    
    VOID            CLX_ClxDialog(HWND hwnd);
    
    BOOL            CLX_Loaded(void);
    
    
    PCLEXTENSION    _pClx;
    
    //*************************************************************
    //
    //  CLX_ClxOffscrOut()
    //
    //  Purpose:    Notifies clx dll that an offscreen bitmap 
    //              was drawn and specifies the position
    //
    //  Parameters: IN [hBitmap]   - handle of the bitmap that was drawn
    //              IN [left]      - left drawing position
    //              IN [top]       - top drawing position
    //
    //  Return:     void
    //
    //  History:    04-15-01    CostinH     Created
    //
    //*************************************************************

    __inline VOID
    CLX_ClxOffscrOut(HANDLE hBitmap,
                     int  left, 
                     int  top)
    {
        if (_pClx && _pClx->pClxOffscrOut) {

            _pClx->pClxOffscrOut(_pClx->pvClxContext, hBitmap, left, top);
        }
    }
    
    //*************************************************************
    //
    //  CLX_ClxTextOut()
    //
    //  Purpose:    Let the clx dll have a look-see at all
    //              test out orders
    //
    //  Parameters: IN [pText]      - ptr to text
    //              IN [textLength] - text length
    //              IN [hBitmap]    - handle of the offscreen bitmap 
    //              IN [left]       - text position 
    //              IN [right]      -   on the client screen
    //              IN [top]        - 
    //              IN [bottom]     -
    //            
    //
    //  Return:     void
    //
    //  History:    09-30-97    BrianTa     Created
    //
    //*************************************************************
    
    __inline VOID
    CLX_ClxTextOut(PVOID pText,
                   int   textLength,
                   HANDLE hBitmap,
                   LONG  left,
                   LONG  right,
                   LONG  top,
                   LONG  bottom)
    {
        if (_pClx) {
            if (_pClx->pClxTextPosOut) {

                RECT r;

                r.left   = left;
                r.right  = right;
                r.top    = top;
                r.bottom = bottom;

                _pClx->pClxTextPosOut(_pClx->pvClxContext, pText, textLength, &r, hBitmap);
            }
            else if (_pClx->pClxTextOut) {
                _pClx->pClxTextOut(_pClx->pvClxContext, pText, textLength);
            }
        }
    }
    
    //*************************************************************
    //
    //  CLX_ClxGlyphOut()
    //
    //  Purpose:    Let the clx dll have a look-see at all
    //              glyph out orders
    //
    //  Parameters: IN [cxBits, cyBits]     - Size of mono bitmap
    //              IN [pBitmap]            - ptr to the bitmap data
    //
    //  Return:     void
    //
    //  History:    5-01-98    VLADIMIS         Created
    //
    //*************************************************************
    __inline VOID
    CLX_ClxGlyphOut(UINT cxBits, UINT cyBits, PVOID pBitmap)
    {
        if (_pClx && _pClx->pClxGlyphOut)
            _pClx->pClxGlyphOut(_pClx->pvClxContext, cxBits, cyBits, pBitmap);
    }
    
    //*************************************************************
    //
    //  CLX_ClxBitmap()
    //
    //  Purpose:    Let the clx dll have a look-see at all
    //              MemBlt orders
    //
    //  Parameters: IN [cxSize, cySize]     - Size of the bitmap
    //              IN [pBitmap]            - ptr to the bitmap data
    //              IN [bmiSize]            - size of pBmi
    //              IN [pBmi]               - ptr to the bitmap info
    //
    //  Return:     void
    //
    //  History:    5-01-98    VLADIMIS         Created
    //
    //*************************************************************
    
    __inline VOID
    CLX_ClxBitmap(UINT cxSize, UINT cySize, PVOID pBitmap, UINT bmiSize, PVOID pBmi)
    {
        if (_pClx && _pClx->pClxBitmap)
            _pClx->pClxBitmap(_pClx->pvClxContext,
                             cxSize, cySize,
                             pBitmap,
                             bmiSize,
                             pBmi);
    }
    
    //*************************************************************
    //
    //  CLX_ClxPktDrawn()
    //
    //  Purpose:    Notifies the clx dll that a new received packet
    //               was drawn
    //
    //  Return:     void
    //
    //  History:    5-14-01    COSTINH         Created
    //
    //*************************************************************
    
    __inline VOID
    CLX_ClxPktDrawn()
    {
        if (_pClx && _pClx->pClxPktDrawn)
            _pClx->pClxPktDrawn(_pClx->pvClxContext);
    }

    //
    // Redirect notify - notify the CLX of the receipt of an SD
    // redirection packet
    //
    __inline VOID
    CLX_RedirectNotify(
        RDP_SERVER_REDIRECTION_PACKET UNALIGNED *pRedirPacket,
        UINT dataLen
        )
    {
        if (_pClx && _pClx->pClxRedirectNotify) {
            _pClx->pClxRedirectNotify(pRedirPacket, dataLen);
        }
    }

    //
    // ConnectEx - notify clx at connection time
    //
    //  szConnectAddress  - exact address we're connecting to,
    //                      in redirect case this is redirection IP
    //  fAutoReconnecting - TRUE if this is an AutoReconnection
    //  fIsConnectedToCluster - TRUE if the connection is in response
    //                      to a redirection request
    //  RedirectedLBInfo  - Redirected LB info (cookie)
    //
    __inline VOID
    CLX_ConnectEx(
        LPTSTR szConnectAddress,
        BOOL   fAutoReconnecting,
        BOOL   fIsConnectedToCluster,
        BSTR   RedirectedLBInfo
        )
    {
        if (_pClx && _pClx->pClxConnectEx) {
            _pClx->pClxConnectEx(
                szConnectAddress,
                fAutoReconnecting,
                fIsConnectedToCluster,
                RedirectedLBInfo
                );
        }
    }


private:
    #ifdef UNICODE
    CHAR _szAnsiClxServer[100];
    CHAR _szAnsiClxCmdLine[MAX_PATH];
    #endif
    CObjs* _pClientObjects;
};


#endif // _H_CLX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\eosint.h ===
/****************************************************************************/
/* Copyright(C) Microsoft Corporation 1998                                  */
/****************************************************************************/
#ifndef _H_EOSINT
#define _H_EOSINT

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

WINGDIAPI HBRUSH  WINAPI CreateHatchBrush(int, COLORREF);

/* Hatch Styles */
#define HS_HORIZONTAL       0       /* ----- */
#define HS_VERTICAL         1       /* ||||| */
#define HS_FDIAGONAL        2       /* \\\\\ */
#define HS_BDIAGONAL        3       /* ///// */
#define HS_CROSS            4       /* +++++ */
#define HS_DIAGCROSS        5       /* xxxxx */

#define HS_LAST             HS_DIAGCROSS

#define BS_HATCHED          2

//const BYTE kbmHorizontal[]  = {0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00};
//const BYTE kbmVertical[]    = {0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88};
//const BYTE kbmFDiagonal[]   = {0x11, 0x22, 0x44, 0x88, 0x11, 0x22, 0x44, 0x88};
//const BYTE kbmBDiagonal[]   = {0x88, 0x44, 0x22, 0x11, 0x88, 0x44, 0x22, 0x11};
//const BYTE kbmCross[]       = {0x11, 0x11, 0x11, 0xFF, 0x11, 0x11, 0x11, 0xFF};
//const BYTE kbmDiagCross[]   = {0x11, 0xAA, 0x8A, 0x44, 0x11, 0xAA, 0x8A, 0x44};

const BYTE kbmBrushBits[6][8] = {{0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00},
                                 {0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88},
                                 {0x11, 0x22, 0x44, 0x88, 0x11, 0x22, 0x44, 0x88},
                                 {0x88, 0x44, 0x22, 0x11, 0x88, 0x44, 0x22, 0x11},
                                 {0x11, 0x11, 0x11, 0xFF, 0x11, 0x11, 0x11, 0xFF},
                                 {0x11, 0xAA, 0x8A, 0x44, 0x11, 0xAA, 0x8A, 0x44}};

#ifdef __cplusplus
}
#endif /* __cplusplus */

#ifdef __cplusplus

class CHatchBrush // chb
{
public:
    CHatchBrush();
    ~CHatchBrush();

    // Inline this since it's only ever called from the 'C' CreateHatchBrush
    inline HBRUSH CreateHatchBrush(int fnStyle, COLORREF clrref)
    {
        // BUGBUG: Not using clrref! Need support from WinCE team
        DC_IGNORE_PARAMETER(clrref);

        HBITMAP hbm;

        DC_BEGIN_FN("CreateHatchBrush");

        switch (fnStyle)
        {
        case HS_BDIAGONAL:      // 45-degree downward left-to-right hatch
        case HS_CROSS:          // Horizontal and vertical crosshatch
        case HS_DIAGCROSS:      // 45-degree crosshatch
        case HS_FDIAGONAL:      // 45-degree upward left-to-right hatch
        case HS_HORIZONTAL:     // Horizontal hatch
        case HS_VERTICAL:       // Vertical hatch
            TRC_DBG((TB, _T("Faking hatched brush creation: %d"), fnStyle));
            if (NULL != (hbm = GetBrushBitmap(fnStyle))) {
                return ::CreatePatternBrush(hbm);
            }
            break;
        default:
            TRC_ERR((TB, _T("Illegal hatched brush style")));
            return NULL;
        }
        return NULL;
    };

private:
    HBITMAP m_hbmBrush[HS_LAST];
    inline HBITMAP GetBrushBitmap(int fnStyle)
    {
        if (NULL == m_hbmBrush[fnStyle]) {
            return (m_hbmBrush[fnStyle] = CreateBitmap(8, 8, 1, 1, (const void *)kbmBrushBits[fnStyle]));
        } else {
            return m_hbmBrush[fnStyle];
        }
    };
};
#endif /* __cplusplus */

#endif // _H_EOSINT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\clxapi.cpp ===
/**MOD+**********************************************************************/
/* Module:    Clxapi.cpp                                                    */
/*                                                                          */
/* Purpose:   Clx API functions                                             */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1999                             */
/*                                                                          */
/****************************************************************************/

#include <adcg.h>

extern "C" {
#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "clxapi"
#include <atrcapi.h>

#include <tchar.h>
#include <windowsx.h>
}

#include "autil.h"
#include "clx.h"
#include "nl.h"
#include "sl.h"

CCLX::CCLX(CObjs* objs)
{
    _pClientObjects = objs;
    _pClx = NULL;
}

CCLX::~CCLX()
{
}

//*************************************************************
//
//  CLX_Alloc()
//
//  Purpose:    Allocates memory
//
//  Parameters: IN [dwSize]     - Size to allocate
//
//  Return:     Ptr to memory block     - if successful
//              NULL                    - if unsuccessful
//
//  History:    09-30-97    BrianTa     Created
//
//*************************************************************

PVOID
CCLX::CLX_Alloc(IN DWORD dwSize)
{
#ifndef OS_WINCE
    return (GlobalAllocPtr(GMEM_MOVEABLE, dwSize));
#else // OS_WINCE
    return LocalAlloc(LMEM_FIXED, dwSize);
#endif
}


//*************************************************************
//
//  CLX_Free()
//
//  Purpose:    Frees previously alloc'ed memory
//
//  Parameters: IN [lpMemory]       - Ptr to memory to free
//
//  Return:     void
//
//  History:    09-30-97    BrianTa     Created
//
//*************************************************************

VOID
CCLX::CLX_Free(IN PVOID lpMemory)
{
#ifndef OS_WINCE
    GlobalFreePtr(lpMemory);
#else
    LocalFree(lpMemory);
#endif
}


//*************************************************************
//
//  CLX_SkipWhite()
//
//  Purpose:    Skips whitespace characters
//
//  Parameters: IN [lpszCmdParam]   - Ptr to string
//
//  Return:     Ptr string past whitespace
//
//  History:    09-30-97    BrianTa     Created
//
//*************************************************************

LPTSTR
CCLX::CLX_SkipWhite(IN LPTSTR lpszCmdParam)
{
    while (*lpszCmdParam)
    {
        if (*lpszCmdParam != ' ')
            break;

        lpszCmdParam++;
    }

    return (lpszCmdParam);
}


//*************************************************************
//
//  CLX_GetClx()
//
//  Purpose:    Returns PER INSTANCE pClx pointer
//
//  Parameters: void
//
//  Return:     Ptr to per instance pClx      - If successfull
//              NULL                    - if not
//
//  History:    09-30-97    BrianTa     Created
//
//*************************************************************

PCLEXTENSION
CCLX::CLX_GetClx(VOID)
{
    if (_pClx == NULL)
    {
        _pClx = (PCLEXTENSION) CLX_Alloc(sizeof(CLEXTENSION));

        if (_pClx)
            memset(_pClx, 0, sizeof(CLEXTENSION));
    }

    return (_pClx);
}

//*************************************************************
//
//  CLX_LoadProcs()
//
//  Purpose:    Loads proc addresses from clxdll
//
//  Parameters: void
//
//  Return:     TRUE            - if successfull
//              FALSE           - if not
//
//  History:    09-30-97    BrianTa     Created
//
//*************************************************************

BOOL
CCLX::CLX_LoadProcs(void)
{
    DC_BEGIN_FN("CLX_LoadProcs");
    _pClx->pClxInitialize = (PCLX_INITIALIZE)
            GetProcAddress(_pClx->hInstance, CLX_INITIALIZE);

    if (!_pClx->pClxInitialize)
    {
        TRC_ERR((TB,_T("CLX_Init() Could not find pClxInitialize entry point\n")));
	}

    _pClx->pClxConnect = (PCLX_CONNECT)
            GetProcAddress(_pClx->hInstance, CLX_CONNECT);

    if (!_pClx->pClxConnect)
    {
        TRC_ERR((TB,_T("CLX_Init() Could not find pClxConnect entry point\n")));
    }

    _pClx->pClxEvent = (PCLX_EVENT)
            GetProcAddress(_pClx->hInstance, CLX_EVENT);

    if (!_pClx->pClxEvent)
    {
        TRC_ERR((TB,_T("CLX_Init() Could not find pClxEvent entry point\n")));
    }

    _pClx->pClxDisconnect = (PCLX_DISCONNECT)
            GetProcAddress(_pClx->hInstance, CLX_DISCONNECT);

    if (!_pClx->pClxDisconnect)
    {
        TRC_ERR((TB,_T("CLX_Init() Could not find pClxDisconnect entry point\n")));
    }

    _pClx->pClxTerminate = (PCLX_TERMINATE)
            GetProcAddress(_pClx->hInstance, CLX_TERMINATE);

    if (!_pClx->pClxTerminate)
    {
        TRC_ERR((TB,_T("CLX_Init() Could not find pClxTerminate entry point\n")));
    }

    _pClx->pClxTextOut = (PCLX_TEXTOUT)
            GetProcAddress(_pClx->hInstance, CLX_TEXTOUT);

    if (!_pClx->pClxTextOut)
    {
        TRC_ERR((TB,_T("CLX_Init() Could not find pClxTextOut entry point\n")));
    }

    _pClx->pClxTextPosOut = (PCLX_TEXTPOSOUT)
            GetProcAddress(_pClx->hInstance, CLX_TEXTPOSOUT);

    if (!_pClx->pClxTextPosOut)
    {
        TRC_ERR((TB,_T("CLX_Init() Could not find pClxTextPosOut entry point\n")));
    }

    _pClx->pClxOffscrOut = (PCLX_OFFSCROUT)
            GetProcAddress(_pClx->hInstance, CLX_OFFSCROUT);

    if (!_pClx->pClxOffscrOut)
    {
        TRC_ERR((TB,_T("CLX_Init() Could not find pClxOffscrOut entry point\n")));
    }

    _pClx->pClxGlyphOut = (PCLX_GLYPHOUT)
            GetProcAddress(_pClx->hInstance, CLX_GLYPHOUT);

    if (!_pClx->pClxGlyphOut)
    {
        TRC_ERR((TB,_T("CLX_Init() Could not find pClxGlyphOut entry point\n")));
    }

    _pClx->pClxBitmap = (PCLX_BITMAP)
            GetProcAddress(_pClx->hInstance, CLX_BITMAP);

    if (!_pClx->pClxGlyphOut)
    {
        TRC_ERR((TB,_T("CLX_Init() Could not find pClxBitmap entry point\n")));
    }

    _pClx->pClxDialog = (PCLX_DIALOG)
            GetProcAddress(_pClx->hInstance, CLX_DIALOG);

    if (!_pClx->pClxDialog)
    {
        TRC_ERR((TB,_T("CLX_Init() Could not find pClxDialog entry point\n")));
    }

    _pClx->pClxPktDrawn = (PCLX_PKTDRAWN)
            GetProcAddress(_pClx->hInstance, CLX_PKTDRAWN);

    if (!_pClx->pClxPktDrawn)
    {
        TRC_ERR((TB,_T("CLX_Init() Could not find pClxPktDrawn entry point\n")));
    }

    _pClx->pClxRedirectNotify = (PCLX_REDIRECTNOTIFY)
            GetProcAddress(_pClx->hInstance, CLX_REDIRECTNOTIFY);

    if (!_pClx->pClxRedirectNotify)
    {
        TRC_ERR((TB,_T("CLX_Init() Could not find pClxRedirectNotify entry point\n")));
    }

    _pClx->pClxConnectEx = (PCLX_CONNECT_EX)
            GetProcAddress(_pClx->hInstance, CLX_CONNECT_EX);

    if (!_pClx->pClxConnectEx)
    {
        TRC_ERR((TB,_T("CLX_Init() Could not find pClxConnectEx entry point\n")));
    }


    DC_END_FN();
    return (_pClx->pClxInitialize && _pClx->pClxTerminate);
}


//*************************************************************
//
//  CLX_ClxLoaded()
//
//  Purpose:    Returns clx load status
//
//  Parameters: void
//
//  Return:     TRUE            - if loaded
//              FALSE           - if not
//
//  History:    09-30-97    BrianTa     Created
//
//*************************************************************

BOOL
CCLX::CLX_Loaded(void)
{
    return (_pClx ? TRUE : FALSE);
}

//*************************************************************
//
//  CLX_Init()
//
//  Purpose:    Loads / initializes the clx dll
//
//  Parameters: IN [hwndMain]   - Main client window handle
//
//  Return:     TRUE            - if successfull
//              FALSE           - if not
//
//  History:    09-30-97    BrianTa     Created
//
//*************************************************************

#define CLX_DLL_NAME _T("clxtshar.dll")
BOOL
CCLX::CLX_Init(HWND hwndMain, LPTSTR szCmdLine)
{
    DC_BEGIN_FN("CLX_Init");
    BOOL        fLoaded;
    CLINFO      clinfo;
    HINSTANCE   hInstance;
    LPTSTR      pszClxDll;

    fLoaded = FALSE;
    hInstance = NULL;

    _pClientObjects->AddObjReference(CLX_OBJECT_FLAG);

    if(!szCmdLine || _T('\0') == szCmdLine[0])
    {
        TRC_ALT((TB,_T("CLX_Init() NO CLX CMD Line Specified. Not loading CLX - %s\n"),
                 CLX_DLL_NAME));
        return FALSE;
    }

    _pClx = CLX_GetClx();

    if (_pClx)
    {
        TRC_NRM((TB,_T("CLX_Init() attempting to load (%s)\n"), CLX_DLL_NAME));

        hInstance = LoadLibrary(CLX_DLL_NAME);

        if (hInstance)
        {
            _pClx->hInstance = hInstance;

            if (CLX_LoadProcs())
            {
                clinfo.cbSize = sizeof(clinfo);
                clinfo.dwVersion = CLINFO_VERSION;

                #ifdef UNICODE
                if(_pClx->pszClxServer)
                {
                    if (!WideCharToMultiByte(CP_ACP,
                                             0,
                                             _pClx->pszClxServer,
                                             -1,
                                             _szAnsiClxServer,
                                             sizeof(_szAnsiClxServer),
                                             NULL,
                                             NULL))
                    {
                        //Conv failed
                        TRC_ERR((TB, _T("Failed to convert pszClxServer to ANSI: 0x%x"),
                            GetLastError()));
                        return FALSE;
                    }
                    clinfo.pszServer  = _szAnsiClxServer;
                }
                else
                {
                    clinfo.pszServer = NULL;
                }

                if(szCmdLine)
                {
                    if (!WideCharToMultiByte(CP_ACP,
                                             0,
                                             szCmdLine,
                                             -1,
                                             _szAnsiClxCmdLine,
                                             sizeof(_szAnsiClxCmdLine),
                                             NULL,
                                             NULL))
                    {
                        //Conv failed
                        TRC_ERR((TB, _T("Failed to convert CLX szCmdLine to ANSI: 0x%x"),
                            GetLastError()));
                        return FALSE;
                    }
                    clinfo.pszCmdLine = _szAnsiClxCmdLine;
                }
                else
                {
                    clinfo.pszCmdLine = NULL;
                }
                
                #else
                //Data is already ANSI
                clinfo.pszServer = _pClx->pszClxServer;
                clinfo.pszCmdLine = szCmdLine;
                #endif
                clinfo.hwndMain = hwndMain;
                fLoaded = _pClx->pClxInitialize(&clinfo, &_pClx->pvClxContext);

                TRC_NRM((TB,_T("CLX_Init() pClxInitialize() returned - %d\n"), fLoaded));
            }
        }
        else
        {
            TRC_NRM((TB,_T("CLX_Init() Error %d loading (%s)\n"),
                    GetLastError(), CLX_DLL_NAME));
        }

        // If we were able to load the ClxDll and successfull perform its
        // base initialization, then tell it to go ahead and connect to the
        // test server

        if (fLoaded)
            fLoaded = CLX_ClxConnect();

        if (!fLoaded)
        {
            if (hInstance)
                FreeLibrary(hInstance);

            if (_pClx->pszClxDll)
                CLX_Free(_pClx->pszClxDll);

            if (_pClx->pszClxServer)
                CLX_Free(_pClx->pszClxServer);

            CLX_Free(_pClx);

            _pClx = NULL;
        }
    }

    DC_END_FN();
    return (_pClx != NULL);
}


//*************************************************************
//
//  CLX_Term()
//
//  Purpose:    Sub-manager termination processing
//
//  Parameters: void
//
//  Return:     void
//
//  History:    09-30-97    BrianTa     Created
//
//*************************************************************

VOID
CCLX::CLX_Term(VOID)
{
    if (_pClx)
    {
        CLX_ClxDisconnect();
        CLX_ClxTerminate();

        if (_pClx->hInstance)
            FreeLibrary(_pClx->hInstance);

        if (_pClx->pszClxDll)
            CLX_Free(_pClx->pszClxDll);

        if (_pClx->pszClxServer)
            CLX_Free(_pClx->pszClxServer);

        CLX_Free(_pClx);

        _pClx = NULL;
    }
    _pClientObjects->ReleaseObjReference(CLX_OBJECT_FLAG);
}


//*************************************************************
//
//  CLX_OnConnected()
//
//  Purpose:    OnConnected processing for the clx dll
//
//  Parameters: void
//
//  Return:     void
//
//  History:    09-30-97    BrianTa     Created
//
//*************************************************************

VOID
CCLX::CLX_OnConnected(VOID)
{
    CLX_ClxEvent(CLX_EVENT_CONNECT, 0);
}


//*************************************************************
//
//  CLX_OnDisconnected()
//
//  Purpose:    OnDisconnected processing for the clx dll
//
//  Parameters: IN [uDisconnect] --     Disconnection code
//
//  Return:     void
//
//  History:    09-30-97    BrianTa     Created
//
//*************************************************************

VOID
CCLX::CLX_OnDisconnected(IN UINT uDisconnect)
{
    UINT    uResult;

    switch (NL_GET_MAIN_REASON_CODE(uDisconnect))
    {
        case NL_DISCONNECT_LOCAL:
            uResult = CLX_DISCONNECT_LOCAL;
            break;

        case NL_DISCONNECT_REMOTE_BY_USER:
            uResult = CLX_DISCONNECT_BY_USER;
            break;

        case NL_DISCONNECT_REMOTE_BY_SERVER:
            uResult = CLX_DISCONNECT_BY_SERVER;
            break;

        case NL_DISCONNECT_ERROR:
            uResult = CLX_DISCONNECT_NL_ERROR;
            break;

        case SL_DISCONNECT_ERROR:
            uResult = CLX_DISCONNECT_SL_ERROR;
            break;

        default:
            uResult = CLX_DISCONNECT_UNKNOWN;
            break;
    }

    CLX_ClxEvent(CLX_EVENT_DISCONNECT, uResult);
}


//*************************************************************
//
//  CLX_ClxConnect()
//
//  Purpose:    Connect processing for the clx dll
//
//  Parameters: void
//
//  Return:     void
//
//  History:    09-30-97    BrianTa     Created
//
//*************************************************************

BOOL
CCLX::CLX_ClxConnect(VOID)
{
    BOOL    fConnect;

    fConnect = TRUE;

    if (_pClx && _pClx->pClxConnect)
        fConnect = _pClx->pClxConnect(_pClx->pvClxContext, _pClx->pszClxServer);

    return (fConnect);
}


//*************************************************************
//
//  CLX_ClxEvent()
//
//  Purpose:    Event processing for the clx dll
//
//  Parameters: IN [ClxEvent]       - Event type
//              IN [ulParam]        - Event specific param
//
//  Return:     void
//
//  History:    09-30-97    BrianTa     Created
//
//*************************************************************

VOID
CCLX::CLX_ClxEvent(IN CLXEVENT ClxEvent,
             IN LPARAM    ulParam)
{
    if (_pClx && _pClx->pClxEvent)
        _pClx->pClxEvent(_pClx->pvClxContext, ClxEvent, ulParam);
}


//*************************************************************
//
//  CLX_Disconnect()
//
//  Purpose:    Disconnect processing for the clx dll
//
//  Parameters: void
//
//  Return:     void
//
//  History:    09-30-97    BrianTa     Created
//
//*************************************************************

VOID
CCLX::CLX_ClxDisconnect(VOID)
{
    if (_pClx && _pClx->pClxDisconnect)
        _pClx->pClxDisconnect(_pClx->pvClxContext);
}


//*************************************************************
//
//  CLX_ClxTerminate()
//
//  Purpose:    Termination processing for the clx dll
//
//  Parameters: void
//
//  Return:     void
//
//  History:    09-30-97    BrianTa     Created
//
//*************************************************************

VOID
CCLX::CLX_ClxTerminate(VOID)
{
    if (_pClx && _pClx->pClxTerminate)
        _pClx->pClxTerminate(_pClx->pvClxContext);
}


//*************************************************************
//
//  CLX_ClxDialog()
//
//  Purpose:    Let the clx dll know of the launched dialog
//
//  Parameters: IN [hwnd]       - Dialog hwnd
//
//  Return:     void
//
//  History:    09-30-97    BrianTa     Created
//
//*************************************************************

VOID
CCLX::CLX_ClxDialog(HWND hwnd)
{
    if (_pClx && _pClx->pClxDialog)
        _pClx->pClxDialog(_pClx->pvClxContext, hwnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\cm.h ===
/****************************************************************************/
// cm.h
//
// Cursor manager header.
//
// Copyright (C) 1997-2000 Microsoft Corp.
/****************************************************************************/

#ifndef _H_CM
#define _H_CM

extern "C" {
    #include <adcgdata.h>
}
#include "autil.h"
#include "wui.h"
#include "uh.h"

#include "objs.h"
#include "cd.h"

#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "cm"
#define TSC_HR_FILEID TSC_HR_CM_H


/****************************************************************************/
/* Cursor size constants. These are t.128 specifications.                   */
/****************************************************************************/
#define CM_CURSOR_WIDTH 32
#define CM_CURSOR_HEIGHT 32
#define CM_NUM_CURSOR_BITMAP_BYTES ((CM_CURSOR_WIDTH * CM_CURSOR_HEIGHT) / 8)


/****************************************************************************/
/* Pointer cache sizes.                                                     */
/*                                                                          */
/* Note: For 'old' style support, the cache includes one entry (never       */
/* used!) for the last mono cursor                                          */
/****************************************************************************/
#define CM_COLOR_CACHE_SIZE    20
#define CM_MONO_CACHE_SIZE     1

#define CM_MONO_CACHE_INDEX    CM_COLOR_CACHE_SIZE

#define CM_CURSOR_CACHE_SIZE   (CM_COLOR_CACHE_SIZE + CM_MONO_CACHE_SIZE)


/**STRUCT+*******************************************************************/
/* Structure: CM_GLOBAL_DATA                                                */
/*                                                                          */
/* Description:                                                             */
/****************************************************************************/
typedef struct tagCM_GLOBAL_DATA
{
    HCURSOR  cursorCache[CM_CURSOR_CACHE_SIZE];
} CM_GLOBAL_DATA, DCPTR PCM_GLOBAL_DATA;
/**STRUCT-*******************************************************************/


#define CM_DEFAULT_ARROW_CURSOR_HANDLE LoadCursor(NULL, IDC_ARROW)


class CCM
{
public:

    CCM(CObjs* objs);
    ~CCM();

    //
    // API
    // 

    /****************************************************************************/
    // Functions
    /****************************************************************************/
    DCVOID DCAPI CM_Init(DCVOID);
    DCVOID DCAPI CM_Enable(ULONG_PTR unused);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CCM, CM_Enable);
    DCVOID DCAPI CM_Disable(ULONG_PTR unused);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CCM, CM_Disable);
    void   DCAPI CM_NullSystemPointerPDU(void);
    void   DCAPI CM_DefaultSystemPointerPDU(void);
    HRESULT   DCAPI CM_MonoPointerPDU(TS_MONOPOINTERATTRIBUTE UNALIGNED FAR *, DCUINT);
    void   DCAPI CM_PositionPDU(TS_POINT16 UNALIGNED FAR *);
    HRESULT   DCAPI CM_ColorPointerPDU(TS_COLORPOINTERATTRIBUTE UNALIGNED FAR *, DCUINT);
    void   DCAPI CM_CachedPointerPDU(unsigned);
    HRESULT   DCAPI CM_PointerPDU(TS_POINTERATTRIBUTE UNALIGNED FAR *, DCUINT);

    /****************************************************************************/
    /* Name:      CM_Term                                                       */
    /*                                                                          */
    /* Purpose:   Cursor Manager termination                                    */
    /****************************************************************************/
    inline void DCAPI CM_Term(void)
    {
    } /* CM_Term */
    
    
    /****************************************************************************/
    // CM_SlowPathPDU
    //
    // Handles non-fast-path translation to handler function calls.
    /****************************************************************************/
    // SECURITY - the size of the packet has been checked only to be sure there is
    //  enough data to read the TS_POINTER_PDU_DATA.messageType field
    inline HRESULT DCAPI CM_SlowPathPDU(
            TS_POINTER_PDU_DATA UNALIGNED FAR *pPointerPDU,
            DCUINT dataLen )
    {
        DC_BEGIN_FN("CM_SlowPathPDU");

        HRESULT hr = S_OK;
   
        switch (pPointerPDU->messageType) {
            case TS_PTRMSGTYPE_POSITION:
                CHECK_READ_N_BYTES(pPointerPDU, (PBYTE)pPointerPDU + dataLen,
                    FIELDOFFSET(TS_POINTER_PDU_DATA,pointerData) + 
                    sizeof(TS_POINT16), hr, (TB, _T("Bad TS_PTRMSGTYPE_POSITION")));
                CM_PositionPDU(&pPointerPDU->pointerData.pointerPosition);
                break;
    
            case TS_PTRMSGTYPE_SYSTEM:
                CHECK_READ_N_BYTES(pPointerPDU, (PBYTE)pPointerPDU + dataLen,
                    FIELDOFFSET(TS_POINTER_PDU_DATA,pointerData) + 
                    sizeof(TSUINT32), hr, (TB, _T("Bad TS_PTRMSGTYPE_SYSTEM")));
                
                switch (pPointerPDU->pointerData.systemPointerType) {
                    case TS_SYSPTR_NULL:
                        CM_NullSystemPointerPDU();
                        break;
    
                    case TS_SYSPTR_DEFAULT:
                        CM_DefaultSystemPointerPDU();
                        break;
    
                    default:
                        TRC_ERR((TB, _T("Invalid system pointer type")));
                        break;
                }
                break;
    
            case TS_PTRMSGTYPE_MONO:
                CHECK_READ_N_BYTES(pPointerPDU, (PBYTE)pPointerPDU + dataLen,
                    FIELDOFFSET(TS_POINTER_PDU_DATA,pointerData) + 
                    sizeof(TS_MONOPOINTERATTRIBUTE), hr, (TB, _T("Bad TS_PTRMSGTYPE_MONO")));
                
                hr = CM_MonoPointerPDU(&pPointerPDU->pointerData.
                    monoPointerAttribute, dataLen - FIELDOFFSET(TS_POINTER_PDU_DATA,pointerData));
                break;
    
            case TS_PTRMSGTYPE_COLOR:
                CHECK_READ_N_BYTES(pPointerPDU, (PBYTE)pPointerPDU + dataLen,
                    FIELDOFFSET(TS_POINTER_PDU_DATA,pointerData) + 
                    sizeof(TS_COLORPOINTERATTRIBUTE), hr, (TB, _T("Bad TS_PTRMSGTYPE_COLOR")));
                
                hr = CM_ColorPointerPDU(&pPointerPDU->pointerData.
                    colorPointerAttribute, dataLen - FIELDOFFSET(TS_POINTER_PDU_DATA,pointerData));
                break;
    
            case TS_PTRMSGTYPE_POINTER:
                CHECK_READ_N_BYTES(pPointerPDU, (PBYTE)pPointerPDU + dataLen,
                    FIELDOFFSET(TS_POINTER_PDU_DATA,pointerData) + 
                    sizeof(TS_POINTERATTRIBUTE), hr, (TB, _T("Bad TS_PTRMSGTYPE_POINTER")));
                
                hr = CM_PointerPDU(&pPointerPDU->pointerData.pointerAttribute,
                    dataLen - FIELDOFFSET(TS_POINTER_PDU_DATA,pointerData));
                break;
    
            case TS_PTRMSGTYPE_CACHED:
                CHECK_READ_N_BYTES(pPointerPDU, (PBYTE)pPointerPDU + dataLen,
                    FIELDOFFSET(TS_POINTER_PDU_DATA,pointerData) + 
                    sizeof(TSUINT16), hr, (TB, _T("Bad TS_PTRMSGTYPE_CACHED")));
                
                CM_CachedPointerPDU(pPointerPDU->pointerData.cachedPointerIndex);
                break;
    
            default:
                TRC_ERR((TB, _T("Unknown PointerPDU type %#x"),
                    pPointerPDU->messageType));
                hr = E_UNEXPECTED;
                break;
        }

    DC_EXIT_POINT:
        DC_END_FN();
        return hr;
    }

public:
    //
    // Public data members
    //
    CM_GLOBAL_DATA _CM;

private:
    //
    // Internal functions
    //

    /****************************************************************************/
    /* Functions                                                                */
    /****************************************************************************/
    HRESULT DCINTERNAL CMCreateColorCursor(unsigned,
            TS_COLORPOINTERATTRIBUTE UNALIGNED FAR *, DCUINT, HCURSOR *);

    HRESULT DCINTERNAL CMCreateMonoCursor(
            TS_MONOPOINTERATTRIBUTE UNALIGNED FAR *, DCUINT, HCURSOR *);

    inline HRESULT DCINTERNAL CMCreateNewCursor(
            TS_POINTERATTRIBUTE UNALIGNED FAR *pAttr,
            DCUINT dataLen,
            HCURSOR FAR *pNewHandle,
            HCURSOR * pOldHandle)
    {
        HRESULT hr = S_OK;
        HCURSOR oldHandle = NULL;
        HCURSOR newHandle;
        unsigned cacheIndex;
        unsigned xorLen;
    
        DC_BEGIN_FN("CMCreateNewCursor");
    
        TRC_DATA_DBG("Rx cursor data", pAttr, sizeof(TS_POINTERATTRIBUTE) );
    
        cacheIndex = pAttr->colorPtrAttr.cacheIndex;

        // SECURITY: 555587 cursor values must be validated
        if (cacheIndex >= CM_CURSOR_CACHE_SIZE) {
            TRC_ERR(( TB, _T("Invalid cache index %d"), cacheIndex));
            hr = E_TSC_CORE_CACHEVALUE;
            DC_QUIT;
        }       
        TRC_DBG((TB, _T("Cached index %d"), cacheIndex));
    
        oldHandle = _CM.cursorCache[cacheIndex];

        // SECURITY 555587: CMCreate<XXX>Cursor must validate input
        if (FIELDOFFSET(TS_COLORPOINTERATTRIBUTE, colorPointerData) + 
            pAttr->colorPtrAttr.lengthXORMask + pAttr->colorPtrAttr.lengthANDMask > dataLen) {
            TRC_ERR(( TB, _T("Bad CreateNewCursor; dataLen %u"), dataLen));
            hr = E_TSC_CORE_LENGTH;
            DC_QUIT;
        }
    
        // Create the new cursor according to the color depth
        if (pAttr->XORBpp == 1) {
            TRC_NRM((TB, _T("Create mono cursor")));
    
            // Data contains XOR followed by AND mask.
            xorLen = pAttr->colorPtrAttr.lengthXORMask;
            TRC_DATA_DBG("AND mask",
                         pAttr->colorPtrAttr.colorPointerData + xorLen,
                         xorLen);
            TRC_DATA_DBG("XOR bitmap",
                         pAttr->colorPtrAttr.colorPointerData,
                         xorLen);
#ifndef OS_WINCE
            newHandle = CreateCursor(_pUi->UI_GetInstanceHandle(),
                                   pAttr->colorPtrAttr.hotSpot.x,
                                   pAttr->colorPtrAttr.hotSpot.y,
                                   pAttr->colorPtrAttr.width,
                                   pAttr->colorPtrAttr.height,
                                   pAttr->colorPtrAttr.colorPointerData + xorLen,
                                   pAttr->colorPtrAttr.colorPointerData);
#else
        /******************************************************************/
        /*  In Windows CE environments, we're not guaranteed that         */
        /*  CreateCursor is part of the OS, so we do a GetProcAddress on  */
        /*  it so we can be sure.  If it's not there, this usually means  */
        /*  we're on a touch screen device where these cursor doesn't     */
        /*  matter anyway.                                                */
        /******************************************************************/
        if (g_pCreateCursor)
        {
            newHandle = g_pCreateCursor(_pUi->UI_GetInstanceHandle(),
                               pAttr->colorPtrAttr.hotSpot.x,
                               pAttr->colorPtrAttr.hotSpot.y,
                               pAttr->colorPtrAttr.width,
                               pAttr->colorPtrAttr.height,
                               pAttr->colorPtrAttr.colorPointerData + xorLen,
                               pAttr->colorPtrAttr.colorPointerData);

        }
        else
        {
            newHandle = NULL;
        }       
#endif // OS_WINCE        
        }
        else {
            TRC_NRM((TB, _T("Create %d bpp cursor"), pAttr->XORBpp));
            hr = CMCreateColorCursor(pAttr->XORBpp, &(pAttr->colorPtrAttr),
                dataLen - FIELDSIZE(TS_POINTERATTRIBUTE, XORBpp), &newHandle);
            DC_QUIT_ON_FAIL(hr);
        }
    
        _CM.cursorCache[cacheIndex] = newHandle;
        if (newHandle != NULL) {
            // New cursor created OK.
            *pNewHandle = newHandle;
        }
        else {
            // Failed to create the new color cursor - use default
            TRC_ALT((TB, _T("Failed to create cursor")));
            *pNewHandle = CM_DEFAULT_ARROW_CURSOR_HANDLE;
        }

        *pOldHandle = oldHandle;

    DC_EXIT_POINT:    
        DC_END_FN();
        return hr;
    }
    
    inline HRESULT DCINTERNAL CMCreateNewColorCursor(
            unsigned cacheIndex,
            TS_COLORPOINTERATTRIBUTE UNALIGNED FAR *pAttr,
            DCUINT dataLen,
            HCURSOR FAR *pNewHandle, 
            HCURSOR * pOldHandle)
    {
        HRESULT hr = S_OK;
        HCURSOR oldHandle = NULL;
        HCURSOR newHandle;
    
        DC_BEGIN_FN("CMCreateNewColorCursor");

        // SECURITY: 555587 cursor values must be validated
        if (cacheIndex >= CM_CURSOR_CACHE_SIZE) {
            TRC_ERR(( TB, _T("Invalid cache index %d"), cacheIndex));
            hr = E_TSC_CORE_CACHEVALUE;
            DC_QUIT;
        }  
    
        TRC_DBG((TB, _T("Cached index %d"), cacheIndex));
    
        oldHandle = _CM.cursorCache[cacheIndex];
    
        // Create the new color cursor. Save in the cache.
        // This is for the 'old' cursor protocol so we hard coded the color
        // depth as 24 bpp.
        
        // SECURITY 559307: CMCreate<XXX>Cursor need size of PDU passed in 
        hr = CMCreateColorCursor(24, pAttr, dataLen, &newHandle);
        DC_QUIT_ON_FAIL(hr);
    
        _CM.cursorCache[cacheIndex] = newHandle;
        if (newHandle != NULL) {
            // New cursor created OK.
            *pNewHandle = newHandle;
        }
        else {
            // Failed to create the new color cursor - use default
            TRC_ALT((TB, _T("Failed to create color cursor")));
            *pNewHandle = CM_DEFAULT_ARROW_CURSOR_HANDLE;
        }

        *pOldHandle = oldHandle;

    DC_EXIT_POINT:
        DC_END_FN();
        return hr;
    }
    
    inline HCURSOR DCINTERNAL CMGetCachedCursor(unsigned cacheIndex)
    {
        DC_BEGIN_FN("CMGetCachedCursor");
    
        TRC_NRM((TB, _T("Cached color pointer - index %d"), cacheIndex));
    
        TRC_ASSERT((cacheIndex < CM_CURSOR_CACHE_SIZE),
                                    (TB, _T("Invalid cache index %d"), cacheIndex));
    
        /************************************************************************/
        /* Assume NULL means we failed to create the cursor, so use the         */
        /* default. If the server has not sent this definition, that is not our */
        /* fault.                                                               */
        /************************************************************************/

        // SECURITY 550811: Cache index must be verified
        if (cacheIndex < CM_CURSOR_CACHE_SIZE && 
            _CM.cursorCache[cacheIndex] != NULL) {
            DC_END_FN();
            return _CM.cursorCache[cacheIndex];
        }
        else {
            TRC_ALT((TB, _T("No cached cursor - use default")));
            DC_END_FN();
            return CM_DEFAULT_ARROW_CURSOR_HANDLE;
        }
    }
    
    
    // Platform specific prototypes.
    HBITMAP CMCreateXORBitmap(LPBITMAPINFO,
            TS_COLORPOINTERATTRIBUTE UNALIGNED FAR *);
    HCURSOR CMCreatePlatformCursor(TS_COLORPOINTERATTRIBUTE UNALIGNED FAR *, 
            HBITMAP, HBITMAP);
#ifdef OS_WINCE
    DCVOID DCINTERNAL CMMakeMonoDIB(HDC, LPBITMAPINFO, PDCUINT8, PDCUINT8);
#endif // OS_WINCE
    

private:
    CUT* _pUt;
    CUH* _pUh;
    CCD* _pCd;
    CIH* _pIh;
    CUI* _pUi;

private:
    CObjs* _pClientObjects;

};

#undef TRC_FILE
#undef TRC_GROUP
#undef TSC_HR_FILEID

#endif // _H_CM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\cmapi.cpp ===
/****************************************************************************/
// acmapi.c
//
// Cursor manager
//
// Copyright (C) 1997-1999 Microsoft Corp.
/****************************************************************************/

#include <adcg.h>
extern "C" {
#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "cmapi"
#include <atrcapi.h>
}

#include "cm.h"
#include "autil.h"
#include "cd.h"
#include "ih.h"

CCM::CCM(CObjs* objs)
{
    _pClientObjects = objs;
}

CCM::~CCM()
{
}

/****************************************************************************/
/* Name:      CM_Init                                                       */
/*                                                                          */
/* Purpose:   Cursor Manager initialization                                 */
/****************************************************************************/
DCVOID DCAPI CCM::CM_Init(DCVOID)
{
    DC_BEGIN_FN("CM_Init");

    _pUt  = _pClientObjects->_pUtObject;
    _pUh  = _pClientObjects->_pUHObject;
    _pCd  = _pClientObjects->_pCdObject;
    _pIh  = _pClientObjects->_pIhObject;
    _pUi  = _pClientObjects->_pUiObject;

    DC_MEMSET(&_CM, 0, sizeof(_CM));


#if !defined(OS_WINCE) || defined(OS_WINCEATTACHTHREADINPUT)
#ifdef OS_WIN32
    /************************************************************************/
    /* Attach input                                                         */
    /************************************************************************/
    if (!AttachThreadInput(GetCurrentThreadId(),
                           GetWindowThreadProcessId(_pUi->UI_GetUIContainerWindow(),
                                                    NULL),
                           TRUE))
    {
        TRC_ALT((TB, _T("Failed AttachThreadInput")));
    }
#endif
#endif // !defined(OS_WINCE) || defined(OS_WINCEATTACHTHREADINPUT)

    DC_END_FN();
} /* CM_Init */


/****************************************************************************/
/* Name:      CM_Enable                                                     */
/*                                                                          */
/* Purpose:   Enables _CM.                                                   */
/****************************************************************************/
DCVOID DCAPI CCM::CM_Enable(ULONG_PTR unused)
{
#ifdef DC_DEBUG
    DCINT i;
#endif

    DC_BEGIN_FN("CM_Enable");

    DC_IGNORE_PARAMETER(unused);

#ifdef DC_DEBUG
    /************************************************************************/
    /* Check that cursor cache is empty                                     */
    /************************************************************************/
    for (i = 0; i < CM_CURSOR_CACHE_SIZE; i++)
    {
        if (_CM.cursorCache[i] != NULL) {
            TRC_ERR((TB, _T("Cursor cache not empty")));
        }
    }
#endif

    DC_END_FN();
} /* CM_Enable */


/****************************************************************************/
/* Name:      CM_Disable                                                    */
/*                                                                          */
/* Purpose:   Disables _CM.                                                  */
/****************************************************************************/
DCVOID DCAPI CCM::CM_Disable(ULONG_PTR unused)
{
    DCINT i;

    DC_BEGIN_FN("CM_Disable");

    DC_IGNORE_PARAMETER(unused);

    TRC_NRM((TB, _T("CM disabled so cleaning up cached cursors")));

    /************************************************************************/
    /* Destroy any cached cursors.                                          */
    /************************************************************************/
    for (i = 0; i < CM_CURSOR_CACHE_SIZE; i++)
    {
        if (_CM.cursorCache[i] != NULL)
        {
#ifndef OS_WINCE
            DestroyCursor(_CM.cursorCache[i]);
#else
            DestroyIcon(_CM.cursorCache[i]);
#endif
        }
        _CM.cursorCache[i] = NULL;
    }

    DC_END_FN();
} /* CM_Disable */


/****************************************************************************/
// CM_NullSystemPointerPDU
//
// Handles a null-pointer PDU from server.
/****************************************************************************/
void DCAPI CCM::CM_NullSystemPointerPDU(void)
{
    DC_BEGIN_FN("CM_NullSystemPointerPDU");

    // Call IH to enable it to set the cursor shape. Must do this
    // synchronously as we may receive a very large number of cursor
    // shape changes - for example when running MS Office 97 setup.

    TRC_NRM((TB, _T("Set cursor handle to NULL")));

    _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, _pIh,
                                         CD_NOTIFICATION_FUNC(CIH,IH_SetCursorShape),
                                        (ULONG_PTR)(LPVOID)NULL);

    DC_END_FN();
}


/****************************************************************************/
// CM_DefaultSystemPointerPDU
//
// Handles a default-pointer PDU from server.
/****************************************************************************/
void DCAPI CCM::CM_DefaultSystemPointerPDU(void)
{
    DC_BEGIN_FN("CM_DefaultSystemPointerPDU");

    // Call IH to enable it to set the cursor shape. Must do this
    // synchronously as we may receive a very large number of cursor
    // shape changes - for example when running MS Office 97 setup.

    TRC_NRM((TB, _T("Set cursor handle to default arrow")));
    _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, _pIh,
                                         CD_NOTIFICATION_FUNC(CIH, IH_SetCursorShape),
                                        (ULONG_PTR)(LPVOID)CM_DEFAULT_ARROW_CURSOR_HANDLE);

    DC_END_FN();
}


/****************************************************************************/
// CM_MonoPointerPDU
//
// Handles a default-pointer PDU from server.
/****************************************************************************/

HRESULT DCAPI CCM::CM_MonoPointerPDU(
    TS_MONOPOINTERATTRIBUTE UNALIGNED FAR *pAttr,
    DCUINT dataLen)
{
    HRESULT hr = S_OK;
    HCURSOR oldHandle, newHandle;

    DC_BEGIN_FN("CM_MonoPointerPDU");

    // Save old mono cursor handle.
    TRC_NRM((TB, _T("Mono Pointer")));
    oldHandle = _CM.cursorCache[CM_MONO_CACHE_INDEX];

    // Create the new cursor.
    // SECURITY: 555587 Must pass size of order on to create<XXX>cursor
    hr = CMCreateMonoCursor(pAttr, dataLen, &newHandle);
    DC_QUIT_ON_FAIL(hr);
    _CM.cursorCache[CM_MONO_CACHE_INDEX] = newHandle;
    if (newHandle == NULL) {
        // Failed to create cursor - use default.
        TRC_ALT((TB, _T("Failed to create mono cursor")));
        newHandle = CM_DEFAULT_ARROW_CURSOR_HANDLE;
    }

    // Call IH to enable it to set the cursor shape. Must do this
    // synchronously as we may receive a very large number of cursor
    // shape changes - for example when running MS Office 97 setup.

    TRC_NRM((TB, _T("Set cursor handle to %p"), newHandle));
    _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, _pIh,
                                  CD_NOTIFICATION_FUNC(CIH, IH_SetCursorShape),
                                  (ULONG_PTR)(LPVOID)newHandle);

    // Destroy any old handle if required, and remove from cache.
    if (oldHandle != NULL) {
#ifndef OS_WINCE
        DestroyCursor(oldHandle);
#else // OS_WINCE
        DestroyIcon(oldHandle);
#endif // OS_WINCE
    }

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}


/****************************************************************************/
// CM_PositionPDU
//
// Handles a position-pointer PDU from server.
/****************************************************************************/
void DCAPI CCM::CM_PositionPDU(TS_POINT16 UNALIGNED FAR *pPoint)
{
    POINT MousePos;

    DC_BEGIN_FN("CM_PositionPDU");

    // Adjust position to local screen coordinates.
    MousePos.x = pPoint->x;
    MousePos.y = pPoint->y;
    TRC_NRM((TB, _T("PointerPositionUpdate: (%d, %d)"), MousePos.x, MousePos.y));

    // Decouple to IH - can only set the pointer if we have the
    // input focus.
    _pCd->CD_DecoupleNotification(CD_SND_COMPONENT, _pIh, CD_NOTIFICATION_FUNC(CIH,IH_SetCursorPos),
                                   &MousePos,sizeof(MousePos));

    DC_END_FN();
}


/****************************************************************************/
// CM_ColorPointerPDU
//
// Handles a color-pointer PDU from server.
/****************************************************************************/
HRESULT DCAPI CCM::CM_ColorPointerPDU(
    TS_COLORPOINTERATTRIBUTE UNALIGNED FAR *pAttr,
    DCUINT dataLen)
{
    HRESULT hr = S_OK;
    HCURSOR oldHandle, newHandle;

    DC_BEGIN_FN("CM_ColorPointerPDU");

    // Create a new color cursor.
    // SECURITY: 555587 Must pass dataLen to CMCreate<XXX>Cursor
    hr = CMCreateNewColorCursor(pAttr->cacheIndex, pAttr, dataLen, &newHandle, &oldHandle);
    DC_QUIT_ON_FAIL(hr);

    // Call IH to enable it to set the cursor shape. Must do this
    // synchronously as we may receive a very large number of cursor
    // shape changes - for example when running MS Office 97 setup.

    TRC_NRM((TB, _T("Set cursor handle to %p"), newHandle));
    _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, _pIh,
                                         CD_NOTIFICATION_FUNC(CIH,IH_SetCursorShape),
                                        (ULONG_PTR)(LPVOID)newHandle);

    // Destroy any old handle if required, and remove from cache.
    if (oldHandle != NULL) {
#ifndef OS_WINCE
        DestroyCursor(oldHandle);
#else // OS_WINCE
        DestroyIcon(oldHandle);
#endif // OS_WINCE
    }

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}


/****************************************************************************/
// CM_CachedPointerPDU
//
// Handles a cached-pointer PDU from server.
/****************************************************************************/
void DCAPI CCM::CM_CachedPointerPDU(unsigned CacheIndex)
{
    HCURSOR newHandle;

    DC_BEGIN_FN("CM_CachedPointerPDU");

    // Get the cursor handle from the cache.
    // SECURITY: Not checking cacheIndex because we can succeeded
    // even with an invalid index
    newHandle = CMGetCachedCursor(CacheIndex);

    // Call IH to enable it to set the cursor shape. Must do this
    // synchronously as we may receive a very large number of cursor
    // shape changes - for example when running MS Office 97 setup.

    TRC_NRM((TB, _T("Set cursor handle to %p"), newHandle));
    _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, _pIh,
                                         CD_NOTIFICATION_FUNC(CIH,IH_SetCursorShape),
                                        (ULONG_PTR)(LPVOID)newHandle);

    DC_END_FN();
}


/****************************************************************************/
// CM_PointerPDU
//
// Handles a new-protocol pointer PDU from server.
/****************************************************************************/
HRESULT DCAPI CCM::CM_PointerPDU(TS_POINTERATTRIBUTE UNALIGNED FAR *pAttr,
    DCUINT dataLen)
{
    HRESULT hr = S_OK;
    HCURSOR oldHandle, newHandle;

    DC_BEGIN_FN("CM_PointerPDU");

    // Create a new cursor - may be mono or color.
    // SECURITY: 555587 must pass data length to CMCreate<XXX>Cursor 
    hr = CMCreateNewCursor(pAttr, dataLen, &newHandle, &oldHandle);
    DC_QUIT_ON_FAIL(hr);

    // Call IH to enable it to set the cursor shape. Must do this
    // synchronously as we may receive a very large number of cursor
    // shape changes - for example when running MS Office 97 setup.

    TRC_NRM((TB, _T("Set cursor handle to %p"), newHandle));
    _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, _pIh,
                                         CD_NOTIFICATION_FUNC(CIH,IH_SetCursorShape),
                                        (ULONG_PTR)(LPVOID)newHandle);

    // Destroy any old handle if required, and remove from cache.
    if (oldHandle != NULL) {
#ifndef OS_WINCE
        DestroyCursor(oldHandle);
#else // OS_WINCE
        DestroyIcon(oldHandle);
#endif // OS_WINCE
    }

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\core.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    core.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Madan Appiah - Sep. 5th 1997

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

C_DEFINES =              \
    $(C_DEFINES)         \
    $(CLIENT_EXE_CDEFS)  \
    -DDC_HICOLOR         \
    -DDRAW_NINEGRID      \
    -DDRAW_GDIPLUS
    
DISABLE_SHADOW_IN_FULLSCREEN = 1

!IFDEF DISABLE_SHADOW_IN_FULLSCREEN
C_DEFINES=$(C_DEFINES) -DDISABLE_SHADOW_IN_FULLSCREEN
!ENDIF

!IFNDEF OS_WINCE
SMART_SIZING=1
!ENDIF

!IFDEF SMART_SIZING
C_DEFINES=$(C_DEFINES) -DSMART_SIZING
!ENDIF

!IFDEF TSC_USE_GDIPLUS
C_DEFINES=$(C_DEFINES) -DUSE_GDIPLUS
!ENDIF

INCLUDES = $(SDK_INC_PATH)\gdiplus; \
          $(INCLUDES)

#
# List of sources
#

SOURCES_PLATFORM =

CLIENT_SOURCES_RC = \

CLIENT_SOURCES_COMMON = \
    ..\abdapi.cpp \
    ..\clicense.cpp \
    ..\aco.cpp    \
    ..\uiapi.cpp  \
    ..\uiint.cpp  \
    ..\ccapi.cpp  \
    ..\ccfsm.cpp  \
    ..\ih.cpp     \
    ..\ihint.cpp  \
    ..\orapi.cpp  \
    ..\orint.cpp  \
    ..\fsapi.cpp  \
    ..\slapi.cpp  \
    ..\slint.cpp  \
    ..\nlapi.cpp  \
    ..\ncapi.cpp  \
    ..\nccb.cpp   \
    ..\mcsapi.cpp \
    ..\mcsint.cpp \
    ..\tdapi.cpp  \
    ..\tdint.cpp  \
    ..\wtdapi.cpp \
    ..\wtdint.cpp \
    ..\cmapi.cpp  \
    ..\wcmint.cpp \
    ..\odapi.cpp  \
    ..\odint.cpp  \
    ..\opapi.cpp  \
    ..\opint.cpp  \
    ..\spapi.cpp  \
    ..\clxapi.cpp \
    ..\ghapi.cpp  \
    ..\ghint.cpp  \
    ..\uhapi.cpp  \
    ..\uhint.cpp  \
    ..\rcvapi.cpp \
    ..\sndapi.cpp \
    ..\cdapi.cpp  \
    ..\cdint.cpp  \
    ..\xtapi.cpp  \
    ..\cchannel.cpp \
    ..\bbar.cpp \
    ..\objs.cpp \
    ..\arcdlg.cpp \
    ..\drawninegrid.cpp	\
    ..\capienc.cpp

CLIENT_SOURCES_LAST  = \
    ..\wxlint.cpp

SOURCES = \
    $(CLIENT_SOURCES_RC) \
    $(SOURCES_PLATFORM) \
    $(CLIENT_SOURCES_COMMON) \
    $(CLIENT_SOURCES_LAST)


#
# Precompiled specs
#
PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE = ..\adcg.h
PRECOMPILED_PCH = adcg.pch
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\eosint.cpp ===
//---------------------------------------------------------------------------
// eosint.cpp
//---------------------------------------------------------------------------
// Copyright (c) 1997, Microsoft Corporation
//                  All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------
//
// This module contains code to supplement the WinCE OS for compatibility.
// 
//---------------------------------------------------------------------------
#include <adcg.h>
#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "eosint"
#include <atrcapi.h>
#include <wince.h>
#include <eosint.h>

// Object which does the work, only one is meant to exist
CHatchBrush vchb;

// WinCE replacement for CreateHatchBrush
WINGDIAPI HBRUSH  WINAPI CreateHatchBrush(int fnStyle, COLORREF clrref)
{
    return vchb.CreateHatchBrush(fnStyle, clrref);
}

// Constructor only NULLs out members
CHatchBrush::CHatchBrush()
{
    int i;
     DC_BEGIN_FN("CC_Event");
    TRC_ERR((TB, _T("Illegal hatched brush style")));

    for (i = 0; i < HS_LAST; i++) {
        m_hbmBrush[i] = NULL;
    }
}

// Destructor deletes any objects that were created
CHatchBrush::~CHatchBrush()
{
    int i;
    for (i = 0; i < HS_LAST; i++) {
        if (NULL != m_hbmBrush[i])
            DeleteObject(m_hbmBrush);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\drawninegrid.cpp ===
/****************************************************************************/
// drawninegrid.cpp
//
// GdiDrawStream Emulation functions
//
// Copyright (C) 2001 Microsoft Corporation
/****************************************************************************/

#include <adcg.h>

#ifndef OS_WINCE

extern "C" {
#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "drawninegrid"
#include <atrcapi.h>
}

#include "aordprot.h"

FNGDI_ALPHABLEND *g_pfnAlphaBlend = NULL;
FNGDI_TRANSPARENTBLT *g_pfnTransparentBlt = NULL;

typedef struct _DNGSTRETCH
{
    ULONG xStart;
    ULONG xAccum;
    ULONG xFrac;
    ULONG xInt;
    ULONG ulDestWidth;
    ULONG ulSrcWidth;
    int   left;
    int   right;
} DNGSTRETCH;

typedef struct _DNGINTERNALDATA
{
    int     cxClipMin;
    int     cxClipMax;

    ULONG*  pvDestBits;
    LONG    lDestDelta;
    int     iDestWidth;
    int     iClipWidth;

    ULONG*  pvSrcBits;
    LONG    lSrcDelta;
    int     iSrcWidth;
    int     iSrcBufWidth;

    int     cxLeftWidth;
    int     xMinLeft;
    int     xMaxLeft;

    int     cxRightWidth;
    int     xMinRight;
    int     xMaxRight;

    int     cxMiddleWidth;
    int     cxNewMiddleWidth;
    int     xMinMiddle;
    int     xMaxMiddle;

    // Variable for shrunken corners and sides
    BOOL    fShowMiddle;
    DNGSTRETCH stretchLeft;
    DNGSTRETCH stretchRight;
    int     cxNewLeftWidth;
    int     cxNewRightWidth;

    BOOL    fTileMode;
    // Specific to non-tile mode (i.e. stretch mode)
    DNGSTRETCH stretchMiddle;

    LONG    lBufWidth;

} DNGINTERNALDATA;

static inline void DNG_StretchRow(ULONG* pvDestBits, ULONG* pvSrcBits, DNGSTRETCH * ps)
{
    ULONG*  pvTemp = pvDestBits + ps->left;
    ULONG*  pvSentinel = pvDestBits + ps->right;

    ULONG   xInt = ps->xInt;
    ULONG   xFrac = ps->xFrac;
    ULONG   xTmp;
    ULONG   xAccum = ps->xAccum;
    ULONG * pulSrc = pvSrcBits + ps->xStart;
    ULONG   ulSrc;

    while (pvTemp != pvSentinel)
    {
        ulSrc  = *pulSrc;
        xTmp   = xAccum + xFrac;
        pulSrc = pulSrc + xInt + (xTmp < xAccum);
        *pvTemp = ulSrc;
        pvTemp++;
        xAccum = xTmp;
    }
}

static inline void DNG_InitStretch(DNGSTRETCH* pStretch, ULONG ulDestWidth, ULONG ulSrcWidth, int left, int right)
{
    pStretch->right = right;
    pStretch->left  = left;

    ULONGLONG dx = ((((ULONGLONG) ulSrcWidth << 32) - 1) / (ULONGLONG) ulDestWidth) + 1;
    ULONGLONG x = (((ULONGLONG) ulSrcWidth << 32) / (ULONGLONG) ulDestWidth) >> 1;
    ULONG   xInt = pStretch->xInt = (ULONG) (dx >> 32);
    ULONG   xFrac = pStretch->xFrac = (ULONG) (dx & 0xFFFFFFFF);

    ULONG   xAccum = (ULONG) (x & 0xFFFFFFFF);
    ULONG   xTmp;
    ULONG   xStart = (ULONG) (x >> 32);

    for (int i = 0; i < left; i++)
    {
        xTmp   = xAccum + xFrac;
        xStart = xStart + xInt + (xTmp < xAccum);
        xAccum = xTmp;
    }

    pStretch->xStart = xStart;
    pStretch->xAccum = xAccum;
}

static inline void DNG_DrawRow(DNGINTERNALDATA* pdng)
{
    ULONG* pvDestLoc = pdng->pvDestBits;
    ULONG* pvSrcLoc = pdng->pvSrcBits;

    // Left
    if (pdng->cxClipMin < pdng->cxNewLeftWidth)
    {
        if (pdng->cxLeftWidth == pdng->cxNewLeftWidth)
        {
            memcpy(pvDestLoc + pdng->xMinLeft, pvSrcLoc + pdng->xMinLeft, (pdng->xMaxLeft - pdng->xMinLeft) * sizeof(ULONG));            
        }
        else
        {
            DNG_StretchRow(pvDestLoc, pvSrcLoc, &pdng->stretchLeft);
        }
    }
    pvDestLoc += pdng->cxNewLeftWidth;
    pvSrcLoc  += pdng->cxLeftWidth;
  
    // Middle
    if (pdng->fShowMiddle)
    {
        if (pdng->xMinMiddle < pdng->xMaxMiddle)
        {
            if (pdng->fTileMode)
            {
                ULONG* pvTempSrc = pvSrcLoc;
                ULONG* pvTempDest = pvDestLoc;

                // Fill in Top Tile
                int xMin = pdng->xMinMiddle;
                int xDiff = xMin - pdng->cxLeftWidth;
                pvDestLoc += xDiff;
                int iTileSize = pdng->cxMiddleWidth - (xDiff % pdng->cxMiddleWidth);
                pvSrcLoc += xDiff % pdng->cxMiddleWidth;

                int xMax = pdng->xMaxMiddle;
                for (int x = xMin; x < xMax; x++, pvDestLoc++ , pvSrcLoc++)
                {
                    *pvDestLoc = *pvSrcLoc;
                    iTileSize--;
                    if (iTileSize == 0)
                    {
                        iTileSize = pdng->cxMiddleWidth;
                        pvSrcLoc -= iTileSize;
                    }
                }

                pvDestLoc = pvTempDest;
                pvSrcLoc = pvTempSrc;
            }
            else
            {
                DNG_StretchRow(pvDestLoc, pvSrcLoc, &pdng->stretchMiddle);
            }
        }
        pvDestLoc += pdng->cxNewMiddleWidth;
    }   
    pvSrcLoc  += pdng->cxMiddleWidth;

    // Right
    if (pdng->cxClipMax > (pdng->iDestWidth - pdng->cxNewRightWidth))
    {
        if (pdng->cxRightWidth == pdng->cxNewRightWidth)
        {
            memcpy(pvDestLoc + pdng->xMinRight, pvSrcLoc + pdng->xMinRight, (pdng->xMaxRight - pdng->xMinRight) * sizeof(ULONG));
        }
        else
        {
            DNG_StretchRow(pvDestLoc, pvSrcLoc, &pdng->stretchRight);
        }
    }
}

static inline void DNG_StretchCol(DNGINTERNALDATA* pdng, DNGSTRETCH * ps)
{
    ULONG*  pvOldDestBits = pdng->pvDestBits;
    ULONG*  pvOldSrcBits = pdng->pvSrcBits;
    
    ULONG*  pvTemp = pdng->pvDestBits - (pdng->lDestDelta * ps->left);
    ULONG*  pvSentinel = pdng->pvDestBits - (pdng->lDestDelta * ps->right); 

    ULONG   xInt = ps->xInt;
    ULONG   xFrac = ps->xFrac;
    ULONG   xTmp;
    ULONG   xAccum = ps->xAccum;
    ULONG * pulSrc = pdng->pvSrcBits - (pdng->lSrcDelta * ps->xStart);
    ULONG   xDelta = 1; // force stretch on first scan

    while (pvTemp != pvSentinel)
    {
        if (xDelta != 0)
        {
            pdng->pvDestBits = pvTemp;
            pdng->pvSrcBits = pulSrc;
            DNG_DrawRow(pdng);
        }
        else
        {
            memcpy(pvTemp + pdng->cxClipMin, pvTemp + pdng->cxClipMin + pdng->lDestDelta, pdng->iClipWidth * sizeof(ULONG));
        }

        xTmp   = xAccum + xFrac;

        xDelta = (xInt + (xTmp < xAccum));
        pulSrc = pulSrc - (pdng->lSrcDelta * xDelta);
        pvTemp -= pdng->lDestDelta;
        xAccum = xTmp;
    }

    pdng->pvDestBits = pvOldDestBits;
    pdng->pvSrcBits = pvOldSrcBits;
}

static void RenderNineGridInternal(
    TS_BITMAPOBJ       *psoScratch,
    TS_BITMAPOBJ       *psoSrc,
    RECTL              *prclClip,
    RECTL              *prclDst,
    RECTL              *prclSrc,
    DS_NINEGRIDINFO    *ngi,
    BOOL                bMirror)
{
    RECTL   rcDest = *prclDst;
    RECTL   rcClip = *prclClip;
    ULONG*  pvDestBits = NULL;
    int     iDestWidth = rcDest.right - rcDest.left;
    int     iDestHeight = rcDest.bottom - rcDest.top;
    int     iClipWidth = rcClip.right - rcClip.left;
    int     iClipHeight = rcClip.bottom - rcClip.top;
    LONG    lBufWidth = psoScratch->sizlBitmap.cx;
    LONG    lBufHeight = psoScratch->sizlBitmap.cy;
    
    DNGINTERNALDATA dng;

    // The code below assumes that the source and scratch is 32bpp

    //ASSERTGDI(psoSrc->iBitmapFormat == BMF_32BPP, "RenderNineGridInternal: source not 32bpp");
    //ASSERTGDI(psoScratch->iBitmapFormat == BMF_32BPP, "RenderNineGridInternal: scratch not 32bpp");

    // The code below assumes that both source and scratch are bottom up

//    ASSERTGDI(psoSrc->lDelta < 0, "RenderNineGridInternal: source is not bottom up");
//    ASSERTGDI(psoScratch->lDelta < 0, "RenderNineGridInternal: scratch is not bottom up");

    dng.lBufWidth = lBufWidth;
    
    LONG lDestDelta = psoScratch->lDelta / sizeof(ULONG);
    dng.lDestDelta = lDestDelta;

    LONG lSrcDelta = psoSrc->lDelta / sizeof(ULONG);
    dng.lSrcDelta = lSrcDelta;

    dng.cxClipMin = rcClip.left - rcDest.left;
    dng.cxClipMax = rcClip.right - rcDest.left;
    int cyClipMin = rcClip.top - rcDest.top;
    int cyClipMax = rcClip.bottom - rcDest.top;
    
    // pvBits points to the pixel addressed at (cxClipMin, cyClipMin)
    // pvDestBits points to the pixel addressed at (0, iDestHeight - 1)
    pvDestBits = (ULONG *) psoScratch->pvBits;
    pvDestBits += (iDestHeight - 1 - cyClipMin) * lDestDelta;
    pvDestBits -=  dng.cxClipMin;

    int cxImage = rcClip.right - rcClip.left;
    int cyImage = rcClip.bottom - rcClip.top;

    LONG lSrcBufWidth = psoSrc->sizlBitmap.cx;
    LONG lSrcWidth = prclSrc->right - prclSrc->left;
    LONG lSrcHeight = prclSrc->bottom - prclSrc->top;

    ULONG * lSrcBits = (ULONG *) psoSrc->pvBits + (lSrcDelta * prclSrc->top) + prclSrc->left;
    lSrcBits += (lSrcDelta * (prclSrc->bottom - prclSrc->top - 1));

//    ULONG * lSrcBits = (ULONG *) psoSrc->pvScan0 + (lSrcDelta * (psoSrc->sizlBitmap.cy - 1));

    if (ngi->flFlags & DSDNG_TRUESIZE)
    {
        ULONG* pvDestLoc = pvDestBits - ((iDestHeight - 1) * lDestDelta);
        ULONG* pvSrcLoc = lSrcBits - ((lSrcHeight - 1) * lSrcDelta);
        int yMin = cyClipMin;
        pvDestLoc += yMin * lDestDelta;
        pvSrcLoc += yMin * lSrcDelta;
        int yMax = min(lSrcHeight, cyClipMax);

        int xMin = dng.cxClipMin;
        int xMax = min(lSrcWidth, dng.cxClipMax);

        if (xMax > xMin)
        {
            for (int y = yMin; y < yMax; y++, pvDestLoc += lDestDelta, pvSrcLoc += lSrcDelta)
            {
                memcpy(pvDestLoc + xMin, pvSrcLoc + xMin, (xMax - xMin) * 4);
            }
        }

        cxImage = xMax - xMin;
        cyImage = yMax - yMin;
    }
    else
    {
        // Setup data
        dng.iDestWidth  = iDestWidth;
        dng.iClipWidth  = iClipWidth;
        dng.iSrcWidth   = lSrcWidth;
        dng.iSrcBufWidth = lSrcBufWidth;

        dng.cxLeftWidth    = ngi->ulLeftWidth;
        dng.cxRightWidth   = ngi->ulRightWidth;

        dng.fTileMode = (ngi->flFlags & DSDNG_TILE);

        // Calculate clip stuff

        // Pre-calc corner stretching variables
        dng.fShowMiddle = (iDestWidth  - dng.cxLeftWidth - dng.cxRightWidth > 0);

        if (!dng.fShowMiddle)
        {
            dng.cxNewLeftWidth  = (dng.cxLeftWidth + dng.cxRightWidth == 0) ? 0 : (dng.cxLeftWidth * dng.iDestWidth) / (dng.cxLeftWidth + dng.cxRightWidth);
            dng.cxNewRightWidth = dng.iDestWidth - dng.cxNewLeftWidth;
        }
        else
        {
            dng.cxNewLeftWidth  = dng.cxLeftWidth;
            dng.cxNewRightWidth = dng.cxRightWidth;
        }

        // Pre-calc Left side variables
        dng.xMinLeft = dng.cxClipMin;
        dng.xMaxLeft = min(dng.cxNewLeftWidth, dng.cxClipMax);
        if (!dng.fShowMiddle && dng.cxNewLeftWidth)
        {
            DNG_InitStretch(&dng.stretchLeft, dng.cxNewLeftWidth, dng.cxLeftWidth, dng.xMinLeft, dng.xMaxLeft);
        }

        // Pre-calc Horizontal Middle Variables
        dng.cxMiddleWidth    = dng.iSrcWidth  - dng.cxLeftWidth - dng.cxRightWidth;
        dng.cxNewMiddleWidth = dng.iDestWidth - dng.cxNewLeftWidth - dng.cxNewRightWidth;
        dng.xMinMiddle = max(dng.cxNewLeftWidth, dng.cxClipMin);
        dng.xMaxMiddle = min(dng.cxNewLeftWidth + dng.cxNewMiddleWidth, dng.cxClipMax);
        if (dng.fShowMiddle)
        {
            DNG_InitStretch(&dng.stretchMiddle, dng.cxNewMiddleWidth, dng.cxMiddleWidth, dng.xMinMiddle - dng.cxNewLeftWidth, dng.xMaxMiddle - dng.cxNewLeftWidth);
        }

        // Pre-calc Right side variables
        dng.xMinRight = max(dng.iDestWidth - dng.cxNewRightWidth, dng.cxClipMin) - dng.cxNewLeftWidth - dng.cxNewMiddleWidth;
        dng.xMaxRight = min(dng.iDestWidth, dng.cxClipMax) - dng.cxNewLeftWidth - dng.cxNewMiddleWidth;
        if (!dng.fShowMiddle && dng.cxNewRightWidth)
        {
            DNG_InitStretch(&dng.stretchRight, dng.cxNewRightWidth, dng.cxRightWidth, dng.xMinRight, dng.xMaxRight);
        }

        BOOL fShowVertMiddle = (iDestHeight - ngi->ulTopHeight - ngi->ulBottomHeight > 0);
        int cyTopHeight    = ngi->ulTopHeight;
        int cyBottomHeight = ngi->ulBottomHeight;
        int cyNewTopHeight;
        int cyNewBottomHeight;
        if (!fShowVertMiddle)
        {
            cyNewTopHeight = (cyTopHeight + cyBottomHeight == 0) ? 0 : (cyTopHeight * iDestHeight) / (cyTopHeight + cyBottomHeight);
            cyNewBottomHeight = iDestHeight - cyNewTopHeight;
        }
        else
        {
            cyNewTopHeight    = cyTopHeight;
            cyNewBottomHeight = cyBottomHeight;
        }

        // Draw Bottom
        // Draw the scan line from (iDestHeight - cyNewBottomHeight) to less than iDestHeight, in screen coordinates
        int yMin = max(iDestHeight - cyNewBottomHeight, cyClipMin);
        int yMax = min(iDestHeight, cyClipMax);

        if (cyClipMax > iDestHeight - cyNewBottomHeight)
        {
            dng.pvDestBits = pvDestBits;
            dng.pvSrcBits = lSrcBits;
            if (cyBottomHeight == cyNewBottomHeight)
            {
                int yDiff = yMin - (iDestHeight - cyNewBottomHeight);
                dng.pvDestBits -= (cyBottomHeight - 1 - yDiff) * lDestDelta;
                
                dng.pvSrcBits  -= (cyBottomHeight - 1 - yDiff) * lSrcDelta;
                for (int y = yMin; y < yMax; y++, dng.pvDestBits += lDestDelta, dng.pvSrcBits += lSrcDelta)
                {
                    DNG_DrawRow(&dng);
                }
            }
            else if (cyNewBottomHeight > 0)
            {
                DNGSTRETCH stretch;
                DNG_InitStretch(&stretch, cyNewBottomHeight, cyBottomHeight, cyNewBottomHeight - (yMax - iDestHeight + cyNewBottomHeight), cyNewBottomHeight - (yMin - iDestHeight + cyNewBottomHeight));
                DNG_StretchCol(&dng, &stretch);
            }
        }

        // Draw Middle
        // Draw the scan line from cyNewTopHeight to less than (iDestHeight - cyNewBottomHeight), in screen coordinates
        if (fShowVertMiddle && (cyClipMin < iDestHeight - cyNewBottomHeight) && (cyClipMax > cyNewTopHeight))
        {
            int cySrcTileSize = lSrcHeight - ngi->ulTopHeight - ngi->ulBottomHeight;
            int cyDestTileSize = iDestHeight - ngi->ulTopHeight - ngi->ulBottomHeight;

            dng.pvDestBits = pvDestBits - ngi->ulBottomHeight * lDestDelta;
            dng.pvSrcBits = lSrcBits - ngi->ulBottomHeight * lSrcDelta;

            int yMin = max(cyTopHeight, cyClipMin);

            if (dng.fTileMode)
            {
                // Start off tile
                dng.pvDestBits -= (cyDestTileSize - 1) * lDestDelta;
                dng.pvSrcBits  -= (cySrcTileSize - 1)  * lSrcDelta;

                int yDiff = yMin - cyTopHeight;
                dng.pvDestBits += yDiff * lDestDelta;

                int yOffset = (yDiff % cySrcTileSize);
                dng.pvSrcBits += yOffset * dng.lSrcDelta;
                int iTileOffset = cySrcTileSize - yOffset;

                int yMax = min(yMin + min(cySrcTileSize, cyDestTileSize), min(iDestHeight - cyBottomHeight, cyClipMax));
                for (int y = yMin; y < yMax; y++, dng.pvDestBits += lDestDelta, dng.pvSrcBits += lSrcDelta)
                {
                    DNG_DrawRow(&dng);
                    iTileOffset--;
                    if (iTileOffset == 0)
                    {
                        iTileOffset = cySrcTileSize;
                        dng.pvSrcBits -= lSrcDelta * cySrcTileSize;
                    }
                }

                // Repeat tile pattern
                dng.pvSrcBits = dng.pvDestBits - (lDestDelta * cySrcTileSize);
                yMin = yMax;
                yMax = min(iDestHeight - cyBottomHeight, cyClipMax);
                for (int y = yMin; y < yMax; y++, dng.pvDestBits += lDestDelta, dng.pvSrcBits += lDestDelta)
                {
                    memcpy(dng.pvDestBits + dng.cxClipMin, dng.pvSrcBits + dng.cxClipMin, dng.iClipWidth * sizeof(ULONG));
                }
            }
            else
            {
                int yMax = min(iDestHeight - cyBottomHeight, cyClipMax);

                DNGSTRETCH stretch;
                DNG_InitStretch(&stretch, cyDestTileSize, cySrcTileSize, cyDestTileSize - (yMax - cyTopHeight), cyDestTileSize - (yMin - cyTopHeight));
                // Convert from screen coords to DIB coords
                DNG_StretchCol(&dng, &stretch);
            }
        }

        // Draw Top
        // Draw the scan line from 0 to less than cyNewTopHeight, in screen coordinates
        yMin = cyClipMin;
        yMax = min(cyNewTopHeight, cyClipMax);

        if (cyClipMin < cyNewTopHeight)
        {
            dng.pvDestBits = pvDestBits - (iDestHeight - cyNewTopHeight) * lDestDelta;
            dng.pvSrcBits = lSrcBits - (lSrcHeight - ngi->ulTopHeight) * lSrcDelta;
            if (cyTopHeight == cyNewTopHeight)
            {
                dng.pvDestBits -= (cyTopHeight - 1 - yMin) * lDestDelta;
                dng.pvSrcBits  -= (cyTopHeight - 1 - yMin) * lSrcDelta;
                for (int y = yMin; y < yMax; y++, dng.pvDestBits += lDestDelta, dng.pvSrcBits += lSrcDelta)
                {
                    DNG_DrawRow(&dng);
                }
            }
            else if (cyNewTopHeight > 0)
            {
                DNGSTRETCH stretch;
                DNG_InitStretch(&stretch, cyNewTopHeight, cyTopHeight, cyNewTopHeight - yMax, cyNewTopHeight - yMin);
                DNG_StretchCol(&dng, &stretch);
            }
        }
    }

    if (bMirror)
    {
        // Flip the buffer
        for (int y = 0; y < iClipHeight; y++)
        {
            ULONG* pvLeftBits = (ULONG *) psoScratch->pvBits + (y * lDestDelta);
            ULONG* pvRightBits = pvLeftBits + iClipWidth - 1;
            for (int x = 0; x < (iClipWidth / 2); x++)
            {
                ULONG ulTemp = *pvLeftBits;
                *pvLeftBits = *pvRightBits;
                *pvRightBits = ulTemp;

                pvLeftBits++;
                pvRightBits--;
            }
        }
    }
}

static void RenderNineGrid(
    HDC                 hdcDst,
    TS_BITMAPOBJ       *psoSrc,
    TS_BITMAPOBJ       *psoScratch,    
    RECTL              *prclClip,    
    RECTL              *prclDst,
    RECTL              *prclSrc,
    DS_NINEGRIDINFO    *ngi,   
    BOOL                bMirror)
{
    // only mirror the contents if we need to

    bMirror = bMirror && (ngi->flFlags & DSDNG_MUSTFLIP);
        
    // render nine grid into scratch

    RECTL erclClip = *prclClip;

    if(bMirror)
    {
        // We need to remap the clip to ensure we generate the right flipped bits
        erclClip.right = prclDst->right - (prclClip->left - prclDst->left);
        erclClip.left = prclDst->right - (prclClip->right - prclDst->left);
    }

    RenderNineGridInternal(psoScratch, psoSrc, &erclClip, prclDst, prclSrc, ngi, bMirror);
    
    // copy scratch to destination
    
    LONG    lClipWidth = prclClip->right - prclClip->left;
    LONG    lClipHeight = prclClip->bottom - prclClip->top;

    RECTL  erclScratch = {0, 0, lClipWidth, lClipHeight};

    if(ngi->flFlags & DSDNG_PERPIXELALPHA)
    {
        BLENDFUNCTION   BlendFunc;

        BlendFunc.AlphaFormat = AC_SRC_ALPHA;
        BlendFunc.BlendFlags = 0;
        BlendFunc.SourceConstantAlpha = 255;
        BlendFunc.BlendOp = AC_SRC_OVER;    

        //PPFNDIRECT(psoDst, AlphaBlend)(psoDst, psoScratch, prclClip, &erclScratch, &eBlendObj);
        g_pfnAlphaBlend(hdcDst, prclClip->left, prclClip->top, (prclClip->right - prclClip->left),
                   (prclClip->bottom - prclClip->top), psoScratch->hdc, erclScratch.left, erclScratch.top, 
                   (erclScratch.right - erclScratch.left), (erclScratch.bottom - erclScratch.top),
                   BlendFunc);
        
    }
    else if(ngi->flFlags & DSDNG_TRANSPARENT)
    {
        //PPFNDIRECT(psoDst, TransparentBlt)(psoDst, psoScratch, prclClip, &erclScratch, ngi->crTransparent, 0);
        g_pfnTransparentBlt(hdcDst, prclClip->left, prclClip->top, (prclClip->right - prclClip->left),
                   (prclClip->bottom - prclClip->top), psoScratch->hdc, erclScratch.left, erclScratch.top, 
                   (erclScratch.right - erclScratch.left), (erclScratch.bottom - erclScratch.top),
                   ngi->crTransparent);
    }
    else
    {
        //PPFNDIRECT(psoDst, CopyBits)(psoDst, psoScratch, prclClip, &gptlZero);
        BitBlt(hdcDst, prclClip->left, prclClip->top, (prclClip->right - prclClip->left),
                   (prclClip->bottom - prclClip->top), psoScratch->hdc, erclScratch.left, erclScratch.top, 
                   SRCCOPY);
    }    
}

BOOL DrawNineGrid(
    HDC             hdcDst,
    TS_BITMAPOBJ   *psoSrc,
    TS_DS_NINEGRID *pDNG)
{
    BOOL             bRet = FALSE;
    DS_NINEGRIDINFO *ngi;
    RECTL            erclDst;
    PRECTL           prclSrc;
    TS_BITMAPOBJ     soScratch = { 0 };
    HBITMAP          hBitmap = NULL;

    ngi = &(pDNG->dng.ngi);
    erclDst = pDNG->dng.rclDst;
    prclSrc = &(pDNG->dng.rclSrc);
    
    g_pfnAlphaBlend = pDNG->pfnAlphaBlend;
    g_pfnTransparentBlt = pDNG->pfnTransparentBlt;

    BOOL bMirror = (erclDst.left > erclDst.right);
    
    if(bMirror)
    {
        LONG    lRight = erclDst.left;
        erclDst.left = erclDst.right;
        erclDst.right = lRight;
    }

    // NOTE: TRUESIZE is a hack.  The caller should do this reduction
    //       and pass us an appropriate destination.
    // TODO: Talk with Justin Mann about changing his behavior in how
    //       he calls us here.  We should add assertions that the
    //       destination dimensions never exceeds the source dimensions and
    //       modify GdiDrawStream callers to pass appropriate data.

    if(ngi->flFlags & DSDNG_TRUESIZE)
    {
        LONG lSrcWidth = prclSrc->right - prclSrc->left;
        LONG lSrcHeight = prclSrc->bottom - prclSrc->top;

        // reduce destination to source size

        if((erclDst.right - erclDst.left) > lSrcWidth)
        {
            if(bMirror)
                erclDst.left = erclDst.right - lSrcWidth;
            else
                erclDst.right = erclDst.left + lSrcWidth;
        }
    
        if((erclDst.bottom - erclDst.top) > lSrcHeight)
        {
            if(bMirror)
                erclDst.top = erclDst.bottom - lSrcHeight;
            else
                erclDst.bottom = erclDst.top + lSrcHeight;
        }
    }

    RECTL erclClip = erclDst;

    // For now, we only support 32bpp sources

    //ASSERTGDI(psoSrc->iBitmapFormat == BMF_32BPP, "EngNineGrid: source not 32bpp");

    
    //ASSERTGDI(erclClip.left >= 0 &&
    //          erclClip.top >= 0 &&
    //          erclClip.right <= psoDst->sizlBitmap.cx &&
    //          erclClip.bottom <= psoDst->sizlBitmap.cy, "EngNineGrid: bad clip");


    if(erclClip.left <= erclClip.right && erclClip.top <= erclClip.bottom)
    {
        LONG    lClipWidth = erclClip.right - erclClip.left;
        LONG    lClipHeight = erclClip.bottom - erclClip.top;

        //ASSERTGDI(lClipWidth > 0, "RenderNineGrid: clip width <= 0");
        //ASSERTGDI(lClipHeight > 0, "RenderNineGrid: clip height <= 0");

        #define SCRATCH_WIDTH    (256)
        #define SCRATCH_HEIGHT   (64)

        {
            BITMAPINFO bi = { 0 };
            void * pvBits = NULL;
            
            bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
            bi.bmiHeader.biWidth = SCRATCH_WIDTH;
            bi.bmiHeader.biHeight = 0 - SCRATCH_HEIGHT;
            bi.bmiHeader.biPlanes = 1;
            bi.bmiHeader.biBitCount = 32;
            bi.bmiHeader.biCompression = BI_RGB;
        
            hBitmap = CreateDIBSection(psoSrc->hdc, &bi, DIB_RGB_COLORS, 
                                       (VOID**)&pvBits, NULL, 0);

            if (hBitmap) {
                soScratch.cjBits = SCRATCH_WIDTH * SCRATCH_HEIGHT * 32 / 8;
                soScratch.iBitmapFormat = 32;
                soScratch.lDelta = SCRATCH_WIDTH * sizeof(ULONG);
                soScratch.pvBits = pvBits;
                soScratch.sizlBitmap.cx = SCRATCH_WIDTH;
                soScratch.sizlBitmap.cy = SCRATCH_HEIGHT;

                soScratch.hdc = CreateCompatibleDC(NULL);
    
                if (soScratch.hdc != NULL) {
                    SelectBitmap(soScratch.hdc, hBitmap);
                }
                else {
                    goto exit;
                }
            }
            else {
                goto exit;
            }
        }

        if(lClipWidth >  SCRATCH_WIDTH || lClipHeight > SCRATCH_HEIGHT)
        {
            LONG    lBufWidth = SCRATCH_WIDTH;
            LONG    lBufHeight = SCRATCH_HEIGHT;

            LONG lReducedClipTop = erclClip.top;

            while(lReducedClipTop < erclClip.bottom)
            {
                LONG lReducedClipBottom = lReducedClipTop + lBufHeight;

                if(lReducedClipBottom > erclClip.bottom)
                    lReducedClipBottom = erclClip.bottom;

                LONG lReducedClipLeft = erclClip.left;

                while(lReducedClipLeft < erclClip.right)
                {
                    LONG lReducedClipRight = lReducedClipLeft + lBufWidth;

                    if(lReducedClipRight > erclClip.right)
                        lReducedClipRight = erclClip.right;

                    RECTL erclReducedClip = {lReducedClipLeft, lReducedClipTop,
                                           lReducedClipRight, lReducedClipBottom};

                    RenderNineGrid(hdcDst,
                                   psoSrc,
                                   &soScratch,
                                   &erclReducedClip,
                                   &erclDst,
                                   prclSrc,
                                   ngi,
                                   bMirror);

                    lReducedClipLeft += lBufWidth;
                }

                lReducedClipTop += lBufHeight;
            }
        }
        else
        {
            RenderNineGrid(hdcDst, psoSrc, &soScratch, &erclClip, &erclDst, prclSrc, ngi, bMirror);
        }
    }

    bRet = TRUE;

exit:

    if (hBitmap != NULL) {
        DeleteObject(hBitmap);
    }
    if (soScratch.hdc != NULL) {
        DeleteDC(soScratch.hdc);
    }
    return bRet;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\ghint.cpp ===
/****************************************************************************/
// wghint.c
//
// Glyph handler - internal Windows specific
//
// Copyright (C) 1997-1999 Microsoft Corporation 1997-1999
/****************************************************************************/

#include <adcg.h>

extern "C" {
#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "wghint"
#include <atrcapi.h>
}
#define TSC_HR_FILEID TSC_HR_GHINT_CPP

#include "autil.h"
#include "gh.h"
#include "uh.h"
#include <wxlint.h>




#if defined(OS_WINCE) || defined(OS_WINNT)

#ifdef DC_HICOLOR
/******************************Public*Routine******************************\
*   vSrcOpaqCopyS1D8_24
*
*   Opaque blt of 1BPP src to 24bpp destination
*
* Arguments:
*    pjSrcIn    - pointer to beginning of current scan line of src buffer
*    SrcLeft    - left (starting) pixel in src rectangle
*    DeltaSrcIn - bytes from one src scan line to next
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer
*    DstLeft    - left(first) dst pixel
*    DstRight   - right(last) dst pixel
*    DeltaDstIn - bytes from one Dst scan line to next
*    cy         - number of scan lines
*    fgCol      - Foreground color
*    bgCol      - Background color
\**************************************************************************/
VOID CGH::vSrcOpaqCopyS1D8_24(
        PBYTE   pjSrcIn,
        LONG    SrcLeft,
        LONG    DeltaSrcIn,
        PBYTE   pjDstIn,
        LONG    DstLeft,
        LONG    DstRight,
        LONG    DeltaDstIn,
        LONG    cy,
        DCRGB   fgCol,
        DCRGB   bgCol)
{
    // We access the 1bpp source a byte at a time, so we have to start accessing
    // the destination on a corresponding 8-pel aligned left edge
    ULONG LeftAln      = (DstLeft & ~0x07);
    ULONG LeftEdgeMask = 0xFF >> (DstLeft & 0x07);
    ULONG RightAln     = (DstRight & ~0x07);
    ULONG AlnDelta     = RightAln - LeftAln;

    LONG  DeltaDst;
    LONG  DeltaSrc;

    PBYTE pjDstEndY;
    PBYTE pjSrc;
    PBYTE pjDst;

    DC_BEGIN_FN("vSrcTranCopyS1D8_24");

    // calculate the pel-aligned pointers and row deltas
    pjDst     = pjDstIn + LeftAln * 3;
    pjDstEndY = pjDst + cy * DeltaDstIn * 3;

    pjSrc     = pjSrcIn + (SrcLeft >> 3);

    DeltaSrc  = DeltaSrcIn - (AlnDelta >> 3);
    DeltaDst  = (DeltaDstIn - AlnDelta) * 3;

    // make sure at least 1 QWORD needs copying
    if (RightAln != LeftAln)
    {

        // for each row...
        do
        {
            PBYTE pjDstEnd = pjDst + AlnDelta * 3;
            BYTE currentPels;
            ULONG i;

            // Mask off the left edge
            currentPels = (BYTE)(*pjSrc & (BYTE)(LeftEdgeMask));

            for (i = 0; i < 8; i++)
            {
                if ((0xff >> i) > (BYTE)(LeftEdgeMask))
                {
                    pjDst += 3;
                }
                else if ((currentPels & 0x80) == 0)
                {
                    *pjDst++ = bgCol.blue;
                    *pjDst++ = bgCol.green;
                    *pjDst++ = bgCol.red;
                }
                else
                {
                    *pjDst++ = fgCol.blue;
                    *pjDst++ = fgCol.green;
                    *pjDst++ = fgCol.red;
                }
                currentPels = (BYTE)(currentPels << 1);
            }
            pjSrc ++;

            // now do the rest of the row
            while (pjDst != pjDstEnd)
            {
                currentPels = *pjSrc;
                if (currentPels != 0)
                {
                    for (i = 0; i < 8 ; i++)
                    {
                        if ((currentPels & 0x80) == 0)
                        {
                            *pjDst++ = bgCol.blue;
                            *pjDst++ = bgCol.green;
                            *pjDst++ = bgCol.red;
                        }
                        else
                        {
                            *pjDst++ = fgCol.blue;
                            *pjDst++ = fgCol.green;
                            *pjDst++ = fgCol.red;
                        }
                        currentPels = (BYTE)(currentPels << 1);
                    }
                }
                else
                {
                    for (i = 0; i < 8 ; i++)
                    {
                        *pjDst++ = bgCol.blue;
                        *pjDst++ = bgCol.green;
                        *pjDst++ = bgCol.red;
                    }
                }

                pjSrc++;
            }

            pjDst += DeltaDst;
            pjSrc += DeltaSrc;

        } while (pjDst != pjDstEndY);
    }

    // Now fill in the right edge
    RightAln = DstRight & 0x07;
    if (RightAln)
    {
        BYTE  currentPels;
        BOOL  bSameQWord = ((DstLeft) & ~0x07) ==  ((DstRight) & ~0x07);

        LeftAln = DstLeft & 0x07;

        // if left and right edges are in same qword handle with masked
        // read-modify-write
        if (bSameQWord)
        {
            LONG  xCount;
            LONG  lDeltaDst;
            PBYTE pjDstEnd;

            xCount = RightAln - LeftAln;

            // sanity checks!
            if (xCount <= 0)
            {
                return;
            }

            lDeltaDst = (DeltaDstIn - xCount) * 3;

            pjDst     = pjDstIn + DstLeft * 3;
            pjDstEndY = pjDst + cy * DeltaDstIn * 3;
            pjSrc     = pjSrcIn + (SrcLeft >> 3);

            // expand, one src byte is all that's required
            do
            {
                // load src and shift into place
                currentPels = *pjSrc;
                currentPels <<= LeftAln;
                pjDstEnd    = pjDst + xCount * 3;

                do
                {
                    if ((currentPels & 0x80) == 0)
                    {
                        *pjDst++ = bgCol.blue;
                        *pjDst++ = bgCol.green;
                        *pjDst++ = bgCol.red;
                    }
                    else
                    {
                        *pjDst++ = fgCol.blue;
                        *pjDst++ = fgCol.green;
                        *pjDst++ = fgCol.red;
                    }

                    currentPels = (BYTE)(currentPels << 1);

                } while (pjDst != pjDstEnd);

                pjDst += lDeltaDst;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);

            return;
        }
        else
        {
            BYTE  currentPels;
            LONG  lDeltaDst = (DeltaDstIn - RightAln) * 3;
            PBYTE pjDstEnd;
            ULONG i;

            pjDst     = pjDstIn + (DstRight & ~0x07) * 3;
            pjDstEndY = pjDst + cy * DeltaDstIn * 3;
            pjSrc     = pjSrcIn + ((SrcLeft + (DstRight - DstLeft)) >> 3);

            do
            {
                // read src
                currentPels = *pjSrc;

                if (currentPels != 0)
                {
                    pjDstEnd = pjDst + RightAln * 3;
                    do
                    {
                        if ((currentPels & 0x80) == 0)
                        {
                            *pjDst++ = bgCol.blue;
                            *pjDst++ = bgCol.green;
                            *pjDst++ = bgCol.red;
                        }
                        else
                        {
                            *pjDst++ = fgCol.blue;
                            *pjDst++ = fgCol.green;
                            *pjDst++ = fgCol.red;
                        }
                        currentPels = (BYTE)(currentPels << 1);

                    } while (pjDst != pjDstEnd);
                }
                else
                {
                    // short cut for zero
                    for (i = 0; i < RightAln ; i++)
                    {
                        *pjDst++ = bgCol.blue;
                        *pjDst++ = bgCol.green;
                        *pjDst++ = bgCol.red;
                    }
                }

                pjDst += lDeltaDst;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);
        }
    }

    DC_END_FN();

}

/******************************Public*Routine******************************\
*   vSrcOpaqCopyS1D8_16
*
*   Opaque blt of 1BPP src to 16bpp destination
*
* Arguments:
*    pjSrcIn    - pointer to beginning of current scan line of src buffer
*    SrcLeft    - left (starting) pixel in src rectangle
*    DeltaSrcIn - bytes from one src scan line to next
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer
*    DstLeft    - left(first) dst pixel
*    DstRight   - right(last) dst pixel
*    DeltaDstIn - bytes from one Dst scan line to next
*    cy         - number of scan lines
*    fgCol      - Foreground color
*    bgCol      - Background color
\**************************************************************************/
VOID CGH::vSrcOpaqCopyS1D8_16(
        PBYTE   pjSrcIn,
        LONG    SrcLeft,
        LONG    DeltaSrcIn,
        PBYTE   pjDstIn,
        LONG    DstLeft,
        LONG    DstRight,
        LONG    DeltaDstIn,
        LONG    cy,
        ULONG   fgCol,
        ULONG   bgCol)
{
    // We access the 1bpp source a byte at a time, so we have to start accessing
    // the destination on a corresponding 8-pel aligned left edge
    ULONG LeftAln      = (DstLeft & ~0x07);
    ULONG LeftEdgeMask = 0xFF >> (DstLeft & 0x07);
    ULONG RightAln     = (DstRight & ~0x07);
    ULONG AlnDelta     = RightAln - LeftAln;

    LONG  DeltaDst;
    LONG  DeltaSrc;

    PBYTE pjDstEndY;
    PBYTE pjSrc;
    PBYTE pjDst;

    DC_BEGIN_FN("vSrcTranCopyS1D8_16");

    // calculate the pel-aligned pointers and row deltas
    pjDst     = pjDstIn + LeftAln * 2;
    pjDstEndY = pjDst + cy * DeltaDstIn * 2;

    pjSrc     = pjSrcIn + (SrcLeft >> 3);

    DeltaSrc  = DeltaSrcIn - (AlnDelta >> 3);
    DeltaDst  = (DeltaDstIn - AlnDelta) * 2;

    // make sure at least 1 QWORD needs copying
    if (RightAln != LeftAln)
    {

        // for each row...
        do
        {
            PBYTE pjDstEnd = pjDst + AlnDelta * 2;
            BYTE  currentPels;
            ULONG i;

            // Mask off the left edge
            currentPels = (BYTE)(*pjSrc & (BYTE)(LeftEdgeMask));

            for (i = 0; i < 8; i++)
            {
                if ((0xff >> i) <= (BYTE)(LeftEdgeMask))
                {
                    if ((currentPels & 0x80) == 0)
                    {
                        *(UINT16 *)pjDst = (UINT16)bgCol;

                    }
                    else
                    {
                        *(UINT16 *)pjDst = (UINT16)fgCol;
                    }
                }
                pjDst += 2;
                currentPels = (BYTE)(currentPels << 1);
            }
            pjSrc ++;

            // now do the rest of the row
            while (pjDst != pjDstEnd)
            {
                currentPels = *pjSrc;
                if (currentPels != 0)
                {
                    for (i = 0; i < 8 ; i++)
                    {
                        if ((currentPels & 0x80) == 0)
                        {
                            *(UINT16 *)pjDst = (UINT16)bgCol;
                        }
                        else
                        {
                            *(UINT16 *)pjDst = (UINT16)fgCol;
                        }
                        pjDst += 2;
                        currentPels = (BYTE)(currentPels << 1);
                    }
                }
                else
                {
                    for (i = 0; i < 8 ; i++)
                    {
                        *(UINT16 *)pjDst = (UINT16)bgCol;
                        pjDst += 2;
                    }
                }

                pjSrc++;
            }

            pjDst += DeltaDst;
            pjSrc += DeltaSrc;

        } while (pjDst != pjDstEndY);
    }

    // Now fill in the right edge
    RightAln = DstRight & 0x07;
    if (RightAln)
    {
        BYTE  currentPels;
        BOOL  bSameQWord = ((DstLeft) & ~0x07) ==  ((DstRight) & ~0x07);

        LeftAln = DstLeft & 0x07;

        // if left and right edges are in same qword handle with masked
        // read-modify-write
        if (bSameQWord)
        {
            LONG  xCount;
            LONG  lDeltaDst;
            PBYTE pjDstEnd;

            xCount = RightAln - LeftAln;

            // sanity checks!
            if (xCount <= 0)
            {
                return;
            }

            lDeltaDst = (DeltaDstIn - xCount) * 2;

            pjDst     = pjDstIn + DstLeft * 2;
            pjDstEndY = pjDst + cy * DeltaDstIn * 2;
            pjSrc     = pjSrcIn + (SrcLeft >> 3);

            // expand, one src byte is all that's required
            do
            {
                // load src and shift into place
                currentPels = *pjSrc;
                currentPels <<= LeftAln;
                pjDstEnd    = pjDst + xCount * 2;

                do
                {
                    if ((currentPels & 0x80) == 0)
                    {
                        *(UINT16 *)pjDst = (UINT16)bgCol;

                    }
                    else
                    {
                        *(UINT16 *)pjDst = (UINT16)fgCol;
                    }
                    pjDst += 2;
                    currentPels = (BYTE)(currentPels << 1);

                } while (pjDst != pjDstEnd);

                pjDst += lDeltaDst;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);

            return;
        }
        else
        {
            BYTE  currentPels;
            LONG  lDeltaDst = (DeltaDstIn - RightAln) * 2;
            PBYTE pjDstEnd;
            ULONG i;

            pjDst     = pjDstIn + (DstRight & ~0x07) * 2;
            pjDstEndY = pjDst + cy * DeltaDstIn * 2;
            pjSrc     = pjSrcIn + ((SrcLeft + (DstRight - DstLeft)) >> 3);

            do
            {
                // read src
                currentPels = *pjSrc;

                if (currentPels != 0)
                {
                    pjDstEnd = pjDst + RightAln * 2;
                    do
                    {
                        if ((currentPels & 0x80) == 0)
                        {
                            *(UINT16 *)pjDst = (UINT16)bgCol;

                        }
                        else
                        {
                            *(UINT16 *)pjDst = (UINT16)fgCol;
                        }
                        pjDst += 2;
                        currentPels = (BYTE)(currentPels << 1);

                    } while (pjDst != pjDstEnd);
                }
                else
                {
                    // short cut for zero
                    for (i = 0; i < RightAln ; i++)
                    {
                        *(UINT16 *)pjDst = (UINT16)bgCol;
                        pjDst += 2;
                    }
                }

                pjDst += lDeltaDst;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);
        }
    }

    DC_END_FN();
}
#endif // HICOLOR

/******************************Public*Routine******************************\
*   vSrcOpaqCopyS1D8
*
*   Opaque blt of 1BPP src to destination format
*
* Arguments:
*    pjSrcIn    - pointer to beginning of current scan line of src buffer
*    SrcLeft    - left (starting) pixel in src rectangle
*    DeltaSrcIn - bytes from one src scan line to next
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer
*    DstLeft    - left(first) dst pixel
*    DstRight   - right(last) dst pixel
*    DeltaDstIn - bytes from one Dst scan line to next
*    cy         - number of scan lines
*    uF         - Foreground color
*    uB         - Background color
\**************************************************************************/
VOID CGH::vSrcOpaqCopyS1D8(
        PBYTE   pjSrcIn,
        LONG    SrcLeft,
        LONG    DeltaSrcIn,
        PBYTE   pjDstIn,
        LONG    DstLeft,
        LONG    DstRight,
        LONG    DeltaDstIn,
        LONG    cy,
        ULONG   uF,
        ULONG   uB)
{
    // Aligned portion
    ULONG LeftAln    = ((DstLeft + 7) & ~0x07);
    ULONG RightAln   = ((DstRight)    & ~0x07);

    ULONG EndOffset  = RightAln - LeftAln;
    ULONG EndOffset4 = EndOffset & ~0x0F;
    ULONG EndOffset8 = EndOffset & ~0x1F;
    LONG  DeltaDst;
    LONG  DeltaSrc;
    PBYTE pjDstEndY;
    PBYTE pjSrc;
    PBYTE pjDst;
    ULONG TextExpTable[16];

    // Generate text expasion table
    ULONG  Accum = uB;

    Accum = Accum | (Accum << 8);
    Accum = Accum | (Accum << 16);
    TextExpTable[0] = Accum;            // 0 0 0 0
    Accum <<= 8;
    Accum |=  uF;
    TextExpTable[8] = Accum;            // 0 0 0 1
    Accum <<= 8;
    Accum |=  uB;
    TextExpTable[4] = Accum;            // 0 0 1 0
    Accum <<= 8;
    Accum |=  uF;
    TextExpTable[10] = Accum;            // 0 1 0 1
    Accum <<= 8;
    Accum |=  uB;
    TextExpTable[5] = Accum;           // 1 0 1 0
    Accum <<= 8;
    Accum |=  uB;
    TextExpTable[ 2] = Accum;           // 0 1 0 0
    Accum <<= 8;
    Accum |=  uF;
    TextExpTable[ 9] = Accum;           // 1 0 0 1
    Accum <<= 8;
    Accum |=  uF;
    TextExpTable[12] = Accum;           // 0 0 1 1
    Accum <<= 8;
    Accum |=  uF;
    TextExpTable[14] = Accum;           // 0 1 1 1
    Accum <<= 8;
    Accum |=  uF;
    TextExpTable[15] = Accum;           // 1 1 1 1
    Accum <<= 8;
    Accum |=  uB;
    TextExpTable[ 7] = Accum;           // 1 1 1 0
    Accum <<= 8;
    Accum |=  uF;
    TextExpTable[11] = Accum;           // 1 1 0 1
    Accum <<= 8;
    Accum |=  uF;
    TextExpTable[13] = Accum;           // 1 0 1 1
    Accum <<= 8;
    Accum |=  uB;
    TextExpTable[06] = Accum;           // 0 1 1 0
    Accum <<= 8;
    Accum |=  uB;
    TextExpTable[ 3] = Accum;           // 1 1 0 0
    Accum <<= 8;
    Accum |=  uB;
    TextExpTable[ 1] = Accum;           // 1 0 0 0

    // calc addresses and strides
    pjDst     = pjDstIn + LeftAln;
    pjDstEndY = pjDst + cy * DeltaDstIn;
    pjSrc     = pjSrcIn + ((SrcLeft+7) >> 3);

    DeltaSrc  = DeltaSrcIn - (EndOffset >> 3);
    DeltaDst  = DeltaDstIn - EndOffset;

    // make sure at least 1 QWORD needs copied
    if (RightAln > LeftAln) {
        // expand buffer
        do {
            PBYTE pjDstEnd  = pjDst + EndOffset;
            PBYTE pjDstEnd4 = pjDst + EndOffset4;
            PBYTE pjDstEnd8 = pjDst + EndOffset8;

            // 4 times unrolled
            while (pjDst != pjDstEnd8) {
                BYTE c0 = *(pjSrc + 0);
                BYTE c1 = *(pjSrc + 1);
                BYTE c2 = *(pjSrc + 2);
                BYTE c3 = *(pjSrc + 3);

                *(PULONG)(pjDst + 0) = TextExpTable[c0  >>  4];
                *(PULONG)(pjDst + 4) = TextExpTable[c0 & 0x0F];

                *(PULONG)(pjDst + 8) = TextExpTable[c1  >>  4];
                *(PULONG)(pjDst +12) = TextExpTable[c1 & 0x0F];

                *(PULONG)(pjDst +16) = TextExpTable[c2  >>  4];
                *(PULONG)(pjDst +20) = TextExpTable[c2 & 0x0F];

                *(PULONG)(pjDst +24) = TextExpTable[c3  >>  4];
                *(PULONG)(pjDst +28) = TextExpTable[c3 & 0x0F];

                pjSrc += 4;
                pjDst += 32;
            }

            // 2 times unrolled
            while (pjDst != pjDstEnd4) {
                BYTE c0 = *(pjSrc + 0);
                BYTE c1 = *(pjSrc + 1);

                *(PULONG)(pjDst + 0) = TextExpTable[c0  >>  4];
                *(PULONG)(pjDst + 4) = TextExpTable[c0 & 0x0F];

                *(PULONG)(pjDst + 8) = TextExpTable[c1  >>  4];
                *(PULONG)(pjDst +12) = TextExpTable[c1 & 0x0F];

                pjSrc += 2;
                pjDst += 16;
            }

            // 1 byte expansion loop
            while (pjDst != pjDstEnd) {
                BYTE c0 = *(pjSrc + 0);

                *(PULONG)(pjDst + 0) = TextExpTable[c0  >>  4];
                *(PULONG)(pjDst + 4) = TextExpTable[c0 & 0x0F];

                pjSrc++;
                pjDst += 8;
            }

            pjDst += DeltaDst;
            pjSrc += DeltaSrc;
        } while (pjDst != pjDstEndY);
    }

    //
    // Starting alignment case: at most 1 src byte is required.
    // Start and end may occur in same Quadword.
    //
    //
    // Left                  Right
    //    0 1 2 34 5 6 7       0 1 2 34 5 6 7
    //   Ŀ     ĺĿ
    // 1  xxxxxxx   1 x       
    //   ĺĴ     ĺĴ
    // 2   xxxxxx   2 xx      
    //   ĺĴ     ĺĴ
    // 3    xxxxx   3 xxx     
    //   ĺĴ     ĺĴ
    // 4     xxxx   4 xxxx    
    //   ĺĴ     ĺĴ
    // 5      xxx   5 xxxxx   
    //   ĺĴ     ĺĴ
    // 6       xx   6 xxxxxx  
    //   ĺĴ     ĺĴ
    // 7        x   7 xxxxxxx 
    //        ĺ
    //

    LeftAln  = DstLeft & 0x07;
    RightAln = DstRight & 0x07;

    if (LeftAln) {
        BYTE  jSrc;
        BOOL  bSameQWord     = ((DstLeft) & ~0x07) ==  ((DstRight) & ~0x07);
        ULONG ul0,ul1;

        // if left and right edges are in same qword handle with masked
        // read-modify-write
        if (bSameQWord) {
            ULONG Mask0,Mask1;

            Mask0     = gTextLeftMask[LeftAln][0] & gTextRightMask[RightAln][0];
            Mask1     = gTextLeftMask[LeftAln][1] & gTextRightMask[RightAln][1];

            pjDst     = pjDstIn + (DstLeft & ~0x07);
            pjDstEndY = pjDst + cy * DeltaDstIn;
            pjSrc     = pjSrcIn + (SrcLeft >> 3);

            // expand
            do {
                jSrc = *pjSrc;

                ul0 = TextExpTable[jSrc  >>  4];
                ul1 = TextExpTable[jSrc & 0x0F];

                *(PULONG)(pjDst)   = (*(PULONG)(pjDst)   & ~Mask0) | (ul0 & Mask0);
                *(PULONG)(pjDst+4) = (*(PULONG)(pjDst+4) & ~Mask1) | (ul1 & Mask1);

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;
            } while (pjDst != pjDstEndY);

            return;
        }

        // Left edge only, handle with special write-only loops
        pjDst     = pjDstIn + (DstLeft & ~0x07);
        pjDstEndY = pjDst + cy * DeltaDstIn;
        pjSrc     = pjSrcIn + (SrcLeft >> 3);
        switch (LeftAln) {
        case 1:
            do {
                jSrc = *pjSrc;
                ul0 = TextExpTable[jSrc  >>  4];
                ul1 = TextExpTable[jSrc & 0x0F];
                *(pjDst+1)            = (BYTE)(ul0 >> 8);
                *((PUSHORT)(pjDst+2)) = (USHORT)(ul0 >> 16);
                *((PULONG)(pjDst+4))  = ul1;

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;
            } while (pjDst != pjDstEndY);
            break;

        case 2:
            do {
                jSrc = *pjSrc;
                ul0 = TextExpTable[jSrc  >>  4];
                ul1 = TextExpTable[jSrc & 0x0F];
                *((PUSHORT)(pjDst+2)) = (USHORT)(ul0 >> 16);
                *((PULONG)(pjDst+4))  = ul1;

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;
            } while (pjDst != pjDstEndY);
            break;

        case 3:
            do {
                jSrc = *pjSrc;
                ul0 = TextExpTable[jSrc  >>  4];
                ul1 = TextExpTable[jSrc & 0x0F];
                *(pjDst+3)            = (BYTE)(ul0 >> 24);
                *((PULONG)(pjDst+4))  = ul1;

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;
            } while (pjDst != pjDstEndY);
            break;

        case 4:
            do {
                jSrc = *pjSrc;
                ul1 = TextExpTable[jSrc & 0x0F];
                *((PULONG)(pjDst+4))  = ul1;

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;
            } while (pjDst != pjDstEndY);
            break;

        case 5:
            do {
                jSrc = *pjSrc;
                ul1 = TextExpTable[jSrc & 0x0F];
                *(pjDst+5)            = (BYTE)(ul1 >> 8);
                *((PUSHORT)(pjDst+6)) = (USHORT)(ul1 >> 16);

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;
            } while (pjDst != pjDstEndY);
            break;

        case 6:
            do {
                jSrc = *pjSrc;
                ul1 = TextExpTable[jSrc & 0x0F];
                *((PUSHORT)(pjDst+6)) = (USHORT)(ul1 >> 16);

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;
            } while (pjDst != pjDstEndY);
            break;

        case 7:
            do {
                jSrc = *pjSrc;
                ul1 = TextExpTable[jSrc & 0x0F];
                *(pjDst+7) = (BYTE)(ul1 >> 24);

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;
            } while (pjDst != pjDstEndY);
            break;
        }
    }

    // handle right edge only, use special write-only loops for each case
    if (RightAln) {
        ULONG ul0,ul1;
        BYTE  jSrc;

        pjDst     = pjDstIn + (DstRight & ~0x07);
        pjDstEndY = pjDst + cy * DeltaDstIn;
        pjSrc     = pjSrcIn + ((SrcLeft + (DstRight - DstLeft)) >> 3);

        // select right case
        switch (RightAln) {
        case 1:
            do {
                jSrc = *pjSrc;
                ul0 = TextExpTable[jSrc  >>  4];
                *(pjDst) = (BYTE)ul0;

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;
            } while (pjDst != pjDstEndY);
            break;

        case 2:
            do {
                jSrc = *pjSrc;
                ul0 = TextExpTable[jSrc  >>  4];
                *(PUSHORT)(pjDst) = (USHORT)ul0;

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;
            } while (pjDst != pjDstEndY);
            break;

        case 3:
            do {
                jSrc = *pjSrc;
                ul0 = TextExpTable[jSrc  >>  4];
                *(PUSHORT)(pjDst) = (USHORT)ul0;
                *(pjDst+2)        = (BYTE)(ul0 >> 16);

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;
            } while (pjDst != pjDstEndY);
            break;

        case 4:
            do {
                jSrc = *pjSrc;
                ul0 = TextExpTable[jSrc  >>  4];
                *(PULONG)(pjDst) = ul0;

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;
            } while (pjDst != pjDstEndY);
            break;

        case 5:
            do {
                jSrc = *pjSrc;
                ul0 = TextExpTable[jSrc  >>  4];
                ul1 = TextExpTable[jSrc & 0x0F];
                *(PULONG)(pjDst) = ul0;
                *(pjDst+4)       = (BYTE)ul1;

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;
            } while (pjDst != pjDstEndY);
            break;

        case 6:
            do {
                jSrc = *pjSrc;
                ul0 = TextExpTable[jSrc  >>  4];
                ul1 = TextExpTable[jSrc & 0x0F];
                *(PULONG)(pjDst)    = ul0;
                *(PUSHORT)(pjDst+4) = (USHORT)ul1;

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);
            break;

        case 7:
            do {
                jSrc = *pjSrc;
                ul0 = TextExpTable[jSrc  >>  4];
                ul1 = TextExpTable[jSrc & 0x0F];

                *(PULONG)(pjDst)    = ul0;
                *(PUSHORT)(pjDst+4) = (USHORT)ul1;
                *(pjDst+6)          = (BYTE)(ul1 >> 16);

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;
            } while (pjDst != pjDstEndY);
            break;
        }
    }
}

#ifdef DC_HICOLOR
/******************************Public*Routine******************************\
*   vSrcTranCopyS1D8_24
*
*   Transparent blt of 1BPP src to 24bpp destination
*   src bits that are "1" are copied to the dest as foreground color,
*   src bits that are "0" are not copied
*
* Arguments:
*    pjSrcIn    - pointer to beginning of current scan line of src buffer
*    SrcLeft    - left (starting) pixel in src rectangle
*    DeltaSrcIn - bytes from one src scan line to next
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer
*    DstLeft    - left(first) dst pixel
*    DstRight   - right(last) dst pixel
*    DeltaDstIn - bytes from one Dst scan line to next
*    cy         - number of scan lines
*    fgCol      - Foreground color
\**************************************************************************/
VOID CGH::vSrcTranCopyS1D8_24(
        PBYTE   pjSrcIn,
        LONG    SrcLeft,
        LONG    DeltaSrcIn,
        PBYTE   pjDstIn,
        LONG    DstLeft,
        LONG    DstRight,
        LONG    DeltaDstIn,
        LONG    cy,
        DCRGB   fgCol)
{
    // We access the 1bpp source a byte at a time, so we have to start accessing
    // the destination on a corresponding 8-pel aligned left edge
    ULONG LeftAln      = (DstLeft & ~0x07);
    ULONG LeftEdgeMask = 0xFF >> (DstLeft & 0x07);
    ULONG RightAln     = (DstRight & ~0x07);
    ULONG AlnDelta     = RightAln - LeftAln;

    LONG  DeltaDst;
    LONG  DeltaSrc;

    PBYTE pjDstEndY;
    PBYTE pjSrc;
    PBYTE pjDst;

    DC_BEGIN_FN("vSrcTranCopyS1D8_24");

    // calculate the pel-aligned pointers and row deltas
    pjDst     = pjDstIn + LeftAln * 3;
    pjDstEndY = pjDst + cy * DeltaDstIn * 3;

    pjSrc     = pjSrcIn + (SrcLeft >> 3);

    DeltaSrc  = DeltaSrcIn - (AlnDelta >> 3);
    DeltaDst  = (DeltaDstIn - AlnDelta) * 3;

    // make sure at least 1 QWORD needs copying
    if (RightAln != LeftAln)
    {

        // for each row...
        do
        {
            PBYTE pjDstEnd = pjDst + AlnDelta * 3;

            // Mask off the left edge
            BYTE currentPels = (BYTE)(*pjSrc & (BYTE)(LeftEdgeMask));

            if (currentPels != 0)
            {
                int i;

                for (i = 0; i < 8 ; i++)
                {
                    if ((currentPels & 0x80) == 0)
                    {
                        pjDst += 3;
                    }
                    else
                    {
                        *pjDst++ = fgCol.blue;
                        *pjDst++ = fgCol.green;
                        *pjDst++ = fgCol.red;
                    }
                    currentPels = (BYTE)(currentPels << 1);
                }
            }
            else
            {
                pjDst += 24;
            }

            pjSrc ++;

            // now do the rest of the row
            while (pjDst != pjDstEnd)
            {
                currentPels = *pjSrc;
                if (currentPels != 0)
                {
                    int i;

                    for (i = 0; i < 8 ; i++)
                    {
                        if ((currentPels & 0x80) == 0)
                        {
                            pjDst += 3;
                        }
                        else
                        {
                            *pjDst++ = fgCol.blue;
                            *pjDst++ = fgCol.green;
                            *pjDst++ = fgCol.red;
                        }
                        currentPels = (BYTE)(currentPels << 1);
                    }
                }
                else
                {
                    pjDst += 24;
                }

                pjSrc++;
            }

            pjDst += DeltaDst;
            pjSrc += DeltaSrc;

        } while (pjDst != pjDstEndY);
    }

    // Now fill in the right edge
    RightAln = DstRight & 0x07;
    if (RightAln)
    {
        BYTE  currentPels;
        BOOL  bSameQWord = ((DstLeft) & ~0x07) ==  ((DstRight) & ~0x07);

        LeftAln = DstLeft & 0x07;

        // if left and right edges are in same qword handle with masked
        // read-modify-write
        if (bSameQWord)
        {
            LONG  xCount;
            LONG  lDeltaDst;
            PBYTE pjDstEnd;

            xCount = RightAln - LeftAln;

            // sanity checks!
            if (xCount <= 0)
            {
                return;
            }

            lDeltaDst = (DeltaDstIn - xCount) * 3;

            pjDst     = pjDstIn + DstLeft * 3;
            pjDstEndY = pjDst + cy * DeltaDstIn * 3;
            pjSrc     = pjSrcIn + (SrcLeft >> 3);

            // expand, one src byte is all that's required
            do
            {
                // load src and shift into place
                currentPels = *pjSrc;
                currentPels <<= LeftAln;
                pjDstEnd    = pjDst + xCount * 3;

                do
                {
                    if ((currentPels & 0x80) == 0)
                    {
                        pjDst += 3;
                    }
                    else
                    {
                        *pjDst++ = fgCol.blue;
                        *pjDst++ = fgCol.green;
                        *pjDst++ = fgCol.red;
                    }

                    currentPels = (BYTE)(currentPels << 1);

                } while (pjDst != pjDstEnd);

                pjDst += lDeltaDst;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);

            return;
        }
        else
        {
            BYTE  currentPels;
            LONG  lDeltaDst = (DeltaDstIn - RightAln) * 3;
            PBYTE pjDstEnd;

            pjDst     = pjDstIn + (DstRight & ~0x07) * 3;
            pjDstEndY = pjDst + cy * DeltaDstIn * 3;
            pjSrc     = pjSrcIn + ((SrcLeft + (DstRight - DstLeft)) >> 3);

            do
            {
                // read src
                currentPels = *pjSrc;

                if (currentPels != 0)
                {
                    pjDstEnd = pjDst + RightAln * 3;
                    do
                    {
                        if ((currentPels & 0x80) == 0)
                        {
                            pjDst += 3;
                        }
                        else
                        {
                            *pjDst++ = fgCol.blue;
                            *pjDst++ = fgCol.green;
                            *pjDst++ = fgCol.red;
                        }
                        currentPels = (BYTE)(currentPels << 1);

                    } while (pjDst != pjDstEnd);
                }
                else
                {
                    // short cut for zero
                    pjDst += RightAln * 3;
                }

                pjDst += lDeltaDst;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);
        }
    }

    DC_END_FN();
}


/******************************Public*Routine******************************\
*   vSrcTranCopyS1D8_16
*
*   Transparent blt of 1BPP src to 16bpp destination
*   src bits that are "1" are copied to the dest as foreground color,
*   src bits that are "0" are not copied
*
* Arguments:
*    pjSrcIn    - pointer to beginning of current scan line of src buffer
*    SrcLeft    - left (starting) pixel in src rectangle
*    DeltaSrcIn - bytes from one src scan line to next
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer
*    DstLeft    - left(first) dst pixel
*    DstRight   - right(last) dst pixel
*    DeltaDstIn - bytes from one Dst scan line to next
*    cy         - number of scan lines
*    fgCol      - Foreground color
\**************************************************************************/
VOID CGH::vSrcTranCopyS1D8_16(
        PBYTE   pjSrcIn,
        LONG    SrcLeft,
        LONG    DeltaSrcIn,
        PBYTE   pjDstIn,
        LONG    DstLeft,
        LONG    DstRight,
        LONG    DeltaDstIn,
        LONG    cy,
        ULONG   fgCol)
{
    // We access the 1bpp source a byte at a time, so we have to start accessing
    // the destination on a corresponding 8-pel aligned left edge
    ULONG LeftAln      = (DstLeft & ~0x07);
    ULONG LeftEdgeMask = 0xFF >> (DstLeft & 0x07);
    ULONG RightAln     = (DstRight & ~0x07);
    ULONG AlnDelta     = RightAln - LeftAln;

    LONG  DeltaDst;
    LONG  DeltaSrc;

    PBYTE pjDstEndY;
    PBYTE pjSrc;
    PBYTE pjDst;

    DC_BEGIN_FN("vSrcTranCopyS1D8_16");

    // calculate the pel-aligned pointers and row deltas
    pjDst     = pjDstIn + LeftAln * 2;
    pjDstEndY = pjDst + cy * DeltaDstIn * 2;

    pjSrc     = pjSrcIn + (SrcLeft >> 3);

    DeltaSrc  = DeltaSrcIn - (AlnDelta >> 3);
    DeltaDst  = (DeltaDstIn - AlnDelta) * 2;

    // make sure at least 1 QWORD needs copying
    if (RightAln != LeftAln)
    {

        // for each row...
        do
        {
            PBYTE pjDstEnd = pjDst + AlnDelta * 2;

            // Mask off the left edge
            BYTE currentPels = (BYTE)(*pjSrc & (BYTE)(LeftEdgeMask));

            if (currentPels != 0)
            {
                int i;

                for (i = 0; i < 8 ; i++)
                {
                    if (currentPels & 0x80)
                    {
                        *(UINT16 *)pjDst = (UINT16)fgCol;
                    }
                    pjDst += 2;
                    currentPels = (BYTE)(currentPels << 1);
                }
            }
            else
            {
                pjDst += 16;
            }

            pjSrc ++;

            // now do the rest of the row
            while (pjDst != pjDstEnd)
            {
                currentPels = *pjSrc;
                if (currentPels != 0)
                {
                    int i;

                    for (i = 0; i < 8 ; i++)
                    {
                        if (currentPels & 0x80)
                        {
                            *(UINT16 *)pjDst = (UINT16)fgCol;
                        }
                        pjDst += 2;
                        currentPels = (BYTE)(currentPels << 1);
                    }
                }
                else
                {
                    pjDst += 16;
                }

                pjSrc++;
            }

            pjDst += DeltaDst;
            pjSrc += DeltaSrc;

        } while (pjDst != pjDstEndY);
    }

    // Now fill in the right edge
    RightAln = DstRight & 0x07;
    if (RightAln)
    {
        BYTE  currentPels;
        BOOL  bSameQWord = ((DstLeft) & ~0x07) ==  ((DstRight) & ~0x07);

        LeftAln = DstLeft & 0x07;

        // if left and right edges are in same qword handle with masked
        // read-modify-write
        if (bSameQWord)
        {
            LONG  xCount;
            LONG  lDeltaDst;
            PBYTE pjDstEnd;

            xCount = RightAln - LeftAln;

            // sanity checks!
            if (xCount <= 0)
            {
                return;
            }

            lDeltaDst = (DeltaDstIn - xCount) * 2;

            pjDst     = pjDstIn + DstLeft * 2;
            pjDstEndY = pjDst + cy * DeltaDstIn * 2;
            pjSrc     = pjSrcIn + (SrcLeft >> 3);

            // expand, one src byte is all that's required
            do
            {
                // load src and shift into place
                currentPels = *pjSrc;
                currentPels <<= LeftAln;
                pjDstEnd    = pjDst + xCount * 2;

                do
                {
                    if (currentPels & 0x80)
                    {
                        *(UINT16 *)pjDst = (UINT16)fgCol;
                    }
                    pjDst += 2;

                    currentPels = (BYTE)(currentPels << 1);

                } while (pjDst != pjDstEnd);

                pjDst += lDeltaDst;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);

            return;
        }
        else
        {
            BYTE  currentPels;
            LONG  lDeltaDst = (DeltaDstIn - RightAln) * 2;
            PBYTE pjDstEnd;

            pjDst     = pjDstIn + (DstRight & ~0x07) * 2;
            pjDstEndY = pjDst + cy * DeltaDstIn * 2;
            pjSrc     = pjSrcIn + ((SrcLeft + (DstRight - DstLeft)) >> 3);

            do
            {
                // read src
                currentPels = *pjSrc;

                if (currentPels != 0)
                {
                    pjDstEnd = pjDst + RightAln * 2;
                    do
                    {
                        if (currentPels & 0x80)
                        {
                            *(UINT16 *)pjDst = (UINT16)fgCol;
                        }
                        pjDst += 2;
                        currentPels = (BYTE)(currentPels << 1);

                    } while (pjDst != pjDstEnd);
                }
                else
                {
                    // short cut for zero
                    pjDst += RightAln * 2;
                }

                pjDst += lDeltaDst;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);
        }
    }

    DC_END_FN();
}
#endif // DC_HICOLOR

/******************************Public*Routine******************************\
*   vSrcTranCopyS1D8
*
#ifdef DC_HICOLOR
*   Transparent blt of 1BPP src to 8bpp destination
#else
*   Transparent blt of 1BPP src to all destination format
#endif
*   src bits that are "1" are copied to the dest as foreground color,
*   src bits that are "0" are not copied
*
* Arguments:
*    pjSrcIn    - pointer to beginning of current scan line of src buffer
*    SrcLeft    - left (starting) pixel in src rectangle
*    DeltaSrcIn - bytes from one src scan line to next
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer
*    DstLeft    - left(first) dst pixel
*    DstRight   - right(last) dst pixel
*    DeltaDstIn - bytes from one Dst scan line to next
*    cy         - number of scan lines
*    uF         - Foreground color
*    uB         - Background color
\**************************************************************************/
VOID CGH::vSrcTranCopyS1D8(
        PBYTE   pjSrcIn,
        LONG    SrcLeft,
        LONG    DeltaSrcIn,
        PBYTE   pjDstIn,
        LONG    DstLeft,
        LONG    DstRight,
        LONG    DeltaDstIn,
        LONG    cy,
        ULONG   uF,
        ULONG   uB)
{
    // start at 8-byte aligned left edge
    ULONG uExpand      = uF | (uF << 8);
    ULONG LeftAln      = (DstLeft   & ~0x07);
    ULONG LeftEdgeMask = 0xFF >> (DstLeft & 0x07);
    ULONG RightAln     = (DstRight  & ~0x07);
    ULONG EndOffset    = RightAln - LeftAln;
    LONG  DeltaDst;
    LONG  DeltaSrc;
    PBYTE pjDstEndY;
    PBYTE pjSrc;
    PBYTE pjDst;

    DC_IGNORE_PARAMETER(uB);

    uExpand = uExpand | (uExpand << 16);

    // calc addresses and strides
    pjDst     = pjDstIn + LeftAln;
    pjDstEndY = pjDst + cy * DeltaDstIn;
    pjSrc     = pjSrcIn + (SrcLeft >> 3);

    DeltaSrc  = DeltaSrcIn - (EndOffset >> 3);
    DeltaDst  = DeltaDstIn - EndOffset;

    // make sure at least 1 QWORD needs copied
    if (RightAln != LeftAln) {
        do {
            PBYTE pjDstEnd   = pjDst + EndOffset;

            // and first src byte to cover left edge
            BYTE c0 = (BYTE)(*pjSrc & (BYTE)(LeftEdgeMask));

            if (c0 != 0) {
                ULONG MaskLow = TranTable[c0 >> 4];
                ULONG MaskHi  = TranTable[c0 & 0x0F];
                ULONG d0      = *(PULONG)pjDst;
                ULONG d1      = *(PULONG)(pjDst + 4);

                d0 = (d0 & ~MaskLow) | (uExpand & MaskLow);
                d1 = (d1 & ~MaskHi)  | (uExpand & MaskHi);

                *(PULONG)pjDst       = d0;
                *(PULONG)(pjDst + 4) = d1;
            }

            pjSrc ++;
            pjDst += 8;

            while (pjDst != pjDstEnd) {
                c0 = *pjSrc;

                if (c0 != 0) {
                    ULONG MaskLow = TranTable[c0 >> 4];
                    ULONG MaskHi  = TranTable[c0 & 0x0F];
                    ULONG d0      = *(PULONG)pjDst;
                    ULONG d1      = *(PULONG)(pjDst + 4);

                    d0 = (d0 & ~MaskLow) | (uExpand & MaskLow);
                    d1 = (d1 & ~MaskHi)  | (uExpand & MaskHi);

                    *(PULONG)pjDst       = d0;
                    *(PULONG)(pjDst + 4) = d1;
                }

                pjSrc ++;
                pjDst += 8;
            }

            pjDst += DeltaDst;
            pjSrc += DeltaSrc;
        } while (pjDst != pjDstEndY);
    }

    RightAln = DstRight & 0x07;
    if (RightAln) {
        BYTE  jSrc;
        BOOL  bSameQWord     = ((DstLeft) & ~0x07) ==  ((DstRight) & ~0x07);

        // if left and right edges are in same qword handle with masked
        // read-modify-write
        if (bSameQWord) {
            LONG  xCount;
            LONG  lDeltaDst;
            PBYTE pjDstEnd;

            LeftAln = DstLeft & 0x07;
            xCount = RightAln - LeftAln;

            // assert ic xCount < 0
            if (xCount <= 0)
                return;

            lDeltaDst = DeltaDstIn - xCount;

            pjDst     = pjDstIn + DstLeft;
            pjDstEndY = pjDst + cy * DeltaDstIn;
            pjSrc     = pjSrcIn + (SrcLeft >> 3);

            // expand, one src byte is all that's required
            do {
                // load src and shift into place
                jSrc = *pjSrc;
                jSrc <<= LeftAln;

                pjDstEnd  = pjDst + xCount;

                do {
                    if (jSrc & 0x80)
                        *pjDst = (BYTE)uF;
                    jSrc <<=1;
                    pjDst++;
                } while (pjDst != pjDstEnd);

                pjDst += lDeltaDst;
                pjSrc += DeltaSrcIn;
            } while (pjDst != pjDstEndY);

            return;
        } else {
            BYTE  jSrc;
            LONG  lDeltaDst = DeltaDstIn - RightAln;
            PBYTE pjDstEnd;

            pjDst               = pjDstIn + (DstRight & ~0x07);
            pjDstEndY           = pjDst + cy * DeltaDstIn;
            pjSrc               = pjSrcIn + ((SrcLeft + (DstRight - DstLeft)) >> 3);

            do {
                // read src
                jSrc = *pjSrc;

                if (jSrc != 0) {
                    pjDstEnd = pjDst + RightAln;
                    do {
                        if (jSrc & 0x80)
                            *pjDst = (BYTE)uF;
                        jSrc <<=1;
                        pjDst++;
                    } while (pjDst != pjDstEnd);
                } else {
                    // short cut for zero
                    pjDst += RightAln;
                }

                pjDst += lDeltaDst;
                pjSrc += DeltaSrcIn;
            } while (pjDst != pjDstEndY);
        }
    }
}

#endif // defined(OS_WINCE) || defined(OS_WINNT)

/****************************************************************************/
/* Name:      CalculateGlyphClipRect                                        */
/*                                                                          */
/*   This function is used to determine if the glyph bits should be clipped */
/*   using the clip rect passed in the order.                               */
/*                                                                          */
/*   It returns one of the values bellow:                                   */
/*   GLYPH_CLIP_NONE-The glyph will fit in the clip rect.No clipping needed */
/*   GLYPH_CLIP_PARTIAL-The glyph is clipped by the clip rect               */
/*   GLYPH_CLIP_ALL - The glyph is completly clipped.                       */
/*                                                                          */
/*                                                                          */
/* Params:  pGlyphRectClipOffset - OUT - it receives the clip offsets       */          
/*          pOrder               - Pointer to the order                     */
/*          pHdr                 - Pointer to the glyph header              */
/*          x,y                  - The coord where the glyph will be drawn  */
/****************************************************************************/
inline DCUINT CalculateGlyphClipRect( PRECTCLIPOFFSET    pGlyphRectClipOffset,
                                      LPINDEX_ORDER          pOrder, 
                                      HPUHGLYPHCACHEENTRYHDR pHdr,
                                      DCINT                  x,
                                      DCINT                  y)
{
    RECT rcGlyph;

    DC_BEGIN_FN("CalculateGlyphClipRect");
    
    //    Here we calculate how the glyph bits will map in the clip rect.
    rcGlyph.left = x + pHdr->x;
    rcGlyph.top  = y + pHdr->y;
    rcGlyph.right = rcGlyph.left + pHdr->cx;
    rcGlyph.bottom = rcGlyph.top + pHdr->cy;

    //    Check if the clip rect clips the glyph rect all the way
    if ((rcGlyph.left >= pOrder->BkRight) ||
        (rcGlyph.right <= pOrder->BkLeft) ||
        (rcGlyph.top >= pOrder->BkBottom) || 
        (rcGlyph.bottom <= pOrder->BkTop)) {
        
        return GLYPH_CLIP_ALL;
    }

    pGlyphRectClipOffset->left   = pOrder->BkLeft - rcGlyph.left;
    pGlyphRectClipOffset->top    = pOrder->BkTop - rcGlyph.top;
    pGlyphRectClipOffset->right  = rcGlyph.right - pOrder->BkRight;
    pGlyphRectClipOffset->bottom = rcGlyph.bottom - pOrder->BkBottom;
    
    if ((pGlyphRectClipOffset->left > 0) ||
        (pGlyphRectClipOffset->top > 0) ||
        (pGlyphRectClipOffset->right > 0) ||
        (pGlyphRectClipOffset->bottom > 0)) {

        return GLYPH_CLIP_PARTIAL;
    };
    
    DC_END_FN();
    return GLYPH_CLIP_NONE;
}
                                     
/****************************************************************************/
/* Name:      ClipGlyphBits                                                 */
/*                                                                          */
/*   This function will clip the glyph bits according to the clipping rect. */
/*   It will actually generate a new glyph that would fit inside the        */
/*   clip rect.                                                             */
/*                                                                          */
/* Params:  inst                 - pointer to a CGH instance                */          
/*          pGlyphRectClipOffset - Pointer to the glyph clip offset struct  */
/*                                 filled in by CalculateGlyphClipRect      */
/*          pHdr                 - Pointer to the glyph header. This will   */
/*                                 be modified accordingly                  */
/*          ppData (IN/OUT)      - Pointer to the start of the glyph bits   */
/*          ppEndData (IN/OUT)   - Pointer to the end of the glyph bits     */
/****************************************************************************/
inline HRESULT ClipGlyphBits(CGH*                   inst,
                             PRECTCLIPOFFSET        pGlyphRectClipOffset, 
                             HPUHGLYPHCACHEENTRYHDR pHdr,
                             PPDCUINT8              ppData, 
                             PPDCUINT8              ppEndData)
{
    HRESULT hr = S_OK;
    PDCUINT8    pNewData, pNewDataEnd;
    DCUINT      ScanLineSize, NewScanLineSize;
    DCUINT      LastByteIndex;
    DCUINT8     LastByteMask;
    DCUINT16    wTmp;
    DCUINT8     clipRightMask, clipLeftBits, clipRightBits;
    DCUINT      clipLeftBytes;
    DCUINT      i,j;
    PDCUINT8    pSrcScanLineStart, pDstScanLineStart, pTmpData, pEndTmpData;

    DC_BEGIN_FN("ClipGlyphBits");

    ScanLineSize = (pHdr->cx+7) / 8; 

    //    If we have to clip from the top we just decrease the 
    //    number of scanlines in the glyph and advance the start
    //    pointer for the glyph bitmap.
 
    if (pGlyphRectClipOffset->top > 0) {
        //    When we clip the top of the glypy we will modify the actual origin
        //    of the glyph so we have to adjust the vector.
        pHdr->y  += pGlyphRectClipOffset->top;
        //    We decrease the height of the glyph
        pHdr->cy -= pGlyphRectClipOffset->top;
        //    We move the start pointer 
        pNewData = *ppData + ScanLineSize * (pGlyphRectClipOffset->top);
    } else {
        pNewData = *ppData;
    }

    //    If we have to clip the bootom we just decrease the number
    //    of lines in the glyph and we adjust the end pointer.
    if (pGlyphRectClipOffset->bottom > 0) {
        pHdr->cy -= pGlyphRectClipOffset->bottom;
        pNewDataEnd = pNewData + ScanLineSize * pHdr->cy;
    } else {
        pNewDataEnd = *ppEndData;
    }

    // Check that the new pointers are still inside the src buffer.
    TRC_ASSERT(((pNewData >=*ppData) && (pNewDataEnd <= *ppEndData)),
               (TB, _T("Error recalculating the glyph src buffer")));

    //    In case we clipped only top/bottom we don't have to do any copy
    //    operation because the scanline start and the scanlise size remains
    //    the same. We just adjust pointers. In case we have to clip from the
    //    width we have to generate a new glyph and return its start address 
    //    in ppData. In case we clip to the left we have to rotate some bits. 
    //    in case we clip to the right we have to mask some bits.
    
    clipRightMask = 0xff;

    if ((pGlyphRectClipOffset->right > 0) || 
        (pGlyphRectClipOffset->left > 0)) {
        
        if (pGlyphRectClipOffset->right > 0) { 
            //    Calculate how many bits are we gonna clip to the right
            clipRightBits = (DCUINT8)(pGlyphRectClipOffset->right & 7);
            //    Then adjust the with of the glyph
            pHdr->cx -= pGlyphRectClipOffset->right;
        } else {
            clipRightBits = 0;
        }

        if (pGlyphRectClipOffset->left > 0) {
            //    Calculate how many bytes we clip to the left. These are bytes
            //    we just won't copy. Then calculate how many bits are left to
            //    clip after we clip the bytes. This will tell us how much we 
            //    have to rotate.
            clipLeftBytes = pGlyphRectClipOffset->left / 8;
            clipLeftBits = (DCUINT8)(pGlyphRectClipOffset->left & 7);
            //    Adjust the glyph width
            pHdr->cx -= pGlyphRectClipOffset->left;
            //    Adjust the origin pointer. Clipping to the right actually
            //    modifies the origin.
            pHdr->x  += pGlyphRectClipOffset->left;
        } else {
            clipLeftBytes = 0;
            clipLeftBits = 0;
        }    

        //
        //    We check if we have to keep some bits at the end of the
        //    scanline. We update the mask...
        if ((pHdr->cx+clipLeftBits) & 7) {
            clipRightMask <<= ( 8 - ((pHdr->cx + clipLeftBits) & 7) );
        }

        NewScanLineSize = (pHdr->cx+7) / 8;

        //    This buffer is maintained by CGH. We don't have to free it.
        pTmpData = inst->GetGlyphClipBuffer(NewScanLineSize * pHdr->cy);
        if (pTmpData == NULL) {
            hr = E_OUTOFMEMORY;
            DC_QUIT;
        }
        
        pEndTmpData = pTmpData + NewScanLineSize * pHdr->cy;
        
        pSrcScanLineStart = pNewData + clipLeftBytes;
        pDstScanLineStart = pTmpData;

        if (clipLeftBits == 0) {
            //    In case we don't clip to the left we don't have to rotate so
            //    things go faster.
            for (i=0; i < pHdr->cy; i++) {
                memcpy(pDstScanLineStart, pSrcScanLineStart, NewScanLineSize);
                pDstScanLineStart[NewScanLineSize-1] &= clipRightMask;

                pSrcScanLineStart += ScanLineSize;
                pDstScanLineStart += NewScanLineSize;
            }
        } else {
            //    The transfer requires rotation
            //    We check to see if we need the last byte.        
            LastByteIndex = ((pHdr->cx + clipLeftBits + 7) / 8) - 1;

            //    LastByteIndex+1 is equal to the size of a scanline before  
            //    clipping the left bits. If this size is grater then NewScanLineSize
            //    it means that clipping to the left would shrink the buffer with 
            //    one byte and that some of the bits we need have to be transfered 
            //    from that last byte. 
            //    Note that LastByteIndex+1 can be grater then NewScanLineSize only 
            //    with 1 byte.

            //    this is the case where LastByteIndex+1 is grater then NewScanLineSize
            if ((LastByteIndex==NewScanLineSize)) {
                for (i=0; i < pHdr->cy; i++) {
                    TRC_ASSERT(((pSrcScanLineStart + NewScanLineSize - 1 < pNewDataEnd) &&
                                (pDstScanLineStart + NewScanLineSize - 1 < pEndTmpData)),
                                (TB, _T("Overflow transfering glyph bits.")));

                    wTmp = (pSrcScanLineStart[LastByteIndex] & clipRightMask) <<
                                                                   clipLeftBits;

                    for (j=NewScanLineSize; j>0; j--) {
                        pDstScanLineStart[j-1] = HIBYTE(wTmp); 
                        wTmp = pSrcScanLineStart[j-1] << clipLeftBits;
                        pDstScanLineStart[j-1] |= LOBYTE(wTmp); 
                    }

                    pSrcScanLineStart += ScanLineSize;
                    pDstScanLineStart += NewScanLineSize;
                }
           }else {
                for (i=0; i < pHdr->cy; i++) {
                    TRC_ASSERT(((pSrcScanLineStart + NewScanLineSize - 1 < pNewDataEnd) &&
                                (pDstScanLineStart + NewScanLineSize - 1 < pEndTmpData)),
                                (TB, _T("Overflow transfering glyph bits.")));
                    
                    wTmp = (pSrcScanLineStart[LastByteIndex] & clipRightMask) <<
                                                                  clipLeftBits;
                    
                    pDstScanLineStart[NewScanLineSize-1] = LOBYTE(wTmp);
                    
                    for (j=NewScanLineSize-1; j>0; j--) {
                        pDstScanLineStart[j-1] = HIBYTE(wTmp); 
                        wTmp = pSrcScanLineStart[j-1] << clipLeftBits;
                        pDstScanLineStart[j-1] |= LOBYTE(wTmp); 
                    }

                    pSrcScanLineStart += ScanLineSize;
                    pDstScanLineStart += NewScanLineSize;
                }
           }
        }

        *ppData =  pTmpData;
        *ppEndData = pEndTmpData;
        
    } else {
        *ppData = pNewData;
        *ppEndData = pNewDataEnd;
    }

DC_EXIT_POINT:
    
    DC_END_FN();
    return hr;
}

inline BOOL CheckSourceGlyphBits(UINT32 cx, 
                                 UINT32 cy, 
                                 PDCUINT8 pStart, 
                                 PDCUINT8 pEnd)
{
    DC_BEGIN_FN("CheckSourceGlyphBits");
    
    UINT32                  SrcScanLineSize = (cx+7) / 8;
    UINT32                  SrcBitmapSize = SrcScanLineSize & cy ;
    TRC_ASSERT((pEnd >= pStart),(TB, _T("pEnd is less then pStart!!")));

    DC_END_FN();

    return  ((SrcBitmapSize <= (UINT32)((PBYTE)pEnd - (PBYTE)pStart)) &&
             (SrcBitmapSize <= SrcScanLineSize) &&
             (SrcBitmapSize <= cy));
   
}

/****************************************************************************/
/* Name:      GHSlowOutputBuffer                                            */
/*                                                                          */
/*   Routine to output the composite glyphout buffer via normal bitblt      */
/*   operation(s)                                                           */
/*                                                                          */
/* Params:  pOrder          - Pointer to glyph index order                  */
/*          pData           - Pointer to composite glyph buffer             */
/*          BufferAlign     - Buffer alignment                              */
/*          ulBufferWidth   - Buffer width (in bytes)                       */
/****************************************************************************/
void DCINTERNAL CGH::GHSlowOutputBuffer(
        LPINDEX_ORDER pOrder,
        PDCUINT8      pData,
        ULONG         BufferAlign,
        unsigned      ulBufferWidth)
{
    HBITMAP  hbmOld;
    unsigned cxBits;
    unsigned cyBits;
#ifndef OS_WINCE
    DCCOLOR  color;
    DWORD    dwRop;
#ifdef DISABLE_SHADOW_IN_FULLSCREEN
    COLORREF rgb;
#endif // DISABLE_SHADOW_IN_FULLSCREEN
#else // OS_WINCE
    HBRUSH   hbr;
    COLORREF rgb;
#endif // OS_WINCE 

    DC_BEGIN_FN("GHSlowOutputBuffer");

    /************************************************************************/
    /* Use the glyph GDI resources                                          */
    /************************************************************************/
    // Calculate the proper cx and cy aligned sizes.
    cxBits = (int)(ulBufferWidth << 3);
    cyBits = (int)(pOrder->BkBottom - pOrder->BkTop);

#ifdef OS_WINCE
    // Create a bitmap with the composite glyph data provided.
    _pUh->_UH.hbmGlyph = CreateBitmap(cxBits, cyBits, 1, 1, pData);
    if (_pUh->_UH.hbmGlyph == NULL) {
        TRC_NRM((TB, _T("Unable to create composite glyph bitmap")));
        DC_QUIT;
    }
#else
    // If the current cache bitmap is not large enough to accomodate the
    // request, then free it so we can alloc one properly sized.
    if (cxBits != _pUh->_UH.cxGlyphBits || cyBits > _pUh->_UH.cyGlyphBits) {
        if (_pUh->_UH.hbmGlyph != NULL) {
            DeleteObject(_pUh->_UH.hbmGlyph);
            _pUh->_UH.hbmGlyph = NULL;
            goto NullGlyphBitmap;
        }
    }

    // If we have a bitmap of sufficient dimensions, then just set the bits
    // otherwise we need to alloc a new bitmap with the given data.
    if (_pUh->_UH.hbmGlyph != NULL) {
        SetBitmapBits(_pUh->_UH.hbmGlyph, (cxBits * cyBits) >> 3, pData);
    }
    else {
NullGlyphBitmap:
        _pUh->_UH.hbmGlyph = CreateBitmap(cxBits, cyBits, 1, 1, pData);
        if (_pUh->_UH.hbmGlyph != NULL) {
            _pUh->_UH.cxGlyphBits = cxBits;
            _pUh->_UH.cyGlyphBits = cyBits;
        }
        else {
            TRC_NRM((TB, _T("Unable to create composite glyph bitmap")));
            DC_QUIT;
        }
    }
#endif
    

    // Create a DC for the composite bitmap and load it into it.
    if (_pUh->_UH.hdcGlyph == NULL)
        _pUh->_UH.hdcGlyph = CreateCompatibleDC(NULL);
    if (_pUh->_UH.hdcGlyph != NULL) {
        hbmOld = (HBITMAP)SelectObject(_pUh->_UH.hdcGlyph, _pUh->_UH.hbmGlyph);
    }
    else {
        TRC_NRM((TB, _T("Unable to create compatible DC")));
        DC_QUIT;
    }

    /************************************************************************/
    /* If the output is to be opaque, then set the fore and back colors     */
    /* appropriately and set the correct rop code                           */
    /************************************************************************/
    if (pOrder->OpTop < pOrder->OpBottom) {

#ifndef OS_WINCE

#ifndef DISABLE_SHADOW_IN_FULLSCREEN
        UHUseTextColor(pOrder->ForeColor, UH_COLOR_PALETTE, _pUh);
        UHUseBkColor(pOrder->BackColor, UH_COLOR_PALETTE, _pUh);
#else
        // When in multimon and two desktops have different color depths
        // glyph color don't look right in 256 color connection
        // Here is the temporary solution, need to investigate more later.
        if (_pUh->_UH.protocolBpp <= 8) {
            rgb = UHGetColorRef(pOrder->ForeColor, UH_COLOR_PALETTE, _pUh);
            rgb = GetNearestColor(_pUh->_UH.hdcDraw, rgb);
            SetTextColor(_pUh->_UH.hdcDraw, rgb); 
            _pUh->_UH.lastTextColor = rgb; 
            
#if defined (OS_WINCE)
            _pUh->_UH.validTextColorDC = _pUh->_UH.hdcDraw;             
#endif

            rgb = UHGetColorRef(pOrder->BackColor, UH_COLOR_PALETTE, _pUh);
            rgb = GetNearestColor(_pUh->_UH.hdcDraw, rgb);
            SetBkColor(_pUh->_UH.hdcDraw, rgb); 
            _pUh->_UH.lastBkColor = rgb;             

#if defined (OS_WINCE)
            _pUh->_UH.validBkColorDC = _pUh->_UH.hdcDraw;             
#endif
        }
        else {
            UHUseTextColor(pOrder->ForeColor, UH_COLOR_PALETTE, _pUh);
            UHUseBkColor(pOrder->BackColor, UH_COLOR_PALETTE, _pUh);
        }
#endif // DISABLE_SHADOW_IN_FULLSCREEN
                
        dwRop = SRCCOPY;
#else // OS_WINCE
        /********************************************************************/
        /* On WinCE, the Transparent ROP is heavily accelerated. For opaque */
        /* just draw a solid rectangle, and then go on to do the            */
        /* transparent blt.                                                 */
        /********************************************************************/
        rgb = UHGetColorRef(pOrder->ForeColor, UH_COLOR_PALETTE, _pUh);
        hbr = CECreateSolidBrush(rgb);
        if(hbr != NULL) {
            FillRect(_pUh->_UH.hdcDraw, (LPRECT) &pOrder->BkLeft, hbr);
            CEDeleteBrush(hbr);
        }
#endif // OS_WINCE

    }

#ifndef OS_WINCE
    // If the output is to be transparent, then set the fore and back
    // colors appropriately and set the correct rop code.
    else {
        UHUseBrushOrg(0, 0, _pUh);
        _pUh->UHUseSolidPaletteBrush(pOrder->BackColor);

        color.u.rgb.red = 0;
        color.u.rgb.green = 0;
        color.u.rgb.blue = 0;
        UHUseTextColor(color, UH_COLOR_RGB, _pUh);

        color.u.rgb.red = 0xff;
        color.u.rgb.green = 0xff;
        color.u.rgb.blue = 0xff;
        UHUseBkColor(color, UH_COLOR_RGB, _pUh);

        dwRop = 0xE20746;
    }
#endif // OS_WINCE

    /************************************************************************/
    /* The opaque vs transparent preamble is done, now just do the right    */
    /* blt operation                                                        */
    /************************************************************************/

#ifdef OS_WINCE
    /************************************************************************/
    /* Create a brush for the foreground color and maskblt with that        */
    /* brush with the glyph bitmap as the mask                              */
    /************************************************************************/
    UHUseBrushOrg(0, 0, _pUh);
    _pUh->UHUseSolidPaletteBrush(pOrder->BackColor);

    /************************************************************************/
    /* The 6th, 7th and 8th parameters (src bitmap) aren't used by the ROP  */
    /* that we pass in.  The documentation says that in this case, hdcSrc   */
    /* should be zero but this causes the call to fail.  We also have to    */
    /* pass in reasonable values for nXSrc and nYSrc or the parameter       */
    /* checking will fail.                                                  */
    /************************************************************************/
    if (!MaskBlt(_pUh->_UH.hdcDraw,
            (int)pOrder->BkLeft,
            (int)pOrder->BkTop,
            (int)(pOrder->BkRight - pOrder->BkLeft),
            (int)(pOrder->BkBottom - pOrder->BkTop),
            _pUh->_UH.hdcGlyph,        // next 3 not used for this ROP
            0,
            0,
            _pUh->_UH.hbmGlyph,
            (int)BufferAlign,
            0,
            0xAAF00000))
    {
        TRC_ERR((TB, _T("Composite glyph MaskBlt failed, %lu"), GetLastError()));
    }

    /************************************************************************/
    // If we're drawing opaque we need to set the brush back to what
    // the fringe rect code is expecting.
    /************************************************************************/
    if (pOrder->OpTop < pOrder->OpBottom)
    {
        _pUh->UHUseSolidPaletteBrush(pOrder->ForeColor);
    }

#else // OS_WINCE
    /************************************************************************/
    /* Bitblt out the composite bitmap                                      */
    /************************************************************************/
    if (!BitBlt(_pUh->_UH.hdcDraw,
                (int)pOrder->BkLeft,
                (int)pOrder->BkTop,
                (int)(pOrder->BkRight - pOrder->BkLeft),
                (int)(pOrder->BkBottom - pOrder->BkTop),
                _pUh->_UH.hdcGlyph,
                (int)BufferAlign,
                0,
                dwRop))
    {
        TRC_ERR((TB, _T("Composite glyph BitBlt failed")));
    }  
#endif // OS_WINCE

    /************************************************************************/
    /* Release GDI resources                                                */
    /************************************************************************/
    SelectObject(_pUh->_UH.hdcGlyph, hbmOld);
#ifdef OS_WINCE
    DeleteDC(_pUh->_UH.hdcGlyph);
    _pUh->_UH.hdcGlyph = NULL;

    DeleteObject(_pUh->_UH.hbmGlyph);
    _pUh->_UH.hbmGlyph = NULL;
#endif
 
DC_EXIT_POINT:
    DC_END_FN();
}

/****************************************************************************/
/* Name:      draw_nf_ntb_o_to_temp_start                                   */
/*                                                                          */
/*   Specialized glyph dispatch routine for non-fixed pitch, top and        */
/*   bottom not aligned glyphs that do overlap. This routine calculates     */
/*   the glyph's position on the temp buffer, then determines the correct   */
/*   highly specialized routine to be used to draw each glyph based on      */
/*   the glyph width, alignment and rotation                                */
/*                                                                          */
/* Params:  pGlyphPos       - Pointer to first in list of GLYPHPOS structs  */
/*          pjTempBuffer    - Pointer to temp 1Bpp buffer to draw into      */
/*          TempBufDelta    - Scan line Delta for TempBuffer (always pos)   */
/****************************************************************************/
HRESULT CGH::draw_nf_ntb_o_to_temp_start(
        CGH*            inst,
        LPINDEX_ORDER   pOrder,
        unsigned        iGlyph,
        PDCUINT8 DCPTR  ppjItem,
        PDCUINT8       pjEndItem,
        PDCINT          px,
        PDCINT          py,
        PDCUINT8        pjTempBuffer,
        PDCUINT8        pjEndTempBuffer,
        ULONG           ulCharInc,
        unsigned        TempBufDelta,
        PDCUINT16       pUnicode,
        int *              pnRet)
{
    HRESULT hr = S_OK;
    PDCUINT8                pTempOutput;
    LONG                    GlyphPosX;
    int                     GlyphPixels;
    LONG                    GlyphAlignment;
    LONG                    SrcBytes;
    LONG                    DstBytes;
    ULONG                   ulDrawFlag;
    PFN_GLYPHLOOPN          pfnGlyphLoopN;
    PFN_GLYPHLOOP           pfnGlyphLoop;
    LONG                    GlyphPosY;
    HPUHGLYPHCACHE          pCache;
    HPUHGLYPHCACHEENTRYHDR  pHdr;
    PDCUINT8                pData;
    PDCUINT8                pEndData;
    ULONG                   cacheIndex;
    INT16                   delta;
    INT32                   GlyphClippingMode;
    UHGLYPHCACHEENTRYHDR    NewHdr;
    RECTCLIPOFFSET          rcOffset;
    
    DC_BEGIN_FN("draw_nf_ntb_o_to_temp_start");

    DC_IGNORE_PARAMETER(iGlyph);

    *pnRet = 0;

    CHECK_READ_ONE_BYTE(*ppjItem, pjEndItem, hr,
        (TB, _T("Read Glyph Cache ID error")));
    cacheIndex = **ppjItem;
    (*ppjItem)++;

    hr = inst->_pUh->UHIsValidGlyphCacheIDIndex(pOrder->cacheId, cacheIndex);
    DC_QUIT_ON_FAIL(hr);
    
    pCache = &(inst->_pUh->_UH.glyphCache[pOrder->cacheId]);

    pHdr  = &(pCache->pHdr[cacheIndex]);
    pData = &(pCache->pData[pCache->cbEntrySize * cacheIndex]);
    pEndData =  (PDCUINT8)((PBYTE)pData + pCache->cbEntrySize);

    if (pUnicode)
        pUnicode[iGlyph] = (UINT16)(pHdr->unicode);

    // Draw non fixed pitch, tops and bottoms not aligned,overlap
    if ((pOrder->flAccel & SO_CHAR_INC_EQUAL_BM_BASE) == 0) {
        CHECK_READ_ONE_BYTE(*ppjItem, pjEndItem, hr,
            (TB, _T("Read Glyph delta")));
        
        delta = (char)(*(*ppjItem)++);

        if (delta & 0x80) {
            CHECK_READ_N_BYTES(*ppjItem, pjEndItem, sizeof(INT16), hr,
                (TB, _T("Read Glyph delta")));
            
            delta = (*(short UNALIGNED FAR *)(*ppjItem));
            (*ppjItem) += sizeof(INT16);
        }

        if (pOrder->flAccel & SO_HORIZONTAL)
            *px += delta;
        else
            *py += delta;
    }
    
    // We make sure that we actually have enough bits for the glyph in the buffer
    if (!CheckSourceGlyphBits(pHdr->cx, pHdr->cy, pData, pEndData)) {
        hr=E_TSC_UI_GLYPH;
        DC_QUIT;
    }

    GlyphClippingMode = CalculateGlyphClipRect(&rcOffset, pOrder, pHdr, *px, *py);    
    if (GlyphClippingMode!=GLYPH_CLIP_NONE) {
        if (GlyphClippingMode==GLYPH_CLIP_ALL) {
            goto SkipGlyphOutput;
        } else {
            //    In case we do clipping we have to modify the header. We make a 
            //    copy so we don't modify the cache.
            memcpy(&NewHdr, pHdr, sizeof(UHGLYPHCACHEENTRYHDR));
            pHdr = &NewHdr;
            hr = ClipGlyphBits(inst, &rcOffset, pHdr, &pData, &pEndData);
            if (FAILED(hr)) {
                DC_QUIT;
            }
        }
    }
    
    // Glyph position in temp buffer = point.x + org.c - (TextRect.left & 0xffffffe0)
    GlyphPosX = *px + pHdr->x - ulCharInc;
    GlyphPosY = *py + pHdr->y - pOrder->BkTop;
    
    GlyphPosY = DC_MAX(0,GlyphPosY);

    GlyphAlignment = GlyphPosX & 0x07;

    // calc byte offset
    pTempOutput = pjTempBuffer + (GlyphPosX >> 3);

    // glyph width
    GlyphPixels = (int)pHdr->cx;

    // source and dest bytes required
    DstBytes = ((GlyphAlignment) + GlyphPixels + 7) >> 3;
    SrcBytes = (GlyphPixels + 7) >> 3;

    pTempOutput += (GlyphPosY * TempBufDelta);

    TRC_ASSERT((pTempOutput >= pjTempBuffer) &&
        (pTempOutput < pjTempBuffer + inst->g_ulBytes - DstBytes),
        (TB,_T("Bad glyph buffer addressing: pTempOutput=%p, pjTempBuffer=%p, g_ulBytes=%d, DstBytes=%d"),
        pTempOutput, pjTempBuffer, inst->g_ulBytes, DstBytes));

    if (pTempOutput < pjTempBuffer) {
        TRC_ABORT((TB, _T("Reading before buffer")));
        goto SkipGlyphOutput;
    }

    if (DstBytes < 0) {
        TRC_ABORT((TB,_T("Bad index into glyph drawing tables")
            _T("DstBytes=%d GlyphAlignment=%d GlyphPixels=%d pHdr->cx=%d ")
            _T("GlyphPosX=%d *px=%d pHdr->x=%d ulCharInc=%d"),
            DstBytes, GlyphAlignment, GlyphPixels, pHdr->cx, GlyphPosX, *px,
            pHdr->x, ulCharInc));
        hr = E_TSC_UI_GLYPH;
        DC_QUIT;        
    }
    
    if (DstBytes <= 4) {
        // use narrow initial table
        ulDrawFlag = ((DstBytes << 2)              |
                      ((DstBytes > SrcBytes) << 1) |
                      ((GlyphAlignment == 0)));

        pfnGlyphLoop = (PFN_GLYPHLOOP)OrAllTableNarrow[ulDrawFlag];
        pfnGlyphLoop(pHdr->cy,
                     GlyphAlignment,
                     TempBufDelta,
                     pData,
                     pEndData,
                     pTempOutput,
                     pjEndTempBuffer,
                     SrcBytes);
    }
    else {
        // use wide glyph drawing
        ulDrawFlag = (((DstBytes > SrcBytes) << 1) |
                      ((GlyphAlignment == 0)));

        pfnGlyphLoopN = (PFN_GLYPHLOOPN)OrAllTableWide[ulDrawFlag];
        pfnGlyphLoopN(pHdr->cy,
                      GlyphAlignment,
                      TempBufDelta,
                      pData,
                      pEndData,
                      pTempOutput,
                      pjEndTempBuffer,
                      SrcBytes,
                      DstBytes);
    }

SkipGlyphOutput:

    if (pOrder->flAccel & SO_CHAR_INC_EQUAL_BM_BASE) {
        if (pOrder->flAccel & SO_HORIZONTAL)
            *px += (unsigned)pHdr->cx;
        else
            *py += (unsigned)pHdr->cy;
    }
    *pnRet = GlyphPixels;

DC_EXIT_POINT:
    
    DC_END_FN();
    return hr;
}

/****************************************************************************/
/* Name:      draw_f_ntb_o_to_temp_start                                    */
/*                                                                          */
/*   Specialized glyph dispatch routine for fixed pitch, top and            */
/*   bottom not aligned glyphs that do overlap. This routine calculates     */
/*   the glyph's position on the temp buffer, then determines the correct   */
/*   highly specialized routine to be used to draw each glyph based on      */
/*   the glyph width, alignment and rotation                                */
/*                                                                          */
/* Params:  pGlyphPos       - Pointer to first in list of GLYPHPOS structs  */
/*          pjTempBuffer    - Pointer to temp 1Bpp buffer to draw into      */
/*          TempBufDelta    - Scan line Delta for TempBuffer (always pos)   */
/****************************************************************************/
HRESULT CGH::draw_f_ntb_o_to_temp_start(
        CGH*            inst,
        LPINDEX_ORDER   pOrder,
        unsigned        iGlyph,
        PDCUINT8 DCPTR  ppjItem,
        PDCUINT8        pjEndItem,
        PDCINT          px,
        PDCINT          py,
        PDCUINT8        pjTempBuffer,
        PDCUINT8        pjEndTempBuffer,
        ULONG           ulCharInc,
        unsigned        TempBufDelta,
        PDCUINT16       pUnicode,
        int *               pnRet)
{
    HRESULT hr = S_OK;
    PDCUINT8                pTempOutput;
    LONG                    GlyphPosX;
    LONG                    GlyphPixels;
    LONG                    GlyphAlignment;
    LONG                    SrcBytes;
    LONG                    DstBytes;
    ULONG                   ulDrawFlag;
    PFN_GLYPHLOOP           pfnGlyphLoop;
    PFN_GLYPHLOOPN          pfnGlyphLoopN;
    LONG                    GlyphPitchX;
    LONG                    GlyphPitchY;
    LONG                    GlyphPosY;
    HPUHGLYPHCACHE          pCache;
    HPUHGLYPHCACHEENTRYHDR  pHdr;
    PDCUINT8                pData;
    PDCUINT8                pEndData;
    ULONG                   cacheIndex;
    INT32                   GlyphClippingMode;
    UHGLYPHCACHEENTRYHDR    NewHdr;
    RECTCLIPOFFSET          rcOffset;
    
    DC_BEGIN_FN("draw_f_ntb_o_to_temp_start");

    DC_IGNORE_PARAMETER(iGlyph);

    *pnRet = 0;

    CHECK_READ_ONE_BYTE(*ppjItem, pjEndItem, hr,
        (TB, _T("Read Glyph Cache ID error")));
    cacheIndex = **ppjItem;
    (*ppjItem)++;

    hr = inst->_pUh->UHIsValidGlyphCacheIDIndex(pOrder->cacheId, cacheIndex);
    DC_QUIT_ON_FAIL(hr);

    pCache = &(inst->_pUh->_UH.glyphCache[pOrder->cacheId]);

    // Draw fixed pitch, tops and bottoms not aligned,overlap
    GlyphPitchX = *px;
    GlyphPitchY = *py - pOrder->BkTop;

    pHdr  = &(pCache->pHdr[cacheIndex]);
    pData = &(pCache->pData[pCache->cbEntrySize * cacheIndex]);
    pEndData =  (PDCUINT8)((PBYTE)pData + pCache->cbEntrySize);

    if (pUnicode)
        pUnicode[iGlyph] = (DCUINT16)(pHdr->unicode);
    
    // We make sure that we actually have enough bits for the glyph in the buffer
    if (!CheckSourceGlyphBits(pHdr->cx, pHdr->cy, pData, pEndData)) {
        hr=E_TSC_UI_GLYPH;
        DC_QUIT;
    }

    
    GlyphClippingMode = CalculateGlyphClipRect(&rcOffset, pOrder, pHdr, *px, *py);    
    if (GlyphClippingMode!=GLYPH_CLIP_NONE) {
        if (GlyphClippingMode==GLYPH_CLIP_ALL) {
            goto SkipGlyphOutput;
        } else {
            //    In case we do clipping we have to modify the header. We make a 
            //    copy so we don't modify the cache.
            memcpy(&NewHdr, pHdr, sizeof(UHGLYPHCACHEENTRYHDR));
            pHdr = &NewHdr;
            hr = ClipGlyphBits(inst, &rcOffset, pHdr, &pData, &pEndData);
            if (FAILED(hr)) {
                DC_QUIT;
            }
        }
    }

    // Glyph position in temp buffer = point.x + org.c - (TextRect.left & 0xfffffff8)
    GlyphPosX = GlyphPitchX + pHdr->x - ulCharInc;
    GlyphPosY = GlyphPitchY + pHdr->y;

    GlyphAlignment = GlyphPosX & 0x07;

    // calc byte offset
    pTempOutput = pjTempBuffer + (GlyphPosX >> 3);

    // glyph width
    GlyphPixels = pHdr->cx;

    // source and dest bytes required
    DstBytes = ((GlyphAlignment) + GlyphPixels + 7) >> 3;
    SrcBytes = (GlyphPixels + 7) >> 3;

    // calc glyph destination scan line
    pTempOutput += (GlyphPosY * TempBufDelta);
    TRC_ASSERT((pTempOutput >= pjTempBuffer) &&
               (pTempOutput < pjTempBuffer + inst->g_ulBytes - DstBytes),
               (TB,_T("Bad glyph buffer addressing")));

    if (pTempOutput < pjTempBuffer) {
        TRC_ABORT((TB, _T("Reading before buffer")));
        goto SkipGlyphOutput;
    }

    if (DstBytes < 0) {
        TRC_ABORT((TB,_T("Bad index into glyph drawing tables")
            _T("DstBytes=%d GlyphAlignment=%d GlyphPixels=%d pHdr->cx=%d ")
            _T("GlyphPosX=%d *px=%d pHdr->x=%d ulCharInc=%d"),
            DstBytes, GlyphAlignment, GlyphPixels, pHdr->cx, GlyphPosX, *px,
            pHdr->x, ulCharInc));
        hr = E_TSC_UI_GLYPH;
        DC_QUIT;        
    }

    if (DstBytes <= 4) {
        // use narrow initial table
        ulDrawFlag = ((DstBytes << 2)              |
                      ((DstBytes > SrcBytes) << 1) |
                      ((GlyphAlignment == 0)));

        pfnGlyphLoop = (PFN_GLYPHLOOP)OrAllTableNarrow[ulDrawFlag];
        pfnGlyphLoop(pHdr->cy,
                     GlyphAlignment,
                     TempBufDelta,
                     pData,
                     pEndData,
                     pTempOutput,
                     pjEndTempBuffer,
                     SrcBytes);
    }
    else {
        // use wide glyph drawing
        ulDrawFlag = (((DstBytes > SrcBytes) << 1) |
                      ((GlyphAlignment == 0)));

        pfnGlyphLoopN = (PFN_GLYPHLOOPN)OrAllTableWide[ulDrawFlag];
        pfnGlyphLoopN(pHdr->cy,
                      GlyphAlignment,
                      TempBufDelta,
                      pData,
                      pEndData,
                      pTempOutput,
                      pjEndTempBuffer,
                      SrcBytes,
                      DstBytes);
    }

SkipGlyphOutput:
    *px += pOrder->ulCharInc;

    *pnRet = pOrder->ulCharInc;
DC_EXIT_POINT:

    DC_END_FN();
    return hr;
}


/****************************************************************************/
/* Name:      draw_nf_tb_no_to_temp_start                                   */
/*                                                                          */
/*   Specialized glyph dispatch routine for non-fixed pitch, top and        */
/*   bottom aligned glyphs that do not overlap. This routine calculates     */
/*   the glyph's position on the temp buffer, then determines the correct   */
/*   highly specialized routine to be used to draw each glyph based on      */
/*   the glyph width, alignment and rotation                                */
/*                                                                          */
/* Params:  pGlyphPos       - Pointer to first in list of GLYPHPOS structs  */
/*          pjTempBuffer    - Pointer to temp 1Bpp buffer to draw into      */
/*          TempBufDelta    - Scan line Delta for TempBuffer (always pos)   */
/****************************************************************************/
HRESULT CGH::draw_nf_tb_no_to_temp_start(
        CGH*            inst,
        LPINDEX_ORDER   pOrder,
        unsigned        iGlyph,
        PDCUINT8 DCPTR  ppjItem,
        PDCUINT8       pjEndItem,
        PDCINT          px,
        PDCINT          py,
        PDCUINT8        pjTempBuffer,
        PDCUINT8        pjEndTempBuffer,
        ULONG           ulCharInc,
        unsigned        TempBufDelta,
        PDCUINT16       pUnicode,
        int *               pnRet)
{
    HRESULT hr = S_OK;
    PDCUINT8                pTempOutput;
    LONG                    GlyphPosX;
    int                     GlyphPixels;
    LONG                    GlyphAlignment;
    LONG                    SrcBytes;
    LONG                    DstBytes;
    ULONG                   ulDrawFlag;
    PFN_GLYPHLOOP           pfnGlyphLoop;
    PFN_GLYPHLOOPN          pfnGlyphLoopN;
    HPUHGLYPHCACHE          pCache;
    HPUHGLYPHCACHEENTRYHDR  pHdr;
    PDCUINT8                pData;
    PDCUINT8                pEndData;
    ULONG                   cacheIndex;
    INT16                   delta;
    INT32                   GlyphClippingMode;
    UHGLYPHCACHEENTRYHDR    NewHdr;
    RECTCLIPOFFSET          rcOffset;
    
    DC_BEGIN_FN("draw_nf_tb_no_to_temp_start");

    DC_IGNORE_PARAMETER(iGlyph);

    *pnRet = 0;

    CHECK_READ_ONE_BYTE(*ppjItem, pjEndItem, hr,
        (TB, _T("Read Glyph Cache ID error")));
    // Draw non fixed pitch, tops and bottoms not aligned, overlap
    cacheIndex = **ppjItem;
    (*ppjItem)++;

    hr = inst->_pUh->UHIsValidGlyphCacheIDIndex(pOrder->cacheId, cacheIndex);
    DC_QUIT_ON_FAIL(hr);

    pCache = &(inst->_pUh->_UH.glyphCache[pOrder->cacheId]);

    if ((pOrder->flAccel & SO_CHAR_INC_EQUAL_BM_BASE) == 0) {
        CHECK_READ_ONE_BYTE(*ppjItem, pjEndItem, hr,
                (TB, _T("Read Glyph delta error")));
        
        delta = (DCINT8)(*(*ppjItem)++);

        if (delta & 0x80) {
            CHECK_READ_N_BYTES(*ppjItem, pjEndItem, sizeof(DCINT16), hr,
                (TB, _T("Read Glyph delta error")));
            
            delta = (*(short UNALIGNED FAR *)(*ppjItem));
            (*ppjItem) += sizeof(DCINT16);
        }

        if (pOrder->flAccel & SO_HORIZONTAL)
            *px += delta;
        else
            *py += delta;
    }

    pHdr  = &(pCache->pHdr[cacheIndex]);
    pData = &(pCache->pData[pCache->cbEntrySize * cacheIndex]);
    pEndData =  (PDCUINT8)((PBYTE)pData + pCache->cbEntrySize);

    if (pUnicode)
        pUnicode[iGlyph] = (DCUINT16)(pHdr->unicode);

    // We make sure that we actually have enough bits for the glyph in the buffer
    if (!CheckSourceGlyphBits(pHdr->cx, pHdr->cy, pData, pEndData)) {
        hr=E_TSC_UI_GLYPH;
        DC_QUIT;
    }

    GlyphClippingMode = CalculateGlyphClipRect(&rcOffset, pOrder, pHdr, *px, *py);  
    if (GlyphClippingMode!=GLYPH_CLIP_NONE) {
        if (GlyphClippingMode==GLYPH_CLIP_ALL) {
            goto SkipGlyphOutput;
        } else {
            //    In case we do clipping we have to modify the header. We make a 
            //    copy so we don't modify the cache.
            memcpy(&NewHdr, pHdr, sizeof(UHGLYPHCACHEENTRYHDR));
            pHdr = &NewHdr;
            hr = ClipGlyphBits(inst, &rcOffset, pHdr, &pData, &pEndData);
            if (FAILED(hr)) {
                DC_QUIT;
            }
        }
    }

    // Glyph position in temp buffer = point.x + org.c - (TextRect.left & 0xfffffff8)
    GlyphPosX = *px + pHdr->x - ulCharInc;
    GlyphAlignment = GlyphPosX & 0x07;

    // calc byte offset
    pTempOutput = pjTempBuffer + (GlyphPosX >> 3);

    // glyph width
    GlyphPixels = (DCINT) pHdr->cx;

    // source and dest bytes required
    DstBytes = ((GlyphAlignment) + GlyphPixels + 7) >> 3;
    SrcBytes = (GlyphPixels + 7) >> 3;

    TRC_ASSERT((pTempOutput >= pjTempBuffer) &&
               (pTempOutput < pjTempBuffer + inst->g_ulBytes - DstBytes),
               (TB,_T("Bad glyph buffer addressing")));
    
    if (pTempOutput < pjTempBuffer) {
        TRC_ABORT((TB, _T("Reading before buffer")));
        goto SkipGlyphOutput;
    }

    if (DstBytes < 0) {
        TRC_ABORT((TB,_T("Bad index into glyph drawing tables")
            _T("DstBytes=%d GlyphAlignment=%d GlyphPixels=%d pHdr->cx=%d ")
            _T("GlyphPosX=%d *px=%d pHdr->x=%d ulCharInc=%d"),
            DstBytes, GlyphAlignment, GlyphPixels, pHdr->cx, GlyphPosX, *px,
            pHdr->x, ulCharInc));
        hr = E_TSC_UI_GLYPH;
        DC_QUIT;        
    }

    if (DstBytes <= 4) {
        // use narrow initial table
        ulDrawFlag = ((DstBytes << 2) |
                      ((DstBytes > SrcBytes) << 1) |
                      ((GlyphAlignment == 0)));

        pfnGlyphLoop = (PFN_GLYPHLOOP)OrInitialTableNarrow[ulDrawFlag];
        pfnGlyphLoop(pHdr->cy,
                     GlyphAlignment,
                     TempBufDelta,
                     pData,
                     pEndData,
                     pTempOutput,
                     pjEndTempBuffer,
                     SrcBytes);
    }
    else {
        // use wide glyph drawing
        ulDrawFlag = (((DstBytes > SrcBytes) << 1) |
                       ((GlyphAlignment == 0)));

        pfnGlyphLoopN = (PFN_GLYPHLOOPN)OrAllTableWide[ulDrawFlag];
        pfnGlyphLoopN(pHdr->cy,
                      GlyphAlignment,
                      TempBufDelta,
                      pData,
                      pEndData,
                      pTempOutput,
                      pjEndTempBuffer,
                      SrcBytes,
                      DstBytes);
    }
    
SkipGlyphOutput:
    
    if (pOrder->flAccel & SO_CHAR_INC_EQUAL_BM_BASE)
        *px += (DCINT) pHdr->cx;

    *pnRet = GlyphPixels;
DC_EXIT_POINT:
    
    DC_END_FN();
    return hr;
}


/****************************************************************************/
/* Name:      draw_f_tb_no_to_temp_start                                    */
/*                                                                          */
/*   Specialized glyph dispatch routine for fixed pitch, top and            */
/*   bottom aligned glyphs that do not overlap. This routine calculates     */
/*   the glyph's position on the temp buffer, then determines the correct   */
/*   highly specialized routine to be used to draw each glyph based on      */
/*   the glyph width, alignment and rotation                                */
/*                                                                          */
/* Params:  pGlyphPos       - Pointer to first in list of GLYPHPOS structs  */
/*          pjTempBuffer    - Pointer to temp 1Bpp buffer to draw into      */
/*          TempBufDelta    - Scan line Delta for TempBuffer (always pos)   */
/****************************************************************************/
HRESULT CGH::draw_f_tb_no_to_temp_start(
        CGH*            inst,
        LPINDEX_ORDER   pOrder,
        unsigned        iGlyph,
        PDCUINT8 DCPTR  ppjItem,
        PDCUINT8       pjEndItem,
        PDCINT          px,
        PDCINT          py,
        PDCUINT8        pjTempBuffer,
        PDCUINT8        pjEndTempBuffer,
        ULONG           ulLeftEdge,
        unsigned        TempBufDelta,
        PDCUINT16       pUnicode,
        int *              pnRet)
{
    HRESULT hr = S_OK;
    PDCUINT8                pTempOutput;
    LONG                    GlyphPosX;
    LONG                    GlyphPixels;
    LONG                    GlyphPitchX;
    LONG                    GlyphAlignment;
    LONG                    SrcBytes;
    LONG                    DstBytes;
    ULONG                   ulDrawFlag;
    PFN_GLYPHLOOPN          pfnGlyphLoopN;
    PFN_GLYPHLOOP           pfnGlyphLoop;
    HPUHGLYPHCACHE          pCache;
    HPUHGLYPHCACHEENTRYHDR  pHdr;
    PDCUINT8                pData;
    PDCUINT8                pEndData;
    ULONG                   cacheIndex;
    INT32                   GlyphClippingMode;
    UHGLYPHCACHEENTRYHDR    NewHdr;
    RECTCLIPOFFSET          rcOffset;

    DC_BEGIN_FN("draw_f_tb_no_to_temp_start");

    DC_IGNORE_PARAMETER(iGlyph);
    DC_IGNORE_PARAMETER(py);

    *pnRet = 0;

    CHECK_READ_ONE_BYTE(*ppjItem, pjEndItem, hr,
        (TB, _T("Read Glyph Cache ID error")));
    cacheIndex = **ppjItem;
    (*ppjItem)++;

    hr = inst->_pUh->UHIsValidGlyphCacheIDIndex(pOrder->cacheId, cacheIndex);
    DC_QUIT_ON_FAIL(hr);

    pCache = &(inst->_pUh->_UH.glyphCache[pOrder->cacheId]);

    // Draw fixed pitch, tops and bottoms not aligned,overlap
    GlyphPitchX = *px;

    pHdr  = &(pCache->pHdr[cacheIndex]);
    pData = &(pCache->pData[pCache->cbEntrySize * cacheIndex]);
    pEndData =  (PDCUINT8)((PBYTE)pData + pCache->cbEntrySize);

    if (pUnicode)
        pUnicode[iGlyph] = (UINT16)(pHdr->unicode);

    // We make sure that we actually have enough bits for the glyph in the buffer
    if (!CheckSourceGlyphBits(pHdr->cx, pHdr->cy, pData, pEndData)) {
        hr=E_TSC_UI_GLYPH;
        DC_QUIT;
    }

    GlyphClippingMode = CalculateGlyphClipRect(&rcOffset, pOrder, pHdr, *px, *py);
    if (GlyphClippingMode!=GLYPH_CLIP_NONE) {
        if (GlyphClippingMode==GLYPH_CLIP_ALL) {
            goto SkipGlyphOutput;
        } else {
            //    In case we do clipping we have to modify the header. We make a 
            //    copy so we don't modify the cache.
            memcpy(&NewHdr, pHdr, sizeof(UHGLYPHCACHEENTRYHDR));
            pHdr = &NewHdr;
            hr = ClipGlyphBits(inst, &rcOffset, pHdr, &pData, &pEndData);
            if (FAILED(hr)) {
                DC_QUIT;
            }
        }
    }
    
    // Glyph position in temp buffer = point.x + org.c - (TextRect.left & 0xfffffff8)
    GlyphPosX = GlyphPitchX + pHdr->x - ulLeftEdge;
    GlyphAlignment = GlyphPosX & 0x07;

    // calc byte offset
    pTempOutput = pjTempBuffer + (GlyphPosX >> 3);

    // glyph width
    GlyphPixels = pHdr->cx;

    // source and dest bytes required
    DstBytes = ((GlyphAlignment) + GlyphPixels + 7) >> 3;
    SrcBytes = (GlyphPixels + 7) >> 3;

    TRC_ASSERT((pTempOutput >= pjTempBuffer) &&
               (pTempOutput < pjTempBuffer + inst->g_ulBytes - DstBytes),
               (TB,_T("Bad glyph buffer addressing")));

    if (pTempOutput < pjTempBuffer) {
        TRC_ABORT((TB, _T("Reading before buffer")));
        goto SkipGlyphOutput;
    }

    if (DstBytes < 0) {
        TRC_ABORT((TB,_T("Bad index into glyph drawing tables")
            _T("DstBytes=%d GlyphAlignment=%d GlyphPixels=%d pHdr->cx=%d ")
            _T("GlyphPosX=%d *px=%d pHdr->x=%d ulLeftEdge=%d"),
            DstBytes, GlyphAlignment, GlyphPixels, pHdr->cx, GlyphPosX, *px,
            pHdr->x, ulLeftEdge));
        hr = E_TSC_UI_GLYPH;
        DC_QUIT;        
    }

    if (DstBytes <= 4) {
        // use narrow initial table
        ulDrawFlag = ((DstBytes << 2) |
                      ((DstBytes > SrcBytes) << 1) |
                       (GlyphAlignment == 0));

        pfnGlyphLoop = (PFN_GLYPHLOOP)OrInitialTableNarrow[ulDrawFlag];
        pfnGlyphLoop(pHdr->cy,
                     GlyphAlignment,
                     TempBufDelta,
                     pData,
                     pEndData,
                     pTempOutput,
                     pjEndTempBuffer,
                     SrcBytes);
    }
    else {
        // use wide glyph drawing
        ulDrawFlag = (((DstBytes > SrcBytes) << 1) |
                      ((GlyphAlignment == 0)));

        pfnGlyphLoopN = (PFN_GLYPHLOOPN)OrAllTableWide[ulDrawFlag];
        pfnGlyphLoopN(pHdr->cy,
                      GlyphAlignment,
                      TempBufDelta,
                      pData,
                      pEndData,
                      pTempOutput,
                      pjEndTempBuffer,
                      SrcBytes,
                      DstBytes);
    }

SkipGlyphOutput:
    *px += pOrder->ulCharInc;

    *pnRet = pOrder->ulCharInc;
DC_EXIT_POINT:
    
    DC_END_FN();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\ih.cpp ===
/****************************************************************************/
/* ih.cpp                                                                   */
/*                                                                          */
/* Input Handler functions                                                  */
/*                                                                          */
/* Copyright (c) 1997-1999 Microsoft Corporation                            */
/****************************************************************************/

#include <adcg.h>

extern "C" {
#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "aihapi"
#include <atrcapi.h>
}

#include "ih.h"
#include "cc.h"

CIH::CIH(CObjs* objs)
{
    DC_BEGIN_FN("CIH::CIH");
    _pClientObjects = objs;
    _hKeyboardHook = NULL;
    _fUseHookBypass = FALSE;
    _fCanUseKeyboardHook = FALSE;

    memset(_KeyboardState, 0, sizeof(_KeyboardState));

    DC_END_FN();
}


CIH::~CIH()
{
    DC_BEGIN_FN("CIH::~CIH");
    DC_END_FN();
}

VOID CIH::IH_StaticInit(HINSTANCE hInstance)
{
    DC_BEGIN_FN("CIH::IH_StaticInit");

    UNREFERENCED_PARAMETER(hInstance);

    TRC_ASSERT(CIH::TlsIndex == 0xFFFFFFFF, (TB, _T("")));
    CIH::TlsIndex = TlsAlloc();

    if (CIH::TlsIndex == 0xFFFFFFFF) {
        TRC_ALT((TB, _T("Unable to allocate Thread Local Storage")));
    }

    DC_END_FN();
}

VOID CIH::IH_StaticTerm()
{
    if (CIH::TlsIndex != 0xFFFFFFFF) {
        TlsFree(CIH::TlsIndex);
        CIH::TlsIndex = 0xFFFFFFFF;
    }
}

/****************************************************************************/
/* Name:      IH_Init                                                       */
/*                                                                          */
/* Purpose:   Initialize Input Handler                                      */
/****************************************************************************/
DCVOID DCAPI CIH::IH_Init(DCVOID)
{
    DC_BEGIN_FN("IH_Init");

    //Setup local object pointers
    _pUt  = _pClientObjects->_pUtObject;
    _pUi  = _pClientObjects->_pUiObject;
    _pSl  = _pClientObjects->_pSlObject;
    _pUh  = _pClientObjects->_pUHObject;
    _pCd  = _pClientObjects->_pCdObject;
    _pIh  = _pClientObjects->_pIhObject;
    _pOr  = _pClientObjects->_pOrObject;
    _pFs  = _pClientObjects->_pFsObject;
    _pCc  = _pClientObjects->_pCcObject;
    _pOp  = _pClientObjects->_pOPObject;

    /************************************************************************/
    /* Initialize the global data and the IH FSM state                      */
    /************************************************************************/
    DC_MEMSET(&_IH, 0, sizeof(_IH));
    _IH.fsmState = IH_STATE_RESET;

    /************************************************************************/
    /* Call the FSM to enter init state                                     */
    /************************************************************************/
    IHFSMProc(IH_FSM_INIT, 0);

    DC_END_FN();
} /* IH_Init */


/****************************************************************************/
/* Name:      IH_Term                                                       */
/*                                                                          */
/* Purpose:   Terminate Input Handler                                       */
/****************************************************************************/
DCVOID DCAPI CIH::IH_Term(DCVOID)
{
    DC_BEGIN_FN("IH_Term");

    /************************************************************************/
    /* Call the FSM to clean up and enter reset state.                      */
    /************************************************************************/
    IHFSMProc(IH_FSM_TERM, 0);

    DC_END_FN();
} /* IH_Term */


/****************************************************************************/
/* Name:      IH_Enable                                                     */
/*                                                                          */
/* Purpose:   Called to enable _IH.                                          */
/****************************************************************************/
DCVOID DCAPI CIH::IH_Enable(DCVOID)
{
    DC_BEGIN_FN("IH_Enable");

    /************************************************************************/
    /* Call the FSM                                                         */
    /************************************************************************/
    IHFSMProc(IH_FSM_ENABLE, 0);

    DC_END_FN();
} /* IH_Enable */


/****************************************************************************/
/* Name:      IH_Disable                                                    */
/*                                                                          */
/* Purpose:   Called to disable _IH.  This can safely be called even if      */
/*            IH is not enabled.                                            */
/****************************************************************************/
DCVOID DCAPI CIH::IH_Disable(DCVOID)
{
    DC_BEGIN_FN("IH_Disable");

    /************************************************************************/
    /* Call the FSM                                                         */
    /************************************************************************/
    IHFSMProc(IH_FSM_DISABLE, 0);

    DC_END_FN();
} /* IH_Disable */


/****************************************************************************/
/* Name:      IH_BufferAvailable                                            */
/*                                                                          */
/* Purpose:   Called when the network indicates that it is ready to send    */
/****************************************************************************/
DCVOID DCAPI CIH::IH_BufferAvailable(DCVOID)
{
    DC_BEGIN_FN("IH_BufferAvailable");

    IHFSMProc(IH_FSM_BUFFERAVAILABLE, 0);

    DC_END_FN();
} /* IH_BufferAvailable */


/****************************************************************************/
/* Name:      IH_GetInputHandlerWindow                                      */
/*                                                                          */
/* Purpose:   Returns the handle of the Input Handler Window.               */
/*                                                                          */
/* Returns:   Window handle.                                                */
/****************************************************************************/
HWND DCAPI CIH::IH_GetInputHandlerWindow(DCVOID)
{
    HWND rc;

    DC_BEGIN_FN("IH_GetInputHandlerWindow");

    rc = _IH.inputCaptureWindow;

    DC_END_FN();

    return(rc);
} /* IH_GetInputHandlerWindow */


/****************************************************************************/
/* Name:      IH_SetAcceleratorPassthrough                                  */
/*                                                                          */
/* Purpose:   Sets the state of the accelerator passthrough.                */
/*                                                                          */
/* Params:    enabled - 0 if disabled, 1 if enabled.                        */
/*                                                                          */
/*            Ideally this parameter would be of type DCBOOL, but this      */
/*            function is called directly by the Component Decoupler so     */
/*            must conform to the standard CD_SIMPLE_NOTIFICATION_FN        */
/*            function type.                                                */
/****************************************************************************/
DCVOID DCAPI CIH::IH_SetAcceleratorPassthrough(ULONG_PTR enabled)
{
    DC_BEGIN_FN("IH_SetAcceleratorPassthrough");

    TRC_ASSERT( ((enabled == 0) || (enabled == 1)),
                (TB, _T("Invalid value for enabled: %u"), enabled) );

    _IH.acceleratorPassthroughEnabled = (DCBOOL)enabled;

    DC_END_FN();
} /* IH_SetAcceleratorPassthrough */


/****************************************************************************/
/* Name:      IH_SetCursorPos                                               */
/*                                                                          */
/* Purpose:   Move the cursor - decoupled from CM                           */
/*                                                                          */
/* Params:    IN      pData  - new position (in remote coordinates)         */
/*            IN      dataLen - length of data                              */
/****************************************************************************/
DCVOID DCAPI CIH::IH_SetCursorPos(PDCVOID pData, DCUINT dataLen)
{
    PPOINT pPos = (PPOINT)pData;

    DC_BEGIN_FN("IH_SetCursorPos");

    TRC_ASSERT((dataLen == sizeof(POINT)), (TB, _T("Invalid point size")));
    DC_IGNORE_PARAMETER(dataLen);

    /************************************************************************/
    /* Only move the mouse when IH has the focus                            */
    /************************************************************************/
    if (_IH.fsmState == IH_STATE_ACTIVE)
    {
        /********************************************************************/
        /* If the local mouse is already outside the client window then we  */
        /* should ignore this message, even though we have the focus        */
        /*                                                                  */
        /* First get the position (screen coords)                           */
        /********************************************************************/
        POINT localMousePos;
        GetCursorPos(&localMousePos);

        /********************************************************************/
        /* now convert to Window coords                                     */
        /********************************************************************/
        ScreenToClient(_pUi->UI_GetUIContainerWindow(), &localMousePos);

        if ((localMousePos.x < _IH.visibleArea.left) ||
            (localMousePos.x > _IH.visibleArea.right)||
            (localMousePos.y < _IH.visibleArea.top)  ||
            (localMousePos.y > _IH.visibleArea.bottom))
        {
            TRC_ALT((TB, _T("MouseMove ignored - client mouse outside client")));
            TRC_DBG((TB, _T("local mouse (%d,%d), desired mouse (%d,%d)"),
                     localMousePos.x, localMousePos.y, pPos->x, pPos->y));
            TRC_DBG((TB, _T("vis area l/t r/b (%d,%d %d,%d)"),
                     _IH.visibleArea.left,  _IH.visibleArea.top,
                     _IH.visibleArea.right, _IH.visibleArea.bottom));

        }
        /********************************************************************/
        /* Don't move the mouse out of the client window.                   */
        /********************************************************************/
        else if ((pPos->x < _IH.visibleArea.left) ||
                 (pPos->x > _IH.visibleArea.right)||
                 (pPos->y < _IH.visibleArea.top)  ||
                 (pPos->y > _IH.visibleArea.bottom))
        {
            TRC_ALT((TB, _T("MouseMove ignored - dest is outside client")));
            TRC_DBG((TB, _T("desired mouse (%d,%d)"), pPos->x, pPos->y));
            TRC_DBG((TB, _T("vis area l/t r/b (%d,%d %d,%d)"),
                     _IH.visibleArea.left,  _IH.visibleArea.top,
                     _IH.visibleArea.right, _IH.visibleArea.bottom));
        }
        else
        {
            /****************************************************************/
            /* Finally we actually apply the move, converting to screen     */
            /* co-ordinates first                                           */
            /****************************************************************/

            TRC_DBG((TB, _T("New Pos %d,%d (window co-ords)"),pPos->x, pPos->y));

#ifdef SMART_SIZING
            //
            // Scale the mouse position in line with the shrunken desktop size
            // Do this before we translate to a screen position
            //
            DCSIZE desktopSize;
    
            _pUi->UI_GetDesktopSize(&desktopSize);
    
    
            if (_pUi->UI_GetSmartSizing()   &&
                desktopSize.width != 0      &&
                desktopSize.height != 0)
            {
                pPos->x = (DCINT16)(pPos->x * _scaleSize.width / desktopSize.width);
                pPos->y = (DCINT16)(pPos->y * _scaleSize.height / desktopSize.height);
            }
            TRC_DBG((TB, _T("SmartSized Pos %d,%d (window co-ords)"),pPos->x, pPos->y));
#endif
            ClientToScreen(_pUi->UI_GetUIContainerWindow(), pPos);

            TRC_DBG((TB, _T("Warp pointer to %d,%d (screen)"),pPos->x, pPos->y));
            SetCursorPos(pPos->x, pPos->y);
        }

    }
    else
    {
        TRC_NRM((TB, _T("Ignore mouse warp - don't have the focus")));
    }

    DC_END_FN();
} /* IH_SetCursorPos */


/****************************************************************************/
/* Name:      IH_SetCursorShape                                             */
/*                                                                          */
/* Purpose:   Set the cursor shape - called by CM                           */
/*                                                                          */
/* Params:    IN      pData     new cursor handle                           */
/*            IN      dataLen - length of data                              */
/****************************************************************************/
DCVOID DCAPI CIH::IH_SetCursorShape(ULONG_PTR data)
{
    DC_BEGIN_FN("IH_SetCursorShape");

    /************************************************************************/
    /* Don't do this unless the session is active.                          */
    /************************************************************************/
    if ((_IH.fsmState == IH_STATE_ACTIVE) ||
        (_IH.fsmState == IH_STATE_PENDACTIVE) ||
        (_IH.fsmState == IH_STATE_SUSPENDED))
    {
        IHSetCursorShape((HCURSOR)data);
    }

    DC_END_FN();
} /* IH_SetCursorShape */


/****************************************************************************/
/* Name:      IH_SetVisiblePos                                              */
/*                                                                          */
/* Purpose:   Set the visible window region, for mouse clipping             */
/*                                                                          */
/* Params:    IN      pData   - position of window                          */
/*            IN      dataLen - length of data                              */
/****************************************************************************/
DCVOID DCAPI CIH::IH_SetVisiblePos(PDCVOID pData, DCUINT dataLen)
{
    PPOINT pNewPos = (PPOINT)pData;
    DCINT  deltaX;
    DCINT  deltaY;

    DC_BEGIN_FN("IH_SetVisiblePos");

    DC_IGNORE_PARAMETER(dataLen);

    /************************************************************************/
    /* Position should be negative                                          */
    /************************************************************************/
    deltaX = _IH.visibleArea.left + pNewPos->x;
    deltaY = _IH.visibleArea.top  + pNewPos->y;

    _IH.visibleArea.left   -= deltaX;
    _IH.visibleArea.top    -= deltaY;
    _IH.visibleArea.right  -= deltaX;
    _IH.visibleArea.bottom -= deltaY;

    TRC_NRM((TB, _T("Top %d Left %d"), _IH.visibleArea.top, _IH.visibleArea.left));
    TRC_NRM((TB, _T("right %d bottom %d"),
                  _IH.visibleArea.right, _IH.visibleArea.bottom));

    DC_END_FN();
} /* IH_SetVisiblePos */


/****************************************************************************/
/* Name:      IH_SetVisibleSize                                             */
/*                                                                          */
/* Purpose:   Set the visible window region, for mouse clipping             */
/*                                                                          */
/* Params:    IN      data     size of window                               */
/****************************************************************************/
DCVOID DCAPI CIH::IH_SetVisibleSize(ULONG_PTR data)
{
    DCUINT width;
    DCUINT height;

    DC_BEGIN_FN("IH_SetVisibleSize");
    width  = LOWORD(data);
    height = HIWORD(data);

    _IH.visibleArea.right  = width + _IH.visibleArea.left - 1;
    _IH.visibleArea.bottom = height + _IH.visibleArea.top - 1;

    TRC_NRM((TB, _T("Top %d Left %d"), _IH.visibleArea.top, _IH.visibleArea.left));
    TRC_NRM((TB, _T("right %d bottom %d"),
                 _IH.visibleArea.right, _IH.visibleArea.bottom));

    DC_END_FN();
} /* IH_SetVisibleSize */


/****************************************************************************/
/* Name:      IH_SetHotkey                                                  */
/*                                                                          */
/* Purpose: To store the value of all the hotkeys passed from the UI        */
/*                                                                          */
/* Params:    hotKey - IN - the value for UI.Hotkey                         */
/****************************************************************************/
DCVOID DCAPI CIH::IH_SetHotkey(PDCVOID pData, DCUINT len)
{
    DC_BEGIN_FN("IH_SetHotkey");

    TRC_ASSERT((len == sizeof(PDCHOTKEY)),
               (TB, _T("Hotkey pointer is invalid")));
    DC_IGNORE_PARAMETER(len);

    _IH.pHotkey = *((PDCHOTKEY DCPTR)pData);

    DC_END_FN();
} /* IH_SetHotkey */


/****************************************************************************/
/* Name:      IH_ProcessInputCaps                                           */
/*                                                                          */
/* Purpose:   Process input capabilities from the server                    */
/*                                                                          */
/* Params:    IN      pInputCaps - pointer to caps                          */
/****************************************************************************/
DCVOID DCAPI CIH::IH_ProcessInputCaps(PTS_INPUT_CAPABILITYSET pInputCaps)
{
    DC_BEGIN_FN("IH_ProcessInputCaps");
    TRC_ASSERT(pInputCaps, (TB,_T("pInputCaps parameter NULL in call to IH_ProcessInputCaps")));
    if(!pInputCaps)
    {
        DC_QUIT;
    }

    if (pInputCaps->inputFlags & TS_INPUT_FLAG_SCANCODES)
    {
        TRC_NRM((TB, _T("Server supports scancodes")));
        _IH.useScancodes = TRUE;
    }
    else
    {
        /********************************************************************/
        /* Note that current versions of the server should support          */
        /* scancodes.                                                       */
        /********************************************************************/
        TRC_ALT((TB, _T("Server doesn't support scancodes")));
        _IH.useScancodes = FALSE;
    }

    if (pInputCaps->inputFlags & TS_INPUT_FLAG_MOUSEX)
    {
        TRC_NRM((TB, _T("Server supports mouse XButtons")));
        _IH.useXButtons = TRUE;
    }
    else
    {
        TRC_ALT((TB, _T("Server doesn't support mouse XButtons")));
        _IH.useXButtons = FALSE;
    }

    // Fast-path input added to RDP 5.0.
    if (pInputCaps->inputFlags & TS_INPUT_FLAG_FASTPATH_INPUT2) {
        TRC_NRM((TB,_T("Server supports fast-path input packets")));
        _IH.bUseFastPathInput = TRUE;
    }
    else {
        TRC_ALT((TB,_T("Server does not support fast-path input packets")));
        _IH.bUseFastPathInput = FALSE;
    }

    // VK_PACKET support added in RDP 5.1.1.
    if (pInputCaps->inputFlags & TS_INPUT_FLAG_VKPACKET)
    {
        TRC_NRM((TB,_T("Server supports VK_PACKET input packets")));
        _IH.fUseVKPacket = TRUE;
    }
    else
    {
        TRC_NRM((TB,_T("Server does not support VK_PACKET input packets")));
        _IH.fUseVKPacket = FALSE;
    }

    DC_END_FN();
DC_EXIT_POINT:
    return;
} /* IH_ProcessInputCaps */


/****************************************************************************/
/* Name:    IH_UpdateKeyboardIndicators                                     */
/*                                                                          */
/* Purpose: Updates server-initiated keyboard indicator states              */
/*                                                                          */
/* Params: IN - UnitId      UnitId                                          */
/*              LedFlags    LedFlags                                        */
/****************************************************************************/
DCVOID DCAPI CIH::IH_UpdateKeyboardIndicators(DCUINT16   UnitId,
                                         DCUINT16   LedFlags)
{
    DCUINT8     keyStates[256];

    DC_BEGIN_FN("IH_UpdateKeyboardIndicators");
    DC_IGNORE_PARAMETER(UnitId);

    /************************************************************************/
    /* Only set the leds when IH has the focus                              */
    /************************************************************************/
    if (_IH.fsmState == IH_STATE_ACTIVE)
    {
        /********************************************************************/
        /* Get the current keyboard toggle states                           */
        /********************************************************************/
#ifdef OS_WINCE
        {
            KEY_STATE_FLAGS KeyStateFlags;
            KeyStateFlags = GetAsyncShiftFlags(0);
            keyStates[VK_SCROLL]  = 0; // CE doesn't support this?
            keyStates[VK_NUMLOCK] = (DCUINT8)((KeyStateFlags & KeyShiftNumLockFlag) ? 1 : 0);
            keyStates[VK_CAPITAL] = (DCUINT8)((KeyStateFlags & KeyShiftCapitalFlag) ? 1 : 0);
        }
#else
        GetKeyboardState(keyStates);
#endif

        /********************************************************************/
        /* Process any SCROLL_LOCK changes                                  */
        /********************************************************************/
        IHUpdateKeyboardIndicator(keyStates,
                                  (DCUINT8) (LedFlags & TS_SYNC_SCROLL_LOCK),
                                  (DCUINT8) VK_SCROLL);

        /********************************************************************/
        /* Process any NUM_LOCK changes                                     */
        /********************************************************************/
        IHUpdateKeyboardIndicator(keyStates,
                                  (DCUINT8) (LedFlags & TS_SYNC_NUM_LOCK),
                                  (DCUINT8) VK_NUMLOCK);

        /************************************************************************/
        /* Keep track of NumLock state                                          */
        /************************************************************************/
        _IH.NumLock = (GetKeyState(VK_NUMLOCK) & IH_KEYSTATE_TOGGLED);

        /********************************************************************/
        /* Process any CAPS_LOCK changes                                    */
        /********************************************************************/
        IHUpdateKeyboardIndicator(keyStates,
                                  (DCUINT8) (LedFlags & TS_SYNC_CAPS_LOCK),
                                  (DCUINT8) VK_CAPITAL);

        /********************************************************************/
        /* Process any KANA_LOCK changes                                    */
        /********************************************************************/
#if defined(OS_WIN32)
        if (JAPANESE_KBD_LAYOUT(_pCc->_ccCombinedCapabilities.inputCapabilitySet.keyboardLayout))
        {
            IHUpdateKeyboardIndicator(keyStates,
                                      (DCUINT8) (LedFlags & TS_SYNC_KANA_LOCK),
                                      (DCUINT8) VK_KANA);
        }
#endif // OS_WIN32
    }
    else
    {
        TRC_NRM((TB, _T("Ignore keyboard set leds - don't have the focus")));
    }

    DC_END_FN();

    return;
}


/****************************************************************************/
/* Name:      IH_InputEvent                                                 */
/*                                                                          */
/* Purpose:   Handle input events from UI                                   */
/*                                                                          */
/* Params:    msg - message received from UI                                */
/****************************************************************************/
DCVOID DCAPI CIH::IH_InputEvent(ULONG_PTR msg)
{
    DC_BEGIN_FN("IH_InputEvent");

#ifndef OS_WINCE
    
    TRC_NRM((TB, _T("Msg %d"), msg));

    switch (msg)
    {
#ifdef OS_WINNT
        case WM_ENTERSIZEMOVE:
        {
            TRC_NRM((TB, _T("WM_ENTERSIZEMOVE")));
            _IH.inSizeMove = TRUE;
            IHFSMProc(IH_FSM_FOCUS_LOSE, 0);
        }
        break;

        case WM_EXITSIZEMOVE:
        {
            TRC_NRM((TB, _T("WM_EXITSIZEMOVE")));
            _IH.inSizeMove = FALSE;
            IHFSMProc(IH_FSM_FOCUS_GAIN, 0);
        }
        break;

        case WM_EXITMENULOOP:
        {
            TRC_NRM((TB, _T("WM_EXITMENULOOP")));
            _IH.focusSyncRequired = TRUE;
            if (_IH.inSizeMove)
            {
                TRC_NRM((TB, _T("Was in size/move")));
                _IH.inSizeMove = FALSE;
                IHFSMProc(IH_FSM_FOCUS_GAIN, 0);
            }
        }
        break;
#endif //OS_WINNT

        default:
        {
            TRC_ERR((TB, _T("Unexpected message %d from UI"), msg));
        }
        break;
    }
#endif //OS_WINCE

    DC_END_FN();
    return;
}


/****************************************************************************/
/* Name:    IH_SetKeyboardImeStatus                                         */
/*                                                                          */
/* Purpose: Updates server-initiated keyboard IME states                    */
/*                                                                          */
/* Params:    IN      pData     size of ImeStatus                           */
/*            IN      dataLen - length of data                              */
/****************************************************************************/
DCVOID DCAPI CIH::IH_SetKeyboardImeStatus(DCUINT32 ImeOpen, DCUINT32 ImeConvMode)
{
    DC_BEGIN_FN("IH_SetKeyboardImeStatus");

#if defined(OS_WINNT)
    if (_pUt->_UT.F3AHVOasysDll.hInst &&
        _pUt->lpfnFujitsuOyayubiControl != NULL) {
        _pUt->lpfnFujitsuOyayubiControl(ImeOpen, ImeConvMode);
    }
#else
    DC_IGNORE_PARAMETER(ImeOpen);
    DC_IGNORE_PARAMETER(ImeConvMode);
#endif // OS_WINNT

    DC_END_FN();
}

//
// Called to notify the IH that we have entered fullscreen mode
//
VOID DCAPI CIH::IH_NotifyEnterFullScreen()
{
    if(_fCanUseKeyboardHook && 
       (UTREG_UI_KEYBOARD_HOOK_FULLSCREEN == _pUi->_UI.keyboardHookMode))
    {
        //Start keyboard hooking
        _fUseHookBypass = TRUE;
    }
}

//
// Called to notify the IH that we have left fullscreen mode
//
VOID DCAPI CIH::IH_NotifyLeaveFullScreen()
{
    if(_fCanUseKeyboardHook && 
       (UTREG_UI_KEYBOARD_HOOK_FULLSCREEN == _pUi->_UI.keyboardHookMode))
    {
        //Stop keyboard hooking
        _fUseHookBypass = FALSE;
    }
}

//
// Inject multiple VKEYS in an atomic way
//
DCVOID DCAPI CIH::IH_InjectMultipleVKeys(ULONG_PTR ihRequestPacket)
{
    PIH_INJECT_VKEYS_REQUEST pihIrp = (PIH_INJECT_VKEYS_REQUEST)ihRequestPacket;
    INT i;
    TS_INPUT_EVENT * pEvent;
    MSG msg;

    DC_BEGIN_FN("IH_InjectMultipleVKeys");

    if (!_IH.pInputPDU)
    {
        //
        // This can happen if we're in the wrong state e.g IH_Disable
        //
        TRC_ERR((TB,_T("Called when no pInputPDU available")));
        pihIrp->fReturnStatus = FALSE;
        return;
    }

    //Flush any current input packet
    _IH.priorityEventsQueued = TRUE;
    IHMaybeSendPDU();


    //Clear any keyboard state
    if (_IH.pInputPDU->numberEvents > 0)
    {
        TRC_NRM((TB, _T("Cannot clear sync as the packet is not empty")));
        return;
    }

    //
    // Inject a Tab-up (the official clear-menu highlighting key because it
    // happens normally when alt-tabbing) before we sync. That way if
    // we thought the alt key was down when we sync, the server injected
    // alt up won't highlight the menu
    //

    IHInjectVKey(WM_SYSKEYUP, VK_TAB);

    //
    // Add the Sync event, setting toggles for CapsLock, NumLock and
    // ScrollLock.
    //
    TRC_DBG((TB, _T("Add sync event")));
    pEvent = &(_IH.pInputPDU->eventList[_IH.pInputPDU->numberEvents]);
    DC_MEMSET(pEvent, 0, sizeof(TS_INPUT_EVENT));

    pEvent->messageType = TS_INPUT_EVENT_SYNC;
    pEvent->eventTime = _pUt->UT_GetCurrentTimeMS();
    pEvent->u.sync.toggleFlags = 0;

    _IH.pInputPDU->numberEvents++;
    TS_DATAPKT_LEN(_IH.pInputPDU) += sizeof(TS_INPUT_EVENT);
    TS_UNCOMP_LEN(_IH.pInputPDU) += sizeof(TS_INPUT_EVENT);

    //
    // Construct dummy message for IHAddEventToPDU.
    //
    msg.hwnd = NULL;
    msg.lParam = 0;
    msg.wParam = 0;

#ifdef OS_WINNT
    //
    // Initialize the state of the Alt & Ctrl keys to up.
    //
    _IH.dwModifierKeyState = 0;
#endif

    //Dummy message
    IHAddEventToPDU(&msg);
    _IH.priorityEventsQueued = TRUE;
    IHMaybeSendPDU();


    //
    //Now send our injected keys
    //

    for(i=0; i< pihIrp->numKeys; i++)
    {
        IHInjectKey(pihIrp->pfArrayKeyUp[i] ? WM_KEYUP : WM_KEYDOWN,
                    0, //VKEY is ignored
                    (DCUINT16)pihIrp->plKeyData[i]);
    }

    //Sync tor restore keyboard state
    IHSync();

    pihIrp->fReturnStatus = TRUE;

    DC_END_FN();
}

#ifdef SMART_SIZING
/****************************************************************************/
/* Name:      IH_MainWindowSizeChange                                       */
/*                                                                          */
/* Purpose:   Remembers the size of the container for scaling               */
/****************************************************************************/
DCVOID DCAPI CIH::IH_MainWindowSizeChange(ULONG_PTR msg)
{
    DCSIZE desktopSize;
    DCUINT width;
    DCUINT height;

    width  = LOWORD(msg);
    height = HIWORD(msg);

    if (_pUi) {

        _pUi->UI_GetDesktopSize(&desktopSize);

        if (width <= desktopSize.width) {
            _scaleSize.width = width;
        } else {
            // full screen, or other times the window is bigger than the 
            // display resolution
            _scaleSize.width = desktopSize.width;
        }

        // Similarly
        if (height <= desktopSize.height) {
            _scaleSize.height = height;
        } else {
            _scaleSize.height = desktopSize.height;
        }
    }
}
#endif // SMART_SIZING
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\fsapi.cpp ===
/**MOD+**********************************************************************/
/* Module:    fsapi.cpp                                                     */
/*                                                                          */
/* Purpose:   Font Sender API functions                                     */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/

#include <adcg.h>
extern "C" {
#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "afsapi"
#include <atrcapi.h>
}

#include "autil.h"
#include "wui.h"
#include "cd.h"
#include "fs.h"
#include "sl.h"


CFS::CFS(CObjs* objs)
{
    _pClientObjects = objs;
}


CFS::~CFS()
{
}

/****************************************************************************/
// FS_Init                                                       
//                                                                          
// Initialize Font Sender                                        
/****************************************************************************/
VOID DCAPI CFS::FS_Init(VOID)
{
    DC_BEGIN_FN("FS_Init");

    _pSl  = _pClientObjects->_pSlObject;
    _pUt  = _pClientObjects->_pUtObject;
    _pUi  = _pClientObjects->_pUiObject;

    /************************************************************************/
    /* Initialize FS data                                                   */
    /************************************************************************/
    TRC_DBG((TB, _T("FS Initialize")));

    _FS.sentFontPDU = FALSE;

    DC_END_FN();
} /* FS_Init */

/****************************************************************************/
// FS_Term                                                                                                                                 
// 
// This is an empty function since we don't enumerate fonts anymore.  We
// use glyphs instead of fonts for text display.  We still keep FS_Term
// is to have a symmetric function with FS_Init
/****************************************************************************/
VOID DCAPI CFS::FS_Term(VOID)
{
    DC_BEGIN_FN("FS_Term");

    TRC_DBG((TB, _T("Empty FS_Term")));
    
    DC_END_FN();
} /* FS_Term */

/****************************************************************************/
// FS_Enable                                                     
//
// This is an empty function since we don't enumerate fonts anymore.  We
// use glyphs instead of fonts for text display.  We still keep FS_Enable
// is to have a symmetric function with FS_Disable                                                                        
/****************************************************************************/
VOID DCAPI CFS::FS_Enable(VOID)
{
    DC_BEGIN_FN("FS_Enable");

    TRC_DBG((TB, _T("Empty FS_Enable")));
    
    DC_END_FN();
} /* FS_Enable */

/****************************************************************************/
// FS_Disable                                                   
//                                                                       
// Disable _FS.                                                  
/****************************************************************************/
VOID DCAPI CFS::FS_Disable(VOID)
{
    DC_BEGIN_FN("FS_Disable");

    TRC_NRM((TB, _T("Disabled")));

    // reset sentFontPDU flag
    _FS.sentFontPDU = FALSE;

    DC_END_FN();
} /* FS_Disable */

/****************************************************************************/
// FS_SendZeroFontList
//
// Attempts to send an empty FontList PDU. The zero-font packet maintains
// backward compatibility with RDP 4.0 servers where RDPWD waits on the
// font list packet to arrive before allowing the session to continue.
// Font support is otherwise not required, so we can send zero fonts.
/****************************************************************************/
DCVOID DCAPI CFS::FS_SendZeroFontList(DCUINT unusedParm)
{
    unsigned short PktLen;
    SL_BUFHND hBuffer;
    PTS_FONT_LIST_PDU pFontListPDU;

    DC_BEGIN_FN("FS_SendFontList");

    DC_IGNORE_PARAMETER(unusedParm);

    // Only send font PDU if we haven't already done so
    if (!_FS.sentFontPDU) {
        PktLen = sizeof(TS_FONT_LIST_PDU) - sizeof(TS_FONT_ATTRIBUTE);
        if (_pSl->SL_GetBuffer(PktLen, (PPDCUINT8)&pFontListPDU, &hBuffer)) {
            TRC_NRM((TB, _T("Successfully alloc'd font list packet")));

            pFontListPDU->shareDataHeader.shareControlHeader.pduType =
                    TS_PDUTYPE_DATAPDU | TS_PROTOCOL_VERSION;
            pFontListPDU->shareDataHeader.shareControlHeader.totalLength = PktLen;
            pFontListPDU->shareDataHeader.shareControlHeader.pduSource =
                    _pUi->UI_GetClientMCSID();
            pFontListPDU->shareDataHeader.shareID = _pUi->UI_GetShareID();
            pFontListPDU->shareDataHeader.pad1 = 0;
            pFontListPDU->shareDataHeader.streamID = TS_STREAM_LOW;
            pFontListPDU->shareDataHeader.pduType2 = TS_PDUTYPE2_FONTLIST;
            pFontListPDU->shareDataHeader.generalCompressedType = 0;
            pFontListPDU->shareDataHeader.generalCompressedLength = 0;

            pFontListPDU->numberFonts = 0;
            pFontListPDU->totalNumFonts = 0;
            pFontListPDU->listFlags = TS_FONTLIST_FIRST | TS_FONTLIST_LAST;
            pFontListPDU->entrySize = sizeof(TS_FONT_ATTRIBUTE);

            TRC_NRM((TB, _T("Send zero length font list")));
            
            _pSl->SL_SendPacket((PDCUINT8)pFontListPDU, PktLen, RNS_SEC_ENCRYPT,
                          hBuffer, _pUi->UI_GetClientMCSID(), _pUi->UI_GetChannelID(),
                          TS_MEDPRIORITY);

            _FS.sentFontPDU = TRUE;
        }
        else {
            // If we fail to allocate a buffer then we will try again when we get
            // an UH_OnBufferAvailable() on WinSock FD_WRITE.
            TRC_ALT((TB, _T("Failed to alloc font list packet")));
            pFontListPDU = NULL;
        }
    }
    
    DC_END_FN();
} /* FS_SendZeroFontList */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\fs.h ===
/**MOD+**********************************************************************/
/* Module:    fs.h                                                          */
/*                                                                          */
/* Purpose:   Header for Font Sender Class                                  */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1999                             */
/*                                                                          */
/****************************************************************************/

#ifndef _H_FS
#define _H_FS
extern "C" {
    #include <adcgdata.h>
}

#include "objs.h"
#include "mcs.h"

/**STRUCT+*******************************************************************/
/* Structure: FS_GLOBAL_DATA                                                */
/*                                                                          */
/* Description: Font Sender global data                                     */
/****************************************************************************/
typedef struct tagFS_GLOBAL_DATA
{
    /************************************************************************/
    /* Internal state flags.                                                */
    /************************************************************************/
    DCBOOL                  sentFontPDU;
    
} FS_GLOBAL_DATA, DCPTR PFS_GLOBAL_DATA;


class CSL;
class CUT;
class CUI;

class CFS
{
public:
    CFS(CObjs* objs);
    ~CFS();


public:
    //
    // API
    //

    VOID DCAPI FS_Init(VOID);
    VOID DCAPI FS_Term(VOID);
    VOID DCAPI FS_Enable(VOID);
    VOID DCAPI FS_Disable(VOID);
    VOID DCAPI FS_SendZeroFontList(UINT unusedParm);

public:
    //
    // Data members
    //

    FS_GLOBAL_DATA _FS;

private:
    CSL* _pSl;
    CUT* _pUt;
    CUI* _pUi;

private:
    CObjs* _pClientObjects;

};

#endif //_H_FS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\gh.h ===
/****************************************************************************/
// wghapi.h
//
// Glyph Handler public types, constants
//
// Copyright (C) 1997-1999 Microsoft Corporation
/****************************************************************************/


#ifndef _H_GH_
#define _H_GH_

extern "C" {
    #include <aordprot.h>
}
#include "or.h"

#define GH_TEXT_BUFFER_SIZE     1024
#define FIFTEEN_BITS            ((1L << 15)-1)


// flAccel flags for STROBJ

// SO_FLAG_DEFAULT_PLACEMENT // defult inc vectors used to position chars
// SO_HORIZONTAL             // "left to right" or "right to left"
// SO_VERTICAL               // "top to bottom" or "bottom to top"
// SO_REVERSED               // set if horiz & "right to left" or if vert &  "bottom to top"
// SO_ZERO_BEARINGS          // all glyphs have zero a and c spaces
// SO_CHAR_INC_EQUAL_BM_BASE // base == cx for horiz, == cy for vert.
// SO_MAXEXT_EQUAL_BM_SIDE   // side == cy for horiz, == cx for vert.

// do not substitute device font for tt font even if device font sub table
// tells the driver this should be done

// SO_DO_NOT_SUBSTITUTE_DEVICE_FONT

#define SO_FLAG_DEFAULT_PLACEMENT        0x00000001
#define SO_HORIZONTAL                    0x00000002
#define SO_VERTICAL                      0x00000004
#define SO_REVERSED                      0x00000008
#define SO_ZERO_BEARINGS                 0x00000010
#define SO_CHAR_INC_EQUAL_BM_BASE        0x00000020
#define SO_MAXEXT_EQUAL_BM_SIDE          0x00000040
#define SO_DO_NOT_SUBSTITUTE_DEVICE_FONT 0x00000080
#define SO_GLYPHINDEX_TEXTOUT            0x00000100


#ifdef DC_DEBUG

#define GHFRAGRESET(x)      g_Fragment = x
#define GHFRAGLEFT(x)       g_FragmentLeft[g_Fragment] = x
#define GHFRAGRIGHT(x)      g_FragmentRight[g_Fragment++] = x

#else

#define GHFRAGRESET(x)
#define GHFRAGLEFT(x)
#define GHFRAGRIGHT(x)

#endif





#if defined(OS_WINCE) || defined(OS_WINNT)

const ULONG gTextLeftMask[8][2] =
{
    {0x00000000,0x00000000},
    {0xffffff00,0xffffffff},
    {0xffff0000,0xffffffff},
    {0xff000000,0xffffffff},
    {0x00000000,0xffffffff},
    {0x00000000,0xffffff00},
    {0x00000000,0xffff0000},
    {0x00000000,0xff000000}
};

const ULONG gTextRightMask[8][2] = 
{
    {0x00000000,0x00000000},
    {0x000000ff,0x00000000},
    {0x0000ffff,0x00000000},
    {0x00ffffff,0x00000000},
    {0xffffffff,0x00000000},
    {0xffffffff,0x000000ff},
    {0xffffffff,0x0000ffff},
    {0xffffffff,0x00ffffff}
};

const ULONG TranTable [] =
{
    0x00000000,
    0xff000000,
    0x00ff0000,
    0xffff0000,
    0x0000ff00,
    0xff00ff00,
    0x00ffff00,
    0xffffff00,
    0x000000ff,
    0xff0000ff,
    0x00ff00ff,
    0xffff00ff,
    0x0000ffff,
    0xff00ffff,
    0x00ffffff,
    0xffffffff
};

#endif // defined(OS_WINCE) || defined(OS_WINNT)

//    the following definitions are used by the glyph clipping functions

#define GLYPH_CLIP_NONE     0   // No clipping is necessary
#define GLYPH_CLIP_PARTIAL  1   // The glyph is partially clipped 
#define GLYPH_CLIP_ALL      2   // The glyph is completly clipped

typedef RECT RECTCLIPOFFSET, *PRECTCLIPOFFSET;


class CUH;
class CCLX;

#include "objs.h"



class CGH
{
public:
    CGH(CObjs* objs);
    ~CGH();

public:

    DCVOID DCAPI GH_Init();

    //
    //API
    //
    HRESULT DCAPI GH_GlyphOut(LPINDEX_ORDER pOrder, LPVARIABLE_INDEXBYTES pVariableBytes);


private:
    //
    // Internal
    //
    
    // flAccel flags for STROBJ

    // SO_FLAG_DEFAULT_PLACEMENT // defult inc vectors used to position chars
    // SO_HORIZONTAL             // "left to right" or "right to left"
    // SO_VERTICAL               // "top to bottom" or "bottom to top"
    // SO_REVERSED               // set if horiz & "right to left" or if vert &  "bottom to top"
    // SO_ZERO_BEARINGS          // all glyphs have zero a and c spaces
    // SO_CHAR_INC_EQUAL_BM_BASE // base == cx for horiz, == cy for vert.
    // SO_MAXEXT_EQUAL_BM_SIDE   // side == cy for horiz, == cx for vert.
    
    // do not substitute device font for tt font even if device font sub table
    // tells the driver this should be done
    
    // SO_DO_NOT_SUBSTITUTE_DEVICE_FONT
    
    #define SO_FLAG_DEFAULT_PLACEMENT        0x00000001
    #define SO_HORIZONTAL                    0x00000002
    #define SO_VERTICAL                      0x00000004
    #define SO_REVERSED                      0x00000008
    #define SO_ZERO_BEARINGS                 0x00000010
    #define SO_CHAR_INC_EQUAL_BM_BASE        0x00000020
    #define SO_MAXEXT_EQUAL_BM_SIDE          0x00000040
    #define SO_DO_NOT_SUBSTITUTE_DEVICE_FONT 0x00000080
    #define SO_GLYPHINDEX_TEXTOUT            0x00000100
    
    
    #ifdef DC_DEBUG
    
    #define GHFRAGRESET(x)      g_Fragment = x
    #define GHFRAGLEFT(x)       g_FragmentLeft[g_Fragment] = x
    #define GHFRAGRIGHT(x)      g_FragmentRight[g_Fragment++] = x
    
    #else
    
    #define GHFRAGRESET(x)
    #define GHFRAGLEFT(x)
    #define GHFRAGRIGHT(x)
    
    #endif
    
    
    
    void DCINTERNAL GHSlowOutputBuffer(LPINDEX_ORDER, PDCUINT8, ULONG, unsigned);

#ifdef DC_HICOLOR
VOID vSrcTranCopyS1D8_24(PBYTE, LONG, LONG, PBYTE, LONG, LONG, LONG, LONG, DCRGB);
VOID vSrcOpaqCopyS1D8_24(PBYTE, LONG, LONG, PBYTE, LONG, LONG, LONG, LONG, DCRGB, DCRGB);

VOID vSrcTranCopyS1D8_16(PBYTE, LONG, LONG, PBYTE, LONG, LONG, LONG, LONG, ULONG);
VOID vSrcOpaqCopyS1D8_16(PBYTE, LONG, LONG, PBYTE, LONG, LONG, LONG, LONG, ULONG, ULONG);
#endif

    VOID vSrcTranCopyS1D8(PBYTE, LONG, LONG, PBYTE, LONG, LONG, LONG, LONG, ULONG, ULONG);
    
    VOID vSrcOpaqCopyS1D8(PBYTE, LONG, LONG, PBYTE, LONG, LONG, LONG, LONG, ULONG, ULONG);
    
public:    
    static HRESULT draw_f_tb_no_to_temp_start (CGH* inst, LPINDEX_ORDER,unsigned,PDCUINT8 DCPTR, PDCUINT8,
                                         PDCINT,PDCINT,PDCUINT8,PDCUINT8,ULONG,unsigned, PDCUINT16, int *);
    
    static HRESULT draw_nf_tb_no_to_temp_start(CGH* inst, LPINDEX_ORDER,unsigned,PDCUINT8 DCPTR, PDCUINT8,
                                         PDCINT,PDCINT,PDCUINT8,PDCUINT8,ULONG,unsigned, PDCUINT16, int *);
    
    static HRESULT draw_f_ntb_o_to_temp_start (CGH* inst, LPINDEX_ORDER,unsigned,PDCUINT8 DCPTR, PDCUINT8,
                                         PDCINT,PDCINT,PDCUINT8,PDCUINT8,ULONG,unsigned, PDCUINT16, int *);
    
    static HRESULT draw_nf_ntb_o_to_temp_start(CGH* inst, LPINDEX_ORDER,unsigned,PDCUINT8 DCPTR, PDCUINT8,
                                         PDCINT,PDCINT,PDCUINT8,PDCUINT8,ULONG,unsigned, PDCUINT16, int *);

    inline PDCUINT8 GetGlyphClipBuffer(ULONG size)
    {
        if (_ClipGlyphBitsBufferSize >= size) {
            TRC_ASSERT((_pClipGlyphBitsBuffer!=NULL), 
                (TB, _T("The is _ClipGlyphBitsBufferSize NULL.")));
            return _pClipGlyphBitsBuffer;
        }

        if (_pClipGlyphBitsBuffer!=NULL) {        
            LocalFree(_pClipGlyphBitsBuffer);
        }
        
        _pClipGlyphBitsBuffer = (PDCUINT8)LocalAlloc(LMEM_FIXED, size);
        _ClipGlyphBitsBufferSize = (_pClipGlyphBitsBuffer == NULL) ? 0 : size;

        return _pClipGlyphBitsBuffer;
    }
private:
    //
    // Private data members
    //
    #ifdef  DC_DEBUG
    unsigned g_Fragment;
    int      g_FragmentLeft[256];
    int      g_FragmentRight[256];
    unsigned g_ulBytes;
    #endif
    
public:
    //Needs to be accessible by CGH:: static functions
    CUH* _pUh;
private:
    CCLX* _pClx;
    CUT*  _pUt;

private:
    CObjs* _pClientObjects;

    PDCUINT8 _pClipGlyphBitsBuffer;
    ULONG _ClipGlyphBitsBufferSize;
  
};


typedef HRESULT (*PFN_MASTERTEXTTYPE) (CGH* inst, LPINDEX_ORDER,unsigned,PDCUINT8 DCPTR, PDCUINT8,
                                         PDCINT,PDCINT,PDCUINT8,PDCUINT8,ULONG,unsigned, PDCUINT16, int *);


extern const PFN_MASTERTEXTTYPE MasterTextTypeTable[8];

#endif  //_H_GH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\ghapi.cpp ===
/****************************************************************************/
// ghapi.cpp
//
// Glyph handler - Windows specific
//
// Copyright (C) 1997-1999 Microsoft Corporation
/****************************************************************************/

#include <adcg.h>
extern "C" {

#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "wghapi"
#include <atrcapi.h>
}
#define TSC_HR_FILEID TSC_HR_GHAPI_CPP

#include "autil.h"
#include "gh.h"
#include "uh.h"
#include "clx.h"


static const PFN_MASTERTEXTTYPE MasterTextTypeTable[8] =
{
    CGH::draw_nf_ntb_o_to_temp_start,
    CGH::draw_f_ntb_o_to_temp_start,
    CGH::draw_nf_ntb_o_to_temp_start,
    CGH::draw_f_ntb_o_to_temp_start,
    CGH::draw_nf_tb_no_to_temp_start,
    CGH::draw_f_tb_no_to_temp_start,
    CGH::draw_nf_ntb_o_to_temp_start,
    CGH::draw_f_ntb_o_to_temp_start
};


CGH::CGH(CObjs* objs)
{
    _pClientObjects = objs;
    _pClipGlyphBitsBuffer = NULL;
    _ClipGlyphBitsBufferSize = 0;
}

CGH::~CGH()
{
    if (_pClipGlyphBitsBuffer!=NULL) {        
        LocalFree(_pClipGlyphBitsBuffer);
    }
}

DCVOID DCAPI CGH::GH_Init(DCVOID)
{
    DC_BEGIN_FN("GH_GlyphOut");
    _pUh  = _pClientObjects->_pUHObject;
    _pClx = _pClientObjects->_pCLXObject;
    _pUt  = _pClientObjects->_pUtObject;

    DC_END_FN();
}

/****************************************************************************/
/* Name:      GH_GlyphOut                                                   */
/*                                                                          */
/* Purpose:   Process glyph output requests                                 */
/*                                                                          */
/* Returns:   Process input event TRUE / FALSE                              */
/****************************************************************************/
HRESULT DCAPI CGH::GH_GlyphOut(
        LPINDEX_ORDER pOrder,
        LPVARIABLE_INDEXBYTES pVariableBytes)
{
    HRESULT hr = E_FAIL; 
    BYTE     szTextBuffer[GH_TEXT_BUFFER_SIZE];
    BYTE     ajFrag[256];
    UINT16   ajUnicode[256];
    unsigned ulBufferWidth;
    unsigned fDrawFlags;
    PDCUINT8 pjBuffer;
    PDCUINT8 pjEndBuffer;
    unsigned crclFringe;
    RECT     arclFringe[4];
    unsigned i;
    int      x;
    int      y;
    PDCUINT8 pjData;
    PDCUINT8 pjDataEnd;
    unsigned iGlyph;
    unsigned cacheIndex;
    unsigned cbFrag;
    PDCUINT8 pjFrag;
    PDCUINT8 pjFragEnd;
    int      dx;
    INT16    delta;
    ULONG    BufferAlign;
    ULONG    BufferOffset;
    unsigned ulBytes;
    unsigned ulHeight;
    PFN_MASTERTEXTTYPE  pfnMasterType;
    
    DC_BEGIN_FN("GH_GlyphOut");

    dx = 0;

    // SECURITY 558128: GH_GlyphOut must verify data in VARAIBLE_INDEXBYTES 
    // parameter which is defined as 255 elements
    if (255 < pVariableBytes->len) {
        TRC_ABORT(( TB, _T("variable bytes len too long %u"), 
            pVariableBytes->len));
        hr = E_TSC_CORE_LENGTH;
        DC_QUIT;
    }

    /************************************************************************/
    // Alloc a temp work buffer -- use the stack buffer if large enough, or
    // alloc heap memory if need be.
    /************************************************************************/
    // Make the buffer width WORD aligned.
    ulBufferWidth  = (unsigned)(((pOrder->BkRight + 31) & ~31) -
            (pOrder->BkLeft & ~31)) >> 3;
    ulHeight = (unsigned)(pOrder->BkBottom - pOrder->BkTop);
    if ((ulBufferWidth <= FIFTEEN_BITS) && (ulHeight <= FIFTEEN_BITS)) {
        ulBytes = ulBufferWidth * ulHeight + 64;

#ifdef DC_DEBUG
        g_ulBytes = ulBytes;
#endif

        // If the temp buffer is big enough, use it. Otherwise attempt to
        // allocate enough memory to satisfy the request.
        if (ulBytes <= (sizeof(szTextBuffer) - 20)) {
            pjBuffer = szTextBuffer;
            memset(szTextBuffer, 0, ulBytes);
        }
        else {
            TRC_NRM((TB, _T("Allocating %d byte temp glyph buffer"), ulBytes));
            pjBuffer = (PDCUINT8)UT_Malloc( _pUt, ulBytes);
            if (pjBuffer != NULL) {
                memset(pjBuffer, 0, ulBytes);
            }
            else {
                TRC_NRM((TB, _T("Unable to alloc temp glyph buffer")));
                DC_QUIT;
            }
        }
    }
    else {
        TRC_NRM((TB, _T("Temp glyph buffer calc overflow")));
        hr = E_TSC_UI_GLYPH;
        DC_QUIT;
    }

    pjEndBuffer = pjBuffer + ulBytes;

#ifdef DC_HICOLOR
    TRC_NRM((TB, _T("Glyph order w %d, h %d, fc %#06lx, bc %#06lx"),
                 ulBufferWidth, ulHeight, pOrder->ForeColor, pOrder->BackColor));
#endif

    /************************************************************************/
    // Clear the fringe opaque rect if need be.
    /************************************************************************/
    // crclFringe ends up holding the number of fringe rectangles to
    // post-process.
    crclFringe = 0;

    if (pOrder->OpTop < pOrder->OpBottom) {
        // Establish solid brush.
        UHUseBrushOrg(0, 0, _pUh);
        _pUh->UHUseSolidPaletteBrush(pOrder->ForeColor);

        // If the background brush is a solid brush, we need to compute the
        // fringe opaque area outside the text rectangle and include the
        // remaining rectangle in the text output. The fringe rectangles will
        // be output last to reduce flickering when a string is "moved"
        // continuously across the screen.
        if (pOrder->BrushStyle == BS_SOLID) {
            // Top fragment
            if (pOrder->BkTop > pOrder->OpTop) {
                arclFringe[crclFringe].left   = (int) pOrder->OpLeft;
                arclFringe[crclFringe].top    = (int) pOrder->OpTop;
                arclFringe[crclFringe].right  = (int) pOrder->OpRight;
                arclFringe[crclFringe].bottom = (int) pOrder->BkTop;
                crclFringe++;
            }

            // Left fragment
            if (pOrder->BkLeft > pOrder->OpLeft) {
                arclFringe[crclFringe].left   = (int) pOrder->OpLeft;
                arclFringe[crclFringe].top    = (int) pOrder->BkTop;
                arclFringe[crclFringe].right  = (int) pOrder->BkLeft;
                arclFringe[crclFringe].bottom = (int) pOrder->BkBottom;
                crclFringe++;
            }

            // Right fragment
            if (pOrder->BkRight < pOrder->OpRight) {
                arclFringe[crclFringe].left   = (int) pOrder->BkRight;
                arclFringe[crclFringe].top    = (int) pOrder->BkTop;
                arclFringe[crclFringe].right  = (int) pOrder->OpRight;
                arclFringe[crclFringe].bottom = (int) pOrder->BkBottom;
                crclFringe++;
            }

            // Bottom fragment
            if (pOrder->BkBottom < pOrder->OpBottom) {
                arclFringe[crclFringe].left   = (int) pOrder->OpLeft;
                arclFringe[crclFringe].top    = (int) pOrder->BkBottom;
                arclFringe[crclFringe].right  = (int) pOrder->OpRight;
                arclFringe[crclFringe].bottom = (int) pOrder->OpBottom;
                crclFringe++;
            }
        }
        else {
            // If the background brush is a pattern brush, we will output the
            // whole rectangle now.
            PatBlt(_pUh->_UH.hdcDraw,
                   (int)pOrder->OpLeft,
                   (int)pOrder->OpTop,
                   (int)(pOrder->OpRight - pOrder->OpLeft),
                   (int)(pOrder->OpBottom - pOrder->OpTop),
                   PATCOPY);
        }
    }


    /************************************************************************/
    // Get fixed pitch, overlap, and top & bottom Y alignment flags.
    /************************************************************************/
    if ((pOrder->flAccel & SO_HORIZONTAL) &&
            !(pOrder->flAccel & SO_REVERSED)) {
        fDrawFlags = ((pOrder->ulCharInc != 0) |
                 (((pOrder->flAccel & 
                     (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT)) !=
                     (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT)) << 1) |
                 (((pOrder->flAccel &
                     (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT | SO_MAXEXT_EQUAL_BM_SIDE)) ==
                     (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT | SO_MAXEXT_EQUAL_BM_SIDE)) << 2));
    }
    else {
        fDrawFlags = 0;
    }
    

    /************************************************************************/
    /* Draw the text into the temp buffer by selecting and calling the      */
    /* appropriate glyph dispatch routine                                   */
    /************************************************************************/
    pfnMasterType = MasterTextTypeTable[fDrawFlags];

    x = (int)pOrder->x;
    y = (int)pOrder->y;

    pjData = &(pVariableBytes->arecs[0].byte);
    pjDataEnd = pjData + pVariableBytes->len;

    BufferAlign  = (pOrder->BkLeft & 31);
    BufferOffset = (pOrder->BkLeft - BufferAlign);

    iGlyph = 0;

    GHFRAGRESET(0);

    while (pjData < pjDataEnd) {
        /********************************************************************/
        /* 'Add Fragment'                                                   */
        /********************************************************************/
        if (*pjData == ORD_INDEX_FRAGMENT_ADD) {
            HPUHFRAGCACHE        pCache;
            HPDCUINT8            pCacheEntryData;
            PUHFRAGCACHEENTRYHDR pCacheEntryHdr;

            pjData++;

            CHECK_READ_N_BYTES(pjData, pjDataEnd, 2, hr,
                ( TB, _T("reading glyph data off end")));

            cacheIndex = *pjData++;
            hr = _pUh->UHIsValidFragmentCacheIndex(cacheIndex);
            DC_QUIT_ON_FAIL(hr);
            
            cbFrag = *pjData++;

            // Add the fragment to the cache.
            pCache = &_pUh->_UH.fragCache;

            if (cbFrag > pCache->cbEntrySize) {
                TRC_ABORT((TB,_T("Invalid fragment size")));
                hr = E_TSC_CORE_LENGTH;
                DC_QUIT;
            }
            
            pCacheEntryHdr  = &(pCache->pHdr[cacheIndex]);
            pCacheEntryHdr->cbFrag = cbFrag;
            pCacheEntryHdr->cacheId = pOrder->cacheId;

            pCacheEntryData = &(pCache->pData[cacheIndex *
                    pCache->cbEntrySize]);

            CHECK_READ_N_BYTES_2ENDED(pjData - cbFrag - 3, &(pVariableBytes->arecs[0].byte), 
                pjDataEnd, cbFrag, hr, (TB,_T("Fragment for ADD begins before data")))
            memcpy(pCacheEntryData, pjData - cbFrag - 3, cbFrag);

            if (pOrder->ulCharInc == 0) {
                if ((pOrder->flAccel & SO_CHAR_INC_EQUAL_BM_BASE) == 0) {
                    if (pCacheEntryData[1] & 0x80) {
                        pCacheEntryData[2] = 0;
                        pCacheEntryData[3] = 0;
                    }
                    else {
                        pCacheEntryData[1] = 0;
                    }
                }
            }
        }

        /********************************************************************/
        /* 'Use Fragment'                                                   */
        /********************************************************************/
        else if (*pjData == ORD_INDEX_FRAGMENT_USE) {
            PUHFRAGCACHE         pCache;
            PDCUINT8             pCacheEntryData;
            PUHFRAGCACHEENTRYHDR pCacheEntryHdr;
            unsigned             cbFrag;

            pjData++;

            CHECK_READ_ONE_BYTE(pjData, pjDataEnd, hr, 
                ( TB, _T("reading glyph data off end")));

            cacheIndex = *pjData++;
            hr = _pUh->UHIsValidFragmentCacheIndex(cacheIndex);
            DC_QUIT_ON_FAIL(hr);

            if ((pOrder->ulCharInc == 0) &&
                   ((pOrder->flAccel & SO_CHAR_INC_EQUAL_BM_BASE) == 0)) {

                CHECK_READ_ONE_BYTE(pjData, pjDataEnd, hr, 
                    ( TB, _T("reading glyph data off end")))
                delta = (*(PDCINT8)pjData++);
                if (delta & 0x80) {
                    CHECK_READ_N_BYTES(pjData, pjDataEnd, sizeof(DCINT16), hr, 
                        ( TB, _T("reading glyph data off end")))
                    delta = (*(PDCINT16)pjData);
                    pjData += sizeof(DCINT16);
                }
                    
                if (pOrder->flAccel & SO_HORIZONTAL)
                    x += delta;
                else
                    y += delta;
            }

            // Get the fragment from the cache.
            pCache = &_pUh->_UH.fragCache;
            pCacheEntryHdr  = &(pCache->pHdr[cacheIndex]);
            pCacheEntryData = &(pCache->pData[cacheIndex *
                    pCache->cbEntrySize]);

            if (pCacheEntryHdr->cacheId != pOrder->cacheId) {
                TRC_ABORT((TB,_T("Fragment cache id mismatch")));
                hr = E_TSC_CORE_CACHEVALUE;
                DC_QUIT;
            }
            
            cbFrag = (unsigned)pCacheEntryHdr->cbFrag;
            if (cbFrag > sizeof(ajFrag)) {
                TRC_ABORT(( TB, _T("cbFrag > sizeof (ajFrag)")));
                hr = E_TSC_CORE_LENGTH;
                DC_QUIT;
            }
            memcpy(ajFrag, pCacheEntryData, cbFrag);

            GHFRAGLEFT(x);
            pjFrag = ajFrag;
            pjFragEnd = &ajFrag[cbFrag];

            while (pjFrag < pjFragEnd) {
                hr = pfnMasterType(this, pOrder, iGlyph++, &pjFrag, pjFragEnd, &x, &y,
                        pjBuffer, pjEndBuffer, BufferOffset, ulBufferWidth, ajUnicode, &dx);
                DC_QUIT_ON_FAIL(hr);
            }

            if (pOrder->flAccel & SO_CHAR_INC_EQUAL_BM_BASE)
                GHFRAGRIGHT(x);
            else
                GHFRAGRIGHT(x+dx);
        }

        /********************************************************************/
        /* Normal glyph out                                                 */
        /********************************************************************/
        else {
            int dummy;
            /****************************************************************/
            /* if we have more than 255 glyphs, we won't get any unicode    */
            /* beyond 255 glyphs because ajUnicode has length of 256        */
            /****************************************************************/
            if (iGlyph < 255) {
                hr = pfnMasterType(this, pOrder, iGlyph++, &pjData, pjDataEnd, &x, &y,
                        pjBuffer, pjEndBuffer, BufferOffset, ulBufferWidth, ajUnicode, &dummy);
                DC_QUIT_ON_FAIL(hr);
            } else {
                hr = pfnMasterType(this, pOrder, iGlyph++, &pjData, pjDataEnd, &x, &y,
                        pjBuffer, pjEndBuffer, BufferOffset, ulBufferWidth, NULL, &dummy);
                DC_QUIT_ON_FAIL(hr);
            }
        }
    }

    if (iGlyph < 255)
        ajUnicode[iGlyph] = 0;
    else
        ajUnicode[255] = 0;


    /************************************************************************/
    /* Draw the temp buffer to the output device                            */
    /************************************************************************/
#if defined(OS_WINCE) || defined(OS_WINNT)
    /************************************************************************/
    // For WinCE, Win9x, and NT use a fast path if possible.
    /************************************************************************/
#ifdef USE_GDIPLUS
    if (_pUh->_UH.bmShadowBits != NULL && 
            _pUh->_UH.protocolBpp == _pUh->_UH.shadowBitmapBpp &&
            _pUh->_UH.hdcDraw == _pUh->_UH.hdcShadowBitmap) {
#else // USE_GDIPLUS
    if (_pUh->_UH.bmShadowBits != NULL && 
            _pUh->_UH.hdcDraw == _pUh->_UH.hdcShadowBitmap) {
#endif // USE_GDIPLUS
        INT32  left, right, top, bottom;
        UINT32 dx, dy;

        if (_pUh->_UH.rectReset) {
            left   = pOrder->BkLeft;
            right  = pOrder->BkRight;
            top    = pOrder->BkTop;
            bottom = pOrder->BkBottom;
        }
        else {
            left   = DC_MAX(pOrder->BkLeft,   _pUh->_UH.lastLeft);
            right  = DC_MIN(pOrder->BkRight,  _pUh->_UH.lastRight + 1);
            top    = DC_MAX(pOrder->BkTop,    _pUh->_UH.lastTop);
            bottom = DC_MIN(pOrder->BkBottom, _pUh->_UH.lastBottom + 1);
        }
        
        //
        //    Fix for bug#699321. In case the shadow bitmap is enabled and we will
        //    use the "performant" functions to copy the glyph fragment into
        //    the shadow buffer we have to make sure that the dest rect is clipped 
        //    to the screen area. If it is not we might overflow the shadow screen 
        //    buffer. The server should not send us orders that will result in 
        //    the dest rect not being fully contained by the screen area. This is
        //    purely a security surface reduction fix.
        //
        if ((left < right) && (top < bottom) && 
            (left >= 0) && (right <= (INT32)_pUh->_UH.bmShadowWidth) && 
            (top >= 0) && (bottom <= (INT32)_pUh->_UH.bmShadowHeight)) {
#ifdef OS_WINNT
            // On NT and Win9x we need to make sure all GDI buffered output
            // is flushed out to the offscreen bitmap.
            GdiFlush();
#endif

            dx = (UINT32)(left - pOrder->BkLeft);
            dy = (UINT32)(top - pOrder->BkTop);

            if (pOrder->OpTop < pOrder->OpBottom) {
#ifdef DC_HICOLOR
    TRC_NRM((TB, _T("Opaque glyph order w %d, h %d, fc %#06lx, bc %#06lx"),
                 ulBufferWidth, ulHeight, pOrder->ForeColor, pOrder->BackColor));

                if (_pUh->_UH.protocolBpp == 24)
                {
                    vSrcOpaqCopyS1D8_24(pjBuffer + dy * ulBufferWidth,
                                        BufferAlign + dx,
                                        ulBufferWidth,
                                        _pUh->_UH.bmShadowBits + top * _pUh->_UH.bmShadowWidth * _pUh->_UH.copyMultiplier,
                                        left,
                                        right,
                                        _pUh->_UH.bmShadowWidth,
                                        bottom - top,
                                        pOrder->BackColor.u.rgb,
                                        pOrder->ForeColor.u.rgb);
                }
                else if ((_pUh->_UH.protocolBpp == 16) || (_pUh->_UH.protocolBpp == 15))
                {
                    vSrcOpaqCopyS1D8_16(pjBuffer + dy * ulBufferWidth,
                                        BufferAlign + dx,
                                        ulBufferWidth,
                                        _pUh->_UH.bmShadowBits + top * _pUh->_UH.bmShadowWidth * _pUh->_UH.copyMultiplier,
                                        left,
                                        right,
                                        _pUh->_UH.bmShadowWidth,
                                        bottom - top,
                                        *((PDCUINT16)&(pOrder->BackColor)),
                                        *((PDCUINT16)&(pOrder->ForeColor)));
                }
                else
                {
#endif
                    vSrcOpaqCopyS1D8(pjBuffer + dy * ulBufferWidth,             // pointer to beginning of current scan line of src buffer
                                     BufferAlign + dx,                          // left (starting) pixel in src rectangle
                                     ulBufferWidth,                             // bytes from one src scan line to next
                                     _pUh->_UH.bmShadowBits + top * _pUh->_UH.bmShadowWidth,  // pointer to beginning of current scan line of Dst buffer
                                     left,                                      // left(first) dst pixel
                                     right,                                     // right(last) dst pixel
                                     _pUh->_UH.bmShadowWidth,                          // bytes from one Dst scan line to next
                                     bottom - top,                              // number of scan lines
                                     pOrder->BackColor.u.index,                 // Foreground color
                                     pOrder->ForeColor.u.index);                // Background color
#ifdef DC_HICOLOR
                }
#endif
            }
            else {
#ifdef DC_HICOLOR
                TRC_NRM((TB, _T("Transparent glyph order w %d, h %d, fc %#06lx, bc %#06lx"),
                             ulBufferWidth, ulHeight, pOrder->ForeColor, pOrder->BackColor));

                if (_pUh->_UH.protocolBpp == 24)
                {
                    vSrcTranCopyS1D8_24(pjBuffer + dy * ulBufferWidth,
                                        BufferAlign + dx,
                                        ulBufferWidth,
                                        _pUh->_UH.bmShadowBits + top * _pUh->_UH.bmShadowWidth * _pUh->_UH.copyMultiplier,
                                        left,
                                        right,
                                        _pUh->_UH.bmShadowWidth,
                                        bottom - top,
                                        pOrder->BackColor.u.rgb);
                }
                else if ((_pUh->_UH.protocolBpp == 16) || (_pUh->_UH.protocolBpp == 15))
                {
                    vSrcTranCopyS1D8_16(pjBuffer + dy * ulBufferWidth,
                                        BufferAlign + dx,
                                        ulBufferWidth,
                                        _pUh->_UH.bmShadowBits + top * _pUh->_UH.bmShadowWidth * _pUh->_UH.copyMultiplier,
                                        left,
                                        right,
                                        _pUh->_UH.bmShadowWidth,
                                        bottom - top,
                                        *((PDCUINT16)&(pOrder->BackColor)));
                }
                else
                {
#endif
                    vSrcTranCopyS1D8(pjBuffer + dy * ulBufferWidth,
                                     BufferAlign + dx,
                                     ulBufferWidth,
                                     _pUh->_UH.bmShadowBits + top * _pUh->_UH.bmShadowWidth,
                                     left,
                                     right,
                                     _pUh->_UH.bmShadowWidth,
                                     bottom - top,
                                     pOrder->BackColor.u.index,
                                     pOrder->ForeColor.u.index);
#ifdef DC_HICOLOR
                }
#endif
            }
        } else {
            if ((left > right) || (top > bottom)) {
                TRC_NRM((TB, _T("Non-ordered glyph paint rect (%d, %d, %d, %d)."),
                         left, top, right, bottom));
            } else if ((left == right) || (top == bottom)) {
                TRC_NRM((TB, _T("Zero width/height glyph paint rect (%d, %d, %d, %d)."), 
                        left, top, right, bottom)); 
            } else {
                TRC_ERR((TB, _T("Bad glyph paint rect (%d, %d, %d, %d)->(%d, %d)."), 
                        left, top, right, bottom, 
                        _pUh->_UH.bmShadowWidth, _pUh->_UH.bmShadowHeight)); 
            }
        }   
    }
    else
#endif // defined(OS_WINCE) || defined(OS_WINNT)
    {
#ifdef DC_HICOLOR
        TRC_NRM((TB, _T("Slow glyph order w %d, h %d, fc %#06lx, bc %#06lx"),
                     ulBufferWidth, ulHeight, pOrder->ForeColor, pOrder->BackColor));

#endif
        GHSlowOutputBuffer(pOrder, pjBuffer, BufferAlign, ulBufferWidth);
    }
    // Send the bitmap thru CLX
    _pClx->CLX_ClxGlyphOut((UINT)(ulBufferWidth << 3),
            (UINT)(pOrder->BkBottom - pOrder->BkTop), pjBuffer);

#ifdef DC_DEBUG
    // In debug, hatch the output yellow if the option is turned on.
    if (_pUh->_UH.hatchIndexPDUData) {
        unsigned i;

        for (i = 0; i < g_Fragment; i++)
            _pUh->UH_HatchRect((int)(g_FragmentLeft[i]),
                        (int)pOrder->BkTop,
                        (int)(g_FragmentRight[i]),
                        (int)pOrder->BkBottom,
                        UH_RGB_YELLOW,
                        UH_BRUSHTYPE_FDIAGONAL);
    }
#endif

    /************************************************************************/
    // Post-process draw fringe rects.
    /************************************************************************/
    for (i = 0; i < crclFringe; i++) {
        if (!PatBlt(_pUh->_UH.hdcDraw,
                    arclFringe[i].left, 
                    arclFringe[i].top, 
                    (int)(arclFringe[i].right - arclFringe[i].left),
                    (int)(arclFringe[i].bottom - arclFringe[i].top),
                    PATCOPY))
        {
            TRC_ERR((TB, _T("Glyph PatBlt failed")));
        }
    }


    /************************************************************************/
    /* Free up any memory we may have allocated for the temp buffer         */
    /************************************************************************/
    if (pjBuffer != szTextBuffer)
        UT_Free( _pUt, pjBuffer);


    /************************************************************************/
    /* Let the clx have a look-see at the unicode text data                 */
    /************************************************************************/
    if ( _pUh->_UH.hdcDraw == _pUh->_UH.hdcOffscreenBitmap ) {
        _pClx->CLX_ClxTextOut(ajUnicode, iGlyph, _pUh->_UH.hdcDraw, 
                              pOrder->BkLeft, pOrder->BkRight, pOrder->BkTop, pOrder->BkBottom);
    }
    else {
        _pClx->CLX_ClxTextOut(ajUnicode, iGlyph, NULL, 
                              pOrder->BkLeft, pOrder->BkRight, pOrder->BkTop, pOrder->BkBottom);
    }
    hr = S_OK;

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\ih.h ===
/**INC+**********************************************************************/
/* Header:    ih.h                                                          */
/*                                                                          */
/* Purpose:   Input Handler external functyion prototypes.                  */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1999                             */
/*                                                                          */
/****************************************************************************/

#ifndef _H_IH
#define _H_IH

extern "C" {
    #include <adcgdata.h>
    #include <at128.h>
}

#include "autil.h"
#include "wui.h"
#include "sl.h"
#include "cd.h"
#ifdef OS_WINCE
#include <ceconfig.h>
#endif

class CUI;
class CSL;
class CUH;
class CCD;
class CIH;
class COR;
class CFS;
class CUT;
class CCC;
class COP;

#include "objs.h"

#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "ih"

#define CHAR_BIT 8
#define BITMASK(b) (1 << ((b) % CHAR_BIT))
#define BITSLOT(b) ((b) / CHAR_BIT)
#define BITSET(a, b) ((a)[BITSLOT(b)] |= BITMASK(b))
#define BITTEST(a, b) ((a)[BITSLOT(b)] & BITMASK(b))
#define BITCLEAR(a, b) ((a)[BITSLOT(b)] &= (0xFF ^ BITMASK(b)))

//
// Time interval for bbar hotzone detection
// for unhide (in milliseconds)
//
#define IH_BBAR_UNHIDE_TIMEINTERVAL 250

#define IH_BBAR_HOTZONE_HEIGHT 5


//
// We pass this around in dwExtraInfo for keys we inject
// back into the local system.
//
#define IH_EXTRAINFO_IGNOREVALUE 0x13790DBA

#define IH_WM_HANDLE_LOCKDESKTOP (WM_APP+1)

/****************************************************************************/
/* Structure: IH_GLOBAL_DATA                                                */
/*                                                                          */
/* Description: Input Handler global data                                   */
/****************************************************************************/
typedef struct tagIH_GLOBAL_DATA
{
    DCBOOL         priorityEventsQueued;
    DCBOOL         syncRequired;
    DCBOOL         focusSyncRequired;
    HWND           inputCaptureWindow;
    DCUINT32       lastInputPDUSendTime;
    DCUINT32       lastFlowPDUSendTime;
    DCUINT         fsmState;
    INT_PTR        timerID;
    DCUINT         timerTickRate;

    PTS_INPUT_PDU  pInputPDU;
    SL_BUFHND      bufHandle;

    DCUINT32       minSendInterval; /* Min time between mousemove sends (ms)*/
    DCUINT32       eventsAtOnce;    /* Max events to pull off in one go     */
    DCUINT32       maxEventCount;   /* Max number of events in InputPDU     */
    DCUINT32       keepAliveInterval; /* keep-alive time (seconds)          */
#ifdef OS_WINCE
     DCUINT32      maxMouseMove;	/* Send max MouseMove data for ink apps */
#endif // OS_WINCE

    WNDCLASS       wndClass;

    DCUINT16       leftButton;
    DCUINT16       rightButton;

    DCBOOL         acceleratorPassthroughEnabled;
    PDCHOTKEY      pHotkey;
    DCBOOL         useScancodes;
    DCBOOL         useXButtons;
    DCBOOL         bUseFastPathInput;
    DCBOOL         fUseVKPacket;
    DCBOOL         sendZeroScanCode;
    DCBOOL         inSizeMove;
    DWORD          dwModifierKeyState;
#define IH_LALT_DOWN     0x0001
#define IH_RALT_DOWN     0x0002
#define IH_ALT_MASK      (IH_LALT_DOWN | IH_RALT_DOWN)
#define IH_LCTRL_DOWN    0x0010
#define IH_RCTRL_DOWN    0x0020
#define IH_CTRL_MASK     (IH_LCTRL_DOWN | IH_RCTRL_DOWN)
#define IH_LWIN_DOWN     0x0100
#define IH_RWIN_DOWN     0x0200
#define IH_WIN_MASK      (IH_LWIN_DOWN | IH_RWIN_DOWN)
#define IH_LSHIFT_DOWN  0x1000
#define IH_RSHIFT_DOWN  0x2000
#define IH_SHIFT_MASK   (IH_LSHIFT_DOWN | IH_RSHIFT_DOWN)

    DCBOOL          NumLock;
    DCBOOL          fWinEvilShiftHack;
    DCBOOL          fCtrlEscHotkey;
    BOOL            fLastKeyWasMenuDown;

    /************************************************************************/
    /* Visible area of the container window                                 */
    /************************************************************************/
    DCRECT         visibleArea;

    /************************************************************************/
    /* Fix for repeated WM_MOUSEMOVE problem.  Save the last mouse position */
    /* here.                                                                */
    /************************************************************************/
    POINT          lastMousePos;

    /************************************************************************/
    /* TRUE = continue to pass on input messages even if we don't have the  */
    /* focus.                                                               */
    /************************************************************************/
    DCBOOL         allowBackgroundInput;

    /************************************************************************/
    /* Maximum number of events in an InputPDU packet                       */
    /************************************************************************/
#define IH_INPUTPDU_MAX_EVENTS 100

    /************************************************************************/
    /* InputPDU buffer size                                                 */
    /************************************************************************/
#define IH_INPUTPDU_BUFSIZE \
  ((IH_INPUTPDU_MAX_EVENTS * sizeof(TS_INPUT_EVENT)) + sizeof(TS_INPUT_PDU))

#ifdef OS_WIN32
    /************************************************************************/
    /* Variables to handle holding off of mouse button-downs.               */
    /************************************************************************/
    DCBOOL          pendMouseDown;
    DCUINT32        mouseDownTime;
    INT_PTR         pendMouseTimer;
#endif

#ifdef OS_WINCE
    /************************************************************************/
    /* Used when trying to simulate Caps Lock keypresses (e.g., WinWord's   */
    /* habit of flipping the state of that key when typing "tHE ").         */
    /************************************************************************/
    DCUINT8         vkEatMe;
#endif // OS_WINCE

#ifdef OS_WINCE
    /************************************************************************/
    /* Tracks the state of the Left mouse button True = down, False = up    */
    /************************************************************************/
    DCBOOL         bLMouseButtonDown;
#endif // OS_WINCE

    //For idle input timer, flag that indicates
    //input was sent since the last time the flag was reset
    BOOL            fInputSentSinceCheckpoint;

    //
    // Current cursor
    //
    HCURSOR         hCurrentCursor;


    //
    // Flag indicating we have to eat the next self-injected (VK_FF)
    // key as it's purely there for sync purposes
    //
    BOOL            fDiscardSyncDownKey;
    BOOL            fDiscardSyncUpKey;
} IH_GLOBAL_DATA;


/****************************************************************************/
/* FSM definitions                                                          */
/****************************************************************************/
#define IH_FSM_INPUTS        9
#define IH_FSM_STATES        5

/****************************************************************************/
/* FSM inputs                                                               */
/****************************************************************************/
#define IH_FSM_INIT             0
#define IH_FSM_ENABLE           1
#define IH_FSM_DISABLE          2
#define IH_FSM_TERM             3
#define IH_FSM_FOCUS_LOSE       4
#define IH_FSM_FOCUS_GAIN       5
#define IH_FSM_INPUT            6
#define IH_FSM_BUFFERAVAILABLE  7
#define IH_FSM_NOBUFFER         8

/****************************************************************************/
/* FSM states                                                               */
/****************************************************************************/
#define IH_STATE_RESET       0
#define IH_STATE_INIT        1
#define IH_STATE_ACTIVE      2
#define IH_STATE_SUSPENDED   3
#define IH_STATE_PENDACTIVE  4


//
// Used by the UI to decouple a request to inject a
// set of VKEYS
// 
typedef struct tagIH_INJECT_VKEYS_REQUEST
{
    LONG  numKeys;
    short* pfArrayKeyUp;
    LONG* plKeyData;

    //Callee sets this to notify caller
    BOOL  fReturnStatus;
} IH_INJECT_VKEYS_REQUEST, *PIH_INJECT_VKEYS_REQUEST;


//
// Internal
//

/****************************************************************************/
/* This is best used for VKEYs that don't change by locale. Use caution.    */
/****************************************************************************/
#define IHInjectVKey(message, vkey) \
    IHInjectKey(message, vkey, (DCUINT16)MapVirtualKey(vkey, 0))


/****************************************************************************/
/* Is a WM_ message an input event?                                         */
/* It is if:                                                                */
/*   - the message is any mouse message                                     */
/*   - the message one of the keyboard messages generated without a call    */
/*     to TranslateMessage.                                                 */
/****************************************************************************/
#define IH_IS_INPUTEVENT(m) (((m >= WM_MOUSEFIRST) &&      \
                              (m <= WM_MOUSELAST)) ||      \
                             ((m == WM_KEYDOWN)    ||      \
                              (m == WM_KEYUP)      ||      \
                              (m == WM_SYSKEYDOWN) ||      \
                              (m == WM_SYSKEYUP)))


/****************************************************************************/
/* Timer tick rate in milliseconds                                          */
/****************************************************************************/
#define IH_TIMER_TICK_RATE  1000


/****************************************************************************/
/* Max time to delay mouse down messages (ms)                               */
/****************************************************************************/
#ifdef OS_WIN32
#define IH_PENDMOUSE_DELAY   200
#endif


/****************************************************************************/
/* (arbitrary) timer IDs for IH timers ("IH").                                      */
/****************************************************************************/
#define IH_TIMER_ID             0x4849
#ifdef OS_WIN32
#define IH_PENDMOUSE_TIMER_ID   0x0410
#endif


/****************************************************************************/
/* IH window class                                                          */
/****************************************************************************/
#define IH_CLASS_NAME       _T("IHWindowClass")


/****************************************************************************/
/* Minimum and maximum times between requesting Flow Control tests          */
/****************************************************************************/
#define IH_MIN_FC_INTERVAL   1000
#define IH_MAX_FC_INTERVAL  10000


/****************************************************************************/
/* Keyboard state flags                                                     */
/****************************************************************************/
#define  IH_KEYSTATE_TOGGLED   0x0001
#define  IH_KEYSTATE_DOWN      0x8000


/****************************************************************************/
/* Extended1 flag                                                           */
/****************************************************************************/
#define IH_KF_EXTENDED1        0x0200


/****************************************************************************/
/* Japanese keyboard layout                                                 */
/****************************************************************************/
#ifdef OS_WINCE
#define JAPANESE_KBD_LAYOUT(hkl) ((LOBYTE(LOWORD(hkl))) == LANG_JAPANESE)
#define KOREAN_KBD_LAYOUT(hkl)   ((LOBYTE(LOWORD(hkl))) == LANG_KOREAN)
#else
#define JAPANESE_KBD_LAYOUT(hkl) ((LOBYTE(LOWORD((ULONG_PTR)hkl))) == LANG_JAPANESE)
#define KOREAN_KBD_LAYOUT(hkl)   ((LOBYTE(LOWORD((ULONG_PTR)hkl))) == LANG_KOREAN)
#endif




class CIH
{
public:
    CIH(CObjs* objs);
    ~CIH();

    //
    // API
    //

    static VOID IH_StaticInit(HINSTANCE hInstance);
    static VOID IH_StaticTerm();

    #define IH_CheckForInput(A)
    
    DCVOID DCAPI IH_Init(DCVOID);
    DCVOID DCAPI IH_Term(DCVOID);
    DCVOID DCAPI IH_Enable(DCVOID);
    DCVOID DCAPI IH_Disable(DCVOID);
    DCVOID DCAPI IH_BufferAvailable(DCVOID);
    HWND   DCAPI IH_GetInputHandlerWindow(DCVOID);

    DCVOID DCAPI IH_SetAcceleratorPassthrough(ULONG_PTR enabled);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN( CIH,IH_SetAcceleratorPassthrough);

    DCVOID DCAPI IH_SetCursorPos(PDCVOID pData, DCUINT dataLen);
    EXPOSE_CD_NOTIFICATION_FN(CIH, IH_SetCursorPos);

    DCVOID DCAPI IH_SetCursorShape(ULONG_PTR data);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CIH, IH_SetCursorShape);
    
    DCVOID DCAPI IH_SetVisiblePos(PDCVOID pData, DCUINT dataLen);
    EXPOSE_CD_NOTIFICATION_FN(CIH,IH_SetVisiblePos);

    DCVOID DCAPI IH_SetVisibleSize(ULONG_PTR data);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CIH, IH_SetVisibleSize);

    DCVOID DCAPI IH_SetHotkey(PDCVOID pData, DCUINT len);
    EXPOSE_CD_NOTIFICATION_FN(CIH, IH_SetHotkey);

    DCVOID DCAPI IH_ProcessInputCaps(PTS_INPUT_CAPABILITYSET pInputCaps);
    DCVOID DCAPI IH_UpdateKeyboardIndicators(DCUINT16 UnitId, DCUINT16 LedFlags);
    DCVOID DCAPI IH_InputEvent(ULONG_PTR msg);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CIH,IH_InputEvent);

    DCVOID DCAPI IH_InjectMultipleVKeys(ULONG_PTR ihRequestPacket);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN( CIH,IH_InjectMultipleVKeys);

    DCVOID DCAPI IH_SetKeyboardImeStatus(DCUINT32 ImeOpen, DCUINT32 ImeConvMode);

#ifndef OS_WINCE
    BOOL   DCAPI IH_SetEnableKeyboardHooking()   {return _fUseHookBypass;}
    BOOL   DCAPI IH_GetEnableKeyboardHooking(BOOL bEnableHook) 
                                            {_fUseHookBypass=bEnableHook;}
#else
    BOOL   DCAPI IH_GetEnableKeyboardHooking()   {return _fUseHookBypass;}
    VOID   DCAPI IH_SetEnableKeyboardHooking(BOOL bEnableHook) 
                                            {_fUseHookBypass=bEnableHook;}
#endif

#ifdef SMART_SIZING
    DCVOID DCAPI IH_MainWindowSizeChange(ULONG_PTR msg);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CIH,IH_MainWindowSizeChange);
#endif // SMART_SIZING

    //
    // Notifications to the IH of fullscreen events
    //
    VOID   DCAPI IH_NotifyEnterFullScreen();
    VOID   DCAPI IH_NotifyLeaveFullScreen();

    //
    // Public data members
    //
    IH_GLOBAL_DATA _IH;
    static DWORD TlsIndex;


    //
    // Internal functions
    //

    static LRESULT CALLBACK  IHStaticInputCaptureWndProc(HWND   hwnd,
                                            UINT   message,
                                            WPARAM wParam,
                                            LPARAM lParam);
    LRESULT CALLBACK  IHInputCaptureWndProc(HWND   hwnd,
                                            UINT   message,
                                            WPARAM wParam,
                                            LPARAM lParam);

    VOID IH_ResetInputWasSentFlag()
    {
        _IH.fInputSentSinceCheckpoint = FALSE;
    }

    BOOL IH_GetInputWasSentFlag()
    {
        return _IH.fInputSentSinceCheckpoint;
    }

    VOID IH_SetInputWasSentFlag(BOOL b)
    {
        _IH.fInputSentSinceCheckpoint = b;
    }

private:

    /****************************************************************************/
    /* Function Prototypes                                                      */
    /****************************************************************************/

    
    DCBOOL DCINTERNAL IHFSMProc(DCUINT32 event, ULONG_PTR data);
    DCBOOL DCINTERNAL IHAddEventToPDU(PMSG inputMsg);
    DCVOID DCINTERNAL IHMaybeSendPDU(DCVOID);
    DCVOID DCINTERNAL IHSync(DCVOID);
    DCVOID DCINTERNAL IHInitPacket(DCVOID);
    DCVOID DCINTERNAL IHSetMouseHandedness(DCVOID);
    DCVOID DCINTERNAL IHDiscardMsg(PMSG pMsg);
    DCBOOL DCINTERNAL IHCheckForHotkey(PMSG pNextMsg);
    DCBOOL DCINTERNAL IHProcessKoreanVKHangulHanja(PWORD scancode, PWORD flags);
    DCBOOL DCINTERNAL IHProcessMouseEvent(PMSG pMsg);
    DCBOOL DCINTERNAL IHProcessKeyboardEvent(PMSG pMsg);
    DCBOOL DCINTERNAL IHMassageZeroScanCode(PMSG pMsg);
#ifdef OS_WINCE
    DCBOOL DCINTERNAL IHAddMultipleEventsToPDU(POINT *ppt, int cpt);
#endif
    VOID IHMaintainModifierKeyState(int vkKey);

    unsigned DCINTERNAL IHTranslateInputToFastPath(unsigned *);
    LRESULT IHLowLevelKeyboardProc(int nCode, WPARAM wParam, 
            LPARAM lParam);
    static LRESULT CALLBACK IHStaticLowLevelKeyboardProc(int nCode, WPARAM wParam, 
            LPARAM lParam);
    VOID IHGatherKeyState();
    BOOL    IHIsForegroundWindow();
    
    /****************************************************************************/
    /* Name:    IHPostMessageToMainWindow                                       */
    /*                                                                          */
    /* Purpose: Sees if the message passed in needs to be passed to the main UI */
    /*          window. If so pass it the window and return true.               */
    /*                                                                          */
    /* Returns: TRUE - if message successfully passed to the UI main window     */
    /*          FALSE - otherwsie                                               */
    /*                                                                          */
    /* Params:  msg - IN - Message to be considered                             */
    /****************************************************************************/
    DCBOOL DCINTERNAL IHPostMessageToMainWindow(DCUINT message,
                                                         WPARAM wParam,
                                                         LPARAM lParam)
    {
        DCBOOL  rc = FALSE;
        DCBOOL  normalKeyPress;
        DCBOOL  altKeyPress;
        DCBOOL  isFullScreenToggle;
        DCBOOL  isNeededAccelerator;
        DCBOOL  isAltTab;
        DCBOOL  isAltSpace;
        DCBOOL  isSpecialFilterSequence;
    
        DC_BEGIN_FN("IHPostMessageToMainWindow");
    
        if (_IH.inSizeMove)
        {
            if ((message != WM_TIMER) && (message != WM_PAINT))
            {
                TRC_NRM((TB, _T("In Size/Move - post to frame")));
                PostMessage( _pUi->UI_GetUIMainWindow(),
                             message,
                             wParam,
                             lParam );
            }
            rc = TRUE;
            DC_QUIT;
        }
    
        normalKeyPress = ((message == WM_KEYDOWN) || (message == WM_KEYUP));
        altKeyPress = ((message == WM_SYSKEYDOWN) || (message == WM_SYSKEYUP));
        isFullScreenToggle = normalKeyPress && 
                (wParam == _IH.pHotkey->fullScreen) && 
                TEST_FLAG(GetKeyState(VK_MENU), IH_KEYSTATE_DOWN);
        isNeededAccelerator = (!_IH.acceleratorPassthroughEnabled) && altKeyPress;
        isAltTab = (message == WM_SYSKEYDOWN) && (wParam == VK_TAB);
        isAltSpace = altKeyPress && (wParam == VK_SPACE);
        isSpecialFilterSequence = isAltTab || isAltSpace;

        /************************************************************************/
        /* Some messages must not be passed to server, and are just passed to   */
        /* the UI's Main Window.                                                */
        /*                                                                      */
        /* These are:                                                           */
        /*  1.  Screen Mode toggle keys - these must be of the form ALT + VK -  */
        /*      for example ALT+Ctrl+Pause.                                     */
        /*  2.  ALT keystrokes sent when accelerator pass-through is disabled.  */
        /*  3.  ALT-TAB keystrokes (although we actually only see these on      */
        /*      Win 3.1). We actually send alt-tab up keys because the server   */
        /*      then recognizes that alt tabbing is going on and doesn't do the */
        /*      menu highlighting thing.                                        */
        /************************************************************************/
        if (isFullScreenToggle ||
             ((isNeededAccelerator ||
             isSpecialFilterSequence) && !_fUseHookBypass))
        {
            TRC_NRM((TB, _T("Post to Frame msg(%#x) wParam(%#x) "), message, wParam));
            if (PostMessage( _pUi->UI_GetUIMainWindow(),
                             message,
                             wParam,
                             lParam ) == 0)
            {
                TRC_ABORT((TB, _T("Failed to post message to main window")));
            }
    
            if ( (!_IH.acceleratorPassthroughEnabled) &&
                 (message == WM_SYSKEYUP) )
            {
                /****************************************************************/
                /* When we use the full-screen hotkey, we can get asymmetric    */
                /* sequences such as:                                           */
                /*                                                              */
                /* WM_KEYDOWN  (VK_CONTROL)                                     */
                /* WM_KEYDOWN  (VK_MENU)                                        */
                /* WM_KEYDOWN  (VK_CANCEL)                                      */
                /* WM_KEYUP    (VK_CANCEL)                                      */
                /* WM_SYSKEYUP (VK_CONTROL)  <- asymmetric                      */
                /* WM_KEYUP    (VK_MENU)                                        */
                /*                                                              */
                /* When accelerator passthrough is off, the WM_SYSKEYUP doesn't */
                /* get passed through to the server, which then thinks that the */
                /* Ctrl key is still down.                                      */
                /*                                                              */
                /* This branch means that the WM_SYSKEYUP is both passed to the */
                /* UI's main window AND processed by whoever called this        */
                /* function.                                                    */
                /****************************************************************/
                TRC_ALT((TB,
                    "Passed WM_SYSKEYUP to UI main window, but lying about it."));
                DC_QUIT;
            }
    
            rc = TRUE;
        }
    
    
    DC_EXIT_POINT:
        DC_END_FN();
    
        return(rc);
    } /* IHPostMessageToMainWindow */
    
    
    /****************************************************************************/
    /* Name:      IHSetCursorShape                                              */
    /*                                                                          */
    /* Purpose:   Set the cursor shape                                          */
    /*                                                                          */
    /* Params:    IN     cursorHandle                                           */
    /****************************************************************************/
    DCVOID DCINTERNAL IHSetCursorShape(HCURSOR cursorHandle)
    {
        DC_BEGIN_FN("IHSetCursorShape");
    
        //
        // Store the cursor for future WM_SETCURSOR's
        //
        _IH.hCurrentCursor = cursorHandle;
    
        //
        // Also set the cursor directly - just to be sure the cursor is in sync
        // during reconnection.
        //
        SetCursor(cursorHandle);
    
        DC_END_FN();
    
        return;
    
    } /* IHSetCursorShape */
    
    
    /****************************************************************************/
    /* Name:      IHUpdateKeyboardIndicator                                     */
    /*                                                                          */
    /* Purpose:   Set the specified keyboard indicator                          */
    /*                                                                          */
    /* Params:    IN     pKeyState - keyStates array                            */
    /*            IN     bState - key state to set                              */
    /*            IN     vkKey - virtual key                                    */
    /****************************************************************************/
    DCVOID DCINTERNAL IHUpdateKeyboardIndicator(PDCUINT8   pKeyStates,
                                                         DCUINT8    bState,
                                                         DCUINT8    vkKey)
    {
        DC_BEGIN_FN("IHUpdateKeyboardIndicator");
    
        if ((bState && !(pKeyStates[vkKey] & 1)) ||
            (!bState && (pKeyStates[vkKey] & 1)))
        {
    
            {
                /****************************************************************/
                /* Scancode of zero will be recognized by WM_KEY* processing    */
                /* code and will not forward the events on to the server        */
                /****************************************************************/
    
    #ifndef OS_WINCE
                keybd_event(vkKey, (DCUINT8) 0, KEYEVENTF_EXTENDEDKEY | 0, 0);
                keybd_event(vkKey, (DCUINT8) 0, KEYEVENTF_EXTENDEDKEY | KEYEVENTF_KEYUP, 0);
    #else
                /****************************************************************/
                /* Save this key for later ignoring.                            */
                /* (The default TSC method of ignoring a key is to send a scan- */
                /* code of 0.  That does not work on WINCE_HPC because it       */
                /* interprets that condition to mean that the keyboard driver   */
                /* has not supplied a scan-code and so inserts the scan-code    */
                /* from the VK identifier.)                                     */
                /****************************************************************/
                if (! g_CEUseScanCodes)
                {
                    _IH.vkEatMe = vkKey;
                }
                keybd_event(vkKey, (DCUINT8) 0, KEYEVENTF_SILENT, 0);
                keybd_event(vkKey, (DCUINT8) 0, KEYEVENTF_SILENT | KEYEVENTF_KEYUP, 0);
    #endif
            }
    
        }
    
        DC_END_FN();
    }
    
    
    /****************************************************************************/
    /* Name:      IHInjectKey                                                   */
    /*                                                                          */
    /* Purpose:   Send the specified key to the server                          */
    /*                                                                          */
    /* Params:    IN     message - keyboard message                             */
    /*            IN     vKey - virtual key code, should mean very little       */
    /*            IN     scancode - scancode to send                            */
    /****************************************************************************/
    DCVOID DCINTERNAL IHInjectKey(UINT message, WPARAM vKey, DCUINT16 scancode)
    {
        MSG msg;
        DC_BEGIN_FN("IHInjectKey");
    
        TRC_ASSERT(message == WM_KEYDOWN || message == WM_KEYUP ||
                message == WM_SYSKEYDOWN || message == WM_SYSKEYUP,
                   (TB, _T("Message %#x should be a keyboard message"), message));
    
        TRC_DBG((TB, _T("Injecting %s vkey: 0x%8.8x, scancode: 0x%8.8x"),
            (message == WM_KEYDOWN ? "WM_KEYDOWN" :
            (message == WM_KEYUP ? "WM_KEYUP" :
            (message == WM_SYSKEYDOWN ? "WM_SYSKEYDOWN" :
            (message == WM_SYSKEYUP ? "WM_SYSKEYUP" : "WM_WHATSWRONGWITHYOU")))),
            vKey, scancode));
    
        msg.hwnd = NULL;
        msg.message = message;
        msg.wParam = vKey;
        msg.lParam = MAKELONG(0, scancode);
        IHAddEventToPDU(&msg);
    
        DC_END_FN();
    }

#ifdef USE_BBAR
    VOID IHSetBBarUnhideTimer(LONG x, LONG y);
#endif

#ifdef OS_WINNT
    VOID IHHandleLocalLockDesktop();
#endif // OS_WINNT

private:
    CUT* _pUt;
    CUI* _pUi;
    CSL* _pSl;
    CUH* _pUh;
    CCD* _pCd;
    CIH* _pIh;
    COR* _pOr;
    CFS* _pFs;
    CCC* _pCc;
    COP* _pOp;

    HHOOK _hKeyboardHook;
    BOOL _fUseHookBypass;
    BOOL _fCanUseKeyboardHook;
    BYTE _KeyboardState[32]; 
#ifdef SMART_SIZING
    DCSIZE _scaleSize;
#endif // SMART_SIZING
private:
    CObjs* _pClientObjects;
};

#undef TRC_FILE
#undef TRC_GROUP

#endif //_H_IH
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\ihint.cpp ===
/****************************************************************************/
// ihint.cpp
//
// IH internal code
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <adcg.h>

extern "C" {
#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "aihint"
#include <atrcapi.h>

#include <adcgfsm.h>
}

#include "objs.h"
#include "ih.h"
#include "autil.h"
#include "sl.h"
#include "aco.h"
#include "wui.h"
#ifdef OS_WINCE
#include "cd.h"
#include "op.h"
#include <ceconfig.h>
#endif
#include "cc.h"

#ifndef VK_KANA
#define VK_KANA 0x15
#endif
#ifndef VK_HANGUL
#define VK_HANGUL 0x15
#endif
#ifndef VK_HANJA
#define VK_HANJA 0x19
#endif

#define VK_l 'l'
#define VK_L 'L'

//
// Special VK value to ignore
//
#define VK_IGNORE_VALUE 0xFF


/****************************************************************************/
/* Dummy hotkey table.  This is used until the UI passes the real hotkey    */
/* table to the core.  An entry of -1 is an invalid hotkey, hence will not  */
/* match any key sequence.                                                  */
/****************************************************************************/
DCHOTKEY ihDummyHotkey = {(DCUINT)-1, (DCUINT)-1, (DCUINT)-1,
                          (DCUINT)-1, (DCUINT)-1, (DCUINT)-1, (DCUINT)-1};

/****************************************************************************/
/* Input Handler FSM                                                        */
/*                                                                          */
/*               State | 0:Reset  1:Init   2:Active 3:Suspend  4: PendAct   */
/*  Input              |                                                    */
/*  ===================+==================================================  */
/*  IH_Init            | 1 a      /        /        /          /            */
/*  IH_Enable          | /        2 g      /        /          /            */
/*  IH_Disable         | /        -        1 c      1 c        1 c          */
/*  IH_Term            | /        0 h      0 h      0 h        0 h          */
/*  Focus lost (+)     | - (*)    -        3 i      -          -            */
/*  Focus regained     | /        -        - b      2 b        -            */
/*  Input/Timer Event  | /        -        - d      - e        - j          */
/*  IH_BufferAvailable | /        -        - f      -          2 g          */
/*  IH_FSM_NOBUFFER    | /        /        4        /          /            */
/*                                                                          */
/* /   invalid input/state combination                                      */
/* -   no state change                                                      */
/* (*) can occur during shutdown on Win16 (as window is not destroyed)      */
/* (+) this event may not be passed through to the FSM (see WM_KILLFOCUS)   */
/*                                                                          */
/* Note that when allowBackgroundInput is enabled the we don't go into      */
/* suspend..this would cause a bug because when focus is regained the FSM   */
/* did not fire an ACT_B to resync even though it needed to...So the FSM was*/
/* changed to make that fix (if you are in ACTIVE and receive focus gain an */
/* ACT_B is sent                                                            */
/****************************************************************************/
const FSM_ENTRY ihFSM[IH_FSM_INPUTS][IH_FSM_STATES] =
{
   { {IH_STATE_INIT,      ACT_A },
     {STATE_INVALID,      ACT_NO},
     {STATE_INVALID,      ACT_NO},
     {STATE_INVALID,      ACT_NO},
     {STATE_INVALID,      ACT_NO} },

   { {STATE_INVALID,      ACT_NO},
     {IH_STATE_ACTIVE,    ACT_G },
     {STATE_INVALID,      ACT_NO},
     {STATE_INVALID,      ACT_NO},
     {STATE_INVALID,      ACT_NO} },

   { {STATE_INVALID,      ACT_NO},
     {IH_STATE_INIT,      ACT_NO},
     {IH_STATE_INIT,      ACT_C },
     {IH_STATE_INIT,      ACT_C },
     {IH_STATE_INIT,      ACT_C } },

   { {STATE_INVALID,      ACT_NO},
     {IH_STATE_RESET,     ACT_H },
     {IH_STATE_RESET,     ACT_H },
     {IH_STATE_RESET,     ACT_H },
     {IH_STATE_RESET,     ACT_H } },

   { {IH_STATE_INIT,      ACT_NO},
     {IH_STATE_INIT,      ACT_NO},
     {IH_STATE_SUSPENDED, ACT_I },
     {IH_STATE_SUSPENDED, ACT_NO},
     {IH_STATE_PENDACTIVE,ACT_NO} },

   { {STATE_INVALID,      ACT_NO},
     {IH_STATE_INIT,      ACT_NO},
     {IH_STATE_ACTIVE,    ACT_B},
     {IH_STATE_ACTIVE,    ACT_B },
     {IH_STATE_PENDACTIVE,ACT_NO} },

   { {STATE_INVALID,      ACT_NO},
     {IH_STATE_INIT,      ACT_NO},
     {IH_STATE_ACTIVE,    ACT_D },
     {IH_STATE_SUSPENDED, ACT_E },
     {IH_STATE_PENDACTIVE,ACT_J } },

   { {STATE_INVALID,      ACT_NO},
     {IH_STATE_INIT,      ACT_NO},
     {IH_STATE_ACTIVE,    ACT_F },
     {IH_STATE_SUSPENDED, ACT_NO},
     {IH_STATE_ACTIVE,    ACT_G } },

   { {STATE_INVALID,      ACT_NO},
     {STATE_INVALID,      ACT_NO},
     {IH_STATE_PENDACTIVE,ACT_NO},
     {STATE_INVALID,      ACT_NO},
     {STATE_INVALID,      ACT_NO} }
};

/****************************************************************************/
/* Debug FSM state and event strings                                        */
/****************************************************************************/
#ifdef DC_DEBUG
static const PDCTCHAR ihFSMStates[IH_FSM_STATES] =
{
    _T("IH_STATE_RESET"),
    _T("IH_STATE_INIT"),
    _T("IH_STATE_ACTIVE"),
    _T("IH_STATE_SUSPENDED"),
    _T("IH_STATE_PENDACTIVE")
};
static const PDCTCHAR ihFSMInputs[IH_FSM_INPUTS] =
{
    _T("IH_FSM_INIT"),
    _T("IH_FSM_ENABLE"),
    _T("IH_FSM_DISABLE"),
    _T("IH_FSM_TERM"),
    _T("IH_FSM_FOCUS_LOSE"),
    _T("IH_FSM_FOCUS_GAIN"),
    _T("IH_FSM_INPUT"),
    _T("IH_FSM_BUFFERAVAILABLE")
};
#endif /* DC_DEBUG */

//
// A thread local variable so the keyboard hook can find the IH for this
// thread
//
// Hey, what's the hungarian for thread local storage?
//
DWORD CIH::TlsIndex = 0xFFFFFFFF;

/****************************************************************************/
/* Name:      IHFSMProc                                                     */
/*                                                                          */
/* Purpose:   Run the IH FSM                                                */
/*                                                                          */
/* Returns:   Process input event TRUE / FALSE                              */
/*                                                                          */
/* Params:    IN      event - FSM input                                     */
/****************************************************************************/
DCBOOL DCINTERNAL CIH::IHFSMProc(DCUINT32 event, ULONG_PTR data)
{
    DCBOOL   rc = TRUE;
    DCUINT8  action;
    MSG      nextMsg;
    DCUINT32 newEvents;
    DCSIZE   desktopSize;
    WNDCLASS tmpWndClass;

    DC_BEGIN_FN("IHFSMProc");

    /************************************************************************/
    /* Run the FSM                                                          */
    /************************************************************************/
    EXECUTE_FSM(ihFSM, event, _IH.fsmState, action, ihFSMInputs, ihFSMStates);

    switch (action)
    {
        case ACT_A:
        {
            TRC_NRM((TB, _T("Initialization")));

            /****************************************************************/
            /* Create a dummy hotkey table                                  */
            /****************************************************************/
            _IH.pHotkey = &ihDummyHotkey;

            /****************************************************************/
            /* Register the IH window class                                 */
            /****************************************************************/
            if(!GetClassInfo(_pUi->UI_GetInstanceHandle(), IH_CLASS_NAME, &tmpWndClass))
            {
                _IH.wndClass.style         = CS_HREDRAW | CS_VREDRAW;
                _IH.wndClass.lpfnWndProc   = IHStaticInputCaptureWndProc;
                _IH.wndClass.cbClsExtra    = 0;
                _IH.wndClass.cbWndExtra    = sizeof(void*); //store this pointer
                _IH.wndClass.hInstance     = _pUi->UI_GetInstanceHandle();
                _IH.wndClass.hIcon         = NULL;
                _IH.wndClass.hCursor       = NULL;
                _IH.wndClass.hbrBackground = (HBRUSH)GetStockObject(HOLLOW_BRUSH);
                _IH.wndClass.lpszMenuName  = NULL;
                _IH.wndClass.lpszClassName = IH_CLASS_NAME;
                if (RegisterClass(&_IH.wndClass) == 0)
                {
                    TRC_ALT((TB, _T("Failed to register IH window class")));
                    _pUi->UI_FatalError(DC_ERR_WINDOWCREATEFAILED);
                }
            }
            /****************************************************************/
            /* Create the Input Capture Window.  We don't want this window  */
            /* to try to send WM_PARENTNOTIFY to the UI containder wnd on   */
            /* create/destroy (since this can cause deadlocks) so we        */
            /* specify WS_EX_NOPARENTNOTIFY.  WM_PARENTNOTIFY doesn't exist */
            /* on WinCE so it's not a problem there.                        */
            /****************************************************************/
            _IH.inputCaptureWindow =
                CreateWindowEx(
#ifndef OS_WINCE
                            WS_EX_NOPARENTNOTIFY | WS_EX_TRANSPARENT,
#else
                            0,                      /* extended style       */
#endif
                            IH_CLASS_NAME,          /* window class name    */
                            _T("Input Capture Window"), /* window caption   */
                            WS_CHILD,               /* window style         */
                            0,                      /* initial x position   */
                            0,                      /* initial y position   */
                            1,                      /* initial x size       */
                            1,                      /* initial y size       */
                            _pUi->UI_GetUIContainerWindow(),/* parent window      */
                            NULL,                   /* window menu handle   */
                            _pUi->UI_GetInstanceHandle(), /* program inst handle  */
                            this);                  /* creation parameters  */

            _IH.hCurrentCursor = LoadCursor(NULL, IDC_ARROW);

            if (_IH.inputCaptureWindow == NULL)
            {
                TRC_ERR((TB, _T("Failed to create Input Capture Window")));

                /************************************************************/
                /* Fatal error - cannot continue.                           */
                /************************************************************/
                _pUi->UI_FatalError(DC_ERR_WINDOWCREATEFAILED);
            }
            TRC_DBG((TB, _T("Capture Window handle %p"), _IH.inputCaptureWindow));

            /********************************************************************/
            /* Disable IME                                                      */
            /********************************************************************/
            _pUi->DisableIME(_IH.inputCaptureWindow);

            /****************************************************************/
            /* Read the registry to get the configuration information.      */
            /****************************************************************/
            _IH.maxEventCount = _pUi->_UI.maxEventCount;
            if (_IH.maxEventCount > IH_INPUTPDU_MAX_EVENTS)
            {
                /************************************************************/
                /* Limit InputPDU size                                      */
                /************************************************************/
                _IH.maxEventCount = IH_INPUTPDU_MAX_EVENTS;
            }
            TRC_DBG((TB, _T("InputPDU max events %d"), _IH.maxEventCount));

            _IH.eventsAtOnce = _pUi->_UI.eventsAtOnce;
            TRC_DBG((TB, _T("%d events at once"), _IH.eventsAtOnce));

#ifdef OS_WINCE
            _IH.maxMouseMove = _pUt->UT_ReadRegistryInt(
                                          UTREG_SECTION,
                                          UTREG_IH_MAX_MOUSEMOVE,
                                          UTREG_IH_MAX_MOUSEMOVE_DFLT);
            TRC_DBG((TB, _T("Max Mouse Move %u"),_IH.maxMouseMove));

            /************************************************************************/
            /* If the INK feature is enabled, min send interval must be zero.  Don't*/
            /* change the registry value so the original value is in place if the   */
            /* INK feature is disabled.                                             */
            /************************************************************************/
            if (_IH.maxMouseMove)
            {
                _IH.minSendInterval = 0;
            }
            else
            {
                _IH.minSendInterval = _pUt->UT_ReadRegistryInt(
                                              UTREG_SECTION,
                                              UTREG_IH_MIN_SEND_INTERVAL,
                                              UTREG_IH_MIN_SEND_INTERVAL_DFLT);
                TRC_DBG((TB, _T("Min send interval %d ms"), _IH.minSendInterval));
            }
#else
            _IH.minSendInterval = _pUi->_UI.minSendInterval;
            TRC_DBG((TB, _T("Min send interval %d ms"), _IH.minSendInterval));
#endif

            _IH.keepAliveInterval = 1000 * _pUi->_UI.keepAliveInterval;
            TRC_DBG((TB, _T("Keepalive interval %d ms"), _IH.keepAliveInterval));

            //
            // Allow background input (Reg only setting)
            //
            _IH.allowBackgroundInput = _pUt->UT_ReadRegistryInt(
                                        UTREG_SECTION,
                                        UTREG_IH_ALLOWBACKGROUNDINPUT,
                                        _pUi->_UI.allowBackgroundInput);

            TRC_DBG((TB, _T("Allow background input %u"),
                                                    _IH.allowBackgroundInput));
            _IH.lastInputPDUSendTime = _pUt->UT_GetCurrentTimeMS();
            _IH.lastFlowPDUSendTime = _pUt->UT_GetCurrentTimeMS();
            _IH.timerTickRate = IH_TIMER_TICK_RATE;
            _IH.pInputPDU = NULL;

            _IH.visibleArea.top = 0;
            _IH.visibleArea.left = 0;
            _IH.visibleArea.right = 1;
            _IH.visibleArea.bottom = 1;

            /************************************************************************/
            /* Initialize the sendZeroScanCode                                      */
            /************************************************************************/
            _IH.sendZeroScanCode = (_pUt->UT_IsNEC98platform() && (_pUi->UI_GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_95));
#ifdef OS_WINCE            
            /************************************************************************/
            /* In order to work around a problem with some input techniques (like   */
            /* the default keyboard driver and CalliGrapher) that have a nasty      */
            /* habit of not providing a scan-code with their WM_KEYDOWN and         */
            /* WM_KEYUP messages, we need to  allow scan-codes of 0 to pass through */
            /* IHFSMProc's ACT_D check against them.  They'll be patched-up in      */
            /* IHAddEventToPDU anyway, so there's nothing to worry about...  :)     */
            /************************************************************************/
            if (!g_CEUseScanCodes)
            {
                _IH.sendZeroScanCode = TRUE;
                _IH.vkEatMe = 0;                            
            }
            else
            {
                _IH.sendZeroScanCode = FALSE;
            }
#else // OS_WINCE

#if defined(OS_WIN32)
            _IH.sendZeroScanCode |= _pUt->UT_IsKorean101LayoutForWin9x();
#endif

#endif // OS_WINCE

        }
        break;

        case ACT_B:
        {
            /****************************************************************/
            /* Regained focus - synchronize.  First try to send any         */
            /* outstanding events.                                          */
            /* Must pend sync until an input event is received, as          */
            /* otherwise we may get the Caps Lock state wrong.              */
            /****************************************************************/
            IHMaybeSendPDU();
            _IH.focusSyncRequired = TRUE;

            //
            // Work around a nasty problem caused because win32k doesn't sync the keystate
            // immediately after a desktop switch by force injecting a dummy key
            // that we only process locally.
            //
            // Injecting the key forces win32k to handle any pending keyevent updates
            // (QEVENT_UPDATEKEYSTATE) and so when we receive the key back in our msg
            // queue we know it's then safe to do the actual sync since modifier
            // key states will be correct.
            //
            //
            if (IHIsForegroundWindow()) {
                TRC_DBG((TB,_T("Fake N on sync DN. focus:0x%x IH:0x%x"),
                         GetFocus(), _IH.inputCaptureWindow));

                //
                // Self inject a fake key
                //
                _IH.fDiscardSyncDownKey = TRUE;
                keybd_event(VK_IGNORE_VALUE, 0,
                            0, IH_EXTRAINFO_IGNOREVALUE);

                //
                // Self inject a fake key
                //
                _IH.fDiscardSyncUpKey = TRUE;
                keybd_event(VK_IGNORE_VALUE, 0,
                            KEYEVENTF_KEYUP,
                            IH_EXTRAINFO_IGNOREVALUE);
            }
            else {
                TRC_DBG((TB,_T("Fake N on sync. Did not have fore DN. focus:0x%x IH:0x%x"),
                         GetFocus(), _IH.inputCaptureWindow));
            }

            //
            // Gaining focus -> Disable Cicero (keyboard/IME) toolbar 
            //
            _pCd->CD_DecoupleSimpleNotification(CD_UI_COMPONENT,
                                    _pUi,
                                    CD_NOTIFICATION_FUNC(CUI,UI_OnInputFocusGained),
                                    0);

        }
        break;

        case ACT_C:
        {
            ShowWindow(_IH.inputCaptureWindow, SW_HIDE);

            /****************************************************************/
            /* Stop the timer                                               */
            /****************************************************************/
            KillTimer(_IH.inputCaptureWindow, _IH.timerID);
            _IH.timerID = 0;

            /****************************************************************/
            /* Ensure no cursor is selected in the window                   */
            /****************************************************************/
            IHSetCursorShape(NULL);

            /****************************************************************/
            /* Release the InputPDU back to the Network Layer               */
            /****************************************************************/
            if (_IH.pInputPDU != NULL)
            {
                TRC_DBG((TB, _T("Free the inputPDU")));
                _pSl->SL_FreeBuffer(_IH.bufHandle);
            }
            _IH.pInputPDU = NULL;

        }
        break;

        case ACT_D:
        {
            /****************************************************************/
            /* Process the event - copy to nextMsg to simplify loop.        */
            /****************************************************************/
            DC_MEMCPY(&nextMsg, (PMSG)data, sizeof(MSG));

            /****************************************************************/
            /* If the PDU is already full, try to send it, as we would like */
            /* to send this new event at least                              */
            /****************************************************************/
            if (_IH.pInputPDU->numberEvents >= _IH.maxEventCount)
            {
                IHMaybeSendPDU();
            }

            if (_IH.pInputPDU->numberEvents >= _IH.maxEventCount)
            {
                /************************************************************/
                /* The send failed and the buffer is full.  Discard this    */
                /* event.                                                   */
                /************************************************************/
                IHDiscardMsg(&nextMsg);

                /************************************************************/
                /* No point in scanning ahead on the queue.                 */
                /************************************************************/
                break;
            }

            /****************************************************************/
            /* Check if we need to sync due to regaining the focus.  If we  */
            /* do, and the message that brought us in here is a CapsLock,   */
            /* NumLock or ScrollLock keydown, we do the sync but don't send */
            /* the keydown, otherwise it will result in the server syncing  */
            /* to the new key state, then receiving a keydown that reverses */
            /* that state.                                                  */
            /*                                                              */
            /* It's OK to let the corresponding keyup go through, since     */
            /* this won't affect any toggle states.                         */
            /*                                                              */
            /* Only do a 'focus regained' sync if this is an input message  */
            /* (not a timer) otherwise GetKeyState won't have up-to-date    */
            /* information.                                                 */
            /****************************************************************/
            if (_IH.focusSyncRequired && (nextMsg.message != WM_TIMER))
            {
                TRC_NRM((TB, _T("Focus regained - attempt to sync (%#x)"),
                             nextMsg.message));

                IHGatherKeyState();
                IHSync();

                if ((nextMsg.message == WM_KEYDOWN) &&
                    ((nextMsg.wParam == VK_CAPITAL) ||
                     (nextMsg.wParam == VK_NUMLOCK) ||
                     (nextMsg.wParam == VK_SCROLL)))
                {
                    /********************************************************/
                    /* Ignore this message because it will override the     */
                    /* sync message we've just sent.  This is not an error  */
                    /* condition, so set rc = TRUE.                         */
                    /********************************************************/
                    TRC_ALT((TB,
                              _T("Not sending keydown that caused sync (VK %#x)"),
                              nextMsg.wParam));
                    rc = TRUE;
                    DC_QUIT;
                }
            }

            /****************************************************************/
            /* Do a sync if required, as we may have just done a successful */
            /* send.                                                        */
            /****************************************************************/
            if (_IH.syncRequired)
            {
                TRC_NRM((TB, _T("Attempt to Sync (%#x)"), nextMsg.message));
                IHSync();
            }

            /****************************************************************/
            /* Pull off remaining events until the PDU is full, or we have  */
            /* pulled off more than eventsAtOnce events.                    */
            /****************************************************************/
            for (newEvents = 0;
                 ((_IH.pInputPDU->numberEvents < _IH.maxEventCount) &&
                  (newEvents < _IH.eventsAtOnce)); )
            {

                if (IH_IS_INPUTEVENT(nextMsg.message))
                {
                    if ((nextMsg.message == WM_KEYDOWN || nextMsg.message == WM_KEYUP) &&
                            IHMassageZeroScanCode(&nextMsg))
                    {
                        TRC_NRM((TB, _T("Discarding input message: 0x%04x sc: 0x%04x"), 
                                nextMsg.message, (((nextMsg.lParam >> 16) & 0xff))));
                    }
                    else
                    {
                        TRC_DBG((TB, _T("Add message %x"), nextMsg.message));
                        newEvents++;
                        if ((nextMsg.message >= WM_KEYFIRST) &&
                            (nextMsg.message <= WM_KEYLAST))
                        {
                            TRC_DBG((TB, _T("Keyboard event")));
                            rc = IHProcessKeyboardEvent(&nextMsg);
                        }
                        else
                        {
                            TRC_DBG((TB, _T("Mouse event")));
                            rc = IHProcessMouseEvent(&nextMsg);
                        }

                        /****************************************************/
                        /* If the handler indicates, force end of loop      */
                        /****************************************************/
                        if (!rc)
                        {
                            TRC_NRM((TB, _T("Force end of loop")));
                            break;
                        }

                    }
                }
                else
                {
                    DefWindowProc(nextMsg.hwnd,
                                  nextMsg.message,
                                  nextMsg.wParam,
                                  nextMsg.lParam);
                }

                /************************************************************/
                /* We may have hit the limit of maxEventCount or            */
                /* eventsAtOnce at this point. Jump out of the loop if so.  */
                /************************************************************/
                if ((_IH.pInputPDU->numberEvents >= _IH.maxEventCount) ||
                    (newEvents >= _IH.eventsAtOnce))
                {
                    TRC_NRM((TB,
                             _T("Limit hit: not pulling off any more events")));
                    break;
                }

                /************************************************************/
                /* Pull the next input event off the message queue.  Note   */
                /* that this also pulls off some other events - but can't   */
                /* split this into separate mouse / keyboard Peeks, as this */
                /* could get the message order wrong.                       */
                /************************************************************/
#if (WM_KEYFIRST > WM_MOUSELAST)
                TRC_ABORT((TB, _T("Internal Error")));
#endif

                /************************************************************/
                /* If there are more input or timer messages in the queue,  */
                /* we would like to pull them out.  First see if the next   */
                /* message is one we want without taking it off the queue.  */
                /************************************************************/
                if (PeekMessage(&nextMsg,
                                _IH.inputCaptureWindow,
                                WM_KEYFIRST,
                                WM_MOUSELAST,
                                PM_NOREMOVE) == 0)
                {
                    TRC_DBG((TB, _T("No more messages")));
                    break;
                }

                /************************************************************/
                /* If the message found in the peek with NOREMOVE set was   */
                /* one we want, peek again but this time remove it.         */
                /* Otherwise the message is not one we want so send the     */
                /* current buffer.                                          */
                /************************************************************/
                if (IH_IS_INPUTEVENT(nextMsg.message) ||
                    (nextMsg.message == WM_TIMER))
                {
#ifdef DC_DEBUG
                    UINT msgPeeked = nextMsg.message;
#endif
                    if (PeekMessage(&nextMsg,
                                    _IH.inputCaptureWindow,
                                    WM_KEYFIRST,
                                    WM_MOUSELAST,
                                    PM_REMOVE) == 0)
                    {
                        /****************************************************/
                        /* We should find the message we found when we      */
                        /* peeked without removing - however this can fail  */
                        /* if a higher priority (non-input) message is      */
                        /* added to the queue in between the two            */
                        /* PeekMessage calls.                               */
                        /****************************************************/
                        TRC_ALT((TB, _T("No messages on queue (did have %#x)"),
                                      msgPeeked));
                        break;
                    }
                    else
                    {
                        TRC_DBG((TB,_T("Found a message (type %#x)"),
                                                           nextMsg.message));

                        /****************************************************/
                        /* If this is a message the main window is          */
                        /* interested in then Post it and send the current  */
                        /* buffer.                                          */
                        /****************************************************/
                        if (IHPostMessageToMainWindow(nextMsg.message,
                                                      nextMsg.wParam,
                                                      nextMsg.lParam))
                        {
                            TRC_NRM((TB, _T("Message passed to main window")));
                            break;
                        }
                    }
                }
                else
                {
                    TRC_NRM((TB, _T("Found blocker message")));
                    break;
                }
            }

            /****************************************************************/
            /* Send the PDU                                                 */
            /****************************************************************/
            IHMaybeSendPDU();

            rc = TRUE;
        }
        break;

        case ACT_E:
        {
            /****************************************************************/
            /* Input / timer event with no focus - just discard this event. */
            /****************************************************************/
            TRC_ASSERT((data != 0), (TB, _T("No message")));
            TRC_DBG((TB, _T("Ignore event %x"), ((PMSG)data)->message));

            /****************************************************************/
            /* But send keepalives if required.                             */
            /****************************************************************/
            IHMaybeSendPDU();
        }
        break;

        case ACT_F:
        {
            /****************************************************************/
            /* A buffer available event has been received.  Try to send the */
            /* packet, and sync if required.                                */
            /****************************************************************/
            IHMaybeSendPDU();

            if (_IH.syncRequired)
            {
                TRC_NRM((TB, _T("Attempt to sync")));
                IHSync();
            }
        }
        break;

        case ACT_G:
        {
            TRC_DBG((TB, _T("Enabling")));

            //Init keyboard hooking settings
            switch( _pUi->_UI.keyboardHookMode)
            {
                case UTREG_UI_KEYBOARD_HOOK_ALWAYS:
                {
                    TRC_DBG((TB, _T("Set keyboard hook to ALWAYS ON")));
                    _fUseHookBypass = _fCanUseKeyboardHook;
                }
                break;
                case UTREG_UI_KEYBOARD_HOOK_FULLSCREEN:
                {
                    _fUseHookBypass = _pUi->UI_IsFullScreen() &&
                                      _fCanUseKeyboardHook;
                }
                break;
                case UTREG_UI_KEYBOARD_HOOK_NEVER: //FALLTHRU
                default:
                {
                    TRC_DBG((TB, _T("Set keyboard hook to ALWAYS OFF")));
                    _fUseHookBypass = FALSE;
                }
                break;
            }

            /****************************************************************/
            /* Get a buffer for the input PDU and initialize it.            */
            /****************************************************************/
            TRC_ASSERT((_IH.pInputPDU == NULL), (TB, _T("Non-NULL InputPDU")));

            if (!_pSl->SL_GetBuffer(IH_INPUTPDU_BUFSIZE,
                              (PPDCUINT8)&_IH.pInputPDU,
                              &_IH.bufHandle))
            {
                TRC_ALT((TB, _T("Failed to get an InputPDU buffer")));

                /************************************************************/
                /* Call the FSM to enter Pending Active state.  Exit the    */
                /* Pending Active state when a buffer is available.         */
                /************************************************************/
                IHFSMProc(IH_FSM_NOBUFFER, 0);
                break;
            }

            /****************************************************************/
            /* Initialize the InputPDU packet header                        */
            /****************************************************************/
            IHInitPacket();

            /****************************************************************/
            /* Synchronize                                                  */
            /****************************************************************/
            IHSync();

            /****************************************************************/
            /* Start the IH Timer                                           */
            /****************************************************************/
            _IH.timerID = SetTimer(_IH.inputCaptureWindow,
                                  IH_TIMER_ID,
                                  _IH.timerTickRate,
                                  NULL);

            /****************************************************************/
            /* We show the window last because we've seen this call end up  */
            /* processing an input message in ACT_D.  That's safe at this   */
            /* point because the input PDU is initialized now.              */
            /*                                                              */
            /* Note that on Windows CE this is the output window.           */
            /****************************************************************/
            _pUi->UI_GetDesktopSize(&desktopSize);
            SetWindowPos( _IH.inputCaptureWindow,
                          NULL,
                          0, 0,
                          desktopSize.width,
                          desktopSize.height,
                          SWP_SHOWWINDOW | SWP_NOZORDER | SWP_NOMOVE |
                          SWP_NOACTIVATE | SWP_NOOWNERZORDER );

        }
        break;

        case ACT_H:
        {
            TRC_DBG((TB, _T("Terminating")));

            /****************************************************************/
            /* Stop the timer if it is active                               */
            /****************************************************************/
            if (_IH.timerID != 0)
            {
                KillTimer(_IH.inputCaptureWindow, _IH.timerID);
                _IH.timerID = 0;
            }

            /****************************************************************/
            /* Ensure no cursor is selected in the window                   */
            /****************************************************************/
            IHSetCursorShape(NULL);

//#ifdef DESTROY_WINDOWS
            /****************************************************************/
            /* Destroy the Input Capture window.                            */
            /****************************************************************/
            TRC_ASSERT((_IH.inputCaptureWindow != NULL), (TB, _T("no window")));
            TRC_NRM((TB, _T("Destroy IH window")));
            DestroyWindow(_IH.inputCaptureWindow);
            TRC_NRM((TB, _T("Destroyed IH window")));

            /****************************************************************/
            /* Unregister the window class                                  */
            /****************************************************************/
            TRC_DBG((TB, _T("Unregister IH window class")));
            if (!UnregisterClass(IH_CLASS_NAME, _pUi->UI_GetInstanceHandle()))
            {
                //Failure to unregister could happen if another instance is still running
                //that's ok...unregistration will happen when the last instance exits.
                TRC_ERR((TB, _T("Failed to unregister IH window class")));
            }
//#endif
        }
        break;

        case ACT_I:
        {
            /****************************************************************/
            /* Release the mouse capture in case we have it.                */
            /****************************************************************/
            TRC_DBG((TB, _T("Losing focus: Release mouse capture")));
            ReleaseCapture();
        }
        break;

        case ACT_J:
        {
            /****************************************************************/
            /* Input event before IH has an InputPDU buffer.                */
            /****************************************************************/
            TRC_DBG((TB, _T("Discard Input Event - no InputPDU buffer")));
            IHDiscardMsg((PMSG)data);
        }
        break;

        case ACT_NO:
        {
            TRC_DBG((TB, _T("Nothing to do here.")));
        }
        break;

        default:
        {
            rc = FALSE;
            TRC_ABORT((TB, _T("Invalid Action!")));
        }
        break;
    }

DC_EXIT_POINT:
    DC_END_FN();

    return(rc);

} /* IHFSMProc */

/****************************************************************************/
/* Name:      IHMassageZeroScanCode (Named by TrevorFo)                     */
/*                                                                          */
/* Purpose:   Fix up or discard zero scan code input                        */
/*                                                                          */
/* Returns:   TRUE  - Scan code was zero and couldn't be fixed, discard     */
/*            FALSE - Scan code was not zero or fixable, process            */
/*                                                                          */
/* Params:    pMsg  - message from Windows                                  */
/****************************************************************************/
DCBOOL DCINTERNAL CIH::IHMassageZeroScanCode(PMSG pMsg)
{
    WORD lParamLo, lParamHi;
    WORD scancode, flags;

    DC_BEGIN_FN("CIH::IHMassageZeroScanCode");

    lParamLo = LOWORD(pMsg->lParam);
    lParamHi = HIWORD(pMsg->lParam);
    scancode = (WORD)(lParamHi & 0x00FF);
    flags    = (WORD)(lParamHi & 0xFF00);

    //
    // VK_Packets can have '0' 'scancodes' when the lowbyte
    // of the unicode character is 0.
    //
    if (VK_PACKET == pMsg->wParam) {
        return FALSE;
    }

    //
    // Self-injected sync keys have 0 scancode
    //
    if (VK_IGNORE_VALUE == pMsg->wParam) {
        return FALSE;
    }

    #ifndef OS_WINCE
    if  (scancode == 0) {
        switch (pMsg->wParam) {
        case VK_BROWSER_BACK:
        case VK_BROWSER_FORWARD:
        case VK_BROWSER_REFRESH:
        case VK_BROWSER_STOP:
        case VK_BROWSER_SEARCH:
        case VK_BROWSER_FAVORITES:
        case VK_BROWSER_HOME:
        case VK_VOLUME_MUTE:
        case VK_VOLUME_DOWN:
        case VK_VOLUME_UP:
        case VK_MEDIA_NEXT_TRACK:
        case VK_MEDIA_PREV_TRACK:
        case VK_MEDIA_STOP:
        case VK_MEDIA_PLAY_PAUSE:
        case VK_LAUNCH_MAIL:
        case VK_LAUNCH_MEDIA_SELECT:
        case VK_LAUNCH_APP1:
        case VK_LAUNCH_APP2:
            TRC_NRM((TB, _T("Fix up Speed Racer key")));
            scancode = (DCUINT16)MapVirtualKey(pMsg->wParam, 0);
        }
    }
    #endif

    // Fix up the lParam with the new scancode
    lParamHi = (WORD)(scancode | flags);
    pMsg->lParam = MAKELONG(lParamLo, lParamHi);

    DC_END_FN();
    return (scancode == 0) && !_IH.sendZeroScanCode;
}


/****************************************************************************/
/* Name:      IHStaticInputCaptureWndProc                                   */
/*                                                                          */
/* Purpose:   STATIC delegates to appropriate instance                      */
/*                                                                          */
/* Returns:   Windows return code                                           */
/*                                                                          */
/* Params:    IN      hwnd    - window handle                               */
/*            IN      message - message id                                  */
/*            IN      wParam  - parameter                                   */
/*            IN      lParam  - parameter                                   */
/****************************************************************************/
LRESULT CALLBACK CIH::IHStaticInputCaptureWndProc(HWND   hwnd,
                                       UINT   message,
                                       WPARAM wParam,
                                       LPARAM lParam)
{
    CIH* pIH = (CIH*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if(WM_CREATE == message)
    {
        //pull out the this pointer and stuff it in the window class
        LPCREATESTRUCT lpcs = (LPCREATESTRUCT) lParam;
        pIH = (CIH*)lpcs->lpCreateParams;

        SetWindowLongPtr( hwnd, GWLP_USERDATA, (LONG_PTR)pIH);
    }

    //
    // Delegate the message to the appropriate instance
    //
    if(pIH)
    {
        return pIH->IHInputCaptureWndProc(hwnd, message, wParam, lParam);
    }
    else
    {
        return DefWindowProc(hwnd, message, wParam, lParam);
    }
}

/****************************************************************************/
/* Name:      IHInputCaptureWndProc                                         */
/*                                                                          */
/* Purpose:   Input Handler window callback procedure                       */
/*                                                                          */
/* Returns:   Windows return code                                           */
/*                                                                          */
/* Params:    IN      hwnd    - window handle                               */
/*            IN      message - message id                                  */
/*            IN      wParam  - parameter                                   */
/*            IN      lParam  - parameter                                   */
/****************************************************************************/
LRESULT CALLBACK CIH::IHInputCaptureWndProc(HWND   hwnd,
                                       UINT   message,
                                       WPARAM wParam,
                                       LPARAM lParam)
{
    LRESULT   rc = 0;
    MSG       copyMsg;

    DC_BEGIN_FN("IHInputCaptureWndProc");

    TRC_ASSERT(((hwnd == _IH.inputCaptureWindow) ||
                (_IH.inputCaptureWindow == NULL)),
               (TB, _T("Wrong window handle %p"), hwnd));

    TRC_DBG((TB, _T("Message id %#x hwnd %p wParam %p lParam %p"),
                 message, hwnd, wParam, lParam));

#ifdef OS_WINCE
    if(!g_CEUseScanCodes && (0 != _IH.vkEatMe) && (wParam == _IH.vkEatMe))
    {
        /********************************************************************/
        /* This key has been marked for ignoring.  Do so now.               */
        /* On configs where g_CEUseScanCodes = 1, _IH.vkEatMe always = 0     */
        /********************************************************************/
        _IH.vkEatMe = 0;
        DC_QUIT;
    }
#endif // OS_WINCE

    if (IHPostMessageToMainWindow(message, wParam, lParam))
    {
        DC_QUIT;
    }


#ifdef PERF
    if ((message == WM_KEYUP) && (wParam == VK_CONTROL))
    {
        OUTPUT_COUNTERS;
        RESET_COUNTERS;
    }
#endif // PERF

    /************************************************************************/
    /* Pass input events and timer events to the FSM                        */
    /************************************************************************/
    if (IH_IS_INPUTEVENT(message) || (message == WM_TIMER))
    {

#ifdef DC_DEBUG
        if (IH_IS_INPUTEVENT(message)) {

            TRC_NRM((TB, _T("Pass input to FSM hwnd:%p msg:%#x wP:%p lp:%p"),
                     hwnd, message, wParam, lParam));

        }
#endif

        TRC_DBG((TB, _T("Pass input/timer to FSM")));
        copyMsg.hwnd    = hwnd;
        copyMsg.message = message;
        copyMsg.wParam  = wParam;
        copyMsg.lParam  = lParam;
        IHFSMProc(IH_FSM_INPUT, (ULONG_PTR)&copyMsg);
    }
    else
    {
        switch (message)
        {
            case WM_CREATE:
            {

#ifdef OS_WIN32
#ifndef OS_WINCE
                if (!AttachThreadInput(
                       GetCurrentThreadId(),
                       GetWindowThreadProcessId(_pUi->UI_GetUIContainerWindow(),
                                                NULL),
                       TRUE ))
                {
                    TRC_ALT((TB, _T("Failed AttachThreadInput")));
                }
#endif
                //
                // Set up some Thread Local Storage so we can have a low
                // level keyboard hook
                //

#ifdef OS_WINCE
                if (g_CEConfig == CE_CONFIG_WBT)
                {
                    _pUi->UI_SetEnableWindowsKey(TRUE);
                    break;
                }
#endif
                if (CIH::TlsIndex != 0xFFFFFFFF) {

                    if (TlsSetValue(CIH::TlsIndex, this)) {
                        TRC_NRM((TB, _T("Set TlsIndex with CIH 0x%p"), this));
                        //
                        // Install a low level keyboard hook to catch key sequences
                        // typically intercepted by the OS and allow us to pass them
                        // to the Terminal Server. Only install it for this thread
                        //

#if (!defined(OS_WINCE)) || (!defined(WINCE_SDKBUILD))
                        _hKeyboardHook = SetWindowsHookEx(WH_KEYBOARD_LL,
                                IHStaticLowLevelKeyboardProc, GetModuleHandle(NULL), 0);
#endif

                        if (_hKeyboardHook == NULL) {
                            TRC_SYSTEM_ERROR("Creating low level keyboard hook.");
                            _fUseHookBypass = FALSE;
                        }
                        else
                        {
                            _fCanUseKeyboardHook = TRUE;
                        }
                    } else {
                        TRC_SYSTEM_ERROR("Unable to TlsSetValue");
                        _fUseHookBypass = FALSE;
                    }
                } else {
                    TRC_ALT((TB, _T("Can't use hooks without Tls, disabling")));
                    _fUseHookBypass = FALSE;
                }

                //
                // Whether we say to send the Windows key is now determined
                // by whether we support hooking it.
                //

                _pUi->UI_SetEnableWindowsKey(_hKeyboardHook != NULL);

#endif
            }
            break;

            case WM_SETCURSOR:
            {
                SetCursor(_IH.hCurrentCursor);
                rc = DefWindowProc(hwnd, message, wParam, lParam);
            }
            break;

            case WM_DESTROY:
            {
                if (_hKeyboardHook != NULL) {
#if (!defined(OS_WINCE)) || (!defined(WINCE_SDKBUILD))
                    if (!UnhookWindowsHookEx(_hKeyboardHook)) {
                        TRC_SYSTEM_ERROR("UnhookWindowsHookEx");
                    }
#endif
                    _hKeyboardHook = NULL;
                }
            }
            break;

#ifdef OS_WINNT
            case IH_WM_HANDLE_LOCKDESKTOP:
            {
                TRC_NRM((TB,_T("Defered handling of IHHandleLocalLockDesktop")));
                IHHandleLocalLockDesktop();
            }
            break;
#endif  //OS_WINNT

            case WM_KILLFOCUS:
            {
                /************************************************************/
                /* Losing the focus.  No action - we won't get any more     */
                /* keystroke events.  The exception here is if we actually  */
                /* want to keep on passing messages through (e.g.  mouse)   */
                /* when we haven't got the focus.                           */
                /************************************************************/
                TRC_DBG((TB, _T("Kill focus")));
                if (!_IH.allowBackgroundInput)
                {
                    IHFSMProc(IH_FSM_FOCUS_LOSE, (ULONG_PTR) 0);
                }

                //
                // Losing focus -> Enable Cicero (keyboard/IME) toolbar 
                // NOTE: it is important to fire this notification regardless
                // of w/not allowBackground input is set
                //
                _pCd->CD_DecoupleSimpleNotification(CD_UI_COMPONENT,
                                        _pUi,
                                        CD_NOTIFICATION_FUNC(CUI,UI_OnInputFocusLost),
                                        0);
#ifdef OS_WINCE
                if (_hKeyboardHook != NULL) {
#if !defined(WINCE_SDKBUILD)
                    if (!UnhookWindowsHookEx(_hKeyboardHook)) {
                        TRC_SYSTEM_ERROR("UnhookWindowsHookEx");
                    }
#endif
                    _hKeyboardHook = NULL;
                    _fUseHookBypass = _fCanUseKeyboardHook = FALSE;
                    _pUi->UI_SetEnableWindowsKey(_fUseHookBypass);
                }
#endif
            }
            break;

            case WM_SETFOCUS:
            {
#ifdef OS_WINCE     //CE allows only one system wide hook. Install it when we get focus and uninstall it when we loose focus
                if (g_CEConfig != CE_CONFIG_WBT) { 
                    if ((CIH::TlsIndex != 0xFFFFFFFF) && (TlsSetValue(CIH::TlsIndex, this)) && (_hKeyboardHook == NULL)) {

#if !defined(WINCE_SDKBUILD)
                        _hKeyboardHook = SetWindowsHookEx(WH_KEYBOARD_LL,
                            IHStaticLowLevelKeyboardProc, GetModuleHandle(NULL), 0);
#endif

                        _fCanUseKeyboardHook =  (_hKeyboardHook != NULL);
                    }
                    _fUseHookBypass = (_pUi->_UI.keyboardHookMode != UTREG_UI_KEYBOARD_HOOK_NEVER) && (_fCanUseKeyboardHook);

                    _pUi->UI_SetEnableWindowsKey(_fUseHookBypass);
                }
#endif
                /************************************************************/
                /* Regaining the focus - need to resync                     */
                /************************************************************/
                TRC_DBG((TB, _T("Set focus")));
                IHFSMProc(IH_FSM_FOCUS_GAIN, (ULONG_PTR) 0);
            }
            break;

            case WM_PAINT:
            {
#ifndef OS_WINCE
                HDC         hdc;
                PAINTSTRUCT ps;
#endif // OS_WINCE

                TRC_NRM((TB, _T("WM_PAINT")));

#ifdef OS_WINCE
                /************************************************************/
                /* Handle drawing in OP.  This is a workaround for the      */
                /* WS_CLIPSIBLINGS problem.                                 */
                /************************************************************/
                _pCd->CD_DecoupleSyncNotification(CD_RCV_COMPONENT,
                                              _pOp,
                                              CD_NOTIFICATION_FUNC(COP,OP_DoPaint),
                                              (ULONG_PTR)hwnd);
#else
                /************************************************************/
                /* Don't do any painting - just validate the invalid region */
                /* by calling BeginPaint/EndPaint.                          */
                /************************************************************/
                hdc = BeginPaint(hwnd, &ps);
                EndPaint(hwnd, &ps);
#endif
            }
            break;

            case WM_SYSCHAR:
            case WM_CHAR:
            case WM_DEADCHAR:
            case WM_SYSDEADCHAR:
            case WM_SYSCOMMAND:
            {
                /************************************************************/
                /* Discard these messages                                   */
                /************************************************************/
                TRC_NRM((TB, _T("Ignore message %#x"), message));
            }
            break;

            default:
            {
                /************************************************************/
                /* Ignore all other messages.                               */
                /************************************************************/
                rc = DefWindowProc(hwnd, message, wParam, lParam);
            }
            break;
        }
    }

DC_EXIT_POINT:
    DC_END_FN();

    return(rc);

} /* IHInputCaptureWndProc */


/****************************************************************************/
/* Name:      IHAddEventToPDU                                               */
/*                                                                          */
/* Purpose:   Add an input event to the T.Share InputPDU packet             */
/*                                                                          */
/* Returns:   Success TRUE / FALSE                                          */
/*                                                                          */
/* Params:    IN      inputMsg - pointer to input event                     */
/*                                                                          */
/* Operation: No conversion to Ascii/Unicode: keystrokes are sent as        */
/*            virtual keys.                                                 */
/****************************************************************************/
DCBOOL DCINTERNAL CIH::IHAddEventToPDU(PMSG inputMsg)
{
    DCBOOL rc = FALSE;
    UINT   message = inputMsg->message;
    LPARAM lParam = inputMsg->lParam;
    WPARAM wParam = inputMsg->wParam;
    PTS_INPUT_EVENT pEvent;
    POINT  mouse;
    DCUINT16 scancode = 0;
#if !defined(OS_WINCE)
    WORD xButton = 0;
#endif

#ifdef OS_WINCE
    static BOOL fIgnoreMenuDown = FALSE;
    BOOL    addanother = FALSE;
    MSG     tmpmsg;    
#endif // OS_WINCE

#ifdef OS_WINCE
    BOOL    bAddMultiple = FALSE;
    UINT    cpt = 128;
    POINT   apt[128];
#endif // OS_WINCE

    DC_BEGIN_FN("IHAddEventToPDU");

    TRC_DBG((TB, _T("Event: %x (%x,%x)"), message, wParam, lParam));

    /************************************************************************/
    /* Don't try to add to the PDU if it's already full.                    */
    /************************************************************************/
    if (_IH.pInputPDU->numberEvents >= _IH.maxEventCount)
    {
        TRC_ALT((TB, _T("No room for new event")));
        DC_QUIT;
    }

    /************************************************************************/
    /* Translate event and add to the queue                                 */
    /************************************************************************/
    pEvent = &(_IH.pInputPDU->eventList[_IH.pInputPDU->numberEvents]);
    DC_MEMSET(pEvent, 0, sizeof(TS_INPUT_EVENT));

    switch (message)
    {
        case WM_KEYDOWN:
        case WM_SYSKEYDOWN:
        case WM_KEYUP:
        case WM_SYSKEYUP:
        {
#ifdef OS_WINCE
            /****************************************************************/
            /* Some input techrniques don't send scan-codes in the WM_*KEY* */
            /* messages they generate.  So we'll try to cover for them by   */
            /* adding a scan-code based on the virtual-key code contained   */
            /* within the wParam of such messages.                          */
            /****************************************************************/
            // Translate the virtual-key to a scan code if necessary
            if(!g_CEUseScanCodes)
            {
                lParam &= 0xFF00FFFF;
                lParam |= MAKELPARAM(0, VKeyToScanCode[wParam & 0xFF]);
            }
#endif // OS_WINCE
        
            /****************************************************************/
            /* Just send the VK.  Set 'priority events queued' flag.        */
            /****************************************************************/
            _IH.priorityEventsQueued = TRUE;

            TRC_NRM((TB, _T("vkey %#hx %s flags %#hx scan %#hx"),
                    (DCUINT16)wParam,
                    (message == WM_KEYUP) || (message == WM_SYSKEYUP) ?
                        _T("up") : _T("down"),
                    (DCUINT16)(HIWORD(lParam) & 0xFF00),
                    (DCUINT16)(HIWORD(lParam) & 0x00FF) ));
            if (wParam != VK_PACKET && _IH.useScancodes)
            {
                /************************************************************/
                /* Extract scancode from the LPARAM.                        */
                /************************************************************/
                scancode = (DCUINT16)(HIWORD(lParam) & 0x00FF);

                TRC_DBG((TB, _T("aetp vk: 0x%04x sc: 0x%04x A/E/U: %d%d%d"), wParam,
                        scancode, (HIWORD(lParam) & KF_ALTDOWN) != 0,
                        (HIWORD(lParam) & KF_EXTENDED) != 0,
                        (HIWORD(lParam) & KF_UP) != 0));

                pEvent->messageType = TS_INPUT_EVENT_SCANCODE;
                pEvent->u.key.keyCode = scancode;
                TRC_DBG((TB, _T("Send scancode %#hx"), scancode));
            }
            else if (VK_PACKET == wParam)
            {
                if (_IH.fUseVKPacket)
                {
                    //
                    // Injected unicode character is contained in the scancode
                    //
                    scancode = (DCUINT16)(HIWORD(lParam) & 0xFFFF);

                    TRC_DBG((TB, _T("aetp vk: 0x%04x sc: 0x04x A/E/U: %d%d%d"),
                             wParam,
                             scancode, (HIWORD(lParam) & KF_ALTDOWN) != 0,
                             (HIWORD(lParam) & KF_EXTENDED) != 0,
                             (HIWORD(lParam) & KF_UP) != 0));

                    pEvent->messageType = TS_INPUT_EVENT_VKPACKET;
                    pEvent->u.key.keyCode = scancode;  //really a unicode character
                    TRC_DBG((TB, _T("Send unicode character (in scancode) %#hx"),
                             scancode));
                }
                else
                {
                    // VK_PACKET not supported, must discard it
                    TRC_DBG((TB,_T("Discarding VK_PACKET")));
                    DC_QUIT;
                }
            }
            else
            {
                pEvent->messageType = TS_INPUT_EVENT_VIRTUALKEY;
                pEvent->u.key.keyCode = (DCUINT16)wParam;
                TRC_DBG((TB, _T("Send VK %#hx"), (DCUINT16)wParam ));
            }

            /****************************************************************/
            /* Check if key was down or up before this event.               */
            /****************************************************************/
            if (HIWORD(lParam) & KF_REPEAT)
            {
                TRC_DBG((TB, _T("Key was down")));
                pEvent->u.key.keyboardFlags = TS_KBDFLAGS_DOWN;
            }


            /****************************************************************/
            /* Set 'release' flag for key up.                               */
            /****************************************************************/
            if ((message == WM_KEYUP) || (message == WM_SYSKEYUP))
            {
                TRC_DBG((TB, _T("Key up message")));
                pEvent->u.key.keyboardFlags |= TS_KBDFLAGS_RELEASE;

#ifdef OS_WINCE
                /****************************************************************/
                /* fIgnoreMuneDown = FALSE always if g_CEUseScanCodes = 1       */
                /****************************************************************/
                if (fIgnoreMenuDown && wParam == VK_MENU)
                {
                    fIgnoreMenuDown = FALSE;
                    DC_QUIT;
                }
#endif // OS_WINCE                
            }

            /****************************************************************/
            /* Set the 'extended' flag                                      */
            /****************************************************************/
            if (HIWORD(lParam) & KF_EXTENDED)
            {
                TRC_DBG((TB, _T("Extended flag set")));
                pEvent->u.key.keyboardFlags |= TS_KBDFLAGS_EXTENDED;
            }

            /****************************************************************/
            /* Set the 'extended1' flag                                     */
            /****************************************************************/
            if (HIWORD(lParam) & IH_KF_EXTENDED1)
            {
                TRC_DBG((TB, _T("Extended1 flag set")));
                pEvent->u.key.keyboardFlags |= TS_KBDFLAGS_EXTENDED1;
            }
#ifdef OS_WINCE
            if (!g_CEUseScanCodes && 
                ((message == WM_KEYDOWN) || (message == WM_SYSKEYDOWN)))
            {
                if ( !((wParam == VK_SHIFT) && _IH.useScancodes) && 
                         fIgnoreMenuDown && wParam == VK_MENU && 
                         (HIWORD(lParam) & KF_REPEAT))
                {
                    // Bail out now if we are ignoring this key.
                    DC_QUIT;
                }
            }
#endif // OS_WINCE             

        }
        break;

        case WM_MOUSEMOVE:
        {
            TRC_DBG((TB, _T("Mousemove")));
            pEvent->messageType = TS_INPUT_EVENT_MOUSE;
            pEvent->u.mouse.pointerFlags = TS_FLAG_MOUSE_MOVE;
#ifdef OS_WINCE
            /****************************************************************/
            /* if this feature is enabled && the mouse button is down,      */
            /* then the user is drawing/writing -- grab all mousemove data  */
            /****************************************************************/
            if( (_IH.bLMouseButtonDown) && (_IH.maxMouseMove))
            {
                if (!GetMouseMovePoints(apt, cpt, &cpt))
                {
                    TRC_DBG((TB, _T("GetMouseMovePoints() failed")));

                }
                else
                {
                    /****************************************************************/
                    /* If we only have single point, don't use addmultiple, just    */
                    /* fall through, otherwise call the multi-event handler         */
                    /****************************************************************/
                    if(cpt > 1)
                    {   
                        bAddMultiple = IHAddMultipleEventsToPDU(apt, cpt);
                    }
                }
                /****************************************************************/
                /* If API fails, or IHAddMultipleEventsToPDU fails, fall through*/
                /* to process the original mouse move event that got us in here */
                /****************************************************************/
                if(bAddMultiple)
                    break;
            }
#endif  // OS_WINCE
            /****************************************************************/
            /* Clip the mouse co-ordinates to the client area.              */
            /* Take care with sign extension here.                          */
            /****************************************************************/
            mouse.x = (DCINT)((DCINT16)LOWORD(lParam));
            mouse.y = (DCINT)((DCINT16)HIWORD(lParam));

            if (mouse.x < _IH.visibleArea.left)
            {
                mouse.x = _IH.visibleArea.left;
            }
            else if (mouse.x > _IH.visibleArea.right)
            {
                mouse.x = _IH.visibleArea.right;
            }

            if (mouse.y < _IH.visibleArea.top)
            {
                mouse.y = _IH.visibleArea.top;
            }
            else if (mouse.y > _IH.visibleArea.bottom)
            {
                mouse.y = _IH.visibleArea.bottom;
            }

            /****************************************************************/
            /* Check for repeated WM_MOUSEMOVE with the same position -     */
            /* seen on NT4.0 under certain (unknown) conditions.            */
            /****************************************************************/
            if ((mouse.x == _IH.lastMousePos.x) &&
                (mouse.y == _IH.lastMousePos.y))
            {
                TRC_NRM((TB, _T("MouseMove to the same position - ignore!")));
                DC_QUIT;
            }
            _IH.lastMousePos = mouse;

#ifdef SMART_SIZING
            if (_pUi->UI_GetSmartSizing()) {
                DCSIZE desktopSize;

                _pUi->UI_GetDesktopSize(&desktopSize);

                if (_scaleSize.width != 0 && _scaleSize.height != 0) {
                    pEvent->u.mouse.x = (DCINT16)(mouse.x * desktopSize.width / _scaleSize.width);
                    pEvent->u.mouse.y = (DCINT16)(mouse.y * desktopSize.height / _scaleSize.height);
                } else {
                    pEvent->u.mouse.x = 0;
                    pEvent->u.mouse.y = 0;
                }
            } else {
#endif // SMART_SIZING
                pEvent->u.mouse.x = (DCINT16)mouse.x;
                pEvent->u.mouse.y = (DCINT16)mouse.y;
#ifdef SMART_SIZING
            }
#endif // SMART_SIZING
        }
        break;

        case WM_MOUSEWHEEL:
        {
            TRC_DBG((TB, _T("Mousewheel")));
            pEvent->messageType = TS_INPUT_EVENT_MOUSE;

            /****************************************************************/
            /* Magellan Mouse - the high word of the wParam field           */
            /* represents the number of clicks the wheel has just turned.   */
            /****************************************************************/
            pEvent->u.mouse.pointerFlags = TS_FLAG_MOUSE_WHEEL;

            /****************************************************************/
            /* Check for overflows.  If the wheel delta is outside the      */
            /* values that can be sent by the protocol, send the maximum    */
            /* values.                                                      */
            /****************************************************************/
            if ((DCINT16)HIWORD(wParam) >
                     (TS_FLAG_MOUSE_ROTATION_MASK - TS_FLAG_MOUSE_DIRECTION))
            {
                TRC_ERR((TB, _T("Mouse wheel overflow %hd"), HIWORD(wParam)));
                pEvent->u.mouse.pointerFlags |=
                      (TS_FLAG_MOUSE_ROTATION_MASK - TS_FLAG_MOUSE_DIRECTION);
            }
            else if ((DCINT16)HIWORD(wParam) < -TS_FLAG_MOUSE_DIRECTION)
            {
                TRC_ERR((TB, _T("Mouse wheel underflow %hd"), HIWORD(wParam)));
                pEvent->u.mouse.pointerFlags |= TS_FLAG_MOUSE_DIRECTION;
            }
            else
            {
                pEvent->u.mouse.pointerFlags |=
                             (HIWORD(wParam) & TS_FLAG_MOUSE_ROTATION_MASK);
            }

            /****************************************************************/
            /* Also send the middle mouse button status.                    */
            /****************************************************************/
            if ((LOWORD(wParam) & MK_MBUTTON) != 0)
            {
                pEvent->u.mouse.pointerFlags |= TS_FLAG_MOUSE_DOWN;
            }
        }
        break;

        case WM_LBUTTONDOWN:
        case WM_LBUTTONUP:
        case WM_RBUTTONDOWN:
        case WM_RBUTTONUP:
        case WM_MBUTTONDOWN:
        case WM_MBUTTONUP:
#if !defined(OS_WINCE)
        case WM_XBUTTONDOWN:
        case WM_XBUTTONUP:
#endif
        {
            /****************************************************************/
            /* Set 'priority event queued' flag.                            */
            /****************************************************************/
            TRC_DBG((TB, _T("Buttonclick")));
            _IH.priorityEventsQueued = TRUE;

            pEvent->messageType = TS_INPUT_EVENT_MOUSE;

            /****************************************************************/
            /* Clip the mouse co-ordinates to the client area.              */
            /* Take care with sign extension here.                          */
            /****************************************************************/
            mouse.x = (DCINT)((DCINT16)LOWORD(lParam));
            mouse.y = (DCINT)((DCINT16)HIWORD(lParam));

            if (mouse.x < _IH.visibleArea.left)
            {
                mouse.x = _IH.visibleArea.left;
            }
            else if (mouse.x > _IH.visibleArea.right)
            {
                mouse.x = _IH.visibleArea.right;
            }

            if (mouse.y < _IH.visibleArea.top)
            {
                mouse.y = _IH.visibleArea.top;
            }
            else if (mouse.y > _IH.visibleArea.bottom)
            {
                mouse.y = _IH.visibleArea.bottom;
            }

            /****************************************************************/
            /* Save the last sent mouse position                            */
            /****************************************************************/
            _IH.lastMousePos = mouse;

#ifdef SMART_SIZING
            if (_pUi->UI_GetSmartSizing()) {
                DCSIZE desktopSize;
                _pUi->UI_GetDesktopSize(&desktopSize);

                if (_scaleSize.width != 0 && _scaleSize.height != 0) {
                    pEvent->u.mouse.x = (DCINT16)(mouse.x * desktopSize.width / _scaleSize.width);
                    pEvent->u.mouse.y = (DCINT16)(mouse.y * desktopSize.height / _scaleSize.height);
                } else {
                    pEvent->u.mouse.x = 0;
                    pEvent->u.mouse.y = 0;
                }
            } else {
#endif // SMART_SIZING
                pEvent->u.mouse.x = (DCINT16)mouse.x;
                pEvent->u.mouse.y = (DCINT16)mouse.y;
#ifdef SMART_SIZING
            }
#endif // SMART_SIZING

#ifdef OS_WINCE
            if (!g_CEUseScanCodes)
            {
                // Special handling for touch screens to simulate right mouse clicks
                // when the Alt key is held down.  This is semi-bogus because the Alt
                // key down and key up are stil sent to the terminal server.
                if ((message == WM_LBUTTONDOWN ||
                     message == WM_LBUTTONUP ||
                     message == WM_LBUTTONDBLCLK) &&
                    (GetKeyState(VK_MENU) & 0x8000))
                {
                    // Change the message to a RBUTTON
                    message += 3;

                    // Inject an an Alt-Up or the menu won't stay up.
                    tmpmsg = *inputMsg;
                    tmpmsg.message = WM_SYSKEYUP;
                    tmpmsg.wParam = VK_MENU;
                    tmpmsg.lParam = MAKELONG(0, MapVirtualKey(VK_MENU, 0));
                    addanother = TRUE;
                }
            }
#endif // OS_WINCE

            switch (message)
            {
                case WM_LBUTTONDOWN:
                {
                    pEvent->u.mouse.pointerFlags =
                          (TSUINT16)(_IH.leftButton | TS_FLAG_MOUSE_DOWN);

#ifdef OS_WINCE
                    /****************************************************************/
                    /* if this feature is enabled && the mouse button was down,     */
                    /* go see if any points are available and add them to the queue */
                    /****************************************************************/
                    if( (_IH.bLMouseButtonDown) && (_IH.maxMouseMove))
                    {
                        /************************************************************************/
                        /* No matter what, we will always skip adding the event at the          */
                        /* end of the loop cause we're adding it next                           */
                        /************************************************************************/
                        bAddMultiple = TRUE;

                        /************************************************************************/
                        /* Finish adding the WM_LBUTTONDOWN event to the pdu                    */
                        /************************************************************************/
                        pEvent->eventTime = _pUt->UT_GetCurrentTimeMS();
                        _IH.pInputPDU->numberEvents++;
                        TS_DATAPKT_LEN(_IH.pInputPDU) += sizeof(TS_INPUT_EVENT);
                        TS_UNCOMP_LEN(_IH.pInputPDU) += sizeof(TS_INPUT_EVENT);

                        if (!GetMouseMovePoints(apt, cpt, &cpt))
                        {
                            TRC_DBG((TB, _T("GetMouseMovePoints() failed")));
                        }
                        else
                        {
                            /****************************************************************/
                            /* If we only have single point, don't use addmultiple, just    */
                            /* fall through, otherwise call the multi-event handler         */
                            /****************************************************************/
                            if(cpt > 1)
                            {
                                IHAddMultipleEventsToPDU(apt, cpt);
                            }
                        }
                    }
#endif  // OS_WINCE
                }
                break;

                case WM_LBUTTONUP:
                {
                    pEvent->u.mouse.pointerFlags = _IH.leftButton;
                }
                break;

                case WM_RBUTTONDOWN:
                {
                    pEvent->u.mouse.pointerFlags =
                          (TSUINT16)(_IH.rightButton | TS_FLAG_MOUSE_DOWN);
                }
                break;

                case WM_RBUTTONUP:
                {
                    pEvent->u.mouse.pointerFlags = _IH.rightButton;
                }
                break;

                case WM_MBUTTONDOWN:
                {
                    pEvent->u.mouse.pointerFlags = TS_FLAG_MOUSE_BUTTON3 |
                                                TS_FLAG_MOUSE_DOWN;
                }
                break;

                case WM_MBUTTONUP:
                {
                    pEvent->u.mouse.pointerFlags = TS_FLAG_MOUSE_BUTTON3;
                }
                break;

#if !defined(OS_WINCE)
                case WM_XBUTTONDOWN:
                    pEvent->u.mouse.pointerFlags = TS_FLAG_MOUSEX_DOWN;
                    /********************************************************/
                    /* Note that we drop through here                       */
                    /********************************************************/

                case WM_XBUTTONUP:
                {
                    /********************************************************/
                    /* For button-down, we've initialized pointerFlags in   */
                    /* the case clause above.  For button-up, pointerFlags  */
                    /* was initialized to zero by the memset at the top of  */
                    /* this function.                                       */
                    /********************************************************/
                    if (!_IH.useXButtons)
                    {
                        TRC_NRM((TB, _T("Can't send this extended buttonclick")));
                        DC_QUIT;
                    }
                    TRC_DBG((TB, _T("Sending extended buttonclick")));
                    pEvent->messageType = TS_INPUT_EVENT_MOUSEX;
                    xButton = GET_XBUTTON_WPARAM(wParam);
                    switch (xButton)
                    {
                        case XBUTTON1:
                        {
                            pEvent->u.mouse.pointerFlags |=
                                                       TS_FLAG_MOUSEX_BUTTON1;
                        }
                        break;

                        case XBUTTON2:
                        {
                            pEvent->u.mouse.pointerFlags |=
                                                       TS_FLAG_MOUSEX_BUTTON2;
                        }
                        break;

                        default:
                        {
                            TRC_ALT((TB, _T("Unknown XButton %#hx"), xButton));
                            DC_QUIT;
                        }
                        break;
                    }
                }
                break;
#endif
            }
        }
        break;

        default:
        {
            /****************************************************************/
            /* Invalid event                                                */
            /****************************************************************/
            TRC_ALT((TB, _T("Unknown input event %#x"), message));
            DC_QUIT;
        }
        break;
    }
#ifdef OS_WINCE
    /************************************************************************/
    /* bAddMultiple = 1 only when IHAddMultipleEventsToPDU() is called and  */
    /* return true OR pEvent data is already added to the pdu               */
    /************************************************************************/
    if(!bAddMultiple)    
    {
#endif

    pEvent->eventTime = _pUt->UT_GetCurrentTimeMS();

    /************************************************************************/
    /* Bump up the packet size.                                             */
    /************************************************************************/
    _IH.pInputPDU->numberEvents++;
    TS_DATAPKT_LEN(_IH.pInputPDU) += sizeof(TS_INPUT_EVENT);
    TS_UNCOMP_LEN(_IH.pInputPDU) += sizeof(TS_INPUT_EVENT);

#ifdef OS_WINCE
    }
#endif    

#ifdef OS_WINCE
    /************************************************************************/
    /* addanother = 1 only when g_CEUseScanCodes = 0.  Needed to workaround */
    /* a touch screen problem.                                              */
    /************************************************************************/
    if (addanother)
    {
        TRC_DBG((TB, _T("Add second message")));
        IHAddEventToPDU(&tmpmsg);
        
        // If we're injecting the VK_MENU up, start ignoring the down keys.
        if (tmpmsg.message == WM_SYSKEYUP && tmpmsg.wParam == VK_MENU)
        {
            fIgnoreMenuDown = TRUE;
        }
    }
#endif    


DC_EXIT_POINT:
    DC_END_FN();
    return(rc);
} /* IHAddEventToPDU */

#ifdef OS_WINCE
/****************************************************************************/
/* Name:      IHAddMultipleEventsToPDU                                      */
/*                                                                          */
/* Purpose:   Add multiple mouse move events to the T.Share InputPDU packet */
/*                                                                          */
/* Returns:   Success TRUE / FALSE                                          */
/*                                                                          */
/* Params:    IN      *ppt - pointer to an array of points to send          */
/*                     cpu - number of points to add                        */
/*                                                                          */
/* Operation:                                                               */
/*                                                                          */
/****************************************************************************/
DCBOOL DCINTERNAL CIH::IHAddMultipleEventsToPDU(POINT *ppt, int cpt)
{
    PTS_INPUT_EVENT pEvent;
    POINT           mouse;
    POINT           *pptEnd, *pptTo;
    DCBOOL          bRet;

    DC_BEGIN_FN("IHAddMultipleEventsToPDU");

    bRet = TRUE;

    if(cpt > 0)
    {
        /************************************************************************/
        /* If the number of events don't fit, just abort for now                */
        /************************************************************************/
        if( cpt > (int)(_IH.maxEventCount - _IH.pInputPDU->numberEvents))
        {
            /************************************************************************/
            /* Send what we have and get a new buffer                               */
            /************************************************************************/
            IHMaybeSendPDU();

            /************************************************************************/
            /* if we have more than a full PDU Buffer, hmmm                         */
            /************************************************************************/
            if( cpt > (int)(_IH.maxEventCount))
            {
                /************************************************************************/
                /* This will rarely, if ever, happen.  When it does. clip the points to */
                /* the maximum size of an empty PDU Buffer                              */
                /************************************************************************/
                cpt = (int)(_IH.maxEventCount);
            }
        }

        pptEnd = ppt + cpt;

        for (pptTo = ppt; ppt < pptEnd; ppt++)
        {
            mouse = *ppt;       

            mouse.x >>= 2;
            mouse.y >>= 2;

            /****************************************************************/
            /* Clip the mouse co-ordinates to the client area.              */
            /* Take care with sign extension here.                          */
            /****************************************************************/
            if (mouse.x < _IH.visibleArea.left)
            {
                mouse.x = _IH.visibleArea.left;
            }
            else if (mouse.x > _IH.visibleArea.right)
            {
                mouse.x = _IH.visibleArea.right;
            }

            if (mouse.y < _IH.visibleArea.top)
            {
                mouse.y = _IH.visibleArea.top;
            }
            else if (mouse.y > _IH.visibleArea.bottom)
            {
                mouse.y = _IH.visibleArea.bottom;
            }
            /****************************************************************/
            /* Check for repeated WM_MOUSEMOVE with the same position.      */
            /****************************************************************/
            if ((mouse.x == _IH.lastMousePos.x) &&
                (mouse.y == _IH.lastMousePos.y))
            {
                TRC_DBG((TB, _T("Add Multiple MouseMove to the same position - ignore!")));
            }
            else
            {
                _IH.lastMousePos = mouse;

                /************************************************************************/
                /* Get pointer into PDU to hold this event                              */
                /************************************************************************/
                pEvent = &(_IH.pInputPDU->eventList[_IH.pInputPDU->numberEvents]);
                DC_MEMSET(pEvent, 0, sizeof(TS_INPUT_EVENT));

                /************************************************************************/
                /* Store the event and time                                             */
                /************************************************************************/
                pEvent->u.mouse.x = (DCINT16)mouse.x;
                pEvent->u.mouse.y = (DCINT16)mouse.y;
                pEvent->eventTime = _pUt->UT_GetCurrentTimeMS();
                pEvent->messageType = TS_INPUT_EVENT_MOUSE;
                pEvent->u.mouse.pointerFlags = TS_FLAG_MOUSE_MOVE;

                /************************************************************************/
                /* Bump up the packet size.                                             */
                /************************************************************************/
                _IH.pInputPDU->numberEvents++;
                TS_DATAPKT_LEN(_IH.pInputPDU) += sizeof(TS_INPUT_EVENT);
                TS_UNCOMP_LEN(_IH.pInputPDU) += sizeof(TS_INPUT_EVENT);
            }

        }   /* end for */
    }

    DC_END_FN();
    return bRet;

} /* IHAddMultipleEventsToPDU */
#endif //OS_WINCE

/****************************************************************************/
/* Name:      IHMaybeSendPDU                                                */
/*                                                                          */
/* Purpose:   Send the InputPDU packet if criteria matched                  */
/*                                                                          */
/* Operation: Send PDU if any of the following is true:                     */
/*            - packet is full OR                                           */
/*            - priority events (button / key /sync) are queued             */
/*            - the minimum send interval has elapsed                       */
/****************************************************************************/
DCVOID DCINTERNAL CIH::IHMaybeSendPDU(DCVOID)
{
    DCUINT32  delta;
    DCUINT32  timeNow;
    PDCUINT8  pNewPacket;
    SL_BUFHND newHandle;
    POINT     mousePos;
    MSG       msg;

    DC_BEGIN_FN("IHMaybeSendPDU");

    timeNow = _pUt->UT_GetCurrentTimeMS();
    delta = timeNow - _IH.lastInputPDUSendTime;
    TRC_DBG((TB, _T("time delta %d"), delta));

#ifdef OS_WIN32
    /************************************************************************/
    /* If we're pending a button-down, we have to wait until                */
    /* IH_PENDMOUSE_DELAY has elapsed before sending.  However, we override */
    /* this and send the packet if it is full (we don't want to throw       */
    /* events away).                                                        */
    /************************************************************************/
    if ((_pUi->UI_GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_95) &&
        _IH.pendMouseDown)
    {
        if (((timeNow - _IH.mouseDownTime) < IH_PENDMOUSE_DELAY) &&
            (_IH.pInputPDU->numberEvents < _IH.maxEventCount))
        {
            TRC_DBG((TB, _T("Not sending input - pendMouseDown is set")));
            DC_QUIT;
        }
        else
        {
            TRC_DBG((TB, _T("Clearing pendMouseDown")));
            _IH.pendMouseDown = FALSE;
            if (_IH.pendMouseTimer != 0)
            {
                KillTimer(_IH.inputCaptureWindow, _IH.pendMouseTimer);
            }
        }
    }
#endif

    /************************************************************************/
    /* See if we need to send a keep-alive.                                 */
    /************************************************************************/
    if ((_IH.keepAliveInterval != 0) && !_IH.priorityEventsQueued &&
        (delta > _IH.keepAliveInterval))
    {
        TRC_NRM((TB, _T("Keep-alive required")));

        /********************************************************************/
        /* Send a move move to the current mouse co-ordinate.               */
        /********************************************************************/
        GetCursorPos(&mousePos);

#ifdef OS_WIN32
        if (!ScreenToClient(_IH.inputCaptureWindow, &mousePos))
        {
            TRC_ERR((TB, _T("Cannot convert mouse coordinates!")));
        }
#else
        ScreenToClient(_IH.inputCaptureWindow, &mousePos);
#endif /* OS_WIN32 */

        /********************************************************************/
        /* Prevent the 'same as last time' mouse position check from        */
        /* kicking in.                                                      */
        /********************************************************************/
        _IH.lastMousePos.x = mousePos.x + 1;

        msg.message = WM_MOUSEMOVE;
        msg.lParam = MAKELONG(mousePos.x, mousePos.y);
        IHAddEventToPDU(&msg);

        /********************************************************************/
        /* Set the priority flag to force the send - also set the last send */
        /* time, as if the send fails we don't want to keep adding more     */
        /* keepalive messages to the buffer.                                */
        /********************************************************************/
        _IH.priorityEventsQueued = TRUE;
        _IH.lastInputPDUSendTime = timeNow;
    }
    else if (_IH.pInputPDU->numberEvents == 0)
    {
        TRC_DBG((TB, _T("Nothing to send")));
        DC_QUIT;
    }

    /************************************************************************/
    /* Try to send if the buffer is full, or any priority events are        */
    /* queued, or a minimum time has elapsed.                               */
    /************************************************************************/
    if ((_IH.pInputPDU->numberEvents >= _IH.maxEventCount) ||
        (_IH.priorityEventsQueued) ||
        (delta > _IH.minSendInterval))
    {
        /********************************************************************/
        /* Only try to send if we can get another packet                    */
        /********************************************************************/
        if (_pSl->SL_GetBuffer(IH_INPUTPDU_BUFSIZE, &pNewPacket, &newHandle))
        {
            TRC_DBG((TB, _T("Got new buffer - send old one")));

            //Flag that input was sent, for the Idle notification
            //event. See UI_SetMinsToIdleTimeout()
            IH_SetInputWasSentFlag(TRUE);

            if (_IH.bUseFastPathInput) {
                unsigned PktSize, NumEvents;

                PktSize = IHTranslateInputToFastPath(&NumEvents);
                _pSl->SL_SendFastPathInputPacket((BYTE FAR *)_IH.pInputPDU,
                        PktSize, NumEvents, _IH.bufHandle);
            }
            else {
                _pSl->SL_SendPacket((PDCUINT8)_IH.pInputPDU,
                        TS_DATAPKT_LEN(_IH.pInputPDU),
                        RNS_SEC_ENCRYPT,
                        _IH.bufHandle,
                        _pUi->UI_GetClientMCSID(),
                        _pUi->UI_GetChannelID(),
                        TS_HIGHPRIORITY);
            }

            TRC_NRM((TB, _T("Sending %h messages"), _IH.pInputPDU->numberEvents));

            /****************************************************************/
            /* Now set the new packet up.                                   */
            /****************************************************************/
            _IH.pInputPDU = (PTS_INPUT_PDU)pNewPacket;
            _IH.bufHandle = newHandle;
            IHInitPacket();
            _IH.lastInputPDUSendTime = timeNow;
            _IH.priorityEventsQueued = FALSE;
        }
        else
        {
            /****************************************************************/
            /* Keep this buffer - can't get a new one.                      */
            /****************************************************************/
            TRC_ALT((TB, _T("Cannot get buffer - no Send")));
        }
    }
    else
    {
        TRC_NRM((TB, _T("Don't try to send")));
    }

DC_EXIT_POINT:
    DC_END_FN();
} /* IHMaybeSendPDU */


/****************************************************************************/
// IHTranslateInputToFastPath
//
// Treats an InputPDU as an intermediate format and in-place translates to
// the fast-path packet format. Returns the size in bytes of the resulting
// packet and, through pNumEvents, the number of events to encode in the
// header byte (see notes on packet format in at128.h).
// TODO: Change IH to encode faster to this format if it's in use, and
//   shorten path lengths for input to reduce latency.
/****************************************************************************/
unsigned DCINTERNAL CIH::IHTranslateInputToFastPath(unsigned *pNumEvents)
{
    unsigned i, NumEvents;
    unsigned PktLen;
    BYTE FAR *pCurEncode;

    DC_BEGIN_FN("IHTranslateInputToFastPath");

    pCurEncode = (BYTE FAR *)_IH.pInputPDU;
    PktLen = 0;

    // To encode in-place over the current contents of the InputPDU, we need
    // to pull needed info from the header which will be the first
    // overwritten.
    NumEvents = _IH.pInputPDU->numberEvents;
    TRC_ASSERT((NumEvents < 256),(TB,_T("Too many input events for byte size")));

    // First, if we have only 4 bits' worth for the number of events, we get
    // to encode the number of events into TS_INPUT_FASTPATH_NUMEVENTS_MASK
    // in the first byte, saving a byte very often. Otherwise, we need to
    // encode 0 in those bits, and create a NumEvents byte as the only input
    // header byte.
    if (NumEvents < 16) {
        *pNumEvents = NumEvents;
    }
    else {
        *pCurEncode++ = (BYTE)NumEvents;
        PktLen++;
        *pNumEvents = 0;
    }

    // Next, re-encode each event into its bytestream format (see at128.h).
    for (i = 0; i < NumEvents; i++) {
        switch (_IH.pInputPDU->eventList[i].messageType) {
            case TS_INPUT_EVENT_SCANCODE:
                // Use a mask, shift, and OR to avoid branches for the
                // extended flags.
                *pCurEncode = (BYTE)(TS_INPUT_FASTPATH_EVENT_KEYBOARD |
                        ((_IH.pInputPDU->eventList[i].u.key.keyboardFlags &
                        (TS_KBDFLAGS_EXTENDED | TS_KBDFLAGS_EXTENDED1)) >> 7));
                if (_IH.pInputPDU->eventList[i].u.key.keyboardFlags &
                        TS_KBDFLAGS_RELEASE)
                    *pCurEncode |= TS_INPUT_FASTPATH_KBD_RELEASE;

                pCurEncode++;
                *pCurEncode++ = (BYTE)_IH.pInputPDU->eventList[i].u.key.keyCode;
                PktLen += 2;
                break;

            case TS_INPUT_EVENT_VKPACKET:
                // Use a mask, shift, and OR to avoid branches for the
                // extended flags.
                *pCurEncode = (BYTE)(TS_INPUT_FASTPATH_EVENT_VKPACKET |
